-- MySQL dump 10.11
--
-- Host: localhost    Database: infoarena_dev
-- ------------------------------------------------------
-- Server version	5.0.32-Debian_3-log

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `ia_file`
--

DROP TABLE IF EXISTS `ia_file`;
CREATE TABLE `ia_file` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `name` varchar(64) collate latin1_general_ci default NULL,
  `page` varchar(64) collate latin1_general_ci default NULL,
  `size` int(10) unsigned NOT NULL,
  `timestamp` datetime NOT NULL,
  `user_id` int(10) unsigned NOT NULL,
  `mime_type` varchar(64) collate latin1_general_ci default NULL,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `name_page_index` (`name`,`page`)
) ENGINE=MyISAM AUTO_INCREMENT=22569 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_file`
--

LOCK TABLES `ia_file` WRITE;
/*!40000 ALTER TABLE `ia_file` DISABLE KEYS */;
INSERT INTO `ia_file` VALUES (22044,'noimage','template/infoarena',2104,'2006-11-27 02:35:20',13,'image/png');
/*!40000 ALTER TABLE `ia_file` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_job`
--

DROP TABLE IF EXISTS `ia_job`;
CREATE TABLE `ia_job` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `task_id` varchar(64) collate latin1_general_ci default NULL,
  `user_id` int(11) default NULL,
  `compiler_id` varchar(8) collate latin1_general_ci default NULL,
  `file_contents` longblob NOT NULL,
  `status` enum('waiting','done','processing') collate latin1_general_ci NOT NULL default 'waiting',
  `submit_time` datetime NOT NULL,
  `eval_log` mediumtext collate latin1_general_ci,
  `score` int(11) default NULL,
  `eval_message` varchar(256) collate latin1_general_ci default NULL,
  PRIMARY KEY  (`id`),
  KEY `status` (`status`),
  KEY `user_id` (`user_id`),
  KEY `submit_time` (`submit_time`),
  KEY `task_id` (`task_id`)
) ENGINE=MyISAM AUTO_INCREMENT=10450 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_job`
--

LOCK TABLES `ia_job` WRITE;
/*!40000 ALTER TABLE `ia_job` DISABLE KEYS */;
INSERT INTO `ia_job` VALUES (2,'algola',1,'c','--gone--','done','2006-11-06 00:07:22','Compilare:\n\n\nRulez testul 1: eroare: timp 0ms: mem 116kb: Killed by signal 8(SIGFPE).: 0 puncte\nRulez testul 2: eroare: timp 0ms: mem 116kb: Killed by signal 8(SIGFPE).: 0 puncte\nRulez testul 3: eroare: timp 0ms: mem 116kb: Killed by signal 8(SIGFPE).: 0 puncte\nRulez testul 4: eroare: timp 0ms: mem 116kb: Killed by signal 8(SIGFPE).: 0 puncte\nRulez testul 5: eroare: timp 0ms: mem 116kb: Killed by signal 8(SIGFPE).: 0 puncte\nRulez testul 6: eroare: timp 0ms: mem 116kb: Killed by signal 8(SIGFPE).: 0 puncte\nRulez testul 7: eroare: timp 0ms: mem 116kb: Killed by signal 8(SIGFPE).: 0 puncte\nRulez testul 8: eroare: timp 0ms: mem 116kb: Killed by signal 8(SIGFPE).: 0 puncte\nRulez testul 9: eroare: timp 0ms: mem 116kb: Killed by signal 8(SIGFPE).: 0 puncte\nRulez testul 10: eroare: timp 0ms: mem 116kb: Killed by signal 8(SIGFPE).: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(5,'adunare',1142,'c','--gone--','done','2006-11-26 18:38:05','Eroare de compilare:\nuser.c:1: error: stray \'\\377\' in program\nuser.c:1: error: stray \'\\330\' in program\nuser.c:1: error: stray \'\\377\' in program\nuser.c:1: error: stray \'\\340\' in program\nuser.c:1:5: warning: null character(s) ignored\nuser.c:1: error: stray \'\\20\' in program\nuser.c:1:11: warning: null character(s) ignored\nuser.c:1: error: stray \'\\1\' in program\nuser.c:1: error: stray \'\\2\' in program\nuser.c:1:14: warning: null character(s) ignored\nuser.c:1: error: syntax error before \"d\"\nuser.c:1:17: warning: null character(s) ignored\nuser.c:1:19: warning: null character(s) ignored\nuser.c:1: error: stray \'\\377\' in program\nuser.c:1: error: stray \'\\354\' in program\nuser.c:1:23: warning: null character(s) ignored\nuser.c:1: error: stray \'\\21\' in program\nuser.c:1:30: warning: null character(s) ignored\nuser.c:1: error: stray \'\\1\' in program\nuser.c:1:32: warning: null character(s) ignored\nuser.c:1: error: stray \'\\4\' in program\nuser.c:1:34: warning: null character(s) ignored\nuser.c:1:38: warning: null character(s) ignored\nuser.c:1: error: stray \'\\377\' in program\nuser.c:1: error: stray \'\\356\' in program\n',0,'Eroare de compilare'),(11,'apdm',1142,'cpp','--gone--','done','2006-11-26 21:31:57','Compilare:\nuser.cpp: In function `void solve()\':\nuser.cpp:59: warning: statement with no effect\n\n\nRulez testul 1: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 2: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 3: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 4: eroare: timp 1ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 5: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 6: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 7: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 8: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 9: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 10: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 11: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 12: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 13: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 14: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 15: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 16: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 17: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 18: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 19: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 20: eroare: timp 0ms: mem 128kb: Killed by signal 11(SIGSEGV).: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(33,'stramosi',1142,'c','--gone--','done','2006-12-04 00:46:05','Compilare:\n\n\nRulez testul 1: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 2: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 3: eroare: timp 1ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 4: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 5: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 6: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 7: eroare: timp 1ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 8: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 9: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 10: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(82,'adunare',1142,'c','--gone--','done','2006-12-04 21:09:18','Compilare:\n\n\nRulez testul 1: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 2: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 3: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 4: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 5: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 6: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 7: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 8: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 9: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\nRulez testul 10: eroare: timp 0ms: mem 88kb: Blocked system call: chroot.: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(85,'adunare',1142,'c','--gone--','done','2006-12-04 21:10:42','Compilare:\n\n\nRulez testul 1: eroare: timp 0ms: mem 88kb: Wall time limit exceeded.: 0 puncte\nRulez testul 2: eroare: timp 0ms: mem 88kb: Wall time limit exceeded.: 0 puncte\nRulez testul 3: eroare: timp 0ms: mem 88kb: Wall time limit exceeded.: 0 puncte\nRulez testul 4: eroare: timp 0ms: mem 88kb: Wall time limit exceeded.: 0 puncte\nRulez testul 5: eroare: timp 0ms: mem 88kb: Wall time limit exceeded.: 0 puncte\nRulez testul 6: eroare: timp 0ms: mem 88kb: Wall time limit exceeded.: 0 puncte\nRulez testul 7: eroare: timp 0ms: mem 88kb: Wall time limit exceeded.: 0 puncte\nRulez testul 8: eroare: timp 0ms: mem 88kb: Wall time limit exceeded.: 0 puncte\nRulez testul 9: eroare: timp 0ms: mem 88kb: Wall time limit exceeded.: 0 puncte\nRulez testul 10: eroare: timp 0ms: mem 88kb: Wall time limit exceeded.: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(143,'12perm',1,'c','--gone--','done','2006-12-05 14:23:43','Compilare:\nuser.c: In function `main\':\nuser.c:11: warning: unused variable `t\'\nuser.c:25:2: warning: no newline at end of file\n\n\nRulez testul 1: ok: timp 0ms: mem 160kb: OK: 5 puncte\nRulez testul 2: ok: timp 0ms: mem 160kb: OK: 5 puncte\nRulez testul 3: ok: timp 0ms: mem 160kb: OK: 5 puncte\nRulez testul 4: ok: timp 1ms: mem 160kb: OK: 5 puncte\nRulez testul 5: ok: timp 0ms: mem 160kb: OK: 5 puncte\nRulez testul 6: ok: timp 0ms: mem 160kb: OK: 5 puncte\nRulez testul 7: ok: timp 1ms: mem 160kb: OK: 5 puncte\nRulez testul 8: ok: timp 2ms: mem 160kb: OK: 5 puncte\nRulez testul 9: ok: timp 2ms: mem 160kb: OK: 5 puncte\nRulez testul 10: ok: timp 4ms: mem 160kb: OK: 5 puncte\nRulez testul 11: ok: timp 4ms: mem 160kb: OK: 5 puncte\nRulez testul 12: ok: timp 9ms: mem 160kb: OK: 5 puncte\nRulez testul 13: ok: timp 15ms: mem 160kb: OK: 5 puncte\nRulez testul 14: ok: timp 20ms: mem 160kb: OK: 5 puncte\nRulez testul 15: ok: timp 24ms: mem 160kb: OK: 5 puncte\nRulez testul 16: ok: timp 36ms: mem 160kb: OK: 5 puncte\nRulez testul 17: ok: timp 47ms: mem 160kb: OK: 5 puncte\nRulez testul 18: ok: timp 49ms: mem 160kb: OK: 5 puncte\nRulez testul 19: ok: timp 57ms: mem 160kb: OK: 5 puncte\nRulez testul 20: ok: timp 58ms: mem 160kb: OK: 5 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(148,'biscuiti',2092,'c','--gone--','done','2006-12-05 19:22:54','Compilare:\n\n\nRulez testul 1: eroare: timp 210ms: mem 67628kb: Memory limit exceeded.: 0 puncte\nRulez testul 2: eroare: timp 208ms: mem 67528kb: Memory limit exceeded.: 0 puncte\nRulez testul 3: eroare: timp 208ms: mem 67720kb: Memory limit exceeded.: 0 puncte\nRulez testul 4: eroare: timp 209ms: mem 67692kb: Memory limit exceeded.: 0 puncte\nRulez testul 5: eroare: timp 208ms: mem 67608kb: Memory limit exceeded.: 0 puncte\nRulez testul 6: eroare: timp 209ms: mem 67788kb: Memory limit exceeded.: 0 puncte\nRulez testul 7: eroare: timp 209ms: mem 67876kb: Memory limit exceeded.: 0 puncte\nRulez testul 8: eroare: timp 208ms: mem 67744kb: Memory limit exceeded.: 0 puncte\nRulez testul 9: eroare: timp 209ms: mem 67816kb: Memory limit exceeded.: 0 puncte\nRulez testul 10: eroare: timp 207ms: mem 66412kb: Memory limit exceeded.: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(349,'adunare',18,'fpc','--gone--','done','2006-12-10 20:49:20','Compilare:\nFree Pascal Compiler version 2.0.2 [2005/12/07] for i386\nCopyright (c) 1993-2005 by Florian Klaempfl\nTarget OS: Linux for i386\nCompiling user.fpc\nLinking user\n8 Lines compiled, 0.0 sec\n\n\nRulez testul 1: eroare: timp 0ms: mem 84kb: Non-zero exit status.: 0 puncte\nRulez testul 2: eroare: timp 0ms: mem 84kb: Non-zero exit status.: 0 puncte\nRulez testul 3: eroare: timp 0ms: mem 84kb: Non-zero exit status.: 0 puncte\nRulez testul 4: eroare: timp 0ms: mem 84kb: Non-zero exit status.: 0 puncte\nRulez testul 5: eroare: timp 0ms: mem 84kb: Non-zero exit status.: 0 puncte\nRulez testul 6: eroare: timp 0ms: mem 84kb: Non-zero exit status.: 0 puncte\nRulez testul 7: eroare: timp 0ms: mem 84kb: Non-zero exit status.: 0 puncte\nRulez testul 8: eroare: timp 0ms: mem 84kb: Non-zero exit status.: 0 puncte\nRulez testul 9: eroare: timp 0ms: mem 84kb: Non-zero exit status.: 0 puncte\nRulez testul 10: eroare: timp 0ms: mem 84kb: Non-zero exit status.: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(360,'apdm',2092,'c','--gone--','done','2006-12-11 06:33:20','Compilare:\nuser.c: In function `bfs\':\nuser.c:13: warning: unused variable `y\'\nuser.c:13: warning: unused variable `ok\'\n\n\nRulez testul 1: ok: timp 0ms: mem 168kb: OK: 5 puncte\nRulez testul 2: ok: timp 0ms: mem 172kb: OK: 5 puncte\nRulez testul 3: ok: timp 0ms: mem 180kb: OK: 5 puncte\nRulez testul 4: ok: timp 0ms: mem 184kb: OK: 5 puncte\nRulez testul 5: ok: timp 0ms: mem 184kb: OK: 5 puncte\nRulez testul 6: ok: timp 0ms: mem 184kb: OK: 5 puncte\nRulez testul 7: ok: timp 1ms: mem 184kb: OK: 5 puncte\nRulez testul 8: ok: timp 0ms: mem 184kb: OK: 5 puncte\nRulez testul 9: ok: timp 0ms: mem 176kb: OK: 5 puncte\nRulez testul 10: ok: timp 0ms: mem 176kb: OK: 5 puncte\nRulez testul 11: ok: timp 0ms: mem 176kb: OK: 5 puncte\nRulez testul 12: ok: timp 0ms: mem 196kb: OK: 5 puncte\nRulez testul 13: ok: timp 8ms: mem 344kb: OK: 5 puncte\nRulez testul 14: eroare: timp 148ms: mem 344kb: Time limit exceeded.: 0 puncte\nRulez testul 15: ok: timp 1ms: mem 352kb: OK: 5 puncte\nRulez testul 16: ok: timp 68ms: mem 352kb: OK: 5 puncte\nRulez testul 17: ok: timp 3ms: mem 352kb: OK: 5 puncte\nRulez testul 18: ok: timp 47ms: mem 352kb: OK: 5 puncte\nRulez testul 19: eroare: timp 111ms: mem 344kb: Time limit exceeded.: 0 puncte\nRulez testul 20: eroare: timp 104ms: mem 352kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 85\n',85,'Evaluare completa'),(680,'datorii',1024,'cpp','--gone--','done','2006-12-11 16:40:07','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:20: warning: long int format, int arg (arg 3)\nuser.cpp:20: warning: long int format, int arg (arg 4)\nuser.cpp:24: warning: long int format, int arg (arg 3)\n\n\nRulez testul 1: eroare: timp 205ms: mem 520kb: Time limit exceeded.: 0 puncte\nRulez testul 2: ok: timp 198ms: mem 520kb: Corect!: 20 puncte\nRulez testul 3: ok: timp 194ms: mem 520kb: Corect!: 20 puncte\nRulez testul 4: eroare: timp 201ms: mem 520kb: Time limit exceeded.: 0 puncte\nRulez testul 5: eroare: timp 207ms: mem 520kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 40\n',40,'Evaluare completa'),(682,'datorii',1024,'cpp','--gone--','done','2006-12-11 16:42:13','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:20: warning: long int format, int arg (arg 3)\nuser.cpp:20: warning: long int format, int arg (arg 4)\nuser.cpp:24: warning: long int format, int arg (arg 3)\n\n\nRulez testul 1: ok: timp 198ms: mem 520kb: Corect!: 20 puncte\nRulez testul 2: ok: timp 200ms: mem 520kb: Corect!: 20 puncte\nRulez testul 3: ok: timp 197ms: mem 520kb: Corect!: 20 puncte\nRulez testul 4: ok: timp 195ms: mem 520kb: Corect!: 20 puncte\nRulez testul 5: ok: timp 198ms: mem 520kb: Corect!: 20 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(930,'lupu',2524,'cpp','--gone--','done','2006-12-12 07:09:49','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 5: ok: timp 1ms: mem 8kb: OK: 4 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 7: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 8: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 9: ok: timp 2ms: mem 8kb: OK: 4 puncte\nRulez testul 10: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 11: ok: timp 3ms: mem 228kb: OK: 4 puncte\nRulez testul 12: ok: timp 18ms: mem 352kb: OK: 4 puncte\nRulez testul 13: ok: timp 166ms: mem 1548kb: Incorect: 0 puncte\nRulez testul 14: eroare: timp 455ms: mem 828kb: Time limit exceeded.: 0 puncte\nRulez testul 15: eroare: timp 455ms: mem 684kb: Time limit exceeded.: 0 puncte\nRulez testul 16: eroare: timp 455ms: mem 768kb: Time limit exceeded.: 0 puncte\nRulez testul 17: ok: timp 102ms: mem 1384kb: Incorect: 0 puncte\nRulez testul 18: ok: timp 120ms: mem 1520kb: OK: 4 puncte\nRulez testul 19: eroare: timp 453ms: mem 936kb: Time limit exceeded.: 0 puncte\nRulez testul 20: ok: timp 163ms: mem 1364kb: Incorect: 0 puncte\nRulez testul 21: eroare: timp 452ms: mem 1052kb: Time limit exceeded.: 0 puncte\nRulez testul 22: ok: timp 226ms: mem 1752kb: OK: 4 puncte\nRulez testul 23: ok: timp 201ms: mem 1620kb: OK: 4 puncte\nRulez testul 24: ok: timp 200ms: mem 1760kb: OK: 4 puncte\nRulez testul 25: ok: timp 306ms: mem 1388kb: OK: 4 puncte\n\nPunctaj total: 64\n',64,'Evaluare completa'),(955,'lupu',2524,'cpp','--gone--','done','2006-12-12 10:04:15','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:27: warning: unused variable `int tmp\'\nuser.cpp:27: warning: unused variable `int x1\'\nuser.cpp:27: warning: unused variable `int y1\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 4: ok: timp 1ms: mem 8kb: OK: 4 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 7: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 8: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 9: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 10: ok: timp 1ms: mem 8kb: OK: 4 puncte\nRulez testul 11: ok: timp 2ms: mem 8kb: OK: 4 puncte\nRulez testul 12: ok: timp 10ms: mem 296kb: OK: 4 puncte\nRulez testul 13: ok: timp 139ms: mem 1160kb: OK: 4 puncte\nRulez testul 14: ok: timp 89ms: mem 960kb: OK: 4 puncte\nRulez testul 15: ok: timp 44ms: mem 592kb: OK: 4 puncte\nRulez testul 16: ok: timp 84ms: mem 824kb: OK: 4 puncte\nRulez testul 17: ok: timp 94ms: mem 864kb: OK: 4 puncte\nRulez testul 18: ok: timp 89ms: mem 1168kb: OK: 4 puncte\nRulez testul 19: ok: timp 96ms: mem 964kb: OK: 4 puncte\nRulez testul 20: ok: timp 125ms: mem 1300kb: OK: 4 puncte\nRulez testul 21: ok: timp 131ms: mem 1160kb: OK: 4 puncte\nRulez testul 22: ok: timp 102ms: mem 1348kb: OK: 4 puncte\nRulez testul 23: ok: timp 106ms: mem 1348kb: OK: 4 puncte\nRulez testul 24: ok: timp 104ms: mem 1348kb: OK: 4 puncte\nRulez testul 25: ok: timp 74ms: mem 1048kb: OK: 4 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(958,'superp',2524,'cpp','--gone--','done','2006-12-12 10:07:04','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:104: warning: char format, different type arg (arg 2)\nuser.cpp:109: warning: comparison between signed and unsigned integer \n   expressions\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 3: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 7: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 8: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 9: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 10: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 11: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 12: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 13: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 14: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 15: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 16: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 17: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 18: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 19: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 20: ok: timp 1ms: mem 8kb: OK: 5 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(963,'hallway',2524,'cpp','--gone--','done','2006-12-12 10:19:49','Compilare:\nuser.cpp:125:2: warning: no newline at end of file\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 6: ok: timp 9ms: mem 916kb: OK: 5 puncte\nRulez testul 7: ok: timp 6ms: mem 676kb: Incorect: 0 puncte\nRulez testul 8: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 9: ok: timp 17ms: mem 1168kb: OK: 5 puncte\nRulez testul 10: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 11: ok: timp 4ms: mem 668kb: OK: 5 puncte\nRulez testul 12: ok: timp 4ms: mem 660kb: Incorect: 0 puncte\nRulez testul 13: ok: timp 21ms: mem 1672kb: Incorect: 0 puncte\nRulez testul 14: ok: timp 5ms: mem 688kb: Incorect: 0 puncte\nRulez testul 15: ok: timp 5ms: mem 704kb: Incorect: 0 puncte\nRulez testul 16: ok: timp 22ms: mem 1976kb: Incorect: 0 puncte\nRulez testul 17: eroare: timp 152ms: mem 4148kb: Time limit exceeded.: 0 puncte\nRulez testul 18: ok: timp 88ms: mem 2992kb: OK: 5 puncte\nRulez testul 19: ok: timp 53ms: mem 2244kb: Incorect: 0 puncte\nRulez testul 20: eroare: timp 143ms: mem 4184kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 40\n',40,'Evaluare completa'),(1232,'graf',2092,'c','--gone--','done','2006-12-12 20:04:39','Compilare:\nuser.c: In function `bfs\':\nuser.c:26: warning: unused variable `i\'\nuser.c: In function `solve_and_write\':\nuser.c:44: warning: unused variable `y\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 6: ok: timp 14ms: mem 752kb: OK: 10 puncte\nRulez testul 7: ok: timp 3ms: mem 392kb: OK: 10 puncte\nRulez testul 8: ok: timp 14ms: mem 668kb: OK: 10 puncte\nRulez testul 9: ok: timp 16ms: mem 736kb: OK: 10 puncte\nRulez testul 10: ok: timp 14ms: mem 752kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(1416,'cc',256,'c','--gone--','done','2006-12-13 14:58:27','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 6: ok: timp 2ms: mem 8kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 6ms: mem 208kb: Incorect: 0 puncte\nRulez testul 8: ok: timp 6ms: mem 208kb: Incorect: 0 puncte\nRulez testul 9: ok: timp 2ms: mem 8kb: Incorect: 0 puncte\nRulez testul 10: ok: timp 4ms: mem 204kb: Incorect: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(1534,'substr',2524,'cpp','--gone--','done','2006-12-13 21:52:14','Compilare:\nuser.cpp: In function `int max(int)\':\nuser.cpp:46: warning: unused variable `int j\'\n\n\nRulez testul 1: eroare: timp 202ms: mem 6304kb: Time limit exceeded.: 0 puncte\nRulez testul 2: eroare: timp 202ms: mem 6304kb: Time limit exceeded.: 0 puncte\nRulez testul 3: eroare: timp 204ms: mem 6304kb: Time limit exceeded.: 0 puncte\nRulez testul 4: eroare: timp 158ms: mem 6272kb: Time limit exceeded.: 0 puncte\nRulez testul 5: eroare: timp 202ms: mem 6300kb: Time limit exceeded.: 0 puncte\nRulez testul 6: eroare: timp 203ms: mem 6300kb: Time limit exceeded.: 0 puncte\nRulez testul 7: ok: timp 124ms: mem 6260kb: OK: 10 puncte\nRulez testul 8: ok: timp 127ms: mem 6260kb: OK: 10 puncte\nRulez testul 9: ok: timp 127ms: mem 6260kb: OK: 10 puncte\nRulez testul 10: eroare: timp 204ms: mem 6288kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 30\n',30,'Evaluare completa'),(1535,'substr',2524,'cpp','--gone--','done','2006-12-13 21:52:55','Compilare:\nuser.cpp: In function `int max(int)\':\nuser.cpp:46: warning: unused variable `int j\'\n\n\nRulez testul 1: ok: timp 143ms: mem 3976kb: Incorect: 0 puncte\nRulez testul 2: eroare: timp 164ms: mem 3976kb: Time limit exceeded.: 0 puncte\nRulez testul 3: eroare: timp 158ms: mem 3976kb: Time limit exceeded.: 0 puncte\nRulez testul 4: ok: timp 105ms: mem 3928kb: OK: 10 puncte\nRulez testul 5: eroare: timp 155ms: mem 3972kb: Time limit exceeded.: 0 puncte\nRulez testul 6: eroare: timp 157ms: mem 3972kb: Time limit exceeded.: 0 puncte\nRulez testul 7: ok: timp 77ms: mem 3916kb: OK: 10 puncte\nRulez testul 8: ok: timp 79ms: mem 3916kb: OK: 10 puncte\nRulez testul 9: ok: timp 79ms: mem 3916kb: OK: 10 puncte\nRulez testul 10: ok: timp 142ms: mem 3960kb: OK: 10 puncte\n\nPunctaj total: 50\n',50,'Evaluare completa'),(1536,'substr',2524,'cpp','--gone--','done','2006-12-13 21:53:38','Compilare:\nuser.cpp: In function `int max(int)\':\nuser.cpp:46: warning: unused variable `int j\'\n\n\nRulez testul 1: ok: timp 105ms: mem 2396kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 115ms: mem 2412kb: OK: 10 puncte\nRulez testul 3: ok: timp 110ms: mem 2412kb: OK: 10 puncte\nRulez testul 4: ok: timp 62ms: mem 2364kb: OK: 10 puncte\nRulez testul 5: ok: timp 107ms: mem 2408kb: OK: 10 puncte\nRulez testul 6: ok: timp 109ms: mem 2408kb: OK: 10 puncte\nRulez testul 7: ok: timp 45ms: mem 2352kb: OK: 10 puncte\nRulez testul 8: ok: timp 44ms: mem 2352kb: OK: 10 puncte\nRulez testul 9: ok: timp 45ms: mem 2352kb: OK: 10 puncte\nRulez testul 10: ok: timp 95ms: mem 2396kb: OK: 10 puncte\n\nPunctaj total: 90\n',90,'Evaluare completa'),(1781,'secventa',2092,'c','--gone--','done','2006-12-14 16:57:00','Compilare:\nuser.c: In function `read_data\':\nuser.c:34: warning: unused variable `minus\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 2ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 6ms: mem 808kb: OK: 10 puncte\nRulez testul 4: ok: timp 10ms: mem 900kb: OK: 10 puncte\nRulez testul 5: ok: timp 14ms: mem 1144kb: OK: 10 puncte\nRulez testul 6: ok: timp 16ms: mem 1340kb: OK: 10 puncte\nRulez testul 7: ok: timp 27ms: mem 2124kb: OK: 10 puncte\nRulez testul 8: ok: timp 44ms: mem 3100kb: OK: 10 puncte\nRulez testul 9: ok: timp 56ms: mem 4080kb: OK: 10 puncte\nRulez testul 10: ok: timp 69ms: mem 5064kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(1893,'abc',1,'cpp','--gone--','done','2006-12-15 09:43:04','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:54: warning: cannot pass objects of non-POD type `struct \n   std::pair<int, int>\' through `...\'; call will abort at runtime\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Esti bazat!: 5 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Nu ai nimerit de data asta!: 0 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Nu ai nimerit de data asta!: 0 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: Nu ai nimerit de data asta!: 0 puncte\nRulez testul 5: ok: timp 1ms: mem 8kb: Esti bazat!: 5 puncte\nRulez testul 6: ok: timp 2ms: mem 8kb: Nu ai nimerit de data asta!: 0 puncte\nRulez testul 7: ok: timp 10ms: mem 648kb: Nu ai nimerit de data asta!: 0 puncte\nRulez testul 8: ok: timp 12ms: mem 648kb: Esti bazat!: 5 puncte\nRulez testul 9: ok: timp 11ms: mem 648kb: Nu ai nimerit de data asta!: 0 puncte\nRulez testul 10: ok: timp 11ms: mem 648kb: Esti bazat!: 5 puncte\nRulez testul 11: ok: timp 19ms: mem 652kb: Nu ai nimerit de data asta!: 0 puncte\nRulez testul 12: ok: timp 23ms: mem 652kb: Nu ai nimerit de data asta!: 0 puncte\nRulez testul 13: ok: timp 31ms: mem 652kb: Nu ai nimerit de data asta!: 0 puncte\nRulez testul 14: ok: timp 39ms: mem 652kb: Nu ai nimerit de data asta!: 0 puncte\nRulez testul 15: ok: timp 37ms: mem 652kb: Esti bazat!: 5 puncte\nRulez testul 16: ok: timp 37ms: mem 652kb: Esti bazat!: 5 puncte\nRulez testul 17: ok: timp 37ms: mem 652kb: Esti bazat!: 5 puncte\nRulez testul 18: ok: timp 35ms: mem 652kb: Nu ai nimerit de data asta!: 0 puncte\nRulez testul 19: ok: timp 6ms: mem 648kb: Nu ai nimerit de data asta!: 0 puncte\nRulez testul 20: ok: timp 5ms: mem 648kb: Esti bazat!: 5 puncte\n\nPunctaj total: 40\n',40,'Evaluare completa'),(1919,'cc',2092,'c','--gone--','done','2006-12-15 11:11:34','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 4ms: mem 384kb: OK: 10 puncte\nRulez testul 5: ok: timp 21ms: mem 556kb: OK: 10 puncte\nRulez testul 6: ok: timp 78ms: mem 696kb: OK: 10 puncte\nRulez testul 7: ok: timp 147ms: mem 864kb: OK: 10 puncte\nRulez testul 8: ok: timp 226ms: mem 876kb: OK: 10 puncte\nRulez testul 9: ok: timp 42ms: mem 636kb: OK: 10 puncte\nRulez testul 10: ok: timp 165ms: mem 824kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(2169,'joc3',2524,'cpp','--gone--','done','2006-12-16 08:28:33','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:9: warning: unused variable `int tmp\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 1ms: mem 8kb: Incorect: 0 puncte\nRulez testul 5: ok: timp 1ms: mem 8kb: Incorect: 0 puncte\nRulez testul 6: ok: timp 1ms: mem 8kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 3ms: mem 8kb: Incorect: 0 puncte\nRulez testul 8: ok: timp 3ms: mem 8kb: Incorect: 0 puncte\nRulez testul 9: ok: timp 3ms: mem 8kb: Incorect: 0 puncte\nRulez testul 10: ok: timp 2ms: mem 220kb: Incorect: 0 puncte\nRulez testul 11: ok: timp 6ms: mem 216kb: Incorect: 0 puncte\nRulez testul 12: ok: timp 10ms: mem 252kb: Incorect: 0 puncte\nRulez testul 13: ok: timp 13ms: mem 308kb: Incorect: 0 puncte\nRulez testul 14: ok: timp 18ms: mem 352kb: Incorect: 0 puncte\nRulez testul 15: ok: timp 22ms: mem 404kb: Incorect: 0 puncte\nRulez testul 16: ok: timp 23ms: mem 408kb: Incorect: 0 puncte\nRulez testul 17: ok: timp 28ms: mem 452kb: Incorect: 0 puncte\nRulez testul 18: ok: timp 31ms: mem 500kb: Incorect: 0 puncte\nRulez testul 19: ok: timp 31ms: mem 500kb: Incorect: 0 puncte\nRulez testul 20: ok: timp 38ms: mem 548kb: Incorect: 0 puncte\n\nPunctaj total: 5\n',5,'Evaluare completa'),(2730,'arbore',256,'c','--gone--','done','2006-12-18 16:57:19','Compilare:\nuser.c: In function `update\':\nuser.c:54: warning: unused variable `fr\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Wrong Answer!: 0 puncte\nRulez testul 2: ok: timp 12ms: mem 372kb: Wrong Answer!: 0 puncte\nRulez testul 3: ok: timp 301ms: mem 1148kb: Wrong Answer!: 0 puncte\nRulez testul 4: ok: timp 403ms: mem 1864kb: Wrong Answer!: 0 puncte\nRulez testul 5: ok: timp 1444ms: mem 3852kb: Wrong Answer!: 0 puncte\nRulez testul 6: ok: timp 1637ms: mem 4468kb: Wrong Answer!: 0 puncte\nRulez testul 7: eroare: timp 2014ms: mem 5732kb: Time limit exceeded.: 0 puncte\nRulez testul 8: eroare: timp 2020ms: mem 6356kb: Time limit exceeded.: 0 puncte\nRulez testul 9: eroare: timp 2018ms: mem 6360kb: Time limit exceeded.: 0 puncte\nRulez testul 10: eroare: timp 188ms: mem 6708kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 11: ok: timp 859ms: mem 3844kb: Wrong Answer!: 0 puncte\nRulez testul 12: ok: timp 1168ms: mem 4468kb: Wrong Answer!: 0 puncte\nRulez testul 13: ok: timp 1321ms: mem 4468kb: Wrong Answer!: 0 puncte\nRulez testul 14: ok: timp 1448ms: mem 5108kb: Wrong Answer!: 0 puncte\nRulez testul 15: ok: timp 1677ms: mem 5116kb: Wrong Answer!: 0 puncte\nRulez testul 16: ok: timp 1725ms: mem 5732kb: Wrong Answer!: 0 puncte\nRulez testul 17: eroare: timp 2031ms: mem 5732kb: Time limit exceeded.: 0 puncte\nRulez testul 18: eroare: timp 2018ms: mem 6352kb: Time limit exceeded.: 0 puncte\nRulez testul 19: eroare: timp 2017ms: mem 6344kb: Time limit exceeded.: 0 puncte\nRulez testul 20: eroare: timp 217ms: mem 6896kb: Killed by signal 11(SIGSEGV).: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(2829,'joc3',256,'c','--gone--','done','2006-12-19 12:38:37','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 5: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 6: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 7: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 8: ok: timp 2ms: mem 8kb: OK: 5 puncte\nRulez testul 9: ok: timp 4ms: mem 8kb: OK: 5 puncte\nRulez testul 10: ok: timp 3ms: mem 200kb: OK: 5 puncte\nRulez testul 11: ok: timp 7ms: mem 188kb: OK: 5 puncte\nRulez testul 12: ok: timp 6ms: mem 232kb: OK: 5 puncte\nRulez testul 13: ok: timp 14ms: mem 288kb: OK: 5 puncte\nRulez testul 14: ok: timp 18ms: mem 336kb: OK: 5 puncte\nRulez testul 15: ok: timp 23ms: mem 384kb: OK: 5 puncte\nRulez testul 16: ok: timp 27ms: mem 384kb: OK: 5 puncte\nRulez testul 17: ok: timp 28ms: mem 432kb: OK: 5 puncte\nRulez testul 18: ok: timp 30ms: mem 480kb: OK: 5 puncte\nRulez testul 19: ok: timp 37ms: mem 532kb: OK: 5 puncte\nRulez testul 20: ok: timp 39ms: mem 524kb: OK: 5 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(3025,'avd',1,'cpp','--gone--','done','2006-12-20 13:47:15','Compilare:\n\n\nRulez testul 1: ok: timp 1ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 7: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 8: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 9: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 10: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(3299,'soc',2092,'c','--gone--','done','2006-12-23 15:29:30','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK!: 5 puncte\nRulez testul 2: eroare: timp 354ms: mem 812kb: Time limit exceeded.: 0 puncte\nRulez testul 3: eroare: timp 342ms: mem 66484kb: Time limit exceeded.: 0 puncte\nRulez testul 4: eroare: timp 260ms: mem 65680kb: Memory limit exceeded.: 0 puncte\nRulez testul 5: eroare: timp 357ms: mem 16364kb: Time limit exceeded.: 0 puncte\nRulez testul 6: eroare: timp 356ms: mem 8464kb: Time limit exceeded.: 0 puncte\nRulez testul 7: eroare: timp 354ms: mem 4980kb: Time limit exceeded.: 0 puncte\nRulez testul 8: eroare: timp 357ms: mem 13728kb: Time limit exceeded.: 0 puncte\nRulez testul 9: eroare: timp 356ms: mem 12304kb: Time limit exceeded.: 0 puncte\nRulez testul 10: eroare: timp 355ms: mem 1968kb: Time limit exceeded.: 0 puncte\nRulez testul 11: eroare: timp 355ms: mem 1420kb: Time limit exceeded.: 0 puncte\nRulez testul 12: eroare: timp 347ms: mem 1104kb: Time limit exceeded.: 0 puncte\nRulez testul 13: eroare: timp 352ms: mem 964kb: Time limit exceeded.: 0 puncte\nRulez testul 14: eroare: timp 354ms: mem 828kb: Time limit exceeded.: 0 puncte\nRulez testul 15: eroare: timp 355ms: mem 3220kb: Time limit exceeded.: 0 puncte\nRulez testul 16: eroare: timp 356ms: mem 808kb: Time limit exceeded.: 0 puncte\nRulez testul 17: eroare: timp 353ms: mem 796kb: Time limit exceeded.: 0 puncte\nRulez testul 18: eroare: timp 356ms: mem 800kb: Time limit exceeded.: 0 puncte\nRulez testul 19: eroare: timp 354ms: mem 808kb: Time limit exceeded.: 0 puncte\nRulez testul 20: eroare: timp 354ms: mem 804kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 5\n',5,'Evaluare completa'),(3305,'mine',256,'c','--gone--','done','2006-12-23 16:59:29','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 7: ok: timp 1ms: mem 8kb: OK: 4 puncte\nRulez testul 8: ok: timp 4ms: mem 196kb: OK: 4 puncte\nRulez testul 9: ok: timp 70ms: mem 196kb: OK: 4 puncte\nRulez testul 10: eroare: timp 212ms: mem 196kb: Time limit exceeded.: 0 puncte\nRulez testul 11: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 12: ok: timp 1ms: mem 8kb: OK: 4 puncte\nRulez testul 13: ok: timp 17ms: mem 504kb: OK: 4 puncte\nRulez testul 14: eroare: timp 211ms: mem 3324kb: Time limit exceeded.: 0 puncte\nRulez testul 15: eroare: timp 218ms: mem 3056kb: Time limit exceeded.: 0 puncte\nRulez testul 16: eroare: timp 223ms: mem 2976kb: Time limit exceeded.: 0 puncte\nRulez testul 17: ok: timp 152ms: mem 2756kb: OK: 4 puncte\nRulez testul 18: ok: timp 178ms: mem 916kb: OK: 4 puncte\nRulez testul 19: eroare: timp 212ms: mem 896kb: Time limit exceeded.: 0 puncte\nRulez testul 20: eroare: timp 210ms: mem 1224kb: Time limit exceeded.: 0 puncte\nRulez testul 21: eroare: timp 211ms: mem 1832kb: Time limit exceeded.: 0 puncte\nRulez testul 22: ok: timp 164ms: mem 1760kb: OK: 4 puncte\nRulez testul 23: ok: timp 193ms: mem 2276kb: OK: 4 puncte\nRulez testul 24: eroare: timp 214ms: mem 3396kb: Time limit exceeded.: 0 puncte\nRulez testul 25: eroare: timp 214ms: mem 3396kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 64\n',64,'Evaluare completa'),(3394,'bcolor',1,'cpp','--gone--','done','2006-12-25 21:11:10','Compilare:\nuser.cpp: In function `int count()\':\nuser.cpp:29: warning: `int k\' might be used uninitialized in this function\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 2: ok: timp 4ms: mem 8kb: OK: 5 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 4: ok: timp 23ms: mem 168kb: OK: 5 puncte\nRulez testul 5: ok: timp 62ms: mem 168kb: OK: 5 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 7: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 8: ok: timp 8ms: mem 168kb: OK: 5 puncte\nRulez testul 9: ok: timp 17ms: mem 168kb: OK: 5 puncte\nRulez testul 10: ok: timp 23ms: mem 168kb: OK: 5 puncte\nRulez testul 11: ok: timp 3ms: mem 8kb: OK: 5 puncte\nRulez testul 12: ok: timp 4ms: mem 168kb: OK: 5 puncte\nRulez testul 13: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 14: ok: timp 27ms: mem 168kb: OK: 5 puncte\nRulez testul 15: ok: timp 48ms: mem 168kb: OK: 5 puncte\nRulez testul 16: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 17: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 18: ok: timp 8ms: mem 168kb: OK: 5 puncte\nRulez testul 19: ok: timp 13ms: mem 168kb: OK: 5 puncte\nRulez testul 20: ok: timp 5ms: mem 168kb: OK: 5 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(3429,'secv4',1,'cpp','--gone--','done','2006-12-26 11:21:48','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:41: warning: array subscript has type `char\'\nuser.cpp:42: warning: array subscript has type `char\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 2: ok: timp 2ms: mem 8kb: OK: 5 puncte\nRulez testul 3: ok: timp 119ms: mem 1716kb: OK: 5 puncte\nRulez testul 4: ok: timp 121ms: mem 1828kb: OK: 5 puncte\nRulez testul 5: ok: timp 124ms: mem 1956kb: OK: 5 puncte\nRulez testul 6: ok: timp 119ms: mem 2008kb: OK: 5 puncte\nRulez testul 7: ok: timp 121ms: mem 2020kb: OK: 5 puncte\nRulez testul 8: ok: timp 121ms: mem 1716kb: OK: 5 puncte\nRulez testul 9: ok: timp 108ms: mem 1628kb: OK: 5 puncte\nRulez testul 10: ok: timp 119ms: mem 1480kb: OK: 5 puncte\nRulez testul 11: ok: timp 126ms: mem 1416kb: OK: 5 puncte\nRulez testul 12: ok: timp 118ms: mem 1112kb: Incorect: 0 puncte\nRulez testul 13: ok: timp 121ms: mem 1544kb: Incorect: 0 puncte\nRulez testul 14: ok: timp 120ms: mem 1272kb: OK: 5 puncte\nRulez testul 15: ok: timp 117ms: mem 1528kb: Incorect: 0 puncte\nRulez testul 16: ok: timp 119ms: mem 1600kb: OK: 5 puncte\nRulez testul 17: ok: timp 118ms: mem 1952kb: OK: 5 puncte\nRulez testul 18: ok: timp 121ms: mem 1720kb: OK: 5 puncte\nRulez testul 19: ok: timp 118ms: mem 1980kb: OK: 5 puncte\nRulez testul 20: ok: timp 125ms: mem 1680kb: OK: 5 puncte\n\nPunctaj total: 85\n',85,'Evaluare completa'),(3432,'secv4',1,'cpp','--gone--','done','2006-12-26 11:42:54','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:34: warning: array subscript has type `char\'\nuser.cpp:35: warning: array subscript has type `char\'\n\n\nRulez testul 1: ok: timp 2ms: mem 8kb: OK: 5 puncte\nRulez testul 2: ok: timp 2ms: mem 8kb: OK: 5 puncte\nRulez testul 3: ok: timp 120ms: mem 1708kb: OK: 5 puncte\nRulez testul 4: ok: timp 122ms: mem 1812kb: OK: 5 puncte\nRulez testul 5: ok: timp 119ms: mem 1936kb: OK: 5 puncte\nRulez testul 6: ok: timp 117ms: mem 2016kb: OK: 5 puncte\nRulez testul 7: ok: timp 119ms: mem 2028kb: OK: 5 puncte\nRulez testul 8: ok: timp 118ms: mem 1752kb: OK: 5 puncte\nRulez testul 9: ok: timp 101ms: mem 1656kb: OK: 5 puncte\nRulez testul 10: ok: timp 123ms: mem 1496kb: OK: 5 puncte\nRulez testul 11: ok: timp 118ms: mem 1428kb: OK: 5 puncte\nRulez testul 12: ok: timp 118ms: mem 1124kb: Incorect: 0 puncte\nRulez testul 13: ok: timp 124ms: mem 1532kb: Incorect: 0 puncte\nRulez testul 14: ok: timp 121ms: mem 1300kb: OK: 5 puncte\nRulez testul 15: ok: timp 119ms: mem 1524kb: Incorect: 0 puncte\nRulez testul 16: ok: timp 121ms: mem 1596kb: OK: 5 puncte\nRulez testul 17: ok: timp 127ms: mem 1896kb: OK: 5 puncte\nRulez testul 18: ok: timp 123ms: mem 1776kb: OK: 5 puncte\nRulez testul 19: ok: timp 120ms: mem 1976kb: OK: 5 puncte\nRulez testul 20: ok: timp 114ms: mem 1656kb: OK: 5 puncte\n\nPunctaj total: 85\n',85,'Evaluare completa'),(3705,'pscnv',1024,'cpp','--gone--','done','2006-12-28 14:15:29','Compilare:\n\n\nRulez testul 1: ok: timp 2ms: mem 248kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 3ms: mem 236kb: Incorect: 0 puncte\nRulez testul 3: ok: timp 10ms: mem 308kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 56ms: mem 1092kb: Incorect: 0 puncte\nRulez testul 5: ok: timp 60ms: mem 1092kb: Incorect: 0 puncte\nRulez testul 6: ok: timp 78ms: mem 1404kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 120ms: mem 2000kb: Incorect: 0 puncte\nRulez testul 8: eroare: timp 5ms: mem 640kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 9: eroare: timp 0ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 10: eroare: timp 0ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(3779,'text',1024,'cpp','--gone--','done','2006-12-29 01:31:27','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Ok!: 10 puncte\nRulez testul 2: ok: timp 1ms: mem 8kb: Ok!: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Ok!: 10 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: Ok!: 10 puncte\nRulez testul 5: ok: timp 1ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 7: ok: timp 21ms: mem 584kb: Ok!: 10 puncte\nRulez testul 8: ok: timp 5ms: mem 448kb: Wrong answer!: 0 puncte\nRulez testul 9: ok: timp 19ms: mem 588kb: Wrong answer!: 0 puncte\nRulez testul 10: ok: timp 84ms: mem 1456kb: Ok!: 10 puncte\n\nPunctaj total: 60\n',60,'Evaluare completa'),(3780,'text',1024,'cpp','--gone--','done','2006-12-29 01:40:16','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Ok!: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Ok!: 10 puncte\nRulez testul 3: ok: timp 1ms: mem 8kb: Ok!: 10 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: Ok!: 10 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 7: ok: timp 19ms: mem 584kb: Ok!: 10 puncte\nRulez testul 8: ok: timp 5ms: mem 448kb: Wrong answer!: 0 puncte\nRulez testul 9: ok: timp 19ms: mem 588kb: Wrong answer!: 0 puncte\nRulez testul 10: ok: timp 85ms: mem 1456kb: Ok!: 10 puncte\n\nPunctaj total: 60\n',60,'Evaluare completa'),(3870,'ct',1,'cpp','--gone--','done','2006-12-29 15:00:59','Eroare de compilare:\nuser.cpp: In function `void BFS()\':\nuser.cpp:28: error: `Q\' undeclared (first use this function)\nuser.cpp:28: error: (Each undeclared identifier is reported only once for each \n   function it appears in.)\nuser.cpp: In function `int main()\':\nuser.cpp:23: error: too many arguments to function `void BFS()\'\nuser.cpp:94: error: at this point in file\n',0,'Eroare de compilare'),(3876,'ct',1,'cpp','--gone--','done','2006-12-29 15:05:03','Compilare:\n\n\nRulez testul 1: ok: timp 14ms: mem 3608kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 132ms: mem 4432kb: Incorect: 0 puncte\nRulez testul 3: ok: timp 347ms: mem 5120kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 1279ms: mem 8916kb: Incorect: 0 puncte\nRulez testul 5: eroare: timp 2511ms: mem 11428kb: Time limit exceeded.: 0 puncte\nRulez testul 6: ok: timp 2115ms: mem 11440kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 10ms: mem 3612kb: Incorect: 0 puncte\nRulez testul 8: ok: timp 486ms: mem 5928kb: Incorect: 0 puncte\nRulez testul 9: eroare: timp 2518ms: mem 11556kb: Time limit exceeded.: 0 puncte\nRulez testul 10: ok: timp 11ms: mem 3000kb: Incorect: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(3879,'ct',1,'cpp','--gone--','done','2006-12-29 15:11:05','Compilare:\n\n\nRulez testul 1: ok: timp 12ms: mem 3608kb: OK: 10 puncte\nRulez testul 2: ok: timp 127ms: mem 4428kb: OK: 10 puncte\nRulez testul 3: ok: timp 378ms: mem 5116kb: OK: 10 puncte\nRulez testul 4: ok: timp 1313ms: mem 8916kb: Incorect: 0 puncte\nRulez testul 5: eroare: timp 2520ms: mem 11424kb: Time limit exceeded.: 0 puncte\nRulez testul 6: ok: timp 2180ms: mem 11436kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 10ms: mem 3608kb: OK: 10 puncte\nRulez testul 8: ok: timp 545ms: mem 5924kb: OK: 10 puncte\nRulez testul 9: eroare: timp 2515ms: mem 11552kb: Time limit exceeded.: 0 puncte\nRulez testul 10: ok: timp 10ms: mem 2996kb: OK: 10 puncte\n\nPunctaj total: 60\n',60,'Evaluare completa'),(4075,'divmul',3369,'cpp','--gone--','done','2006-12-30 18:47:46','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:22: warning: unused variable `int x\'\nuser.cpp:22: warning: unused variable `int y\'\nuser.cpp:22: warning: unused variable `int i\'\nuser.cpp:22: warning: unused variable `int j\'\nuser.cpp:22: warning: unused variable `int r\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(4352,'ct',1,'cpp','--gone--','done','2007-01-03 10:46:45','Compilare:\n\n\nRulez testul 1: ok: timp 17ms: mem 4036kb: OK: 10 puncte\nRulez testul 2: ok: timp 133ms: mem 4896kb: OK: 10 puncte\nRulez testul 3: ok: timp 374ms: mem 5620kb: OK: 10 puncte\nRulez testul 4: ok: timp 1364ms: mem 10272kb: Incorect: 0 puncte\nRulez testul 5: eroare: timp 2520ms: mem 13100kb: Time limit exceeded.: 0 puncte\nRulez testul 6: ok: timp 2243ms: mem 13080kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 12ms: mem 3984kb: OK: 10 puncte\nRulez testul 8: ok: timp 522ms: mem 6484kb: OK: 10 puncte\nRulez testul 9: eroare: timp 2516ms: mem 12952kb: Time limit exceeded.: 0 puncte\nRulez testul 10: ok: timp 12ms: mem 3980kb: OK: 10 puncte\n\nPunctaj total: 60\n',60,'Evaluare completa'),(4358,'ct',1,'cpp','--gone--','done','2007-01-03 11:05:53','Compilare:\n\n\nRulez testul 1: ok: timp 11ms: mem 3544kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 94ms: mem 4300kb: Incorect: 0 puncte\nRulez testul 3: ok: timp 260ms: mem 4956kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 1081ms: mem 9392kb: Incorect: 0 puncte\nRulez testul 5: eroare: timp 2519ms: mem 11936kb: Time limit exceeded.: 0 puncte\nRulez testul 6: ok: timp 1845ms: mem 11920kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 11ms: mem 3028kb: Incorect: 0 puncte\nRulez testul 8: ok: timp 378ms: mem 5708kb: Incorect: 0 puncte\nRulez testul 9: ok: timp 2438ms: mem 11792kb: Incorect: 0 puncte\nRulez testul 10: ok: timp 9ms: mem 3028kb: Incorect: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(4646,'ecu',2092,'c','--gone--','done','2007-01-06 20:36:57','Compilare:\nuser.c: In function `solve\':\nuser.c:15: warning: unused variable `k\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Okay: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 3: ok: timp 2ms: mem 8kb: Okay: 10 puncte\nRulez testul 4: ok: timp 34ms: mem 1504kb: Wrong answer!: 0 puncte\nRulez testul 5: ok: timp 19ms: mem 1008kb: Wrong answer!: 0 puncte\nRulez testul 6: ok: timp 36ms: mem 1420kb: Wrong answer!: 0 puncte\nRulez testul 7: ok: timp 34ms: mem 1448kb: Wrong answer!: 0 puncte\nRulez testul 8: ok: timp 32ms: mem 1364kb: Wrong answer!: 0 puncte\nRulez testul 9: ok: timp 35ms: mem 1532kb: Wrong answer!: 0 puncte\nRulez testul 10: ok: timp 37ms: mem 1532kb: Wrong answer!: 0 puncte\n\nPunctaj total: 20\n',20,'Evaluare completa'),(5239,'eq',1,'cpp','--gone--','done','2007-01-11 22:55:59','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 8ms: mem 1252kb: Incorect: 0 puncte\nRulez testul 5: ok: timp 5ms: mem 468kb: Incorect: 0 puncte\nRulez testul 6: ok: timp 6ms: mem 724kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 6ms: mem 720kb: Incorect: 0 puncte\nRulez testul 8: ok: timp 84ms: mem 732kb: Incorect: 0 puncte\nRulez testul 9: ok: timp 113ms: mem 1256kb: Incorect: 0 puncte\nRulez testul 10: ok: timp 256ms: mem 2332kb: Incorect: 0 puncte\nRulez testul 11: ok: timp 387ms: mem 2340kb: Incorect: 0 puncte\nRulez testul 12: ok: timp 604ms: mem 4428kb: Incorect: 0 puncte\nRulez testul 13: ok: timp 348ms: mem 4460kb: Incorect: 0 puncte\nRulez testul 14: ok: timp 207ms: mem 4464kb: Incorect: 0 puncte\nRulez testul 15: ok: timp 515ms: mem 4488kb: Incorect: 0 puncte\nRulez testul 16: ok: timp 950ms: mem 4520kb: Incorect: 0 puncte\nRulez testul 17: ok: timp 341ms: mem 4524kb: Incorect: 0 puncte\nRulez testul 18: ok: timp 1109ms: mem 4524kb: Incorect: 0 puncte\nRulez testul 19: ok: timp 382ms: mem 4528kb: Incorect: 0 puncte\nRulez testul 20: ok: timp 747ms: mem 8672kb: Incorect: 0 puncte\nRulez testul 21: eroare: timp 1220ms: mem 8680kb: Time limit exceeded.: 0 puncte\nRulez testul 22: eroare: timp 1221ms: mem 8728kb: Time limit exceeded.: 0 puncte\nRulez testul 23: eroare: timp 1216ms: mem 8768kb: Time limit exceeded.: 0 puncte\nRulez testul 24: eroare: timp 1222ms: mem 8768kb: Time limit exceeded.: 0 puncte\nRulez testul 25: eroare: timp 1215ms: mem 8768kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 4\n',4,'Evaluare completa'),(5247,'eq',1,'cpp','--gone--','done','2007-01-12 00:07:38','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 4 puncte\nRulez testul 4: ok: timp 3ms: mem 1036kb: OK: 4 puncte\nRulez testul 5: ok: timp 3ms: mem 420kb: OK: 4 puncte\nRulez testul 6: ok: timp 4ms: mem 620kb: OK: 4 puncte\nRulez testul 7: ok: timp 5ms: mem 612kb: OK: 4 puncte\nRulez testul 8: ok: timp 73ms: mem 632kb: OK: 4 puncte\nRulez testul 9: ok: timp 100ms: mem 1040kb: OK: 4 puncte\nRulez testul 10: ok: timp 221ms: mem 1932kb: OK: 4 puncte\nRulez testul 11: ok: timp 342ms: mem 1948kb: OK: 4 puncte\nRulez testul 12: ok: timp 542ms: mem 3552kb: OK: 4 puncte\nRulez testul 13: ok: timp 295ms: mem 3640kb: OK: 4 puncte\nRulez testul 14: ok: timp 162ms: mem 3652kb: OK: 4 puncte\nRulez testul 15: ok: timp 437ms: mem 3692kb: OK: 4 puncte\nRulez testul 16: ok: timp 851ms: mem 3764kb: OK: 4 puncte\nRulez testul 17: ok: timp 293ms: mem 3772kb: OK: 4 puncte\nRulez testul 18: ok: timp 989ms: mem 3772kb: OK: 4 puncte\nRulez testul 19: ok: timp 320ms: mem 3784kb: OK: 4 puncte\nRulez testul 20: ok: timp 640ms: mem 6968kb: OK: 4 puncte\nRulez testul 21: eroare: timp 1210ms: mem 6984kb: Time limit exceeded.: 0 puncte\nRulez testul 22: eroare: timp 1216ms: mem 7096kb: Time limit exceeded.: 0 puncte\nRulez testul 23: eroare: timp 1221ms: mem 7176kb: Time limit exceeded.: 0 puncte\nRulez testul 24: eroare: timp 1219ms: mem 7176kb: Time limit exceeded.: 0 puncte\nRulez testul 25: eroare: timp 1216ms: mem 7176kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 80\n',80,'Evaluare completa'),(5497,'colectie',2092,'cpp','--gone--','done','2007-01-13 12:49:04','Compilare:\nuser.cpp: In function `void bkt(int)\':\nuser.cpp:58: warning: unused variable `int poz\'\nuser.cpp: In function `void ruleaza()\':\nuser.cpp:145: warning: unused variable `int a\'\nuser.cpp:145: warning: unused variable `int b\'\n\n\nRulez testul 1: ok: timp 9ms: mem 276kb: Chiar exista solutie: 0 puncte\nRulez testul 2: ok: timp 8ms: mem 276kb: Chiar exista solutie: 0 puncte\nRulez testul 3: ok: timp 9ms: mem 276kb: Chiar exista solutie: 0 puncte\nRulez testul 4: ok: timp 8ms: mem 276kb: Chiar exista solutie: 0 puncte\nRulez testul 5: ok: timp 173ms: mem 1728kb: Chiar exista solutie: 0 puncte\nRulez testul 6: ok: timp 567ms: mem 4788kb: Chiar exista solutie: 0 puncte\nRulez testul 7: ok: timp 494ms: mem 4788kb: Chiar exista solutie: 0 puncte\nRulez testul 8: ok: timp 735ms: mem 6320kb: Chiar exista solutie: 0 puncte\nRulez testul 9: ok: timp 746ms: mem 6320kb: Chiar exista solutie: 0 puncte\nRulez testul 10: ok: timp 769ms: mem 6320kb: Chiar exista solutie: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(5515,'colectie',2092,'cpp','--gone--','done','2007-01-13 14:23:59','Compilare:\nuser.cpp: In function `void bkt(int)\':\nuser.cpp:70: warning: unused variable `int poz\'\nuser.cpp: In function `void ruleaza()\':\nuser.cpp:158: warning: unused variable `int a\'\nuser.cpp:158: warning: unused variable `int b\'\n\n\nRulez testul 1: ok: timp 9ms: mem 280kb: OK!: 10 puncte\nRulez testul 2: ok: timp 8ms: mem 280kb: OK!: 10 puncte\nRulez testul 3: ok: timp 8ms: mem 280kb: OK!: 10 puncte\nRulez testul 4: ok: timp 9ms: mem 280kb: OK!: 10 puncte\nRulez testul 5: ok: timp 174ms: mem 1728kb: OK!: 10 puncte\nRulez testul 6: ok: timp 564ms: mem 4792kb: OK!: 10 puncte\nRulez testul 7: ok: timp 497ms: mem 4792kb: OK!: 10 puncte\nRulez testul 8: ok: timp 725ms: mem 6324kb: OK!: 10 puncte\nRulez testul 9: ok: timp 741ms: mem 6324kb: OK!: 10 puncte\nRulez testul 10: ok: timp 763ms: mem 6316kb: OK!: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(5649,'perm4',2092,'c','--gone--','done','2007-01-14 21:36:26','Compilare:\n\n\nRulez testul 1: ok: timp 336ms: mem 180kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 336ms: mem 176kb: Incorect: 0 puncte\nRulez testul 3: ok: timp 156ms: mem 176kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 57ms: mem 176kb: Incorect: 0 puncte\nRulez testul 5: ok: timp 337ms: mem 176kb: Incorect: 0 puncte\nRulez testul 6: ok: timp 205ms: mem 168kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 39ms: mem 168kb: Incorect: 0 puncte\nRulez testul 8: ok: timp 37ms: mem 168kb: Incorect: 0 puncte\nRulez testul 9: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 10: ok: timp 0ms: mem 8kb: OK: 10 puncte\n\nPunctaj total: 20\n',20,'Evaluare completa'),(6160,'perm4',961,'cpp','--gone--','done','2007-01-18 17:19:04','Compilare:\n\n\nRulez testul 1: ok: timp 81ms: mem 204kb: OK: 10 puncte\nRulez testul 2: ok: timp 80ms: mem 200kb: OK: 10 puncte\nRulez testul 3: ok: timp 37ms: mem 200kb: OK: 10 puncte\nRulez testul 4: ok: timp 13ms: mem 192kb: OK: 10 puncte\nRulez testul 5: ok: timp 81ms: mem 200kb: OK: 10 puncte\nRulez testul 6: ok: timp 48ms: mem 188kb: OK: 10 puncte\nRulez testul 7: ok: timp 9ms: mem 192kb: OK: 10 puncte\nRulez testul 8: ok: timp 8ms: mem 192kb: OK: 10 puncte\nRulez testul 9: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 10: ok: timp 0ms: mem 8kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(6316,'zeap',961,'cpp','--gone--','done','2007-01-19 16:29:10','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:177: warning: `int a\' might be used uninitialized in this function\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 12ms: mem 208kb: OK: 10 puncte\nRulez testul 3: ok: timp 978ms: mem 688kb: OK: 10 puncte\nRulez testul 4: ok: timp 1212ms: mem 1104kb: OK: 10 puncte\nRulez testul 5: ok: timp 1278ms: mem 1840kb: OK: 10 puncte\nRulez testul 6: eroare: timp 1712ms: mem 2128kb: Time limit exceeded.: 0 puncte\nRulez testul 7: eroare: timp 1713ms: mem 3728kb: Time limit exceeded.: 0 puncte\nRulez testul 8: ok: timp 1051ms: mem 3284kb: OK: 10 puncte\nRulez testul 9: ok: timp 277ms: mem 788kb: OK: 10 puncte\nRulez testul 10: eroare: timp 1721ms: mem 5140kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 70\n',70,'Evaluare completa'),(6580,'nr',256,'c','--gone--','done','2007-01-20 17:10:00','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 7: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 8: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 9: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 10: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(6613,'Radiatie',1,'cpp','--gone--','done','2007-01-20 20:04:02','Eroare de compilare:\nuser.cpp: In function `int query(int, int)\':\nuser.cpp:87: error: parse error before `:\' token\n',0,'Eroare de compilare'),(6669,'triplete',1,'cpp','--gone--','done','2007-01-20 21:40:18','Compilare:\n\n\nRulez testul 1: ok: timp 6ms: mem 2172kb: OK: 10 puncte\nRulez testul 2: ok: timp 17ms: mem 2264kb: OK: 10 puncte\nRulez testul 3: ok: timp 31ms: mem 2304kb: OK: 10 puncte\nRulez testul 4: ok: timp 50ms: mem 2340kb: OK: 10 puncte\nRulez testul 5: ok: timp 112ms: mem 2480kb: OK: 10 puncte\nRulez testul 6: ok: timp 137ms: mem 2536kb: OK: 10 puncte\nRulez testul 7: ok: timp 158ms: mem 2576kb: OK: 10 puncte\nRulez testul 8: ok: timp 181ms: mem 2616kb: OK: 10 puncte\nRulez testul 9: ok: timp 180ms: mem 2616kb: OK: 10 puncte\nRulez testul 10: ok: timp 234ms: mem 2728kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(6673,'triplete',1,'cpp','--gone--','done','2007-01-20 21:41:51','Compilare:\n\n\nRulez testul 1: ok: timp 5ms: mem 2168kb: OK: 10 puncte\nRulez testul 2: ok: timp 21ms: mem 2264kb: OK: 10 puncte\nRulez testul 3: ok: timp 54ms: mem 2304kb: OK: 10 puncte\nRulez testul 4: ok: timp 117ms: mem 2352kb: OK: 10 puncte\nRulez testul 5: eroare: timp 351ms: mem 2464kb: Time limit exceeded.: 0 puncte\nRulez testul 6: eroare: timp 352ms: mem 2520kb: Time limit exceeded.: 0 puncte\nRulez testul 7: eroare: timp 347ms: mem 2560kb: Time limit exceeded.: 0 puncte\nRulez testul 8: eroare: timp 350ms: mem 2600kb: Time limit exceeded.: 0 puncte\nRulez testul 9: eroare: timp 348ms: mem 2600kb: Time limit exceeded.: 0 puncte\nRulez testul 10: eroare: timp 355ms: mem 2712kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 40\n',40,'Evaluare completa'),(6709,'1-sir',1,'cpp','--gone--','done','2007-01-21 01:35:00','Compilare:\n\n\nRulez testul 1: ok: timp 4ms: mem 684kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 14ms: mem 684kb: Incorect: 0 puncte\nRulez testul 3: ok: timp 29ms: mem 684kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 45ms: mem 684kb: Incorect: 0 puncte\nRulez testul 5: ok: timp 48ms: mem 684kb: Incorect: 0 puncte\nRulez testul 6: ok: timp 94ms: mem 684kb: Incorect: 0 puncte\nRulez testul 7: eroare: timp 132ms: mem 684kb: Time limit exceeded.: 0 puncte\nRulez testul 8: eroare: timp 151ms: mem 668kb: Time limit exceeded.: 0 puncte\nRulez testul 9: eroare: timp 152ms: mem 668kb: Time limit exceeded.: 0 puncte\nRulez testul 10: eroare: timp 151ms: mem 668kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(6716,'1-sir',1,'cpp','--gone--','done','2007-01-21 02:02:38','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 1ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 7ms: mem 256kb: OK: 10 puncte\nRulez testul 5: ok: timp 6ms: mem 256kb: OK: 10 puncte\nRulez testul 6: ok: timp 22ms: mem 360kb: OK: 10 puncte\nRulez testul 7: ok: timp 60ms: mem 488kb: OK: 10 puncte\nRulez testul 8: ok: timp 103ms: mem 528kb: OK: 10 puncte\nRulez testul 9: ok: timp 249ms: mem 684kb: OK: 10 puncte\nRulez testul 10: ok: timp 261ms: mem 684kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(6779,'pachete',2986,'cpp','--gone--','done','2007-01-21 09:04:22','Eroare de compilare:\nuser.cpp:3: error: `long int y0\' redeclared as different kind of symbol\n/usr/include/bits/mathcalls.h:241: error: previous declaration of `double \n   y0(double)\'\nuser.cpp:68:2: warning: no newline at end of file\n',0,'Eroare de compilare'),(6786,'triplete',142,'cpp','--gone--','done','2007-01-21 09:07:41','Compilare:\nuser.cpp: In function `void dfs(int, int)\':\nuser.cpp:43: warning: comparison between signed and unsigned integer \n   expressions\n\n\nRulez testul 1: ok: timp 10ms: mem 412kb: OK: 10 puncte\nRulez testul 2: ok: timp 287ms: mem 508kb: OK: 10 puncte\nRulez testul 3: eroare: timp 356ms: mem 556kb: Time limit exceeded.: 0 puncte\nRulez testul 4: eroare: timp 355ms: mem 696kb: Time limit exceeded.: 0 puncte\nRulez testul 5: eroare: timp 353ms: mem 1016kb: Time limit exceeded.: 0 puncte\nRulez testul 6: eroare: timp 350ms: mem 1148kb: Time limit exceeded.: 0 puncte\nRulez testul 7: eroare: timp 348ms: mem 1200kb: Time limit exceeded.: 0 puncte\nRulez testul 8: eroare: timp 350ms: mem 1224kb: Time limit exceeded.: 0 puncte\nRulez testul 9: eroare: timp 350ms: mem 1220kb: Time limit exceeded.: 0 puncte\nRulez testul 10: eroare: timp 348ms: mem 1644kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 20\n',20,'Evaluare completa'),(6945,'pachete',142,'cpp','--gone--','done','2007-01-21 10:50:35','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 7ms: mem 200kb: Incorect: 0 puncte\nRulez testul 5: ok: timp 93ms: mem 1572kb: Incorect: 0 puncte\nRulez testul 6: ok: timp 107ms: mem 1564kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 20ms: mem 684kb: Incorect: 0 puncte\nRulez testul 8: ok: timp 40ms: mem 908kb: Incorect: 0 puncte\nRulez testul 9: ok: timp 93ms: mem 1568kb: Incorect: 0 puncte\nRulez testul 10: ok: timp 58ms: mem 1124kb: Incorect: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(7131,'radiatie',1024,'cpp','--gone--','done','2007-01-21 11:30:53','Compilare:\nuser.cpp: In function `void Solve(int, int)\':\nuser.cpp:92: warning: statement with no effect\nuser.cpp:96: warning: statement with no effect\nuser.cpp: In function `void Kap(int)\':\nuser.cpp:152: warning: unused variable `int n1\'\nuser.cpp:152: warning: unused variable `int n2\'\n\n\nRulez testul 1: ok: timp 3ms: mem 8kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 147ms: mem 216kb: Incorect: 0 puncte\nRulez testul 3: eroare: timp 560ms: mem 268kb: Time limit exceeded.: 0 puncte\nRulez testul 4: eroare: timp 558ms: mem 348kb: Time limit exceeded.: 0 puncte\nRulez testul 5: eroare: timp 558ms: mem 612kb: Time limit exceeded.: 0 puncte\nRulez testul 6: eroare: timp 557ms: mem 752kb: Time limit exceeded.: 0 puncte\nRulez testul 7: eroare: timp 514ms: mem 668kb: Time limit exceeded.: 0 puncte\nRulez testul 8: eroare: timp 557ms: mem 876kb: Time limit exceeded.: 0 puncte\nRulez testul 9: eroare: timp 556ms: mem 1344kb: Time limit exceeded.: 0 puncte\nRulez testul 10: eroare: timp 555ms: mem 1336kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(7164,'elimin',1,'cpp','--gone--','done','2007-01-21 13:06:34','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 3ms: mem 8kb: OK: 10 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 6: ok: timp 4ms: mem 232kb: OK: 10 puncte\nRulez testul 7: ok: timp 115ms: mem 252kb: OK: 10 puncte\nRulez testul 8: ok: timp 35ms: mem 244kb: OK: 10 puncte\nRulez testul 9: ok: timp 85ms: mem 312kb: OK: 10 puncte\nRulez testul 10: ok: timp 205ms: mem 292kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(7176,'elimin',1,'cpp','--gone--','done','2007-01-21 13:16:30','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 2ms: mem 8kb: OK: 10 puncte\nRulez testul 5: ok: timp 1ms: mem 8kb: OK: 10 puncte\nRulez testul 6: ok: timp 4ms: mem 232kb: OK: 10 puncte\nRulez testul 7: ok: timp 112ms: mem 252kb: OK: 10 puncte\nRulez testul 8: ok: timp 36ms: mem 244kb: OK: 10 puncte\nRulez testul 9: ok: timp 88ms: mem 312kb: OK: 10 puncte\nRulez testul 10: ok: timp 205ms: mem 292kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(7179,'elimin',2524,'cpp','--gone--','done','2007-01-21 13:28:37','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 7: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 8: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 9: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\nRulez testul 10: ok: timp 0ms: mem 8kb: Fisier de iesire lipsa: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(7262,'triplete',256,'c','--gone--','done','2007-01-21 14:46:45','Compilare:\n\n\nRulez testul 1: eroare: timp 10ms: mem 392kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 2: eroare: timp 14ms: mem 392kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 3: eroare: timp 15ms: mem 1168kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 4: eroare: timp 23ms: mem 1572kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 5: eroare: timp 44ms: mem 2736kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 6: eroare: timp 56ms: mem 3280kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 7: eroare: timp 65ms: mem 3820kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 8: ok: timp 172ms: mem 4896kb: Incorect: 0 puncte\nRulez testul 9: ok: timp 173ms: mem 4896kb: Incorect: 0 puncte\nRulez testul 10: eroare: timp 120ms: mem 5084kb: Killed by signal 11(SIGSEGV).: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(7289,'aprindere',256,'c','--gone--','done','2007-01-21 15:11:21','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 7: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 8: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 9: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 10: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 11: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 12: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 13: ok: timp 2ms: mem 8kb: OK: 5 puncte\nRulez testul 14: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 15: ok: timp 4ms: mem 152kb: OK: 5 puncte\nRulez testul 16: ok: timp 4ms: mem 152kb: OK: 5 puncte\nRulez testul 17: ok: timp 20ms: mem 152kb: OK: 5 puncte\nRulez testul 18: ok: timp 2ms: mem 8kb: OK: 5 puncte\nRulez testul 19: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 20: ok: timp 1ms: mem 8kb: OK: 5 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(7335,'triplete',2092,'c','--gone--','done','2007-01-21 18:09:10','Compilare:\nuser.c: In function `solve\':\nuser.c:33: warning: unused variable `y\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 3ms: mem 560kb: OK: 10 puncte\nRulez testul 3: ok: timp 11ms: mem 732kb: OK: 10 puncte\nRulez testul 4: ok: timp 16ms: mem 896kb: OK: 10 puncte\nRulez testul 5: ok: timp 50ms: mem 1356kb: Incorect: 0 puncte\nRulez testul 6: eroare: timp 36ms: mem 972kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 7: eroare: timp 41ms: mem 1036kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 8: eroare: timp 48ms: mem 1180kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 9: eroare: timp 42ms: mem 1320kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 10: eroare: timp 58ms: mem 1196kb: Killed by signal 11(SIGSEGV).: 0 puncte\n\nPunctaj total: 40\n',40,'Evaluare completa'),(7343,'triplete',2092,'c','--gone--','done','2007-01-21 18:18:33','Compilare:\nuser.c: In function `solve\':\nuser.c:39: warning: unused variable `y\'\n\n\nRulez testul 1: ok: timp 1ms: mem 108kb: OK: 10 puncte\nRulez testul 2: ok: timp 3ms: mem 624kb: OK: 10 puncte\nRulez testul 3: ok: timp 9ms: mem 896kb: OK: 10 puncte\nRulez testul 4: ok: timp 19ms: mem 1148kb: OK: 10 puncte\nRulez testul 5: ok: timp 57ms: mem 1880kb: OK: 10 puncte\nRulez testul 6: ok: timp 71ms: mem 2204kb: OK: 10 puncte\nRulez testul 7: ok: timp 94ms: mem 2504kb: OK: 10 puncte\nRulez testul 8: ok: timp 122ms: mem 3084kb: OK: 10 puncte\nRulez testul 9: ok: timp 119ms: mem 3080kb: OK: 10 puncte\nRulez testul 10: ok: timp 161ms: mem 3320kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(7558,'maxsecv',48,'cpp','--gone--','done','2007-01-22 18:37:17','Compilare:\nuser.cpp:47:2: warning: no newline at end of file\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 2ms: mem 8kb: OK: 10 puncte\nRulez testul 5: ok: timp 28ms: mem 964kb: OK: 10 puncte\nRulez testul 6: ok: timp 57ms: mem 1744kb: OK: 10 puncte\nRulez testul 7: ok: timp 144ms: mem 4088kb: OK: 10 puncte\nRulez testul 8: ok: timp 227ms: mem 6432kb: OK: 10 puncte\nRulez testul 9: ok: timp 256ms: mem 7216kb: OK: 10 puncte\nRulez testul 10: ok: timp 294ms: mem 7992kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(7807,'patrate3',2092,'c','--gone--','done','2007-01-23 18:51:18','Compilare:\n\n\nRulez testul 1: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 7: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 8: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 9: ok: timp 4ms: mem 180kb: OK: 5 puncte\nRulez testul 10: ok: timp 4ms: mem 180kb: OK: 5 puncte\nRulez testul 11: ok: timp 37ms: mem 184kb: OK: 5 puncte\nRulez testul 12: ok: timp 39ms: mem 184kb: Incorect: 0 puncte\nRulez testul 13: ok: timp 39ms: mem 184kb: OK: 5 puncte\nRulez testul 14: ok: timp 45ms: mem 184kb: Incorect: 0 puncte\nRulez testul 15: ok: timp 45ms: mem 184kb: Incorect: 0 puncte\nRulez testul 16: ok: timp 47ms: mem 184kb: Incorect: 0 puncte\nRulez testul 17: ok: timp 49ms: mem 172kb: Incorect: 0 puncte\nRulez testul 18: ok: timp 52ms: mem 172kb: Incorect: 0 puncte\nRulez testul 19: ok: timp 68ms: mem 188kb: OK: 5 puncte\nRulez testul 20: ok: timp 69ms: mem 188kb: OK: 5 puncte\n\nPunctaj total: 70\n',70,'Evaluare completa'),(7939,'domino',2092,'c','--gone--','done','2007-01-23 22:05:41','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Too few lines!: 0 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 5: ok: timp 29ms: mem 936kb: Too few lines!: 0 puncte\nRulez testul 6: ok: timp 55ms: mem 2560kb: All OK!: 5 puncte\nRulez testul 7: ok: timp 66ms: mem 2924kb: All OK!: 5 puncte\nRulez testul 8: ok: timp 66ms: mem 2924kb: All OK!: 5 puncte\nRulez testul 9: ok: timp 53ms: mem 1932kb: All OK!: 5 puncte\nRulez testul 10: ok: timp 28ms: mem 1104kb: All OK!: 5 puncte\nRulez testul 11: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 12: ok: timp 1ms: mem 8kb: All OK!: 5 puncte\nRulez testul 13: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 14: ok: timp 1ms: mem 8kb: All OK!: 5 puncte\nRulez testul 15: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 16: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 17: ok: timp 1ms: mem 8kb: All OK!: 5 puncte\nRulez testul 18: ok: timp 14ms: mem 1056kb: All OK!: 5 puncte\nRulez testul 19: ok: timp 43ms: mem 1964kb: All OK!: 5 puncte\nRulez testul 20: ok: timp 55ms: mem 2364kb: All OK!: 5 puncte\n\nPunctaj total: 90\n',90,'Evaluare completa'),(7946,'domino',2092,'c','--gone--','done','2007-01-23 23:03:27','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 7: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 8: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 9: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 10: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 11: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 12: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 13: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 14: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 15: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 16: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 17: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 18: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 19: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\nRulez testul 20: ok: timp 0ms: mem 8kb: Wrong answer!: 0 puncte\n\nPunctaj total: 5\n',5,'Evaluare completa'),(7948,'domino',2092,'c','--gone--','done','2007-01-23 23:06:52','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Too few lines!: 0 puncte\nRulez testul 4: ok: timp 1ms: mem 8kb: All OK!: 5 puncte\nRulez testul 5: ok: timp 27ms: mem 748kb: Too few lines!: 0 puncte\nRulez testul 6: ok: timp 55ms: mem 2764kb: All OK!: 5 puncte\nRulez testul 7: ok: timp 62ms: mem 3088kb: All OK!: 5 puncte\nRulez testul 8: ok: timp 63ms: mem 3088kb: All OK!: 5 puncte\nRulez testul 9: ok: timp 51ms: mem 2116kb: All OK!: 5 puncte\nRulez testul 10: ok: timp 29ms: mem 1148kb: All OK!: 5 puncte\nRulez testul 11: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 12: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 13: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 14: ok: timp 0ms: mem 8kb: All OK!: 5 puncte\nRulez testul 15: ok: timp 1ms: mem 8kb: All OK!: 5 puncte\nRulez testul 16: ok: timp 1ms: mem 8kb: All OK!: 5 puncte\nRulez testul 17: ok: timp 2ms: mem 8kb: All OK!: 5 puncte\nRulez testul 18: ok: timp 14ms: mem 1112kb: All OK!: 5 puncte\nRulez testul 19: ok: timp 45ms: mem 2112kb: All OK!: 5 puncte\nRulez testul 20: ok: timp 54ms: mem 2600kb: All OK!: 5 puncte\n\nPunctaj total: 90\n',90,'Evaluare completa'),(8240,'aprindere',18,'cpp','--gone--','done','2007-01-24 22:50:24','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 6: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 7: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 8: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 9: ok: timp 0ms: mem 8kb: OK: 5 puncte\nRulez testul 10: ok: timp 2ms: mem 8kb: OK: 5 puncte\nRulez testul 11: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 12: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 13: ok: timp 2ms: mem 8kb: OK: 5 puncte\nRulez testul 14: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 15: ok: timp 4ms: mem 368kb: OK: 5 puncte\nRulez testul 16: ok: timp 6ms: mem 368kb: OK: 5 puncte\nRulez testul 17: ok: timp 20ms: mem 628kb: OK: 5 puncte\nRulez testul 18: ok: timp 4ms: mem 384kb: OK: 5 puncte\nRulez testul 19: ok: timp 1ms: mem 8kb: OK: 5 puncte\nRulez testul 20: ok: timp 2ms: mem 8kb: OK: 5 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(8599,'fact',5695,'cpp','--gone--','done','2007-01-26 11:16:56','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:4: warning: unused variable `long unsigned int y\'\nuser.cpp:23:2: warning: no newline at end of file\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Raspuns incorect: 0 puncte\nRulez testul 2: ok: timp 1ms: mem 8kb: Corect!: 5 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Raspuns incorect: 0 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: Raspuns incorect: 0 puncte\nRulez testul 5: eroare: timp 558ms: mem 160kb: Time limit exceeded.: 0 puncte\nRulez testul 6: eroare: timp 559ms: mem 160kb: Time limit exceeded.: 0 puncte\nRulez testul 7: ok: timp 13ms: mem 160kb: Corect!: 5 puncte\nRulez testul 8: ok: timp 34ms: mem 160kb: Corect!: 5 puncte\nRulez testul 9: ok: timp 334ms: mem 160kb: Corect!: 5 puncte\nRulez testul 10: ok: timp 453ms: mem 160kb: Raspuns incorect: 0 puncte\nRulez testul 11: ok: timp 110ms: mem 160kb: Raspuns incorect: 0 puncte\nRulez testul 12: eroare: timp 558ms: mem 160kb: Time limit exceeded.: 0 puncte\nRulez testul 13: ok: timp 353ms: mem 160kb: Corect!: 5 puncte\nRulez testul 14: eroare: timp 559ms: mem 160kb: Time limit exceeded.: 0 puncte\nRulez testul 15: ok: timp 58ms: mem 160kb: Raspuns incorect: 0 puncte\nRulez testul 16: ok: timp 205ms: mem 160kb: Corect!: 5 puncte\nRulez testul 17: ok: timp 141ms: mem 160kb: Corect!: 5 puncte\nRulez testul 18: ok: timp 139ms: mem 160kb: Corect!: 5 puncte\nRulez testul 19: ok: timp 208ms: mem 160kb: Corect!: 5 puncte\nRulez testul 20: ok: timp 365ms: mem 160kb: Raspuns incorect: 0 puncte\n\nPunctaj total: 45\n',45,'Evaluare completa'),(8745,'chernel',18,'cpp','--gone--','done','2007-01-26 20:46:29','\nEroare de sistem.\nVa rugam sa postati pe forum si sa mentionati id-ul job-ului.',0,'System error'),(8758,'amenzi',961,'cpp','--gone--','done','2007-01-26 23:05:26','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:46: warning: comparison between signed and unsigned integer \n   expressions\n\n\nRulez testul 1: ok: timp 10ms: mem 2416kb: OK: 10 puncte\nRulez testul 2: ok: timp 22ms: mem 3248kb: OK: 10 puncte\nRulez testul 3: ok: timp 54ms: mem 2472kb: OK: 10 puncte\nRulez testul 4: ok: timp 56ms: mem 2576kb: OK: 10 puncte\nRulez testul 5: ok: timp 65ms: mem 2444kb: OK: 10 puncte\nRulez testul 6: ok: timp 68ms: mem 3208kb: OK: 10 puncte\nRulez testul 7: ok: timp 47ms: mem 3912kb: OK: 10 puncte\nRulez testul 8: ok: timp 92ms: mem 2968kb: OK: 10 puncte\nRulez testul 9: ok: timp 103ms: mem 2536kb: OK: 10 puncte\nRulez testul 10: ok: timp 102ms: mem 2548kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(8769,'maxsecv',1,'cpp','--gone--','done','2007-01-27 00:39:54','Compilare:\n\n\nRulez testul 1: ok: timp 1ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 2ms: mem 8kb: OK: 10 puncte\nRulez testul 5: ok: timp 30ms: mem 532kb: OK: 10 puncte\nRulez testul 6: ok: timp 57ms: mem 932kb: OK: 10 puncte\nRulez testul 7: ok: timp 142ms: mem 2136kb: OK: 10 puncte\nRulez testul 8: ok: timp 225ms: mem 3308kb: OK: 10 puncte\nRulez testul 9: ok: timp 248ms: mem 3700kb: OK: 10 puncte\nRulez testul 10: ok: timp 284ms: mem 4088kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(8777,'amenzi',1,'cpp','--gone--','done','2007-01-27 01:41:13','Compilare:\n\n\nRulez testul 1: ok: timp 8ms: mem 2036kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 27ms: mem 2832kb: Incorect: 0 puncte\nRulez testul 3: eroare: timp 0ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 4: ok: timp 89ms: mem 2164kb: Incorect: 0 puncte\nRulez testul 5: ok: timp 100ms: mem 2060kb: Incorect: 0 puncte\nRulez testul 6: ok: timp 113ms: mem 2704kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 71ms: mem 3264kb: Incorect: 0 puncte\nRulez testul 8: eroare: timp 0ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 9: ok: timp 168ms: mem 2132kb: Incorect: 0 puncte\nRulez testul 10: eroare: timp 1ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(8817,'amenzi',1,'cpp','--gone--','done','2007-01-27 10:49:49','Compilare:\n\n\nRulez testul 1: ok: timp 10ms: mem 2424kb: OK: 10 puncte\nRulez testul 2: ok: timp 38ms: mem 3296kb: OK: 10 puncte\nRulez testul 3: ok: timp 117ms: mem 2480kb: OK: 10 puncte\nRulez testul 4: ok: timp 120ms: mem 2596kb: OK: 10 puncte\nRulez testul 5: ok: timp 186ms: mem 2736kb: OK: 10 puncte\nRulez testul 6: ok: timp 162ms: mem 3356kb: OK: 10 puncte\nRulez testul 7: ok: timp 220ms: mem 3224kb: OK: 10 puncte\nRulez testul 8: ok: timp 243ms: mem 4016kb: OK: 10 puncte\nRulez testul 9: ok: timp 249ms: mem 3180kb: OK: 10 puncte\nRulez testul 10: ok: timp 245ms: mem 2820kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(9016,'amenzi',2524,'cpp','--gone--','done','2007-01-27 13:36:42','Compilare:\n\n\nRulez testul 1: ok: timp 7ms: mem 2372kb: OK: 10 puncte\nRulez testul 2: ok: timp 9ms: mem 2380kb: OK: 10 puncte\nRulez testul 3: ok: timp 38ms: mem 2384kb: OK: 10 puncte\nRulez testul 4: ok: timp 25ms: mem 2384kb: OK: 10 puncte\nRulez testul 5: ok: timp 36ms: mem 2384kb: OK: 10 puncte\nRulez testul 6: ok: timp 31ms: mem 2388kb: OK: 10 puncte\nRulez testul 7: ok: timp 46ms: mem 2428kb: OK: 10 puncte\nRulez testul 8: ok: timp 56ms: mem 2472kb: OK: 10 puncte\nRulez testul 9: ok: timp 56ms: mem 2452kb: OK: 10 puncte\nRulez testul 10: eroare: timp 9ms: mem 280kb: Killed by signal 11(SIGSEGV).: 0 puncte\n\nPunctaj total: 90\n',90,'Evaluare completa'),(9226,'amenzi',2092,'c','--gone--','done','2007-01-27 14:36:15','Compilare:\nuser.c: In function `solve\':\nuser.c:19: warning: unused variable `k\'\n\n\nRulez testul 1: ok: timp 6ms: mem 2548kb: OK: 10 puncte\nRulez testul 2: ok: timp 23ms: mem 3664kb: OK: 10 puncte\nRulez testul 3: ok: timp 47ms: mem 2908kb: OK: 10 puncte\nRulez testul 4: ok: timp 51ms: mem 3064kb: OK: 10 puncte\nRulez testul 5: ok: timp 82ms: mem 3384kb: OK: 10 puncte\nRulez testul 6: ok: timp 72ms: mem 4236kb: OK: 10 puncte\nRulez testul 7: ok: timp 85ms: mem 3828kb: OK: 10 puncte\nRulez testul 8: ok: timp 102ms: mem 4144kb: OK: 10 puncte\nRulez testul 9: ok: timp 106ms: mem 4772kb: OK: 10 puncte\nRulez testul 10: ok: timp 110ms: mem 3732kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(9541,'amenzi',75,'cpp','--gone--','done','2007-01-27 17:59:57','Compilare:\n\n\nRulez testul 1: ok: timp 18ms: mem 4500kb: OK: 10 puncte\nRulez testul 2: ok: timp 33ms: mem 5588kb: OK: 10 puncte\nRulez testul 3: ok: timp 69ms: mem 4600kb: OK: 10 puncte\nRulez testul 4: ok: timp 70ms: mem 4820kb: OK: 10 puncte\nRulez testul 5: ok: timp 151ms: mem 5024kb: OK: 10 puncte\nRulez testul 6: ok: timp 96ms: mem 6064kb: OK: 10 puncte\nRulez testul 7: ok: timp 122ms: mem 5596kb: OK: 10 puncte\nRulez testul 8: ok: timp 138ms: mem 5884kb: OK: 10 puncte\nRulez testul 9: ok: timp 158ms: mem 6864kb: OK: 10 puncte\nRulez testul 10: ok: timp 145ms: mem 5256kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(9549,'secv5',75,'cpp','--gone--','done','2007-01-27 18:04:32','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:21: warning: unused variable `char buf[32]\'\nuser.cpp:23: warning: unused variable `int siz\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 3ms: mem 224kb: Incorect: 0 puncte\nRulez testul 3: ok: timp 15ms: mem 328kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 61ms: mem 808kb: Incorect: 0 puncte\nRulez testul 5: ok: timp 90ms: mem 1008kb: Incorect: 0 puncte\nRulez testul 6: ok: timp 275ms: mem 2672kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 726ms: mem 5872kb: Incorect: 0 puncte\nRulez testul 8: ok: timp 798ms: mem 6824kb: Incorect: 0 puncte\nRulez testul 9: ok: timp 1385ms: mem 9688kb: Incorect: 0 puncte\nRulez testul 10: ok: timp 1265ms: mem 9368kb: Incorect: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(9550,'secv5',75,'cpp','--gone--','done','2007-01-27 18:05:43','Compilare:\nuser.cpp: In function `int main()\':\nuser.cpp:21: warning: unused variable `char buf[32]\'\nuser.cpp:23: warning: unused variable `int siz\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 4ms: mem 232kb: OK: 10 puncte\nRulez testul 3: ok: timp 16ms: mem 352kb: OK: 10 puncte\nRulez testul 4: ok: timp 70ms: mem 920kb: OK: 10 puncte\nRulez testul 5: ok: timp 100ms: mem 1048kb: OK: 10 puncte\nRulez testul 6: ok: timp 424ms: mem 3120kb: OK: 10 puncte\nRulez testul 7: ok: timp 993ms: mem 6352kb: OK: 10 puncte\nRulez testul 8: ok: timp 1141ms: mem 7216kb: OK: 10 puncte\nRulez testul 9: eroare: timp 1525ms: mem 7984kb: Time limit exceeded.: 0 puncte\nRulez testul 10: eroare: timp 1520ms: mem 10368kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 80\n',80,'Evaluare completa'),(9663,'secv5',2092,'cpp','--gone--','done','2007-01-27 19:31:07','Compilare:\nuser.cpp: In function `int get_pos(unsigned int)\':\nuser.cpp:18: warning: `int r\' might be used uninitialized in this function\nuser.cpp: In function `void solve()\':\nuser.cpp:33: warning: unused variable `unsigned int v\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 4ms: mem 232kb: Incorect: 0 puncte\nRulez testul 3: eroare: timp 1ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 4: eroare: timp 0ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 5: eroare: timp 3ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 6: eroare: timp 3ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 7: eroare: timp 2ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 8: eroare: timp 1ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 9: eroare: timp 2ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 10: eroare: timp 1ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\n\nPunctaj total: 10\n',10,'Evaluare completa'),(9671,'secv5',2092,'cpp','--gone--','done','2007-01-27 19:33:51','Compilare:\nuser.cpp: In function `int get_pos(unsigned int)\':\nuser.cpp:18: warning: `int r\' might be used uninitialized in this function\nuser.cpp: In function `void solve()\':\nuser.cpp:33: warning: unused variable `unsigned int v\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 5ms: mem 244kb: OK: 10 puncte\nRulez testul 3: ok: timp 19ms: mem 364kb: OK: 10 puncte\nRulez testul 4: ok: timp 87ms: mem 932kb: OK: 10 puncte\nRulez testul 5: ok: timp 108ms: mem 1060kb: OK: 10 puncte\nRulez testul 6: ok: timp 658ms: mem 3132kb: OK: 10 puncte\nRulez testul 7: eroare: timp 1559ms: mem 6352kb: Time limit exceeded.: 0 puncte\nRulez testul 8: eroare: timp 1556ms: mem 7216kb: Time limit exceeded.: 0 puncte\nRulez testul 9: eroare: timp 1532ms: mem 11376kb: Time limit exceeded.: 0 puncte\nRulez testul 10: eroare: timp 1512ms: mem 10376kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 60\n',60,'Evaluare completa'),(9745,'chernel',2092,'c','--gone--','done','2007-01-27 21:23:16','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 2ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 194ms: mem 184kb: OK: 10 puncte\nRulez testul 5: eroare: timp 533ms: mem 240kb: Time limit exceeded.: 0 puncte\nRulez testul 6: eroare: timp 0ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 7: ok: timp 438ms: mem 252kb: OK: 10 puncte\nRulez testul 8: eroare: timp 560ms: mem 244kb: Time limit exceeded.: 0 puncte\nRulez testul 9: ok: timp 38ms: mem 252kb: Incorect: 0 puncte\nRulez testul 10: eroare: timp 559ms: mem 244kb: Time limit exceeded.: 0 puncte\n\nPunctaj total: 50\n',50,'Evaluare completa'),(9780,'chernel',2092,'c','--gone--','done','2007-01-27 21:55:33','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 58ms: mem 312kb: OK: 10 puncte\nRulez testul 5: ok: timp 165ms: mem 604kb: OK: 10 puncte\nRulez testul 6: eroare: timp 1ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 7: ok: timp 127ms: mem 652kb: OK: 10 puncte\nRulez testul 8: ok: timp 220ms: mem 648kb: OK: 10 puncte\nRulez testul 9: ok: timp 32ms: mem 648kb: OK: 10 puncte\nRulez testul 10: ok: timp 307ms: mem 644kb: OK: 10 puncte\n\nPunctaj total: 90\n',90,'Evaluare completa'),(9790,'chernel',2092,'c','--gone--','done','2007-01-27 22:02:50','Compilare:\nuser.c: In function `main\':\nuser.c:21: warning: unused variable `j\'\nuser.c:21: warning: unused variable `t\'\nuser.c:21: warning: unused variable `oldt\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 6: eroare: timp 1ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 7: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 8: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 9: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 10: ok: timp 1ms: mem 8kb: Incorect: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(9796,'chernel',2092,'c','--gone--','done','2007-01-27 22:07:06','Compilare:\nuser.c: In function `main\':\nuser.c:23: warning: unused variable `j\'\nuser.c:23: warning: unused variable `p\'\nuser.c:23: warning: unused variable `t\'\nuser.c:23: warning: unused variable `oldt\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 5: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 6: eroare: timp 3ms: mem 8kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 7: ok: timp 2ms: mem 8kb: Incorect: 0 puncte\nRulez testul 8: ok: timp 2ms: mem 8kb: Incorect: 0 puncte\nRulez testul 9: ok: timp 1ms: mem 8kb: Incorect: 0 puncte\nRulez testul 10: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa'),(9800,'chernel',2092,'c','--gone--','done','2007-01-27 22:11:58','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 58ms: mem 312kb: OK: 10 puncte\nRulez testul 5: ok: timp 164ms: mem 604kb: OK: 10 puncte\nRulez testul 6: eroare: timp 7ms: mem 2840kb: Killed by signal 11(SIGSEGV).: 0 puncte\nRulez testul 7: ok: timp 127ms: mem 652kb: OK: 10 puncte\nRulez testul 8: ok: timp 219ms: mem 648kb: OK: 10 puncte\nRulez testul 9: ok: timp 32ms: mem 648kb: OK: 10 puncte\nRulez testul 10: ok: timp 310ms: mem 652kb: OK: 10 puncte\n\nPunctaj total: 90\n',90,'Evaluare completa'),(9809,'maxsecv',2092,'c','--gone--','done','2007-01-27 22:32:19','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 1ms: mem 8kb: OK: 10 puncte\nRulez testul 5: ok: timp 14ms: mem 248kb: OK: 10 puncte\nRulez testul 6: ok: timp 32ms: mem 1140kb: OK: 10 puncte\nRulez testul 7: ok: timp 78ms: mem 2604kb: OK: 10 puncte\nRulez testul 8: ok: timp 124ms: mem 4072kb: OK: 10 puncte\nRulez testul 9: ok: timp 137ms: mem 4556kb: OK: 10 puncte\nRulez testul 10: ok: timp 158ms: mem 5044kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(9869,'secv5',2092,'c','--gone--','done','2007-01-28 09:57:09','Compilare:\nuser.c: In function `solve\':\nuser.c:74: warning: unused variable `x\'\nuser.c:74: warning: unused variable `v\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 11ms: mem 4036kb: OK: 10 puncte\nRulez testul 3: ok: timp 34ms: mem 9068kb: OK: 10 puncte\nRulez testul 4: ok: timp 91ms: mem 16116kb: OK: 10 puncte\nRulez testul 5: ok: timp 97ms: mem 11524kb: OK: 10 puncte\nRulez testul 6: ok: timp 311ms: mem 17704kb: OK: 10 puncte\nRulez testul 7: ok: timp 748ms: mem 19340kb: OK: 10 puncte\nRulez testul 8: ok: timp 813ms: mem 19700kb: OK: 10 puncte\nRulez testul 9: ok: timp 1290ms: mem 23080kb: OK: 10 puncte\nRulez testul 10: ok: timp 1298ms: mem 21896kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(9874,'secv5',2092,'c','--gone--','done','2007-01-28 10:02:24','Compilare:\nuser.c: In function `solve\':\nuser.c:74: warning: unused variable `x\'\nuser.c:74: warning: unused variable `v\'\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 11ms: mem 3772kb: OK: 10 puncte\nRulez testul 3: ok: timp 30ms: mem 7548kb: OK: 10 puncte\nRulez testul 4: ok: timp 86ms: mem 13088kb: OK: 10 puncte\nRulez testul 5: ok: timp 86ms: mem 9832kb: OK: 10 puncte\nRulez testul 6: ok: timp 304ms: mem 14580kb: OK: 10 puncte\nRulez testul 7: ok: timp 714ms: mem 16220kb: OK: 10 puncte\nRulez testul 8: ok: timp 831ms: mem 16572kb: OK: 10 puncte\nRulez testul 9: ok: timp 1283ms: mem 19952kb: OK: 10 puncte\nRulez testul 10: ok: timp 1293ms: mem 18768kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(10078,'maxsecv',256,'c','--gone--','done','2007-01-28 15:18:27','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 2ms: mem 8kb: OK: 10 puncte\nRulez testul 5: ok: timp 27ms: mem 156kb: OK: 10 puncte\nRulez testul 6: ok: timp 56ms: mem 148kb: OK: 10 puncte\nRulez testul 7: ok: timp 135ms: mem 148kb: OK: 10 puncte\nRulez testul 8: ok: timp 222ms: mem 148kb: OK: 10 puncte\nRulez testul 9: ok: timp 240ms: mem 148kb: OK: 10 puncte\nRulez testul 10: ok: timp 276ms: mem 148kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(10105,'chernel',256,'c','--gone--','done','2007-01-28 16:01:37','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 16ms: mem 156kb: OK: 10 puncte\nRulez testul 5: ok: timp 41ms: mem 156kb: OK: 10 puncte\nRulez testul 6: ok: timp 412ms: mem 156kb: OK: 10 puncte\nRulez testul 7: ok: timp 42ms: mem 156kb: OK: 10 puncte\nRulez testul 8: ok: timp 64ms: mem 156kb: OK: 10 puncte\nRulez testul 9: ok: timp 9ms: mem 156kb: OK: 10 puncte\nRulez testul 10: ok: timp 106ms: mem 156kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(10122,'amenzi',256,'cpp','--gone--','done','2007-01-28 16:34:24','Compilare:\n\n\nRulez testul 1: ok: timp 15ms: mem 2556kb: OK: 10 puncte\nRulez testul 2: ok: timp 28ms: mem 3944kb: OK: 10 puncte\nRulez testul 3: ok: timp 45ms: mem 2996kb: OK: 10 puncte\nRulez testul 4: ok: timp 51ms: mem 3532kb: OK: 10 puncte\nRulez testul 5: ok: timp 74ms: mem 3508kb: OK: 10 puncte\nRulez testul 6: ok: timp 67ms: mem 5132kb: OK: 10 puncte\nRulez testul 7: ok: timp 88ms: mem 6892kb: OK: 10 puncte\nRulez testul 8: ok: timp 99ms: mem 8276kb: OK: 10 puncte\nRulez testul 9: ok: timp 115ms: mem 11532kb: OK: 10 puncte\nRulez testul 10: ok: timp 111ms: mem 5788kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(10148,'maxsecv',2524,'cpp','--gone--','done','2007-01-28 17:43:40','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 2ms: mem 8kb: OK: 10 puncte\nRulez testul 5: ok: timp 25ms: mem 168kb: OK: 10 puncte\nRulez testul 6: ok: timp 52ms: mem 168kb: OK: 10 puncte\nRulez testul 7: ok: timp 130ms: mem 168kb: OK: 10 puncte\nRulez testul 8: ok: timp 199ms: mem 168kb: OK: 10 puncte\nRulez testul 9: ok: timp 233ms: mem 168kb: OK: 10 puncte\nRulez testul 10: ok: timp 259ms: mem 168kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(10218,'chernel',1,'cpp','--gone--','done','2007-01-28 21:20:26','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 3: ok: timp 0ms: mem 8kb: OK: 10 puncte\nRulez testul 4: ok: timp 16ms: mem 172kb: OK: 10 puncte\nRulez testul 5: ok: timp 40ms: mem 172kb: OK: 10 puncte\nRulez testul 6: ok: timp 41ms: mem 172kb: OK: 10 puncte\nRulez testul 7: ok: timp 43ms: mem 172kb: OK: 10 puncte\nRulez testul 8: ok: timp 63ms: mem 172kb: OK: 10 puncte\nRulez testul 9: ok: timp 10ms: mem 172kb: OK: 10 puncte\nRulez testul 10: ok: timp 103ms: mem 156kb: OK: 10 puncte\n\nPunctaj total: 100\n',100,'Evaluare completa'),(10220,'patrate3',1024,'cpp','--gone--','done','2007-01-28 21:23:05','Compilare:\n\n\nRulez testul 1: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 2: ok: timp 0ms: mem 8kb: Incorect: 0 puncte\nRulez testul 3: ok: timp 1ms: mem 8kb: Incorect: 0 puncte\nRulez testul 4: ok: timp 2ms: mem 8kb: Incorect: 0 puncte\nRulez testul 5: ok: timp 3ms: mem 8kb: Incorect: 0 puncte\nRulez testul 6: ok: timp 2ms: mem 8kb: Incorect: 0 puncte\nRulez testul 7: ok: timp 3ms: mem 212kb: Incorect: 0 puncte\nRulez testul 8: ok: timp 11ms: mem 212kb: Incorect: 0 puncte\nRulez testul 9: ok: timp 18ms: mem 216kb: Incorect: 0 puncte\nRulez testul 10: ok: timp 24ms: mem 216kb: Incorect: 0 puncte\nRulez testul 11: ok: timp 183ms: mem 224kb: Incorect: 0 puncte\nRulez testul 12: ok: timp 188ms: mem 224kb: Incorect: 0 puncte\nRulez testul 13: ok: timp 195ms: mem 220kb: Incorect: 0 puncte\nRulez testul 14: ok: timp 222ms: mem 224kb: Incorect: 0 puncte\nRulez testul 15: ok: timp 224ms: mem 224kb: Incorect: 0 puncte\nRulez testul 16: ok: timp 236ms: mem 224kb: Incorect: 0 puncte\nRulez testul 17: ok: timp 247ms: mem 224kb: Incorect: 0 puncte\nRulez testul 18: ok: timp 266ms: mem 224kb: Incorect: 0 puncte\nRulez testul 19: ok: timp 333ms: mem 224kb: Incorect: 0 puncte\nRulez testul 20: ok: timp 334ms: mem 224kb: Incorect: 0 puncte\n\nPunctaj total: 0\n',0,'Evaluare completa');
/*!40000 ALTER TABLE `ia_job` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_parameter_value`
--

DROP TABLE IF EXISTS `ia_parameter_value`;
CREATE TABLE `ia_parameter_value` (
  `parameter_id` varchar(64) collate latin1_general_ci NOT NULL default '',
  `object_type` enum('task','round') collate latin1_general_ci NOT NULL,
  `object_id` varchar(64) collate latin1_general_ci NOT NULL default '',
  `value` varchar(256) collate latin1_general_ci default NULL,
  PRIMARY KEY  (`object_type`,`object_id`,`parameter_id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_parameter_value`
--

LOCK TABLES `ia_parameter_value` WRITE;
/*!40000 ALTER TABLE `ia_parameter_value` DISABLE KEYS */;
INSERT INTO `ia_parameter_value` VALUES ('unique_output','task','cifru','1'),('timelimit','task','adapost2','1'),('tests','task','adapost2','20'),('timelimit','task','gfact','0.3'),('okfiles','task','java','1'),('evaluator','task','java',''),('unique_output','task','java','1'),('memlimit','task','sah','65536'),('memlimit','task','java','65536'),('timelimit','task','java','1'),('unique_output','task','popandai','0'),('evaluator','task','popandai','eval.c'),('timelimit','task','popandai','3.5'),('memlimit','task','popandai','65536'),('tests','task','java','20'),('okfiles','task','arbciclu','1'),('evaluator','task','arbciclu',''),('unique_output','task','arbciclu','1'),('timelimit','task','calcul','1'),('memlimit','task','calcul','65536'),('memlimit','task','arbciclu','65536'),('timelimit','task','arbciclu','5'),('unique_output','task','dmin','1'),('evaluator','task','dmin',''),('okfiles','task','dmin','1'),('memlimit','task','matrix','65536'),('unique_output','task','matrix','1'),('tests','task','arbciclu','10'),('okfiles','task','nodiv','1'),('evaluator','task','nodiv','eval.cpp'),('unique_output','task','nodiv','0'),('memlimit','task','nodiv','65536'),('timelimit','task','nodiv','0.2'),('tests','task','nodiv','10'),('okfiles','task','hprob','1'),('evaluator','task','hprob',''),('tests','task','nrcuv','20'),('timelimit','task','nrcuv','0.1'),('memlimit','task','nrcuv','65536'),('unique_output','task','nrcuv','1'),('evaluator','task','nrcuv',''),('okfiles','task','nrcuv','1'),('memlimit','task','reg','65536'),('unique_output','task','hprob','1'),('memlimit','task','hprob','65536'),('timelimit','task','hprob','1'),('evaluator','task','note',''),('memlimit','task','gfact','65536'),('unique_output','task','gfact','1'),('evaluator','task','gfact',''),('okfiles','task','gfact','1'),('tests','task','matrix','20'),('tests','task','hprob','10'),('okfiles','task','itree','1'),('evaluator','task','itree',''),('unique_output','task','itree','1'),('memlimit','task','itree','65536'),('timelimit','task','itree','1.5'),('unique_output','task','puternic','1'),('tests','task','itree','10'),('okfiles','task','geometry','1'),('evaluator','task','geometry',''),('timelimit','task','nextseq','0.3'),('memlimit','task','nextseq','65536'),('unique_output','task','geometry','1'),('memlimit','task','geometry','65536'),('timelimit','task','geometry','1'),('tests','task','geometry','10'),('okfiles','task','joc3','1'),('evaluator','task','joc3',''),('unique_output','task','joc3','1'),('memlimit','task','joc3','65536'),('timelimit','task','joc3','0.1'),('tests','task','joc3','20'),('okfiles','task','cc','1'),('unique_output','task','count','1'),('evaluator','task','cc',''),('timelimit','task','sah','0.3'),('evaluator','task','cowfood',''),('okfiles','task','cowfood','1'),('unique_output','task','cc','1'),('memlimit','task','cc','65536'),('evaluator','task','count',''),('okfiles','task','count','1'),('tests','task','cowfood','50'),('timelimit','task','cowfood','1'),('memlimit','task','cowfood','65536'),('unique_output','task','cowfood','1'),('timelimit','task','sum','0.2'),('tests','task','pavare2','20'),('timelimit','task','pavare2','0.1'),('memlimit','task','pavare2','65536'),('unique_output','task','pavare2','1'),('evaluator','task','pavare2',''),('okfiles','task','pavare2','1'),('okfiles','task','subsir2','1'),('timelimit','task','cc','1'),('unique_output','task','sum','1'),('tests','task','cc','10'),('timelimit','task','subsir2','0.1'),('okfiles','task','hanoi4','1'),('evaluator','task','hanoi4',''),('unique_output','task','hanoi4','1'),('memlimit','task','hanoi4','65536'),('timelimit','task','hanoi4','1'),('tests','task','hanoi4','10'),('unique_output','task','divprim','1'),('evaluator','task','divprim',''),('okfiles','task','divprim','1'),('unique_output','task','euler','1'),('okfiles','task','1expr','1'),('evaluator','task','1expr','eval.cpp'),('unique_output','task','1expr','0'),('memlimit','task','1expr','65536'),('timelimit','task','1expr','2'),('tests','task','1expr','10'),('unique_output','task','obj','1'),('okfiles','task','obj','1'),('evaluator','task','obj',''),('memlimit','task','obj','65536'),('timelimit','task','obj','0.1'),('tests','task','obj','10'),('unique_output','task','nrtri','1'),('evaluator','task','nrtri',''),('okfiles','task','nrtri','1'),('okfiles','task','int','1'),('evaluator','task','int',''),('unique_output','task','int','1'),('memlimit','task','int','65536'),('timelimit','task','int','0.8'),('tests','task','int','10'),('okfiles','task','swap','1'),('evaluator','task','swap',''),('unique_output','task','swap','1'),('memlimit','task','swap','65536'),('timelimit','task','swap','0.1'),('tests','task','swap','10'),('okfiles','task','ct','1'),('tests','task','path','10'),('unique_output','task','password','1'),('evaluator','task','password',''),('evaluator','task','ct',''),('unique_output','task','ct','1'),('memlimit','task','ct','65536'),('timelimit','task','ct','2.5'),('tests','task','ct','10'),('okfiles','task','avd','1'),('evaluator','task','avd',''),('unique_output','task','avd','1'),('memlimit','task','avd','65536'),('timelimit','task','avd','0.6'),('unique_output','task','12perm','1'),('timelimit','task','12perm','0.1'),('memlimit','task','12perm','65536'),('tests','task','order','20'),('timelimit','task','order','0.1'),('memlimit','task','order','65536'),('unique_output','task','order','1'),('evaluator','task','order',''),('okfiles','task','order','1'),('tests','task','points','20'),('timelimit','task','points','0.1'),('memlimit','task','points','65536'),('unique_output','task','points','1'),('memlimit','task','dame','65536'),('unique_output','task','supersf','1'),('evaluator','task','supersf',''),('okfiles','task','supersf','1'),('tests','task','dame','20'),('timelimit','task','dame','0.1'),('memlimit','task','supersf','65536'),('timelimit','task','supersf','1'),('memlimit','task','santa','65536'),('unique_output','task','santa','0'),('evaluator','task','santa','eval.cpp'),('okfiles','task','santa','1'),('tests','task','supersf','20'),('unique_output','task','reg','1'),('evaluator','task','reg',''),('okfiles','task','reg','1'),('tests','task','santa','10'),('timelimit','task','santa','7'),('tests','task','avd','10'),('okfiles','task','eq','1'),('evaluator','task','eq',''),('unique_output','task','eq','1'),('memlimit','task','eq','65536'),('timelimit','task','eq','1.2'),('tests','task','eq','25'),('okfiles','task','parcare','1'),('evaluator','task','parcare','eval.cpp'),('unique_output','task','parcare','0'),('memlimit','task','parcare','65536'),('evaluator','task','zapada','eval.cpp'),('timelimit','task','parcare','0.4'),('timelimit','task','zapada','1'),('memlimit','task','zapada','65536'),('tests','task','parcare','10'),('okfiles','task','monezi','1'),('tests','task','superp','20'),('timelimit','task','superp','0.2'),('memlimit','task','superp','65536'),('okfiles','task','secv4','1'),('evaluator','task','poly',''),('okfiles','task','soldati','1'),('tests','task','monezi','10'),('timelimit','task','monezi','0.75'),('evaluator','task','soldati',''),('unique_output','task','soldati','1'),('evaluator','task','secv4',''),('unique_output','task','secv4','1'),('memlimit','task','soldati','65536'),('memlimit','task','secv4','65536'),('timelimit','task','secv4','0.3'),('timelimit','task','numere2','0.5'),('memlimit','task','numere2','65536'),('unique_output','task','numere2','1'),('evaluator','task','numere2',''),('tests','task','secv4','20'),('memlimit','task','ben','65536'),('unique_output','task','ben','0'),('tests','task','ben','10'),('timelimit','task','ben','0.5'),('okfiles','task','bridge','1'),('evaluator','task','bridge',''),('unique_output','task','bridge','1'),('memlimit','task','sticle','65536'),('tests','task','sticle','10'),('timelimit','task','sticle','0.1'),('memlimit','task','bridge','65536'),('timelimit','task','bridge','1'),('tests','task','insula','10'),('timelimit','task','insula','1'),('memlimit','task','insula','65536'),('timelimit','task','coach','0.5'),('memlimit','task','coach','65536'),('unique_output','task','coach','0'),('timelimit','task','expr','0.2'),('memlimit','task','expr','65536'),('unique_output','task','expr','1'),('evaluator','task','expr',''),('evaluator','task','ciclu','eval.cpp'),('okfiles','task','ciclu','1'),('tests','task','bridge','10'),('okfiles','task','poly','1'),('unique_output','task','poly','1'),('memlimit','task','poly','65536'),('timelimit','task','poly','0.1'),('tests','task','poly','10'),('evaluator','task','adapost','eval.pas'),('okfiles','task','adapost','1'),('tests','task','sortari','10'),('unique_output','task','dreptunghiuri','1'),('okfiles','task','gold','1'),('memlimit','task','pawns','65536'),('unique_output','task','pawns','1'),('evaluator','task','pawns',''),('evaluator','task','geamuri',''),('okfiles','task','geamuri','1'),('tests','task','distante','10'),('timelimit','task','distante','0.5'),('memlimit','task','distante','65536'),('tests','task','cercuri','1'),('timelimit','task','cercuri','0.1'),('memlimit','task','cercuri','65536'),('unique_output','task','cercuri','0'),('evaluator','task','cercuri','eval.cpp'),('unique_output','task','resturi','1'),('unique_output','task','linterv','1'),('evaluator','task','linterv',''),('okfiles','task','linterv','1'),('tests','task','resturi','1'),('timelimit','task','resturi','2'),('tests','task','palind','1'),('timelimit','task','palind','1'),('evaluator','task','gold',''),('unique_output','task','gold','1'),('memlimit','task','gold','65536'),('timelimit','task','gold','1.5'),('tests','task','gold','10'),('okfiles','task','oras','1'),('evaluator','task','oras','eval.c'),('unique_output','task','oras','0'),('memlimit','task','oras','65536'),('timelimit','task','oras','0.1'),('tests','task','oras','20'),('okfiles','task','abc','1'),('evaluator','task','abc','eval.cpp'),('unique_output','task','abc','0'),('memlimit','task','abc','65536'),('timelimit','task','abc','0.1'),('okfiles','task','poligon2','1'),('tests','task','abc','20'),('okfiles','task','treid','1'),('evaluator','task','treid',''),('unique_output','task','treid','1'),('memlimit','task','treid','65536'),('timelimit','task','treid','0.5'),('tests','task','treid','20'),('okfiles','task','plimbare','1'),('evaluator','task','plimbare','eval.cpp'),('tests','task','transport','10'),('unique_output','task','plimbare','0'),('memlimit','task','plimbare','65536'),('tests','task','muzeu','10'),('timelimit','task','bile','0.3'),('memlimit','task','bile','65536'),('unique_output','task','bile','1'),('evaluator','task','bile',''),('memlimit','task','granita','65536'),('unique_output','task','granita','1'),('evaluator','task','granita',''),('okfiles','task','granita','1'),('tests','task','asmax','10'),('timelimit','task','asmax','0.1'),('tests','task','echipe','20'),('timelimit','task','plimbare','0.2'),('tests','task','plimbare','20'),('memlimit','task','invcs','65536'),('unique_output','task','invcs','1'),('evaluator','task','invcs',''),('okfiles','task','invcs','1'),('okfiles','task','sah','1'),('evaluator','task','sah','eval.cpp'),('unique_output','task','sah','0'),('timelimit','task','patrol','1'),('unique_output','task','base3','1'),('okfiles','task','color2','1'),('evaluator','task','soc','eval.c'),('okfiles','task','soc','1'),('tests','task','ecu','10'),('timelimit','task','ecu','0.1'),('memlimit','task','ecu','65536'),('unique_output','task','ecu','0'),('evaluator','task','ecu','eval.c'),('okfiles','task','ecu','1'),('tests','task','tri2','10'),('timelimit','task','tri2','2'),('memlimit','task','tri2','65536'),('unique_output','task','tri2','1'),('evaluator','task','tri2',''),('okfiles','task','tri2','1'),('tests','task','lanterna','10'),('timelimit','task','lanterna','0.2'),('memlimit','task','lanterna','65536'),('unique_output','task','lanterna','1'),('evaluator','task','lanterna',''),('okfiles','task','lanterna','1'),('tests','task','trans','10'),('timelimit','task','trans','0.3'),('memlimit','task','trans','65536'),('unique_output','task','trans','1'),('evaluator','task','trans',''),('okfiles','task','trans','1'),('tests','task','color2','20'),('timelimit','task','color2','0.1'),('memlimit','task','color2','65536'),('unique_output','task','color2','1'),('evaluator','task','apdm',''),('tests','task','sah','10'),('okfiles','task','pscpld','1'),('evaluator','task','pscpld',''),('unique_output','task','pscpld','1'),('evaluator','task','matrix',''),('okfiles','task','matrix','1'),('evaluator','task','sir',''),('memlimit','task','pscpld','65536'),('timelimit','task','pscpld','0.2'),('tests','task','pscpld','10'),('okfiles','task','patrol','1'),('tests','task','omizi','10'),('timelimit','task','omizi','0.1'),('memlimit','task','omizi','65536'),('unique_output','task','nextseq','1'),('evaluator','task','patrol',''),('unique_output','task','patrol','1'),('memlimit','task','patrol','65536'),('evaluator','task','demolish',''),('okfiles','task','demolish','1'),('tests','task','nextseq','20'),('tests','task','patrol','10'),('okfiles','task','free','1'),('evaluator','task','free',''),('unique_output','task','free','1'),('memlimit','task','free','65536'),('timelimit','task','free','0.1'),('tests','task','free','10'),('okfiles','task','bilete','1'),('evaluator','task','bilete',''),('unique_output','task','bilete','1'),('memlimit','task','bilete','65536'),('timelimit','task','bilete','0.1'),('tests','task','bilete','10'),('memlimit','task','subsir2','65536'),('okfiles','task','sum','1'),('okfiles','task','note','1'),('unique_output','task','note','1'),('memlimit','task','note','65536'),('timelimit','task','note','0.3'),('tests','task','sum','20'),('evaluator','task','subsir2','eval.c'),('okfiles','task','zapada','1'),('tests','task','note','10'),('okfiles','task','euler','1'),('evaluator','task','euler',''),('memlimit','task','euler','65536'),('timelimit','task','euler','0.5'),('tests','task','euler','10'),('okfiles','task','alpin','1'),('evaluator','task','biscuiti',''),('evaluator','task','alpin','eval.c'),('unique_output','task','alpin','0'),('memlimit','task','alpin','65536'),('memlimit','task','grazing','65536'),('timelimit','task','alpin','1.5'),('tests','task','alpin','10'),('okfiles','task','catun','1'),('evaluator','task','catun',''),('timelimit','task','siruri','3'),('unique_output','task','catun','1'),('memlimit','task','catun','65536'),('timelimit','task','catun','0.4'),('tests','task','catun','10'),('okfiles','task','puternic','1'),('evaluator','task','puternic',''),('evaluator','task','desc','eval.cpp'),('okfiles','task','desc','1'),('tests','task','struti','10'),('timelimit','task','struti','4'),('timelimit','task','zc','3'),('memlimit','task','puternic','65536'),('timelimit','task','puternic','1.5'),('tests','task','puternic','10'),('okfiles','task','vila','1'),('evaluator','task','vila',''),('unique_output','task','vila','1'),('memlimit','task','vila','65536'),('timelimit','task','vila','0.1'),('tests','task','vila','10'),('okfiles','task','senat','1'),('evaluator','task','senat','eval.c'),('unique_output','task','senat','0'),('memlimit','task','senat','65536'),('timelimit','task','senat','0.1'),('tests','task','senat','10'),('tests','task','reg','10'),('okfiles','task','bcolor','1'),('evaluator','task','bcolor',''),('unique_output','task','bcolor','1'),('memlimit','task','bcolor','65536'),('unique_output','task','siruri','0'),('unique_output','task','zapada','0'),('timelimit','task','fold','0.2'),('timelimit','task','bcolor','0.1'),('tests','task','bcolor','20'),('evaluator','task','monezi',''),('unique_output','task','monezi','1'),('tests','task','soldati','10'),('okfiles','task','arbfind','1'),('evaluator','task','arbfind',''),('unique_output','task','arbfind','1'),('memlimit','task','arbfind','65536'),('timelimit','task','arbfind','1'),('tests','task','arbfind','20'),('okfiles','task','mine','1'),('evaluator','task','mine',''),('unique_output','task','mine','1'),('memlimit','task','mine','65536'),('timelimit','task','mine','0.2'),('tests','task','mine','25'),('okfiles','task','drumuri2','1'),('okfiles','task','sticle','1'),('unique_output','task','sticle','1'),('evaluator','task','sticle',''),('okfiles','task','insula','1'),('evaluator','task','drumuri2',''),('unique_output','task','drumuri2','1'),('memlimit','task','drumuri2','65536'),('timelimit','task','drumuri2','0.1'),('tests','task','drumuri2','10'),('evaluator','task','divizori','eval.pas'),('okfiles','task','panouri','1'),('evaluator','task','panouri',''),('unique_output','task','panouri','1'),('memlimit','task','panouri','65536'),('timelimit','task','panouri','0.1'),('tests','task','ciclu','10'),('timelimit','task','ciclu','3'),('memlimit','task','ciclu','65536'),('evaluator','task','balans',''),('okfiles','task','balans','1'),('tests','task','dreptunghiuri','10'),('timelimit','task','dreptunghiuri','0.3'),('okfiles','task','resturi','1'),('tests','task','panouri','10'),('okfiles','task','map','1'),('evaluator','task','map',''),('unique_output','task','map','1'),('memlimit','task','map','65536'),('timelimit','task','map','0.7'),('tests','task','map','20'),('okfiles','task','csir','1'),('unique_output','task','palind','1'),('evaluator','task','palind',''),('okfiles','task','calatorie','1'),('tests','task','razboi','1'),('timelimit','task','razboi','3'),('memlimit','task','razboi','65536'),('unique_output','task','razboi','1'),('evaluator','task','razboi',''),('evaluator','task','zoo',''),('evaluator','task','csir',''),('unique_output','task','csir','1'),('timelimit','task','string','0.3'),('memlimit','task','csir','65536'),('evaluator','task','suma',''),('unique_output','task','transport','1'),('timelimit','task','csir','0.3'),('tests','task','csir','10'),('okfiles','task','acolor','1'),('evaluator','task','acolor',''),('unique_output','task','acolor','1'),('memlimit','task','muzeu','65536'),('unique_output','task','muzeu','1'),('evaluator','task','arie',''),('memlimit','task','acolor','65536'),('timelimit','task','acolor','0.6'),('tests','task','acolor','20'),('okfiles','task','avere','1'),('evaluator','task','avere','eval.c'),('unique_output','task','avere','0'),('memlimit','task','avere','65536'),('unique_output','task','prefix','1'),('timelimit','task','base3','0.2'),('timelimit','task','avere','0.1'),('tests','task','avere','10'),('okfiles','task','omizi','1'),('timelimit','task','subsir','0.1'),('memlimit','task','subsir','65536'),('evaluator','task','subsir','eval.c'),('evaluator','task','z',''),('unique_output','task','omizi','1'),('timelimit','task','cifru','0.3'),('okfiles','task','path','1'),('evaluator','task','path',''),('unique_output','task','path','1'),('memlimit','task','path','65536'),('timelimit','task','path','0.1'),('okfiles','task','password','1'),('memlimit','task','password','65536'),('unique_output','task','superp','1'),('tests','task','siruri','20'),('timelimit','task','password','0.1'),('tests','task','password','20'),('okfiles','task','bmatrix','1'),('evaluator','task','bmatrix',''),('unique_output','task','bmatrix','1'),('memlimit','task','bmatrix','65536'),('timelimit','task','bmatrix','0.1'),('tests','task','bmatrix','20'),('okfiles','task','aladdin2','1'),('evaluator','task','aladdin2',''),('unique_output','task','aladdin2','1'),('memlimit','task','aladdin2','65536'),('timelimit','task','aladdin2','0.1'),('tests','task','aladdin2','20'),('okfiles','task','points','1'),('evaluator','task','points',''),('memlimit','task','transport','65536'),('okfiles','task','prefix','1'),('timelimit','task','invcs','0.1'),('tests','task','invcs','10'),('okfiles','task','biscuiti','1'),('evaluator','task','struti',''),('unique_output','task','desc','0'),('memlimit','task','siruri','65536'),('unique_output','task','biscuiti','1'),('memlimit','task','biscuiti','65536'),('timelimit','task','biscuiti','0.5'),('unique_output','task','insula','1'),('tests','task','biscuiti','10'),('okfiles','task','pawns','1'),('okfiles','task','sortari','1'),('evaluator','task','sortari',''),('timelimit','task','sortari','0.9'),('timelimit','task','pawns','0.1'),('timelimit','task','linterv','3'),('tests','task','pawns','20'),('okfiles','task','game','1'),('unique_output','task','expresii','1'),('evaluator','task','expresii',''),('evaluator','task','game',''),('evaluator','task','graf',''),('unique_output','task','camera','0'),('unique_output','task','game','1'),('memlimit','task','game','65536'),('timelimit','task','game','0.1'),('tests','task','game','20'),('okfiles','task','hallway','1'),('evaluator','task','hallway',''),('unique_output','task','hallway','1'),('memlimit','task','hallway','65536'),('timelimit','task','hallway','0.1'),('tests','task','hallway','20'),('okfiles','task','fold','1'),('evaluator','task','fold',''),('unique_output','task','fold','1'),('memlimit','task','fold','65536'),('tests','task','fold','20'),('okfiles','task','numere','1'),('timelimit','task','poligon2','0.1'),('okfiles','task','base3','1'),('okfiles','task','cifru','1'),('evaluator','task','cifru',''),('okfiles','task','popandai','1'),('memlimit','task','cifru','65536'),('tests','task','cifru','10'),('okfiles','task','divizori','1'),('unique_output','task','divizori','0'),('memlimit','task','divizori','65536'),('timelimit','task','divizori','0.1'),('tests','task','divizori','25'),('okfiles','task','apdm','1'),('unique_output','task','apdm','1'),('memlimit','task','apdm','65536'),('timelimit','task','apdm','0.1'),('tests','task','apdm','20'),('okfiles','task','grazing','1'),('evaluator','task','grazing',''),('unique_output','task','grazing','1'),('timelimit','task','grazing','1'),('tests','task','grazing','10'),('okfiles','task','geom','1'),('evaluator','task','geom','eval.cpp'),('timelimit','task','soldati','1'),('unique_output','task','geom','0'),('memlimit','task','geom','65536'),('tests','task','geom','20'),('timelimit','task','geom','1.5'),('okfiles','task','colorare','1'),('evaluator','task','colorare',''),('unique_output','task','colorare','1'),('memlimit','task','colorare','65536'),('timelimit','task','colorare','1'),('tests','task','colorare','20'),('evaluator','task','lesbulan',''),('okfiles','task','lesbulan','1'),('unique_output','task','lesbulan','1'),('memlimit','task','lesbulan','65536'),('evaluator','task','calcul',''),('okfiles','task','calcul','1'),('tests','task','popandai','25'),('unique_output','task','calcul','1'),('tests','task','calcul','20'),('memlimit','task','dmin','65536'),('timelimit','task','lesbulan','0.1'),('timelimit','task','dmin','0.1'),('evaluator','task','camera','eval.c'),('okfiles','task','camera','1'),('tests','task','invsc','10'),('timelimit','task','invsc','0.2'),('memlimit','task','invsc','65536'),('unique_output','task','invsc','0'),('evaluator','task','invsc','eval.pas'),('okfiles','task','invsc','1'),('tests','task','timbre','10'),('timelimit','task','timbre','0.4'),('memlimit','task','timbre','65536'),('unique_output','task','timbre','0'),('evaluator','task','timbre','eval.c'),('okfiles','task','timbre','1'),('tests','task','nrtri','20'),('timelimit','task','nrtri','0.1'),('tests','task','lesbulan','20'),('okfiles','task','joc2','1'),('evaluator','task','joc2',''),('unique_output','task','joc2','1'),('memlimit','task','joc2','65536'),('timelimit','task','joc2','0.1'),('tests','task','joc2','20'),('okfiles','task','srevni','1'),('evaluator','task','srevni',''),('unique_output','task','srevni','1'),('memlimit','task','srevni','65536'),('timelimit','task','srevni','0.5'),('tests','task','srevni','20'),('okfiles','task','aladdin','1'),('evaluator','task','aladdin','eval.pas'),('unique_output','task','aladdin','0'),('memlimit','task','aladdin','65536'),('timelimit','task','aladdin','5'),('tests','task','aladdin','20'),('okfiles','task','biti2','1'),('unique_output','task','subsir2','0'),('evaluator','task','biti2',''),('unique_output','task','biti2','1'),('memlimit','task','biti2','65536'),('timelimit','task','biti2','1'),('tests','task','biti2','20'),('okfiles','task','sequencequery','1'),('evaluator','task','sequencequery',''),('unique_output','task','sequencequery','1'),('memlimit','task','sequencequery','65536'),('timelimit','task','camera','1'),('timelimit','task','sequencequery','1'),('okfiles','task','struti','1'),('tests','task','sequencequery','20'),('unique_output','task','struti','1'),('okfiles','task','paralelograme','1'),('memlimit','task','desc','65536'),('evaluator','task','paralelograme',''),('unique_output','task','paralelograme','1'),('memlimit','task','paralelograme','65536'),('timelimit','task','paralelograme','1'),('tests','task','paralelograme','20'),('okfiles','task','z','1'),('memlimit','task','zc','65536'),('unique_output','task','zc','0'),('evaluator','task','zc','eval.c'),('okfiles','task','zc','1'),('tests','task','grupuri','50'),('timelimit','task','grupuri','0.1'),('memlimit','task','grupuri','65536'),('unique_output','task','grupuri','1'),('evaluator','task','grupuri',''),('okfiles','task','grupuri','1'),('unique_output','task','z','1'),('timelimit','task','reg','5'),('unique_output','task','turneu','1'),('evaluator','task','turneu',''),('okfiles','task','siruri','1'),('memlimit','task','z','65536'),('timelimit','task','z','0.1'),('evaluator','task','superp',''),('okfiles','task','superp','1'),('tests','task','zapada','20'),('tests','task','z','10'),('okfiles','task','popandai2','1'),('evaluator','task','popandai2',''),('unique_output','task','popandai2','1'),('memlimit','task','popandai2','65536'),('tests','task','numere2','20'),('okfiles','task','ben','1'),('timelimit','task','popandai2','0.5'),('tests','task','popandai2','10'),('okfiles','task','domino','1'),('evaluator','task','domino','eval.pas'),('unique_output','task','domino','0'),('memlimit','task','domino','65536'),('timelimit','task','domino','0.3'),('tests','task','domino','20'),('okfiles','task','numar','1'),('evaluator','task','numar',''),('tests','task','coach','10'),('okfiles','task','expr','1'),('unique_output','task','numar','1'),('memlimit','task','numar','65536'),('timelimit','task','numar','0.2'),('tests','task','numar','10'),('okfiles','task','subsiruri','1'),('evaluator','task','subsiruri',''),('unique_output','task','subsiruri','1'),('timelimit','task','balans','4.5'),('memlimit','task','subsiruri','65536'),('timelimit','task','subsiruri','0.2'),('tests','task','subsiruri','10'),('okfiles','task','jocul','1'),('tests','task','geamuri','10'),('timelimit','task','jarbore','0.5'),('evaluator','task','jocul',''),('unique_output','task','jocul','1'),('memlimit','task','jocul','65536'),('timelimit','task','jocul','0.2'),('tests','task','jocul','10'),('evaluator','task','divmul',''),('memlimit','task','calatorie','65536'),('unique_output','task','calatorie','1'),('okfiles','task','figuri','1'),('evaluator','task','figuri',''),('unique_output','task','figuri','1'),('timelimit','task','zoo','1'),('memlimit','task','figuri','65536'),('timelimit','task','figuri','0.3'),('tests','task','figuri','10'),('okfiles','task','spirala','1'),('evaluator','task','spirala',''),('unique_output','task','spirala','1'),('memlimit','task','struti','65536'),('memlimit','task','spirala','65536'),('timelimit','task','spirala','0.2'),('evaluator','task','sum',''),('tests','task','spirala','10'),('okfiles','task','minim','1'),('evaluator','task','minim',''),('unique_output','task','minim','1'),('memlimit','task','minim','65536'),('timelimit','task','minim','0.1'),('tests','task','minim','10'),('okfiles','task','sir','1'),('unique_output','task','sir','1'),('memlimit','task','sir','65536'),('timelimit','task','sir','0.5'),('okfiles','task','cercuri2','1'),('tests','task','sir','20'),('evaluator','task','cercuri2',''),('tests','task','count','10'),('timelimit','task','count','1'),('memlimit','task','count','65536'),('memlimit','task','sum','65536'),('tests','task','subsir2','20'),('unique_output','task','cercuri2','1'),('memlimit','task','cercuri2','65536'),('timelimit','task','cercuri2','0.2'),('tests','task','cercuri2','25'),('okfiles','task','pedefe','1'),('evaluator','task','pedefe',''),('unique_output','task','pedefe','1'),('memlimit','task','pedefe','65536'),('timelimit','task','pedefe','2.5'),('tests','task','12perm','20'),('tests','task','pedefe','20'),('okfiles','task','arbore','1'),('evaluator','task','arbore','eval.c'),('unique_output','task','arbore','0'),('memlimit','task','arbore','65536'),('timelimit','task','arbore','2'),('tests','task','arbore','20'),('okfiles','task','pscnv','1'),('memlimit','task','monezi','65536'),('evaluator','task','pscnv',''),('unique_output','task','pscnv','1'),('memlimit','task','pscnv','65536'),('okfiles','task','coach','1'),('timelimit','task','pscnv','1'),('tests','task','pscnv','10'),('okfiles','task','robotei','1'),('evaluator','task','robotei',''),('unique_output','task','robotei','1'),('timelimit','task','divmul','0.5'),('unique_output','task','poligon2','0'),('tests','task','robotei','10'),('timelimit','task','robotei','1.5'),('memlimit','task','robotei','65536'),('okfiles','task','iv','1'),('evaluator','task','iv',''),('unique_output','task','iv','1'),('memlimit','task','iv','65536'),('timelimit','task','iv','3'),('tests','task','iv','20'),('okfiles','task','overlap','1'),('unique_output','task','overlap','0'),('evaluator','task','overlap','eval.cpp'),('memlimit','task','overlap','65536'),('timelimit','task','overlap','0.5'),('okfiles','task','dreptunghiuri','1'),('tests','task','invers','10'),('timelimit','task','invers','0.3'),('memlimit','task','invers','65536'),('unique_output','task','invers','1'),('evaluator','task','invers',''),('okfiles','task','invers','1'),('tests','task','reuniune','10'),('timelimit','task','reuniune','0.1'),('memlimit','task','reuniune','65536'),('unique_output','task','reuniune','1'),('evaluator','task','reuniune',''),('okfiles','task','reuniune','1'),('tests','task','patrate2','10'),('timelimit','task','patrate2','0.1'),('memlimit','task','patrate2','65536'),('unique_output','task','patrate2','1'),('evaluator','task','patrate2',''),('okfiles','task','patrate2','1'),('tests','task','harta','20'),('timelimit','task','harta','0.8'),('memlimit','task','harta','65536'),('unique_output','task','harta','0'),('evaluator','task','harta','eval.cpp'),('okfiles','task','harta','1'),('tests','task','adapost','20'),('timelimit','task','zebughil','1.2'),('memlimit','task','geamuri','65536'),('tests','task','overlap','25'),('okfiles','task','lupu','1'),('unique_output','task','lupu','1'),('evaluator','task','lupu',''),('memlimit','task','lupu','65536'),('timelimit','task','lupu','0.4'),('tests','task','lupu','25'),('evaluator','task','asmax',''),('okfiles','task','divk','1'),('timelimit','task','sediu','0.1'),('evaluator','task','divk',''),('tests','task','dmin','20'),('evaluator','task','nextseq',''),('okfiles','task','nextseq','1'),('unique_output','task','divk','1'),('memlimit','task','divk','65536'),('timelimit','task','divk','0.5'),('tests','task','divk','10'),('tests','task','gfact','20'),('timelimit','task','demolish','0.6'),('memlimit','task','demolish','65536'),('tests','task','divprim','20'),('timelimit','task','divprim','1'),('memlimit','task','divprim','65536'),('okfiles','task','graf','1'),('memlimit','task','graf','65536'),('unique_output','task','graf','1'),('memlimit','task','nrtri','65536'),('memlimit','task','camera','65536'),('timelimit','task','graf','0.1'),('tests','task','graf','10'),('okfiles','task','custi','1'),('tests','task','camera','10'),('evaluator','task','12perm',''),('okfiles','task','12perm','1'),('tests','task','desc','10'),('timelimit','task','desc','1'),('tests','task','dmg','20'),('timelimit','task','dmg','1'),('memlimit','task','dmg','65536'),('unique_output','task','dmg','0'),('evaluator','task','dmg','eval.cpp'),('okfiles','task','dmg','1'),('tests','task','turneu','10'),('timelimit','task','turneu','1'),('memlimit','task','turneu','65536'),('tests','task','expr','10'),('unique_output','task','ciclu','0'),('memlimit','task','adapost','65536'),('unique_output','task','adapost','0'),('tests','task','calatorie','1'),('evaluator','task','custi',''),('unique_output','task','jarbore','1'),('memlimit','task','cai','65536'),('unique_output','task','cai','1'),('tests','task','numere','10'),('timelimit','task','numere','0.1'),('memlimit','task','numere','65536'),('unique_output','task','custi','1'),('memlimit','task','custi','65536'),('evaluator','task','omizi',''),('timelimit','task','custi','0.5'),('tests','task','custi','10'),('okfiles','task','semne','1'),('evaluator','task','semne','eval.pas'),('unique_output','task','semne','0'),('memlimit','task','semne','65536'),('timelimit','task','semne','3'),('tests','task','semne','20'),('okfiles','task','farey','1'),('evaluator','task','farey',''),('unique_output','task','farey','1'),('memlimit','task','farey','65536'),('timelimit','task','farey','0.3'),('tests','task','farey','10'),('okfiles','task','caraibe','1'),('evaluator','task','caraibe',''),('unique_output','task','caraibe','1'),('okfiles','task','turneu','1'),('evaluator','task','siruri','eval.c'),('memlimit','task','caraibe','65536'),('timelimit','task','caraibe','0.1'),('tests','task','caraibe','20'),('okfiles','task','invsort','1'),('evaluator','task','invsort','eval.c'),('unique_output','task','invsort','0'),('okfiles','task','numere2','1'),('evaluator','task','ben','eval.cpp'),('memlimit','task','invsort','65536'),('timelimit','task','invsort','0.5'),('evaluator','task','insula',''),('tests','task','invsort','20'),('evaluator','task','coach','eval.c'),('okfiles','task','euro','1'),('evaluator','task','euro',''),('unique_output','task','euro','1'),('memlimit','task','euro','65536'),('timelimit','task','euro','0.4'),('tests','task','euro','20'),('timelimit','task','matrix','1'),('okfiles','task','trib','1'),('evaluator','task','trib',''),('unique_output','task','trib','1'),('memlimit','task','trib','65536'),('timelimit','task','trib','0.5'),('tests','task','trib','10'),('okfiles','task','substr','1'),('tests','task','demolish','10'),('evaluator','task','substr',''),('unique_output','task','substr','1'),('memlimit','task','substr','65536'),('unique_output','task','demolish','1'),('timelimit','task','substr','0.15'),('tests','task','substr','10'),('okfiles','task','telegraf','1'),('evaluator','task','telegraf',''),('unique_output','task','telegraf','1'),('memlimit','task','telegraf','65536'),('timelimit','task','telegraf','0.1'),('tests','task','telegraf','10'),('okfiles','task','sortnet','1'),('evaluator','task','sortnet',''),('unique_output','task','sortnet','1'),('memlimit','task','sortnet','65536'),('timelimit','task','sortnet','1'),('tests','task','sortnet','20'),('okfiles','task','sumdiv','1'),('evaluator','task','sumdiv',''),('unique_output','task','sumdiv','1'),('tests','task','zc','10'),('okfiles','task','dame','1'),('unique_output','task','dame','0'),('evaluator','task','dame','eval.c'),('timelimit','task','sumdiv','0.2'),('memlimit','task','sumdiv','65536'),('tests','task','sumdiv','10'),('okfiles','task','eqs','1'),('evaluator','task','eqs',''),('unique_output','task','eqs','1'),('memlimit','task','eqs','65536'),('tests','task','eqs','10'),('timelimit','task','eqs','1'),('okfiles','task','banana','1'),('evaluator','task','banana',''),('unique_output','task','banana','1'),('memlimit','task','banana','65536'),('timelimit','task','banana','0.1'),('tests','task','banana','10'),('memlimit','task','sortari','65536'),('unique_output','task','sortari','1'),('okfiles','task','seti','1'),('evaluator','task','seti',''),('unique_output','task','seti','1'),('unique_output','task','zebughil','1'),('timelimit','task','seti','1'),('memlimit','task','seti','65536'),('tests','task','seti','10'),('evaluator','task','mult',''),('okfiles','task','mult','1'),('timelimit','task','expresii','1'),('unique_output','task','mult','1'),('okfiles','task','string','1'),('unique_output','task','string','0'),('memlimit','task','mult','65536'),('timelimit','task','mult','2'),('memlimit','task','suma','65536'),('okfiles','task','transport','1'),('tests','task','mult','20'),('okfiles','task','adapost2','1'),('memlimit','task','arie','65536'),('okfiles','task','echipe','1'),('memlimit','task','echipe','65536'),('unique_output','task','sediu','1'),('evaluator','task','comp','eval.c'),('timelimit','task','comp','0.1'),('evaluator','task','adapost2','eval.pas'),('timelimit','task','prefix','0.5'),('unique_output','task','adapost2','0'),('memlimit','task','adapost2','65536'),('timelimit','task','text','0.1'),('memlimit','task','text','65536'),('unique_output','task','text','0'),('evaluator','task','text','eval.c'),('okfiles','task','text','1'),('tests','task','trapez','10'),('timelimit','task','trapez','2.5'),('memlimit','task','trapez','65536'),('unique_output','task','trapez','0'),('evaluator','task','trapez','eval.c'),('okfiles','task','trapez','1'),('tests','task','adn','10'),('timelimit','task','adn','3'),('memlimit','task','adn','65536'),('unique_output','task','adn','0'),('evaluator','task','adn','eval.c'),('okfiles','task','adn','1'),('tests','task','barbar','10'),('timelimit','task','barbar','2'),('memlimit','task','barbar','65536'),('unique_output','task','barbar','0'),('evaluator','task','barbar','eval.c'),('okfiles','task','barbar','1'),('tests','task','iepuri','10'),('timelimit','task','iepuri','0.1'),('memlimit','task','iepuri','65536'),('unique_output','task','iepuri','0'),('evaluator','task','iepuri','eval.c'),('okfiles','task','iepuri','1'),('tests','task','pascal','10'),('timelimit','task','pascal','1.2'),('memlimit','task','pascal','65536'),('unique_output','task','pascal','0'),('evaluator','task','pascal','eval.c'),('okfiles','task','pascal','1'),('tests','task','secv','10'),('timelimit','task','secv','0.1'),('memlimit','task','secv','65536'),('unique_output','task','secv','0'),('evaluator','task','secv','eval.c'),('okfiles','task','secv','1'),('tests','task','car','10'),('timelimit','task','car','0.8'),('memlimit','task','car','65536'),('unique_output','task','car','0'),('evaluator','task','car','eval.c'),('okfiles','task','car','1'),('tests','task','indep','20'),('timelimit','task','indep','1'),('memlimit','task','indep','65536'),('unique_output','task','indep','0'),('evaluator','task','indep','eval.c'),('okfiles','task','indep','1'),('tests','task','cerere','20'),('timelimit','task','cerere','0.5'),('memlimit','task','cerere','65536'),('unique_output','task','cerere','0'),('evaluator','task','cerere','eval.c'),('okfiles','task','cerere','1'),('tests','task','rubarba','10'),('timelimit','task','rubarba','1'),('memlimit','task','rubarba','65536'),('unique_output','task','rubarba','0'),('evaluator','task','rubarba','eval.c'),('okfiles','task','rubarba','1'),('tests','task','barman','10'),('timelimit','task','barman','1.5'),('memlimit','task','barman','65536'),('unique_output','task','barman','0'),('evaluator','task','barman','eval.c'),('okfiles','task','barman','1'),('tests','task','cifre','10'),('timelimit','task','cifre','0.2'),('memlimit','task','cifre','65536'),('unique_output','task','cifre','0'),('evaluator','task','cifre','eval.c'),('okfiles','task','cifre','1'),('tests','task','farfurii','10'),('timelimit','task','farfurii','0.2'),('memlimit','task','farfurii','65536'),('unique_output','task','farfurii','0'),('evaluator','task','farfurii','eval.c'),('okfiles','task','farfurii','1'),('tests','task','critice','10'),('timelimit','task','critice','1'),('memlimit','task','critice','65536'),('unique_output','task','critice','0'),('evaluator','task','critice','eval.cpp'),('okfiles','task','critice','1'),('tests','task','ferma','10'),('timelimit','task','ferma','0.8'),('memlimit','task','ferma','65536'),('unique_output','task','ferma','0'),('evaluator','task','ferma','eval.c'),('okfiles','task','ferma','1'),('tests','task','poligon','10'),('timelimit','task','poligon','0.2'),('memlimit','task','poligon','65536'),('unique_output','task','poligon','0'),('evaluator','task','poligon','eval.cpp'),('okfiles','task','poligon','1'),('tests','task','bombar','10'),('timelimit','task','bombar','1'),('memlimit','task','bombar','65536'),('unique_output','task','bombar','1'),('evaluator','task','bombar',''),('okfiles','task','bombar','1'),('tests','task','cobai','20'),('timelimit','task','cobai','0.1'),('memlimit','task','cobai','65536'),('unique_output','task','cobai','0'),('evaluator','task','cobai','eval.c'),('okfiles','task','cobai','1'),('tests','task','concert','10'),('timelimit','task','concert','0.5'),('memlimit','task','concert','65536'),('unique_output','task','concert','0'),('evaluator','task','concert','eval.c'),('okfiles','task','concert','1'),('tests','task','perm3','10'),('timelimit','task','perm3','1'),('memlimit','task','perm3','65536'),('unique_output','task','perm3','0'),('evaluator','task','perm3','eval.c'),('okfiles','task','perm3','1'),('tests','task','triang','10'),('timelimit','task','triang','1'),('memlimit','task','triang','65536'),('unique_output','task','triang','0'),('evaluator','task','triang','eval.c'),('okfiles','task','triang','1'),('tests','task','patrate','25'),('timelimit','task','patrate','0.2'),('memlimit','task','patrate','65536'),('unique_output','task','patrate','1'),('evaluator','task','patrate',''),('okfiles','task','patrate','1'),('tests','task','regine','10'),('timelimit','task','regine','0.1'),('memlimit','task','regine','65536'),('unique_output','task','regine','0'),('evaluator','task','regine','eval.c'),('okfiles','task','regine','1'),('tests','task','robot','20'),('timelimit','task','robot','5'),('memlimit','task','robot','65536'),('unique_output','task','robot','0'),('evaluator','task','robot','eval.c'),('okfiles','task','robot','1'),('tests','task','concurs','10'),('timelimit','task','concurs','2'),('memlimit','task','concurs','65536'),('unique_output','task','concurs','1'),('evaluator','task','concurs',''),('okfiles','task','concurs','1'),('tests','task','tri','20'),('timelimit','task','tri','0.5'),('memlimit','task','tri','65536'),('unique_output','task','tri','0'),('evaluator','task','tri','eval.c'),('okfiles','task','tri','1'),('tests','task','perechi','20'),('timelimit','task','perechi','0.1'),('memlimit','task','perechi','65536'),('unique_output','task','perechi','1'),('evaluator','task','perechi',''),('okfiles','task','perechi','1'),('timelimit','task','homm','1'),('tests','task','homm','10'),('memlimit','task','homm','65536'),('okfiles','task','homm','1'),('tests','task','colectie','10'),('timelimit','task','colectie','1'),('memlimit','task','colectie','65536'),('unique_output','task','colectie','0'),('evaluator','task','colectie','eval.pas'),('okfiles','task','colectie','1'),('tests','task','drumuri','10'),('timelimit','task','drumuri','1'),('memlimit','task','drumuri','65536'),('unique_output','task','drumuri','0'),('evaluator','task','drumuri','eval.c'),('okfiles','task','drumuri','1'),('tests','task','tj','20'),('timelimit','task','tj','4'),('memlimit','task','tj','65536'),('unique_output','task','tj','1'),('evaluator','task','tj',''),('okfiles','task','tj','1'),('tests','task','trapeze','10'),('timelimit','task','trapeze','0.1'),('memlimit','task','trapeze','65536'),('unique_output','task','trapeze','1'),('evaluator','task','trapeze',''),('okfiles','task','trapeze','1'),('tests','task','frac','10'),('timelimit','task','frac','0.1'),('memlimit','task','frac','65536'),('unique_output','task','frac','1'),('evaluator','task','frac',''),('okfiles','task','frac','1'),('tests','task','tvshow','10'),('timelimit','task','tvshow','0.1'),('memlimit','task','tvshow','65536'),('unique_output','task','tvshow','1'),('evaluator','task','tvshow',''),('okfiles','task','tvshow','1'),('tests','task','pal','10'),('timelimit','task','pal','1'),('memlimit','task','pal','65536'),('unique_output','task','pal','0'),('evaluator','task','pal','eval.c'),('okfiles','task','pal','1'),('tests','task','bifo','10'),('timelimit','task','bifo','1'),('memlimit','task','bifo','65536'),('unique_output','task','bifo','1'),('evaluator','task','bifo',''),('okfiles','task','bifo','1'),('tests','task','evantai','20'),('timelimit','task','evantai','1'),('memlimit','task','evantai','65536'),('unique_output','task','evantai','1'),('evaluator','task','evantai',''),('okfiles','task','evantai','1'),('tests','task','algola','10'),('timelimit','task','algola','0.3'),('memlimit','task','algola','65536'),('unique_output','task','algola','1'),('evaluator','task','algola',''),('okfiles','task','algola','1'),('tests','task','camion','10'),('timelimit','task','camion','0.3'),('memlimit','task','camion','65536'),('unique_output','task','camion','1'),('evaluator','task','camion',''),('okfiles','task','camion','1'),('tests','task','luna','20'),('timelimit','task','luna','0.5'),('memlimit','task','luna','65536'),('unique_output','task','luna','1'),('evaluator','task','luna',''),('okfiles','task','luna','1'),('tests','task','gard','20'),('timelimit','task','gard','0.1'),('memlimit','task','gard','65536'),('unique_output','task','gard','1'),('evaluator','task','gard',''),('okfiles','task','gard','1'),('tests','task','gard2','20'),('timelimit','task','gard2','0.1'),('memlimit','task','gard2','65536'),('unique_output','task','gard2','1'),('evaluator','task','gard2',''),('okfiles','task','gard2','1'),('tests','task','otilia','20'),('timelimit','task','otilia','1.5'),('memlimit','task','otilia','65536'),('unique_output','task','otilia','1'),('evaluator','task','otilia',''),('okfiles','task','otilia','1'),('tests','task','delay','10'),('timelimit','task','delay','1'),('memlimit','task','delay','65536'),('unique_output','task','delay','1'),('evaluator','task','delay',''),('okfiles','task','delay','1'),('tests','task','gard3','20'),('timelimit','task','gard3','0.2'),('memlimit','task','gard3','65536'),('unique_output','task','gard3','1'),('evaluator','task','gard3',''),('okfiles','task','gard3','1'),('tests','task','sistem','20'),('timelimit','task','sistem','0.1'),('memlimit','task','sistem','65536'),('unique_output','task','sistem','1'),('evaluator','task','sistem',''),('okfiles','task','sistem','1'),('tests','task','doipatru','20'),('timelimit','task','doipatru','0.1'),('memlimit','task','doipatru','65536'),('unique_output','task','doipatru','1'),('evaluator','task','doipatru',''),('okfiles','task','doipatru','1'),('tests','task','hotel','10'),('timelimit','task','hotel','2'),('memlimit','task','hotel','65536'),('unique_output','task','hotel','1'),('evaluator','task','hotel',''),('okfiles','task','hotel','1'),('tests','task','color','10'),('timelimit','task','color','0.3'),('memlimit','task','color','65536'),('unique_output','task','color','1'),('evaluator','task','color',''),('okfiles','task','color','1'),('tests','task','asmin','20'),('timelimit','task','asmin','0.1'),('memlimit','task','asmin','65536'),('unique_output','task','asmin','1'),('evaluator','task','asmin',''),('okfiles','task','asmin','1'),('tests','task','proc','20'),('timelimit','task','proc','0.2'),('memlimit','task','proc','65536'),('unique_output','task','proc','1'),('evaluator','task','proc',''),('okfiles','task','proc','1'),('tests','task','parcele','20'),('timelimit','task','parcele','2'),('memlimit','task','parcele','65536'),('unique_output','task','parcele','1'),('evaluator','task','parcele',''),('okfiles','task','parcele','1'),('tests','task','soc','20'),('timelimit','task','soc','0.3'),('timelimit','task','adapost','1.5'),('evaluator','task','dreptunghiuri',''),('memlimit','task','dreptunghiuri','65536'),('unique_output','task','balans','1'),('memlimit','task','balans','65536'),('okfiles','task','zebughil','1'),('tests','task','balans','20'),('evaluator','task','zebughil',''),('memlimit','task','zebughil','65536'),('okfiles','task','distante','1'),('tests','task','zebughil','10'),('evaluator','task','distante',''),('unique_output','task','distante','1'),('unique_output','task','geamuri','1'),('timelimit','task','geamuri','0.2'),('okfiles','task','jarbore','1'),('evaluator','task','jarbore',''),('memlimit','task','jarbore','65536'),('tests','task','jarbore','1'),('okfiles','task','cercuri','1'),('okfiles','task','cai','1'),('evaluator','task','cai',''),('timelimit','task','cai','0.5'),('tests','task','cai','1'),('evaluator','task','resturi',''),('memlimit','task','resturi','65536'),('memlimit','task','linterv','65536'),('tests','task','linterv','1'),('okfiles','task','palind','1'),('memlimit','task','palind','65536'),('okfiles','task','divmul','1'),('unique_output','task','divmul','1'),('memlimit','task','divmul','65536'),('tests','task','divmul','1'),('okfiles','task','razboi','1'),('evaluator','task','calatorie',''),('timelimit','task','calatorie','2'),('okfiles','task','expresii','1'),('memlimit','task','expresii','65536'),('tests','task','expresii','1'),('evaluator','task','numere',''),('unique_output','task','numere','1'),('okfiles','task','zoo','1'),('unique_output','task','zoo','1'),('memlimit','task','zoo','65536'),('tests','task','zoo','10'),('evaluator','task','string','eval.c'),('memlimit','task','string','65536'),('tests','task','string','10'),('evaluator','task','poligon2','eval.c'),('memlimit','task','poligon2','65536'),('tests','task','poligon2','10'),('okfiles','task','suma','1'),('unique_output','task','suma','1'),('timelimit','task','suma','0.1'),('tests','task','suma','10'),('evaluator','task','transport',''),('timelimit','task','transport','0.1'),('okfiles','task','muzeu','1'),('evaluator','task','muzeu',''),('timelimit','task','muzeu','0.1'),('okfiles','task','bile','1'),('tests','task','bile','10'),('okfiles','task','arie','1'),('unique_output','task','arie','1'),('timelimit','task','arie','0.1'),('tests','task','arie','10'),('okfiles','task','asmax','1'),('unique_output','task','asmax','1'),('memlimit','task','asmax','65536'),('timelimit','task','granita','0.1'),('tests','task','granita','10'),('evaluator','task','echipe',''),('unique_output','task','echipe','1'),('timelimit','task','echipe','0.1'),('okfiles','task','sediu','1'),('evaluator','task','sediu',''),('memlimit','task','sediu','65536'),('tests','task','sediu','20'),('okfiles','task','comp','1'),('unique_output','task','comp','0'),('memlimit','task','comp','65536'),('tests','task','comp','20'),('evaluator','task','prefix',''),('memlimit','task','prefix','65536'),('tests','task','prefix','10'),('evaluator','task','base3',''),('memlimit','task','base3','65536'),('tests','task','base3','20'),('evaluator','task','color2',''),('unique_output','task','soc','0'),('memlimit','task','soc','65536'),('tests','task','text','10'),('okfiles','task','subsir','1'),('unique_output','task','subsir','0'),('tests','task','subsir','10'),('okfiles','task','petsoft','1'),('unique_output','task','petsoft','0'),('evaluator','task','petsoft','eval.cpp'),('memlimit','task','petsoft','65536'),('timelimit','task','petsoft','0.2'),('okfiles','task','boom','1'),('tests','task','petsoft','10'),('evaluator','task','boom','eval.cpp'),('memlimit','task','boom','65536'),('unique_output','task','boom','0'),('timelimit','task','boom','1'),('tests','task','boom','10'),('evaluator','task','xormax','eval.c'),('okfiles','task','xormax','1'),('unique_output','task','xormax','0'),('timelimit','task','xormax','0.5'),('memlimit','task','xormax','65536'),('tests','task','xormax','10'),('okfiles','task','sobo','1'),('unique_output','task','sobo','0'),('evaluator','task','sobo','eval.cpp'),('memlimit','task','sobo','65536'),('timelimit','task','sobo','2'),('okfiles','task','zaharel','0'),('tests','task','sobo','10'),('evaluator','task','zaharel','eval.c'),('unique_output','task','zaharel','0'),('memlimit','task','zaharel','65536'),('tests','task','zaharel','10'),('timelimit','task','zaharel','0.3'),('okfiles','task','coins','1'),('evaluator','task','coins','eval.c'),('memlimit','task','coins','65536'),('unique_output','task','coins','0'),('timelimit','task','coins','3'),('tests','task','coins','10'),('evaluator','task','tribute','eval.cpp'),('okfiles','task','tribute','1'),('unique_output','task','tribute','0'),('memlimit','task','tribute','65536'),('tests','task','tribute','10'),('timelimit','task','tribute','0.2'),('okfiles','task','atac','1'),('evaluator','task','atac','eval.c'),('memlimit','task','atac','65536'),('unique_output','task','atac','0'),('timelimit','task','atac','3'),('tests','task','atac','10'),('okfiles','task','cutii','1'),('unique_output','task','cutii','0'),('evaluator','task','cutii','eval.c'),('memlimit','task','cutii','65536'),('timelimit','task','cutii','7'),('okfiles','task','party','0'),('tests','task','cutii','10'),('evaluator','task','party','eval.c'),('memlimit','task','party','65536'),('unique_output','task','party','0'),('timelimit','task','party','1'),('tests','task','party','10'),('okfiles','task','fractal','1'),('unique_output','task','fractal','0'),('evaluator','task','fractal','eval.c'),('memlimit','task','fractal','65536'),('timelimit','task','fractal','0.5'),('okfiles','task','bool','1'),('tests','task','fractal','10'),('evaluator','task','bool','eval.c'),('unique_output','task','bool','0'),('timelimit','task','bool','0.2'),('memlimit','task','bool','65536'),('tests','task','bool','10'),('okfiles','task','lacate','0'),('unique_output','task','lacate','0'),('evaluator','task','lacate','eval.c'),('memlimit','task','lacate','65536'),('timelimit','task','lacate','0.1'),('tests','task','lacate','10'),('okfiles','task','traseu','1'),('evaluator','task','traseu','eval.c'),('unique_output','task','traseu','0'),('memlimit','task','traseu','65536'),('timelimit','task','traseu','0.3'),('tests','task','traseu','10'),('okfiles','task','secv3','1'),('evaluator','task','secv3','eval.c'),('unique_output','task','secv3','0'),('memlimit','task','secv3','65536'),('timelimit','task','secv3','0.5'),('tests','task','secv3','10'),('okfiles','task','lapte','1'),('evaluator','task','lapte','eval.c'),('unique_output','task','lapte','0'),('memlimit','task','lapte','65536'),('timelimit','task','lapte','0.5'),('tests','task','lapte','10'),('okfiles','task','secv2','1'),('evaluator','task','secv2','eval.c'),('unique_output','task','secv2','0'),('memlimit','task','secv2','65536'),('timelimit','task','secv2','0.3'),('tests','task','secv2','10'),('okfiles','task','loto','1'),('evaluator','task','loto','eval.c'),('unique_output','task','loto','0'),('memlimit','task','loto','65536'),('timelimit','task','loto','1'),('tests','task','loto','20'),('okfiles','task','energii','1'),('evaluator','task','energii','eval.c'),('unique_output','task','energii','0'),('memlimit','task','energii','65536'),('timelimit','task','energii','0.2'),('tests','task','energii','20'),('okfiles','task','munte','1'),('evaluator','task','munte','eval.c'),('unique_output','task','munte','0'),('memlimit','task','munte','65536'),('timelimit','task','munte','0.1'),('tests','task','munte','10'),('okfiles','task','sume','1'),('evaluator','task','sume','eval.c'),('unique_output','task','sume','0'),('memlimit','task','sume','65536'),('timelimit','task','sume','0.2'),('tests','task','sume','20'),('okfiles','task','prim','1'),('evaluator','task','prim','eval.c'),('unique_output','task','prim','0'),('memlimit','task','prim','65536'),('timelimit','task','prim','1'),('tests','task','prim','10'),('okfiles','task','perle','1'),('evaluator','task','perle','eval.c'),('unique_output','task','perle','0'),('memlimit','task','perle','65536'),('timelimit','task','perle','0.2'),('tests','task','perle','10'),('okfiles','task','zero','1'),('evaluator','task','zero','eval.cpp'),('unique_output','task','zero','0'),('memlimit','task','zero','65536'),('timelimit','task','zero','0.1'),('tests','task','zero','20'),('okfiles','task','tort','1'),('evaluator','task','tort','eval.cpp'),('unique_output','task','tort','0'),('memlimit','task','tort','65536'),('timelimit','task','tort','0.1'),('tests','task','tort','20'),('okfiles','task','pavare','1'),('evaluator','task','pavare','eval.c'),('unique_output','task','pavare','0'),('memlimit','task','pavare','65536'),('timelimit','task','pavare','0.8'),('tests','task','pavare','10'),('okfiles','task','sir23','1'),('tests','task','sir23','10'),('timelimit','task','sir23','1'),('unique_output','task','sir23','0'),('okfiles','task','triunghi','0'),('evaluator','task','triunghi','eval.c'),('unique_output','task','triunghi','0'),('memlimit','task','triunghi','65536'),('timelimit','task','triunghi','0.1'),('tests','task','triunghi','10'),('okfiles','task','joc','1'),('evaluator','task','joc','eval.c'),('unique_output','task','joc','0'),('memlimit','task','joc','65536'),('timelimit','task','joc','0.75'),('tests','task','joc','10'),('okfiles','task','perm2','1'),('evaluator','task','perm2','eval.c'),('unique_output','task','perm2','0'),('memlimit','task','perm2','65536'),('timelimit','task','perm2','0.1'),('tests','task','perm2','20'),('okfiles','task','secventa','1'),('evaluator','task','secventa',''),('unique_output','task','secventa','1'),('memlimit','task','secventa','65536'),('timelimit','task','secventa','0.18'),('tests','task','secventa','10'),('okfiles','task','petrica','1'),('evaluator','task','petrica','eval.c'),('unique_output','task','petrica','0'),('memlimit','task','petrica','65536'),('timelimit','task','petrica','0.3'),('tests','task','petrica','10'),('okfiles','task','pietre','1'),('evaluator','task','pietre','eval.cpp'),('unique_output','task','pietre','0'),('memlimit','task','pietre','65536'),('timelimit','task','pietre','0.1'),('tests','task','pietre','20'),('okfiles','task','copaci','1'),('evaluator','task','copaci','eval.cpp'),('unique_output','task','copaci','0'),('memlimit','task','copaci','65536'),('timelimit','task','copaci','0.1'),('tests','task','copaci','10'),('okfiles','task','stramosi','1'),('evaluator','task','stramosi','eval.c'),('unique_output','task','stramosi','0'),('memlimit','task','stramosi','65536'),('timelimit','task','stramosi','1.2'),('tests','task','stramosi','10'),('okfiles','task','tabela','1'),('evaluator','task','tabela','eval.c'),('unique_output','task','tabela','0'),('memlimit','task','tabela','65536'),('timelimit','task','tabela','0.1'),('tests','task','tabela','50'),('okfiles','task','cifra','1'),('evaluator','task','cifra','eval.c'),('unique_output','task','cifra','0'),('memlimit','task','cifra','65536'),('timelimit','task','cifra','0.1'),('tests','task','cifra','10'),('okfiles','task','datorii','1'),('evaluator','task','datorii','eval.c'),('unique_output','task','datorii','0'),('memlimit','task','datorii','65536'),('timelimit','task','datorii','0.2'),('tests','task','datorii','5'),('okfiles','task','fact','1'),('evaluator','task','fact','eval.c'),('unique_output','task','fact','0'),('memlimit','task','fact','65536'),('timelimit','task','fact','0.5'),('tests','task','fact','20'),('okfiles','task','perm','1'),('evaluator','task','perm','eval.c'),('unique_output','task','perm','0'),('memlimit','task','perm','65536'),('timelimit','task','perm','0.3'),('tests','task','perm','10'),('okfiles','task','biti','1'),('evaluator','task','biti','eval.c'),('unique_output','task','biti','0'),('memlimit','task','biti','65536'),('timelimit','task','biti','1'),('tests','task','biti','20'),('okfiles','task','fractii','1'),('evaluator','task','fractii','eval.c'),('unique_output','task','fractii','0'),('memlimit','task','fractii','65536'),('timelimit','task','fractii','2'),('tests','task','fractii','10'),('okfiles','task','flip','1'),('evaluator','task','flip','eval.c'),('unique_output','task','flip','0'),('memlimit','task','flip','65536'),('timelimit','task','flip','0.5'),('tests','task','flip','10'),('okfiles','task','cmmdc','0'),('evaluator','task','cmmdc','eval.c'),('unique_output','task','cmmdc','0'),('memlimit','task','cmmdc','65536'),('timelimit','task','cmmdc','0.1'),('tests','task','cmmdc','10'),('okfiles','task','adunare','0'),('evaluator','task','adunare','eval.c'),('tests','task','adunare','10'),('timelimit','task','adunare','0.1'),('memlimit','task','adunare','65536'),('unique_output','task','adunare','0'),('tests','task','rf','20'),('timelimit','task','rf','0.4'),('memlimit','task','rf','65536'),('unique_output','task','rf','1'),('evaluator','task','rf',''),('okfiles','task','rf','1'),('tests','task','biomech','20'),('timelimit','task','biomech','1'),('memlimit','task','biomech','65536'),('unique_output','task','biomech','1'),('evaluator','task','biomech',''),('okfiles','task','biomech','1'),('tests','task','emm','20'),('timelimit','task','emm','1'),('memlimit','task','emm','65536'),('unique_output','task','emm','1'),('evaluator','task','emm',''),('okfiles','task','emm','1'),('tests','task','zeap','10'),('timelimit','task','zeap','1.7'),('memlimit','task','zeap','65536'),('unique_output','task','zeap','1'),('evaluator','task','zeap',''),('okfiles','task','zeap','1'),('tests','task','noroc','10'),('timelimit','task','noroc','0.1'),('memlimit','task','noroc','65536'),('unique_output','task','noroc','1'),('evaluator','task','noroc',''),('okfiles','task','noroc','1'),('rating_timestamp','round','autumn06','1157714431'),('rating_timestamp','round','filip1','1100419537'),('rating_timestamp','round','filip2','1100420831'),('rating_timestamp','round','happy','1126335958'),('rating_timestamp','round','happy2006','1160382340'),('rating_timestamp','round','hc2','1129964392'),('rating_timestamp','round','moisil1','1143726383'),('rating_timestamp','round','moisil2','1143724418'),('rating_timestamp','round','moisil3','1143724001'),('rating_timestamp','round','moisil4','1143724349'),('rating_timestamp','round','preoji1','1077460486'),('rating_timestamp','round','preoji2','1077459949'),('rating_timestamp','round','preoni1','1080397170'),('rating_timestamp','round','preoni2','1080398009'),('rating_timestamp','round','preoni3','1080479128'),('rating_timestamp','round','preoni4','1080482118'),('rating_timestamp','round','preoni51a','1106485077'),('rating_timestamp','round','preoni51b','1106486267'),('rating_timestamp','round','preoni52a','1109169527'),('rating_timestamp','round','preoni52b','1109168971'),('rating_timestamp','round','preoni53a','1111317511'),('rating_timestamp','round','preoni53b','1111317540'),('rating_timestamp','round','preoni61a','1132384478'),('rating_timestamp','round','preoni61b','1132385899'),('rating_timestamp','round','preoni61c','1132385123'),('rating_timestamp','round','preoni62a','1134806504'),('rating_timestamp','round','preoni62b','1134806436'),('rating_timestamp','round','preoni62c','1134806431'),('rating_timestamp','round','preoni63a','1137838443'),('rating_timestamp','round','preoni63b','1137838422'),('rating_timestamp','round','preoni63c','1137838881'),('rating_timestamp','round','preoni64a','1140352884'),('rating_timestamp','round','preoni64b','1140351520'),('rating_timestamp','round','preoni64c','1140353207'),('rating_timestamp','round','preoni65a','1143272313'),('rating_timestamp','round','preoni65b','1143273413'),('rating_timestamp','round','preoni65c','1143274229'),('rating_timestamp','round','summer06','1154604552'),('rating_timestamp','round','summer2','1155287712'),('rating_timestamp','round','summer3','1156663015'),('rating_update','round','autumn06','1'),('rating_update','round','ba6','1'),('rating_update','round','filip1','1'),('rating_update','round','filip2','1'),('rating_update','round','happy','1'),('rating_update','round','happy2006','1'),('rating_update','round','hc2','1'),('rating_update','round','moisil1','1'),('rating_update','round','moisil2','1'),('rating_update','round','moisil3','1'),('rating_update','round','moisil4','1'),('rating_update','round','preoji1','1'),('rating_update','round','preoji2','1'),('rating_update','round','preoni1','1'),('rating_update','round','preoni2','1'),('rating_update','round','preoni3','1'),('rating_update','round','preoni4','1'),('rating_update','round','preoni51a','1'),('rating_update','round','preoni51b','1'),('rating_update','round','preoni52a','1'),('rating_update','round','preoni52b','1'),('rating_update','round','preoni53a','1'),('rating_update','round','preoni53b','1'),('rating_update','round','preoni61a','1'),('rating_update','round','preoni61b','1'),('rating_update','round','preoni61c','1'),('rating_update','round','preoni62a','1'),('rating_update','round','preoni62b','1'),('rating_update','round','preoni62c','1'),('rating_update','round','preoni63a','1'),('rating_update','round','preoni63b','1'),('rating_update','round','preoni63c','1'),('rating_update','round','preoni64a','1'),('rating_update','round','preoni64b','1'),('rating_update','round','preoni64c','1'),('duration','round','preoni65a','5'),('rating_update','round','preoni65b','1'),('rating_update','round','preoni65c','1'),('rating_update','round','summer06','1'),('rating_update','round','summer2','1'),('rating_update','round','summer3','1'),('rating_timestamp','round','ba6','1120893742'),('duration','round','ba6','4.5'),('duration','round','bac2005','4.5'),('duration','round','autumn06','4.5'),('unique_output','task','homm','1'),('evaluator','task','homm',''),('duration','round','filip1','4.5'),('duration','round','filip2','4.5'),('duration','round','happy','4.5'),('duration','round','happy2006','4.5'),('duration','round','hc2','4.5'),('duration','round','moisil1','4.5'),('duration','round','moisil2','4.5'),('duration','round','moisil3','4.5'),('duration','round','moisil4','4.5'),('duration','round','preoji1','4.5'),('duration','round','preoji2','4.5'),('duration','round','preoni1','4.5'),('duration','round','preoni2','4.5'),('duration','round','preoni3','4.5'),('duration','round','preoni4','4.5'),('duration','round','preoni51a','4.5'),('duration','round','preoni51b','4.5'),('duration','round','preoni52a','4.5'),('duration','round','preoni52b','4.5'),('duration','round','preoni53a','4.5'),('duration','round','preoni53b','4.5'),('duration','round','preoni61a','4.5'),('duration','round','preoni61b','4.5'),('duration','round','preoni61c','4.5'),('duration','round','preoni62a','4.5'),('duration','round','preoni62b','4.5'),('duration','round','preoni62c','4.5'),('duration','round','preoni63a','4.5'),('duration','round','preoni63b','4.5'),('duration','round','preoni63c','4.5'),('duration','round','preoni64a','4.5'),('duration','round','preoni64b','4.5'),('duration','round','preoni64c','4.5'),('rating_update','round','preoni65a','1'),('duration','round','preoni65b','4.5'),('duration','round','preoni65c','4.5'),('duration','round','summer06','4.5'),('duration','round','summer2','4.5'),('duration','round','summer3','4.5'),('memlimit','task','sir23','65536'),('evaluator','task','sir23','eval.c'),('memlimit','task','perm4','16000'),('timelimit','task','nr','2.5'),('tests','task','nr','10'),('okfiles','task','nr','1'),('memlimit','task','nr','16000'),('evaluator','task','nr',''),('tests','task','perm4','10'),('timelimit','task','perm4','1'),('okfiles','task','perm4','1'),('evaluator','task','perm4',''),('timelimit','task','criptare','0.1'),('tests','task','criptare','10'),('okfiles','task','criptare','1'),('evaluator','task','criptare',''),('memlimit','task','criptare','16000'),('tests','task','elimin','10'),('okfiles','task','elimin','1'),('memlimit','task','elimin','2048'),('memlimit','task','diviz','2048'),('okfiles','task','diviz','1'),('tests','task','diviz','10'),('memlimit','task','pachete','16384'),('okfiles','task','pachete','1'),('tests','task','pachete','10'),('timelimit','task','pachete','0.2'),('evaluator','task','pachete',''),('timelimit','task','Radiatii','1'),('memlimit','task','Radiatii','16000'),('tests','task','Radiatii','10'),('okfiles','task','Radiatii','0'),('evaluator','task','Radiatii','eval.c'),('timelimit','task','radiatie','0.5'),('tests','task','radiatie','10'),('okfiles','task','radiatie','1'),('memlimit','task','radiatie','16384'),('evaluator','task','radiatie',''),('duration','round','preoni-2007','4.5'),('rating_update','round','unirea9-10','1'),('timelimit','task','elimin','0.3'),('evaluator','task','diviz',''),('evaluator','task','elimin',''),('timelimit','task','diviz','0.3'),('timelimit','task','1-sir','0.3'),('tests','task','1-sir','10'),('okfiles','task','1-sir','1'),('evaluator','task','1-sir',''),('memlimit','task','1-sir','16000'),('memlimit','task','triplete','16384'),('okfiles','task','triplete','1'),('tests','task','triplete','10'),('timelimit','task','triplete','0.3'),('memlimit','task','aprindere','16000'),('okfiles','task','aprindere','1'),('tests','task','aprindere','20'),('timelimit','task','aprindere','0.2'),('timelimit','task','patrate3','0.5'),('evaluator','task','aprindere',''),('evaluator','task','patrate3',''),('memlimit','task','patrate3','16000'),('okfiles','task','patrate3','1'),('tests','task','patrate3','20'),('evaluator','task','triplete',''),('rating_update','round','preoni2007_runda1_9','1'),('duration','round','preoni2007_runda1_9','4'),('duration','round','preoni2007_runda1_10','4'),('rating_timestamp','round','preoni2007_runda1_10','1169384954'),('rating_update','round','preoni2007_runda1_1112','1'),('duration','round','preoni2007_runda1_1112','4'),('duration','round','test-cristi','0.16'),('evaluator','task','test-p1','eval.c'),('memlimit','task','test-p1','16000'),('okfiles','task','test-p1','0'),('tests','task','test-p1','10'),('timelimit','task','test-p1','1'),('duration','round','arhiva','10000000'),('rating_timestamp','round','preoni2007_runda1_9','1169384946'),('rating_update','round','preoni2007_runda1_10','1'),('rating_timestamp','round','preoni2007_runda1_1112','1169384958'),('duration','round','unirea9-10','3'),('rating_update','round','unirea11-12','1'),('duration','round','unirea11-12','3'),('memlimit','task','maxsecv','16000'),('okfiles','task','maxsecv','1'),('tests','task','maxsecv','10'),('timelimit','task','maxsecv','0.4'),('evaluator','task','maxsecv',''),('tests','task','amenzi','10'),('okfiles','task','amenzi','1'),('memlimit','task','amenzi','16000'),('evaluator','task','amenzi',''),('timelimit','task','chernel','0.5'),('tests','task','chernel','10'),('okfiles','task','chernel','1'),('memlimit','task','chernel','16000'),('evaluator','task','chernel',''),('memlimit','task','secv5','65536'),('okfiles','task','secv5','1'),('tests','task','secv5','10'),('timelimit','task','secv5','1.5'),('timelimit','task','amenzi','0.3'),('evaluator','task','secv5',''),('rating_timestamp','round','unirea9-10','1169899200'),('rating_timestamp','round','unirea11-12','1169899200'),('rating_timestamp','round','arhiva','0');
/*!40000 ALTER TABLE `ia_parameter_value` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_round`
--

DROP TABLE IF EXISTS `ia_round`;
CREATE TABLE `ia_round` (
  `id` varchar(64) collate latin1_general_ci NOT NULL default '',
  `title` varchar(64) collate latin1_general_ci default NULL,
  `page_name` varchar(64) collate latin1_general_ci default NULL,
  `state` enum('running','waiting','complete') collate latin1_general_ci NOT NULL default 'waiting',
  `start_time` datetime default NULL,
  `type` enum('classic','archive') collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_round`
--

LOCK TABLES `ia_round` WRITE;
/*!40000 ALTER TABLE `ia_round` DISABLE KEYS */;
INSERT INTO `ia_round` VALUES ('preoji2','2004, preOJI, clasele XI-XII','preoji-2004','complete',NULL,'classic'),('preoji1','2004, preOJI, clasele IX-X','preoji-2004','complete',NULL,'classic'),('arhiva','Arhiva de probleme, pregatire pentru concursuri de informatica','arhiva','running','1970-01-01 00:00:00','archive'),('preoni4','2004, preONI, ZIUA2, clasele XI-XI','preoni-2004/runda-2','complete',NULL,'classic'),('preoni3','2004, preONI, ZIUA2, clasele IX-X','preoni-2004/runda-2','complete',NULL,'classic'),('preoni2','2004, preONI, ZIUA1, clasele XI-XI','preoni-2004/runda-1','complete',NULL,'classic'),('preoni1','2004, preONI, ZIUA1, clasele IX-X','preoni-2004/runda-1','complete',NULL,'classic'),('filip1','Concurs de incalzire, clasele IX-X','warm-up-2004','complete',NULL,'classic'),('filip2','Concurs de incalzire, clasele XI-XII','warm-up-2004','complete',NULL,'classic'),('preoni51a','preONI 2005, runda 1, clasele IX-X','preoni-2005/runda-1','complete',NULL,'classic'),('preoni51b','preONI 2005, runda 1, clasele XI-XII','preoni-2005/runda-1','complete',NULL,'classic'),('preoni52a','preONI 2005, runda 2, clasele IX-X','preoni-2005/runda-2','complete',NULL,'classic'),('preoni52b','preONI 2005, runda 2, clasele XI-XII','preoni-2005/runda-2','complete',NULL,'classic'),('preoni53a','preONI 2005, runda 3, clasele IX-X','preoni-2005/runda-3','complete',NULL,'classic'),('preoni53b','preONI 2005, runda 3, clasele XI-XII','preoni-2005/runda-3','complete',NULL,'classic'),('ba6','Bursele Agora editia 6, finala online','agora-finala','complete',NULL,'classic'),('bac2005','Bacalaureat 2005','bacalaureat-2005','complete',NULL,'classic'),('happy','Happy Coding 2005','happy-coding-2005-1','complete',NULL,'classic'),('hc2','Happy Coding 2','happy-coding-2005-2','complete',NULL,'classic'),('preoni61b','[preONI 2006] Runda #1, clasa a X-a','preoni-2006/runda-1','complete',NULL,'classic'),('preoni61c','[preONI 2006] Runda #1, clasele XI-XII','preoni-2006/runda-1','complete',NULL,'classic'),('preoni62a','[preONI 2006] Runda #2, clasa a IX-a (si gimnaziu)','preoni-2006/runda-2','complete',NULL,'classic'),('preoni62b','[preONI 2006] Runda #2, clasa a X-a','preoni-2006/runda-2','complete',NULL,'classic'),('preoni62c','[preONI 2006] Runda #2, clasele XI-XII','preoni-2006/runda-2','complete',NULL,'classic'),('preoni61a','[preONI 2006] Runda #1, clasa a IX-a (si gimnaziu)','preoni-2006/runda-1','complete',NULL,'classic'),('preoni63c','[preONI 2006] Runda #3, clasele XI-XII','preoni-2006/runda-3','complete',NULL,'classic'),('preoni63b','[preONI 2006] Runda #3, clasa a X-a','preoni-2006/runda-3','complete',NULL,'classic'),('preoni63a','[preONI 2006] Runda #3, clasa a IX-a (si gimnaziu)','preoni-2006/runda-3','complete',NULL,'classic'),('preoni64a','[preONI 2006] Runda #4, clasa a IX-a (si gimnaziu)','preoni-2006/runda-4','complete',NULL,'classic'),('preoni64b','[preONI 2006] Runda #4, clasa a X-a','preoni-2006/runda-4','complete',NULL,'classic'),('preoni64c','[preONI 2006] Runda #4, clasele XI-XII','preoni-2006/runda-4','complete',NULL,'classic'),('preoni65b','[preONI 2006] Runda Finala, clasa a X-a','preoni-2006/finala','complete',NULL,'classic'),('preoni65a','[preONI 2006] Runda Finala, clasa a IX-a (si gimnaziu)','preoni-2006/finala','complete','2006-03-25 00:00:00','classic'),('moisil1','Grigore Moisil By Net, clasele VII-VIII','moisil-by-net-2006','complete',NULL,'classic'),('preoni65c','[preONI 2006] Runda Finala, clasele XI-XII','preoni-2006/finala','complete',NULL,'classic'),('moisil3','Grigore Moisil By Net, clasa a X-a','moisil-by-net-2006','complete',NULL,'classic'),('moisil4','Grigore Moisil By Net, clasele XI-XII','moisil-by-net-2006','complete',NULL,'classic'),('moisil2','Grigore Moisil By Net, clasa a IX-a','moisil-by-net-2006','complete',NULL,'classic'),('summer06','Summer Challenge Unu','summer-challenge-unu','complete',NULL,'classic'),('summer2','Summer Challenge Doi','summer-challenge-2','complete',NULL,'classic'),('summer3','Summer Challenge Trei','summer-challenge-3','complete',NULL,'classic'),('autumn06','Autumn WarmUp 2006','warm-up-2006','complete',NULL,'classic'),('happy2006','Happy Coding 2006','happy-coding-2006','complete',NULL,'classic'),('preoni-2007','preoni-2007','runda/preoni-2007','waiting',NULL,'classic'),('preoni2007_runda1_9','preONI 2007, Runda 1, Clasa a 9-a si gimnaziu','preoni-2007/runda-1/9','complete','2007-01-21 07:30:00','classic'),('preoni2007_runda1_10','preONI 2007, Runda 1, Clasa a 10-a','preoni-2007/runda-1/10','complete','2007-01-21 07:30:00','classic'),('preoni2007_runda1_1112','preONI 2007, Runda 1, Clasele 11-12','preoni-2007/runda-1/11-12','complete','2007-01-21 07:30:00','classic'),('test-cristi','test-cristi','runda/test-cristi','complete','2007-01-20 23:30:00','classic'),('unirea9-10','Unirea 2007, clasele 9-10','unirea-2007/clasele-9-10','complete','2007-01-27 12:00:00','classic'),('unirea11-12','Unirea 2007, clasele 11-12','unirea-2007/clasele-11-12','complete','2007-01-27 12:00:00','classic');
/*!40000 ALTER TABLE `ia_round` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_round_task`
--

DROP TABLE IF EXISTS `ia_round_task`;
CREATE TABLE `ia_round_task` (
  `round_id` varchar(64) collate latin1_general_ci NOT NULL default '',
  `task_id` varchar(64) collate latin1_general_ci NOT NULL default '',
  PRIMARY KEY  (`round_id`,`task_id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_round_task`
--

LOCK TABLES `ia_round_task` WRITE;
/*!40000 ALTER TABLE `ia_round_task` DISABLE KEYS */;
INSERT INTO `ia_round_task` VALUES ('arhiva','1-sir'),('arhiva','12perm'),('arhiva','1expr'),('arhiva','abc'),('arhiva','acolor'),('arhiva','adapost'),('arhiva','adapost2'),('arhiva','adn'),('arhiva','adunare'),('arhiva','aladdin'),('arhiva','aladdin2'),('arhiva','algola'),('arhiva','alpin'),('arhiva','amenzi'),('arhiva','apdm'),('arhiva','aprindere'),('arhiva','arbciclu'),('arhiva','arbfind'),('arhiva','arbore'),('arhiva','arie'),('arhiva','asmax'),('arhiva','asmin'),('arhiva','atac'),('arhiva','avd'),('arhiva','avere'),('arhiva','balans'),('arhiva','banana'),('arhiva','barbar'),('arhiva','barman'),('arhiva','base3'),('arhiva','bcolor'),('arhiva','ben'),('arhiva','bifo'),('arhiva','bile'),('arhiva','bilete'),('arhiva','biomech'),('arhiva','biscuiti'),('arhiva','biti'),('arhiva','biti2'),('arhiva','bmatrix'),('arhiva','bombar'),('arhiva','bool'),('arhiva','boom'),('arhiva','bridge'),('arhiva','cai'),('arhiva','calatorie'),('arhiva','calcul'),('arhiva','camera'),('arhiva','camion'),('arhiva','car'),('arhiva','caraibe'),('arhiva','catun'),('arhiva','cc'),('arhiva','cercuri'),('arhiva','cercuri2'),('arhiva','cerere'),('arhiva','chernel'),('arhiva','ciclu'),('arhiva','cifra'),('arhiva','cifre'),('arhiva','cifru'),('arhiva','cmmdc'),('arhiva','coach'),('arhiva','cobai'),('arhiva','coins'),('arhiva','colectie'),('arhiva','color'),('arhiva','color2'),('arhiva','colorare'),('arhiva','comp'),('arhiva','concert'),('arhiva','concurs'),('arhiva','copaci'),('arhiva','count'),('arhiva','cowfood'),('arhiva','criptare'),('arhiva','critice'),('arhiva','csir'),('arhiva','ct'),('arhiva','custi'),('arhiva','cutii'),('arhiva','dame'),('arhiva','datorii'),('arhiva','delay'),('arhiva','demolish'),('arhiva','desc'),('arhiva','distante'),('arhiva','diviz'),('arhiva','divizori'),('arhiva','divk'),('arhiva','divmul'),('arhiva','divprim'),('arhiva','dmg'),('arhiva','dmin'),('arhiva','doipatru'),('arhiva','domino'),('arhiva','dreptunghiuri'),('arhiva','drumuri'),('arhiva','drumuri2'),('arhiva','echipe'),('arhiva','ecu'),('arhiva','elimin'),('arhiva','emm'),('arhiva','energii'),('arhiva','eq'),('arhiva','eqs'),('arhiva','euler'),('arhiva','euro'),('arhiva','evantai'),('arhiva','expr'),('arhiva','expresii'),('arhiva','fact'),('arhiva','farey'),('arhiva','farfurii'),('arhiva','ferma'),('arhiva','figuri'),('arhiva','flip'),('arhiva','fold'),('arhiva','frac'),('arhiva','fractal'),('arhiva','fractii'),('arhiva','free'),('arhiva','game'),('arhiva','gard'),('arhiva','gard2'),('arhiva','gard3'),('arhiva','geamuri'),('arhiva','geom'),('arhiva','geometry'),('arhiva','gfact'),('arhiva','gold'),('arhiva','graf'),('arhiva','granita'),('arhiva','grazing'),('arhiva','grupuri'),('arhiva','hallway'),('arhiva','hanoi4'),('arhiva','harta'),('arhiva','homm'),('arhiva','hotel'),('arhiva','hprob'),('arhiva','iepuri'),('arhiva','indep'),('arhiva','insula'),('arhiva','int'),('arhiva','invcs'),('arhiva','invers'),('arhiva','invsc'),('arhiva','invsort'),('arhiva','itree'),('arhiva','iv'),('arhiva','jarbore'),('arhiva','java'),('arhiva','joc'),('arhiva','joc2'),('arhiva','joc3'),('arhiva','jocul'),('arhiva','lacate'),('arhiva','lanterna'),('arhiva','lapte'),('arhiva','lesbulan'),('arhiva','linterv'),('arhiva','loto'),('arhiva','luna'),('arhiva','lupu'),('arhiva','map'),('arhiva','matrix'),('arhiva','maxsecv'),('arhiva','mine'),('arhiva','minim'),('arhiva','monezi'),('arhiva','mult'),('arhiva','munte'),('arhiva','muzeu'),('arhiva','nextseq'),('arhiva','nodiv'),('arhiva','noroc'),('arhiva','note'),('arhiva','nr'),('arhiva','nrcuv'),('arhiva','nrtri'),('arhiva','numar'),('arhiva','numere'),('arhiva','numere2'),('arhiva','obj'),('arhiva','omizi'),('arhiva','oras'),('arhiva','order'),('arhiva','otilia'),('arhiva','overlap'),('arhiva','pachete'),('arhiva','pal'),('arhiva','palind'),('arhiva','panouri'),('arhiva','paralelograme'),('arhiva','parcare'),('arhiva','parcele'),('arhiva','party'),('arhiva','pascal'),('arhiva','password'),('arhiva','path'),('arhiva','patrate'),('arhiva','patrate2'),('arhiva','patrate3'),('arhiva','patrol'),('arhiva','pavare'),('arhiva','pavare2'),('arhiva','pawns'),('arhiva','pedefe'),('arhiva','perechi'),('arhiva','perle'),('arhiva','perm'),('arhiva','perm2'),('arhiva','perm3'),('arhiva','perm4'),('arhiva','petrica'),('arhiva','petsoft'),('arhiva','pietre'),('arhiva','plimbare'),('arhiva','points'),('arhiva','poligon'),('arhiva','poligon2'),('arhiva','poly'),('arhiva','popandai'),('arhiva','popandai2'),('arhiva','prefix'),('arhiva','prim'),('arhiva','proc'),('arhiva','pscnv'),('arhiva','pscpld'),('arhiva','puternic'),('arhiva','radiatie'),('arhiva','razboi'),('arhiva','reg'),('arhiva','regine'),('arhiva','resturi'),('arhiva','reuniune'),('arhiva','rf'),('arhiva','robot'),('arhiva','robotei'),('arhiva','rubarba'),('arhiva','sah'),('arhiva','santa'),('arhiva','secv'),('arhiva','secv2'),('arhiva','secv3'),('arhiva','secv4'),('arhiva','secv5'),('arhiva','secventa'),('arhiva','sediu'),('arhiva','semne'),('arhiva','senat'),('arhiva','sequencequery'),('arhiva','seti'),('arhiva','sir'),('arhiva','sir23'),('arhiva','siruri'),('arhiva','sistem'),('arhiva','sobo'),('arhiva','soc'),('arhiva','soldati'),('arhiva','sortari'),('arhiva','sortnet'),('arhiva','spirala'),('arhiva','srevni'),('arhiva','sticle'),('arhiva','stramosi'),('arhiva','string'),('arhiva','struti'),('arhiva','subsir'),('arhiva','subsir2'),('arhiva','subsiruri'),('arhiva','substr'),('arhiva','sum'),('arhiva','suma'),('arhiva','sumdiv'),('arhiva','sume'),('arhiva','superp'),('arhiva','supersf'),('arhiva','swap'),('arhiva','tabela'),('arhiva','telegraf'),('arhiva','text'),('arhiva','timbre'),('arhiva','tj'),('arhiva','tort'),('arhiva','trans'),('arhiva','transport'),('arhiva','trapez'),('arhiva','trapeze'),('arhiva','traseu'),('arhiva','treid'),('arhiva','tri'),('arhiva','tri2'),('arhiva','triang'),('arhiva','trib'),('arhiva','tribute'),('arhiva','triplete'),('arhiva','triunghi'),('arhiva','turneu'),('arhiva','tvshow'),('arhiva','vila'),('arhiva','xormax'),('arhiva','z'),('arhiva','zaharel'),('arhiva','zapada'),('arhiva','zc'),('arhiva','zeap'),('arhiva','zebughil'),('arhiva','zero'),('arhiva','zoo'),('autumn06','bridge'),('autumn06','eq'),('autumn06','parcare'),('autumn06','poly'),('autumn06','secv4'),('ba6','colectie'),('ba6','drumuri'),('ba6','homm'),('bac2005','bur01'),('bac2005','bur02'),('bac2005','div3'),('bac2005','matrice'),('bac2005','multimi'),('bac2005','numere'),('filip1','coins'),('filip1','sobo'),('filip1','zaharel'),('filip2','boom'),('filip2','petsoft'),('filip2','xormax'),('happy','arie'),('happy','bile'),('happy','muzeu'),('happy','numere'),('happy','suma'),('happy','transport'),('happy2006','1expr'),('happy2006','arbciclu'),('happy2006','avd'),('happy2006','biomech'),('happy2006','cc'),('happy2006','ct'),('happy2006','emm'),('happy2006','geometry'),('happy2006','hanoi4'),('happy2006','hprob'),('happy2006','int'),('happy2006','itree'),('happy2006','java'),('happy2006','joc3'),('happy2006','nodiv'),('happy2006','noroc'),('happy2006','obj'),('happy2006','rf'),('happy2006','swap'),('happy2006','zeap'),('hc2','cai'),('hc2','calatorie'),('hc2','cercuri'),('hc2','divmul'),('hc2','expresii'),('hc2','jarbore'),('hc2','linterv'),('hc2','palind'),('hc2','razboi'),('hc2','resturi'),('moisil1','minim'),('moisil1','spirala'),('moisil2','figuri'),('moisil2','jocul'),('moisil3','numar'),('moisil3','subsiruri'),('moisil4','domino'),('moisil4','popandai2'),('moisil4','z'),('preoji1','joc'),('preoji1','perm2'),('preoji2','petrica'),('preoji2','secventa'),('preoni1','lapte'),('preoni1','loto'),('preoni1','secv2'),('preoni2','lacate'),('preoni2','secv3'),('preoni2','traseu'),('preoni2007_runda1_10','elimin'),('preoni2007_runda1_10','pachete'),('preoni2007_runda1_10','triplete'),('preoni2007_runda1_1112','1-sir'),('preoni2007_runda1_1112','diviz'),('preoni2007_runda1_1112','radiatie'),('preoni2007_runda1_9','aprindere'),('preoni2007_runda1_9','elimin'),('preoni2007_runda1_9','patrate3'),('preoni3','bool'),('preoni3','fractal'),('preoni3','party'),('preoni4','atac'),('preoni4','cutii'),('preoni4','tribute'),('preoni51a','subsir'),('preoni51a','text'),('preoni51a','trapez'),('preoni51b','adn'),('preoni51b','barbar'),('preoni51b','iepuri'),('preoni52a','car'),('preoni52a','pascal'),('preoni52a','secv'),('preoni52b','cerere'),('preoni52b','indep'),('preoni52b','rubarba'),('preoni53a','barman'),('preoni53a','cifre'),('preoni53a','farfurii'),('preoni53b','critice'),('preoni53b','ferma'),('preoni53b','poligon'),('preoni61a','invers'),('preoni61a','patrate2'),('preoni61a','reuniune'),('preoni61b','dreptunghiuri'),('preoni61b','invers'),('preoni61b','zebughil'),('preoni61c','balans'),('preoni61c','distante'),('preoni61c','zebughil'),('preoni62a','dame'),('preoni62a','grupuri'),('preoni62a','zc'),('preoni62b','12perm'),('preoni62b','desc'),('preoni62b','grupuri'),('preoni62c','camera'),('preoni62c','desc'),('preoni62c','struti'),('preoni63a','divprim'),('preoni63a','nrtri'),('preoni63a','subsir2'),('preoni63b','pavare2'),('preoni63b','subsir2'),('preoni63b','sum'),('preoni63c','count'),('preoni63c','cowfood'),('preoni63c','subsir2'),('preoni64a','gfact'),('preoni64a','matrix'),('preoni64a','nextseq'),('preoni64b','calcul'),('preoni64b','matrix'),('preoni64b','nrcuv'),('preoni64c','calcul'),('preoni64c','dmin'),('preoni64c','popandai'),('preoni65a','divk'),('preoni65a','lupu'),('preoni65a','overlap'),('preoni65b','divk'),('preoni65b','iv'),('preoni65b','robotei'),('preoni65c','arbore'),('preoni65c','pedefe'),('preoni65c','pscnv'),('summer06','free'),('summer06','patrol'),('summer06','pscpld'),('summer2','plimbare'),('summer2','sah'),('summer2','treid'),('summer3','abc'),('summer3','gold'),('summer3','oras'),('test-cristi','test-p1'),('unirea11-12','amenzi'),('unirea11-12','secv5'),('unirea9-10','chernel'),('unirea9-10','maxsecv');
/*!40000 ALTER TABLE `ia_round_task` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_score`
--

DROP TABLE IF EXISTS `ia_score`;
CREATE TABLE `ia_score` (
  `name` varchar(64) collate latin1_general_ci default NULL,
  `user_id` int(11) default NULL,
  `round_id` varchar(64) collate latin1_general_ci default NULL,
  `task_id` varchar(64) collate latin1_general_ci default NULL,
  `score` decimal(11,4) NOT NULL,
  UNIQUE KEY `name` (`name`,`user_id`,`round_id`,`task_id`),
  KEY `name_round_score` (`name`,`round_id`,`score`),
  KEY `name_task_score` (`name`,`task_id`,`score`),
  KEY `name_user_score` (`name`,`user_id`,`score`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_score`
--

LOCK TABLES `ia_score` WRITE;
/*!40000 ALTER TABLE `ia_score` DISABLE KEYS */;
INSERT INTO `ia_score` VALUES ('score',13,'arhiva','adunare','100.0000'),('submit_count',13,'arhiva','adunare','100.0000'),('score',13,'arhiva','cmmdc','100.0000'),('submit_count',13,'arhiva','cmmdc','100.0000'),('score',1,'arhiva','cmmdc','100.0000'),('submit_count',1,'arhiva','cmmdc','100.0000'),('score',1,'arhiva','adunare','100.0000'),('submit_count',1,'arhiva','adunare','100.0000'),('score',18,'arhiva','adunare','100.0000'),('submit_count',18,'arhiva','adunare','100.0000'),('score',18,'arhiva','cmmdc','100.0000'),('submit_count',18,'arhiva','cmmdc','100.0000'),('score',1,'arhiva','fractii','100.0000'),('submit_count',1,'arhiva','fractii','100.0000'),('score',1,'arhiva','flip','100.0000'),('submit_count',1,'arhiva','flip','100.0000'),('score',1,'arhiva','biti','100.0000'),('submit_count',1,'arhiva','biti','100.0000'),('score',13,'arhiva','flip','0.0000'),('submit_count',13,'arhiva','flip','100.0000'),('score',1,'arhiva','perm','100.0000'),('submit_count',1,'arhiva','perm','100.0000'),('score',48,'arhiva','adunare','100.0000'),('submit_count',48,'arhiva','adunare','100.0000'),('score',13,'arhiva','perm','100.0000'),('submit_count',13,'arhiva','perm','100.0000'),('score',13,'arhiva','fractii','100.0000'),('submit_count',13,'arhiva','fractii','100.0000'),('score',18,'arhiva','flip','100.0000'),('submit_count',18,'arhiva','flip','100.0000'),('score',18,'arhiva','perm','100.0000'),('submit_count',18,'arhiva','perm','100.0000'),('score',48,'arhiva','biti','100.0000'),('submit_count',48,'arhiva','biti','100.0000'),('score',48,'arhiva','cmmdc','100.0000'),('submit_count',48,'arhiva','cmmdc','100.0000'),('score',13,'arhiva','fact','100.0000'),('submit_count',13,'arhiva','fact','100.0000'),('score',1,'arhiva','fact','100.0000'),('submit_count',1,'arhiva','fact','100.0000'),('score',13,'arhiva','datorii','100.0000'),('submit_count',13,'arhiva','datorii','100.0000'),('score',48,'arhiva','datorii','100.0000'),('submit_count',48,'arhiva','datorii','100.0000'),('score',48,'arhiva','fact','100.0000'),('submit_count',48,'arhiva','fact','100.0000'),('score',75,'arhiva','adunare','0.0000'),('submit_count',75,'arhiva','adunare','0.0000'),('score',76,'arhiva','adunare','100.0000'),('submit_count',76,'arhiva','adunare','100.0000'),('score',75,'arhiva','cmmdc','100.0000'),('submit_count',75,'arhiva','cmmdc','100.0000'),('score',76,'arhiva','cmmdc','100.0000'),('submit_count',76,'arhiva','cmmdc','100.0000'),('score',18,'arhiva','fractii','100.0000'),('submit_count',18,'arhiva','fractii','100.0000'),('score',1,'arhiva','datorii','100.0000'),('submit_count',1,'arhiva','datorii','100.0000'),('score',18,'arhiva','fact','100.0000'),('submit_count',18,'arhiva','fact','100.0000'),('score',18,'arhiva','datorii','100.0000'),('submit_count',18,'arhiva','datorii','100.0000'),('score',48,'arhiva','perm','100.0000'),('submit_count',48,'arhiva','perm','100.0000'),('score',48,'arhiva','flip','100.0000'),('submit_count',48,'arhiva','flip','100.0000'),('score',48,'arhiva','fractii','100.0000'),('submit_count',48,'arhiva','fractii','100.0000'),('score',1,'arhiva','cifra','100.0000'),('submit_count',1,'arhiva','cifra','100.0000'),('score',13,'arhiva','cifra','100.0000'),('submit_count',13,'arhiva','cifra','100.0000'),('score',1,'arhiva','tabela','100.0000'),('submit_count',1,'arhiva','tabela','100.0000'),('score',142,'preoni53a','farfurii','90.0000'),('submit_count',142,'preoni53a','farfurii','90.0000'),('score',13,'arhiva','tabela','100.0000'),('submit_count',13,'arhiva','tabela','100.0000'),('score',1,'arhiva','stramosi','100.0000'),('submit_count',1,'arhiva','stramosi','100.0000'),('score',13,'arhiva','biti','100.0000'),('submit_count',13,'arhiva','biti','100.0000'),('score',48,'arhiva','cifra','100.0000'),('submit_count',48,'arhiva','cifra','100.0000'),('score',18,'arhiva','tabela','100.0000'),('submit_count',18,'arhiva','tabela','100.0000'),('score',18,'arhiva','stramosi','100.0000'),('submit_count',18,'arhiva','stramosi','100.0000'),('score',48,'arhiva','tabela','100.0000'),('submit_count',48,'arhiva','tabela','100.0000'),('score',93,'arhiva','cifra','100.0000'),('submit_count',93,'arhiva','cifra','100.0000'),('score',93,'arhiva','flip','100.0000'),('submit_count',93,'arhiva','flip','100.0000'),('score',93,'arhiva','adunare','100.0000'),('submit_count',93,'arhiva','adunare','100.0000'),('score',48,'arhiva','stramosi','100.0000'),('submit_count',48,'arhiva','stramosi','100.0000'),('score',93,'arhiva','cmmdc','100.0000'),('submit_count',93,'arhiva','cmmdc','100.0000'),('score',18,'arhiva','cifra','100.0000'),('submit_count',18,'arhiva','cifra','100.0000'),('score',1,'arhiva','copaci','100.0000'),('submit_count',1,'arhiva','copaci','100.0000'),('score',18,'arhiva','biti','100.0000'),('submit_count',18,'arhiva','biti','100.0000'),('score',93,'arhiva','fact','100.0000'),('submit_count',93,'arhiva','fact','100.0000'),('score',18,'arhiva','pietre','100.0000'),('submit_count',18,'arhiva','pietre','100.0000'),('score',18,'arhiva','copaci','100.0000'),('submit_count',18,'arhiva','copaci','100.0000'),('score',142,'arhiva','adunare','100.0000'),('submit_count',142,'arhiva','adunare','100.0000'),('score',1,'arhiva','pietre','100.0000'),('submit_count',1,'arhiva','pietre','100.0000'),('score',75,'preoji1','perm2','25.0000'),('submit_count',75,'preoji1','perm2','25.0000'),('score',13,'preoji1','perm2','100.0000'),('submit_count',13,'preoji1','perm2','100.0000'),('score',18,'preoji1','joc','60.0000'),('submit_count',18,'preoji1','joc','60.0000'),('score',48,'preoji1','joc','50.0000'),('submit_count',48,'preoji1','joc','50.0000'),('score',48,'preoji1','perm2','100.0000'),('submit_count',48,'preoji1','perm2','100.0000'),('score',75,'preoji1','joc','100.0000'),('submit_count',75,'preoji1','joc','100.0000'),('score',18,'preoji1','perm2','100.0000'),('submit_count',18,'preoji1','perm2','100.0000'),('score',13,'preoji1','joc','30.0000'),('submit_count',13,'preoji1','joc','30.0000'),('score',13,'arhiva','petrica','100.0000'),('submit_count',13,'arhiva','petrica','100.0000'),('score',13,'arhiva','perm2','100.0000'),('submit_count',13,'arhiva','perm2','100.0000'),('score',48,'arhiva','secventa','100.0000'),('submit_count',48,'arhiva','secventa','100.0000'),('score',93,'arhiva','fractii','100.0000'),('submit_count',93,'arhiva','fractii','100.0000'),('score',48,'arhiva','perm2','100.0000'),('submit_count',48,'arhiva','perm2','100.0000'),('score',18,'arhiva','perm2','100.0000'),('submit_count',18,'arhiva','perm2','100.0000'),('score',18,'arhiva','secventa','100.0000'),('submit_count',18,'arhiva','secventa','100.0000'),('score',1,'arhiva','perm2','100.0000'),('submit_count',1,'arhiva','perm2','100.0000'),('score',1,'arhiva','secventa','100.0000'),('submit_count',1,'arhiva','secventa','100.0000'),('score',13,'arhiva','pietre','95.0000'),('submit_count',13,'arhiva','pietre','95.0000'),('score',1,'arhiva','joc','100.0000'),('submit_count',1,'arhiva','joc','100.0000'),('score',142,'arhiva','cifra','100.0000'),('submit_count',142,'arhiva','cifra','100.0000'),('score',142,'arhiva','cmmdc','100.0000'),('submit_count',142,'arhiva','cmmdc','100.0000'),('score',58,'arhiva','adunare','100.0000'),('submit_count',58,'arhiva','adunare','100.0000'),('score',142,'arhiva','flip','100.0000'),('submit_count',142,'arhiva','flip','100.0000'),('score',142,'arhiva','fact','100.0000'),('submit_count',142,'arhiva','fact','100.0000'),('score',13,'arhiva','stramosi','100.0000'),('submit_count',13,'arhiva','stramosi','100.0000'),('score',58,'arhiva','cmmdc','100.0000'),('submit_count',58,'arhiva','cmmdc','100.0000'),('score',1,'arhiva','petrica','100.0000'),('submit_count',1,'arhiva','petrica','100.0000'),('score',58,'arhiva','flip','100.0000'),('submit_count',58,'arhiva','flip','100.0000'),('score',48,'arhiva','joc','100.0000'),('submit_count',48,'arhiva','joc','100.0000'),('score',58,'arhiva','tabela','100.0000'),('submit_count',58,'arhiva','tabela','100.0000'),('score',256,'arhiva','adunare','100.0000'),('submit_count',256,'arhiva','adunare','100.0000'),('score',256,'arhiva','cmmdc','100.0000'),('submit_count',256,'arhiva','cmmdc','100.0000'),('score',256,'arhiva','cifra','100.0000'),('submit_count',256,'arhiva','cifra','100.0000'),('score',75,'arhiva','joc','100.0000'),('submit_count',75,'arhiva','joc','100.0000'),('score',1,'arhiva','triunghi','100.0000'),('submit_count',1,'arhiva','triunghi','100.0000'),('score',75,'arhiva','perm2','100.0000'),('submit_count',75,'arhiva','perm2','100.0000'),('score',1975,'arhiva','fact','100.0000'),('submit_count',1975,'arhiva','fact','100.0000'),('score',256,'arhiva','perm2','100.0000'),('submit_count',256,'arhiva','perm2','100.0000'),('score',58,'arhiva','copaci','100.0000'),('submit_count',58,'arhiva','copaci','100.0000'),('score',58,'arhiva','perm2','100.0000'),('submit_count',58,'arhiva','perm2','100.0000'),('score',93,'arhiva','perm2','100.0000'),('submit_count',93,'arhiva','perm2','100.0000'),('score',13,'arhiva','sir23','100.0000'),('submit_count',13,'arhiva','sir23','100.0000'),('score',1,'arhiva','sir23','100.0000'),('submit_count',1,'arhiva','sir23','100.0000'),('score',58,'arhiva','pietre','100.0000'),('submit_count',58,'arhiva','pietre','100.0000'),('score',18,'arhiva','triunghi','100.0000'),('submit_count',18,'arhiva','triunghi','100.0000'),('score',58,'arhiva','fractii','100.0000'),('submit_count',58,'arhiva','fractii','100.0000'),('score',58,'arhiva','datorii','100.0000'),('submit_count',58,'arhiva','datorii','100.0000'),('score',58,'arhiva','fact','100.0000'),('submit_count',58,'arhiva','fact','100.0000'),('score',256,'arhiva','tabela','100.0000'),('submit_count',256,'arhiva','tabela','100.0000'),('score',18,'arhiva','joc','100.0000'),('submit_count',18,'arhiva','joc','100.0000'),('score',18,'arhiva','petrica','100.0000'),('submit_count',18,'arhiva','petrica','100.0000'),('score',18,'arhiva','sir23','100.0000'),('submit_count',18,'arhiva','sir23','100.0000'),('score',58,'arhiva','cifra','100.0000'),('submit_count',58,'arhiva','cifra','100.0000'),('score',58,'arhiva','joc','100.0000'),('submit_count',58,'arhiva','joc','100.0000'),('score',58,'arhiva','stramosi','100.0000'),('submit_count',58,'arhiva','stramosi','100.0000'),('score',1,'arhiva','pavare','100.0000'),('submit_count',1,'arhiva','pavare','100.0000'),('score',93,'arhiva','biti','100.0000'),('submit_count',93,'arhiva','biti','100.0000'),('score',58,'arhiva','triunghi','100.0000'),('submit_count',58,'arhiva','triunghi','100.0000'),('score',75,'arhiva','pavare','20.0000'),('submit_count',75,'arhiva','pavare','20.0000'),('score',93,'arhiva','sir23','100.0000'),('submit_count',93,'arhiva','sir23','100.0000'),('score',93,'arhiva','copaci','100.0000'),('submit_count',93,'arhiva','copaci','100.0000'),('score',1,'arhiva','prim','100.0000'),('submit_count',1,'arhiva','prim','100.0000'),('score',93,'arhiva','prim','100.0000'),('submit_count',93,'arhiva','prim','100.0000'),('score',93,'arhiva','tort','100.0000'),('submit_count',93,'arhiva','tort','100.0000'),('score',93,'arhiva','perm','100.0000'),('submit_count',93,'arhiva','perm','100.0000'),('score',13,'arhiva','zero','100.0000'),('submit_count',13,'arhiva','zero','100.0000'),('score',13,'arhiva','prim','100.0000'),('submit_count',13,'arhiva','prim','100.0000'),('score',13,'arhiva','tort','100.0000'),('submit_count',13,'arhiva','tort','100.0000'),('score',13,'arhiva','copaci','100.0000'),('submit_count',13,'arhiva','copaci','100.0000'),('score',256,'arhiva','prim','100.0000'),('submit_count',256,'arhiva','prim','100.0000'),('score',13,'arhiva','secventa','80.0000'),('submit_count',13,'arhiva','secventa','80.0000'),('score',66,'arhiva','joc','100.0000'),('submit_count',66,'arhiva','joc','100.0000'),('score',66,'arhiva','adunare','100.0000'),('submit_count',66,'arhiva','adunare','100.0000'),('score',58,'arhiva','prim','100.0000'),('submit_count',58,'arhiva','prim','100.0000'),('score',58,'arhiva','tort','100.0000'),('submit_count',58,'arhiva','tort','100.0000'),('score',66,'arhiva','fact','100.0000'),('submit_count',66,'arhiva','fact','100.0000'),('score',66,'arhiva','cmmdc','100.0000'),('submit_count',66,'arhiva','cmmdc','100.0000'),('score',66,'arhiva','cifra','100.0000'),('submit_count',66,'arhiva','cifra','100.0000'),('score',58,'arhiva','secventa','100.0000'),('submit_count',58,'arhiva','secventa','100.0000'),('score',58,'arhiva','pavare','100.0000'),('submit_count',58,'arhiva','pavare','100.0000'),('score',66,'arhiva','flip','100.0000'),('submit_count',66,'arhiva','flip','100.0000'),('score',18,'arhiva','prim','100.0000'),('submit_count',18,'arhiva','prim','100.0000'),('score',18,'arhiva','tort','100.0000'),('submit_count',18,'arhiva','tort','100.0000'),('score',1,'arhiva','perle','100.0000'),('submit_count',1,'arhiva','perle','100.0000'),('score',1,'arhiva','sume','100.0000'),('submit_count',1,'arhiva','sume','100.0000'),('score',1,'arhiva','tort','100.0000'),('submit_count',1,'arhiva','tort','100.0000'),('score',1,'arhiva','zero','100.0000'),('submit_count',1,'arhiva','zero','100.0000'),('score',1,'arhiva','energii','100.0000'),('submit_count',1,'arhiva','energii','100.0000'),('score',256,'arhiva','tort','100.0000'),('submit_count',256,'arhiva','tort','100.0000'),('score',93,'arhiva','joc','100.0000'),('submit_count',93,'arhiva','joc','100.0000'),('score',93,'arhiva','sume','100.0000'),('submit_count',93,'arhiva','sume','100.0000'),('score',66,'arhiva','perm2','100.0000'),('submit_count',66,'arhiva','perm2','100.0000'),('score',66,'arhiva','energii','100.0000'),('submit_count',66,'arhiva','energii','100.0000'),('score',1,'arhiva','munte','100.0000'),('submit_count',1,'arhiva','munte','100.0000'),('score',66,'arhiva','perle','100.0000'),('submit_count',66,'arhiva','perle','100.0000'),('score',66,'arhiva','sume','100.0000'),('submit_count',66,'arhiva','sume','100.0000'),('score',93,'arhiva','tabela','100.0000'),('submit_count',93,'arhiva','tabela','100.0000'),('score',93,'arhiva','energii','90.0000'),('submit_count',93,'arhiva','energii','90.0000'),('score',18,'arhiva','munte','100.0000'),('submit_count',18,'arhiva','munte','100.0000'),('score',18,'arhiva','energii','100.0000'),('submit_count',18,'arhiva','energii','100.0000'),('score',18,'arhiva','perle','100.0000'),('submit_count',18,'arhiva','perle','100.0000'),('score',66,'arhiva','secventa','100.0000'),('submit_count',66,'arhiva','secventa','100.0000'),('score',93,'arhiva','pietre','100.0000'),('submit_count',93,'arhiva','pietre','100.0000'),('score',66,'arhiva','prim','100.0000'),('submit_count',66,'arhiva','prim','100.0000'),('score',66,'arhiva','datorii','100.0000'),('submit_count',66,'arhiva','datorii','100.0000'),('score',13,'arhiva','sume','100.0000'),('submit_count',13,'arhiva','sume','100.0000'),('score',66,'arhiva','pietre','100.0000'),('submit_count',66,'arhiva','pietre','100.0000'),('score',13,'arhiva','energii','100.0000'),('submit_count',13,'arhiva','energii','100.0000'),('score',66,'arhiva','stramosi','100.0000'),('submit_count',66,'arhiva','stramosi','100.0000'),('score',66,'arhiva','biti','100.0000'),('submit_count',66,'arhiva','biti','100.0000'),('score',256,'preoni1','secv2','100.0000'),('submit_count',256,'preoni1','secv2','100.0000'),('score',76,'preoni1','secv2','40.0000'),('submit_count',76,'preoni1','secv2','40.0000'),('score',13,'preoni2','secv3','100.0000'),('submit_count',13,'preoni2','secv3','100.0000'),('score',256,'preoni1','loto','20.0000'),('submit_count',256,'preoni1','loto','20.0000'),('score',256,'preoni1','lapte','0.0000'),('submit_count',256,'preoni1','lapte','0.0000'),('score',66,'preoni1','loto','0.0000'),('submit_count',66,'preoni1','loto','0.0000'),('score',66,'preoni1','secv2','100.0000'),('submit_count',66,'preoni1','secv2','100.0000'),('score',75,'preoni1','lapte','10.0000'),('submit_count',75,'preoni1','lapte','10.0000'),('score',75,'preoni1','loto','35.0000'),('submit_count',75,'preoni1','loto','35.0000'),('score',75,'preoni1','secv2','80.0000'),('submit_count',75,'preoni1','secv2','80.0000'),('score',18,'preoni2','secv3','30.0000'),('submit_count',18,'preoni2','secv3','30.0000'),('score',13,'preoni2','lacate','0.0000'),('submit_count',13,'preoni2','lacate','0.0000'),('score',1,'preoni3','bool','100.0000'),('submit_count',1,'preoni3','bool','100.0000'),('score',1,'preoni4','cutii','100.0000'),('submit_count',1,'preoni4','cutii','100.0000'),('score',1,'preoni3','party','100.0000'),('submit_count',1,'preoni3','party','100.0000'),('score',1,'preoni3','fractal','100.0000'),('submit_count',1,'preoni3','fractal','100.0000'),('score',13,'preoni4','tribute','100.0000'),('submit_count',13,'preoni4','tribute','100.0000'),('score',256,'preoni3','bool','100.0000'),('submit_count',256,'preoni3','bool','100.0000'),('score',256,'preoni3','fractal','10.0000'),('submit_count',256,'preoni3','fractal','10.0000'),('score',256,'preoni3','party','0.0000'),('submit_count',256,'preoni3','party','0.0000'),('score',58,'preoni4','tribute','100.0000'),('submit_count',58,'preoni4','tribute','100.0000'),('score',13,'preoni4','atac','40.0000'),('submit_count',13,'preoni4','atac','40.0000'),('score',75,'preoni3','fractal','20.0000'),('submit_count',75,'preoni3','fractal','20.0000'),('score',1,'arhiva','bool','100.0000'),('submit_count',1,'arhiva','bool','100.0000'),('score',13,'arhiva','secv3','100.0000'),('submit_count',13,'arhiva','secv3','100.0000'),('score',13,'arhiva','tribute','100.0000'),('submit_count',13,'arhiva','tribute','100.0000'),('score',13,'arhiva','atac','0.0000'),('submit_count',13,'arhiva','atac','100.0000'),('score',18,'arhiva','tribute','100.0000'),('submit_count',18,'arhiva','tribute','100.0000'),('score',1,'arhiva','cutii','100.0000'),('submit_count',1,'arhiva','cutii','100.0000'),('score',1,'arhiva','fractal','100.0000'),('submit_count',1,'arhiva','fractal','100.0000'),('score',1,'arhiva','lacate','100.0000'),('submit_count',1,'arhiva','lacate','100.0000'),('score',1,'arhiva','lapte','100.0000'),('submit_count',1,'arhiva','lapte','100.0000'),('score',1,'arhiva','loto','100.0000'),('submit_count',1,'arhiva','loto','100.0000'),('score',1,'arhiva','party','100.0000'),('submit_count',1,'arhiva','party','100.0000'),('score',1,'arhiva','secv2','100.0000'),('submit_count',1,'arhiva','secv2','100.0000'),('score',1,'arhiva','secv3','100.0000'),('submit_count',1,'arhiva','secv3','100.0000'),('score',1,'arhiva','traseu','100.0000'),('submit_count',1,'arhiva','traseu','100.0000'),('score',18,'arhiva','secv3','100.0000'),('submit_count',18,'arhiva','secv3','100.0000'),('score',66,'preoni53b','poligon','60.0000'),('submit_count',66,'preoni53b','poligon','60.0000'),('score',75,'preoni53a','farfurii','100.0000'),('submit_count',75,'preoni53a','farfurii','100.0000'),('score',18,'arhiva','cutii','100.0000'),('submit_count',18,'arhiva','cutii','100.0000'),('score',18,'arhiva','atac','100.0000'),('submit_count',18,'arhiva','atac','100.0000'),('score',1,'arhiva','atac','100.0000'),('submit_count',1,'arhiva','atac','100.0000'),('score',93,'arhiva','triunghi','100.0000'),('submit_count',93,'arhiva','triunghi','100.0000'),('score',1,'arhiva','tribute','100.0000'),('submit_count',1,'arhiva','tribute','100.0000'),('score',13,'arhiva','secv2','100.0000'),('submit_count',13,'arhiva','secv2','100.0000'),('score',256,'arhiva','bool','100.0000'),('submit_count',256,'arhiva','bool','100.0000'),('score',256,'arhiva','secv2','100.0000'),('submit_count',256,'arhiva','secv2','100.0000'),('score',13,'arhiva','loto','100.0000'),('submit_count',13,'arhiva','loto','100.0000'),('score',18,'arhiva','lacate','100.0000'),('submit_count',18,'arhiva','lacate','100.0000'),('score',13,'arhiva','bool','100.0000'),('submit_count',13,'arhiva','bool','100.0000'),('score',1024,'preoni53a','farfurii','0.0000'),('submit_count',1024,'preoni53a','farfurii','0.0000'),('score',18,'arhiva','party','100.0000'),('submit_count',18,'arhiva','party','100.0000'),('score',18,'arhiva','bool','100.0000'),('submit_count',18,'arhiva','bool','100.0000'),('score',18,'arhiva','fractal','100.0000'),('submit_count',18,'arhiva','fractal','100.0000'),('score',18,'arhiva','lapte','100.0000'),('submit_count',18,'arhiva','lapte','100.0000'),('score',18,'arhiva','loto','100.0000'),('submit_count',18,'arhiva','loto','100.0000'),('score',18,'arhiva','secv2','100.0000'),('submit_count',18,'arhiva','secv2','100.0000'),('score',48,'arhiva','atac','100.0000'),('submit_count',48,'arhiva','atac','100.0000'),('score',48,'arhiva','cutii','100.0000'),('submit_count',48,'arhiva','cutii','100.0000'),('score',18,'arhiva','traseu','100.0000'),('submit_count',18,'arhiva','traseu','100.0000'),('score',48,'arhiva','traseu','100.0000'),('submit_count',48,'arhiva','traseu','100.0000'),('score',93,'arhiva','perle','100.0000'),('submit_count',93,'arhiva','perle','100.0000'),('score',256,'arhiva','fact','100.0000'),('submit_count',256,'arhiva','fact','100.0000'),('score',13,'arhiva','cutii','100.0000'),('submit_count',13,'arhiva','cutii','100.0000'),('score',18,'arhiva','zero','100.0000'),('submit_count',18,'arhiva','zero','100.0000'),('score',58,'arhiva','fractal','100.0000'),('submit_count',58,'arhiva','fractal','100.0000'),('score',58,'arhiva','party','100.0000'),('submit_count',58,'arhiva','party','100.0000'),('score',58,'arhiva','secv2','100.0000'),('submit_count',58,'arhiva','secv2','100.0000'),('score',58,'arhiva','lacate','100.0000'),('submit_count',58,'arhiva','lacate','100.0000'),('score',58,'arhiva','loto','100.0000'),('submit_count',58,'arhiva','loto','100.0000'),('score',58,'arhiva','tribute','100.0000'),('submit_count',58,'arhiva','tribute','100.0000'),('score',58,'arhiva','energii','100.0000'),('submit_count',58,'arhiva','energii','100.0000'),('score',58,'arhiva','biti','100.0000'),('submit_count',58,'arhiva','biti','100.0000'),('score',58,'arhiva','perle','100.0000'),('submit_count',58,'arhiva','perle','100.0000'),('score',58,'arhiva','petrica','100.0000'),('submit_count',58,'arhiva','petrica','100.0000'),('score',58,'arhiva','perm','100.0000'),('submit_count',58,'arhiva','perm','100.0000'),('score',630,'arhiva','adunare','100.0000'),('submit_count',630,'arhiva','adunare','100.0000'),('score',630,'arhiva','cmmdc','100.0000'),('submit_count',630,'arhiva','cmmdc','100.0000'),('score',66,'arhiva','secv2','100.0000'),('submit_count',66,'arhiva','secv2','100.0000'),('score',58,'arhiva','atac','100.0000'),('submit_count',58,'arhiva','atac','100.0000'),('score',13,'arhiva','fractal','100.0000'),('submit_count',13,'arhiva','fractal','100.0000'),('score',13,'arhiva','triunghi','0.0000'),('submit_count',13,'arhiva','triunghi','0.0000'),('score',13,'arhiva','pavare','100.0000'),('submit_count',13,'arhiva','pavare','100.0000'),('score',18,'arhiva','sume','100.0000'),('submit_count',18,'arhiva','sume','100.0000'),('score',93,'arhiva','zero','100.0000'),('submit_count',93,'arhiva','zero','100.0000'),('score',93,'arhiva','fractal','100.0000'),('submit_count',93,'arhiva','fractal','100.0000'),('score',13,'arhiva','traseu','0.0000'),('submit_count',13,'arhiva','traseu','0.0000'),('score',66,'arhiva','tort','100.0000'),('submit_count',66,'arhiva','tort','100.0000'),('score',66,'arhiva','loto','100.0000'),('submit_count',66,'arhiva','loto','100.0000'),('score',66,'arhiva','triunghi','100.0000'),('submit_count',66,'arhiva','triunghi','100.0000'),('score',18,'arhiva','pavare','100.0000'),('submit_count',18,'arhiva','pavare','100.0000'),('score',961,'arhiva','adunare','100.0000'),('submit_count',961,'arhiva','adunare','100.0000'),('score',961,'arhiva','cmmdc','100.0000'),('submit_count',961,'arhiva','cmmdc','100.0000'),('score',961,'arhiva','flip','100.0000'),('submit_count',961,'arhiva','flip','100.0000'),('score',66,'arhiva','tabela','100.0000'),('submit_count',66,'arhiva','tabela','100.0000'),('score',961,'arhiva','fractii','100.0000'),('submit_count',961,'arhiva','fractii','100.0000'),('score',961,'arhiva','biti','100.0000'),('submit_count',961,'arhiva','biti','100.0000'),('score',961,'arhiva','perm','100.0000'),('submit_count',961,'arhiva','perm','100.0000'),('score',961,'arhiva','fact','100.0000'),('submit_count',961,'arhiva','fact','100.0000'),('score',961,'arhiva','datorii','100.0000'),('submit_count',961,'arhiva','datorii','100.0000'),('score',961,'arhiva','tabela','100.0000'),('submit_count',961,'arhiva','tabela','100.0000'),('score',961,'arhiva','cifra','100.0000'),('submit_count',961,'arhiva','cifra','100.0000'),('score',961,'arhiva','copaci','100.0000'),('submit_count',961,'arhiva','copaci','100.0000'),('score',66,'arhiva','fractii','100.0000'),('submit_count',66,'arhiva','fractii','100.0000'),('score',961,'arhiva','stramosi','100.0000'),('submit_count',961,'arhiva','stramosi','100.0000'),('score',66,'arhiva','bool','100.0000'),('submit_count',66,'arhiva','bool','100.0000'),('score',970,'arhiva','secventa','100.0000'),('submit_count',970,'arhiva','secventa','100.0000'),('score',970,'arhiva','adunare','100.0000'),('submit_count',970,'arhiva','adunare','100.0000'),('score',970,'arhiva','cmmdc','100.0000'),('submit_count',970,'arhiva','cmmdc','100.0000'),('score',970,'arhiva','flip','100.0000'),('submit_count',970,'arhiva','flip','100.0000'),('score',970,'arhiva','datorii','100.0000'),('submit_count',970,'arhiva','datorii','100.0000'),('score',970,'arhiva','energii','100.0000'),('submit_count',970,'arhiva','energii','100.0000'),('score',970,'arhiva','stramosi','80.0000'),('submit_count',970,'arhiva','stramosi','80.0000'),('score',93,'arhiva','datorii','100.0000'),('submit_count',93,'arhiva','datorii','100.0000'),('score',961,'arhiva','pietre','100.0000'),('submit_count',961,'arhiva','pietre','100.0000'),('score',961,'arhiva','perm2','100.0000'),('submit_count',961,'arhiva','perm2','100.0000'),('score',961,'arhiva','joc','100.0000'),('submit_count',961,'arhiva','joc','100.0000'),('score',961,'arhiva','prim','100.0000'),('submit_count',961,'arhiva','prim','100.0000'),('score',961,'arhiva','secventa','100.0000'),('submit_count',961,'arhiva','secventa','100.0000'),('score',13,'arhiva','joc','0.0000'),('submit_count',13,'arhiva','joc','0.0000'),('score',961,'filip2','xormax','10.0000'),('submit_count',961,'filip2','xormax','10.0000'),('score',1142,'filip2','boom','100.0000'),('submit_count',1142,'filip2','boom','100.0000'),('score',961,'filip2','petsoft','10.0000'),('submit_count',961,'filip2','petsoft','10.0000'),('score',1142,'filip2','xormax','90.0000'),('submit_count',1142,'filip2','xormax','90.0000'),('score',961,'filip2','boom','10.0000'),('submit_count',961,'filip2','boom','10.0000'),('score',1024,'filip1','coins','0.0000'),('submit_count',1024,'filip1','coins','0.0000'),('score',1142,'filip2','petsoft','10.0000'),('submit_count',1142,'filip2','petsoft','10.0000'),('score',13,'arhiva','xormax','100.0000'),('submit_count',13,'arhiva','xormax','100.0000'),('score',1,'arhiva','zaharel','100.0000'),('submit_count',1,'arhiva','zaharel','100.0000'),('score',1,'arhiva','sobo','100.0000'),('submit_count',1,'arhiva','sobo','100.0000'),('score',13,'arhiva','petsoft','100.0000'),('submit_count',13,'arhiva','petsoft','100.0000'),('score',13,'arhiva','sobo','100.0000'),('submit_count',13,'arhiva','sobo','100.0000'),('score',13,'arhiva','boom','100.0000'),('submit_count',13,'arhiva','boom','100.0000'),('score',13,'arhiva','zaharel','100.0000'),('submit_count',13,'arhiva','zaharel','100.0000'),('score',1,'arhiva','xormax','100.0000'),('submit_count',1,'arhiva','xormax','100.0000'),('score',1,'arhiva','boom','100.0000'),('submit_count',1,'arhiva','boom','100.0000'),('score',13,'arhiva','coins','100.0000'),('submit_count',13,'arhiva','coins','100.0000'),('score',18,'arhiva','xormax','100.0000'),('submit_count',18,'arhiva','xormax','100.0000'),('score',1024,'arhiva','adunare','100.0000'),('submit_count',1024,'arhiva','adunare','100.0000'),('score',1024,'arhiva','cmmdc','100.0000'),('submit_count',1024,'arhiva','cmmdc','100.0000'),('score',18,'arhiva','coins','100.0000'),('submit_count',18,'arhiva','coins','100.0000'),('score',18,'arhiva','petsoft','100.0000'),('submit_count',18,'arhiva','petsoft','100.0000'),('score',18,'arhiva','zaharel','100.0000'),('submit_count',18,'arhiva','zaharel','100.0000'),('score',18,'arhiva','sobo','100.0000'),('submit_count',18,'arhiva','sobo','100.0000'),('score',961,'arhiva','triunghi','100.0000'),('submit_count',961,'arhiva','triunghi','100.0000'),('score',1,'arhiva','petsoft','100.0000'),('submit_count',1,'arhiva','petsoft','100.0000'),('score',961,'arhiva','sir23','100.0000'),('submit_count',961,'arhiva','sir23','100.0000'),('score',961,'arhiva','tort','100.0000'),('submit_count',961,'arhiva','tort','100.0000'),('score',961,'arhiva','petrica','100.0000'),('submit_count',961,'arhiva','petrica','100.0000'),('score',961,'arhiva','perle','100.0000'),('submit_count',961,'arhiva','perle','100.0000'),('score',961,'arhiva','energii','100.0000'),('submit_count',961,'arhiva','energii','100.0000'),('score',961,'arhiva','zero','100.0000'),('submit_count',961,'arhiva','zero','100.0000'),('score',961,'arhiva','sume','100.0000'),('submit_count',961,'arhiva','sume','100.0000'),('score',961,'arhiva','munte','100.0000'),('submit_count',961,'arhiva','munte','100.0000'),('score',1,'arhiva','coins','100.0000'),('submit_count',1,'arhiva','coins','100.0000'),('score',961,'arhiva','pavare','100.0000'),('submit_count',961,'arhiva','pavare','100.0000'),('score',961,'arhiva','loto','100.0000'),('submit_count',961,'arhiva','loto','100.0000'),('score',961,'arhiva','secv2','100.0000'),('submit_count',961,'arhiva','secv2','100.0000'),('score',961,'arhiva','lapte','100.0000'),('submit_count',961,'arhiva','lapte','100.0000'),('score',961,'arhiva','secv3','100.0000'),('submit_count',961,'arhiva','secv3','100.0000'),('score',961,'arhiva','lacate','100.0000'),('submit_count',961,'arhiva','lacate','100.0000'),('score',961,'arhiva','traseu','100.0000'),('submit_count',961,'arhiva','traseu','100.0000'),('score',93,'arhiva','lacate','100.0000'),('submit_count',93,'arhiva','lacate','100.0000'),('score',1287,'arhiva','adunare','100.0000'),('submit_count',1287,'arhiva','adunare','100.0000'),('score',1287,'arhiva','cmmdc','100.0000'),('submit_count',1287,'arhiva','cmmdc','100.0000'),('score',1287,'arhiva','flip','0.0000'),('submit_count',1287,'arhiva','flip','0.0000'),('score',1287,'arhiva','cifra','0.0000'),('submit_count',1287,'arhiva','cifra','0.0000'),('score',1287,'arhiva','fractii','10.0000'),('submit_count',1287,'arhiva','fractii','10.0000'),('score',1287,'arhiva','prim','0.0000'),('submit_count',1287,'arhiva','prim','0.0000'),('score',961,'arhiva','fractal','100.0000'),('submit_count',961,'arhiva','fractal','100.0000'),('score',1287,'arhiva','fact','20.0000'),('submit_count',1287,'arhiva','fact','20.0000'),('score',961,'arhiva','cutii','100.0000'),('submit_count',961,'arhiva','cutii','100.0000'),('score',961,'arhiva','party','100.0000'),('submit_count',961,'arhiva','party','100.0000'),('score',961,'arhiva','tribute','100.0000'),('submit_count',961,'arhiva','tribute','100.0000'),('score',961,'arhiva','bool','100.0000'),('submit_count',961,'arhiva','bool','100.0000'),('score',1287,'arhiva','energii','0.0000'),('submit_count',1287,'arhiva','energii','0.0000'),('score',961,'arhiva','atac','100.0000'),('submit_count',961,'arhiva','atac','100.0000'),('score',18,'arhiva','boom','100.0000'),('submit_count',18,'arhiva','boom','100.0000'),('score',1142,'arhiva','adunare','100.0000'),('submit_count',1142,'arhiva','adunare','100.0000'),('score',1142,'arhiva','atac','100.0000'),('submit_count',1142,'arhiva','atac','100.0000'),('score',1142,'arhiva','biti','100.0000'),('submit_count',1142,'arhiva','biti','100.0000'),('score',1142,'arhiva','bool','100.0000'),('submit_count',1142,'arhiva','bool','100.0000'),('score',1142,'arhiva','cifra','100.0000'),('submit_count',1142,'arhiva','cifra','100.0000'),('score',1142,'arhiva','cmmdc','100.0000'),('submit_count',1142,'arhiva','cmmdc','100.0000'),('score',1142,'arhiva','copaci','100.0000'),('submit_count',1142,'arhiva','copaci','100.0000'),('score',1142,'arhiva','boom','100.0000'),('submit_count',1142,'arhiva','boom','100.0000'),('score',1142,'arhiva','cutii','100.0000'),('submit_count',1142,'arhiva','cutii','0.0000'),('score',1142,'arhiva','datorii','100.0000'),('submit_count',1142,'arhiva','datorii','100.0000'),('score',1142,'arhiva','energii','100.0000'),('submit_count',1142,'arhiva','energii','100.0000'),('score',1142,'arhiva','fact','100.0000'),('submit_count',1142,'arhiva','fact','100.0000'),('score',1142,'arhiva','flip','100.0000'),('submit_count',1142,'arhiva','flip','100.0000'),('score',1142,'arhiva','fractal','100.0000'),('submit_count',1142,'arhiva','fractal','100.0000'),('score',1142,'arhiva','fractii','100.0000'),('submit_count',1142,'arhiva','fractii','100.0000'),('score',1142,'arhiva','joc','100.0000'),('submit_count',1142,'arhiva','joc','100.0000'),('score',1142,'arhiva','lacate','100.0000'),('submit_count',1142,'arhiva','lacate','100.0000'),('score',1142,'arhiva','lapte','100.0000'),('submit_count',1142,'arhiva','lapte','100.0000'),('score',1142,'arhiva','loto','100.0000'),('submit_count',1142,'arhiva','loto','100.0000'),('score',1142,'arhiva','munte','100.0000'),('submit_count',1142,'arhiva','munte','100.0000'),('score',1142,'arhiva','party','100.0000'),('submit_count',1142,'arhiva','party','100.0000'),('score',1142,'arhiva','pavare','100.0000'),('submit_count',1142,'arhiva','pavare','100.0000'),('score',1142,'arhiva','perle','100.0000'),('submit_count',1142,'arhiva','perle','100.0000'),('score',1142,'arhiva','perm','100.0000'),('submit_count',1142,'arhiva','perm','100.0000'),('score',1142,'arhiva','perm2','0.0000'),('submit_count',1142,'arhiva','perm2','100.0000'),('score',1142,'arhiva','petrica','100.0000'),('submit_count',1142,'arhiva','petrica','100.0000'),('score',1142,'arhiva','petsoft','100.0000'),('submit_count',1142,'arhiva','petsoft','100.0000'),('score',1142,'arhiva','pietre','0.0000'),('submit_count',1142,'arhiva','pietre','100.0000'),('score',1142,'arhiva','prim','100.0000'),('submit_count',1142,'arhiva','prim','100.0000'),('score',1142,'arhiva','secv2','100.0000'),('submit_count',1142,'arhiva','secv2','100.0000'),('score',1142,'arhiva','secv3','100.0000'),('submit_count',1142,'arhiva','secv3','100.0000'),('score',1142,'arhiva','secventa','0.0000'),('submit_count',1142,'arhiva','secventa','100.0000'),('score',1142,'arhiva','sir23','100.0000'),('submit_count',1142,'arhiva','sir23','0.0000'),('score',1142,'arhiva','stramosi','0.0000'),('submit_count',1142,'arhiva','stramosi','100.0000'),('score',1142,'arhiva','sume','100.0000'),('submit_count',1142,'arhiva','sume','100.0000'),('score',1142,'arhiva','tabela','100.0000'),('submit_count',1142,'arhiva','tabela','100.0000'),('score',1142,'arhiva','tort','100.0000'),('submit_count',1142,'arhiva','tort','100.0000'),('score',1142,'arhiva','traseu','100.0000'),('submit_count',1142,'arhiva','traseu','100.0000'),('score',1142,'arhiva','tribute','100.0000'),('submit_count',1142,'arhiva','tribute','100.0000'),('score',1142,'arhiva','triunghi','100.0000'),('submit_count',1142,'arhiva','triunghi','100.0000'),('score',1142,'arhiva','xormax','100.0000'),('submit_count',1142,'arhiva','xormax','100.0000'),('score',1142,'arhiva','zero','100.0000'),('submit_count',1142,'arhiva','zero','100.0000'),('score',1142,'arhiva','coins','100.0000'),('submit_count',1142,'arhiva','coins','100.0000'),('score',1142,'arhiva','zaharel','100.0000'),('submit_count',1142,'arhiva','zaharel','100.0000'),('score',1142,'arhiva','sobo','100.0000'),('submit_count',1142,'arhiva','sobo','100.0000'),('score',961,'arhiva','zaharel','100.0000'),('submit_count',961,'arhiva','zaharel','100.0000'),('score',961,'arhiva','sobo','100.0000'),('submit_count',961,'arhiva','sobo','100.0000'),('score',961,'arhiva','coins','100.0000'),('submit_count',961,'arhiva','coins','100.0000'),('score',1024,'arhiva','coins','0.0000'),('submit_count',1024,'arhiva','coins','0.0000'),('score',1024,'arhiva','flip','100.0000'),('submit_count',1024,'arhiva','flip','100.0000'),('score',1024,'arhiva','sir23','40.0000'),('submit_count',1024,'arhiva','sir23','40.0000'),('score',1024,'arhiva','fact','100.0000'),('submit_count',1024,'arhiva','fact','100.0000'),('score',1024,'arhiva','energii','100.0000'),('submit_count',1024,'arhiva','energii','100.0000'),('score',1024,'arhiva','sume','10.0000'),('submit_count',1024,'arhiva','sume','10.0000'),('score',1024,'arhiva','fractii','100.0000'),('submit_count',1024,'arhiva','fractii','100.0000'),('score',1024,'arhiva','loto','100.0000'),('submit_count',1024,'arhiva','loto','100.0000'),('score',1024,'arhiva','sobo','0.0000'),('submit_count',1024,'arhiva','sobo','0.0000'),('score',961,'arhiva','boom','100.0000'),('submit_count',961,'arhiva','boom','100.0000'),('score',961,'arhiva','petsoft','100.0000'),('submit_count',961,'arhiva','petsoft','100.0000'),('score',256,'arhiva','loto','100.0000'),('submit_count',256,'arhiva','loto','100.0000'),('score',961,'arhiva','xormax','100.0000'),('submit_count',961,'arhiva','xormax','100.0000'),('score',256,'arhiva','energii','100.0000'),('submit_count',256,'arhiva','energii','100.0000'),('score',66,'arhiva','perm','100.0000'),('submit_count',66,'arhiva','perm','100.0000'),('score',256,'arhiva','perm','100.0000'),('submit_count',256,'arhiva','perm','100.0000'),('score',66,'arhiva','copaci','100.0000'),('submit_count',66,'arhiva','copaci','100.0000'),('score',142,'preoni51a','text','100.0000'),('submit_count',142,'preoni51a','text','100.0000'),('score',1142,'preoni51b','iepuri','100.0000'),('submit_count',1142,'preoni51b','iepuri','100.0000'),('score',961,'preoni51b','iepuri','40.0000'),('submit_count',961,'preoni51b','iepuri','40.0000'),('score',142,'preoni51a','subsir','0.0000'),('submit_count',142,'preoni51a','subsir','0.0000'),('score',1287,'preoni51a','text','30.0000'),('submit_count',1287,'preoni51a','text','30.0000'),('score',961,'preoni51b','barbar','30.0000'),('submit_count',961,'preoni51b','barbar','30.0000'),('score',1142,'preoni51b','barbar','90.0000'),('submit_count',1142,'preoni51b','barbar','90.0000'),('score',142,'preoni51b','iepuri','100.0000'),('submit_count',142,'preoni51b','iepuri','100.0000'),('score',75,'preoni51a','text','90.0000'),('submit_count',75,'preoni51a','text','90.0000'),('score',142,'preoni51a','trapez','0.0000'),('submit_count',142,'preoni51a','trapez','0.0000'),('score',75,'preoni51a','trapez','10.0000'),('submit_count',75,'preoni51a','trapez','10.0000'),('score',1024,'preoni51a','text','0.0000'),('submit_count',1024,'preoni51a','text','0.0000'),('score',66,'preoni51b','barbar','70.0000'),('submit_count',66,'preoni51b','barbar','70.0000'),('score',1024,'preoni51a','subsir','0.0000'),('submit_count',1024,'preoni51a','subsir','0.0000'),('score',66,'arhiva','cutii','100.0000'),('submit_count',66,'arhiva','cutii','100.0000'),('score',66,'arhiva','coins','100.0000'),('submit_count',66,'arhiva','coins','100.0000'),('score',13,'arhiva','adn','100.0000'),('submit_count',13,'arhiva','adn','100.0000'),('score',13,'arhiva','barbar','100.0000'),('submit_count',13,'arhiva','barbar','100.0000'),('score',13,'arhiva','iepuri','100.0000'),('submit_count',13,'arhiva','iepuri','100.0000'),('score',13,'arhiva','trapez','100.0000'),('submit_count',13,'arhiva','trapez','100.0000'),('score',13,'arhiva','subsir','100.0000'),('submit_count',13,'arhiva','subsir','100.0000'),('score',13,'arhiva','text','100.0000'),('submit_count',13,'arhiva','text','100.0000'),('score',961,'arhiva','barbar','100.0000'),('submit_count',961,'arhiva','barbar','100.0000'),('score',1,'arhiva','adn','100.0000'),('submit_count',1,'arhiva','adn','100.0000'),('score',1,'arhiva','barbar','100.0000'),('submit_count',1,'arhiva','barbar','100.0000'),('score',1,'arhiva','iepuri','100.0000'),('submit_count',1,'arhiva','iepuri','100.0000'),('score',1,'arhiva','subsir','100.0000'),('submit_count',1,'arhiva','subsir','100.0000'),('score',1,'arhiva','text','100.0000'),('submit_count',1,'arhiva','text','100.0000'),('score',1,'arhiva','trapez','100.0000'),('submit_count',1,'arhiva','trapez','100.0000'),('score',961,'arhiva','iepuri','100.0000'),('submit_count',961,'arhiva','iepuri','100.0000'),('score',66,'arhiva','zero','100.0000'),('submit_count',66,'arhiva','zero','100.0000'),('score',961,'arhiva','text','100.0000'),('submit_count',961,'arhiva','text','100.0000'),('score',961,'arhiva','trapez','100.0000'),('submit_count',961,'arhiva','trapez','100.0000'),('score',961,'arhiva','subsir','100.0000'),('submit_count',961,'arhiva','subsir','100.0000'),('score',66,'arhiva','trapez','100.0000'),('submit_count',66,'arhiva','trapez','100.0000'),('score',66,'arhiva','text','100.0000'),('submit_count',66,'arhiva','text','100.0000'),('score',18,'arhiva','barbar','100.0000'),('submit_count',18,'arhiva','barbar','100.0000'),('score',18,'arhiva','iepuri','100.0000'),('submit_count',18,'arhiva','iepuri','100.0000'),('score',18,'arhiva','adn','100.0000'),('submit_count',18,'arhiva','adn','100.0000'),('score',18,'arhiva','text','100.0000'),('submit_count',18,'arhiva','text','100.0000'),('score',66,'arhiva','barbar','100.0000'),('submit_count',66,'arhiva','barbar','100.0000'),('score',970,'arhiva','barbar','10.0000'),('submit_count',970,'arhiva','barbar','10.0000'),('score',1024,'arhiva','text','100.0000'),('submit_count',1024,'arhiva','text','70.0000'),('score',75,'arhiva','sir23','100.0000'),('submit_count',75,'arhiva','sir23','100.0000'),('score',75,'arhiva','trapez','100.0000'),('submit_count',75,'arhiva','trapez','100.0000'),('score',93,'arhiva','text','100.0000'),('submit_count',93,'arhiva','text','100.0000'),('score',1636,'arhiva','pavare','0.0000'),('submit_count',1636,'arhiva','pavare','0.0000'),('score',58,'arhiva','coins','100.0000'),('submit_count',58,'arhiva','coins','100.0000'),('score',1024,'arhiva','secv2','100.0000'),('submit_count',1024,'arhiva','secv2','100.0000'),('score',1636,'arhiva','fractii','0.0000'),('submit_count',1636,'arhiva','fractii','0.0000'),('score',256,'arhiva','secventa','100.0000'),('submit_count',256,'arhiva','secventa','100.0000'),('score',1666,'arhiva','adn','0.0000'),('submit_count',1666,'arhiva','adn','0.0000'),('score',1666,'arhiva','adunare','100.0000'),('submit_count',1666,'arhiva','adunare','100.0000'),('score',1666,'arhiva','cmmdc','100.0000'),('submit_count',1666,'arhiva','cmmdc','100.0000'),('score',1666,'arhiva','pietre','40.0000'),('submit_count',1666,'arhiva','pietre','40.0000'),('score',1670,'arhiva','adunare','100.0000'),('submit_count',1670,'arhiva','adunare','100.0000'),('score',1666,'arhiva','sir23','100.0000'),('submit_count',1666,'arhiva','sir23','100.0000'),('score',1670,'arhiva','cmmdc','100.0000'),('submit_count',1670,'arhiva','cmmdc','100.0000'),('score',1670,'arhiva','pietre','40.0000'),('submit_count',1670,'arhiva','pietre','40.0000'),('score',18,'arhiva','trapez','100.0000'),('submit_count',18,'arhiva','trapez','100.0000'),('score',1670,'arhiva','fractii','100.0000'),('submit_count',1670,'arhiva','fractii','100.0000'),('score',1670,'arhiva','cifra','100.0000'),('submit_count',1670,'arhiva','cifra','100.0000'),('score',18,'arhiva','subsir','100.0000'),('submit_count',18,'arhiva','subsir','100.0000'),('score',1636,'arhiva','subsir','0.0000'),('submit_count',1636,'arhiva','subsir','0.0000'),('score',58,'arhiva','traseu','40.0000'),('submit_count',58,'arhiva','traseu','40.0000'),('score',93,'arhiva','trapez','100.0000'),('submit_count',93,'arhiva','trapez','100.0000'),('score',93,'arhiva','iepuri','100.0000'),('submit_count',93,'arhiva','iepuri','100.0000'),('score',630,'arhiva','fact','5.0000'),('submit_count',630,'arhiva','fact','5.0000'),('score',630,'arhiva','fractii','0.0000'),('submit_count',630,'arhiva','fractii','0.0000'),('score',1696,'arhiva','cmmdc','50.0000'),('submit_count',1696,'arhiva','cmmdc','50.0000'),('score',66,'arhiva','lacate','100.0000'),('submit_count',66,'arhiva','lacate','100.0000'),('score',93,'arhiva','secv2','100.0000'),('submit_count',93,'arhiva','secv2','100.0000'),('score',66,'arhiva','traseu','100.0000'),('submit_count',66,'arhiva','traseu','100.0000'),('score',1696,'arhiva','adunare','100.0000'),('submit_count',1696,'arhiva','adunare','100.0000'),('score',66,'arhiva','fractal','100.0000'),('submit_count',66,'arhiva','fractal','100.0000'),('score',66,'arhiva','boom','100.0000'),('submit_count',66,'arhiva','boom','100.0000'),('score',1696,'arhiva','pietre','40.0000'),('submit_count',1696,'arhiva','pietre','40.0000'),('score',1636,'arhiva','zero','55.0000'),('submit_count',1636,'arhiva','zero','55.0000'),('score',1636,'arhiva','cifra','0.0000'),('submit_count',1636,'arhiva','cifra','0.0000'),('score',1636,'arhiva','datorii','0.0000'),('submit_count',1636,'arhiva','datorii','0.0000'),('score',66,'arhiva','tribute','100.0000'),('submit_count',66,'arhiva','tribute','100.0000'),('score',66,'arhiva','iepuri','100.0000'),('submit_count',66,'arhiva','iepuri','100.0000'),('score',66,'arhiva','zaharel','100.0000'),('submit_count',66,'arhiva','zaharel','100.0000'),('score',630,'arhiva','flip','0.0000'),('submit_count',630,'arhiva','flip','0.0000'),('score',66,'arhiva','atac','100.0000'),('submit_count',66,'arhiva','atac','100.0000'),('score',1636,'arhiva','prim','50.0000'),('submit_count',1636,'arhiva','prim','50.0000'),('score',1689,'arhiva','subsir','0.0000'),('submit_count',1689,'arhiva','subsir','0.0000'),('score',1636,'arhiva','adunare','100.0000'),('submit_count',1636,'arhiva','adunare','100.0000'),('score',1636,'arhiva','secv3','0.0000'),('submit_count',1636,'arhiva','secv3','0.0000'),('score',75,'preoni52a','secv','100.0000'),('submit_count',75,'preoni52a','secv','100.0000'),('score',256,'preoni52a','pascal','100.0000'),('submit_count',256,'preoni52a','pascal','100.0000'),('score',256,'preoni52a','secv','90.0000'),('submit_count',256,'preoni52a','secv','90.0000'),('score',1024,'preoni52a','secv','20.0000'),('submit_count',1024,'preoni52a','secv','20.0000'),('score',75,'preoni52a','car','10.0000'),('submit_count',75,'preoni52a','car','10.0000'),('score',1024,'preoni52a','car','10.0000'),('submit_count',1024,'preoni52a','car','10.0000'),('score',256,'preoni52a','car','20.0000'),('submit_count',256,'preoni52a','car','20.0000'),('score',1689,'preoni52a','pascal','60.0000'),('submit_count',1689,'preoni52a','pascal','60.0000'),('score',1024,'preoni52a','pascal','0.0000'),('submit_count',1024,'preoni52a','pascal','0.0000'),('score',75,'preoni52a','pascal','50.0000'),('submit_count',75,'preoni52a','pascal','50.0000'),('score',1503,'preoni52a','car','0.0000'),('submit_count',1503,'preoni52a','car','0.0000'),('score',961,'preoni52b','indep','100.0000'),('submit_count',961,'preoni52b','indep','100.0000'),('score',961,'preoni52b','cerere','80.0000'),('submit_count',961,'preoni52b','cerere','80.0000'),('score',142,'preoni52b','cerere','100.0000'),('submit_count',142,'preoni52b','cerere','100.0000'),('score',142,'preoni52b','indep','80.0000'),('submit_count',142,'preoni52b','indep','80.0000'),('score',66,'preoni52b','rubarba','20.0000'),('submit_count',66,'preoni52b','rubarba','20.0000'),('score',66,'preoni52b','indep','10.0000'),('submit_count',66,'preoni52b','indep','10.0000'),('score',66,'preoni52b','cerere','80.0000'),('submit_count',66,'preoni52b','cerere','80.0000'),('score',1696,'preoni52b','cerere','0.0000'),('submit_count',1696,'preoni52b','cerere','0.0000'),('score',961,'preoni52b','rubarba','30.0000'),('submit_count',961,'preoni52b','rubarba','30.0000'),('score',142,'preoni52b','rubarba','40.0000'),('submit_count',142,'preoni52b','rubarba','40.0000'),('score',970,'arhiva','fact','100.0000'),('submit_count',970,'arhiva','fact','100.0000'),('score',970,'arhiva','zero','5.0000'),('submit_count',970,'arhiva','zero','5.0000'),('score',970,'arhiva','tabela','100.0000'),('submit_count',970,'arhiva','tabela','100.0000'),('score',1287,'arhiva','text','40.0000'),('submit_count',1287,'arhiva','text','40.0000'),('score',970,'arhiva','pietre','100.0000'),('submit_count',970,'arhiva','pietre','100.0000'),('score',1287,'arhiva','triunghi','0.0000'),('submit_count',1287,'arhiva','triunghi','0.0000'),('score',1287,'arhiva','perm','10.0000'),('submit_count',1287,'arhiva','perm','10.0000'),('score',970,'arhiva','perle','100.0000'),('submit_count',970,'arhiva','perle','100.0000'),('score',66,'arhiva','lapte','100.0000'),('submit_count',66,'arhiva','lapte','100.0000'),('score',1,'arhiva','car','100.0000'),('submit_count',1,'arhiva','car','100.0000'),('score',1,'arhiva','cerere','100.0000'),('submit_count',1,'arhiva','cerere','100.0000'),('score',1,'arhiva','indep','100.0000'),('submit_count',1,'arhiva','indep','100.0000'),('score',1,'arhiva','pascal','100.0000'),('submit_count',1,'arhiva','pascal','100.0000'),('score',1,'arhiva','rubarba','100.0000'),('submit_count',1,'arhiva','rubarba','100.0000'),('score',1,'arhiva','secv','100.0000'),('submit_count',1,'arhiva','secv','100.0000'),('score',66,'arhiva','indep','100.0000'),('submit_count',66,'arhiva','indep','100.0000'),('score',961,'arhiva','rubarba','100.0000'),('submit_count',961,'arhiva','rubarba','100.0000'),('score',961,'arhiva','indep','100.0000'),('submit_count',961,'arhiva','indep','100.0000'),('score',66,'arhiva','cerere','100.0000'),('submit_count',66,'arhiva','cerere','100.0000'),('score',961,'arhiva','cerere','100.0000'),('submit_count',961,'arhiva','cerere','100.0000'),('score',18,'arhiva','rubarba','100.0000'),('submit_count',18,'arhiva','rubarba','100.0000'),('score',18,'arhiva','cerere','100.0000'),('submit_count',18,'arhiva','cerere','100.0000'),('score',18,'arhiva','indep','100.0000'),('submit_count',18,'arhiva','indep','100.0000'),('score',18,'arhiva','pascal','100.0000'),('submit_count',18,'arhiva','pascal','100.0000'),('score',1024,'arhiva','secv','20.0000'),('submit_count',1024,'arhiva','secv','20.0000'),('score',1024,'arhiva','car','10.0000'),('submit_count',1024,'arhiva','car','10.0000'),('score',18,'arhiva','secv','100.0000'),('submit_count',18,'arhiva','secv','100.0000'),('score',66,'arhiva','car','100.0000'),('submit_count',66,'arhiva','car','100.0000'),('score',18,'arhiva','car','100.0000'),('submit_count',18,'arhiva','car','100.0000'),('score',1967,'arhiva','adunare','100.0000'),('submit_count',1967,'arhiva','adunare','100.0000'),('score',1967,'arhiva','cmmdc','100.0000'),('submit_count',1967,'arhiva','cmmdc','100.0000'),('score',66,'arhiva','pascal','100.0000'),('submit_count',66,'arhiva','pascal','100.0000'),('score',66,'arhiva','secv','100.0000'),('submit_count',66,'arhiva','secv','100.0000'),('score',66,'arhiva','adn','100.0000'),('submit_count',66,'arhiva','adn','100.0000'),('score',66,'arhiva','sobo','100.0000'),('submit_count',66,'arhiva','sobo','100.0000'),('score',66,'arhiva','xormax','100.0000'),('submit_count',66,'arhiva','xormax','100.0000'),('score',961,'arhiva','secv','100.0000'),('submit_count',961,'arhiva','secv','100.0000'),('score',961,'arhiva','pascal','100.0000'),('submit_count',961,'arhiva','pascal','100.0000'),('score',66,'arhiva','petrica','100.0000'),('submit_count',66,'arhiva','petrica','100.0000'),('score',66,'arhiva','subsir','100.0000'),('submit_count',66,'arhiva','subsir','100.0000'),('score',66,'arhiva','sir23','100.0000'),('submit_count',66,'arhiva','sir23','100.0000'),('score',66,'arhiva','secv3','100.0000'),('submit_count',66,'arhiva','secv3','100.0000'),('score',75,'arhiva','datorii','100.0000'),('submit_count',75,'arhiva','datorii','100.0000'),('score',1967,'arhiva','flip','30.0000'),('submit_count',1967,'arhiva','flip','30.0000'),('score',75,'arhiva','cutii','100.0000'),('submit_count',75,'arhiva','cutii','100.0000'),('score',1142,'arhiva','subsir','100.0000'),('submit_count',1142,'arhiva','subsir','100.0000'),('score',1142,'arhiva','text','100.0000'),('submit_count',1142,'arhiva','text','100.0000'),('score',1142,'arhiva','trapez','100.0000'),('submit_count',1142,'arhiva','trapez','100.0000'),('score',1142,'arhiva','barbar','100.0000'),('submit_count',1142,'arhiva','barbar','100.0000'),('score',1142,'arhiva','iepuri','100.0000'),('submit_count',1142,'arhiva','iepuri','100.0000'),('score',1142,'arhiva','adn','0.0000'),('submit_count',1142,'arhiva','adn','100.0000'),('score',1142,'arhiva','pascal','100.0000'),('submit_count',1142,'arhiva','pascal','100.0000'),('score',1142,'arhiva','secv','100.0000'),('submit_count',1142,'arhiva','secv','100.0000'),('score',1142,'arhiva','car','100.0000'),('submit_count',1142,'arhiva','car','100.0000'),('score',1142,'arhiva','indep','100.0000'),('submit_count',1142,'arhiva','indep','100.0000'),('score',1142,'arhiva','cerere','100.0000'),('submit_count',1142,'arhiva','cerere','100.0000'),('score',1142,'arhiva','rubarba','100.0000'),('submit_count',1142,'arhiva','rubarba','100.0000'),('score',75,'arhiva','perm','100.0000'),('submit_count',75,'arhiva','perm','100.0000'),('score',75,'arhiva','triunghi','100.0000'),('submit_count',75,'arhiva','triunghi','100.0000'),('score',75,'arhiva','stramosi','100.0000'),('submit_count',75,'arhiva','stramosi','100.0000'),('score',13,'arhiva','cerere','0.0000'),('submit_count',13,'arhiva','cerere','0.0000'),('score',13,'arhiva','car','0.0000'),('submit_count',13,'arhiva','car','0.0000'),('score',142,'preoni53a','cifre','40.0000'),('submit_count',142,'preoni53a','cifre','40.0000'),('score',961,'preoni53b','ferma','60.0000'),('submit_count',961,'preoni53b','ferma','60.0000'),('score',961,'preoni53b','poligon','50.0000'),('submit_count',961,'preoni53b','poligon','50.0000'),('score',66,'preoni53b','critice','60.0000'),('submit_count',66,'preoni53b','critice','60.0000'),('score',961,'preoni53b','critice','60.0000'),('submit_count',961,'preoni53b','critice','60.0000'),('score',142,'preoni53b','critice','0.0000'),('submit_count',142,'preoni53b','critice','0.0000'),('score',1503,'preoni53a','cifre','50.0000'),('submit_count',1503,'preoni53a','cifre','50.0000'),('score',1024,'preoni53a','barman','0.0000'),('submit_count',1024,'preoni53a','barman','0.0000'),('score',1024,'preoni53a','cifre','0.0000'),('submit_count',1024,'preoni53a','cifre','0.0000'),('score',66,'preoni53b','ferma','0.0000'),('submit_count',66,'preoni53b','ferma','0.0000'),('score',1975,'preoni53a','cifre','10.0000'),('submit_count',1975,'preoni53a','cifre','10.0000'),('score',256,'preoni53a','cifre','60.0000'),('submit_count',256,'preoni53a','cifre','60.0000'),('score',256,'preoni53a','farfurii','80.0000'),('submit_count',256,'preoni53a','farfurii','80.0000'),('score',1975,'preoni53a','farfurii','50.0000'),('submit_count',1975,'preoni53a','farfurii','50.0000'),('score',256,'preoni53a','barman','10.0000'),('submit_count',256,'preoni53a','barman','10.0000'),('score',18,'arhiva','critice','80.0000'),('submit_count',18,'arhiva','critice','80.0000'),('score',961,'arhiva','critice','100.0000'),('submit_count',961,'arhiva','critice','100.0000'),('score',18,'arhiva','barman','80.0000'),('submit_count',18,'arhiva','barman','80.0000'),('score',18,'arhiva','cifre','100.0000'),('submit_count',18,'arhiva','cifre','100.0000'),('score',18,'arhiva','farfurii','100.0000'),('submit_count',18,'arhiva','farfurii','100.0000'),('score',18,'arhiva','poligon','100.0000'),('submit_count',18,'arhiva','poligon','100.0000'),('score',1,'arhiva','barman','100.0000'),('submit_count',1,'arhiva','barman','100.0000'),('score',1,'arhiva','cifre','100.0000'),('submit_count',1,'arhiva','cifre','100.0000'),('score',1,'arhiva','farfurii','100.0000'),('submit_count',1,'arhiva','farfurii','100.0000'),('score',1,'arhiva','critice','100.0000'),('submit_count',1,'arhiva','critice','100.0000'),('score',1,'arhiva','ferma','100.0000'),('submit_count',1,'arhiva','ferma','100.0000'),('score',961,'arhiva','ferma','100.0000'),('submit_count',961,'arhiva','ferma','100.0000'),('score',75,'arhiva','farfurii','100.0000'),('submit_count',75,'arhiva','farfurii','100.0000'),('score',256,'arhiva','farfurii','100.0000'),('submit_count',256,'arhiva','farfurii','100.0000'),('score',256,'arhiva','cifre','100.0000'),('submit_count',256,'arhiva','cifre','100.0000'),('score',75,'arhiva','barman','10.0000'),('submit_count',75,'arhiva','barman','10.0000'),('score',75,'arhiva','cifre','50.0000'),('submit_count',75,'arhiva','cifre','50.0000'),('score',961,'arhiva','car','100.0000'),('submit_count',961,'arhiva','car','100.0000'),('score',18,'arhiva','ferma','100.0000'),('submit_count',18,'arhiva','ferma','100.0000'),('score',66,'arhiva','critice','100.0000'),('submit_count',66,'arhiva','critice','100.0000'),('score',66,'arhiva','party','100.0000'),('submit_count',66,'arhiva','party','100.0000'),('score',66,'arhiva','farfurii','100.0000'),('submit_count',66,'arhiva','farfurii','100.0000'),('score',961,'arhiva','farfurii','100.0000'),('submit_count',961,'arhiva','farfurii','100.0000'),('score',48,'arhiva','petrica','100.0000'),('submit_count',48,'arhiva','petrica','100.0000'),('score',48,'arhiva','pietre','45.0000'),('submit_count',48,'arhiva','pietre','45.0000'),('score',48,'arhiva','pavare','100.0000'),('submit_count',48,'arhiva','pavare','100.0000'),('score',58,'arhiva','poligon','100.0000'),('submit_count',58,'arhiva','poligon','100.0000'),('score',58,'arhiva','car','100.0000'),('submit_count',58,'arhiva','car','100.0000'),('score',58,'arhiva','adn','100.0000'),('submit_count',58,'arhiva','adn','100.0000'),('score',1,'arhiva','poligon','100.0000'),('submit_count',1,'arhiva','poligon','100.0000'),('score',66,'arhiva','rubarba','100.0000'),('submit_count',66,'arhiva','rubarba','100.0000'),('score',1142,'arhiva','farfurii','0.0000'),('submit_count',1142,'arhiva','farfurii','0.0000'),('score',970,'arhiva','cifra','100.0000'),('submit_count',970,'arhiva','cifra','100.0000'),('score',2092,'arhiva','adunare','100.0000'),('submit_count',2092,'arhiva','adunare','100.0000'),('score',2092,'arhiva','cmmdc','100.0000'),('submit_count',2092,'arhiva','cmmdc','100.0000'),('score',2092,'arhiva','fractii','100.0000'),('submit_count',2092,'arhiva','fractii','100.0000'),('score',2092,'arhiva','fact','100.0000'),('submit_count',2092,'arhiva','fact','100.0000'),('score',93,'arhiva','stramosi','100.0000'),('submit_count',93,'arhiva','stramosi','100.0000'),('score',93,'arhiva','farfurii','100.0000'),('submit_count',93,'arhiva','farfurii','100.0000'),('score',2092,'arhiva','cifra','100.0000'),('submit_count',2092,'arhiva','cifra','100.0000'),('score',2092,'arhiva','datorii','100.0000'),('submit_count',2092,'arhiva','datorii','100.0000'),('score',93,'arhiva','cerere','100.0000'),('submit_count',93,'arhiva','cerere','100.0000'),('score',58,'arhiva','cutii','100.0000'),('submit_count',58,'arhiva','cutii','100.0000'),('score',58,'arhiva','zero','100.0000'),('submit_count',58,'arhiva','zero','100.0000'),('score',93,'arhiva','loto','100.0000'),('submit_count',93,'arhiva','loto','100.0000'),('score',2092,'arhiva','biti','0.0000'),('submit_count',2092,'arhiva','biti','0.0000'),('score',66,'arhiva','petsoft','100.0000'),('submit_count',66,'arhiva','petsoft','100.0000'),('score',2092,'arhiva','tabela','100.0000'),('submit_count',2092,'arhiva','tabela','100.0000'),('score',66,'arhiva','ferma','100.0000'),('submit_count',66,'arhiva','ferma','100.0000'),('score',2092,'arhiva','perm2','95.0000'),('submit_count',2092,'arhiva','perm2','95.0000'),('score',66,'arhiva','munte','100.0000'),('submit_count',66,'arhiva','munte','100.0000'),('score',2092,'arhiva','flip','100.0000'),('submit_count',2092,'arhiva','flip','100.0000'),('score',961,'arhiva','poligon','100.0000'),('submit_count',961,'arhiva','poligon','100.0000'),('score',93,'arhiva','secv','100.0000'),('submit_count',93,'arhiva','secv','100.0000'),('score',2092,'arhiva','text','100.0000'),('submit_count',2092,'arhiva','text','100.0000'),('score',2092,'arhiva','stramosi','100.0000'),('submit_count',2092,'arhiva','stramosi','100.0000'),('score',2092,'arhiva','pietre','100.0000'),('submit_count',2092,'arhiva','pietre','100.0000'),('score',961,'arhiva','adn','100.0000'),('submit_count',961,'arhiva','adn','100.0000'),('score',2092,'arhiva','pascal','100.0000'),('submit_count',2092,'arhiva','pascal','100.0000'),('score',2092,'arhiva','perm','100.0000'),('submit_count',2092,'arhiva','perm','100.0000'),('score',2092,'arhiva','secv2','100.0000'),('submit_count',2092,'arhiva','secv2','100.0000'),('score',75,'arhiva','perle','100.0000'),('submit_count',75,'arhiva','perle','100.0000'),('score',75,'arhiva','biti','100.0000'),('submit_count',75,'arhiva','biti','100.0000'),('score',75,'arhiva','energii','100.0000'),('submit_count',75,'arhiva','energii','100.0000'),('score',2092,'arhiva','sir23','100.0000'),('submit_count',2092,'arhiva','sir23','100.0000'),('score',2092,'arhiva','joc','100.0000'),('submit_count',2092,'arhiva','joc','100.0000'),('score',75,'arhiva','copaci','100.0000'),('submit_count',75,'arhiva','copaci','100.0000'),('score',48,'arhiva','xormax','100.0000'),('submit_count',48,'arhiva','xormax','100.0000'),('score',48,'arhiva','boom','100.0000'),('submit_count',48,'arhiva','boom','100.0000'),('score',2092,'arhiva','sume','95.0000'),('submit_count',2092,'arhiva','sume','95.0000'),('score',2092,'arhiva','prim','100.0000'),('submit_count',2092,'arhiva','prim','100.0000'),('score',48,'arhiva','petsoft','100.0000'),('submit_count',48,'arhiva','petsoft','100.0000'),('score',2092,'arhiva','pavare','100.0000'),('submit_count',2092,'arhiva','pavare','100.0000'),('score',48,'arhiva','iepuri','100.0000'),('submit_count',48,'arhiva','iepuri','100.0000'),('score',48,'arhiva','barbar','100.0000'),('submit_count',48,'arhiva','barbar','100.0000'),('score',48,'arhiva','indep','100.0000'),('submit_count',48,'arhiva','indep','100.0000'),('score',48,'arhiva','cerere','100.0000'),('submit_count',48,'arhiva','cerere','100.0000'),('score',48,'arhiva','adn','100.0000'),('submit_count',48,'arhiva','adn','100.0000'),('score',48,'arhiva','subsir','100.0000'),('submit_count',48,'arhiva','subsir','100.0000'),('score',2092,'arhiva','secv','100.0000'),('submit_count',2092,'arhiva','secv','100.0000'),('score',48,'arhiva','critice','100.0000'),('submit_count',48,'arhiva','critice','100.0000'),('score',48,'arhiva','ferma','100.0000'),('submit_count',48,'arhiva','ferma','100.0000'),('score',2092,'arhiva','loto','100.0000'),('submit_count',2092,'arhiva','loto','100.0000'),('score',93,'arhiva','bool','100.0000'),('submit_count',93,'arhiva','bool','100.0000'),('score',256,'arhiva','cerere','100.0000'),('submit_count',256,'arhiva','cerere','100.0000'),('score',256,'arhiva','pascal','100.0000'),('submit_count',256,'arhiva','pascal','100.0000'),('score',256,'arhiva','barbar','100.0000'),('submit_count',256,'arhiva','barbar','100.0000'),('score',256,'arhiva','datorii','100.0000'),('submit_count',256,'arhiva','datorii','100.0000'),('score',256,'arhiva','sir23','100.0000'),('submit_count',256,'arhiva','sir23','100.0000'),('score',970,'arhiva','poligon','10.0000'),('submit_count',970,'arhiva','poligon','10.0000'),('score',93,'arhiva','pascal','100.0000'),('submit_count',93,'arhiva','pascal','100.0000'),('score',2092,'arhiva','energii','100.0000'),('submit_count',2092,'arhiva','energii','100.0000'),('score',93,'arhiva','petrica','60.0000'),('submit_count',93,'arhiva','petrica','60.0000'),('score',2455,'arhiva','perm','0.0000'),('submit_count',2455,'arhiva','perm','0.0000'),('score',1137,'arhiva','adunare','100.0000'),('submit_count',1137,'arhiva','adunare','100.0000'),('score',256,'arhiva','ferma','100.0000'),('submit_count',256,'arhiva','ferma','100.0000'),('score',75,'arhiva','tabela','100.0000'),('submit_count',75,'arhiva','tabela','100.0000'),('score',256,'arhiva','tribute','100.0000'),('submit_count',256,'arhiva','tribute','100.0000'),('score',1,'arhiva','bombar','100.0000'),('submit_count',1,'arhiva','bombar','100.0000'),('score',1,'arhiva','cobai','100.0000'),('submit_count',1,'arhiva','cobai','100.0000'),('score',1,'arhiva','concert','100.0000'),('submit_count',1,'arhiva','concert','100.0000'),('score',1,'arhiva','perm3','100.0000'),('submit_count',1,'arhiva','perm3','100.0000'),('score',1,'arhiva','triang','100.0000'),('submit_count',1,'arhiva','triang','100.0000'),('score',1,'arhiva','patrate','100.0000'),('submit_count',1,'arhiva','patrate','100.0000'),('score',1,'arhiva','regine','100.0000'),('submit_count',1,'arhiva','regine','100.0000'),('score',58,'arhiva','patrate','100.0000'),('submit_count',58,'arhiva','patrate','100.0000'),('score',1,'bac2005','numere','100.0000'),('submit_count',1,'bac2005','numere','100.0000'),('score',13,'arhiva','perm3','100.0000'),('submit_count',13,'arhiva','perm3','100.0000'),('score',2092,'bac2005','numere','100.0000'),('submit_count',2092,'bac2005','numere','100.0000'),('score',2092,'arhiva','triang','100.0000'),('submit_count',2092,'arhiva','triang','100.0000'),('score',961,'arhiva','regine','100.0000'),('submit_count',961,'arhiva','regine','100.0000'),('score',2524,'arhiva','adunare','100.0000'),('submit_count',2524,'arhiva','adunare','100.0000'),('score',2524,'arhiva','cmmdc','100.0000'),('submit_count',2524,'arhiva','cmmdc','100.0000'),('score',961,'arhiva','triang','100.0000'),('submit_count',961,'arhiva','triang','100.0000'),('score',961,'arhiva','bombar','100.0000'),('submit_count',961,'arhiva','bombar','100.0000'),('score',961,'arhiva','cobai','100.0000'),('submit_count',961,'arhiva','cobai','100.0000'),('score',256,'arhiva','patrate','100.0000'),('submit_count',256,'arhiva','patrate','100.0000'),('score',2092,'arhiva','zero','100.0000'),('submit_count',2092,'arhiva','zero','100.0000'),('score',961,'arhiva','patrate','100.0000'),('submit_count',961,'arhiva','patrate','100.0000'),('score',256,'arhiva','bombar','100.0000'),('submit_count',256,'arhiva','bombar','100.0000'),('score',256,'arhiva','cobai','100.0000'),('submit_count',256,'arhiva','cobai','100.0000'),('score',256,'arhiva','perm3','100.0000'),('submit_count',256,'arhiva','perm3','100.0000'),('score',256,'arhiva','regine','100.0000'),('submit_count',256,'arhiva','regine','100.0000'),('score',256,'arhiva','text','100.0000'),('submit_count',256,'arhiva','text','100.0000'),('score',256,'arhiva','triang','70.0000'),('submit_count',256,'arhiva','triang','70.0000'),('score',961,'arhiva','perm3','100.0000'),('submit_count',961,'arhiva','perm3','100.0000'),('score',256,'arhiva','iepuri','100.0000'),('submit_count',256,'arhiva','iepuri','100.0000'),('score',1,'arhiva','robot','100.0000'),('submit_count',1,'arhiva','robot','100.0000'),('score',256,'arhiva','indep','100.0000'),('submit_count',256,'arhiva','indep','100.0000'),('score',256,'arhiva','secv','100.0000'),('submit_count',256,'arhiva','secv','100.0000'),('score',961,'arhiva','concert','100.0000'),('submit_count',961,'arhiva','concert','100.0000'),('score',256,'arhiva','sobo','100.0000'),('submit_count',256,'arhiva','sobo','100.0000'),('score',66,'arhiva','bombar','100.0000'),('submit_count',66,'arhiva','bombar','100.0000'),('score',961,'arhiva','barman','100.0000'),('submit_count',961,'arhiva','barman','100.0000'),('score',66,'arhiva','perm3','100.0000'),('submit_count',66,'arhiva','perm3','100.0000'),('score',66,'arhiva','regine','100.0000'),('submit_count',66,'arhiva','regine','100.0000'),('score',18,'arhiva','bombar','100.0000'),('submit_count',18,'arhiva','bombar','100.0000'),('score',18,'arhiva','cobai','100.0000'),('submit_count',18,'arhiva','cobai','100.0000'),('score',1024,'arhiva','tabela','100.0000'),('submit_count',1024,'arhiva','tabela','100.0000'),('score',75,'arhiva','secventa','100.0000'),('submit_count',75,'arhiva','secventa','100.0000'),('score',1024,'arhiva','subsir','40.0000'),('submit_count',1024,'arhiva','subsir','40.0000'),('score',75,'arhiva','secv3','100.0000'),('submit_count',75,'arhiva','secv3','100.0000'),('score',256,'arhiva','zero','100.0000'),('submit_count',256,'arhiva','zero','100.0000'),('score',256,'arhiva','perle','100.0000'),('submit_count',256,'arhiva','perle','100.0000'),('score',1,'arhiva','concurs','100.0000'),('submit_count',1,'arhiva','concurs','100.0000'),('score',66,'arhiva','concurs','100.0000'),('submit_count',66,'arhiva','concurs','100.0000'),('score',961,'arhiva','concurs','100.0000'),('submit_count',961,'arhiva','concurs','100.0000'),('score',66,'arhiva','cobai','100.0000'),('submit_count',66,'arhiva','cobai','100.0000'),('score',256,'arhiva','flip','100.0000'),('submit_count',256,'arhiva','flip','100.0000'),('score',66,'arhiva','triang','100.0000'),('submit_count',66,'arhiva','triang','100.0000'),('score',1024,'arhiva','cifra','100.0000'),('submit_count',1024,'arhiva','cifra','100.0000'),('score',66,'arhiva','pavare','100.0000'),('submit_count',66,'arhiva','pavare','100.0000'),('score',256,'arhiva','concurs','100.0000'),('submit_count',256,'arhiva','concurs','100.0000'),('score',1,'arhiva','tri','100.0000'),('submit_count',1,'arhiva','tri','100.0000'),('score',66,'arhiva','patrate','100.0000'),('submit_count',66,'arhiva','patrate','100.0000'),('score',961,'arhiva','tri','100.0000'),('submit_count',961,'arhiva','tri','100.0000'),('score',1024,'arhiva','tort','100.0000'),('submit_count',1024,'arhiva','tort','100.0000'),('score',2524,'arhiva','flip','100.0000'),('submit_count',2524,'arhiva','flip','100.0000'),('score',2524,'arhiva','sume','100.0000'),('submit_count',2524,'arhiva','sume','100.0000'),('score',2524,'arhiva','fact','100.0000'),('submit_count',2524,'arhiva','fact','100.0000'),('score',66,'arhiva','barman','100.0000'),('submit_count',66,'arhiva','barman','100.0000'),('score',1024,'arhiva','prim','100.0000'),('submit_count',1024,'arhiva','prim','100.0000'),('score',1024,'arhiva','bool','90.0000'),('submit_count',1024,'arhiva','bool','90.0000'),('score',256,'arhiva','biti','100.0000'),('submit_count',256,'arhiva','biti','100.0000'),('score',256,'arhiva','fractii','100.0000'),('submit_count',256,'arhiva','fractii','100.0000'),('score',961,'arhiva','robot','100.0000'),('submit_count',961,'arhiva','robot','100.0000'),('score',1,'arhiva','perechi','100.0000'),('submit_count',1,'arhiva','perechi','100.0000'),('score',961,'arhiva','perechi','100.0000'),('submit_count',961,'arhiva','perechi','100.0000'),('score',66,'arhiva','perechi','100.0000'),('submit_count',66,'arhiva','perechi','100.0000'),('score',1024,'arhiva','secventa','20.0000'),('submit_count',1024,'arhiva','secventa','20.0000'),('score',256,'arhiva','perechi','100.0000'),('submit_count',256,'arhiva','perechi','100.0000'),('score',256,'arhiva','petrica','100.0000'),('submit_count',256,'arhiva','petrica','100.0000'),('score',256,'arhiva','stramosi','100.0000'),('submit_count',256,'arhiva','stramosi','100.0000'),('score',256,'arhiva','triunghi','100.0000'),('submit_count',256,'arhiva','triunghi','100.0000'),('score',256,'arhiva','zaharel','100.0000'),('submit_count',256,'arhiva','zaharel','100.0000'),('score',256,'arhiva','trapez','100.0000'),('submit_count',256,'arhiva','trapez','100.0000'),('score',256,'arhiva','coins','100.0000'),('submit_count',256,'arhiva','coins','100.0000'),('score',256,'arhiva','copaci','100.0000'),('submit_count',256,'arhiva','copaci','100.0000'),('score',256,'arhiva','atac','100.0000'),('submit_count',256,'arhiva','atac','100.0000'),('score',256,'arhiva','sume','100.0000'),('submit_count',256,'arhiva','sume','100.0000'),('score',75,'arhiva','concurs','100.0000'),('submit_count',75,'arhiva','concurs','100.0000'),('score',15,'arhiva','prim','0.0000'),('submit_count',15,'arhiva','prim','0.0000'),('score',75,'arhiva','secv2','100.0000'),('submit_count',75,'arhiva','secv2','100.0000'),('score',256,'arhiva','munte','90.0000'),('submit_count',256,'arhiva','munte','90.0000'),('score',256,'arhiva','joc','100.0000'),('submit_count',256,'arhiva','joc','100.0000'),('score',256,'arhiva','lacate','100.0000'),('submit_count',256,'arhiva','lacate','100.0000'),('score',66,'arhiva','poligon','100.0000'),('submit_count',66,'arhiva','poligon','100.0000'),('score',256,'arhiva','pietre','100.0000'),('submit_count',256,'arhiva','pietre','100.0000'),('score',75,'arhiva','perm3','100.0000'),('submit_count',75,'arhiva','perm3','100.0000'),('score',66,'arhiva','concert','100.0000'),('submit_count',66,'arhiva','concert','100.0000'),('score',75,'arhiva','fact','100.0000'),('submit_count',75,'arhiva','fact','100.0000'),('score',13,'arhiva','perechi','0.0000'),('submit_count',13,'arhiva','perechi','0.0000'),('score',13,'arhiva','robot','0.0000'),('submit_count',13,'arhiva','robot','0.0000'),('score',2092,'arhiva','trapez','100.0000'),('submit_count',2092,'arhiva','trapez','100.0000'),('score',2092,'arhiva','iepuri','100.0000'),('submit_count',2092,'arhiva','iepuri','100.0000'),('score',2092,'arhiva','tort','100.0000'),('submit_count',2092,'arhiva','tort','100.0000'),('score',1,'arhiva','homm','100.0000'),('submit_count',1,'arhiva','homm','100.0000'),('score',1,'arhiva','colectie','100.0000'),('submit_count',1,'arhiva','colectie','100.0000'),('score',1,'arhiva','drumuri','100.0000'),('submit_count',1,'arhiva','drumuri','100.0000'),('score',1,'arhiva','tj','100.0000'),('submit_count',1,'arhiva','tj','100.0000'),('score',58,'arhiva','homm','100.0000'),('submit_count',58,'arhiva','homm','100.0000'),('score',58,'arhiva','colectie','100.0000'),('submit_count',58,'arhiva','colectie','100.0000'),('score',58,'arhiva','drumuri','100.0000'),('submit_count',58,'arhiva','drumuri','100.0000'),('score',1,'arhiva','trapeze','100.0000'),('submit_count',1,'arhiva','trapeze','100.0000'),('score',1,'arhiva','frac','100.0000'),('submit_count',1,'arhiva','frac','100.0000'),('score',961,'arhiva','frac','100.0000'),('submit_count',961,'arhiva','frac','100.0000'),('score',961,'arhiva','homm','100.0000'),('submit_count',961,'arhiva','homm','100.0000'),('score',961,'arhiva','drumuri','100.0000'),('submit_count',961,'arhiva','drumuri','100.0000'),('score',961,'arhiva','trapeze','100.0000'),('submit_count',961,'arhiva','trapeze','100.0000'),('score',961,'arhiva','cifre','100.0000'),('submit_count',961,'arhiva','cifre','100.0000'),('score',1,'arhiva','tvshow','100.0000'),('submit_count',1,'arhiva','tvshow','100.0000'),('score',961,'arhiva','tvshow','100.0000'),('submit_count',961,'arhiva','tvshow','100.0000'),('score',1,'arhiva','pal','100.0000'),('submit_count',1,'arhiva','pal','100.0000'),('score',1,'arhiva','bifo','100.0000'),('submit_count',1,'arhiva','bifo','100.0000'),('score',1,'arhiva','evantai','100.0000'),('submit_count',1,'arhiva','evantai','100.0000'),('score',1,'arhiva','algola','100.0000'),('submit_count',1,'arhiva','algola','100.0000'),('score',1,'arhiva','camion','100.0000'),('submit_count',1,'arhiva','camion','100.0000'),('score',961,'arhiva','colectie','100.0000'),('submit_count',961,'arhiva','colectie','100.0000'),('score',961,'arhiva','evantai','100.0000'),('submit_count',961,'arhiva','evantai','100.0000'),('score',2092,'arhiva','homm','100.0000'),('submit_count',2092,'arhiva','homm','100.0000'),('score',961,'arhiva','pal','100.0000'),('submit_count',961,'arhiva','pal','100.0000'),('score',961,'arhiva','camion','100.0000'),('submit_count',961,'arhiva','camion','100.0000'),('score',961,'arhiva','bifo','100.0000'),('submit_count',961,'arhiva','bifo','100.0000'),('score',2524,'arhiva','farfurii','100.0000'),('submit_count',2524,'arhiva','farfurii','100.0000'),('score',2524,'arhiva','pietre','100.0000'),('submit_count',2524,'arhiva','pietre','100.0000'),('score',2524,'arhiva','tabela','100.0000'),('submit_count',2524,'arhiva','tabela','100.0000'),('score',2524,'arhiva','tort','100.0000'),('submit_count',2524,'arhiva','tort','100.0000'),('score',2524,'arhiva','homm','100.0000'),('submit_count',2524,'arhiva','homm','100.0000'),('score',961,'arhiva','algola','100.0000'),('submit_count',961,'arhiva','algola','100.0000'),('score',2524,'arhiva','cobai','5.0000'),('submit_count',2524,'arhiva','cobai','5.0000'),('score',2524,'arhiva','secv','100.0000'),('submit_count',2524,'arhiva','secv','100.0000'),('score',2524,'arhiva','text','100.0000'),('submit_count',2524,'arhiva','text','90.0000'),('score',961,'arhiva','tj','100.0000'),('submit_count',961,'arhiva','tj','100.0000'),('score',961,'bac2005','numere','40.0000'),('submit_count',961,'bac2005','numere','40.0000'),('score',66,'arhiva','evantai','100.0000'),('submit_count',66,'arhiva','evantai','100.0000'),('score',256,'arhiva','frac','100.0000'),('submit_count',256,'arhiva','frac','100.0000'),('score',2092,'arhiva','tvshow','100.0000'),('submit_count',2092,'arhiva','tvshow','100.0000'),('score',66,'arhiva','homm','100.0000'),('submit_count',66,'arhiva','homm','100.0000'),('score',256,'arhiva','homm','100.0000'),('submit_count',256,'arhiva','homm','100.0000'),('score',66,'arhiva','camion','100.0000'),('submit_count',66,'arhiva','camion','100.0000'),('score',66,'arhiva','tj','100.0000'),('submit_count',66,'arhiva','tj','100.0000'),('score',256,'arhiva','xormax','100.0000'),('submit_count',256,'arhiva','xormax','100.0000'),('score',66,'arhiva','bifo','100.0000'),('submit_count',66,'arhiva','bifo','100.0000'),('score',66,'arhiva','drumuri','100.0000'),('submit_count',66,'arhiva','drumuri','100.0000'),('score',256,'arhiva','camion','100.0000'),('submit_count',256,'arhiva','camion','100.0000'),('score',66,'arhiva','frac','100.0000'),('submit_count',66,'arhiva','frac','100.0000'),('score',256,'arhiva','colectie','100.0000'),('submit_count',256,'arhiva','colectie','100.0000'),('score',66,'arhiva','tvshow','100.0000'),('submit_count',66,'arhiva','tvshow','100.0000'),('score',2092,'arhiva','copaci','100.0000'),('submit_count',2092,'arhiva','copaci','100.0000'),('score',256,'arhiva','lapte','100.0000'),('submit_count',256,'arhiva','lapte','100.0000'),('score',2092,'arhiva','subsir','100.0000'),('submit_count',2092,'arhiva','subsir','70.0000'),('score',256,'arhiva','bifo','100.0000'),('submit_count',256,'arhiva','bifo','100.0000'),('score',256,'arhiva','subsir','100.0000'),('submit_count',256,'arhiva','subsir','100.0000'),('score',2092,'arhiva','perm3','100.0000'),('submit_count',2092,'arhiva','perm3','100.0000'),('score',2092,'arhiva','frac','100.0000'),('submit_count',2092,'arhiva','frac','100.0000'),('score',13,'arhiva','pascal','100.0000'),('submit_count',13,'arhiva','pascal','100.0000'),('score',13,'arhiva','secv','100.0000'),('submit_count',13,'arhiva','secv','100.0000'),('score',2092,'arhiva','camion','100.0000'),('submit_count',2092,'arhiva','camion','100.0000'),('score',256,'arhiva','fractal','100.0000'),('submit_count',256,'arhiva','fractal','100.0000'),('score',256,'arhiva','rubarba','90.0000'),('submit_count',256,'arhiva','rubarba','90.0000'),('score',256,'arhiva','cutii','100.0000'),('submit_count',256,'arhiva','cutii','100.0000'),('score',2524,'arhiva','perm2','100.0000'),('submit_count',2524,'arhiva','perm2','100.0000'),('score',2524,'arhiva','cifra','100.0000'),('submit_count',2524,'arhiva','cifra','100.0000'),('score',2524,'arhiva','prim','100.0000'),('submit_count',2524,'arhiva','prim','100.0000'),('score',2524,'arhiva','cerere','100.0000'),('submit_count',2524,'arhiva','cerere','100.0000'),('score',2524,'arhiva','pal','50.0000'),('submit_count',2524,'arhiva','pal','50.0000'),('score',2524,'arhiva','zero','100.0000'),('submit_count',2524,'arhiva','zero','100.0000'),('score',2524,'arhiva','stramosi','100.0000'),('submit_count',2524,'arhiva','stramosi','100.0000'),('score',2524,'arhiva','camion','0.0000'),('submit_count',2524,'arhiva','camion','0.0000'),('score',2524,'arhiva','car','90.0000'),('submit_count',2524,'arhiva','car','90.0000'),('score',2524,'arhiva','perm','100.0000'),('submit_count',2524,'arhiva','perm','100.0000'),('score',2524,'arhiva','trapez','100.0000'),('submit_count',2524,'arhiva','trapez','100.0000'),('score',2524,'arhiva','pascal','100.0000'),('submit_count',2524,'arhiva','pascal','100.0000'),('score',2524,'arhiva','energii','100.0000'),('submit_count',2524,'arhiva','energii','100.0000'),('score',256,'arhiva','evantai','100.0000'),('submit_count',256,'arhiva','evantai','100.0000'),('score',2186,'arhiva','patrate','0.0000'),('submit_count',2186,'arhiva','patrate','0.0000'),('score',256,'arhiva','pal','100.0000'),('submit_count',256,'arhiva','pal','100.0000'),('score',1,'arhiva','luna','100.0000'),('submit_count',1,'arhiva','luna','100.0000'),('score',256,'arhiva','luna','100.0000'),('submit_count',256,'arhiva','luna','100.0000'),('score',1,'arhiva','gard','100.0000'),('submit_count',1,'arhiva','gard','100.0000'),('score',66,'arhiva','gard','100.0000'),('submit_count',66,'arhiva','gard','100.0000'),('score',1,'arhiva','gard2','100.0000'),('submit_count',1,'arhiva','gard2','100.0000'),('score',256,'arhiva','gard2','100.0000'),('submit_count',256,'arhiva','gard2','100.0000'),('score',1,'arhiva','otilia','100.0000'),('submit_count',1,'arhiva','otilia','100.0000'),('score',1142,'arhiva','triang','0.0000'),('submit_count',1142,'arhiva','triang','0.0000'),('score',66,'arhiva','luna','100.0000'),('submit_count',66,'arhiva','luna','100.0000'),('score',1,'arhiva','delay','100.0000'),('submit_count',1,'arhiva','delay','100.0000'),('score',66,'arhiva','gard2','100.0000'),('submit_count',66,'arhiva','gard2','100.0000'),('score',66,'arhiva','otilia','100.0000'),('submit_count',66,'arhiva','otilia','100.0000'),('score',1,'arhiva','gard3','100.0000'),('submit_count',1,'arhiva','gard3','100.0000'),('score',1,'arhiva','sistem','100.0000'),('submit_count',1,'arhiva','sistem','100.0000'),('score',66,'arhiva','gard3','100.0000'),('submit_count',66,'arhiva','gard3','100.0000'),('score',256,'arhiva','sistem','100.0000'),('submit_count',256,'arhiva','sistem','100.0000'),('score',66,'arhiva','sistem','100.0000'),('submit_count',66,'arhiva','sistem','100.0000'),('score',1,'arhiva','doipatru','100.0000'),('submit_count',1,'arhiva','doipatru','100.0000'),('score',2986,'arhiva','adunare','100.0000'),('submit_count',2986,'arhiva','adunare','100.0000'),('score',2986,'arhiva','cmmdc','100.0000'),('submit_count',2986,'arhiva','cmmdc','100.0000'),('score',66,'arhiva','doipatru','100.0000'),('submit_count',66,'arhiva','doipatru','100.0000'),('score',1,'arhiva','hotel','100.0000'),('submit_count',1,'arhiva','hotel','100.0000'),('score',1,'arhiva','color','100.0000'),('submit_count',1,'arhiva','color','100.0000'),('score',66,'arhiva','hotel','100.0000'),('submit_count',66,'arhiva','hotel','100.0000'),('score',2524,'arhiva','sistem','0.0000'),('submit_count',2524,'arhiva','sistem','0.0000'),('score',1,'arhiva','asmin','100.0000'),('submit_count',1,'arhiva','asmin','100.0000'),('score',1,'arhiva','proc','100.0000'),('submit_count',1,'arhiva','proc','100.0000'),('score',1,'arhiva','parcele','100.0000'),('submit_count',1,'arhiva','parcele','100.0000'),('score',256,'arhiva','color','100.0000'),('submit_count',256,'arhiva','color','100.0000'),('score',2524,'arhiva','joc','100.0000'),('submit_count',2524,'arhiva','joc','100.0000'),('score',48,'arhiva','triunghi','100.0000'),('submit_count',48,'arhiva','triunghi','100.0000'),('score',1,'arhiva','soc','100.0000'),('submit_count',1,'arhiva','soc','100.0000'),('score',1,'arhiva','ecu','100.0000'),('submit_count',1,'arhiva','ecu','100.0000'),('score',48,'arhiva','sir23','100.0000'),('submit_count',48,'arhiva','sir23','100.0000'),('score',1,'arhiva','tri2','100.0000'),('submit_count',1,'arhiva','tri2','100.0000'),('score',48,'arhiva','tort','100.0000'),('submit_count',48,'arhiva','tort','100.0000'),('score',48,'arhiva','zero','100.0000'),('submit_count',48,'arhiva','zero','100.0000'),('score',48,'arhiva','perle','100.0000'),('submit_count',48,'arhiva','perle','100.0000'),('score',48,'arhiva','prim','100.0000'),('submit_count',48,'arhiva','prim','100.0000'),('score',1,'arhiva','lanterna','100.0000'),('submit_count',1,'arhiva','lanterna','100.0000'),('score',1,'arhiva','trans','100.0000'),('submit_count',1,'arhiva','trans','100.0000'),('score',48,'arhiva','sume','100.0000'),('submit_count',48,'arhiva','sume','100.0000'),('score',48,'arhiva','munte','100.0000'),('submit_count',48,'arhiva','munte','100.0000'),('score',48,'arhiva','energii','100.0000'),('submit_count',48,'arhiva','energii','100.0000'),('score',48,'arhiva','loto','100.0000'),('submit_count',48,'arhiva','loto','100.0000'),('score',48,'arhiva','secv2','100.0000'),('submit_count',48,'arhiva','secv2','100.0000'),('score',48,'arhiva','lapte','100.0000'),('submit_count',48,'arhiva','lapte','100.0000'),('score',1,'arhiva','color2','100.0000'),('submit_count',1,'arhiva','color2','100.0000'),('score',48,'arhiva','secv3','100.0000'),('submit_count',48,'arhiva','secv3','100.0000'),('score',1,'arhiva','base3','100.0000'),('submit_count',1,'arhiva','base3','100.0000'),('score',1,'arhiva','prefix','100.0000'),('submit_count',1,'arhiva','prefix','100.0000'),('score',961,'arhiva','luna','100.0000'),('submit_count',961,'arhiva','luna','100.0000'),('score',256,'arhiva','trans','100.0000'),('submit_count',256,'arhiva','trans','100.0000'),('score',256,'arhiva','color2','100.0000'),('submit_count',256,'arhiva','color2','100.0000'),('score',2092,'arhiva','gard','100.0000'),('submit_count',2092,'arhiva','gard','100.0000'),('score',48,'arhiva','lacate','100.0000'),('submit_count',48,'arhiva','lacate','100.0000'),('score',1,'arhiva','comp','100.0000'),('submit_count',1,'arhiva','comp','100.0000'),('score',1,'arhiva','sediu','100.0000'),('submit_count',1,'arhiva','sediu','100.0000'),('score',1,'arhiva','echipe','100.0000'),('submit_count',1,'arhiva','echipe','100.0000'),('score',256,'arhiva','sediu','100.0000'),('submit_count',256,'arhiva','sediu','100.0000'),('score',2092,'arhiva','proc','100.0000'),('submit_count',2092,'arhiva','proc','100.0000'),('score',1,'arhiva','granita','100.0000'),('submit_count',1,'arhiva','granita','100.0000'),('score',1,'arhiva','asmax','100.0000'),('submit_count',1,'arhiva','asmax','100.0000'),('score',256,'arhiva','granita','100.0000'),('submit_count',256,'arhiva','granita','100.0000'),('score',256,'arhiva','asmax','100.0000'),('submit_count',256,'arhiva','asmax','100.0000'),('score',256,'arhiva','prefix','100.0000'),('submit_count',256,'arhiva','prefix','100.0000'),('score',961,'arhiva','gard','100.0000'),('submit_count',961,'arhiva','gard','100.0000'),('score',2186,'arhiva','color','0.0000'),('submit_count',2186,'arhiva','color','0.0000'),('score',66,'arhiva','prefix','100.0000'),('submit_count',66,'arhiva','prefix','100.0000'),('score',961,'arhiva','granita','100.0000'),('submit_count',961,'arhiva','granita','100.0000'),('score',66,'arhiva','granita','100.0000'),('submit_count',66,'arhiva','granita','100.0000'),('score',2092,'arhiva','prefix','100.0000'),('submit_count',2092,'arhiva','prefix','100.0000'),('score',66,'happy','arie','80.0000'),('submit_count',66,'happy','arie','80.0000'),('score',66,'happy','bile','100.0000'),('submit_count',66,'happy','bile','100.0000'),('score',66,'happy','muzeu','100.0000'),('submit_count',66,'happy','muzeu','100.0000'),('score',58,'happy','arie','100.0000'),('submit_count',58,'happy','arie','100.0000'),('score',58,'happy','bile','100.0000'),('submit_count',58,'happy','bile','100.0000'),('score',58,'happy','muzeu','100.0000'),('submit_count',58,'happy','muzeu','100.0000'),('score',58,'happy','numere','100.0000'),('submit_count',58,'happy','numere','100.0000'),('score',58,'happy','suma','100.0000'),('submit_count',58,'happy','suma','100.0000'),('score',58,'happy','transport','100.0000'),('submit_count',58,'happy','transport','100.0000'),('score',93,'happy','suma','100.0000'),('submit_count',93,'happy','suma','100.0000'),('score',93,'happy','transport','100.0000'),('submit_count',93,'happy','transport','100.0000'),('score',93,'happy','muzeu','100.0000'),('submit_count',93,'happy','muzeu','100.0000'),('score',961,'happy','transport','100.0000'),('submit_count',961,'happy','transport','100.0000'),('score',961,'happy','suma','100.0000'),('submit_count',961,'happy','suma','100.0000'),('score',961,'happy','muzeu','100.0000'),('submit_count',961,'happy','muzeu','100.0000'),('score',961,'happy','bile','100.0000'),('submit_count',961,'happy','bile','100.0000'),('score',961,'happy','numere','100.0000'),('submit_count',961,'happy','numere','100.0000'),('score',2092,'happy','transport','100.0000'),('submit_count',2092,'happy','transport','100.0000'),('score',2092,'happy','suma','100.0000'),('submit_count',2092,'happy','suma','100.0000'),('score',2092,'happy','numere','100.0000'),('submit_count',2092,'happy','numere','100.0000'),('score',2092,'happy','muzeu','100.0000'),('submit_count',2092,'happy','muzeu','100.0000'),('score',93,'happy','numere','100.0000'),('submit_count',93,'happy','numere','100.0000'),('score',18,'happy','bile','100.0000'),('submit_count',18,'happy','bile','100.0000'),('score',18,'happy','muzeu','100.0000'),('submit_count',18,'happy','muzeu','100.0000'),('score',18,'happy','numere','100.0000'),('submit_count',18,'happy','numere','100.0000'),('score',18,'happy','suma','100.0000'),('submit_count',18,'happy','suma','100.0000'),('score',18,'happy','transport','100.0000'),('submit_count',18,'happy','transport','100.0000'),('score',970,'happy','numere','100.0000'),('submit_count',970,'happy','numere','100.0000'),('score',970,'happy','suma','100.0000'),('submit_count',970,'happy','suma','100.0000'),('score',970,'happy','transport','100.0000'),('submit_count',970,'happy','transport','100.0000'),('score',970,'happy','muzeu','100.0000'),('submit_count',970,'happy','muzeu','100.0000'),('score',93,'happy','arie','10.0000'),('submit_count',93,'happy','arie','10.0000'),('score',2092,'happy','bile','10.0000'),('submit_count',2092,'happy','bile','10.0000'),('score',93,'happy','bile','100.0000'),('submit_count',93,'happy','bile','100.0000'),('score',970,'happy','bile','100.0000'),('submit_count',970,'happy','bile','100.0000'),('score',18,'happy','arie','100.0000'),('submit_count',18,'happy','arie','100.0000'),('score',961,'happy','arie','90.0000'),('submit_count',961,'happy','arie','90.0000'),('score',970,'happy','arie','100.0000'),('submit_count',970,'happy','arie','100.0000'),('score',2092,'arhiva','cutii','100.0000'),('submit_count',2092,'arhiva','cutii','100.0000'),('score',2092,'arhiva','perle','100.0000'),('submit_count',2092,'arhiva','perle','100.0000'),('score',961,'arhiva','gard2','100.0000'),('submit_count',961,'arhiva','gard2','100.0000'),('score',961,'arhiva','otilia','100.0000'),('submit_count',961,'arhiva','otilia','100.0000'),('score',961,'arhiva','delay','100.0000'),('submit_count',961,'arhiva','delay','100.0000'),('score',961,'arhiva','color2','100.0000'),('submit_count',961,'arhiva','color2','100.0000'),('score',1,'arhiva','arie','100.0000'),('submit_count',1,'arhiva','arie','100.0000'),('score',1,'arhiva','bile','100.0000'),('submit_count',1,'arhiva','bile','100.0000'),('score',1,'arhiva','muzeu','100.0000'),('submit_count',1,'arhiva','muzeu','100.0000'),('score',1,'arhiva','numere','100.0000'),('submit_count',1,'arhiva','numere','100.0000'),('score',1,'arhiva','transport','100.0000'),('submit_count',1,'arhiva','transport','100.0000'),('score',1,'arhiva','suma','100.0000'),('submit_count',1,'arhiva','suma','100.0000'),('score',256,'arhiva','transport','100.0000'),('submit_count',256,'arhiva','transport','100.0000'),('score',93,'arhiva','suma','100.0000'),('submit_count',93,'arhiva','suma','100.0000'),('score',93,'arhiva','transport','100.0000'),('submit_count',93,'arhiva','transport','100.0000'),('score',93,'arhiva','numere','100.0000'),('submit_count',93,'arhiva','numere','100.0000'),('score',93,'arhiva','muzeu','100.0000'),('submit_count',93,'arhiva','muzeu','100.0000'),('score',93,'arhiva','bile','100.0000'),('submit_count',93,'arhiva','bile','100.0000'),('score',961,'arhiva','bile','100.0000'),('submit_count',961,'arhiva','bile','100.0000'),('score',961,'arhiva','muzeu','100.0000'),('submit_count',961,'arhiva','muzeu','100.0000'),('score',961,'arhiva','numere','100.0000'),('submit_count',961,'arhiva','numere','100.0000'),('score',961,'arhiva','transport','100.0000'),('submit_count',961,'arhiva','transport','100.0000'),('score',961,'arhiva','suma','100.0000'),('submit_count',961,'arhiva','suma','100.0000'),('score',2092,'arhiva','muzeu','100.0000'),('submit_count',2092,'arhiva','muzeu','100.0000'),('score',2092,'arhiva','numere','100.0000'),('submit_count',2092,'arhiva','numere','100.0000'),('score',2092,'arhiva','transport','100.0000'),('submit_count',2092,'arhiva','transport','100.0000'),('score',2092,'arhiva','suma','100.0000'),('submit_count',2092,'arhiva','suma','100.0000'),('score',256,'arhiva','muzeu','100.0000'),('submit_count',256,'arhiva','muzeu','100.0000'),('score',256,'arhiva','suma','100.0000'),('submit_count',256,'arhiva','suma','100.0000'),('score',2092,'arhiva','barbar','100.0000'),('submit_count',2092,'arhiva','barbar','100.0000'),('score',256,'arhiva','bile','100.0000'),('submit_count',256,'arhiva','bile','100.0000'),('score',256,'arhiva','numere','100.0000'),('submit_count',256,'arhiva','numere','100.0000'),('score',961,'arhiva','gard3','100.0000'),('submit_count',961,'arhiva','gard3','100.0000'),('score',256,'arhiva','proc','100.0000'),('submit_count',256,'arhiva','proc','100.0000'),('score',961,'arhiva','sistem','100.0000'),('submit_count',961,'arhiva','sistem','100.0000'),('score',2524,'arhiva','suma','100.0000'),('submit_count',2524,'arhiva','suma','100.0000'),('score',48,'arhiva','bool','100.0000'),('submit_count',48,'arhiva','bool','100.0000'),('score',66,'arhiva','suma','100.0000'),('submit_count',66,'arhiva','suma','100.0000'),('score',66,'arhiva','muzeu','100.0000'),('submit_count',66,'arhiva','muzeu','100.0000'),('score',66,'arhiva','bile','100.0000'),('submit_count',66,'arhiva','bile','100.0000'),('score',66,'arhiva','trans','100.0000'),('submit_count',66,'arhiva','trans','100.0000'),('score',256,'arhiva','lanterna','100.0000'),('submit_count',256,'arhiva','lanterna','100.0000'),('score',256,'arhiva','base3','80.0000'),('submit_count',256,'arhiva','base3','80.0000'),('score',1,'arhiva','poligon2','100.0000'),('submit_count',1,'arhiva','poligon2','100.0000'),('score',1975,'arhiva','prim','100.0000'),('submit_count',1975,'arhiva','prim','100.0000'),('score',1,'arhiva','string','100.0000'),('submit_count',1,'arhiva','string','100.0000'),('score',2092,'arhiva','indep','100.0000'),('submit_count',2092,'arhiva','indep','100.0000'),('score',48,'arhiva','fractal','100.0000'),('submit_count',48,'arhiva','fractal','100.0000'),('score',256,'arhiva','boom','100.0000'),('submit_count',256,'arhiva','boom','100.0000'),('score',256,'arhiva','poligon2','100.0000'),('submit_count',256,'arhiva','poligon2','100.0000'),('score',961,'arhiva','prefix','100.0000'),('submit_count',961,'arhiva','prefix','100.0000'),('score',48,'arhiva','party','100.0000'),('submit_count',48,'arhiva','party','100.0000'),('score',961,'arhiva','proc','100.0000'),('submit_count',961,'arhiva','proc','100.0000'),('score',961,'arhiva','asmin','100.0000'),('submit_count',961,'arhiva','asmin','100.0000'),('score',961,'arhiva','asmax','100.0000'),('submit_count',961,'arhiva','asmax','100.0000'),('score',1,'arhiva','zoo','100.0000'),('submit_count',1,'arhiva','zoo','100.0000'),('score',961,'arhiva','doipatru','100.0000'),('submit_count',961,'arhiva','doipatru','100.0000'),('score',961,'arhiva','sediu','100.0000'),('submit_count',961,'arhiva','sediu','100.0000'),('score',256,'arhiva','zoo','100.0000'),('submit_count',256,'arhiva','zoo','100.0000'),('score',48,'arhiva','tribute','100.0000'),('submit_count',48,'arhiva','tribute','100.0000'),('score',256,'arhiva','string','100.0000'),('submit_count',256,'arhiva','string','100.0000'),('score',48,'arhiva','coins','100.0000'),('submit_count',48,'arhiva','coins','100.0000'),('score',256,'arhiva','parcele','100.0000'),('submit_count',256,'arhiva','parcele','100.0000'),('score',961,'arhiva','color','100.0000'),('submit_count',961,'arhiva','color','100.0000'),('score',961,'arhiva','poligon2','100.0000'),('submit_count',961,'arhiva','poligon2','100.0000'),('score',961,'arhiva','ecu','100.0000'),('submit_count',961,'arhiva','ecu','100.0000'),('score',961,'arhiva','trans','100.0000'),('submit_count',961,'arhiva','trans','100.0000'),('score',66,'arhiva','transport','100.0000'),('submit_count',66,'arhiva','transport','100.0000'),('score',66,'arhiva','sediu','100.0000'),('submit_count',66,'arhiva','sediu','100.0000'),('score',1975,'arhiva','sume','0.0000'),('submit_count',1975,'arhiva','sume','0.0000'),('score',961,'arhiva','arie','100.0000'),('submit_count',961,'arhiva','arie','100.0000'),('score',66,'arhiva','string','100.0000'),('submit_count',66,'arhiva','string','100.0000'),('score',961,'arhiva','soc','100.0000'),('submit_count',961,'arhiva','soc','100.0000'),('score',1024,'arhiva','suma','100.0000'),('submit_count',1024,'arhiva','suma','100.0000'),('score',66,'arhiva','ecu','100.0000'),('submit_count',66,'arhiva','ecu','100.0000'),('score',66,'arhiva','poligon2','100.0000'),('submit_count',66,'arhiva','poligon2','100.0000'),('score',2986,'arhiva','sume','90.0000'),('submit_count',2986,'arhiva','sume','90.0000'),('score',66,'arhiva','color','100.0000'),('submit_count',66,'arhiva','color','100.0000'),('score',66,'arhiva','proc','100.0000'),('submit_count',66,'arhiva','proc','100.0000'),('score',66,'arhiva','color2','100.0000'),('submit_count',66,'arhiva','color2','100.0000'),('score',66,'arhiva','lanterna','100.0000'),('submit_count',66,'arhiva','lanterna','100.0000'),('score',961,'arhiva','string','100.0000'),('submit_count',961,'arhiva','string','100.0000'),('score',961,'arhiva','lanterna','100.0000'),('submit_count',961,'arhiva','lanterna','100.0000'),('score',66,'arhiva','delay','100.0000'),('submit_count',66,'arhiva','delay','100.0000'),('score',1975,'arhiva','suma','100.0000'),('submit_count',1975,'arhiva','suma','100.0000'),('score',961,'arhiva','hotel','100.0000'),('submit_count',961,'arhiva','hotel','100.0000'),('score',66,'arhiva','asmax','100.0000'),('submit_count',66,'arhiva','asmax','100.0000'),('score',961,'arhiva','zoo','100.0000'),('submit_count',961,'arhiva','zoo','100.0000'),('score',66,'arhiva','asmin','100.0000'),('submit_count',66,'arhiva','asmin','100.0000'),('score',66,'arhiva','numere','100.0000'),('submit_count',66,'arhiva','numere','100.0000'),('score',66,'arhiva','soc','100.0000'),('submit_count',66,'arhiva','soc','100.0000'),('score',48,'arhiva','zaharel','100.0000'),('submit_count',48,'arhiva','zaharel','100.0000'),('score',961,'arhiva','parcele','100.0000'),('submit_count',961,'arhiva','parcele','100.0000'),('score',1024,'arhiva','triang','0.0000'),('submit_count',1024,'arhiva','triang','0.0000'),('score',48,'arhiva','sobo','100.0000'),('submit_count',48,'arhiva','sobo','100.0000'),('score',256,'arhiva','gard','100.0000'),('submit_count',256,'arhiva','gard','100.0000'),('score',66,'arhiva','zoo','100.0000'),('submit_count',66,'arhiva','zoo','100.0000'),('score',1024,'arhiva','concert','100.0000'),('submit_count',1024,'arhiva','concert','100.0000'),('score',1024,'arhiva','perm','0.0000'),('submit_count',1024,'arhiva','perm','0.0000'),('score',2524,'arhiva','secventa','100.0000'),('submit_count',2524,'arhiva','secventa','100.0000'),('score',1024,'bac2005','numere','100.0000'),('submit_count',1024,'bac2005','numere','100.0000'),('score',1024,'arhiva','perechi','100.0000'),('submit_count',1024,'arhiva','perechi','100.0000'),('score',256,'arhiva','hotel','100.0000'),('submit_count',256,'arhiva','hotel','100.0000'),('score',48,'arhiva','text','100.0000'),('submit_count',48,'arhiva','text','100.0000'),('score',48,'arhiva','trapez','100.0000'),('submit_count',48,'arhiva','trapez','100.0000'),('score',48,'arhiva','pascal','100.0000'),('submit_count',48,'arhiva','pascal','100.0000'),('score',1024,'arhiva','farfurii','100.0000'),('submit_count',1024,'arhiva','farfurii','100.0000'),('score',2524,'arhiva','numere','100.0000'),('submit_count',2524,'arhiva','numere','100.0000'),('score',256,'arhiva','tj','10.0000'),('submit_count',256,'arhiva','tj','10.0000'),('score',48,'arhiva','secv','100.0000'),('submit_count',48,'arhiva','secv','100.0000'),('score',2524,'arhiva','muzeu','100.0000'),('submit_count',2524,'arhiva','muzeu','100.0000'),('score',18,'arhiva','bifo','100.0000'),('submit_count',18,'arhiva','bifo','100.0000'),('score',18,'arhiva','evantai','100.0000'),('submit_count',18,'arhiva','evantai','100.0000'),('score',18,'arhiva','gard','100.0000'),('submit_count',18,'arhiva','gard','100.0000'),('score',66,'arhiva','arie','100.0000'),('submit_count',66,'arhiva','arie','100.0000'),('score',48,'arhiva','car','100.0000'),('submit_count',48,'arhiva','car','100.0000'),('score',48,'arhiva','barman','80.0000'),('submit_count',48,'arhiva','barman','80.0000'),('score',48,'arhiva','cifre','100.0000'),('submit_count',48,'arhiva','cifre','100.0000'),('score',18,'hc2','calatorie','0.0000'),('submit_count',18,'hc2','calatorie','0.0000'),('score',2092,'hc2','cercuri','0.0000'),('submit_count',2092,'hc2','cercuri','0.0000'),('score',2092,'hc2','cai','0.0000'),('submit_count',2092,'hc2','cai','0.0000'),('score',970,'hc2','divmul','100.0000'),('submit_count',970,'hc2','divmul','100.0000'),('score',2092,'hc2','linterv','100.0000'),('submit_count',2092,'hc2','linterv','100.0000'),('score',970,'hc2','cercuri','0.0000'),('submit_count',970,'hc2','cercuri','0.0000'),('score',970,'hc2','cai','0.0000'),('submit_count',970,'hc2','cai','0.0000'),('score',2092,'hc2','calatorie','100.0000'),('submit_count',2092,'hc2','calatorie','100.0000'),('score',75,'hc2','expresii','0.0000'),('submit_count',75,'hc2','expresii','0.0000'),('score',1142,'hc2','expresii','0.0000'),('submit_count',1142,'hc2','expresii','0.0000'),('score',93,'hc2','razboi','0.0000'),('submit_count',93,'hc2','razboi','0.0000'),('score',93,'hc2','linterv','100.0000'),('submit_count',93,'hc2','linterv','100.0000'),('score',2524,'hc2','divmul','100.0000'),('submit_count',2524,'hc2','divmul','100.0000'),('score',1024,'hc2','divmul','0.0000'),('submit_count',1024,'hc2','divmul','0.0000'),('score',970,'hc2','linterv','100.0000'),('submit_count',970,'hc2','linterv','100.0000'),('score',2524,'hc2','cercuri','0.0000'),('submit_count',2524,'hc2','cercuri','0.0000'),('score',970,'hc2','calatorie','100.0000'),('submit_count',970,'hc2','calatorie','100.0000'),('score',970,'hc2','razboi','100.0000'),('submit_count',970,'hc2','razboi','100.0000'),('score',93,'hc2','cercuri','0.0000'),('submit_count',93,'hc2','cercuri','0.0000'),('score',93,'hc2','palind','100.0000'),('submit_count',93,'hc2','palind','100.0000'),('score',142,'hc2','expresii','100.0000'),('submit_count',142,'hc2','expresii','100.0000'),('score',93,'hc2','divmul','100.0000'),('submit_count',93,'hc2','divmul','100.0000'),('score',2524,'hc2','linterv','100.0000'),('submit_count',2524,'hc2','linterv','100.0000'),('score',1,'arhiva','expresii','100.0000'),('submit_count',1,'arhiva','expresii','100.0000'),('score',1,'arhiva','calatorie','100.0000'),('submit_count',1,'arhiva','calatorie','100.0000'),('score',1,'arhiva','razboi','100.0000'),('submit_count',1,'arhiva','razboi','100.0000'),('score',1,'arhiva','divmul','100.0000'),('submit_count',1,'arhiva','divmul','100.0000'),('score',1,'arhiva','palind','100.0000'),('submit_count',1,'arhiva','palind','100.0000'),('score',1,'arhiva','linterv','100.0000'),('submit_count',1,'arhiva','linterv','100.0000'),('score',1,'arhiva','resturi','100.0000'),('submit_count',1,'arhiva','resturi','100.0000'),('score',961,'arhiva','jarbore','100.0000'),('submit_count',961,'arhiva','jarbore','100.0000'),('score',1,'arhiva','cai','100.0000'),('submit_count',1,'arhiva','cai','100.0000'),('score',961,'arhiva','cai','100.0000'),('submit_count',961,'arhiva','cai','100.0000'),('score',961,'arhiva','divmul','100.0000'),('submit_count',961,'arhiva','divmul','100.0000'),('score',1,'arhiva','cercuri','100.0000'),('submit_count',1,'arhiva','cercuri','100.0000'),('score',961,'arhiva','linterv','100.0000'),('submit_count',961,'arhiva','linterv','100.0000'),('score',961,'arhiva','palind','100.0000'),('submit_count',961,'arhiva','palind','100.0000'),('score',961,'arhiva','razboi','100.0000'),('submit_count',961,'arhiva','razboi','100.0000'),('score',961,'arhiva','calatorie','100.0000'),('submit_count',961,'arhiva','calatorie','100.0000'),('score',93,'arhiva','cercuri','100.0000'),('submit_count',93,'arhiva','cercuri','100.0000'),('score',93,'arhiva','palind','100.0000'),('submit_count',93,'arhiva','palind','100.0000'),('score',93,'arhiva','linterv','100.0000'),('submit_count',93,'arhiva','linterv','100.0000'),('score',93,'arhiva','divmul','100.0000'),('submit_count',93,'arhiva','divmul','100.0000'),('score',66,'arhiva','divmul','100.0000'),('submit_count',66,'arhiva','divmul','100.0000'),('score',66,'arhiva','cai','100.0000'),('submit_count',66,'arhiva','cai','100.0000'),('score',66,'arhiva','cercuri','100.0000'),('submit_count',66,'arhiva','cercuri','100.0000'),('score',66,'arhiva','expresii','100.0000'),('submit_count',66,'arhiva','expresii','100.0000'),('score',66,'arhiva','calatorie','100.0000'),('submit_count',66,'arhiva','calatorie','100.0000'),('score',66,'arhiva','razboi','100.0000'),('submit_count',66,'arhiva','razboi','100.0000'),('score',66,'arhiva','palind','100.0000'),('submit_count',66,'arhiva','palind','100.0000'),('score',66,'arhiva','linterv','100.0000'),('submit_count',66,'arhiva','linterv','100.0000'),('score',2524,'arhiva','cercuri','100.0000'),('submit_count',2524,'arhiva','cercuri','100.0000'),('score',2524,'arhiva','divmul','100.0000'),('submit_count',2524,'arhiva','divmul','100.0000'),('score',2524,'arhiva','linterv','100.0000'),('submit_count',2524,'arhiva','linterv','100.0000'),('score',66,'arhiva','resturi','100.0000'),('submit_count',66,'arhiva','resturi','100.0000'),('score',2092,'arhiva','calatorie','100.0000'),('submit_count',2092,'arhiva','calatorie','100.0000'),('score',2092,'arhiva','linterv','100.0000'),('submit_count',2092,'arhiva','linterv','100.0000'),('score',2092,'arhiva','cercuri','100.0000'),('submit_count',2092,'arhiva','cercuri','100.0000'),('score',2092,'arhiva','secv3','100.0000'),('submit_count',2092,'arhiva','secv3','100.0000'),('score',961,'arhiva','cercuri','100.0000'),('submit_count',961,'arhiva','cercuri','100.0000'),('score',18,'arhiva','expresii','100.0000'),('submit_count',18,'arhiva','expresii','100.0000'),('score',18,'arhiva','calatorie','100.0000'),('submit_count',18,'arhiva','calatorie','100.0000'),('score',18,'arhiva','razboi','100.0000'),('submit_count',18,'arhiva','razboi','100.0000'),('score',18,'arhiva','divmul','100.0000'),('submit_count',18,'arhiva','divmul','100.0000'),('score',18,'arhiva','palind','100.0000'),('submit_count',18,'arhiva','palind','100.0000'),('score',18,'arhiva','cai','100.0000'),('submit_count',18,'arhiva','cai','100.0000'),('score',18,'arhiva','cercuri','100.0000'),('submit_count',18,'arhiva','cercuri','100.0000'),('score',18,'arhiva','jarbore','100.0000'),('submit_count',18,'arhiva','jarbore','100.0000'),('score',18,'arhiva','linterv','100.0000'),('submit_count',18,'arhiva','linterv','100.0000'),('score',18,'arhiva','arie','100.0000'),('submit_count',18,'arhiva','arie','100.0000'),('score',18,'arhiva','bile','100.0000'),('submit_count',18,'arhiva','bile','100.0000'),('score',18,'arhiva','muzeu','100.0000'),('submit_count',18,'arhiva','muzeu','100.0000'),('score',18,'arhiva','numere','100.0000'),('submit_count',18,'arhiva','numere','100.0000'),('score',18,'arhiva','transport','100.0000'),('submit_count',18,'arhiva','transport','100.0000'),('score',18,'arhiva','suma','100.0000'),('submit_count',18,'arhiva','suma','100.0000'),('score',18,'arhiva','trans','100.0000'),('submit_count',18,'arhiva','trans','100.0000'),('score',18,'arhiva','color2','100.0000'),('submit_count',18,'arhiva','color2','100.0000'),('score',18,'arhiva','base3','100.0000'),('submit_count',18,'arhiva','base3','100.0000'),('score',18,'arhiva','comp','100.0000'),('submit_count',18,'arhiva','comp','100.0000'),('score',18,'arhiva','lanterna','90.0000'),('submit_count',18,'arhiva','lanterna','90.0000'),('score',961,'arhiva','resturi','100.0000'),('submit_count',961,'arhiva','resturi','100.0000'),('score',3257,'arhiva','adunare','100.0000'),('submit_count',3257,'arhiva','adunare','100.0000'),('score',66,'arhiva','jarbore','100.0000'),('submit_count',66,'arhiva','jarbore','100.0000'),('score',2092,'arhiva','divmul','100.0000'),('submit_count',2092,'arhiva','divmul','100.0000'),('score',3257,'arhiva','flip','20.0000'),('submit_count',3257,'arhiva','flip','20.0000'),('score',3257,'arhiva','cmmdc','100.0000'),('submit_count',3257,'arhiva','cmmdc','100.0000'),('score',3257,'arhiva','fractii','10.0000'),('submit_count',3257,'arhiva','fractii','10.0000'),('score',66,'arhiva','cifre','100.0000'),('submit_count',66,'arhiva','cifre','100.0000'),('score',1142,'arhiva','cercuri','100.0000'),('submit_count',1142,'arhiva','cercuri','100.0000'),('score',1142,'arhiva','linterv','100.0000'),('submit_count',1142,'arhiva','linterv','100.0000'),('score',256,'arhiva','razboi','100.0000'),('submit_count',256,'arhiva','razboi','100.0000'),('score',256,'arhiva','divmul','100.0000'),('submit_count',256,'arhiva','divmul','100.0000'),('score',256,'arhiva','cai','0.0000'),('submit_count',256,'arhiva','cai','0.0000'),('score',66,'arhiva','colectie','100.0000'),('submit_count',66,'arhiva','colectie','100.0000'),('score',48,'arhiva','farfurii','100.0000'),('submit_count',48,'arhiva','farfurii','100.0000'),('score',48,'arhiva','expresii','100.0000'),('submit_count',48,'arhiva','expresii','100.0000'),('score',48,'arhiva','calatorie','100.0000'),('submit_count',48,'arhiva','calatorie','100.0000'),('score',48,'arhiva','razboi','100.0000'),('submit_count',48,'arhiva','razboi','100.0000'),('score',66,'arhiva','trapeze','100.0000'),('submit_count',66,'arhiva','trapeze','100.0000'),('score',256,'arhiva','calatorie','100.0000'),('submit_count',256,'arhiva','calatorie','100.0000'),('score',256,'arhiva','linterv','100.0000'),('submit_count',256,'arhiva','linterv','100.0000'),('score',66,'arhiva','pal','100.0000'),('submit_count',66,'arhiva','pal','100.0000'),('score',256,'arhiva','palind','100.0000'),('submit_count',256,'arhiva','palind','100.0000'),('score',75,'arhiva','expresii','100.0000'),('submit_count',75,'arhiva','expresii','100.0000'),('score',1670,'arhiva','fact','100.0000'),('submit_count',1670,'arhiva','fact','100.0000'),('score',2524,'arhiva','secv2','100.0000'),('submit_count',2524,'arhiva','secv2','100.0000'),('score',2524,'arhiva','secv3','100.0000'),('submit_count',2524,'arhiva','secv3','100.0000'),('score',1975,'arhiva','divmul','100.0000'),('submit_count',1975,'arhiva','divmul','100.0000'),('score',1975,'arhiva','linterv','100.0000'),('submit_count',1975,'arhiva','linterv','100.0000'),('score',256,'arhiva','jarbore','100.0000'),('submit_count',256,'arhiva','jarbore','100.0000'),('score',48,'arhiva','linterv','100.0000'),('submit_count',48,'arhiva','linterv','100.0000'),('score',48,'arhiva','palind','100.0000'),('submit_count',48,'arhiva','palind','100.0000'),('score',961,'arhiva','expresii','100.0000'),('submit_count',961,'arhiva','expresii','100.0000'),('score',961,'arhiva','comp','100.0000'),('submit_count',961,'arhiva','comp','100.0000'),('score',1,'arhiva','jarbore','100.0000'),('submit_count',1,'arhiva','jarbore','100.0000'),('score',48,'arhiva','delay','100.0000'),('submit_count',48,'arhiva','delay','100.0000'),('score',961,'arhiva','echipe','100.0000'),('submit_count',961,'arhiva','echipe','100.0000'),('score',48,'arhiva','hotel','100.0000'),('submit_count',48,'arhiva','hotel','100.0000'),('score',2092,'arhiva','cobai','100.0000'),('submit_count',2092,'arhiva','cobai','100.0000'),('score',58,'arhiva','arie','100.0000'),('submit_count',58,'arhiva','arie','100.0000'),('score',58,'arhiva','bile','100.0000'),('submit_count',58,'arhiva','bile','100.0000'),('score',58,'arhiva','muzeu','100.0000'),('submit_count',58,'arhiva','muzeu','100.0000'),('score',58,'arhiva','numere','100.0000'),('submit_count',58,'arhiva','numere','100.0000'),('score',58,'arhiva','suma','100.0000'),('submit_count',58,'arhiva','suma','100.0000'),('score',58,'arhiva','transport','100.0000'),('submit_count',58,'arhiva','transport','100.0000'),('score',75,'arhiva','calatorie','100.0000'),('submit_count',75,'arhiva','calatorie','100.0000'),('score',66,'arhiva','algola','100.0000'),('submit_count',66,'arhiva','algola','100.0000'),('score',75,'arhiva','cercuri','100.0000'),('submit_count',75,'arhiva','cercuri','100.0000'),('score',66,'arhiva','echipe','100.0000'),('submit_count',66,'arhiva','echipe','100.0000'),('score',66,'arhiva','comp','100.0000'),('submit_count',66,'arhiva','comp','100.0000'),('score',93,'arhiva','calatorie','100.0000'),('submit_count',93,'arhiva','calatorie','100.0000'),('score',48,'arhiva','divmul','100.0000'),('submit_count',48,'arhiva','divmul','100.0000'),('score',66,'arhiva','base3','100.0000'),('submit_count',66,'arhiva','base3','100.0000'),('score',1,'arhiva','geamuri','100.0000'),('submit_count',1,'arhiva','geamuri','100.0000'),('score',66,'arhiva','geamuri','100.0000'),('submit_count',66,'arhiva','geamuri','100.0000'),('score',961,'arhiva','geamuri','100.0000'),('submit_count',961,'arhiva','geamuri','100.0000'),('score',66,'arhiva','parcele','100.0000'),('submit_count',66,'arhiva','parcele','100.0000'),('score',48,'arhiva','jarbore','100.0000'),('submit_count',48,'arhiva','jarbore','100.0000'),('score',48,'arhiva','cercuri','100.0000'),('submit_count',48,'arhiva','cercuri','100.0000'),('score',48,'arhiva','rubarba','100.0000'),('submit_count',48,'arhiva','rubarba','100.0000'),('score',48,'arhiva','cai','100.0000'),('submit_count',48,'arhiva','cai','100.0000'),('score',48,'arhiva','zoo','100.0000'),('submit_count',48,'arhiva','zoo','100.0000'),('score',1024,'arhiva','cercuri','0.0000'),('submit_count',1024,'arhiva','cercuri','0.0000'),('score',48,'arhiva','string','100.0000'),('submit_count',48,'arhiva','string','100.0000'),('score',66,'arhiva','tri2','100.0000'),('submit_count',66,'arhiva','tri2','100.0000'),('score',48,'arhiva','poligon2','100.0000'),('submit_count',48,'arhiva','poligon2','100.0000'),('score',48,'arhiva','suma','100.0000'),('submit_count',48,'arhiva','suma','100.0000'),('score',48,'arhiva','transport','100.0000'),('submit_count',48,'arhiva','transport','100.0000'),('score',48,'arhiva','numere','100.0000'),('submit_count',48,'arhiva','numere','100.0000'),('score',18,'arhiva','geamuri','100.0000'),('submit_count',18,'arhiva','geamuri','100.0000'),('score',18,'arhiva','poligon2','100.0000'),('submit_count',18,'arhiva','poligon2','100.0000'),('score',18,'arhiva','string','100.0000'),('submit_count',18,'arhiva','string','100.0000'),('score',18,'arhiva','asmax','100.0000'),('submit_count',18,'arhiva','asmax','100.0000'),('score',18,'arhiva','granita','100.0000'),('submit_count',18,'arhiva','granita','100.0000'),('score',18,'arhiva','prefix','100.0000'),('submit_count',18,'arhiva','prefix','100.0000'),('score',18,'arhiva','color','100.0000'),('submit_count',18,'arhiva','color','100.0000'),('score',18,'arhiva','asmin','100.0000'),('submit_count',18,'arhiva','asmin','100.0000'),('score',18,'arhiva','proc','100.0000'),('submit_count',18,'arhiva','proc','100.0000'),('score',18,'arhiva','sediu','100.0000'),('submit_count',18,'arhiva','sediu','100.0000'),('score',18,'arhiva','frac','100.0000'),('submit_count',18,'arhiva','frac','100.0000'),('score',18,'arhiva','perechi','100.0000'),('submit_count',18,'arhiva','perechi','100.0000'),('score',2092,'arhiva','gard2','100.0000'),('submit_count',2092,'arhiva','gard2','100.0000'),('score',256,'arhiva','geamuri','100.0000'),('submit_count',256,'arhiva','geamuri','100.0000'),('score',48,'arhiva','muzeu','100.0000'),('submit_count',48,'arhiva','muzeu','100.0000'),('score',48,'arhiva','bile','100.0000'),('submit_count',48,'arhiva','bile','100.0000'),('score',2092,'arhiva','color','100.0000'),('submit_count',2092,'arhiva','color','100.0000'),('score',2092,'arhiva','color2','100.0000'),('submit_count',2092,'arhiva','color2','100.0000'),('score',18,'arhiva','hotel','100.0000'),('submit_count',18,'arhiva','hotel','100.0000'),('score',18,'arhiva','concurs','100.0000'),('submit_count',18,'arhiva','concurs','100.0000'),('score',18,'arhiva','homm','100.0000'),('submit_count',18,'arhiva','homm','100.0000'),('score',3369,'arhiva','fractii','100.0000'),('submit_count',3369,'arhiva','fractii','100.0000'),('score',3369,'arhiva','energii','95.0000'),('submit_count',3369,'arhiva','energii','95.0000'),('score',3369,'arhiva','transport','100.0000'),('submit_count',3369,'arhiva','transport','100.0000'),('score',18,'arhiva','perm3','100.0000'),('submit_count',18,'arhiva','perm3','100.0000'),('score',3369,'arhiva','fact','100.0000'),('submit_count',3369,'arhiva','fact','100.0000'),('score',3369,'arhiva','perechi','90.0000'),('submit_count',3369,'arhiva','perechi','90.0000'),('score',3369,'arhiva','stramosi','100.0000'),('submit_count',3369,'arhiva','stramosi','100.0000'),('score',18,'arhiva','camion','100.0000'),('submit_count',18,'arhiva','camion','100.0000'),('score',48,'arhiva','arie','100.0000'),('submit_count',48,'arhiva','arie','100.0000'),('score',3369,'arhiva','atac','50.0000'),('submit_count',3369,'arhiva','atac','50.0000'),('score',48,'arhiva','geamuri','100.0000'),('submit_count',48,'arhiva','geamuri','100.0000'),('score',3369,'arhiva','poligon2','80.0000'),('submit_count',3369,'arhiva','poligon2','80.0000'),('score',2524,'arhiva','loto','100.0000'),('submit_count',2524,'arhiva','loto','100.0000'),('score',2092,'arhiva','razboi','100.0000'),('submit_count',2092,'arhiva','razboi','100.0000'),('score',48,'arhiva','asmax','100.0000'),('submit_count',48,'arhiva','asmax','100.0000'),('score',48,'arhiva','granita','100.0000'),('submit_count',48,'arhiva','granita','100.0000'),('score',961,'arhiva','tri2','100.0000'),('submit_count',961,'arhiva','tri2','100.0000'),('score',48,'arhiva','echipe','100.0000'),('submit_count',48,'arhiva','echipe','100.0000'),('score',48,'arhiva','sediu','100.0000'),('submit_count',48,'arhiva','sediu','100.0000'),('score',18,'arhiva','triang','100.0000'),('submit_count',18,'arhiva','triang','100.0000'),('score',18,'arhiva','delay','100.0000'),('submit_count',18,'arhiva','delay','100.0000'),('score',2524,'arhiva','triunghi','100.0000'),('submit_count',2524,'arhiva','triunghi','100.0000'),('score',2092,'arhiva','evantai','100.0000'),('submit_count',2092,'arhiva','evantai','100.0000'),('score',2092,'arhiva','cerere','100.0000'),('submit_count',2092,'arhiva','cerere','100.0000'),('score',1503,'arhiva','adunare','100.0000'),('submit_count',1503,'arhiva','adunare','100.0000'),('score',3369,'arhiva','secventa','100.0000'),('submit_count',3369,'arhiva','secventa','100.0000'),('score',3369,'arhiva','adunare','100.0000'),('submit_count',3369,'arhiva','adunare','100.0000'),('score',75,'arhiva','cifra','100.0000'),('submit_count',75,'arhiva','cifra','100.0000'),('score',3369,'arhiva','bile','100.0000'),('submit_count',3369,'arhiva','bile','100.0000'),('score',3257,'arhiva','cifra','0.0000'),('submit_count',3257,'arhiva','cifra','0.0000'),('score',75,'arhiva','bile','10.0000'),('submit_count',75,'arhiva','bile','10.0000'),('score',2092,'arhiva','bool','90.0000'),('submit_count',2092,'arhiva','bool','90.0000'),('score',3369,'arhiva','cifre','40.0000'),('submit_count',3369,'arhiva','cifre','40.0000'),('score',142,'arhiva','indep','25.0000'),('submit_count',142,'arhiva','indep','25.0000'),('score',1503,'preoni61a','invers','10.0000'),('submit_count',1503,'preoni61a','invers','10.0000'),('score',1503,'preoni61b','invers','10.0000'),('submit_count',1503,'preoni61b','invers','10.0000'),('score',2986,'preoni61a','patrate2','10.0000'),('submit_count',2986,'preoni61a','patrate2','10.0000'),('score',2524,'preoni61b','invers','10.0000'),('submit_count',2524,'preoni61b','invers','10.0000'),('score',2524,'preoni61b','dreptunghiuri','0.0000'),('submit_count',2524,'preoni61b','dreptunghiuri','0.0000'),('score',2092,'preoni61c','distante','90.0000'),('submit_count',2092,'preoni61c','distante','90.0000'),('score',75,'preoni61c','distante','0.0000'),('submit_count',75,'preoni61c','distante','0.0000'),('score',142,'preoni61a','patrate2','50.0000'),('submit_count',142,'preoni61a','patrate2','50.0000'),('score',2092,'preoni61c','zebughil','30.0000'),('submit_count',2092,'preoni61c','zebughil','30.0000'),('score',2524,'preoni61b','zebughil','40.0000'),('submit_count',2524,'preoni61b','zebughil','40.0000'),('score',75,'preoni61c','balans','25.0000'),('submit_count',75,'preoni61c','balans','25.0000'),('score',2092,'preoni61c','balans','30.0000'),('submit_count',2092,'preoni61c','balans','30.0000'),('score',1503,'preoni61c','distante','0.0000'),('submit_count',1503,'preoni61c','distante','0.0000'),('score',961,'arhiva','zebughil','100.0000'),('submit_count',961,'arhiva','zebughil','100.0000'),('score',961,'arhiva','invers','100.0000'),('submit_count',961,'arhiva','invers','100.0000'),('score',961,'arhiva','reuniune','100.0000'),('submit_count',961,'arhiva','reuniune','100.0000'),('score',961,'arhiva','dreptunghiuri','100.0000'),('submit_count',961,'arhiva','dreptunghiuri','100.0000'),('score',18,'arhiva','zebughil','100.0000'),('submit_count',18,'arhiva','zebughil','100.0000'),('score',18,'arhiva','distante','100.0000'),('submit_count',18,'arhiva','distante','100.0000'),('score',18,'arhiva','patrate2','100.0000'),('submit_count',18,'arhiva','patrate2','100.0000'),('score',1,'arhiva','distante','100.0000'),('submit_count',1,'arhiva','distante','100.0000'),('score',1,'arhiva','balans','100.0000'),('submit_count',1,'arhiva','balans','100.0000'),('score',1,'arhiva','invers','100.0000'),('submit_count',1,'arhiva','invers','100.0000'),('score',1,'arhiva','reuniune','100.0000'),('submit_count',1,'arhiva','reuniune','100.0000'),('score',1,'arhiva','patrate2','100.0000'),('submit_count',1,'arhiva','patrate2','100.0000'),('score',48,'arhiva','comp','100.0000'),('submit_count',48,'arhiva','comp','100.0000'),('score',75,'arhiva','distante','0.0000'),('submit_count',75,'arhiva','distante','0.0000'),('score',2092,'arhiva','zebughil','100.0000'),('submit_count',2092,'arhiva','zebughil','100.0000'),('score',256,'arhiva','distante','100.0000'),('submit_count',256,'arhiva','distante','100.0000'),('score',256,'arhiva','zebughil','100.0000'),('submit_count',256,'arhiva','zebughil','100.0000'),('score',2092,'arhiva','distante','100.0000'),('submit_count',2092,'arhiva','distante','100.0000'),('score',48,'arhiva','prefix','100.0000'),('submit_count',48,'arhiva','prefix','100.0000'),('score',48,'arhiva','base3','100.0000'),('submit_count',48,'arhiva','base3','100.0000'),('score',66,'arhiva','invers','100.0000'),('submit_count',66,'arhiva','invers','100.0000'),('score',66,'arhiva','reuniune','100.0000'),('submit_count',66,'arhiva','reuniune','100.0000'),('score',3369,'arhiva','distante','100.0000'),('submit_count',3369,'arhiva','distante','100.0000'),('score',66,'arhiva','patrate2','100.0000'),('submit_count',66,'arhiva','patrate2','100.0000'),('score',961,'arhiva','patrate2','100.0000'),('submit_count',961,'arhiva','patrate2','100.0000'),('score',961,'arhiva','distante','100.0000'),('submit_count',961,'arhiva','distante','100.0000'),('score',256,'arhiva','secv3','100.0000'),('submit_count',256,'arhiva','secv3','100.0000'),('score',256,'arhiva','dreptunghiuri','100.0000'),('submit_count',256,'arhiva','dreptunghiuri','100.0000'),('score',961,'arhiva','balans','100.0000'),('submit_count',961,'arhiva','balans','100.0000'),('score',48,'arhiva','color2','100.0000'),('submit_count',48,'arhiva','color2','100.0000'),('score',48,'arhiva','lanterna','100.0000'),('submit_count',48,'arhiva','lanterna','100.0000'),('score',48,'arhiva','trans','100.0000'),('submit_count',48,'arhiva','trans','100.0000'),('score',256,'arhiva','balans','100.0000'),('submit_count',256,'arhiva','balans','100.0000'),('score',2092,'arhiva','granita','100.0000'),('submit_count',2092,'arhiva','granita','100.0000'),('score',2092,'arhiva','asmax','100.0000'),('submit_count',2092,'arhiva','asmax','100.0000'),('score',1,'arhiva','dreptunghiuri','100.0000'),('submit_count',1,'arhiva','dreptunghiuri','100.0000'),('score',75,'arhiva','loto','90.0000'),('submit_count',75,'arhiva','loto','90.0000'),('score',66,'arhiva','distante','100.0000'),('submit_count',66,'arhiva','distante','100.0000'),('score',48,'arhiva','tri2','100.0000'),('submit_count',48,'arhiva','tri2','100.0000'),('score',2186,'arhiva','zebughil','60.0000'),('submit_count',2186,'arhiva','zebughil','60.0000'),('score',3369,'arhiva','patrate2','100.0000'),('submit_count',3369,'arhiva','patrate2','100.0000'),('score',66,'arhiva','dreptunghiuri','100.0000'),('submit_count',66,'arhiva','dreptunghiuri','100.0000'),('score',2524,'arhiva','reuniune','100.0000'),('submit_count',2524,'arhiva','reuniune','100.0000'),('score',3369,'arhiva','reuniune','90.0000'),('submit_count',3369,'arhiva','reuniune','90.0000'),('score',66,'arhiva','zebughil','100.0000'),('submit_count',66,'arhiva','zebughil','100.0000'),('score',48,'arhiva','soc','100.0000'),('submit_count',48,'arhiva','soc','100.0000'),('score',66,'arhiva','balans','100.0000'),('submit_count',66,'arhiva','balans','100.0000'),('score',2092,'arhiva','patrate2','100.0000'),('submit_count',2092,'arhiva','patrate2','100.0000'),('score',3369,'arhiva','zebughil','10.0000'),('submit_count',3369,'arhiva','zebughil','10.0000'),('score',2092,'arhiva','sediu','100.0000'),('submit_count',2092,'arhiva','sediu','100.0000'),('score',1,'arhiva','zebughil','100.0000'),('submit_count',1,'arhiva','zebughil','100.0000'),('score',3369,'arhiva','perm2','100.0000'),('submit_count',3369,'arhiva','perm2','100.0000'),('score',961,'arhiva','harta','100.0000'),('submit_count',961,'arhiva','harta','100.0000'),('score',1,'arhiva','harta','100.0000'),('submit_count',1,'arhiva','harta','100.0000'),('score',66,'arhiva','harta','100.0000'),('submit_count',66,'arhiva','harta','100.0000'),('score',961,'arhiva','adapost','100.0000'),('submit_count',961,'arhiva','adapost','100.0000'),('score',48,'arhiva','ecu','100.0000'),('submit_count',48,'arhiva','ecu','100.0000'),('score',66,'arhiva','adapost','100.0000'),('submit_count',66,'arhiva','adapost','100.0000'),('score',2092,'arhiva','triunghi','90.0000'),('submit_count',2092,'arhiva','triunghi','90.0000'),('score',2092,'arhiva','poligon2','100.0000'),('submit_count',2092,'arhiva','poligon2','100.0000'),('score',3369,'arhiva','harta','100.0000'),('submit_count',3369,'arhiva','harta','100.0000'),('score',1,'arhiva','adapost','100.0000'),('submit_count',1,'arhiva','adapost','100.0000'),('score',66,'arhiva','robot','100.0000'),('submit_count',66,'arhiva','robot','100.0000'),('score',48,'arhiva','parcele','100.0000'),('submit_count',48,'arhiva','parcele','100.0000'),('score',18,'arhiva','harta','100.0000'),('submit_count',18,'arhiva','harta','100.0000'),('score',3369,'arhiva','tort','100.0000'),('submit_count',3369,'arhiva','tort','100.0000'),('score',961,'arhiva','sortari','100.0000'),('submit_count',961,'arhiva','sortari','100.0000'),('score',66,'arhiva','sortari','100.0000'),('submit_count',66,'arhiva','sortari','100.0000'),('score',3369,'arhiva','sortari','100.0000'),('submit_count',3369,'arhiva','sortari','100.0000'),('score',66,'arhiva','ciclu','100.0000'),('submit_count',66,'arhiva','ciclu','100.0000'),('score',2092,'arhiva','bifo','100.0000'),('submit_count',2092,'arhiva','bifo','100.0000'),('score',1,'arhiva','sortari','100.0000'),('submit_count',1,'arhiva','sortari','100.0000'),('score',18,'arhiva','sortari','100.0000'),('submit_count',18,'arhiva','sortari','100.0000'),('score',1,'arhiva','ciclu','100.0000'),('submit_count',1,'arhiva','ciclu','100.0000'),('score',66,'arhiva','Expr','100.0000'),('submit_count',66,'arhiva','Expr','100.0000'),('score',66,'arhiva','Coach','100.0000'),('submit_count',66,'arhiva','Coach','100.0000'),('score',3369,'arhiva','Coach','100.0000'),('submit_count',3369,'arhiva','Coach','100.0000'),('score',48,'arhiva','proc','100.0000'),('submit_count',48,'arhiva','proc','100.0000'),('score',18,'arhiva','ciclu','100.0000'),('submit_count',18,'arhiva','ciclu','100.0000'),('score',2092,'arhiva','Coach','100.0000'),('submit_count',2092,'arhiva','Coach','100.0000'),('score',961,'arhiva','ciclu','100.0000'),('submit_count',961,'arhiva','ciclu','100.0000'),('score',18,'arhiva','Coach','100.0000'),('submit_count',18,'arhiva','Coach','100.0000'),('score',1,'arhiva','Expr','100.0000'),('submit_count',1,'arhiva','Expr','100.0000'),('score',2092,'arhiva','lapte','100.0000'),('submit_count',2092,'arhiva','lapte','100.0000'),('score',1,'arhiva','Coach','100.0000'),('submit_count',1,'arhiva','Coach','100.0000'),('score',18,'arhiva','drumuri','100.0000'),('submit_count',18,'arhiva','drumuri','100.0000'),('score',66,'arhiva','tri','100.0000'),('submit_count',66,'arhiva','tri','100.0000'),('score',48,'arhiva','color','100.0000'),('submit_count',48,'arhiva','color','100.0000'),('score',961,'arhiva','Expr','100.0000'),('submit_count',961,'arhiva','Expr','100.0000'),('score',18,'arhiva','pal','100.0000'),('submit_count',18,'arhiva','pal','100.0000'),('score',3369,'arhiva','perm3','100.0000'),('submit_count',3369,'arhiva','perm3','100.0000'),('score',961,'arhiva','Coach','100.0000'),('submit_count',961,'arhiva','Coach','100.0000'),('score',48,'arhiva','resturi','0.0000'),('submit_count',48,'arhiva','resturi','0.0000'),('score',48,'arhiva','asmin','100.0000'),('submit_count',48,'arhiva','asmin','100.0000'),('score',18,'arhiva','ecu','100.0000'),('submit_count',18,'arhiva','ecu','100.0000'),('score',3369,'arhiva','perle','50.0000'),('submit_count',3369,'arhiva','perle','50.0000'),('score',2092,'arhiva','lanterna','100.0000'),('submit_count',2092,'arhiva','lanterna','100.0000'),('score',2092,'arhiva','trans','100.0000'),('submit_count',2092,'arhiva','trans','100.0000'),('score',2092,'arhiva','secventa','100.0000'),('submit_count',2092,'arhiva','secventa','100.0000'),('score',18,'arhiva','sistem','100.0000'),('submit_count',18,'arhiva','sistem','100.0000'),('score',961,'arhiva','insula','100.0000'),('submit_count',961,'arhiva','insula','100.0000'),('score',66,'arhiva','insula','100.0000'),('submit_count',66,'arhiva','insula','100.0000'),('score',2092,'arhiva','lacate','100.0000'),('submit_count',2092,'arhiva','lacate','100.0000'),('score',18,'arhiva','insula','100.0000'),('submit_count',18,'arhiva','insula','100.0000'),('score',2524,'arhiva','ciclu','20.0000'),('submit_count',2524,'arhiva','ciclu','20.0000'),('score',256,'arhiva','ciclu','100.0000'),('submit_count',256,'arhiva','ciclu','100.0000'),('score',3369,'arhiva','xormax','90.0000'),('submit_count',3369,'arhiva','xormax','90.0000'),('score',256,'arhiva','Coach','100.0000'),('submit_count',256,'arhiva','Coach','100.0000'),('score',18,'arhiva','reuniune','100.0000'),('submit_count',18,'arhiva','reuniune','100.0000'),('score',2524,'arhiva','poligon2','100.0000'),('submit_count',2524,'arhiva','poligon2','100.0000'),('score',961,'arhiva','base3','100.0000'),('submit_count',961,'arhiva','base3','100.0000'),('score',18,'arhiva','regine','100.0000'),('submit_count',18,'arhiva','regine','100.0000'),('score',18,'arhiva','tvshow','100.0000'),('submit_count',18,'arhiva','tvshow','100.0000'),('score',2092,'arhiva','balans','45.0000'),('submit_count',2092,'arhiva','balans','45.0000'),('score',256,'arhiva','sortari','100.0000'),('submit_count',256,'arhiva','sortari','100.0000'),('score',18,'arhiva','tri2','100.0000'),('submit_count',18,'arhiva','tri2','100.0000'),('score',18,'arhiva','trapeze','100.0000'),('submit_count',18,'arhiva','trapeze','100.0000'),('score',18,'arhiva','patrate','92.0000'),('submit_count',18,'arhiva','patrate','92.0000'),('score',48,'arhiva','doipatru','100.0000'),('submit_count',48,'arhiva','doipatru','100.0000'),('score',2092,'arhiva','sortari','100.0000'),('submit_count',2092,'arhiva','sortari','100.0000'),('score',2092,'arhiva','ferma','100.0000'),('submit_count',2092,'arhiva','ferma','100.0000'),('score',256,'arhiva','Expr','100.0000'),('submit_count',256,'arhiva','Expr','100.0000'),('score',3369,'arhiva','barbar','90.0000'),('submit_count',3369,'arhiva','barbar','90.0000'),('score',3369,'arhiva','copaci','70.0000'),('submit_count',3369,'arhiva','copaci','70.0000'),('score',2092,'arhiva','ciclu','100.0000'),('submit_count',2092,'arhiva','ciclu','100.0000'),('score',2524,'arhiva','regine','100.0000'),('submit_count',2524,'arhiva','regine','100.0000'),('score',1670,'arhiva','sume','100.0000'),('submit_count',1670,'arhiva','sume','100.0000'),('score',3369,'arhiva','calatorie','100.0000'),('submit_count',3369,'arhiva','calatorie','100.0000'),('score',3369,'arhiva','sobo','100.0000'),('submit_count',3369,'arhiva','sobo','100.0000'),('score',2092,'arhiva','gard3','100.0000'),('submit_count',2092,'arhiva','gard3','100.0000'),('score',66,'bac2005','numere','100.0000'),('submit_count',66,'bac2005','numere','100.0000'),('score',1670,'arhiva','suma','100.0000'),('submit_count',1670,'arhiva','suma','100.0000'),('score',1670,'arhiva','loto','20.0000'),('submit_count',1670,'arhiva','loto','20.0000'),('score',1,'arhiva','insula','100.0000'),('submit_count',1,'arhiva','insula','100.0000'),('score',3369,'arhiva','cai','0.0000'),('submit_count',3369,'arhiva','cai','0.0000'),('score',2986,'arhiva','fact','100.0000'),('submit_count',2986,'arhiva','fact','100.0000'),('score',2986,'arhiva','tabela','100.0000'),('submit_count',2986,'arhiva','tabela','100.0000'),('score',2986,'arhiva','fractii','100.0000'),('submit_count',2986,'arhiva','fractii','100.0000'),('score',48,'arhiva','sistem','100.0000'),('submit_count',48,'arhiva','sistem','100.0000'),('score',48,'arhiva','gard3','100.0000'),('submit_count',48,'arhiva','gard3','100.0000'),('score',2524,'arhiva','fractal','100.0000'),('submit_count',2524,'arhiva','fractal','100.0000'),('score',1670,'arhiva','divmul','100.0000'),('submit_count',1670,'arhiva','divmul','100.0000'),('score',1670,'arhiva','tabela','100.0000'),('submit_count',1670,'arhiva','tabela','100.0000'),('score',58,'arhiva','poligon2','90.0000'),('submit_count',58,'arhiva','poligon2','90.0000'),('score',58,'arhiva','sortari','100.0000'),('submit_count',58,'arhiva','sortari','100.0000'),('score',1,'arhiva','sticle','100.0000'),('submit_count',1,'arhiva','sticle','100.0000'),('score',66,'arhiva','sticle','100.0000'),('submit_count',66,'arhiva','sticle','100.0000'),('score',1,'arhiva','turneu','100.0000'),('submit_count',1,'arhiva','turneu','100.0000'),('score',1,'arhiva','superp','100.0000'),('submit_count',1,'arhiva','superp','100.0000'),('score',1,'arhiva','monezi','100.0000'),('submit_count',1,'arhiva','monezi','100.0000'),('score',1,'arhiva','numere2','100.0000'),('submit_count',1,'arhiva','numere2','100.0000'),('score',961,'arhiva','santa','100.0000'),('submit_count',961,'arhiva','santa','100.0000'),('score',1,'arhiva','ben','100.0000'),('submit_count',1,'arhiva','ben','100.0000'),('score',1,'arhiva','siruri','100.0000'),('submit_count',1,'arhiva','siruri','100.0000'),('score',18,'arhiva','sticle','100.0000'),('submit_count',18,'arhiva','sticle','100.0000'),('score',75,'arhiva','soldati','100.0000'),('submit_count',75,'arhiva','soldati','100.0000'),('score',75,'arhiva','ben','100.0000'),('submit_count',75,'arhiva','ben','100.0000'),('score',961,'arhiva','reg','100.0000'),('submit_count',961,'arhiva','reg','100.0000'),('score',961,'arhiva','sticle','100.0000'),('submit_count',961,'arhiva','sticle','100.0000'),('score',58,'arhiva','sticle','100.0000'),('submit_count',58,'arhiva','sticle','100.0000'),('score',3369,'arhiva','turneu','90.0000'),('submit_count',3369,'arhiva','turneu','90.0000'),('score',66,'arhiva','siruri','100.0000'),('submit_count',66,'arhiva','siruri','100.0000'),('score',961,'arhiva','turneu','100.0000'),('submit_count',961,'arhiva','turneu','100.0000'),('score',2524,'arhiva','sticle','100.0000'),('submit_count',2524,'arhiva','sticle','100.0000'),('score',2524,'arhiva','zapada','0.0000'),('submit_count',2524,'arhiva','zapada','0.0000'),('score',961,'arhiva','ben','100.0000'),('submit_count',961,'arhiva','ben','100.0000'),('score',961,'arhiva','monezi','100.0000'),('submit_count',961,'arhiva','monezi','100.0000'),('score',961,'arhiva','soldati','100.0000'),('submit_count',961,'arhiva','soldati','100.0000'),('score',2092,'arhiva','ben','100.0000'),('submit_count',2092,'arhiva','ben','100.0000'),('score',75,'arhiva','reg','100.0000'),('submit_count',75,'arhiva','reg','100.0000'),('score',1024,'arhiva','camion','100.0000'),('submit_count',1024,'arhiva','camion','100.0000'),('score',2524,'preoni62b','grupuri','8.0000'),('submit_count',2524,'preoni62b','grupuri','8.0000'),('score',2986,'preoni62a','zc','0.0000'),('submit_count',2986,'preoni62a','zc','0.0000'),('score',1024,'preoni62b','12perm','0.0000'),('submit_count',1024,'preoni62b','12perm','0.0000'),('score',75,'preoni62c','struti','30.0000'),('submit_count',75,'preoni62c','struti','30.0000'),('score',1024,'preoni62b','grupuri','0.0000'),('submit_count',1024,'preoni62b','grupuri','0.0000'),('score',1024,'preoni62a','grupuri','0.0000'),('submit_count',1024,'preoni62a','grupuri','0.0000'),('score',2092,'preoni62c','desc','30.0000'),('submit_count',2092,'preoni62c','desc','30.0000'),('score',2092,'preoni62c','struti','20.0000'),('submit_count',2092,'preoni62c','struti','20.0000'),('score',2524,'preoni62b','12perm','0.0000'),('submit_count',2524,'preoni62b','12perm','0.0000'),('score',3369,'arhiva','numere2','50.0000'),('submit_count',3369,'arhiva','numere2','50.0000'),('score',961,'arhiva','grupuri','100.0000'),('submit_count',961,'arhiva','grupuri','100.0000'),('score',961,'arhiva','12perm','100.0000'),('submit_count',961,'arhiva','12perm','100.0000'),('score',1,'arhiva','dame','100.0000'),('submit_count',1,'arhiva','dame','100.0000'),('score',1,'arhiva','zc','100.0000'),('submit_count',1,'arhiva','zc','100.0000'),('score',1,'arhiva','grupuri','100.0000'),('submit_count',1,'arhiva','grupuri','100.0000'),('score',1,'arhiva','12perm','100.0000'),('submit_count',1,'arhiva','12perm','100.0000'),('score',961,'arhiva','desc','100.0000'),('submit_count',961,'arhiva','desc','100.0000'),('score',1,'arhiva','desc','100.0000'),('submit_count',1,'arhiva','desc','100.0000'),('score',961,'arhiva','struti','100.0000'),('submit_count',961,'arhiva','struti','100.0000'),('score',256,'arhiva','struti','100.0000'),('submit_count',256,'arhiva','struti','100.0000'),('score',3369,'arhiva','ben','54.0000'),('submit_count',3369,'arhiva','ben','54.0000'),('score',66,'arhiva','camera','100.0000'),('submit_count',66,'arhiva','camera','100.0000'),('score',66,'arhiva','12perm','100.0000'),('submit_count',66,'arhiva','12perm','100.0000'),('score',3369,'arhiva','12perm','100.0000'),('submit_count',3369,'arhiva','12perm','100.0000'),('score',1,'arhiva','invsc','100.0000'),('submit_count',1,'arhiva','invsc','100.0000'),('score',18,'arhiva','zc','100.0000'),('submit_count',18,'arhiva','zc','100.0000'),('score',2092,'arhiva','bile','100.0000'),('submit_count',2092,'arhiva','bile','100.0000'),('score',2524,'arhiva','coins','100.0000'),('submit_count',2524,'arhiva','coins','100.0000'),('score',2092,'arhiva','invsc','100.0000'),('submit_count',2092,'arhiva','invsc','100.0000'),('score',2524,'arhiva','fractii','100.0000'),('submit_count',2524,'arhiva','fractii','100.0000'),('score',2524,'arhiva','invsc','100.0000'),('submit_count',2524,'arhiva','invsc','100.0000'),('score',3369,'arhiva','ciclu','90.0000'),('submit_count',3369,'arhiva','ciclu','90.0000'),('score',1024,'arhiva','poligon','0.0000'),('submit_count',1024,'arhiva','poligon','0.0000'),('score',1024,'arhiva','poligon2','0.0000'),('submit_count',1024,'arhiva','poligon2','0.0000'),('score',256,'arhiva','superp','100.0000'),('submit_count',256,'arhiva','superp','100.0000'),('score',256,'arhiva','monezi','100.0000'),('submit_count',256,'arhiva','monezi','100.0000'),('score',2092,'arhiva','farfurii','100.0000'),('submit_count',2092,'arhiva','farfurii','100.0000'),('score',2092,'arhiva','concurs','100.0000'),('submit_count',2092,'arhiva','concurs','100.0000'),('score',3369,'arhiva','dame','100.0000'),('submit_count',3369,'arhiva','dame','100.0000'),('score',75,'arhiva','dmg','85.0000'),('submit_count',75,'arhiva','dmg','75.0000'),('score',961,'arhiva','invsc','100.0000'),('submit_count',961,'arhiva','invsc','100.0000'),('score',3369,'arhiva','grupuri','100.0000'),('submit_count',3369,'arhiva','grupuri','100.0000'),('score',3369,'arhiva','invsc','100.0000'),('submit_count',3369,'arhiva','invsc','100.0000'),('score',2092,'arhiva','petrica','100.0000'),('submit_count',2092,'arhiva','petrica','100.0000'),('score',1024,'arhiva','perle','100.0000'),('submit_count',1024,'arhiva','perle','100.0000'),('score',2092,'arhiva','sistem','100.0000'),('submit_count',2092,'arhiva','sistem','100.0000'),('score',256,'arhiva','desc','100.0000'),('submit_count',256,'arhiva','desc','100.0000'),('score',256,'arhiva','invsc','100.0000'),('submit_count',256,'arhiva','invsc','100.0000'),('score',256,'arhiva','12perm','100.0000'),('submit_count',256,'arhiva','12perm','100.0000'),('score',66,'arhiva','invsc','100.0000'),('submit_count',66,'arhiva','invsc','100.0000'),('score',2186,'arhiva','arie','10.0000'),('submit_count',2186,'arhiva','arie','10.0000'),('score',2092,'arhiva','bombar','100.0000'),('submit_count',2092,'arhiva','bombar','100.0000'),('score',66,'arhiva','grupuri','100.0000'),('submit_count',66,'arhiva','grupuri','100.0000'),('score',961,'arhiva','siruri','100.0000'),('submit_count',961,'arhiva','siruri','100.0000'),('score',961,'arhiva','superp','100.0000'),('submit_count',961,'arhiva','superp','100.0000'),('score',3369,'arhiva','flip','100.0000'),('submit_count',3369,'arhiva','flip','100.0000'),('score',2092,'arhiva','boom','100.0000'),('submit_count',2092,'arhiva','boom','100.0000'),('score',961,'arhiva','numere2','100.0000'),('submit_count',961,'arhiva','numere2','100.0000'),('score',961,'arhiva','zapada','100.0000'),('submit_count',961,'arhiva','zapada','100.0000'),('score',961,'arhiva','dame','100.0000'),('submit_count',961,'arhiva','dame','100.0000'),('score',2524,'arhiva','transport','100.0000'),('submit_count',2524,'arhiva','transport','100.0000'),('score',2524,'arhiva','cai','100.0000'),('submit_count',2524,'arhiva','cai','100.0000'),('score',2524,'arhiva','triang','100.0000'),('submit_count',2524,'arhiva','triang','100.0000'),('score',2524,'arhiva','patrate2','100.0000'),('submit_count',2524,'arhiva','patrate2','100.0000'),('score',66,'arhiva','struti','100.0000'),('submit_count',66,'arhiva','struti','100.0000'),('score',256,'arhiva','patrate2','100.0000'),('submit_count',256,'arhiva','patrate2','100.0000'),('score',2524,'arhiva','perechi','100.0000'),('submit_count',2524,'arhiva','perechi','100.0000'),('score',2524,'arhiva','dame','100.0000'),('submit_count',2524,'arhiva','dame','100.0000'),('score',2092,'arhiva','monezi','100.0000'),('submit_count',2092,'arhiva','monezi','100.0000'),('score',256,'arhiva','ben','100.0000'),('submit_count',256,'arhiva','ben','100.0000'),('score',2524,'arhiva','zc','10.0000'),('submit_count',2524,'arhiva','zc','10.0000'),('score',2524,'arhiva','cifre','70.0000'),('submit_count',2524,'arhiva','cifre','70.0000'),('score',3369,'arhiva','secv3','70.0000'),('submit_count',3369,'arhiva','secv3','70.0000'),('score',961,'arhiva','zc','100.0000'),('submit_count',961,'arhiva','zc','100.0000'),('score',48,'arhiva','distante','100.0000'),('submit_count',48,'arhiva','distante','100.0000'),('score',48,'arhiva','zebughil','100.0000'),('submit_count',48,'arhiva','zebughil','100.0000'),('score',48,'arhiva','balans','100.0000'),('submit_count',48,'arhiva','balans','100.0000'),('score',48,'arhiva','dreptunghiuri','0.0000'),('submit_count',48,'arhiva','dreptunghiuri','0.0000'),('score',2092,'arhiva','desc','100.0000'),('submit_count',2092,'arhiva','desc','100.0000'),('score',2524,'arhiva','perm3','100.0000'),('submit_count',2524,'arhiva','perm3','100.0000'),('score',1975,'arhiva','perm3','100.0000'),('submit_count',1975,'arhiva','perm3','100.0000'),('score',3369,'arhiva','farfurii','90.0000'),('submit_count',3369,'arhiva','farfurii','90.0000'),('score',2524,'arhiva','lapte','100.0000'),('submit_count',2524,'arhiva','lapte','100.0000'),('score',2524,'arhiva','trapeze','100.0000'),('submit_count',2524,'arhiva','trapeze','100.0000'),('score',2524,'arhiva','poligon','0.0000'),('submit_count',2524,'arhiva','poligon','0.0000'),('score',2092,'arhiva','delay','100.0000'),('submit_count',2092,'arhiva','delay','100.0000'),('score',2092,'arhiva','string','100.0000'),('submit_count',2092,'arhiva','string','100.0000'),('score',2524,'arhiva','sir23','100.0000'),('submit_count',2524,'arhiva','sir23','100.0000'),('score',2092,'arhiva','party','100.0000'),('submit_count',2092,'arhiva','party','100.0000'),('score',18,'arhiva','timbre','100.0000'),('submit_count',18,'arhiva','timbre','100.0000'),('score',256,'arhiva','timbre','100.0000'),('submit_count',256,'arhiva','timbre','100.0000'),('score',2092,'arhiva','timbre','100.0000'),('submit_count',2092,'arhiva','timbre','100.0000'),('score',256,'arhiva','petsoft','90.0000'),('submit_count',256,'arhiva','petsoft','90.0000'),('score',1670,'arhiva','iepuri','0.0000'),('submit_count',1670,'arhiva','iepuri','0.0000'),('score',1670,'arhiva','stramosi','50.0000'),('submit_count',1670,'arhiva','stramosi','50.0000'),('score',2092,'arhiva','fractal','100.0000'),('submit_count',2092,'arhiva','fractal','100.0000'),('score',66,'arhiva','ben','100.0000'),('submit_count',66,'arhiva','ben','100.0000'),('score',961,'arhiva','timbre','100.0000'),('submit_count',961,'arhiva','timbre','100.0000'),('score',2092,'arhiva','atac','100.0000'),('submit_count',2092,'arhiva','atac','100.0000'),('score',1967,'arhiva','cifra','0.0000'),('submit_count',1967,'arhiva','cifra','0.0000'),('score',2092,'arhiva','coins','100.0000'),('submit_count',2092,'arhiva','coins','100.0000'),('score',3369,'arhiva','concurs','100.0000'),('submit_count',3369,'arhiva','concurs','100.0000'),('score',142,'preoni63a','nrtri','0.0000'),('submit_count',142,'preoni63a','nrtri','0.0000'),('score',142,'preoni63a','divprim','10.0000'),('submit_count',142,'preoni63a','divprim','10.0000'),('score',142,'preoni63a','subsir2','50.0000'),('submit_count',142,'preoni63a','subsir2','50.0000'),('score',2524,'preoni63b','pavare2','65.0000'),('submit_count',2524,'preoni63b','pavare2','65.0000'),('score',2524,'preoni63b','sum','10.0000'),('submit_count',2524,'preoni63b','sum','10.0000'),('score',2092,'preoni63c','subsir2','100.0000'),('submit_count',2092,'preoni63c','subsir2','100.0000'),('score',2092,'preoni63c','cowfood','22.0000'),('submit_count',2092,'preoni63c','cowfood','22.0000'),('score',2092,'preoni63c','count','20.0000'),('submit_count',2092,'preoni63c','count','20.0000'),('score',961,'arhiva','cowfood','100.0000'),('submit_count',961,'arhiva','cowfood','100.0000'),('score',961,'arhiva','divprim','100.0000'),('submit_count',961,'arhiva','divprim','100.0000'),('score',961,'arhiva','subsir2','100.0000'),('submit_count',961,'arhiva','subsir2','100.0000'),('score',66,'arhiva','sum','100.0000'),('submit_count',66,'arhiva','sum','100.0000'),('score',256,'arhiva','subsir2','100.0000'),('submit_count',256,'arhiva','subsir2','100.0000'),('score',18,'arhiva','cowfood','100.0000'),('submit_count',18,'arhiva','cowfood','100.0000'),('score',256,'arhiva','divprim','100.0000'),('submit_count',256,'arhiva','divprim','100.0000'),('score',256,'arhiva','sum','100.0000'),('submit_count',256,'arhiva','sum','100.0000'),('score',256,'arhiva','nrtri','100.0000'),('submit_count',256,'arhiva','nrtri','100.0000'),('score',961,'arhiva','sum','100.0000'),('submit_count',961,'arhiva','sum','100.0000'),('score',2092,'arhiva','subsir2','100.0000'),('submit_count',2092,'arhiva','subsir2','100.0000'),('score',66,'arhiva','count','100.0000'),('submit_count',66,'arhiva','count','100.0000'),('score',66,'arhiva','divprim','100.0000'),('submit_count',66,'arhiva','divprim','100.0000'),('score',66,'arhiva','nrtri','100.0000'),('submit_count',66,'arhiva','nrtri','100.0000'),('score',66,'arhiva','pavare2','100.0000'),('submit_count',66,'arhiva','pavare2','100.0000'),('score',2092,'arhiva','nrtri','100.0000'),('submit_count',2092,'arhiva','nrtri','100.0000'),('score',256,'arhiva','delay','100.0000'),('submit_count',256,'arhiva','delay','100.0000'),('score',256,'arhiva','pavare2','100.0000'),('submit_count',256,'arhiva','pavare2','100.0000'),('score',13,'arhiva','nrtri','85.0000'),('submit_count',13,'arhiva','nrtri','85.0000'),('score',1,'arhiva','subsir2','100.0000'),('submit_count',1,'arhiva','subsir2','100.0000'),('score',1,'arhiva','sum','100.0000'),('submit_count',1,'arhiva','sum','100.0000'),('score',1,'arhiva','nrtri','100.0000'),('submit_count',1,'arhiva','nrtri','100.0000'),('score',2092,'arhiva','sum','100.0000'),('submit_count',2092,'arhiva','sum','100.0000'),('score',1,'arhiva','pavare2','100.0000'),('submit_count',1,'arhiva','pavare2','100.0000'),('score',1,'arhiva','divprim','100.0000'),('submit_count',1,'arhiva','divprim','100.0000'),('score',1,'arhiva','cowfood','100.0000'),('submit_count',1,'arhiva','cowfood','100.0000'),('score',2092,'arhiva','divprim','100.0000'),('submit_count',2092,'arhiva','divprim','100.0000'),('score',1,'arhiva','count','100.0000'),('submit_count',1,'arhiva','count','100.0000'),('score',2092,'arhiva','grupuri','100.0000'),('submit_count',2092,'arhiva','grupuri','100.0000'),('score',1,'arhiva','timbre','100.0000'),('submit_count',1,'arhiva','timbre','100.0000'),('score',18,'arhiva','nrtri','100.0000'),('submit_count',18,'arhiva','nrtri','100.0000'),('score',18,'arhiva','count','100.0000'),('submit_count',18,'arhiva','count','100.0000'),('score',18,'arhiva','monezi','100.0000'),('submit_count',18,'arhiva','monezi','100.0000'),('score',18,'arhiva','superp','100.0000'),('submit_count',18,'arhiva','superp','100.0000'),('score',18,'arhiva','divprim','100.0000'),('submit_count',18,'arhiva','divprim','100.0000'),('score',142,'arhiva','perm','100.0000'),('submit_count',142,'arhiva','perm','100.0000'),('score',48,'arhiva','otilia','100.0000'),('submit_count',48,'arhiva','otilia','100.0000'),('score',256,'arhiva','demolish','100.0000'),('submit_count',256,'arhiva','demolish','100.0000'),('score',66,'arhiva','timbre','100.0000'),('submit_count',66,'arhiva','timbre','100.0000'),('score',66,'arhiva','subsir2','100.0000'),('submit_count',66,'arhiva','subsir2','100.0000'),('score',66,'arhiva','dame','100.0000'),('submit_count',66,'arhiva','dame','100.0000'),('score',66,'arhiva','superp','100.0000'),('submit_count',66,'arhiva','superp','100.0000'),('score',18,'arhiva','sum','100.0000'),('submit_count',18,'arhiva','sum','100.0000'),('score',3369,'arhiva','sum','100.0000'),('submit_count',3369,'arhiva','sum','100.0000'),('score',1670,'arhiva','tort','60.0000'),('submit_count',1670,'arhiva','tort','60.0000'),('score',1670,'arhiva','secv2','100.0000'),('submit_count',1670,'arhiva','secv2','100.0000'),('score',1670,'arhiva','secventa','20.0000'),('submit_count',1670,'arhiva','secventa','20.0000'),('score',66,'arhiva','desc','100.0000'),('submit_count',66,'arhiva','desc','100.0000'),('score',256,'arhiva','grupuri','100.0000'),('submit_count',256,'arhiva','grupuri','100.0000'),('score',2524,'arhiva','barbar','90.0000'),('submit_count',2524,'arhiva','barbar','90.0000'),('score',2092,'arhiva','munte','100.0000'),('submit_count',2092,'arhiva','munte','100.0000'),('score',2092,'arhiva','sobo','100.0000'),('submit_count',2092,'arhiva','sobo','100.0000'),('score',75,'arhiva','patrate','100.0000'),('submit_count',75,'arhiva','patrate','100.0000'),('score',256,'arhiva','count','100.0000'),('submit_count',256,'arhiva','count','100.0000'),('score',256,'arhiva','cowfood','100.0000'),('submit_count',256,'arhiva','cowfood','100.0000'),('score',2524,'arhiva','munte','100.0000'),('submit_count',2524,'arhiva','munte','100.0000'),('score',256,'arhiva','comp','100.0000'),('submit_count',256,'arhiva','comp','100.0000'),('score',2524,'arhiva','divprim','100.0000'),('submit_count',2524,'arhiva','divprim','100.0000'),('score',3369,'arhiva','biti','100.0000'),('submit_count',3369,'arhiva','biti','100.0000'),('score',75,'arhiva','critice','100.0000'),('submit_count',75,'arhiva','critice','100.0000'),('score',48,'arhiva','gard2','100.0000'),('submit_count',48,'arhiva','gard2','100.0000'),('score',48,'arhiva','divprim','100.0000'),('submit_count',48,'arhiva','divprim','100.0000'),('score',2092,'arhiva','harta','100.0000'),('submit_count',2092,'arhiva','harta','100.0000'),('score',48,'arhiva','gard','100.0000'),('submit_count',48,'arhiva','gard','100.0000'),('score',2524,'arhiva','sum','95.0000'),('submit_count',2524,'arhiva','sum','95.0000'),('score',66,'arhiva','soldati','100.0000'),('submit_count',66,'arhiva','soldati','100.0000'),('score',2524,'arhiva','datorii','100.0000'),('submit_count',2524,'arhiva','datorii','100.0000'),('score',2524,'arhiva','subsir2','73.0000'),('submit_count',2524,'arhiva','subsir2','73.0000'),('score',256,'arhiva','zapada','0.0000'),('submit_count',256,'arhiva','zapada','0.0000'),('score',2524,'arhiva','subsir','100.0000'),('submit_count',2524,'arhiva','subsir','100.0000'),('score',2524,'arhiva','cutii','100.0000'),('submit_count',2524,'arhiva','cutii','100.0000'),('score',256,'arhiva','numere2','100.0000'),('submit_count',256,'arhiva','numere2','100.0000'),('score',3369,'arhiva','pascal','60.0000'),('submit_count',3369,'arhiva','pascal','60.0000'),('score',256,'arhiva','drumuri','100.0000'),('submit_count',256,'arhiva','drumuri','100.0000'),('score',48,'arhiva','luna','100.0000'),('submit_count',48,'arhiva','luna','100.0000'),('score',2524,'arhiva','soldati','100.0000'),('submit_count',2524,'arhiva','soldati','100.0000'),('score',2524,'arhiva','bifo','100.0000'),('submit_count',2524,'arhiva','bifo','100.0000'),('score',2186,'arhiva','lanterna','100.0000'),('submit_count',2186,'arhiva','lanterna','100.0000'),('score',2092,'arhiva','critice','100.0000'),('submit_count',2092,'arhiva','critice','100.0000'),('score',75,'arhiva','pietre','100.0000'),('submit_count',75,'arhiva','pietre','100.0000'),('score',75,'arhiva','flip','100.0000'),('submit_count',75,'arhiva','flip','100.0000'),('score',75,'arhiva','fractii','100.0000'),('submit_count',75,'arhiva','fractii','100.0000'),('score',630,'arhiva','cifra','0.0000'),('submit_count',630,'arhiva','cifra','0.0000'),('score',1670,'arhiva','sir23','40.0000'),('submit_count',1670,'arhiva','sir23','40.0000'),('score',75,'arhiva','petrica','100.0000'),('submit_count',75,'arhiva','petrica','100.0000'),('score',75,'arhiva','tort','100.0000'),('submit_count',75,'arhiva','tort','100.0000'),('score',75,'arhiva','zero','100.0000'),('submit_count',75,'arhiva','zero','100.0000'),('score',1024,'arhiva','homm','100.0000'),('submit_count',1024,'arhiva','homm','100.0000'),('score',2524,'preoni64b','nrcuv','100.0000'),('submit_count',2524,'preoni64b','nrcuv','100.0000'),('score',75,'preoni64c','dmin','0.0000'),('submit_count',75,'preoni64c','dmin','0.0000'),('score',2986,'preoni64a','gfact','20.0000'),('submit_count',2986,'preoni64a','gfact','20.0000'),('score',2092,'preoni64c','dmin','0.0000'),('submit_count',2092,'preoni64c','dmin','0.0000'),('score',2524,'preoni64b','matrix','70.0000'),('submit_count',2524,'preoni64b','matrix','70.0000'),('score',2092,'preoni64c','calcul','20.0000'),('submit_count',2092,'preoni64c','calcul','20.0000'),('score',2524,'preoni64b','calcul','20.0000'),('submit_count',2524,'preoni64b','calcul','20.0000'),('score',75,'preoni64c','calcul','15.0000'),('submit_count',75,'preoni64c','calcul','15.0000'),('score',2092,'arhiva','dmin','100.0000'),('submit_count',2092,'arhiva','dmin','100.0000'),('score',1,'arhiva','gfact','100.0000'),('submit_count',1,'arhiva','gfact','100.0000'),('score',1,'arhiva','matrix','100.0000'),('submit_count',1,'arhiva','matrix','100.0000'),('score',1,'arhiva','nrcuv','100.0000'),('submit_count',1,'arhiva','nrcuv','100.0000'),('score',1,'arhiva','dmin','100.0000'),('submit_count',1,'arhiva','dmin','100.0000'),('score',1,'arhiva','calcul','100.0000'),('submit_count',1,'arhiva','calcul','100.0000'),('score',1,'arhiva','popandai','100.0000'),('submit_count',1,'arhiva','popandai','100.0000'),('score',2092,'arhiva','matrix','100.0000'),('submit_count',2092,'arhiva','matrix','100.0000'),('score',256,'arhiva','matrix','100.0000'),('submit_count',256,'arhiva','matrix','100.0000'),('score',256,'arhiva','nrcuv','100.0000'),('submit_count',256,'arhiva','nrcuv','100.0000'),('score',961,'arhiva','dmin','100.0000'),('submit_count',961,'arhiva','dmin','100.0000'),('score',961,'arhiva','calcul','100.0000'),('submit_count',961,'arhiva','calcul','100.0000'),('score',961,'arhiva','nrtri','100.0000'),('submit_count',961,'arhiva','nrtri','100.0000'),('score',256,'arhiva','gfact','100.0000'),('submit_count',256,'arhiva','gfact','100.0000'),('score',3369,'arhiva','matrix','100.0000'),('submit_count',3369,'arhiva','matrix','100.0000'),('score',18,'arhiva','popandai','100.0000'),('submit_count',18,'arhiva','popandai','100.0000'),('score',18,'arhiva','dmin','100.0000'),('submit_count',18,'arhiva','dmin','100.0000'),('score',18,'arhiva','nrcuv','100.0000'),('submit_count',18,'arhiva','nrcuv','100.0000'),('score',18,'arhiva','matrix','100.0000'),('submit_count',18,'arhiva','matrix','100.0000'),('score',18,'arhiva','gfact','100.0000'),('submit_count',18,'arhiva','gfact','100.0000'),('score',2092,'arhiva','nrcuv','100.0000'),('submit_count',2092,'arhiva','nrcuv','100.0000'),('score',2092,'arhiva','gfact','80.0000'),('submit_count',2092,'arhiva','gfact','80.0000'),('score',18,'arhiva','nextseq','100.0000'),('submit_count',18,'arhiva','nextseq','100.0000'),('score',2092,'arhiva','calcul','100.0000'),('submit_count',2092,'arhiva','calcul','100.0000'),('score',2092,'arhiva','nextseq','100.0000'),('submit_count',2092,'arhiva','nextseq','100.0000'),('score',2524,'arhiva','nrcuv','100.0000'),('submit_count',2524,'arhiva','nrcuv','100.0000'),('score',2524,'arhiva','gfact','100.0000'),('submit_count',2524,'arhiva','gfact','100.0000'),('score',2524,'arhiva','matrix','70.0000'),('submit_count',2524,'arhiva','matrix','70.0000'),('score',3369,'arhiva','dmin','100.0000'),('submit_count',3369,'arhiva','dmin','100.0000'),('score',961,'arhiva','matrix','100.0000'),('submit_count',961,'arhiva','matrix','100.0000'),('score',2524,'arhiva','nextseq','100.0000'),('submit_count',2524,'arhiva','nextseq','100.0000'),('score',256,'arhiva','dmin','100.0000'),('submit_count',256,'arhiva','dmin','100.0000'),('score',961,'arhiva','nrcuv','100.0000'),('submit_count',961,'arhiva','nrcuv','100.0000'),('score',2092,'arhiva','geamuri','100.0000'),('submit_count',2092,'arhiva','geamuri','100.0000'),('score',2524,'arhiva','sortari','100.0000'),('submit_count',2524,'arhiva','sortari','100.0000'),('score',2524,'arhiva','nrtri','100.0000'),('submit_count',2524,'arhiva','nrtri','100.0000'),('score',18,'arhiva','demolish','100.0000'),('submit_count',18,'arhiva','demolish','100.0000'),('score',18,'arhiva','12perm','100.0000'),('submit_count',18,'arhiva','12perm','100.0000'),('score',18,'arhiva','grupuri','100.0000'),('submit_count',18,'arhiva','grupuri','100.0000'),('score',2524,'arhiva','superp','100.0000'),('submit_count',2524,'arhiva','superp','35.0000'),('score',18,'arhiva','invsc','100.0000'),('submit_count',18,'arhiva','invsc','100.0000'),('score',2524,'arhiva','grupuri','100.0000'),('submit_count',2524,'arhiva','grupuri','100.0000'),('score',2092,'arhiva','tri2','100.0000'),('submit_count',2092,'arhiva','tri2','100.0000'),('score',961,'arhiva','nextseq','100.0000'),('submit_count',961,'arhiva','nextseq','100.0000'),('score',2092,'arhiva','luna','100.0000'),('submit_count',2092,'arhiva','luna','100.0000'),('score',142,'arhiva','nextseq','100.0000'),('submit_count',142,'arhiva','nextseq','100.0000'),('score',2092,'arhiva','regine','100.0000'),('submit_count',2092,'arhiva','regine','100.0000'),('score',142,'arhiva','gfact','15.0000'),('submit_count',142,'arhiva','gfact','15.0000'),('score',2092,'arhiva','popandai','100.0000'),('submit_count',2092,'arhiva','popandai','100.0000'),('score',2092,'arhiva','zoo','100.0000'),('submit_count',2092,'arhiva','zoo','100.0000'),('score',2092,'arhiva','sticle','100.0000'),('submit_count',2092,'arhiva','sticle','100.0000'),('score',2524,'arhiva','ben','100.0000'),('submit_count',2524,'arhiva','ben','100.0000'),('score',142,'arhiva','homm','100.0000'),('submit_count',142,'arhiva','homm','100.0000'),('score',2524,'arhiva','12perm','100.0000'),('submit_count',2524,'arhiva','12perm','100.0000'),('score',1,'arhiva','adapost2','100.0000'),('submit_count',1,'arhiva','adapost2','100.0000'),('score',2092,'arhiva','xormax','100.0000'),('submit_count',2092,'arhiva','xormax','100.0000'),('score',2092,'arhiva','petsoft','100.0000'),('submit_count',2092,'arhiva','petsoft','100.0000'),('score',1,'arhiva','mult','100.0000'),('submit_count',1,'arhiva','mult','100.0000'),('score',142,'arhiva','loto','100.0000'),('submit_count',142,'arhiva','loto','100.0000'),('score',630,'arhiva','fractal','0.0000'),('submit_count',630,'arhiva','fractal','0.0000'),('score',630,'arhiva','pascal','0.0000'),('submit_count',630,'arhiva','pascal','0.0000'),('score',66,'arhiva','adapost2','100.0000'),('submit_count',66,'arhiva','adapost2','100.0000'),('score',66,'arhiva','mult','100.0000'),('submit_count',66,'arhiva','mult','100.0000'),('score',66,'arhiva','popandai','100.0000'),('submit_count',66,'arhiva','popandai','100.0000'),('score',66,'arhiva','matrix','100.0000'),('submit_count',66,'arhiva','matrix','100.0000'),('score',66,'arhiva','nrcuv','100.0000'),('submit_count',66,'arhiva','nrcuv','100.0000'),('score',66,'arhiva','dmin','100.0000'),('submit_count',66,'arhiva','dmin','100.0000'),('score',66,'arhiva','nextseq','100.0000'),('submit_count',66,'arhiva','nextseq','100.0000'),('score',66,'arhiva','gfact','100.0000'),('submit_count',66,'arhiva','gfact','100.0000'),('score',142,'arhiva','text','100.0000'),('submit_count',142,'arhiva','text','100.0000'),('score',2524,'arhiva','mult','100.0000'),('submit_count',2524,'arhiva','mult','100.0000'),('score',66,'arhiva','calcul','100.0000'),('submit_count',66,'arhiva','calcul','100.0000'),('score',961,'arhiva','mult','100.0000'),('submit_count',961,'arhiva','mult','100.0000'),('score',142,'arhiva','expresii','100.0000'),('submit_count',142,'arhiva','expresii','100.0000'),('score',2092,'arhiva','mult','100.0000'),('submit_count',2092,'arhiva','mult','100.0000'),('score',142,'arhiva','farfurii','100.0000'),('submit_count',142,'arhiva','farfurii','100.0000'),('score',961,'arhiva','adapost2','100.0000'),('submit_count',961,'arhiva','adapost2','100.0000'),('score',256,'arhiva','mult','100.0000'),('submit_count',256,'arhiva','mult','100.0000'),('score',256,'arhiva','harta','100.0000'),('submit_count',256,'arhiva','harta','100.0000'),('score',961,'arhiva','gfact','100.0000'),('submit_count',961,'arhiva','gfact','100.0000'),('score',48,'arhiva','seti','100.0000'),('submit_count',48,'arhiva','seti','100.0000'),('score',48,'arhiva','banana','100.0000'),('submit_count',48,'arhiva','banana','100.0000'),('score',48,'arhiva','eqs','100.0000'),('submit_count',48,'arhiva','eqs','100.0000'),('score',48,'arhiva','sumdiv','100.0000'),('submit_count',48,'arhiva','sumdiv','100.0000'),('score',48,'arhiva','sortnet','100.0000'),('submit_count',48,'arhiva','sortnet','100.0000'),('score',48,'arhiva','telegraf','100.0000'),('submit_count',48,'arhiva','telegraf','100.0000'),('score',48,'arhiva','substr','100.0000'),('submit_count',48,'arhiva','substr','100.0000'),('score',48,'arhiva','trib','100.0000'),('submit_count',48,'arhiva','trib','100.0000'),('score',48,'arhiva','euro','100.0000'),('submit_count',48,'arhiva','euro','100.0000'),('score',48,'arhiva','invsort','100.0000'),('submit_count',48,'arhiva','invsort','100.0000'),('score',2092,'arhiva','banana','100.0000'),('submit_count',2092,'arhiva','banana','100.0000'),('score',2092,'arhiva','eqs','100.0000'),('submit_count',2092,'arhiva','eqs','100.0000'),('score',256,'arhiva','eqs','100.0000'),('submit_count',256,'arhiva','eqs','100.0000'),('score',66,'arhiva','invsort','100.0000'),('submit_count',66,'arhiva','invsort','100.0000'),('score',1,'arhiva','substr','100.0000'),('submit_count',1,'arhiva','substr','100.0000'),('score',1,'arhiva','euro','100.0000'),('submit_count',1,'arhiva','euro','100.0000'),('score',1,'arhiva','invsort','100.0000'),('submit_count',1,'arhiva','invsort','100.0000'),('score',1,'arhiva','eqs','100.0000'),('submit_count',1,'arhiva','eqs','100.0000'),('score',48,'arhiva','adapost','100.0000'),('submit_count',48,'arhiva','adapost','100.0000'),('score',256,'arhiva','banana','100.0000'),('submit_count',256,'arhiva','banana','100.0000'),('score',256,'arhiva','sumdiv','80.0000'),('submit_count',256,'arhiva','sumdiv','80.0000'),('score',18,'arhiva','mult','100.0000'),('submit_count',18,'arhiva','mult','100.0000'),('score',48,'arhiva','caraibe','100.0000'),('submit_count',48,'arhiva','caraibe','100.0000'),('score',18,'arhiva','adapost2','100.0000'),('submit_count',18,'arhiva','adapost2','100.0000'),('score',18,'arhiva','banana','100.0000'),('submit_count',18,'arhiva','banana','100.0000'),('score',18,'arhiva','substr','100.0000'),('submit_count',18,'arhiva','substr','100.0000'),('score',18,'arhiva','eqs','100.0000'),('submit_count',18,'arhiva','eqs','100.0000'),('score',2524,'arhiva','calatorie','100.0000'),('submit_count',2524,'arhiva','calatorie','100.0000'),('score',2524,'arhiva','banana','20.0000'),('submit_count',2524,'arhiva','banana','20.0000'),('score',2524,'arhiva','distante','100.0000'),('submit_count',2524,'arhiva','distante','100.0000'),('score',256,'arhiva','invsort','100.0000'),('submit_count',256,'arhiva','invsort','100.0000'),('score',256,'arhiva','adapost2','100.0000'),('submit_count',256,'arhiva','adapost2','100.0000'),('score',2092,'arhiva','sumdiv','100.0000'),('submit_count',2092,'arhiva','sumdiv','100.0000'),('score',3369,'arhiva','sortnet','80.0000'),('submit_count',3369,'arhiva','sortnet','80.0000'),('score',2092,'arhiva','seti','100.0000'),('submit_count',2092,'arhiva','seti','100.0000'),('score',1,'arhiva','caraibe','100.0000'),('submit_count',1,'arhiva','caraibe','100.0000'),('score',1,'arhiva','sumdiv','100.0000'),('submit_count',1,'arhiva','sumdiv','100.0000'),('score',2524,'arhiva','eqs','100.0000'),('submit_count',2524,'arhiva','eqs','100.0000'),('score',1,'arhiva','banana','100.0000'),('submit_count',1,'arhiva','banana','100.0000'),('score',1,'arhiva','seti','100.0000'),('submit_count',1,'arhiva','seti','100.0000'),('score',2092,'arhiva','drumuri','100.0000'),('submit_count',2092,'arhiva','drumuri','100.0000'),('score',1,'arhiva','nextseq','100.0000'),('submit_count',1,'arhiva','nextseq','100.0000'),('score',961,'arhiva','sumdiv','100.0000'),('submit_count',961,'arhiva','sumdiv','100.0000'),('score',2524,'arhiva','pavare','100.0000'),('submit_count',2524,'arhiva','pavare','100.0000'),('score',2524,'arhiva','bile','100.0000'),('submit_count',2524,'arhiva','bile','100.0000'),('score',66,'arhiva','turneu','100.0000'),('submit_count',66,'arhiva','turneu','100.0000'),('score',1,'arhiva','struti','100.0000'),('submit_count',1,'arhiva','struti','100.0000'),('score',66,'arhiva','demolish','100.0000'),('submit_count',66,'arhiva','demolish','100.0000'),('score',3369,'arhiva','banana','10.0000'),('submit_count',3369,'arhiva','banana','10.0000'),('score',3369,'arhiva','gard','0.0000'),('submit_count',3369,'arhiva','gard','0.0000'),('score',2092,'arhiva','traseu','100.0000'),('submit_count',2092,'arhiva','traseu','100.0000'),('score',1,'arhiva','zapada','100.0000'),('submit_count',1,'arhiva','zapada','100.0000'),('score',1,'arhiva','dmg','100.0000'),('submit_count',1,'arhiva','dmg','100.0000'),('score',2092,'arhiva','arie','100.0000'),('submit_count',2092,'arhiva','arie','100.0000'),('score',2092,'arhiva','expresii','100.0000'),('submit_count',2092,'arhiva','expresii','100.0000'),('score',1,'arhiva','soldati','100.0000'),('submit_count',1,'arhiva','soldati','100.0000'),('score',142,'arhiva','subsir','100.0000'),('submit_count',142,'arhiva','subsir','100.0000'),('score',1142,'arhiva','adapost2','10.0000'),('submit_count',1142,'arhiva','adapost2','10.0000'),('score',961,'arhiva','caraibe','100.0000'),('submit_count',961,'arhiva','caraibe','100.0000'),('score',4115,'arhiva','gfact','10.0000'),('submit_count',4115,'arhiva','gfact','10.0000'),('score',4115,'arhiva','adunare','100.0000'),('submit_count',4115,'arhiva','adunare','100.0000'),('score',4115,'arhiva','cmmdc','100.0000'),('submit_count',4115,'arhiva','cmmdc','100.0000'),('score',4115,'arhiva','flip','20.0000'),('submit_count',4115,'arhiva','flip','20.0000'),('score',4115,'arhiva','fractii','0.0000'),('submit_count',4115,'arhiva','fractii','0.0000'),('score',4115,'arhiva','perm','10.0000'),('submit_count',4115,'arhiva','perm','10.0000'),('score',2092,'arhiva','cai','100.0000'),('submit_count',2092,'arhiva','cai','100.0000'),('score',4115,'arhiva','fact','5.0000'),('submit_count',4115,'arhiva','fact','5.0000'),('score',2092,'arhiva','cifre','100.0000'),('submit_count',2092,'arhiva','cifre','80.0000'),('score',2524,'arhiva','turneu','90.0000'),('submit_count',2524,'arhiva','turneu','90.0000'),('score',2524,'arhiva','dmin','0.0000'),('submit_count',2524,'arhiva','dmin','0.0000'),('score',66,'arhiva','reg','100.0000'),('submit_count',66,'arhiva','reg','100.0000'),('score',3369,'arhiva','nextseq','85.0000'),('submit_count',3369,'arhiva','nextseq','85.0000'),('score',2524,'arhiva','palind','100.0000'),('submit_count',2524,'arhiva','palind','100.0000'),('score',66,'arhiva','supersf','100.0000'),('submit_count',66,'arhiva','supersf','100.0000'),('score',1975,'arhiva','sumdiv','80.0000'),('submit_count',1975,'arhiva','sumdiv','80.0000'),('score',3369,'arhiva','numere','20.0000'),('submit_count',3369,'arhiva','numere','20.0000'),('score',256,'arhiva','reuniune','100.0000'),('submit_count',256,'arhiva','reuniune','100.0000'),('score',48,'arhiva','farey','100.0000'),('submit_count',48,'arhiva','farey','100.0000'),('score',256,'arhiva','farey','100.0000'),('submit_count',256,'arhiva','farey','100.0000'),('score',1,'arhiva','farey','100.0000'),('submit_count',1,'arhiva','farey','100.0000'),('score',66,'arhiva','dmg','100.0000'),('submit_count',66,'arhiva','dmg','100.0000'),('score',2524,'arhiva','pavare2','55.0000'),('submit_count',2524,'arhiva','pavare2','55.0000'),('score',66,'arhiva','zapada','100.0000'),('submit_count',66,'arhiva','zapada','100.0000'),('score',2524,'arhiva','sumdiv','50.0000'),('submit_count',2524,'arhiva','sumdiv','50.0000'),('score',66,'arhiva','monezi','100.0000'),('submit_count',66,'arhiva','monezi','100.0000'),('score',2092,'arhiva','perechi','100.0000'),('submit_count',2092,'arhiva','perechi','100.0000'),('score',2524,'arhiva','iepuri','100.0000'),('submit_count',2524,'arhiva','iepuri','100.0000'),('score',66,'arhiva','numere2','100.0000'),('submit_count',66,'arhiva','numere2','100.0000'),('score',66,'arhiva','sumdiv','100.0000'),('submit_count',66,'arhiva','sumdiv','100.0000'),('score',66,'arhiva','eqs','100.0000'),('submit_count',66,'arhiva','eqs','100.0000'),('score',66,'arhiva','banana','100.0000'),('submit_count',66,'arhiva','banana','100.0000'),('score',66,'arhiva','sortnet','100.0000'),('submit_count',66,'arhiva','sortnet','100.0000'),('score',66,'arhiva','substr','100.0000'),('submit_count',66,'arhiva','substr','100.0000'),('score',66,'arhiva','euro','100.0000'),('submit_count',66,'arhiva','euro','100.0000'),('score',4159,'arhiva','adunare','100.0000'),('submit_count',4159,'arhiva','adunare','100.0000'),('score',4159,'arhiva','cmmdc','100.0000'),('submit_count',4159,'arhiva','cmmdc','100.0000'),('score',4159,'arhiva','flip','100.0000'),('submit_count',4159,'arhiva','flip','100.0000'),('score',3369,'arhiva','pietre','100.0000'),('submit_count',3369,'arhiva','pietre','100.0000'),('score',961,'arhiva','sortnet','100.0000'),('submit_count',961,'arhiva','sortnet','100.0000'),('score',4159,'arhiva','fractii','100.0000'),('submit_count',4159,'arhiva','fractii','100.0000'),('score',961,'arhiva','substr','100.0000'),('submit_count',961,'arhiva','substr','100.0000'),('score',961,'arhiva','euro','100.0000'),('submit_count',961,'arhiva','euro','100.0000'),('score',961,'arhiva','banana','100.0000'),('submit_count',961,'arhiva','banana','100.0000'),('score',4159,'arhiva','biti','100.0000'),('submit_count',4159,'arhiva','biti','100.0000'),('score',3369,'arhiva','petrica','100.0000'),('submit_count',3369,'arhiva','petrica','100.0000'),('score',4159,'arhiva','geamuri','100.0000'),('submit_count',4159,'arhiva','geamuri','100.0000'),('score',2092,'arhiva','asmin','100.0000'),('submit_count',2092,'arhiva','asmin','100.0000'),('score',4159,'arhiva','mult','95.0000'),('submit_count',4159,'arhiva','mult','95.0000'),('score',1024,'arhiva','luna','5.0000'),('submit_count',1024,'arhiva','luna','5.0000'),('score',256,'arhiva','concert','100.0000'),('submit_count',256,'arhiva','concert','100.0000'),('score',256,'arhiva','asmin','100.0000'),('submit_count',256,'arhiva','asmin','100.0000'),('score',961,'arhiva','eqs','100.0000'),('submit_count',961,'arhiva','eqs','100.0000'),('score',256,'arhiva','resturi','100.0000'),('submit_count',256,'arhiva','resturi','100.0000'),('score',4159,'arhiva','fact','100.0000'),('submit_count',4159,'arhiva','fact','100.0000'),('score',4159,'arhiva','cifra','100.0000'),('submit_count',4159,'arhiva','cifra','100.0000'),('score',4159,'arhiva','datorii','100.0000'),('submit_count',4159,'arhiva','datorii','100.0000'),('score',4159,'arhiva','tabela','100.0000'),('submit_count',4159,'arhiva','tabela','100.0000'),('score',4159,'arhiva','stramosi','100.0000'),('submit_count',4159,'arhiva','stramosi','100.0000'),('score',256,'arhiva','custi','100.0000'),('submit_count',256,'arhiva','custi','100.0000'),('score',3369,'arhiva','custi','30.0000'),('submit_count',3369,'arhiva','custi','30.0000'),('score',18,'arhiva','ben','100.0000'),('submit_count',18,'arhiva','ben','100.0000'),('score',4159,'arhiva','custi','100.0000'),('submit_count',4159,'arhiva','custi','100.0000'),('score',4197,'arhiva','adunare','0.0000'),('submit_count',4197,'arhiva','adunare','0.0000'),('score',4197,'arhiva','cmmdc','100.0000'),('submit_count',4197,'arhiva','cmmdc','100.0000'),('score',18,'arhiva','semne','100.0000'),('submit_count',18,'arhiva','semne','100.0000'),('score',2092,'arhiva','custi','100.0000'),('submit_count',2092,'arhiva','custi','100.0000'),('score',18,'arhiva','custi','100.0000'),('submit_count',18,'arhiva','custi','100.0000'),('score',4197,'arhiva','fact','10.0000'),('submit_count',4197,'arhiva','fact','10.0000'),('score',2524,'arhiva','custi','100.0000'),('submit_count',2524,'arhiva','custi','100.0000'),('score',2092,'arhiva','superp','100.0000'),('submit_count',2092,'arhiva','superp','100.0000'),('score',66,'arhiva','custi','100.0000'),('submit_count',66,'arhiva','custi','100.0000'),('score',142,'arhiva','custi','100.0000'),('submit_count',142,'arhiva','custi','100.0000'),('score',2092,'arhiva','hotel','80.0000'),('submit_count',2092,'arhiva','hotel','80.0000'),('score',256,'arhiva','ecu','100.0000'),('submit_count',256,'arhiva','ecu','100.0000'),('score',2092,'arhiva','farey','100.0000'),('submit_count',2092,'arhiva','farey','100.0000'),('score',142,'arhiva','seti','30.0000'),('submit_count',142,'arhiva','seti','30.0000'),('score',4159,'arhiva','nrcuv','100.0000'),('submit_count',4159,'arhiva','nrcuv','100.0000'),('score',4159,'arhiva','cai','0.0000'),('submit_count',4159,'arhiva','cai','0.0000'),('score',4159,'arhiva','frac','100.0000'),('submit_count',4159,'arhiva','frac','100.0000'),('score',4159,'arhiva','pietre','100.0000'),('submit_count',4159,'arhiva','pietre','100.0000'),('score',4159,'arhiva','grupuri','100.0000'),('submit_count',4159,'arhiva','grupuri','100.0000'),('score',75,'arhiva','prim','100.0000'),('submit_count',75,'arhiva','prim','100.0000'),('score',75,'arhiva','munte','100.0000'),('submit_count',75,'arhiva','munte','100.0000'),('score',75,'arhiva','traseu','60.0000'),('submit_count',75,'arhiva','traseu','60.0000'),('score',2092,'arhiva','semne','100.0000'),('submit_count',2092,'arhiva','semne','100.0000'),('score',18,'arhiva','graf','100.0000'),('submit_count',18,'arhiva','graf','100.0000'),('score',2524,'preoni65b','divk','100.0000'),('submit_count',2524,'preoni65b','divk','100.0000'),('score',2524,'preoni65b','robotei','10.0000'),('submit_count',2524,'preoni65b','robotei','10.0000'),('score',2524,'preoni65b','iv','55.0000'),('submit_count',2524,'preoni65b','iv','55.0000'),('score',75,'preoni65c','pscnv','80.0000'),('submit_count',75,'preoni65c','pscnv','80.0000'),('score',75,'preoni65c','arbore','50.0000'),('submit_count',75,'preoni65c','arbore','50.0000'),('score',142,'preoni65a','lupu','12.0000'),('submit_count',142,'preoni65a','lupu','12.0000'),('score',2092,'preoni65c','pscnv','90.0000'),('submit_count',2092,'preoni65c','pscnv','90.0000'),('score',2092,'preoni65c','arbore','0.0000'),('submit_count',2092,'preoni65c','arbore','0.0000'),('score',142,'preoni65a','divk','0.0000'),('submit_count',142,'preoni65a','divk','0.0000'),('score',75,'preoni65c','pedefe','5.0000'),('submit_count',75,'preoni65c','pedefe','5.0000'),('score',18,'arhiva','divk','100.0000'),('submit_count',18,'arhiva','divk','100.0000'),('score',18,'arhiva','lupu','100.0000'),('submit_count',18,'arhiva','lupu','100.0000'),('score',18,'arhiva','iv','100.0000'),('submit_count',18,'arhiva','iv','100.0000'),('score',2092,'arhiva','pscnv','100.0000'),('submit_count',2092,'arhiva','pscnv','100.0000'),('score',2092,'arhiva','arbore','100.0000'),('submit_count',2092,'arhiva','arbore','100.0000'),('score',18,'arhiva','pscnv','100.0000'),('submit_count',18,'arhiva','pscnv','100.0000'),('score',2092,'arhiva','adn','100.0000'),('submit_count',2092,'arhiva','adn','100.0000'),('score',48,'arhiva','arbore','100.0000'),('submit_count',48,'arhiva','arbore','100.0000'),('score',48,'arhiva','pedefe','100.0000'),('submit_count',48,'arhiva','pedefe','100.0000'),('score',18,'arhiva','euro','100.0000'),('submit_count',18,'arhiva','euro','100.0000'),('score',18,'arhiva','sumdiv','100.0000'),('submit_count',18,'arhiva','sumdiv','100.0000'),('score',2092,'arhiva','divk','100.0000'),('submit_count',2092,'arhiva','divk','100.0000'),('score',66,'arhiva','overlap','100.0000'),('submit_count',66,'arhiva','overlap','100.0000'),('score',961,'arhiva','lupu','100.0000'),('submit_count',961,'arhiva','lupu','100.0000'),('score',256,'arhiva','divk','100.0000'),('submit_count',256,'arhiva','divk','100.0000'),('score',66,'arhiva','divk','100.0000'),('submit_count',66,'arhiva','divk','100.0000'),('score',66,'arhiva','arbore','100.0000'),('submit_count',66,'arhiva','arbore','100.0000'),('score',66,'arhiva','lupu','100.0000'),('submit_count',66,'arhiva','lupu','100.0000'),('score',66,'arhiva','robotei','100.0000'),('submit_count',66,'arhiva','robotei','100.0000'),('score',66,'arhiva','graf','100.0000'),('submit_count',66,'arhiva','graf','100.0000'),('score',256,'arhiva','graf','100.0000'),('submit_count',256,'arhiva','graf','100.0000'),('score',66,'arhiva','pscnv','100.0000'),('submit_count',66,'arhiva','pscnv','100.0000'),('score',2524,'arhiva','divk','100.0000'),('submit_count',2524,'arhiva','divk','100.0000'),('score',75,'arhiva','pscnv','90.0000'),('submit_count',75,'arhiva','pscnv','90.0000'),('score',2524,'arhiva','luna','40.0000'),('submit_count',2524,'arhiva','luna','40.0000'),('score',256,'arhiva','substr','100.0000'),('submit_count',256,'arhiva','substr','100.0000'),('score',1,'arhiva','graf','100.0000'),('submit_count',1,'arhiva','graf','100.0000'),('score',1,'arhiva','pedefe','100.0000'),('submit_count',1,'arhiva','pedefe','100.0000'),('score',1,'arhiva','custi','100.0000'),('submit_count',1,'arhiva','custi','100.0000'),('score',961,'arhiva','divk','100.0000'),('submit_count',961,'arhiva','divk','100.0000'),('score',1,'arhiva','semne','100.0000'),('submit_count',1,'arhiva','semne','100.0000'),('score',961,'arhiva','overlap','100.0000'),('submit_count',961,'arhiva','overlap','100.0000'),('score',961,'arhiva','iv','100.0000'),('submit_count',961,'arhiva','iv','100.0000'),('score',256,'arhiva','pscnv','100.0000'),('submit_count',256,'arhiva','pscnv','100.0000'),('score',1,'arhiva','divk','100.0000'),('submit_count',1,'arhiva','divk','100.0000'),('score',75,'arhiva','divk','100.0000'),('submit_count',75,'arhiva','divk','100.0000'),('score',1,'arhiva','lupu','100.0000'),('submit_count',1,'arhiva','lupu','100.0000'),('score',66,'arhiva','cercuri2','100.0000'),('submit_count',66,'arhiva','cercuri2','100.0000'),('score',2092,'arhiva','pedefe','20.0000'),('submit_count',2092,'arhiva','pedefe','20.0000'),('score',2092,'arhiva','sir','100.0000'),('submit_count',2092,'arhiva','sir','100.0000'),('score',142,'arhiva','tabela','100.0000'),('submit_count',142,'arhiva','tabela','100.0000'),('score',2092,'arhiva','lupu','100.0000'),('submit_count',2092,'arhiva','lupu','100.0000'),('score',66,'arhiva','sir','100.0000'),('submit_count',66,'arhiva','sir','100.0000'),('score',256,'arhiva','sir','100.0000'),('submit_count',256,'arhiva','sir','100.0000'),('score',2092,'arhiva','cercuri2','100.0000'),('submit_count',2092,'arhiva','cercuri2','100.0000'),('score',1,'arhiva','overlap','100.0000'),('submit_count',1,'arhiva','overlap','100.0000'),('score',961,'arhiva','camera','100.0000'),('submit_count',961,'arhiva','camera','100.0000'),('score',1,'arhiva','cercuri2','100.0000'),('submit_count',1,'arhiva','cercuri2','100.0000'),('score',1,'arhiva','sir','100.0000'),('submit_count',1,'arhiva','sir','100.0000'),('score',2524,'moisil3','subsiruri','100.0000'),('submit_count',2524,'moisil3','subsiruri','100.0000'),('score',2524,'moisil3','numar','100.0000'),('submit_count',2524,'moisil3','numar','100.0000'),('score',75,'moisil4','z','100.0000'),('submit_count',75,'moisil4','z','100.0000'),('score',142,'moisil2','jocul','100.0000'),('submit_count',142,'moisil2','jocul','100.0000'),('score',2986,'moisil2','jocul','70.0000'),('submit_count',2986,'moisil2','jocul','70.0000'),('score',1024,'moisil3','subsiruri','80.0000'),('submit_count',1024,'moisil3','subsiruri','80.0000'),('score',142,'moisil2','figuri','90.0000'),('submit_count',142,'moisil2','figuri','90.0000'),('score',2092,'moisil4','domino','75.0000'),('submit_count',2092,'moisil4','domino','75.0000'),('score',2092,'moisil4','popandai2','0.0000'),('submit_count',2092,'moisil4','popandai2','0.0000'),('score',2092,'moisil4','z','100.0000'),('submit_count',2092,'moisil4','z','100.0000'),('score',75,'moisil4','domino','80.0000'),('submit_count',75,'moisil4','domino','80.0000'),('score',2524,'arhiva','lupu','100.0000'),('submit_count',2524,'arhiva','lupu','60.0000'),('score',2524,'arhiva','subsiruri','100.0000'),('submit_count',2524,'arhiva','subsiruri','100.0000'),('score',2524,'arhiva','numar','100.0000'),('submit_count',2524,'arhiva','numar','100.0000'),('score',1,'arhiva','minim','100.0000'),('submit_count',1,'arhiva','minim','100.0000'),('score',961,'arhiva','z','100.0000'),('submit_count',961,'arhiva','z','100.0000'),('score',1,'arhiva','spirala','100.0000'),('submit_count',1,'arhiva','spirala','100.0000'),('score',1,'arhiva','figuri','100.0000'),('submit_count',1,'arhiva','figuri','100.0000'),('score',58,'arhiva','minim','100.0000'),('submit_count',58,'arhiva','minim','100.0000'),('score',58,'arhiva','spirala','100.0000'),('submit_count',58,'arhiva','spirala','100.0000'),('score',58,'arhiva','figuri','90.0000'),('submit_count',58,'arhiva','figuri','90.0000'),('score',58,'arhiva','jocul','0.0000'),('submit_count',58,'arhiva','jocul','0.0000'),('score',58,'arhiva','numar','100.0000'),('submit_count',58,'arhiva','numar','100.0000'),('score',58,'arhiva','popandai2','90.0000'),('submit_count',58,'arhiva','popandai2','90.0000'),('score',58,'arhiva','z','100.0000'),('submit_count',58,'arhiva','z','100.0000'),('score',66,'arhiva','minim','100.0000'),('submit_count',66,'arhiva','minim','100.0000'),('score',66,'arhiva','spirala','100.0000'),('submit_count',66,'arhiva','spirala','100.0000'),('score',66,'arhiva','jocul','100.0000'),('submit_count',66,'arhiva','jocul','100.0000'),('score',66,'arhiva','subsiruri','100.0000'),('submit_count',66,'arhiva','subsiruri','100.0000'),('score',66,'arhiva','popandai2','100.0000'),('submit_count',66,'arhiva','popandai2','100.0000'),('score',4318,'arhiva','numar','50.0000'),('submit_count',4318,'arhiva','numar','50.0000'),('score',2524,'arhiva','spirala','100.0000'),('submit_count',2524,'arhiva','spirala','100.0000'),('score',2524,'arhiva','minim','80.0000'),('submit_count',2524,'arhiva','minim','80.0000'),('score',961,'arhiva','minim','100.0000'),('submit_count',961,'arhiva','minim','100.0000'),('score',961,'arhiva','spirala','100.0000'),('submit_count',961,'arhiva','spirala','100.0000'),('score',2092,'arhiva','popandai2','100.0000'),('submit_count',2092,'arhiva','popandai2','100.0000'),('score',2524,'arhiva','z','100.0000'),('submit_count',2524,'arhiva','z','100.0000'),('score',961,'arhiva','subsiruri','100.0000'),('submit_count',961,'arhiva','subsiruri','100.0000'),('score',1024,'arhiva','subsiruri','100.0000'),('submit_count',1024,'arhiva','subsiruri','100.0000'),('score',961,'arhiva','numar','100.0000'),('submit_count',961,'arhiva','numar','100.0000'),('score',48,'arhiva','domino','100.0000'),('submit_count',48,'arhiva','domino','100.0000'),('score',48,'arhiva','popandai2','100.0000'),('submit_count',48,'arhiva','popandai2','100.0000'),('score',48,'arhiva','z','100.0000'),('submit_count',48,'arhiva','z','100.0000'),('score',75,'arhiva','hotel','10.0000'),('submit_count',75,'arhiva','hotel','10.0000'),('score',961,'arhiva','jocul','100.0000'),('submit_count',961,'arhiva','jocul','100.0000'),('score',48,'arhiva','Expr','100.0000'),('submit_count',48,'arhiva','Expr','100.0000'),('score',1,'arhiva','jocul','100.0000'),('submit_count',1,'arhiva','jocul','100.0000'),('score',1,'arhiva','subsiruri','100.0000'),('submit_count',1,'arhiva','subsiruri','100.0000'),('score',961,'arhiva','figuri','100.0000'),('submit_count',961,'arhiva','figuri','100.0000'),('score',961,'arhiva','custi','100.0000'),('submit_count',961,'arhiva','custi','100.0000'),('score',256,'arhiva','subsiruri','100.0000'),('submit_count',256,'arhiva','subsiruri','100.0000'),('score',256,'arhiva','numar','100.0000'),('submit_count',256,'arhiva','numar','100.0000'),('score',256,'arhiva','z','100.0000'),('submit_count',256,'arhiva','z','100.0000'),('score',2092,'arhiva','numar','100.0000'),('submit_count',2092,'arhiva','numar','100.0000'),('score',18,'arhiva','popandai2','100.0000'),('submit_count',18,'arhiva','popandai2','100.0000'),('score',18,'arhiva','z','100.0000'),('submit_count',18,'arhiva','z','100.0000'),('score',2092,'arhiva','subsiruri','100.0000'),('submit_count',2092,'arhiva','subsiruri','100.0000'),('score',961,'arhiva','paralelograme','100.0000'),('submit_count',961,'arhiva','paralelograme','100.0000'),('score',48,'arhiva','ciclu','100.0000'),('submit_count',48,'arhiva','ciclu','100.0000'),('score',2524,'arhiva','numere2','15.0000'),('submit_count',2524,'arhiva','numere2','15.0000'),('score',961,'arhiva','sequencequery','100.0000'),('submit_count',961,'arhiva','sequencequery','100.0000'),('score',2092,'arhiva','jocul','100.0000'),('submit_count',2092,'arhiva','jocul','100.0000'),('score',66,'arhiva','sequencequery','100.0000'),('submit_count',66,'arhiva','sequencequery','100.0000'),('score',961,'arhiva','graf','100.0000'),('submit_count',961,'arhiva','graf','100.0000'),('score',961,'arhiva','demolish','100.0000'),('submit_count',961,'arhiva','demolish','100.0000'),('score',1,'arhiva','paralelograme','100.0000'),('submit_count',1,'arhiva','paralelograme','100.0000'),('score',1,'arhiva','sequencequery','100.0000'),('submit_count',1,'arhiva','sequencequery','100.0000'),('score',1,'arhiva','biti2','100.0000'),('submit_count',1,'arhiva','biti2','100.0000'),('score',1,'arhiva','numar','100.0000'),('submit_count',1,'arhiva','numar','100.0000'),('score',1,'arhiva','popandai2','100.0000'),('submit_count',1,'arhiva','popandai2','100.0000'),('score',18,'arhiva','paralelograme','100.0000'),('submit_count',18,'arhiva','paralelograme','100.0000'),('score',1,'arhiva','z','100.0000'),('submit_count',1,'arhiva','z','100.0000'),('score',1,'arhiva','domino','100.0000'),('submit_count',1,'arhiva','domino','100.0000'),('score',2524,'arhiva','biti2','100.0000'),('submit_count',2524,'arhiva','biti2','100.0000'),('score',256,'arhiva','biti2','100.0000'),('submit_count',256,'arhiva','biti2','100.0000'),('score',66,'arhiva','z','100.0000'),('submit_count',66,'arhiva','z','100.0000'),('score',66,'arhiva','biti2','100.0000'),('submit_count',66,'arhiva','biti2','100.0000'),('score',66,'arhiva','paralelograme','100.0000'),('submit_count',66,'arhiva','paralelograme','100.0000'),('score',66,'arhiva','domino','100.0000'),('submit_count',66,'arhiva','domino','100.0000'),('score',1,'arhiva','iv','100.0000'),('submit_count',1,'arhiva','iv','100.0000'),('score',4159,'arhiva','subsiruri','70.0000'),('submit_count',4159,'arhiva','subsiruri','70.0000'),('score',961,'arhiva','aladdin','65.0000'),('submit_count',961,'arhiva','aladdin','65.0000'),('score',58,'arhiva','aladdin','100.0000'),('submit_count',58,'arhiva','aladdin','100.0000'),('score',961,'arhiva','srevni','100.0000'),('submit_count',961,'arhiva','srevni','100.0000'),('score',58,'arhiva','srevni','100.0000'),('submit_count',58,'arhiva','srevni','100.0000'),('score',18,'arhiva','srevni','100.0000'),('submit_count',18,'arhiva','srevni','100.0000'),('score',256,'arhiva','popandai2','100.0000'),('submit_count',256,'arhiva','popandai2','100.0000'),('score',256,'arhiva','spirala','100.0000'),('submit_count',256,'arhiva','spirala','100.0000'),('score',256,'arhiva','minim','100.0000'),('submit_count',256,'arhiva','minim','100.0000'),('score',256,'arhiva','jocul','100.0000'),('submit_count',256,'arhiva','jocul','100.0000'),('score',1,'arhiva','aladdin','100.0000'),('submit_count',1,'arhiva','aladdin','100.0000'),('score',1,'arhiva','srevni','100.0000'),('submit_count',1,'arhiva','srevni','100.0000'),('score',256,'arhiva','srevni','100.0000'),('submit_count',256,'arhiva','srevni','100.0000'),('score',2092,'arhiva','srevni','100.0000'),('submit_count',2092,'arhiva','srevni','100.0000'),('score',2092,'arhiva','paralelograme','100.0000'),('submit_count',2092,'arhiva','paralelograme','100.0000'),('score',961,'arhiva','biti2','100.0000'),('submit_count',961,'arhiva','biti2','100.0000'),('score',1,'arhiva','pscnv','100.0000'),('submit_count',1,'arhiva','pscnv','100.0000'),('score',256,'arhiva','sequencequery','100.0000'),('submit_count',256,'arhiva','sequencequery','100.0000'),('score',2092,'arhiva','sequencequery','100.0000'),('submit_count',2092,'arhiva','sequencequery','100.0000'),('score',256,'arhiva','car','80.0000'),('submit_count',256,'arhiva','car','80.0000'),('score',75,'arhiva','jocul','100.0000'),('submit_count',75,'arhiva','jocul','100.0000'),('score',2092,'arhiva','biti2','100.0000'),('submit_count',2092,'arhiva','biti2','100.0000'),('score',256,'arhiva','nextseq','100.0000'),('submit_count',256,'arhiva','nextseq','100.0000'),('score',256,'arhiva','calcul','100.0000'),('submit_count',256,'arhiva','calcul','100.0000'),('score',961,'arhiva','joc2','100.0000'),('submit_count',961,'arhiva','joc2','100.0000'),('score',18,'arhiva','biti2','100.0000'),('submit_count',18,'arhiva','biti2','100.0000'),('score',18,'arhiva','joc2','100.0000'),('submit_count',18,'arhiva','joc2','100.0000'),('score',961,'arhiva','lesbulan','100.0000'),('submit_count',961,'arhiva','lesbulan','100.0000'),('score',961,'arhiva','colorare','100.0000'),('submit_count',961,'arhiva','colorare','100.0000'),('score',961,'arhiva','geom','100.0000'),('submit_count',961,'arhiva','geom','100.0000'),('score',58,'arhiva','geom','100.0000'),('submit_count',58,'arhiva','geom','100.0000'),('score',18,'arhiva','jocul','100.0000'),('submit_count',18,'arhiva','jocul','100.0000'),('score',2092,'arhiva','parcele','100.0000'),('submit_count',2092,'arhiva','parcele','100.0000'),('score',75,'arhiva','popandai2','100.0000'),('submit_count',75,'arhiva','popandai2','100.0000'),('score',1,'arhiva','joc2','100.0000'),('submit_count',1,'arhiva','joc2','100.0000'),('score',1,'arhiva','lesbulan','100.0000'),('submit_count',1,'arhiva','lesbulan','100.0000'),('score',1,'arhiva','colorare','100.0000'),('submit_count',1,'arhiva','colorare','100.0000'),('score',1,'arhiva','geom','100.0000'),('submit_count',1,'arhiva','geom','100.0000'),('score',2524,'arhiva','biti','100.0000'),('submit_count',2524,'arhiva','biti','100.0000'),('score',18,'arhiva','geom','100.0000'),('submit_count',18,'arhiva','geom','100.0000'),('score',256,'arhiva','figuri','100.0000'),('submit_count',256,'arhiva','figuri','100.0000'),('score',2092,'arhiva','demolish','70.0000'),('submit_count',2092,'arhiva','demolish','70.0000'),('score',75,'arhiva','arbore','100.0000'),('submit_count',75,'arhiva','arbore','100.0000'),('score',18,'arhiva','overlap','100.0000'),('submit_count',18,'arhiva','overlap','100.0000'),('score',18,'arhiva','sortnet','100.0000'),('submit_count',18,'arhiva','sortnet','100.0000'),('score',1,'arhiva','arbore','100.0000'),('submit_count',1,'arhiva','arbore','100.0000'),('score',1,'arhiva','robotei','100.0000'),('submit_count',1,'arhiva','robotei','100.0000'),('score',256,'arhiva','arbore','0.0000'),('submit_count',256,'arhiva','arbore','40.0000'),('score',256,'arhiva','lupu','100.0000'),('submit_count',256,'arhiva','lupu','100.0000'),('score',4159,'arhiva','sir','0.0000'),('submit_count',4159,'arhiva','sir','0.0000'),('score',3968,'arhiva','adunare','100.0000'),('submit_count',3968,'arhiva','adunare','100.0000'),('score',961,'arhiva','sir','100.0000'),('submit_count',961,'arhiva','sir','100.0000'),('score',75,'arhiva','algola','100.0000'),('submit_count',75,'arhiva','algola','100.0000'),('score',3968,'arhiva','cmmdc','50.0000'),('submit_count',3968,'arhiva','cmmdc','50.0000'),('score',961,'arhiva','semne','100.0000'),('submit_count',961,'arhiva','semne','100.0000'),('score',75,'arhiva','rubarba','100.0000'),('submit_count',75,'arhiva','rubarba','100.0000'),('score',18,'arhiva','subsiruri','100.0000'),('submit_count',18,'arhiva','subsiruri','100.0000'),('score',18,'arhiva','gard2','100.0000'),('submit_count',18,'arhiva','gard2','100.0000'),('score',3968,'arhiva','sume','0.0000'),('submit_count',3968,'arhiva','sume','0.0000'),('score',18,'arhiva','turneu','100.0000'),('submit_count',18,'arhiva','turneu','100.0000'),('score',1,'arhiva','demolish','100.0000'),('submit_count',1,'arhiva','demolish','100.0000'),('score',4159,'arhiva','lesbulan','5.0000'),('submit_count',4159,'arhiva','lesbulan','5.0000'),('score',2092,'arhiva','trapeze','100.0000'),('submit_count',2092,'arhiva','trapeze','100.0000'),('score',961,'arhiva','arbore','100.0000'),('submit_count',961,'arhiva','arbore','100.0000'),('score',1,'arhiva','camera','100.0000'),('submit_count',1,'arhiva','camera','100.0000'),('score',961,'arhiva','seti','100.0000'),('submit_count',961,'arhiva','seti','100.0000'),('score',1,'arhiva','sortnet','100.0000'),('submit_count',1,'arhiva','sortnet','100.0000'),('score',961,'arhiva','pavare2','100.0000'),('submit_count',961,'arhiva','pavare2','100.0000'),('score',961,'arhiva','grazing','100.0000'),('submit_count',961,'arhiva','grazing','100.0000'),('score',961,'arhiva','count','100.0000'),('submit_count',961,'arhiva','count','100.0000'),('score',961,'arhiva','popandai','100.0000'),('submit_count',961,'arhiva','popandai','100.0000'),('score',2092,'arhiva','grazing','100.0000'),('submit_count',2092,'arhiva','grazing','100.0000'),('score',961,'arhiva','pscnv','100.0000'),('submit_count',961,'arhiva','pscnv','100.0000'),('score',961,'arhiva','cercuri2','100.0000'),('submit_count',961,'arhiva','cercuri2','100.0000'),('score',1,'arhiva','grazing','100.0000'),('submit_count',1,'arhiva','grazing','100.0000'),('score',58,'arhiva','apdm','100.0000'),('submit_count',58,'arhiva','apdm','100.0000'),('score',1,'arhiva','apdm','100.0000'),('submit_count',1,'arhiva','apdm','100.0000'),('score',1,'arhiva','divizori','100.0000'),('submit_count',1,'arhiva','divizori','100.0000'),('score',2092,'arhiva','divizori','100.0000'),('submit_count',2092,'arhiva','divizori','100.0000'),('score',18,'arhiva','divizori','100.0000'),('submit_count',18,'arhiva','divizori','100.0000'),('score',18,'arhiva','cifru','100.0000'),('submit_count',18,'arhiva','cifru','100.0000'),('score',1,'arhiva','telegraf','100.0000'),('submit_count',1,'arhiva','telegraf','100.0000'),('score',1,'arhiva','cifru','100.0000'),('submit_count',1,'arhiva','cifru','100.0000'),('score',2092,'arhiva','apdm','100.0000'),('submit_count',2092,'arhiva','apdm','100.0000'),('score',961,'arhiva','cifru','100.0000'),('submit_count',961,'arhiva','cifru','100.0000'),('score',18,'arhiva','arbore','100.0000'),('submit_count',18,'arhiva','arbore','100.0000'),('score',961,'arhiva','apdm','100.0000'),('submit_count',961,'arhiva','apdm','100.0000'),('score',18,'arhiva','grazing','100.0000'),('submit_count',18,'arhiva','grazing','100.0000'),('score',256,'arhiva','divizori','100.0000'),('submit_count',256,'arhiva','divizori','100.0000'),('score',18,'arhiva','apdm','100.0000'),('submit_count',18,'arhiva','apdm','100.0000'),('score',58,'arhiva','fold','100.0000'),('submit_count',58,'arhiva','fold','100.0000'),('score',1,'arhiva','fold','100.0000'),('submit_count',1,'arhiva','fold','100.0000'),('score',18,'arhiva','fold','100.0000'),('submit_count',18,'arhiva','fold','100.0000'),('score',256,'arhiva','fold','100.0000'),('submit_count',256,'arhiva','fold','100.0000'),('score',1,'arhiva','hallway','100.0000'),('submit_count',1,'arhiva','hallway','100.0000'),('score',58,'arhiva','hallway','100.0000'),('submit_count',58,'arhiva','hallway','100.0000'),('score',1,'arhiva','trib','100.0000'),('submit_count',1,'arhiva','trib','100.0000'),('score',2092,'arhiva','fold','100.0000'),('submit_count',2092,'arhiva','fold','100.0000'),('score',1,'arhiva','supersf','100.0000'),('submit_count',1,'arhiva','supersf','100.0000'),('score',1,'arhiva','santa','100.0000'),('submit_count',1,'arhiva','santa','100.0000'),('score',18,'arhiva','hallway','100.0000'),('submit_count',18,'arhiva','hallway','100.0000'),('score',18,'arhiva','seti','100.0000'),('submit_count',18,'arhiva','seti','100.0000'),('score',2092,'arhiva','cifru','100.0000'),('submit_count',2092,'arhiva','cifru','100.0000'),('score',18,'arhiva','spirala','100.0000'),('submit_count',18,'arhiva','spirala','100.0000'),('score',18,'arhiva','numar','100.0000'),('submit_count',18,'arhiva','numar','100.0000'),('score',66,'arhiva','fold','100.0000'),('submit_count',66,'arhiva','fold','100.0000'),('score',1,'arhiva','reg','100.0000'),('submit_count',1,'arhiva','reg','100.0000'),('score',961,'arhiva','fold','100.0000'),('submit_count',961,'arhiva','fold','100.0000'),('score',58,'arhiva','game','100.0000'),('submit_count',58,'arhiva','game','100.0000'),('score',1,'arhiva','game','100.0000'),('submit_count',1,'arhiva','game','100.0000'),('score',58,'arhiva','pawns','100.0000'),('submit_count',58,'arhiva','pawns','100.0000'),('score',1,'arhiva','pawns','100.0000'),('submit_count',1,'arhiva','pawns','100.0000'),('score',961,'arhiva','game','100.0000'),('submit_count',961,'arhiva','game','100.0000'),('score',18,'arhiva','game','100.0000'),('submit_count',18,'arhiva','game','100.0000'),('score',961,'arhiva','pawns','100.0000'),('submit_count',961,'arhiva','pawns','100.0000'),('score',18,'arhiva','pawns','100.0000'),('submit_count',18,'arhiva','pawns','100.0000'),('score',961,'arhiva','divizori','100.0000'),('submit_count',961,'arhiva','divizori','100.0000'),('score',2092,'arhiva','game','100.0000'),('submit_count',2092,'arhiva','game','100.0000'),('score',3968,'arhiva','dame','65.0000'),('submit_count',3968,'arhiva','dame','65.0000'),('score',2092,'arhiva','pawns','100.0000'),('submit_count',2092,'arhiva','pawns','100.0000'),('score',961,'arhiva','popandai2','100.0000'),('submit_count',961,'arhiva','popandai2','100.0000'),('score',66,'arhiva','game','100.0000'),('submit_count',66,'arhiva','game','100.0000'),('score',961,'arhiva','domino','100.0000'),('submit_count',961,'arhiva','domino','100.0000'),('score',66,'arhiva','pawns','100.0000'),('submit_count',66,'arhiva','pawns','100.0000'),('score',66,'arhiva','srevni','100.0000'),('submit_count',66,'arhiva','srevni','100.0000'),('score',66,'arhiva','joc2','100.0000'),('submit_count',66,'arhiva','joc2','100.0000'),('score',66,'arhiva','lesbulan','100.0000'),('submit_count',66,'arhiva','lesbulan','100.0000'),('score',66,'arhiva','colorare','100.0000'),('submit_count',66,'arhiva','colorare','100.0000'),('score',66,'arhiva','geom','100.0000'),('submit_count',66,'arhiva','geom','100.0000'),('score',66,'arhiva','grazing','100.0000'),('submit_count',66,'arhiva','grazing','100.0000'),('score',961,'arhiva','supersf','100.0000'),('submit_count',961,'arhiva','supersf','100.0000'),('score',66,'arhiva','divizori','100.0000'),('submit_count',66,'arhiva','divizori','100.0000'),('score',66,'arhiva','cifru','100.0000'),('submit_count',66,'arhiva','cifru','100.0000'),('score',1,'arhiva','biscuiti','100.0000'),('submit_count',1,'arhiva','biscuiti','100.0000'),('score',1,'arhiva','invcs','100.0000'),('submit_count',1,'arhiva','invcs','100.0000'),('score',961,'arhiva','biscuiti','100.0000'),('submit_count',961,'arhiva','biscuiti','100.0000'),('score',2092,'arhiva','invcs','100.0000'),('submit_count',2092,'arhiva','invcs','100.0000'),('score',2092,'arhiva','biscuiti','100.0000'),('submit_count',2092,'arhiva','biscuiti','100.0000'),('score',256,'arhiva','biscuiti','100.0000'),('submit_count',256,'arhiva','biscuiti','100.0000'),('score',58,'arhiva','order','100.0000'),('submit_count',58,'arhiva','order','100.0000'),('score',961,'arhiva','invsort','100.0000'),('submit_count',961,'arhiva','invsort','100.0000'),('score',1,'arhiva','order','100.0000'),('submit_count',1,'arhiva','order','100.0000'),('score',58,'arhiva','points','100.0000'),('submit_count',58,'arhiva','points','100.0000'),('score',1,'arhiva','points','100.0000'),('submit_count',1,'arhiva','points','100.0000'),('score',2092,'arhiva','order','100.0000'),('submit_count',2092,'arhiva','order','100.0000'),('score',2092,'arhiva','points','100.0000'),('submit_count',2092,'arhiva','points','100.0000'),('score',66,'arhiva','points','100.0000'),('submit_count',66,'arhiva','points','100.0000'),('score',18,'arhiva','points','100.0000'),('submit_count',18,'arhiva','points','100.0000'),('score',961,'arhiva','invcs','100.0000'),('submit_count',961,'arhiva','invcs','100.0000'),('score',2092,'arhiva','z','100.0000'),('submit_count',2092,'arhiva','z','100.0000'),('score',75,'arhiva','lupu','100.0000'),('submit_count',75,'arhiva','lupu','100.0000'),('score',75,'arhiva','biscuiti','100.0000'),('submit_count',75,'arhiva','biscuiti','100.0000'),('score',961,'arhiva','robotei','100.0000'),('submit_count',961,'arhiva','robotei','100.0000'),('score',58,'arhiva','aladdin2','100.0000'),('submit_count',58,'arhiva','aladdin2','100.0000'),('score',58,'arhiva','bmatrix','100.0000'),('submit_count',58,'arhiva','bmatrix','100.0000'),('score',58,'arhiva','password','100.0000'),('submit_count',58,'arhiva','password','100.0000'),('score',18,'arhiva','aladdin2','100.0000'),('submit_count',18,'arhiva','aladdin2','100.0000'),('score',58,'arhiva','path','75.0000'),('submit_count',58,'arhiva','path','75.0000'),('score',75,'arhiva','sir','100.0000'),('submit_count',75,'arhiva','sir','100.0000'),('score',75,'arhiva','spirala','100.0000'),('submit_count',75,'arhiva','spirala','100.0000'),('score',66,'arhiva','password','100.0000'),('submit_count',66,'arhiva','password','100.0000'),('score',1,'arhiva','aladdin2','100.0000'),('submit_count',1,'arhiva','aladdin2','100.0000'),('score',1,'arhiva','bmatrix','100.0000'),('submit_count',1,'arhiva','bmatrix','100.0000'),('score',75,'arhiva','z','100.0000'),('submit_count',75,'arhiva','z','100.0000'),('score',75,'arhiva','domino','80.0000'),('submit_count',75,'arhiva','domino','80.0000'),('score',256,'arhiva','tri2','100.0000'),('submit_count',256,'arhiva','tri2','100.0000'),('score',256,'arhiva','bmatrix','100.0000'),('submit_count',256,'arhiva','bmatrix','100.0000'),('score',1,'arhiva','password','100.0000'),('submit_count',1,'arhiva','password','100.0000'),('score',1,'arhiva','path','100.0000'),('submit_count',1,'arhiva','path','100.0000'),('score',2092,'arhiva','password','100.0000'),('submit_count',2092,'arhiva','password','100.0000'),('score',961,'arhiva','aladdin2','100.0000'),('submit_count',961,'arhiva','aladdin2','100.0000'),('score',66,'arhiva','path','100.0000'),('submit_count',66,'arhiva','path','100.0000'),('score',2092,'arhiva','aladdin2','100.0000'),('submit_count',2092,'arhiva','aladdin2','100.0000'),('score',66,'arhiva','bmatrix','100.0000'),('submit_count',66,'arhiva','bmatrix','100.0000'),('score',961,'arhiva','points','100.0000'),('submit_count',961,'arhiva','points','100.0000'),('score',961,'arhiva','password','100.0000'),('submit_count',961,'arhiva','password','100.0000'),('score',256,'arhiva','aladdin2','100.0000'),('submit_count',256,'arhiva','aladdin2','100.0000'),('score',18,'arhiva','password','100.0000'),('submit_count',18,'arhiva','password','100.0000'),('score',2092,'arhiva','bmatrix','100.0000'),('submit_count',2092,'arhiva','bmatrix','100.0000'),('score',18,'arhiva','bmatrix','100.0000'),('submit_count',18,'arhiva','bmatrix','100.0000'),('score',18,'arhiva','path','100.0000'),('submit_count',18,'arhiva','path','100.0000'),('score',256,'arhiva','order','100.0000'),('submit_count',256,'arhiva','order','100.0000'),('score',18,'arhiva','order','100.0000'),('submit_count',18,'arhiva','order','100.0000'),('score',256,'arhiva','critice','100.0000'),('submit_count',256,'arhiva','critice','100.0000'),('score',2092,'arhiva','path','100.0000'),('submit_count',2092,'arhiva','path','100.0000'),('score',18,'arhiva','invcs','100.0000'),('submit_count',18,'arhiva','invcs','100.0000'),('score',18,'arhiva','domino','100.0000'),('submit_count',18,'arhiva','domino','100.0000'),('score',18,'arhiva','lesbulan','100.0000'),('submit_count',18,'arhiva','lesbulan','100.0000'),('score',66,'arhiva','aladdin2','100.0000'),('submit_count',66,'arhiva','aladdin2','100.0000'),('score',961,'arhiva','trib','100.0000'),('submit_count',961,'arhiva','trib','100.0000'),('score',1024,'arhiva','jocul','100.0000'),('submit_count',1024,'arhiva','jocul','100.0000'),('score',3968,'arhiva','nrtri','0.0000'),('submit_count',3968,'arhiva','nrtri','0.0000'),('score',3968,'arhiva','flip','0.0000'),('submit_count',3968,'arhiva','flip','0.0000'),('score',3968,'arhiva','joc2','5.0000'),('submit_count',3968,'arhiva','joc2','5.0000'),('score',3968,'arhiva','text','30.0000'),('submit_count',3968,'arhiva','text','30.0000'),('score',3968,'arhiva','sumdiv','0.0000'),('submit_count',3968,'arhiva','sumdiv','0.0000'),('score',3968,'arhiva','subsir','0.0000'),('submit_count',3968,'arhiva','subsir','0.0000'),('score',3968,'arhiva','password','0.0000'),('submit_count',3968,'arhiva','password','0.0000'),('score',1024,'arhiva','muzeu','100.0000'),('submit_count',1024,'arhiva','muzeu','100.0000'),('score',3968,'arhiva','trapez','0.0000'),('submit_count',3968,'arhiva','trapez','0.0000'),('score',3968,'arhiva','color','0.0000'),('submit_count',3968,'arhiva','color','0.0000'),('score',256,'arhiva','password','100.0000'),('submit_count',256,'arhiva','password','100.0000'),('score',256,'arhiva','path','100.0000'),('submit_count',256,'arhiva','path','100.0000'),('score',256,'arhiva','semne','60.0000'),('submit_count',256,'arhiva','semne','60.0000'),('score',3968,'arhiva','grupuri','2.0000'),('submit_count',3968,'arhiva','grupuri','2.0000'),('score',66,'arhiva','numar','100.0000'),('submit_count',66,'arhiva','numar','100.0000'),('score',66,'arhiva','order','100.0000'),('submit_count',66,'arhiva','order','100.0000'),('score',66,'arhiva','biscuiti','100.0000'),('submit_count',66,'arhiva','biscuiti','100.0000'),('score',3968,'arhiva','12perm','0.0000'),('submit_count',3968,'arhiva','12perm','0.0000'),('score',18,'arhiva','parcele','100.0000'),('submit_count',18,'arhiva','parcele','100.0000'),('score',18,'arhiva','luna','100.0000'),('submit_count',18,'arhiva','luna','100.0000'),('score',66,'arhiva','zc','100.0000'),('submit_count',66,'arhiva','zc','100.0000'),('score',66,'arhiva','seti','100.0000'),('submit_count',66,'arhiva','seti','100.0000'),('score',66,'arhiva','semne','100.0000'),('submit_count',66,'arhiva','semne','100.0000'),('score',256,'arhiva','camera','100.0000'),('submit_count',256,'arhiva','camera','100.0000'),('score',18,'arhiva','otilia','100.0000'),('submit_count',18,'arhiva','otilia','100.0000'),('score',18,'arhiva','sir','100.0000'),('submit_count',18,'arhiva','sir','100.0000'),('score',1024,'arhiva','copaci','100.0000'),('submit_count',1024,'arhiva','copaci','100.0000'),('score',66,'arhiva','apdm','100.0000'),('submit_count',66,'arhiva','apdm','100.0000'),('score',66,'arhiva','hallway','100.0000'),('submit_count',66,'arhiva','hallway','100.0000'),('score',66,'arhiva','figuri','100.0000'),('submit_count',66,'arhiva','figuri','100.0000'),('score',2092,'arhiva','substr','100.0000'),('submit_count',2092,'arhiva','substr','100.0000'),('score',4351,'arhiva','adunare','100.0000'),('submit_count',4351,'arhiva','adunare','100.0000'),('score',4351,'arhiva','cmmdc','50.0000'),('submit_count',4351,'arhiva','cmmdc','50.0000'),('score',256,'arhiva','omizi','100.0000'),('submit_count',256,'arhiva','omizi','100.0000'),('score',256,'arhiva','avere','100.0000'),('submit_count',256,'arhiva','avere','100.0000'),('score',2092,'arhiva','avere','100.0000'),('submit_count',2092,'arhiva','avere','100.0000'),('score',4159,'arhiva','santa','0.0000'),('submit_count',4159,'arhiva','santa','0.0000'),('score',256,'arhiva','acolor','100.0000'),('submit_count',256,'arhiva','acolor','100.0000'),('score',1024,'arhiva','dreptunghiuri','100.0000'),('submit_count',1024,'arhiva','dreptunghiuri','100.0000'),('score',256,'arhiva','seti','100.0000'),('submit_count',256,'arhiva','seti','100.0000'),('score',66,'arhiva','acolor','100.0000'),('submit_count',66,'arhiva','acolor','100.0000'),('score',18,'arhiva','avere','100.0000'),('submit_count',18,'arhiva','avere','100.0000'),('score',1,'arhiva','omizi','100.0000'),('submit_count',1,'arhiva','omizi','100.0000'),('score',1,'arhiva','avere','100.0000'),('submit_count',1,'arhiva','avere','100.0000'),('score',1,'arhiva','acolor','100.0000'),('submit_count',1,'arhiva','acolor','100.0000'),('score',3968,'arhiva','path','0.0000'),('submit_count',3968,'arhiva','path','0.0000'),('score',3968,'arhiva','iv','0.0000'),('submit_count',3968,'arhiva','iv','0.0000'),('score',256,'arhiva','adn','100.0000'),('submit_count',256,'arhiva','adn','100.0000'),('score',961,'arhiva','avere','100.0000'),('submit_count',961,'arhiva','avere','100.0000'),('score',961,'arhiva','order','100.0000'),('submit_count',961,'arhiva','order','100.0000'),('score',961,'arhiva','path','100.0000'),('submit_count',961,'arhiva','path','100.0000'),('score',18,'arhiva','reg','100.0000'),('submit_count',18,'arhiva','reg','100.0000'),('score',18,'arhiva','zapada','100.0000'),('submit_count',18,'arhiva','zapada','100.0000'),('score',256,'arhiva','cercuri','100.0000'),('submit_count',256,'arhiva','cercuri','100.0000'),('score',18,'arhiva','siruri','100.0000'),('submit_count',18,'arhiva','siruri','100.0000'),('score',961,'arhiva','hallway','100.0000'),('submit_count',961,'arhiva','hallway','100.0000'),('score',961,'arhiva','bmatrix','100.0000'),('submit_count',961,'arhiva','bmatrix','100.0000'),('score',2524,'arhiva','biscuiti','100.0000'),('submit_count',2524,'arhiva','biscuiti','100.0000'),('score',2524,'arhiva','bmatrix','100.0000'),('submit_count',2524,'arhiva','bmatrix','100.0000'),('score',2524,'arhiva','order','90.0000'),('submit_count',2524,'arhiva','order','90.0000'),('score',2524,'arhiva','points','0.0000'),('submit_count',2524,'arhiva','points','0.0000'),('score',256,'arhiva','poligon','100.0000'),('submit_count',256,'arhiva','poligon','100.0000'),('score',2524,'arhiva','aladdin2','100.0000'),('submit_count',2524,'arhiva','aladdin2','100.0000'),('score',18,'arhiva','calcul','100.0000'),('submit_count',18,'arhiva','calcul','100.0000'),('score',2092,'arhiva','siruri','100.0000'),('submit_count',2092,'arhiva','siruri','100.0000'),('score',256,'arhiva','echipe','100.0000'),('submit_count',256,'arhiva','echipe','100.0000'),('score',18,'arhiva','invsort','100.0000'),('submit_count',18,'arhiva','invsort','100.0000'),('score',18,'arhiva','trib','100.0000'),('submit_count',18,'arhiva','trib','100.0000'),('score',18,'arhiva','cercuri2','100.0000'),('submit_count',18,'arhiva','cercuri2','100.0000'),('score',18,'arhiva','numere2','100.0000'),('submit_count',18,'arhiva','numere2','100.0000'),('score',256,'arhiva','cifru','100.0000'),('submit_count',256,'arhiva','cifru','100.0000'),('score',961,'arhiva','csir','100.0000'),('submit_count',961,'arhiva','csir','100.0000'),('score',1,'arhiva','csir','100.0000'),('submit_count',1,'arhiva','csir','100.0000'),('score',66,'arhiva','csir','100.0000'),('submit_count',66,'arhiva','csir','100.0000'),('score',2092,'arhiva','omizi','100.0000'),('submit_count',2092,'arhiva','omizi','100.0000'),('score',48,'arhiva','supersf','100.0000'),('submit_count',48,'arhiva','supersf','100.0000'),('score',1024,'arhiva','asmax','100.0000'),('submit_count',1024,'arhiva','asmax','100.0000'),('score',256,'arhiva','siruri','100.0000'),('submit_count',256,'arhiva','siruri','75.0000'),('score',2524,'arhiva','semne','100.0000'),('submit_count',2524,'arhiva','semne','100.0000'),('score',2524,'arhiva','path','0.0000'),('submit_count',2524,'arhiva','path','0.0000'),('score',2986,'arhiva','prim','50.0000'),('submit_count',2986,'arhiva','prim','50.0000'),('score',2524,'arhiva','indep','90.0000'),('submit_count',2524,'arhiva','indep','90.0000'),('score',2524,'arhiva','timbre','70.0000'),('submit_count',2524,'arhiva','timbre','70.0000'),('score',18,'arhiva','map','100.0000'),('submit_count',18,'arhiva','map','100.0000'),('score',2524,'arhiva','srevni','100.0000'),('submit_count',2524,'arhiva','srevni','100.0000'),('score',2092,'arhiva','map','100.0000'),('submit_count',2092,'arhiva','map','100.0000'),('score',2092,'arhiva','panouri','100.0000'),('submit_count',2092,'arhiva','panouri','100.0000'),('score',18,'arhiva','panouri','100.0000'),('submit_count',18,'arhiva','panouri','100.0000'),('score',961,'arhiva','map','100.0000'),('submit_count',961,'arhiva','map','100.0000'),('score',961,'arhiva','panouri','100.0000'),('submit_count',961,'arhiva','panouri','100.0000'),('score',256,'arhiva','drumuri2','100.0000'),('submit_count',256,'arhiva','drumuri2','100.0000'),('score',2092,'arhiva','drumuri2','100.0000'),('submit_count',2092,'arhiva','drumuri2','100.0000'),('score',4663,'arhiva','adunare','100.0000'),('submit_count',4663,'arhiva','adunare','100.0000'),('score',4663,'arhiva','cmmdc','100.0000'),('submit_count',4663,'arhiva','cmmdc','100.0000'),('score',18,'arhiva','mine','100.0000'),('submit_count',18,'arhiva','mine','100.0000'),('score',18,'arhiva','drumuri2','100.0000'),('submit_count',18,'arhiva','drumuri2','100.0000'),('score',66,'arhiva','mine','100.0000'),('submit_count',66,'arhiva','mine','100.0000'),('score',961,'arhiva','mine','100.0000'),('submit_count',961,'arhiva','mine','100.0000'),('score',2092,'arhiva','mine','100.0000'),('submit_count',2092,'arhiva','mine','100.0000'),('score',4663,'arhiva','fact','0.0000'),('submit_count',4663,'arhiva','fact','0.0000'),('score',4663,'arhiva','tabela','100.0000'),('submit_count',4663,'arhiva','tabela','100.0000'),('score',2092,'arhiva','zapada','100.0000'),('submit_count',2092,'arhiva','zapada','100.0000'),('score',256,'arhiva','panouri','100.0000'),('submit_count',256,'arhiva','panouri','100.0000'),('score',256,'arhiva','map','100.0000'),('submit_count',256,'arhiva','map','100.0000'),('score',66,'arhiva','drumuri2','100.0000'),('submit_count',66,'arhiva','drumuri2','100.0000'),('score',18,'arhiva','resturi','100.0000'),('submit_count',18,'arhiva','resturi','100.0000'),('score',961,'arhiva','drumuri2','100.0000'),('submit_count',961,'arhiva','drumuri2','100.0000'),('score',66,'arhiva','map','100.0000'),('submit_count',66,'arhiva','map','100.0000'),('score',66,'arhiva','panouri','100.0000'),('submit_count',66,'arhiva','panouri','100.0000'),('score',256,'arhiva','traseu','100.0000'),('submit_count',256,'arhiva','traseu','100.0000'),('score',256,'arhiva','arie','100.0000'),('submit_count',256,'arhiva','arie','100.0000'),('score',1,'arhiva','drumuri2','100.0000'),('submit_count',1,'arhiva','drumuri2','100.0000'),('score',2524,'arhiva','tribute','90.0000'),('submit_count',2524,'arhiva','tribute','90.0000'),('score',256,'arhiva','zc','40.0000'),('submit_count',256,'arhiva','zc','40.0000'),('score',2524,'arhiva','panouri','100.0000'),('submit_count',2524,'arhiva','panouri','100.0000'),('score',1,'arhiva','map','100.0000'),('submit_count',1,'arhiva','map','100.0000'),('score',1,'arhiva','panouri','100.0000'),('submit_count',1,'arhiva','panouri','100.0000'),('score',1,'arhiva','mine','100.0000'),('submit_count',1,'arhiva','mine','100.0000'),('score',18,'arhiva','aladdin','100.0000'),('submit_count',18,'arhiva','aladdin','100.0000'),('score',961,'arhiva','omizi','100.0000'),('submit_count',961,'arhiva','omizi','100.0000'),('score',18,'arhiva','dreptunghiuri','100.0000'),('submit_count',18,'arhiva','dreptunghiuri','100.0000'),('score',66,'arhiva','invcs','100.0000'),('submit_count',66,'arhiva','invcs','100.0000'),('score',256,'arhiva','arbfind','100.0000'),('submit_count',256,'arhiva','arbfind','100.0000'),('score',961,'arhiva','arbfind','100.0000'),('submit_count',961,'arhiva','arbfind','100.0000'),('score',18,'arhiva','Expr','100.0000'),('submit_count',18,'arhiva','Expr','100.0000'),('score',66,'arhiva','iv','100.0000'),('submit_count',66,'arhiva','iv','100.0000'),('score',2092,'arhiva','arbfind','100.0000'),('submit_count',2092,'arhiva','arbfind','100.0000'),('score',256,'arhiva','popandai','100.0000'),('submit_count',256,'arhiva','popandai','100.0000'),('score',256,'arhiva','invcs','100.0000'),('submit_count',256,'arhiva','invcs','100.0000'),('score',256,'arhiva','trapeze','100.0000'),('submit_count',256,'arhiva','trapeze','100.0000'),('score',256,'arhiva','sticle','100.0000'),('submit_count',256,'arhiva','sticle','100.0000'),('score',2092,'arhiva','12perm','100.0000'),('submit_count',2092,'arhiva','12perm','100.0000'),('score',2524,'arhiva','sir','20.0000'),('submit_count',2524,'arhiva','sir','20.0000'),('score',2524,'arhiva','struti','100.0000'),('submit_count',2524,'arhiva','struti','100.0000'),('score',2092,'arhiva','robotei','100.0000'),('submit_count',2092,'arhiva','robotei','100.0000'),('score',2524,'arhiva','lacate','100.0000'),('submit_count',2524,'arhiva','lacate','100.0000'),('score',2524,'arhiva','iv','0.0000'),('submit_count',2524,'arhiva','iv','0.0000'),('score',1024,'arhiva','graf','100.0000'),('submit_count',1024,'arhiva','graf','100.0000'),('score',2524,'arhiva','pscnv','0.0000'),('submit_count',2524,'arhiva','pscnv','0.0000'),('score',2524,'arhiva','mine','4.0000'),('submit_count',2524,'arhiva','mine','4.0000'),('score',2524,'arhiva','monezi','100.0000'),('submit_count',2524,'arhiva','monezi','100.0000'),('score',2524,'arhiva','figuri','0.0000'),('submit_count',2524,'arhiva','figuri','0.0000'),('score',2186,'arhiva','mine','8.0000'),('submit_count',2186,'arhiva','mine','8.0000'),('score',1024,'arhiva','dmin','100.0000'),('submit_count',1024,'arhiva','dmin','100.0000'),('score',2524,'arhiva','robotei','0.0000'),('submit_count',2524,'arhiva','robotei','0.0000'),('score',2524,'arhiva','proc','100.0000'),('submit_count',2524,'arhiva','proc','100.0000'),('score',2524,'arhiva','overlap','40.0000'),('submit_count',2524,'arhiva','overlap','40.0000'),('score',2524,'arhiva','gard2','100.0000'),('submit_count',2524,'arhiva','gard2','100.0000'),('score',256,'arhiva','senat','100.0000'),('submit_count',256,'arhiva','senat','100.0000'),('score',256,'arhiva','vila','100.0000'),('submit_count',256,'arhiva','vila','100.0000'),('score',256,'arhiva','puternic','100.0000'),('submit_count',256,'arhiva','puternic','100.0000'),('score',256,'arhiva','catun','100.0000'),('submit_count',256,'arhiva','catun','100.0000'),('score',1024,'arhiva','vila','100.0000'),('submit_count',1024,'arhiva','vila','100.0000'),('score',256,'arhiva','alpin','100.0000'),('submit_count',256,'arhiva','alpin','100.0000'),('score',256,'arhiva','euler','100.0000'),('submit_count',256,'arhiva','euler','100.0000'),('score',256,'arhiva','note','100.0000'),('submit_count',256,'arhiva','note','100.0000'),('score',2092,'arhiva','note','100.0000'),('submit_count',2092,'arhiva','note','100.0000'),('score',256,'arhiva','bilete','100.0000'),('submit_count',256,'arhiva','bilete','100.0000'),('score',2092,'arhiva','bilete','100.0000'),('submit_count',2092,'arhiva','bilete','100.0000'),('score',1024,'arhiva','note','100.0000'),('submit_count',1024,'arhiva','note','100.0000'),('score',2092,'arhiva','alpin','100.0000'),('submit_count',2092,'arhiva','alpin','100.0000'),('score',2092,'arhiva','catun','100.0000'),('submit_count',2092,'arhiva','catun','100.0000'),('score',66,'arhiva','euler','100.0000'),('submit_count',66,'arhiva','euler','100.0000'),('score',66,'arhiva','note','100.0000'),('submit_count',66,'arhiva','note','100.0000'),('score',66,'arhiva','alpin','100.0000'),('submit_count',66,'arhiva','alpin','100.0000'),('score',66,'arhiva','bilete','100.0000'),('submit_count',66,'arhiva','bilete','100.0000'),('score',66,'arhiva','catun','100.0000'),('submit_count',66,'arhiva','catun','100.0000'),('score',66,'arhiva','senat','100.0000'),('submit_count',66,'arhiva','senat','100.0000'),('score',66,'arhiva','vila','100.0000'),('submit_count',66,'arhiva','vila','100.0000'),('score',66,'arhiva','bcolor','100.0000'),('submit_count',66,'arhiva','bcolor','100.0000'),('score',66,'arhiva','cowfood','100.0000'),('submit_count',66,'arhiva','cowfood','100.0000'),('score',18,'arhiva','caraibe','100.0000'),('submit_count',18,'arhiva','caraibe','100.0000'),('score',66,'arhiva','caraibe','100.0000'),('submit_count',66,'arhiva','caraibe','100.0000'),('score',66,'arhiva','arbfind','100.0000'),('submit_count',66,'arhiva','arbfind','100.0000'),('score',18,'arhiva','arbfind','100.0000'),('submit_count',18,'arhiva','arbfind','100.0000'),('score',18,'arhiva','puternic','10.0000'),('submit_count',18,'arhiva','puternic','10.0000'),('score',2524,'arhiva','puternic','10.0000'),('submit_count',2524,'arhiva','puternic','10.0000'),('score',75,'arhiva','eqs','100.0000'),('submit_count',75,'arhiva','eqs','100.0000'),('score',2524,'arhiva','note','100.0000'),('submit_count',2524,'arhiva','note','100.0000'),('score',2524,'arhiva','euler','100.0000'),('submit_count',2524,'arhiva','euler','100.0000'),('score',2524,'arhiva','alpin','100.0000'),('submit_count',2524,'arhiva','alpin','100.0000'),('score',2524,'arhiva','bilete','40.0000'),('submit_count',2524,'arhiva','bilete','40.0000'),('score',2524,'arhiva','vila','90.0000'),('submit_count',2524,'arhiva','vila','90.0000'),('score',2524,'arhiva','catun','100.0000'),('submit_count',2524,'arhiva','catun','100.0000'),('score',1,'arhiva','arbfind','100.0000'),('submit_count',1,'arhiva','arbfind','100.0000'),('score',1,'arhiva','senat','100.0000'),('submit_count',1,'arhiva','senat','100.0000'),('score',2524,'arhiva','granita','100.0000'),('submit_count',2524,'arhiva','granita','100.0000'),('score',1,'arhiva','vila','100.0000'),('submit_count',1,'arhiva','vila','100.0000'),('score',1,'arhiva','catun','100.0000'),('submit_count',1,'arhiva','catun','100.0000'),('score',1,'arhiva','alpin','100.0000'),('submit_count',1,'arhiva','alpin','100.0000'),('score',1,'arhiva','note','100.0000'),('submit_count',1,'arhiva','note','100.0000'),('score',1,'arhiva','bilete','100.0000'),('submit_count',1,'arhiva','bilete','100.0000'),('score',1,'arhiva','euler','100.0000'),('submit_count',1,'arhiva','euler','100.0000'),('score',1,'arhiva','puternic','100.0000'),('submit_count',1,'arhiva','puternic','100.0000'),('score',2092,'arhiva','euler','100.0000'),('submit_count',2092,'arhiva','euler','100.0000'),('score',2524,'arhiva','jocul','100.0000'),('submit_count',2524,'arhiva','jocul','100.0000'),('score',18,'arhiva','catun','100.0000'),('submit_count',18,'arhiva','catun','100.0000'),('score',18,'arhiva','alpin','100.0000'),('submit_count',18,'arhiva','alpin','100.0000'),('score',18,'arhiva','euler','100.0000'),('submit_count',18,'arhiva','euler','100.0000'),('score',2524,'summer06','free','100.0000'),('submit_count',2524,'summer06','free','100.0000'),('score',1,'summer06','free','100.0000'),('submit_count',1,'summer06','free','100.0000'),('score',2092,'summer06','free','0.0000'),('submit_count',2092,'summer06','free','0.0000'),('score',1,'summer06','patrol','100.0000'),('submit_count',1,'summer06','patrol','100.0000'),('score',75,'summer06','patrol','40.0000'),('submit_count',75,'summer06','patrol','40.0000'),('score',66,'summer06','free','100.0000'),('submit_count',66,'summer06','free','100.0000'),('score',66,'summer06','patrol','100.0000'),('submit_count',66,'summer06','patrol','100.0000'),('score',66,'summer06','pscpld','100.0000'),('submit_count',66,'summer06','pscpld','100.0000'),('score',1,'summer06','pscpld','40.0000'),('submit_count',1,'summer06','pscpld','40.0000'),('score',75,'arhiva','euler','100.0000'),('submit_count',75,'arhiva','euler','100.0000'),('score',961,'arhiva','free','100.0000'),('submit_count',961,'arhiva','free','100.0000'),('score',75,'arhiva','patrol','50.0000'),('submit_count',75,'arhiva','patrol','50.0000'),('score',2092,'arhiva','free','100.0000'),('submit_count',2092,'arhiva','free','100.0000'),('score',2524,'arhiva','free','100.0000'),('submit_count',2524,'arhiva','free','100.0000'),('score',66,'arhiva','pscpld','90.0000'),('submit_count',66,'arhiva','pscpld','90.0000'),('score',2524,'arhiva','senat','100.0000'),('submit_count',2524,'arhiva','senat','100.0000'),('score',2524,'arhiva','trans','100.0000'),('submit_count',2524,'arhiva','trans','100.0000'),('score',2524,'arhiva','adapost2','92.0000'),('submit_count',2524,'arhiva','adapost2','92.0000'),('score',2092,'arhiva','pscpld','100.0000'),('submit_count',2092,'arhiva','pscpld','100.0000'),('score',2524,'arhiva','asmax','100.0000'),('submit_count',2524,'arhiva','asmax','100.0000'),('score',2524,'arhiva','frac','20.0000'),('submit_count',2524,'arhiva','frac','20.0000'),('score',2524,'summer2','sah','100.0000'),('submit_count',2524,'summer2','sah','100.0000'),('score',1,'summer2','sah','100.0000'),('submit_count',1,'summer2','sah','100.0000'),('score',1,'summer2','plimbare','100.0000'),('submit_count',1,'summer2','plimbare','100.0000'),('score',75,'summer2','treid','0.0000'),('submit_count',75,'summer2','treid','0.0000'),('score',1,'summer2','treid','100.0000'),('submit_count',1,'summer2','treid','100.0000'),('score',18,'summer2','sah','100.0000'),('submit_count',18,'summer2','sah','100.0000'),('score',18,'summer2','plimbare','70.0000'),('submit_count',18,'summer2','plimbare','70.0000'),('score',18,'summer2','treid','100.0000'),('submit_count',18,'summer2','treid','100.0000'),('score',18,'arhiva','sah','100.0000'),('submit_count',18,'arhiva','sah','100.0000'),('score',18,'arhiva','treid','100.0000'),('submit_count',18,'arhiva','treid','100.0000'),('score',256,'arhiva','free','100.0000'),('submit_count',256,'arhiva','free','100.0000'),('score',256,'arhiva','patrol','100.0000'),('submit_count',256,'arhiva','patrol','100.0000'),('score',256,'arhiva','sah','100.0000'),('submit_count',256,'arhiva','sah','100.0000'),('score',2092,'arhiva','sah','100.0000'),('submit_count',2092,'arhiva','sah','100.0000'),('score',961,'arhiva','sah','100.0000'),('submit_count',961,'arhiva','sah','100.0000'),('score',2524,'arhiva','password','100.0000'),('submit_count',2524,'arhiva','password','100.0000'),('score',2524,'arhiva','sah','100.0000'),('submit_count',2524,'arhiva','sah','100.0000'),('score',1,'arhiva','free','100.0000'),('submit_count',1,'arhiva','free','100.0000'),('score',1,'arhiva','patrol','100.0000'),('submit_count',1,'arhiva','patrol','100.0000'),('score',1,'arhiva','sah','100.0000'),('submit_count',1,'arhiva','sah','100.0000'),('score',1,'arhiva','treid','100.0000'),('submit_count',1,'arhiva','treid','100.0000'),('score',2524,'arhiva','zebughil','100.0000'),('submit_count',2524,'arhiva','zebughil','100.0000'),('score',2524,'arhiva','domino','15.0000'),('submit_count',2524,'arhiva','domino','15.0000'),('score',2524,'arhiva','zaharel','100.0000'),('submit_count',2524,'arhiva','zaharel','100.0000'),('score',2524,'summer3','abc','100.0000'),('submit_count',2524,'summer3','abc','100.0000'),('score',2524,'summer3','oras','50.0000'),('submit_count',2524,'summer3','oras','50.0000'),('score',2524,'summer3','gold','100.0000'),('submit_count',2524,'summer3','gold','100.0000'),('score',256,'arhiva','abc','100.0000'),('submit_count',256,'arhiva','abc','100.0000'),('score',256,'arhiva','gold','70.0000'),('submit_count',256,'arhiva','gold','70.0000'),('score',2524,'arhiva','abc','100.0000'),('submit_count',2524,'arhiva','abc','100.0000'),('score',2524,'arhiva','oras','50.0000'),('submit_count',2524,'arhiva','oras','50.0000'),('score',2524,'arhiva','gold','100.0000'),('submit_count',2524,'arhiva','gold','100.0000'),('score',2524,'arhiva','sobo','70.0000'),('submit_count',2524,'arhiva','sobo','30.0000'),('score',961,'arhiva','gold','100.0000'),('submit_count',961,'arhiva','gold','100.0000'),('score',961,'arhiva','oras','100.0000'),('submit_count',961,'arhiva','oras','100.0000'),('score',256,'arhiva','oras','100.0000'),('submit_count',256,'arhiva','oras','100.0000'),('score',2524,'arhiva','colorare','0.0000'),('submit_count',2524,'arhiva','colorare','0.0000'),('score',256,'arhiva','grazing','100.0000'),('submit_count',256,'arhiva','grazing','100.0000'),('score',2524,'arhiva','paralelograme','100.0000'),('submit_count',2524,'arhiva','paralelograme','100.0000'),('score',256,'arhiva','colorare','100.0000'),('submit_count',256,'arhiva','colorare','100.0000'),('score',1,'arhiva','oras','100.0000'),('submit_count',1,'arhiva','oras','100.0000'),('score',1,'arhiva','gold','100.0000'),('submit_count',1,'arhiva','gold','100.0000'),('score',18,'arhiva','abc','0.0000'),('submit_count',18,'arhiva','abc','0.0000'),('score',256,'arhiva','expresii','100.0000'),('submit_count',256,'arhiva','expresii','100.0000'),('score',256,'arhiva','mine','64.0000'),('submit_count',256,'arhiva','mine','64.0000'),('score',2092,'arhiva','oras','100.0000'),('submit_count',2092,'arhiva','oras','100.0000'),('score',1503,'arhiva','cmmdc','100.0000'),('submit_count',1503,'arhiva','cmmdc','100.0000'),('score',2092,'arhiva','abc','100.0000'),('submit_count',2092,'arhiva','abc','100.0000'),('score',1503,'autumn06','poly','0.0000'),('submit_count',1503,'autumn06','poly','0.0000'),('score',2092,'autumn06','secv4','100.0000'),('submit_count',2092,'autumn06','secv4','100.0000'),('score',75,'autumn06','poly','0.0000'),('submit_count',75,'autumn06','poly','0.0000'),('score',2524,'autumn06','bridge','80.0000'),('submit_count',2524,'autumn06','bridge','80.0000'),('score',2524,'autumn06','poly','100.0000'),('submit_count',2524,'autumn06','poly','100.0000'),('score',3369,'autumn06','secv4','15.0000'),('submit_count',3369,'autumn06','secv4','15.0000'),('score',2092,'autumn06','bridge','100.0000'),('submit_count',2092,'autumn06','bridge','100.0000'),('score',3369,'autumn06','bridge','0.0000'),('submit_count',3369,'autumn06','bridge','0.0000'),('score',1024,'autumn06','poly','40.0000'),('submit_count',1024,'autumn06','poly','40.0000'),('score',1024,'autumn06','secv4','0.0000'),('submit_count',1024,'autumn06','secv4','0.0000'),('score',2524,'autumn06','secv4','100.0000'),('submit_count',2524,'autumn06','secv4','100.0000'),('score',2092,'autumn06','poly','100.0000'),('submit_count',2092,'autumn06','poly','100.0000'),('score',256,'arhiva','poly','100.0000'),('submit_count',256,'arhiva','poly','100.0000'),('score',256,'arhiva','bridge','100.0000'),('submit_count',256,'arhiva','bridge','100.0000'),('score',256,'arhiva','secv4','100.0000'),('submit_count',256,'arhiva','secv4','100.0000'),('score',256,'arhiva','parcare','100.0000'),('submit_count',256,'arhiva','parcare','100.0000'),('score',2524,'arhiva','eq','0.0000'),('submit_count',2524,'arhiva','eq','0.0000'),('score',2524,'arhiva','poly','100.0000'),('submit_count',2524,'arhiva','poly','100.0000'),('score',2524,'arhiva','secv4','100.0000'),('submit_count',2524,'arhiva','secv4','100.0000'),('score',2524,'arhiva','bridge','100.0000'),('submit_count',2524,'arhiva','bridge','100.0000'),('score',2092,'arhiva','eq','92.0000'),('submit_count',2092,'arhiva','eq','92.0000'),('score',2092,'arhiva','poly','100.0000'),('submit_count',2092,'arhiva','poly','100.0000'),('score',2092,'arhiva','bridge','100.0000'),('submit_count',2092,'arhiva','bridge','100.0000'),('score',2092,'arhiva','secv4','100.0000'),('submit_count',2092,'arhiva','secv4','100.0000'),('score',1,'arhiva','poly','100.0000'),('submit_count',1,'arhiva','poly','100.0000'),('score',2092,'arhiva','treid','100.0000'),('submit_count',2092,'arhiva','treid','100.0000'),('score',142,'arhiva','geamuri','100.0000'),('submit_count',142,'arhiva','geamuri','100.0000'),('score',142,'arhiva','sortari','100.0000'),('submit_count',142,'arhiva','sortari','100.0000'),('score',2524,'arhiva','drumuri2','80.0000'),('submit_count',2524,'arhiva','drumuri2','80.0000'),('score',2092,'arhiva','struti','100.0000'),('submit_count',2092,'arhiva','struti','100.0000'),('score',256,'arhiva','pavare','100.0000'),('submit_count',256,'arhiva','pavare','100.0000'),('score',256,'arhiva','tvshow','10.0000'),('submit_count',256,'arhiva','tvshow','10.0000'),('score',2524,'arhiva','xormax','100.0000'),('submit_count',2524,'arhiva','xormax','100.0000'),('score',2524,'arhiva','copaci','100.0000'),('submit_count',2524,'arhiva','copaci','100.0000'),('score',2092,'arhiva','palind','100.0000'),('submit_count',2092,'arhiva','palind','100.0000'),('score',2092,'arhiva','jarbore','100.0000'),('submit_count',2092,'arhiva','jarbore','100.0000'),('score',2092,'arhiva','gold','100.0000'),('submit_count',2092,'arhiva','gold','100.0000'),('score',2092,'arhiva','count','100.0000'),('submit_count',2092,'arhiva','count','100.0000'),('score',2524,'arhiva','avere','100.0000'),('submit_count',2524,'arhiva','avere','100.0000'),('score',2092,'arhiva','senat','100.0000'),('submit_count',2092,'arhiva','senat','100.0000'),('score',2092,'arhiva','cowfood','100.0000'),('submit_count',2092,'arhiva','cowfood','100.0000'),('score',1024,'arhiva','avere','100.0000'),('submit_count',1024,'arhiva','avere','100.0000'),('score',1024,'arhiva','nrtri','100.0000'),('submit_count',1024,'arhiva','nrtri','100.0000'),('score',2092,'arhiva','zc','100.0000'),('submit_count',2092,'arhiva','zc','100.0000'),('score',2524,'arhiva','petrica','100.0000'),('submit_count',2524,'arhiva','petrica','0.0000'),('score',2524,'arhiva','string','100.0000'),('submit_count',2524,'arhiva','string','100.0000'),('score',961,'arhiva','poly','100.0000'),('submit_count',961,'arhiva','poly','100.0000'),('score',1024,'arhiva','invsc','0.0000'),('submit_count',1024,'arhiva','invsc','0.0000'),('score',1024,'arhiva','triunghi','100.0000'),('submit_count',1024,'arhiva','triunghi','100.0000'),('score',2092,'arhiva','poligon','60.0000'),('submit_count',2092,'arhiva','poligon','60.0000'),('score',1024,'arhiva','catun','70.0000'),('submit_count',1024,'arhiva','catun','70.0000'),('score',1024,'arhiva','distante','100.0000'),('submit_count',1024,'arhiva','distante','100.0000'),('score',1024,'arhiva','patrate2','10.0000'),('submit_count',1024,'arhiva','patrate2','10.0000'),('score',1024,'arhiva','puternic','40.0000'),('submit_count',1024,'arhiva','puternic','40.0000'),('score',2092,'arhiva','sortnet','100.0000'),('submit_count',2092,'arhiva','sortnet','100.0000'),('score',142,'arhiva','soldati','100.0000'),('submit_count',142,'arhiva','soldati','100.0000'),('score',142,'arhiva','cifru','100.0000'),('submit_count',142,'arhiva','cifru','100.0000'),('score',1024,'arhiva','spirala','100.0000'),('submit_count',1024,'arhiva','spirala','100.0000'),('score',142,'arhiva','proc','100.0000'),('submit_count',142,'arhiva','proc','100.0000'),('score',142,'arhiva','eqs','100.0000'),('submit_count',142,'arhiva','eqs','100.0000'),('score',1024,'arhiva','alpin','100.0000'),('submit_count',1024,'arhiva','alpin','100.0000'),('score',1024,'arhiva','barbar','100.0000'),('submit_count',1024,'arhiva','barbar','100.0000'),('score',2092,'arhiva','patrate','100.0000'),('submit_count',2092,'arhiva','patrate','100.0000'),('score',2092,'happy2006','emm','100.0000'),('submit_count',2092,'happy2006','emm','100.0000'),('score',2092,'happy2006','int','100.0000'),('submit_count',2092,'happy2006','int','100.0000'),('score',2092,'happy2006','geometry','100.0000'),('submit_count',2092,'happy2006','geometry','100.0000'),('score',2092,'happy2006','rf','100.0000'),('submit_count',2092,'happy2006','rf','100.0000'),('score',1024,'happy2006','geometry','100.0000'),('submit_count',1024,'happy2006','geometry','100.0000'),('score',2524,'happy2006','int','100.0000'),('submit_count',2524,'happy2006','int','100.0000'),('score',2524,'happy2006','geometry','100.0000'),('submit_count',2524,'happy2006','geometry','100.0000'),('score',2524,'happy2006','emm','100.0000'),('submit_count',2524,'happy2006','emm','100.0000'),('score',1024,'happy2006','rf','100.0000'),('submit_count',1024,'happy2006','rf','100.0000'),('score',2524,'happy2006','rf','100.0000'),('submit_count',2524,'happy2006','rf','100.0000'),('score',2524,'happy2006','hanoi4','100.0000'),('submit_count',2524,'happy2006','hanoi4','100.0000'),('score',2092,'happy2006','1expr','100.0000'),('submit_count',2092,'happy2006','1expr','100.0000'),('score',1024,'happy2006','cc','0.0000'),('submit_count',1024,'happy2006','cc','0.0000'),('score',1024,'happy2006','noroc','20.0000'),('submit_count',1024,'happy2006','noroc','20.0000'),('score',2092,'happy2006','swap','100.0000'),('submit_count',2092,'happy2006','swap','100.0000'),('score',2986,'happy2006','noroc','90.0000'),('submit_count',2986,'happy2006','noroc','90.0000'),('score',2986,'happy2006','swap','10.0000'),('submit_count',2986,'happy2006','swap','10.0000'),('score',2986,'happy2006','joc3','5.0000'),('submit_count',2986,'happy2006','joc3','5.0000'),('score',142,'happy2006','geometry','100.0000'),('submit_count',142,'happy2006','geometry','100.0000'),('score',3369,'happy2006','geometry','100.0000'),('submit_count',3369,'happy2006','geometry','100.0000'),('score',142,'happy2006','hanoi4','100.0000'),('submit_count',142,'happy2006','hanoi4','100.0000'),('score',3369,'happy2006','rf','100.0000'),('submit_count',3369,'happy2006','rf','100.0000'),('score',3369,'happy2006','hanoi4','100.0000'),('submit_count',3369,'happy2006','hanoi4','100.0000'),('score',2986,'happy2006','hanoi4','100.0000'),('submit_count',2986,'happy2006','hanoi4','100.0000'),('score',2986,'happy2006','cc','10.0000'),('submit_count',2986,'happy2006','cc','10.0000'),('score',2092,'happy2006','itree','100.0000'),('submit_count',2092,'happy2006','itree','100.0000'),('score',142,'happy2006','emm','85.0000'),('submit_count',142,'happy2006','emm','85.0000'),('score',1024,'happy2006','int','100.0000'),('submit_count',1024,'happy2006','int','100.0000'),('score',2092,'happy2006','arbciclu','0.0000'),('submit_count',2092,'happy2006','arbciclu','0.0000'),('score',142,'happy2006','rf','100.0000'),('submit_count',142,'happy2006','rf','100.0000'),('score',1024,'happy2006','hanoi4','100.0000'),('submit_count',1024,'happy2006','hanoi4','100.0000'),('score',142,'happy2006','int','100.0000'),('submit_count',142,'happy2006','int','100.0000'),('score',2092,'happy2006','zeap','100.0000'),('submit_count',2092,'happy2006','zeap','100.0000'),('score',2524,'happy2006','swap','100.0000'),('submit_count',2524,'happy2006','swap','100.0000'),('score',2524,'happy2006','itree','40.0000'),('submit_count',2524,'happy2006','itree','40.0000'),('score',2524,'happy2006','noroc','100.0000'),('submit_count',2524,'happy2006','noroc','100.0000'),('score',75,'happy2006','noroc','100.0000'),('submit_count',75,'happy2006','noroc','100.0000'),('score',75,'happy2006','hanoi4','100.0000'),('submit_count',75,'happy2006','hanoi4','100.0000'),('score',75,'happy2006','cc','40.0000'),('submit_count',75,'happy2006','cc','40.0000'),('score',2092,'happy2006','cc','100.0000'),('submit_count',2092,'happy2006','cc','100.0000'),('score',142,'happy2006','swap','100.0000'),('submit_count',142,'happy2006','swap','100.0000'),('score',75,'happy2006','geometry','100.0000'),('submit_count',75,'happy2006','geometry','100.0000'),('score',75,'happy2006','itree','100.0000'),('submit_count',75,'happy2006','itree','100.0000'),('score',2092,'happy2006','hanoi4','100.0000'),('submit_count',2092,'happy2006','hanoi4','100.0000'),('score',3369,'happy2006','noroc','100.0000'),('submit_count',3369,'happy2006','noroc','100.0000'),('score',142,'happy2006','noroc','100.0000'),('submit_count',142,'happy2006','noroc','100.0000'),('score',2092,'happy2006','obj','100.0000'),('submit_count',2092,'happy2006','obj','100.0000'),('score',75,'happy2006','int','100.0000'),('submit_count',75,'happy2006','int','100.0000'),('score',75,'happy2006','rf','100.0000'),('submit_count',75,'happy2006','rf','100.0000'),('score',5083,'arhiva','cmmdc','100.0000'),('submit_count',5083,'arhiva','cmmdc','100.0000'),('score',5083,'arhiva','adunare','100.0000'),('submit_count',5083,'arhiva','adunare','100.0000'),('score',142,'happy2006','itree','100.0000'),('submit_count',142,'happy2006','itree','100.0000'),('score',1024,'happy2006','swap','10.0000'),('submit_count',1024,'happy2006','swap','10.0000'),('score',75,'happy2006','emm','100.0000'),('submit_count',75,'happy2006','emm','100.0000'),('score',2092,'happy2006','hprob','100.0000'),('submit_count',2092,'happy2006','hprob','100.0000'),('score',2092,'happy2006','java','0.0000'),('submit_count',2092,'happy2006','java','0.0000'),('score',3369,'happy2006','cc','100.0000'),('submit_count',3369,'happy2006','cc','100.0000'),('score',142,'happy2006','obj','100.0000'),('submit_count',142,'happy2006','obj','100.0000'),('score',2524,'happy2006','hprob','100.0000'),('submit_count',2524,'happy2006','hprob','100.0000'),('score',142,'happy2006','cc','100.0000'),('submit_count',142,'happy2006','cc','100.0000'),('score',3369,'happy2006','emm','45.0000'),('submit_count',3369,'happy2006','emm','45.0000'),('score',2092,'happy2006','avd','100.0000'),('submit_count',2092,'happy2006','avd','100.0000'),('score',3369,'happy2006','zeap','20.0000'),('submit_count',3369,'happy2006','zeap','20.0000'),('score',2092,'happy2006','noroc','100.0000'),('submit_count',2092,'happy2006','noroc','100.0000'),('score',2524,'happy2006','1expr','100.0000'),('submit_count',2524,'happy2006','1expr','100.0000'),('score',75,'happy2006','zeap','70.0000'),('submit_count',75,'happy2006','zeap','70.0000'),('score',75,'happy2006','swap','100.0000'),('submit_count',75,'happy2006','swap','100.0000'),('score',2986,'happy2006','geometry','10.0000'),('submit_count',2986,'happy2006','geometry','10.0000'),('score',2092,'happy2006','nodiv','100.0000'),('submit_count',2092,'happy2006','nodiv','100.0000'),('score',2524,'happy2006','avd','100.0000'),('submit_count',2524,'happy2006','avd','100.0000'),('score',142,'happy2006','zeap','0.0000'),('submit_count',142,'happy2006','zeap','0.0000'),('score',142,'happy2006','joc3','5.0000'),('submit_count',142,'happy2006','joc3','5.0000'),('score',75,'happy2006','hprob','100.0000'),('submit_count',75,'happy2006','hprob','100.0000'),('score',2092,'happy2006','joc3','100.0000'),('submit_count',2092,'happy2006','joc3','100.0000'),('score',18,'arhiva','noroc','100.0000'),('submit_count',18,'arhiva','noroc','100.0000'),('score',18,'arhiva','nodiv','50.0000'),('submit_count',18,'arhiva','nodiv','50.0000'),('score',2524,'arhiva','avd','100.0000'),('submit_count',2524,'arhiva','avd','100.0000'),('score',2524,'arhiva','swap','100.0000'),('submit_count',2524,'arhiva','swap','100.0000'),('score',2524,'arhiva','int','100.0000'),('submit_count',2524,'arhiva','int','100.0000'),('score',2524,'arhiva','1expr','100.0000'),('submit_count',2524,'arhiva','1expr','100.0000'),('score',2524,'arhiva','hanoi4','100.0000'),('submit_count',2524,'arhiva','hanoi4','100.0000'),('score',2524,'arhiva','geometry','100.0000'),('submit_count',2524,'arhiva','geometry','100.0000'),('score',2524,'arhiva','hprob','100.0000'),('submit_count',2524,'arhiva','hprob','100.0000'),('score',2524,'arhiva','rf','100.0000'),('submit_count',2524,'arhiva','rf','100.0000'),('score',2524,'arhiva','emm','100.0000'),('submit_count',2524,'arhiva','emm','100.0000'),('score',2524,'arhiva','noroc','100.0000'),('submit_count',2524,'arhiva','noroc','100.0000'),('score',1,'arhiva','zeap','100.0000'),('submit_count',1,'arhiva','zeap','100.0000'),('score',1,'arhiva','arbciclu','100.0000'),('submit_count',1,'arhiva','arbciclu','100.0000'),('score',1,'arhiva','java','100.0000'),('submit_count',1,'arhiva','java','100.0000'),('score',142,'arhiva','fractii','100.0000'),('submit_count',142,'arhiva','fractii','100.0000'),('score',66,'arhiva','joc3','100.0000'),('submit_count',66,'arhiva','joc3','100.0000'),('score',961,'arhiva','avd','100.0000'),('submit_count',961,'arhiva','avd','100.0000'),('score',961,'arhiva','noroc','100.0000'),('submit_count',961,'arhiva','noroc','100.0000'),('score',961,'arhiva','emm','100.0000'),('submit_count',961,'arhiva','emm','100.0000'),('score',961,'arhiva','itree','100.0000'),('submit_count',961,'arhiva','itree','100.0000'),('score',961,'arhiva','rf','100.0000'),('submit_count',961,'arhiva','rf','100.0000'),('score',2092,'arhiva','noroc','100.0000'),('submit_count',2092,'arhiva','noroc','100.0000'),('score',2092,'arhiva','zeap','100.0000'),('submit_count',2092,'arhiva','zeap','100.0000'),('score',2092,'arhiva','emm','100.0000'),('submit_count',2092,'arhiva','emm','100.0000'),('score',2092,'arhiva','rf','100.0000'),('submit_count',2092,'arhiva','rf','100.0000'),('score',2092,'arhiva','nodiv','100.0000'),('submit_count',2092,'arhiva','nodiv','100.0000'),('score',2092,'arhiva','hprob','100.0000'),('submit_count',2092,'arhiva','hprob','100.0000'),('score',2092,'arhiva','itree','100.0000'),('submit_count',2092,'arhiva','itree','100.0000'),('score',2092,'arhiva','geometry','100.0000'),('submit_count',2092,'arhiva','geometry','100.0000'),('score',2092,'arhiva','joc3','100.0000'),('submit_count',2092,'arhiva','joc3','100.0000'),('score',2092,'arhiva','cc','100.0000'),('submit_count',2092,'arhiva','cc','100.0000'),('score',2092,'arhiva','hanoi4','100.0000'),('submit_count',2092,'arhiva','hanoi4','100.0000'),('score',2092,'arhiva','1expr','100.0000'),('submit_count',2092,'arhiva','1expr','100.0000'),('score',2092,'arhiva','obj','100.0000'),('submit_count',2092,'arhiva','obj','100.0000'),('score',2092,'arhiva','int','100.0000'),('submit_count',2092,'arhiva','int','100.0000'),('score',2092,'arhiva','avd','100.0000'),('submit_count',2092,'arhiva','avd','100.0000'),('score',2092,'arhiva','swap','100.0000'),('submit_count',2092,'arhiva','swap','100.0000'),('score',961,'arhiva','swap','100.0000'),('submit_count',961,'arhiva','swap','100.0000'),('score',1024,'arhiva','rf','100.0000'),('submit_count',1024,'arhiva','rf','100.0000'),('score',1024,'arhiva','geometry','100.0000'),('submit_count',1024,'arhiva','geometry','100.0000'),('score',1024,'arhiva','hanoi4','100.0000'),('submit_count',1024,'arhiva','hanoi4','100.0000'),('score',1024,'arhiva','int','100.0000'),('submit_count',1024,'arhiva','int','100.0000'),('score',961,'arhiva','hanoi4','100.0000'),('submit_count',961,'arhiva','hanoi4','100.0000'),('score',1024,'arhiva','noroc','100.0000'),('submit_count',1024,'arhiva','noroc','100.0000'),('score',5147,'arhiva','adunare','100.0000'),('submit_count',5147,'arhiva','adunare','100.0000'),('score',256,'arhiva','avd','100.0000'),('submit_count',256,'arhiva','avd','100.0000'),('score',256,'arhiva','ct','100.0000'),('submit_count',256,'arhiva','ct','100.0000'),('score',256,'arhiva','swap','100.0000'),('submit_count',256,'arhiva','swap','100.0000'),('score',256,'arhiva','int','100.0000'),('submit_count',256,'arhiva','int','100.0000'),('score',256,'arhiva','1expr','100.0000'),('submit_count',256,'arhiva','1expr','100.0000'),('score',256,'arhiva','hanoi4','100.0000'),('submit_count',256,'arhiva','hanoi4','100.0000'),('score',256,'arhiva','geometry','100.0000'),('submit_count',256,'arhiva','geometry','100.0000'),('score',256,'arhiva','nodiv','100.0000'),('submit_count',256,'arhiva','nodiv','100.0000'),('score',256,'arhiva','rf','100.0000'),('submit_count',256,'arhiva','rf','100.0000'),('score',256,'arhiva','emm','100.0000'),('submit_count',256,'arhiva','emm','100.0000'),('score',256,'arhiva','zeap','100.0000'),('submit_count',256,'arhiva','zeap','100.0000'),('score',256,'arhiva','hprob','100.0000'),('submit_count',256,'arhiva','hprob','100.0000'),('score',2092,'arhiva','ct','100.0000'),('submit_count',2092,'arhiva','ct','100.0000'),('score',48,'arhiva','colorare','100.0000'),('submit_count',48,'arhiva','colorare','100.0000'),('score',2092,'arhiva','arbciclu','100.0000'),('submit_count',2092,'arhiva','arbciclu','100.0000'),('score',2524,'arhiva','itree','90.0000'),('submit_count',2524,'arhiva','itree','90.0000'),('score',2092,'arhiva','otilia','100.0000'),('submit_count',2092,'arhiva','otilia','100.0000'),('score',1024,'arhiva','linterv','0.0000'),('submit_count',1024,'arhiva','linterv','0.0000'),('score',2524,'arhiva','perle','100.0000'),('submit_count',2524,'arhiva','perle','100.0000'),('score',2524,'arhiva','bool','100.0000'),('submit_count',2524,'arhiva','bool','100.0000'),('score',1024,'arhiva','swap','10.0000'),('submit_count',1024,'arhiva','swap','10.0000'),('score',2092,'arhiva','tribute','100.0000'),('submit_count',2092,'arhiva','tribute','100.0000'),('score',2092,'arhiva','base3','100.0000'),('submit_count',2092,'arhiva','base3','100.0000'),('score',1024,'arhiva','cerere','100.0000'),('submit_count',1024,'arhiva','cerere','100.0000'),('score',961,'arhiva','nodiv','100.0000'),('submit_count',961,'arhiva','nodiv','100.0000'),('score',961,'arhiva','geometry','100.0000'),('submit_count',961,'arhiva','geometry','100.0000'),('score',1024,'arhiva','datorii','100.0000'),('submit_count',1024,'arhiva','datorii','0.0000'),('score',961,'arhiva','cc','100.0000'),('submit_count',961,'arhiva','cc','100.0000'),('score',3369,'arhiva','minim','100.0000'),('submit_count',3369,'arhiva','minim','100.0000'),('score',961,'arhiva','int','100.0000'),('submit_count',961,'arhiva','int','100.0000'),('score',256,'arhiva','sortnet','100.0000'),('submit_count',256,'arhiva','sortnet','100.0000'),('score',256,'arhiva','algola','100.0000'),('submit_count',256,'arhiva','algola','100.0000'),('score',256,'arhiva','treid','85.0000'),('submit_count',256,'arhiva','treid','85.0000'),('score',2092,'arhiva','iv','100.0000'),('submit_count',2092,'arhiva','iv','100.0000'),('score',256,'arhiva','domino','100.0000'),('submit_count',256,'arhiva','domino','100.0000'),('score',1024,'arhiva','senat','100.0000'),('submit_count',1024,'arhiva','senat','100.0000'),('score',1024,'arhiva','harta','100.0000'),('submit_count',1024,'arhiva','harta','100.0000'),('score',256,'arhiva','apdm','80.0000'),('submit_count',256,'arhiva','apdm','80.0000'),('score',142,'arhiva','calatorie','100.0000'),('submit_count',142,'arhiva','calatorie','100.0000'),('score',142,'arhiva','password','90.0000'),('submit_count',142,'arhiva','password','90.0000'),('score',1,'arhiva','noroc','100.0000'),('submit_count',1,'arhiva','noroc','100.0000'),('score',1,'arhiva','emm','100.0000'),('submit_count',1,'arhiva','emm','100.0000'),('score',1,'arhiva','rf','100.0000'),('submit_count',1,'arhiva','rf','100.0000'),('score',1,'arhiva','nodiv','100.0000'),('submit_count',1,'arhiva','nodiv','100.0000'),('score',1,'arhiva','geometry','100.0000'),('submit_count',1,'arhiva','geometry','100.0000'),('score',1,'arhiva','hanoi4','100.0000'),('submit_count',1,'arhiva','hanoi4','100.0000'),('score',961,'arhiva','java','100.0000'),('submit_count',961,'arhiva','java','100.0000'),('score',961,'arhiva','hprob','100.0000'),('submit_count',961,'arhiva','hprob','100.0000'),('score',961,'arhiva','bridge','100.0000'),('submit_count',961,'arhiva','bridge','100.0000'),('score',961,'arhiva','joc3','100.0000'),('submit_count',961,'arhiva','joc3','100.0000'),('score',961,'arhiva','obj','100.0000'),('submit_count',961,'arhiva','obj','100.0000'),('score',961,'arhiva','note','100.0000'),('submit_count',961,'arhiva','note','100.0000'),('score',961,'arhiva','bilete','100.0000'),('submit_count',961,'arhiva','bilete','100.0000'),('score',961,'arhiva','catun','100.0000'),('submit_count',961,'arhiva','catun','100.0000'),('score',961,'arhiva','senat','100.0000'),('submit_count',961,'arhiva','senat','100.0000'),('score',961,'arhiva','euler','100.0000'),('submit_count',961,'arhiva','euler','100.0000'),('score',961,'arhiva','abc','100.0000'),('submit_count',961,'arhiva','abc','100.0000'),('score',1024,'arhiva','pscnv','70.0000'),('submit_count',1024,'arhiva','pscnv','70.0000'),('score',1,'arhiva','swap','100.0000'),('submit_count',1,'arhiva','swap','100.0000'),('score',1,'arhiva','int','100.0000'),('submit_count',1,'arhiva','int','100.0000'),('score',1024,'arhiva','trapez','100.0000'),('submit_count',1024,'arhiva','trapez','100.0000'),('score',142,'arhiva','jocul','100.0000'),('submit_count',142,'arhiva','jocul','100.0000'),('score',1024,'arhiva','iepuri','40.0000'),('submit_count',1024,'arhiva','iepuri','0.0000'),('score',1024,'arhiva','lanterna','100.0000'),('submit_count',1024,'arhiva','lanterna','100.0000'),('score',961,'arhiva','vila','100.0000'),('submit_count',961,'arhiva','vila','100.0000'),('score',2092,'arhiva','geom','100.0000'),('submit_count',2092,'arhiva','geom','100.0000'),('score',2092,'arhiva','java','100.0000'),('submit_count',2092,'arhiva','java','100.0000'),('score',1024,'arhiva','cutii','100.0000'),('submit_count',1024,'arhiva','cutii','100.0000'),('score',2986,'unirea9-10','maxsecv','10.0000'),('rating',1024,'preoni62a',NULL,'1367.8280'),('rating',1024,'preoni62b',NULL,'1348.6905'),('deviation',1024,'preoni62b',NULL,'40.7245'),('rating',2524,'preoni62b',NULL,'1517.5468'),('deviation',2524,'preoni62b',NULL,'36.3463'),('rating',75,'preoni61c',NULL,'1483.3736'),('deviation',75,'preoni61c',NULL,'33.2570'),('rating',1503,'preoni61c',NULL,'1386.3769'),('deviation',1503,'preoni61c',NULL,'36.5474'),('rating',2524,'preoni61b',NULL,'1565.0706'),('deviation',2524,'preoni61b',NULL,'36.4912'),('rating',1503,'preoni61b',NULL,'1388.6309'),('deviation',1503,'preoni61b',NULL,'37.2432'),('rating',2092,'preoni62c',NULL,'1640.8282'),('deviation',2092,'preoni62c',NULL,'41.0066'),('rating',75,'preoni62c',NULL,'1518.2624'),('deviation',75,'preoni62c',NULL,'41.0961'),('rating',2092,'preoni61c',NULL,'1607.0114'),('deviation',2092,'preoni61c',NULL,'34.2007'),('rating',1503,'preoni61a',NULL,'1436.3854'),('deviation',1503,'preoni61a',NULL,'60.4442'),('rating',2986,'preoni61a',NULL,'1461.2512'),('deviation',2986,'preoni61a',NULL,'53.4655'),('rating',1142,'hc2',NULL,'1606.6233'),('deviation',1142,'hc2',NULL,'33.1444'),('rating',18,'hc2',NULL,'1545.0822'),('deviation',18,'hc2',NULL,'29.5068'),('rating',970,'hc2',NULL,'1634.2620'),('deviation',970,'hc2',NULL,'31.0892'),('rating',93,'hc2',NULL,'1589.5525'),('deviation',93,'hc2',NULL,'30.4826'),('rating',2524,'hc2',NULL,'1505.8203'),('deviation',2524,'hc2',NULL,'30.9092'),('rating',2092,'hc2',NULL,'1541.6299'),('deviation',2092,'hc2',NULL,'29.9951'),('rating',142,'hc2',NULL,'1517.4498'),('deviation',142,'hc2',NULL,'31.1504'),('score',5695,'arhiva','fact','55.0000'),('rating',1024,'preoni53a',NULL,'1337.6751'),('deviation',1024,'preoni53a',NULL,'40.2393'),('rating',961,'preoni53b',NULL,'1768.5063'),('deviation',961,'preoni53b',NULL,'47.3255'),('rating',66,'preoni53b',NULL,'1678.7415'),('deviation',66,'preoni53b',NULL,'45.8188'),('rating',142,'preoni53b',NULL,'1583.1682'),('deviation',142,'preoni53b',NULL,'45.4143'),('rating',18,'happy',NULL,'1636.2695'),('deviation',18,'happy',NULL,'37.8148'),('rating',58,'happy',NULL,'1703.7924'),('deviation',58,'happy',NULL,'39.8171'),('rating',970,'happy',NULL,'1604.6320'),('deviation',970,'happy',NULL,'35.2883'),('rating',961,'happy',NULL,'1772.6442'),('deviation',961,'happy',NULL,'41.7447'),('rating',93,'happy',NULL,'1581.1010'),('deviation',93,'happy',NULL,'34.9958'),('rating',2092,'happy',NULL,'1550.0219'),('deviation',2092,'happy',NULL,'34.6431'),('score',5695,'arhiva','cifra','100.0000'),('score',1024,'arhiva','patrate3','45.0000'),('rating',3369,'happy2006',NULL,'1471.5524'),('deviation',3369,'happy2006',NULL,'40.0326'),('score',2524,'unirea11-12','amenzi','90.0000'),('score',75,'unirea11-12','secv5','80.0000'),('score',256,'arhiva','euro','100.0000'),('score',18,'arhiva','aprindere','100.0000'),('score',18,'arhiva','triplete','100.0000'),('rating',66,'happy',NULL,'1593.9590'),('deviation',66,'happy',NULL,'35.5048'),('rating',256,'preoni53a',NULL,'1758.8933'),('deviation',256,'preoni53a',NULL,'41.4781'),('rating',142,'preoni53a',NULL,'1717.4653'),('deviation',142,'preoni53a',NULL,'40.7357'),('rating',75,'preoni53a',NULL,'1641.7867'),('deviation',75,'preoni53a',NULL,'38.3085'),('rating',1975,'preoni53a',NULL,'1495.9721'),('deviation',1975,'preoni53a',NULL,'43.8855'),('rating',1503,'preoni53a',NULL,'1437.5944'),('deviation',1503,'preoni53a',NULL,'38.9323'),('score',1142,'arhiva','12perm','0.0000'),('score',1142,'arhiva','noroc','100.0000'),('score',1142,'arhiva','adapost','0.0000'),('score',1142,'arhiva','acolor','0.0000'),('score',1142,'arhiva','alpin','0.0000'),('score',1142,'arhiva','apdm','0.0000'),('score',15,'arhiva','adunare','0.0000'),('score',1142,'arhiva','expr','100.0000'),('rating',1503,'preoni52a',NULL,'1420.0712'),('deviation',1503,'preoni52a',NULL,'31.2472'),('rating',1689,'preoni52a',NULL,'1492.7040'),('deviation',1689,'preoni52a',NULL,'31.9399'),('rating',1024,'preoni52a',NULL,'1365.6549'),('deviation',1024,'preoni52a',NULL,'33.4709'),('rating',256,'preoni52a',NULL,'1734.3046'),('deviation',256,'preoni52a',NULL,'37.3132'),('rating',75,'preoni52a',NULL,'1641.4316'),('deviation',75,'preoni52a',NULL,'32.4129'),('deviation',1696,'preoni52b',NULL,'38.7399'),('rating',1696,'preoni52b',NULL,'1439.5625'),('rating',142,'preoni52b',NULL,'1703.5762'),('deviation',142,'preoni52b',NULL,'40.0967'),('rating',961,'preoni52b',NULL,'1681.6924'),('deviation',961,'preoni52b',NULL,'39.9473'),('rating',66,'preoni52b',NULL,'1604.4519'),('deviation',66,'preoni52b',NULL,'38.8395'),('rating',142,'preoni51b',NULL,'1598.2123'),('deviation',142,'preoni51b',NULL,'40.7358'),('rating',66,'preoni51b',NULL,'1569.9588'),('deviation',66,'preoni51b',NULL,'49.7950'),('rating',961,'preoni51b',NULL,'1560.2476'),('deviation',961,'preoni51b',NULL,'46.7829'),('rating',1024,'preoni51a',NULL,'1352.7910'),('deviation',1024,'preoni51a',NULL,'39.4143'),('rating',1142,'preoni51b',NULL,'1821.9174'),('deviation',1142,'preoni51b',NULL,'53.8024'),('rating',142,'preoni51a',NULL,'1543.4908'),('deviation',142,'preoni51a',NULL,'38.3663'),('rating',75,'preoni51a',NULL,'1563.8511'),('deviation',75,'preoni51a',NULL,'40.1683'),('rating',1287,'preoni51a',NULL,'1435.9974'),('deviation',1287,'preoni51a',NULL,'37.8247'),('rating',1024,'filip1',NULL,'1437.2021'),('deviation',1024,'filip1',NULL,'47.7789'),('rating',1142,'filip2',NULL,'1732.7076'),('deviation',1142,'filip2',NULL,'57.0814'),('rating',961,'filip2',NULL,'1526.6445'),('deviation',961,'filip2',NULL,'54.9248'),('deviation',13,'preoni4',NULL,'50.9790'),('rating',58,'preoni4',NULL,'1654.8180'),('deviation',58,'preoni4',NULL,'56.1504'),('rating',1,'preoni4',NULL,'1752.6242'),('deviation',1,'preoni4',NULL,'50.3204'),('rating',75,'preoni3',NULL,'1537.0081'),('deviation',75,'preoni3',NULL,'40.3086'),('rating',13,'preoni4',NULL,'1760.1443'),('rating',1,'preoni3',NULL,'1733.8166'),('deviation',1,'preoni3',NULL,'49.2766'),('rating',256,'preoni3',NULL,'1622.8629'),('deviation',256,'preoni3',NULL,'41.0683'),('rating',18,'preoni2',NULL,'1532.8475'),('deviation',18,'preoni2',NULL,'51.3592'),('rating',18,'preoji1',NULL,'1629.8511'),('deviation',18,'preoji1',NULL,'61.1837'),('rating',48,'preoji1',NULL,'1616.5849'),('deviation',48,'preoji1',NULL,'61.1421'),('rating',13,'preoji1',NULL,'1584.7481'),('deviation',13,'preoji1',NULL,'61.0012'),('rating',75,'preoji1',NULL,'1578.2677'),('deviation',75,'preoji1',NULL,'60.9806'),('rating',75,'preoni1',NULL,'1622.0567'),('deviation',75,'preoni1',NULL,'38.8438'),('rating',256,'preoni1',NULL,'1575.0998'),('deviation',256,'preoni1',NULL,'38.6032'),('rating',66,'preoni1',NULL,'1548.1738'),('deviation',66,'preoni1',NULL,'38.3915'),('rating',76,'preoni1',NULL,'1459.1444'),('deviation',76,'preoni1',NULL,'38.1351'),('rating',13,'preoni2',NULL,'1666.4757'),('deviation',13,'preoni2',NULL,'52.6221'),('score',2092,'arhiva','triplete','100.0000'),('score',2092,'arhiva','pachete','100.0000'),('score',256,'arhiva','radiatie','100.0000'),('score',256,'arhiva','1-sir','100.0000'),('score',2092,'arhiva','radiatie','100.0000'),('score',2092,'arhiva','elimin','100.0000'),('score',2092,'arhiva','aprindere','100.0000'),('score',2092,'arhiva','patrate3','100.0000'),('score',2092,'arhiva','domino','100.0000'),('rating',75,'unirea11-12',NULL,'1664.0691'),('deviation',1024,'preoni62a',NULL,'43.7548'),('rating',2986,'preoni62a',NULL,'1433.7098'),('deviation',2986,'preoni62a',NULL,'44.3948'),('score',2092,'arhiva','bcolor','100.0000'),('score',2092,'arhiva','plimbare','100.0000'),('score',2524,'arhiva','adn','100.0000'),('score',2524,'arhiva','hallway','90.0000'),('score',2524,'arhiva','prefix','100.0000'),('score',256,'arhiva','geom','95.0000'),('score',2092,'arhiva','caraibe','100.0000'),('score',2092,'arhiva','colorare','100.0000'),('score',2092,'arhiva','dame','100.0000'),('score',2092,'arhiva','graf','100.0000'),('score',2092,'arhiva','invsort','100.0000'),('score',2092,'arhiva','soldati','100.0000'),('score',2524,'arhiva','tj','100.0000'),('score',256,'arhiva','dmg','100.0000'),('score',256,'arhiva','cc','100.0000'),('score',2524,'arhiva','substr','90.0000'),('score',1,'arhiva','cc','100.0000'),('score',1,'arhiva','pscpld','100.0000'),('score',1,'arhiva','plimbare','100.0000'),('score',256,'arhiva','adapost','0.0000'),('score',1,'arhiva','abc','100.0000'),('score',1024,'arhiva','euler','100.0000'),('score',75,'arhiva','joc3','100.0000'),('score',2524,'arhiva','joc3','5.0000'),('score',256,'arhiva','game','100.0000'),('score',256,'arhiva','doipatru','100.0000'),('score',256,'arhiva','soc','100.0000'),('score',256,'arhiva','telegraf','100.0000'),('score',256,'arhiva','joc3','100.0000'),('score',2092,'arhiva','patrol','100.0000'),('score',256,'arhiva','pawns','100.0000'),('score',1,'arhiva','avd','100.0000'),('score',256,'arhiva','points','100.0000'),('score',2092,'arhiva','soc','100.0000'),('score',1,'arhiva','bcolor','100.0000'),('score',1,'arhiva','bridge','100.0000'),('score',1,'arhiva','secv4','100.0000'),('score',1,'arhiva','joc3','100.0000'),('score',1,'arhiva','hprob','100.0000'),('score',1,'arhiva','ct','100.0000'),('score',1142,'arhiva','barman','0.0000'),('score',1024,'arhiva','subsir2','100.0000'),('score',3369,'arhiva','divmul','0.0000'),('score',2092,'arhiva','ecu','100.0000'),('score',1,'arhiva','obj','100.0000'),('score',1,'arhiva','itree','100.0000'),('score',1,'arhiva','eq','100.0000'),('score',1,'arhiva','1expr','100.0000'),('score',2092,'arhiva','colectie','100.0000'),('score',1142,'arhiva','nr','0.0000'),('score',1,'arhiva','nr','100.0000'),('score',2092,'arhiva','nr','100.0000'),('score',1,'arhiva','perm4','100.0000'),('score',2092,'arhiva','perm4','100.0000'),('score',1,'arhiva','criptare','100.0000'),('score',961,'arhiva','perm4','100.0000'),('score',5695,'arhiva','adunare','100.0000'),('score',5695,'arhiva','cmmdc','100.0000'),('score',2524,'arhiva','perm4','100.0000'),('score',2524,'arhiva','nr','100.0000'),('score',961,'arhiva','zeap','70.0000'),('score',256,'arhiva','elimin','100.0000'),('score',256,'arhiva','diviz','100.0000'),('score',1,'arhiva','pachete','100.0000'),('score',256,'arhiva','pachete','100.0000'),('score',256,'arhiva','nr','80.0000'),('score',256,'arhiva','perm4','100.0000'),('score',66,'arhiva','1-sir','100.0000'),('score',48,'arhiva','aprindere','100.0000'),('score',1,'arhiva','Radiatie','100.0000'),('score',48,'arhiva','patrate3','100.0000'),('score',1024,'arhiva','string','80.0000'),('score',1,'arhiva','triplete','100.0000'),('score',256,'arhiva','patrate3','100.0000'),('score',2524,'preoni2007_runda1_1112','1-sir','0.0000'),('score',2092,'preoni2007_runda1_1112','diviz','80.0000'),('score',2986,'preoni2007_runda1_10','pachete','0.0000'),('score',142,'preoni2007_runda1_10','triplete','20.0000'),('score',2524,'preoni2007_runda1_1112','diviz','90.0000'),('score',2986,'preoni2007_runda1_10','triplete','0.0000'),('score',2092,'preoni2007_runda1_1112','1-sir','30.0000'),('score',2986,'preoni2007_runda1_10','elimin','0.0000'),('score',2524,'preoni2007_runda1_1112','radiatie','30.0000'),('score',142,'preoni2007_runda1_10','pachete','0.0000'),('score',2092,'preoni2007_runda1_1112','radiatie','40.0000'),('score',142,'preoni2007_runda1_10','elimin','30.0000'),('score',1024,'preoni2007_runda1_1112','radiatie','0.0000'),('score',1,'arhiva','elimin','100.0000'),('rating',1024,'happy2006',NULL,'1451.9762'),('deviation',1024,'happy2006',NULL,'43.6640'),('rating',142,'preoni63a',NULL,'1511.1053'),('deviation',142,'preoni63a',NULL,'49.3393'),('rating',2092,'preoni63c',NULL,'1753.2896'),('deviation',2092,'preoni63c',NULL,'47.3005'),('rating',2524,'preoni64b',NULL,'1659.8445'),('deviation',2524,'preoni64b',NULL,'43.5773'),('rating',2986,'preoni64a',NULL,'1407.9722'),('deviation',2986,'preoni64a',NULL,'55.6791'),('rating',2092,'preoni64c',NULL,'1656.3436'),('deviation',2092,'preoni64c',NULL,'46.1102'),('rating',75,'preoni64c',NULL,'1520.3233'),('deviation',75,'preoni64c',NULL,'52.9546'),('rating',142,'preoni65a',NULL,'1510.3070'),('deviation',142,'preoni65a',NULL,'57.9017'),('rating',2524,'preoni65b',NULL,'1806.4263'),('deviation',2524,'preoni65b',NULL,'54.9314'),('rating',75,'preoni65c',NULL,'1698.6075'),('deviation',75,'preoni65c',NULL,'59.5543'),('rating',2092,'preoni65c',NULL,'1662.8605'),('deviation',2092,'preoni65c',NULL,'56.3137'),('rating',2524,'moisil3',NULL,'1819.6373'),('deviation',2524,'moisil3',NULL,'47.4668'),('rating',1024,'moisil3',NULL,'1419.2619'),('deviation',1024,'moisil3',NULL,'49.7640'),('rating',75,'moisil4',NULL,'1711.9217'),('deviation',75,'moisil4',NULL,'47.2223'),('rating',2092,'moisil4',NULL,'1686.1669'),('deviation',2092,'moisil4',NULL,'46.4882'),('rating',142,'moisil2',NULL,'1680.8120'),('deviation',142,'moisil2',NULL,'50.8546'),('rating',2986,'moisil2',NULL,'1459.5703'),('deviation',2986,'moisil2',NULL,'53.7890'),('rating',66,'summer06',NULL,'1859.2661'),('deviation',66,'summer06',NULL,'55.0763'),('rating',1,'summer06',NULL,'1929.3921'),('deviation',1,'summer06',NULL,'58.1990'),('rating',2524,'summer06',NULL,'1731.6456'),('deviation',2524,'summer06',NULL,'49.9889'),('rating',75,'summer06',NULL,'1590.4162'),('deviation',75,'summer06',NULL,'45.9776'),('rating',2092,'summer06',NULL,'1512.9854'),('deviation',2092,'summer06',NULL,'44.3756'),('rating',1,'summer2',NULL,'2022.7086'),('deviation',1,'summer2',NULL,'52.3292'),('rating',18,'summer2',NULL,'1893.0300'),('deviation',18,'summer2',NULL,'60.5933'),('rating',2524,'summer2',NULL,'1702.2410'),('deviation',2524,'summer2',NULL,'44.5970'),('rating',75,'summer2',NULL,'1495.7801'),('deviation',75,'summer2',NULL,'43.0510'),('rating',2524,'summer3',NULL,'1805.4550'),('deviation',2524,'summer3',NULL,'48.5510'),('rating',2092,'autumn06',NULL,'1668.7790'),('deviation',2092,'autumn06',NULL,'40.2690'),('rating',2524,'autumn06',NULL,'1854.8137'),('deviation',2524,'autumn06',NULL,'42.4006'),('rating',1024,'autumn06',NULL,'1451.9762'),('deviation',1024,'autumn06',NULL,'43.6640'),('rating',3369,'autumn06',NULL,'1471.5524'),('deviation',3369,'autumn06',NULL,'40.0326'),('rating',1503,'autumn06',NULL,'1390.9364'),('deviation',1503,'autumn06',NULL,'45.1736'),('rating',75,'autumn06',NULL,'1465.9921'),('deviation',75,'autumn06',NULL,'36.1664'),('rating',2092,'happy2006',NULL,'1668.7790'),('deviation',2092,'happy2006',NULL,'40.2690'),('rating',2524,'happy2006',NULL,'1854.8137'),('deviation',2524,'happy2006',NULL,'42.4006'),('rating',75,'happy2006',NULL,'1465.9921'),('deviation',75,'happy2006',NULL,'36.1664'),('rating',142,'happy2006',NULL,'1680.8120'),('deviation',142,'happy2006',NULL,'50.8546'),('rating',2524,'preoni63b',NULL,'1538.0927'),('deviation',2524,'preoni63b',NULL,'40.9594'),('score',2524,'arhiva','elimin','0.0000'),('score',2524,'arhiva','1-sir','80.0000'),('score',1,'arhiva','1-sir','100.0000'),('score',2092,'arhiva','1-sir','100.0000'),('deviation',75,'unirea11-12',NULL,'31.3907'),('rating',2986,'happy2006',NULL,'1459.5703'),('deviation',2986,'happy2006',NULL,'53.7890'),('score',1,'arhiva','aprindere','100.0000'),('score',2092,'arhiva','diviz','100.0000'),('score',256,'arhiva','triplete','100.0000'),('score',256,'arhiva','aprindere','100.0000'),('rating',142,'preoni61a',NULL,'1540.9284'),('deviation',142,'preoni61a',NULL,'44.1985'),('rating',1024,'hc2',NULL,'1332.4250'),('deviation',1024,'hc2',NULL,'34.6178'),('rating',75,'hc2',NULL,'1523.6491'),('deviation',75,'hc2',NULL,'30.9106'),('rating',1024,'preoni2007_runda1_1112',NULL,'1448.7169'),('deviation',1024,'preoni2007_runda1_1112',NULL,'39.3789'),('rating',142,'preoni2007_runda1_10',NULL,'1651.2423'),('deviation',142,'preoni2007_runda1_10',NULL,'52.0253'),('rating',2986,'preoni2007_runda1_10',NULL,'1432.2615'),('deviation',2986,'preoni2007_runda1_10',NULL,'48.8343'),('rating',2092,'preoni2007_runda1_1112',NULL,'1789.0718'),('deviation',2092,'preoni2007_runda1_1112',NULL,'44.4211'),('rating',2524,'preoni2007_runda1_1112',NULL,'1894.7770'),('deviation',2524,'preoni2007_runda1_1112',NULL,'46.7320'),('score',2092,'unirea11-12','secv5','10.0000'),('score',142,'unirea9-10','chernel','30.0000'),('score',142,'unirea9-10','maxsecv','100.0000'),('score',2524,'unirea11-12','secv5','0.0000'),('score',75,'unirea11-12','amenzi','100.0000'),('score',2092,'unirea11-12','amenzi','100.0000'),('score',1024,'unirea11-12','secv5','0.0000'),('score',1689,'unirea11-12','secv5','0.0000'),('rating',2092,'unirea11-12',NULL,'1838.0802'),('deviation',2092,'unirea11-12',NULL,'33.5129'),('rating',2524,'unirea11-12',NULL,'1927.9188'),('deviation',2524,'unirea11-12',NULL,'34.5210'),('rating',1689,'unirea11-12',NULL,'1497.5444'),('deviation',1689,'unirea11-12',NULL,'30.7598'),('rating',1024,'unirea11-12',NULL,'1460.0799'),('deviation',1024,'unirea11-12',NULL,'28.0853'),('rating',1503,'unirea11-12',NULL,'1408.8107'),('deviation',1503,'unirea11-12',NULL,'30.9543'),('rating',5292,'unirea11-12',NULL,'1482.0011'),('deviation',5292,'unirea11-12',NULL,'29.0447'),('rating',142,'unirea9-10',NULL,'1686.1941'),('deviation',142,'unirea9-10',NULL,'26.9925'),('rating',2986,'unirea9-10',NULL,'1440.0425'),('deviation',2986,'unirea9-10',NULL,'25.0280'),('rating',5855,'unirea9-10',NULL,'1431.0333'),('deviation',5855,'unirea9-10',NULL,'25.0265'),('score',1689,'arhiva','secv5','0.0000'),('score',75,'arhiva','secv5','80.0000'),('score',75,'arhiva','amenzi','100.0000'),('score',75,'arhiva','sume','100.0000'),('score',1689,'arhiva','adunare','100.0000'),('score',18,'arhiva','chernel','100.0000'),('score',2092,'arhiva','secv5','100.0000'),('score',2092,'arhiva','amenzi','100.0000'),('score',2092,'arhiva','chernel','100.0000'),('score',2092,'arhiva','maxsecv','100.0000'),('score',256,'arhiva','maxsecv','100.0000'),('score',256,'arhiva','chernel','100.0000'),('score',256,'arhiva','amenzi','100.0000'),('score',2524,'arhiva','amenzi','90.0000'),('score',2524,'arhiva','maxsecv','100.0000'),('score',1,'arhiva','maxsecv','100.0000'),('score',1,'arhiva','amenzi','100.0000'),('score',1,'arhiva','chernel','100.0000'),('score',1,'arhiva','secv5','100.0000');
/*!40000 ALTER TABLE `ia_score` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_attachments`
--

DROP TABLE IF EXISTS `ia_smf_attachments`;
CREATE TABLE `ia_smf_attachments` (
  `ID_ATTACH` int(10) unsigned NOT NULL auto_increment,
  `ID_THUMB` int(10) unsigned NOT NULL default '0',
  `ID_MSG` int(10) unsigned NOT NULL default '0',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `filename` tinytext collate latin1_general_ci NOT NULL,
  `size` int(10) unsigned NOT NULL default '0',
  `downloads` mediumint(8) unsigned NOT NULL default '0',
  `attachmentType` tinyint(3) unsigned NOT NULL default '0',
  `width` mediumint(8) unsigned NOT NULL default '0',
  `height` mediumint(8) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_ATTACH`),
  UNIQUE KEY `ID_MEMBER` (`ID_MEMBER`,`ID_ATTACH`),
  KEY `ID_MSG` (`ID_MSG`)
) ENGINE=MyISAM AUTO_INCREMENT=172 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_attachments`
--

LOCK TABLES `ia_smf_attachments` WRITE;
/*!40000 ALTER TABLE `ia_smf_attachments` DISABLE KEYS */;
INSERT INTO `ia_smf_attachments` VALUES (143,0,0,3,'avatar_3.png',16060,5574,0,100,74),(2,0,0,10,'avatar_10.jpg',0,8641,0,100,95),(3,0,0,11,'avatar_11.jpg',0,898,0,96,81),(4,0,0,20,'avatar_20.jpg',0,2916,0,100,75),(5,0,0,31,'avatar_31.jpg',0,139,0,88,100),(6,0,0,43,'avatar_43.gif',0,7532,0,50,49),(7,0,0,46,'avatar_46.jpg',0,1046,0,100,100),(114,0,0,47,'avatar_47.jpg',6121,4606,0,60,60),(9,0,0,55,'avatar_55.jpg',0,2682,0,95,100),(10,0,0,56,'avatar_56.gif',0,1529,0,100,79),(12,0,0,60,'avatar_60.jpg',0,884,0,100,90),(13,0,0,66,'avatar_66.jpg',0,327,0,60,84),(16,0,0,75,'avatar_75.jpg',0,588,0,100,100),(75,0,0,530,'avatar_530.png',17749,449,0,100,75),(18,0,0,86,'avatar_86.jpg',0,157,0,96,96),(109,0,0,96,'avatar_96.png',20809,3186,0,97,100),(20,0,0,100,'avatar_100.jpg',0,345,0,75,98),(150,0,0,103,'avatar_103.png',18060,766,0,100,75),(22,0,0,121,'avatar_121.gif',0,5456,0,20,20),(117,0,0,122,'avatar_122.png',7950,724,0,100,77),(24,0,0,130,'avatar_130.jpg',0,927,0,80,64),(25,0,0,132,'avatar_132.jpg',0,4734,0,96,96),(26,0,0,140,'avatar_140.jpg',0,1076,0,90,100),(30,0,0,156,'avatar_156.jpg',0,999,0,86,100),(31,0,0,159,'avatar_159.jpg',0,12,0,100,86),(32,0,0,166,'avatar_166.gif',0,385,0,73,72),(170,0,0,187,'avatar_187.png',13815,85,0,100,75),(35,0,0,239,'avatar_239.jpg',0,1344,0,99,66),(36,0,0,242,'avatar_242.gif',0,362,0,100,60),(167,0,0,256,'avatar_256.jpg',3391,45,0,50,50),(41,0,0,322,'avatar_322.jpg',0,599,0,100,100),(43,0,0,332,'avatar_332.jpg',0,3154,0,89,100),(44,0,0,345,'avatar_345.jpg',0,14,0,99,94),(46,0,0,371,'avatar_371.jpg',0,162,0,100,100),(47,0,0,399,'avatar_399.jpg',0,10,0,75,50),(118,0,0,412,'avatar_412.gif',65786,9218,0,68,70),(49,0,0,416,'avatar_416.jpg',0,271,0,97,77),(106,0,0,451,'avatar_451.jpg',18909,1163,0,70,80),(168,0,0,452,'avatar_452.png',8077,39,0,100,75),(68,0,0,460,'avatar_460.jpg',3809,4455,0,88,84),(55,0,0,465,'avatar_465.jpg',0,548,0,135,93),(110,0,0,471,'avatar_471.png',14935,342,0,100,95),(57,0,0,472,'avatar_472.jpg',0,1101,0,64,64),(144,0,0,520,'avatar_520.png',3926,2982,0,100,75),(63,0,0,529,'avatar_529.jpg',0,922,0,100,88),(64,0,0,539,'avatar_539.jpg',0,314,0,75,100),(65,0,0,546,'avatar_546.jpg',0,683,0,140,112),(66,0,0,548,'avatar_548.jpg',0,107,0,64,64),(83,0,0,615,'avatar_615.png',17336,898,0,75,100),(169,0,0,79,'avatar_79.jpg',2161,378,0,88,93),(73,0,0,553,'avatar_553.png',10244,62,0,100,100),(74,0,0,569,'avatar_569.png',11796,1977,0,100,66),(76,0,0,39,'avatar_39.png',16107,665,0,76,100),(77,0,0,593,'avatar_593.png',14428,55,0,67,100),(80,0,0,69,'avatar_69.png',18145,4174,0,100,75),(82,0,0,610,'avatar_610.png',16638,14,0,80,100),(166,0,0,617,'avatar_617.png',12306,707,0,100,74),(88,0,0,554,'avatar_554.png',16756,439,0,96,100),(87,0,0,608,'avatar_608.png',11196,2203,0,100,75),(91,0,0,343,'avatar_343.png',19474,1832,0,100,100),(129,0,0,620,'avatar_620.png',8214,911,0,68,100),(148,0,0,394,'avatar_394.png',19411,6215,0,75,100),(102,0,8334,0,'pinksheep.jpg_thumb',20091,0,3,150,132),(101,102,8334,0,'pinksheep.jpg',45633,15,0,200,177),(104,0,0,574,'avatar_574.gif',4611,16,0,64,64),(111,0,8605,0,'huff.txt',5107,17,0,0,0),(158,0,0,665,'avatar_665.png',21912,346,0,75,100),(159,0,0,662,'avatar_662.png',18851,2914,0,100,75),(126,0,0,505,'avatar_505.png',21025,5737,0,100,90),(146,0,0,484,'avatar_484.png',20459,1258,0,100,89),(136,137,9466,0,'flux2.jpg',19544,13,0,420,300),(137,0,9466,0,'flux2.jpg_thumb',7051,0,3,150,107),(153,0,0,516,'avatar_516.png',13686,399,0,100,75),(156,0,0,531,'avatar_531.jpg',1019,220,0,46,46),(161,0,0,714,'avatar_714.png',16751,731,0,77,100),(163,0,0,744,'avatar_744.png',6713,1,0,100,75),(165,0,0,408,'avatar_408.png',15563,228,0,100,75);
/*!40000 ALTER TABLE `ia_smf_attachments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_ban_groups`
--

DROP TABLE IF EXISTS `ia_smf_ban_groups`;
CREATE TABLE `ia_smf_ban_groups` (
  `ID_BAN_GROUP` mediumint(8) unsigned NOT NULL auto_increment,
  `name` varchar(20) collate latin1_general_ci NOT NULL default '',
  `ban_time` int(10) unsigned NOT NULL default '0',
  `expire_time` int(10) unsigned default NULL,
  `cannot_access` tinyint(3) unsigned NOT NULL default '0',
  `cannot_register` tinyint(3) unsigned NOT NULL default '0',
  `cannot_post` tinyint(3) unsigned NOT NULL default '0',
  `cannot_login` tinyint(3) unsigned NOT NULL default '0',
  `reason` tinytext collate latin1_general_ci NOT NULL,
  `notes` text collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`ID_BAN_GROUP`)
) ENGINE=MyISAM AUTO_INCREMENT=10 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_ban_groups`
--

LOCK TABLES `ia_smf_ban_groups` WRITE;
/*!40000 ALTER TABLE `ia_smf_ban_groups` DISABLE KEYS */;
INSERT INTO `ia_smf_ban_groups` VALUES (1,'full_ban_001',1143797793,NULL,1,0,0,0,'Migrated from phpBB2',''),(2,'full_ban_002',1143797793,NULL,1,0,0,0,'Migrated from phpBB2',''),(3,'full_ban_003',1143797793,NULL,1,0,0,0,'Migrated from phpBB2',''),(4,'full_ban_004',1143797793,NULL,1,0,0,0,'Migrated from phpBB2',''),(5,'full_ban_005',1143797793,NULL,1,0,0,0,'Migrated from phpBB2',''),(6,'sorin',1146932652,NULL,1,0,0,0,'vedeta de pe ginfo nu mai e available si aici',''),(7,'sorinaccio',1147365599,NULL,1,0,0,0,'',''),(8,'sorin_PD',1147367190,NULL,1,0,0,0,'',''),(9,'nu_ma_mai_banati',1147978074,NULL,1,0,0,0,'','');
/*!40000 ALTER TABLE `ia_smf_ban_groups` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_ban_items`
--

DROP TABLE IF EXISTS `ia_smf_ban_items`;
CREATE TABLE `ia_smf_ban_items` (
  `ID_BAN` mediumint(8) unsigned NOT NULL auto_increment,
  `ID_BAN_GROUP` smallint(5) unsigned NOT NULL default '0',
  `ip_low1` tinyint(3) unsigned NOT NULL default '0',
  `ip_high1` tinyint(3) unsigned NOT NULL default '0',
  `ip_low2` tinyint(3) unsigned NOT NULL default '0',
  `ip_high2` tinyint(3) unsigned NOT NULL default '0',
  `ip_low3` tinyint(3) unsigned NOT NULL default '0',
  `ip_high3` tinyint(3) unsigned NOT NULL default '0',
  `ip_low4` tinyint(3) unsigned NOT NULL default '0',
  `ip_high4` tinyint(3) unsigned NOT NULL default '0',
  `hostname` tinytext collate latin1_general_ci NOT NULL,
  `email_address` tinytext collate latin1_general_ci NOT NULL,
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `hits` mediumint(8) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_BAN`),
  KEY `ID_BAN_GROUP` (`ID_BAN_GROUP`)
) ENGINE=MyISAM AUTO_INCREMENT=14 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_ban_items`
--

LOCK TABLES `ia_smf_ban_items` WRITE;
/*!40000 ALTER TABLE `ia_smf_ban_items` DISABLE KEYS */;
INSERT INTO `ia_smf_ban_items` VALUES (2,2,0,0,0,0,0,0,0,0,'','',436,0),(5,5,0,0,0,0,0,0,0,0,'','',291,1),(6,6,85,85,186,186,13,13,229,229,'','',0,16),(8,6,0,0,0,0,0,0,0,0,'','',626,4),(9,7,82,82,77,77,124,124,131,131,'','',0,3),(12,9,86,86,34,34,40,40,176,176,'','',0,0);
/*!40000 ALTER TABLE `ia_smf_ban_items` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_board_permissions`
--

DROP TABLE IF EXISTS `ia_smf_board_permissions`;
CREATE TABLE `ia_smf_board_permissions` (
  `ID_GROUP` smallint(5) NOT NULL default '0',
  `ID_BOARD` smallint(5) unsigned NOT NULL default '0',
  `permission` varchar(30) collate latin1_general_ci NOT NULL default '',
  `addDeny` tinyint(4) NOT NULL default '1',
  PRIMARY KEY  (`ID_GROUP`,`ID_BOARD`,`permission`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_board_permissions`
--

LOCK TABLES `ia_smf_board_permissions` WRITE;
/*!40000 ALTER TABLE `ia_smf_board_permissions` DISABLE KEYS */;
INSERT INTO `ia_smf_board_permissions` VALUES (-1,0,'poll_view',1),(0,0,'send_topic',1),(0,0,'lock_own',1),(0,0,'remove_own',1),(0,0,'post_reply_own',1),(0,0,'post_reply_any',1),(0,0,'delete_own',1),(0,0,'modify_own',1),(0,0,'report_any',1),(0,0,'poll_view',1),(0,0,'poll_vote',1),(0,0,'poll_post',1),(0,0,'poll_add_own',1),(2,0,'report_any',1),(2,0,'split_any',1),(3,0,'post_reply_own',1),(3,0,'lock_own',1),(3,0,'lock_any',1),(3,0,'remove_own',1),(3,0,'remove_any',1),(3,0,'merge_any',1),(3,0,'post_new',1),(3,0,'post_reply_any',1),(3,0,'split_any',1),(3,0,'send_topic',1),(3,0,'make_sticky',1),(3,0,'move_any',1),(3,0,'moderate_board',1),(0,12,'post_reply_any',1),(0,12,'post_new',1),(0,12,'post_attachment',1),(0,12,'poll_vote',1),(0,12,'remove_own',1),(0,12,'report_any',1),(0,12,'send_topic',1),(2,0,'send_topic',1),(2,18,'post_attachment',1),(2,18,'view_attachments',1),(2,18,'mark_notify',1),(2,18,'mark_any_notify',1),(2,18,'poll_remove_any',1),(2,18,'poll_lock_any',1),(2,18,'poll_edit_any',1),(2,18,'poll_edit_own',1),(2,18,'poll_add_any',1),(2,18,'poll_add_own',1),(2,18,'poll_post',1),(2,18,'poll_vote',1),(20,21,'mark_notify',1),(2,21,'poll_lock_any',1),(2,0,'modify_any',1),(0,12,'view_attachments',1),(2,12,'delete_own',1),(2,12,'announce_topic',1),(2,12,'delete_replies',1),(2,12,'modify_replies',1),(2,12,'post_reply_any',1),(2,12,'poll_edit_any',1),(2,12,'mark_any_notify',1),(3,12,'moderate_board',1),(3,12,'post_new',1),(3,12,'post_reply_own',1),(3,12,'post_reply_any',1),(3,12,'poll_post',1),(3,12,'poll_add_own',1),(3,12,'poll_remove_any',1),(3,12,'poll_view',1),(3,12,'poll_vote',1),(3,12,'report_any',1),(3,12,'lock_own',1),(3,12,'send_topic',1),(3,12,'mark_any_notify',1),(3,12,'mark_notify',1),(3,12,'remove_own',1),(3,12,'modify_own',1),(3,12,'make_sticky',1),(3,12,'lock_any',1),(3,12,'delete_any',1),(3,12,'move_any',1),(3,12,'split_any',1),(3,12,'merge_any',1),(3,12,'remove_any',1),(3,12,'modify_any',1),(2,12,'send_topic',1),(2,12,'split_any',1),(2,12,'merge_any',1),(2,12,'post_new',1),(2,12,'moderate_board',1),(2,12,'delete_any',1),(2,12,'modify_own',1),(20,12,'modify_own',1),(2,12,'poll_edit_own',1),(2,12,'poll_add_any',1),(2,12,'poll_add_own',1),(2,12,'poll_post',1),(2,12,'poll_vote',1),(0,22,'post_new',1),(0,22,'post_attachment',1),(0,22,'poll_vote',1),(0,22,'remove_own',1),(0,22,'report_any',1),(0,22,'send_topic',1),(0,22,'view_attachments',1),(2,22,'post_reply_any',1),(2,22,'poll_edit_any',1),(2,22,'mark_any_notify',1),(3,22,'moderate_board',1),(2,22,'delete_own',1),(2,22,'delete_replies',1),(2,22,'modify_replies',1),(2,22,'announce_topic',1),(2,22,'report_any',1),(2,22,'mark_notify',1),(2,22,'view_attachments',1),(2,22,'post_attachment',1),(2,22,'modify_any',1),(2,22,'poll_remove_any',1),(20,22,'view_attachments',1),(2,12,'poll_view',1),(2,12,'report_any',1),(2,12,'mark_notify',1),(2,12,'view_attachments',1),(2,12,'post_attachment',1),(2,12,'modify_any',1),(2,12,'poll_remove_any',1),(20,12,'view_attachments',1),(20,12,'send_topic',1),(20,12,'report_any',1),(20,12,'remove_own',1),(20,12,'post_reply_own',1),(2,18,'lock_own',1),(20,12,'post_reply_any',1),(20,12,'post_new',1),(20,12,'delete_own',1),(2,12,'lock_any',1),(2,12,'remove_own',1),(2,12,'remove_any',1),(2,21,'poll_remove_own',1),(2,21,'poll_lock_own',1),(2,21,'make_sticky',1),(2,21,'move_own',1),(2,21,'move_any',1),(2,21,'lock_own',1),(2,21,'lock_any',1),(2,21,'remove_own',1),(2,21,'remove_any',1),(2,21,'post_reply_own',1),(20,21,'mark_any_notify',1),(20,21,'lock_own',1),(20,21,'delete_own',1),(20,21,'post_new',1),(20,21,'post_reply_any',1),(20,21,'post_reply_own',1),(20,21,'remove_own',1),(20,21,'report_any',1),(20,21,'send_topic',1),(20,21,'view_attachments',1),(2,21,'poll_remove_any',1),(2,21,'modify_any',1),(20,12,'lock_own',1),(20,12,'mark_any_notify',1),(2,12,'post_reply_own',1),(2,12,'lock_own',1),(2,12,'move_any',1),(2,13,'delete_own',1),(2,13,'remove_own',1),(2,13,'make_sticky',1),(2,13,'announce_topic',1),(2,13,'poll_post',1),(2,13,'poll_add_own',1),(3,13,'delete_own',1),(3,13,'remove_own',1),(3,13,'make_sticky',1),(3,13,'announce_topic',1),(3,13,'poll_post',1),(3,13,'poll_add_own',1),(20,12,'poll_add_own',1),(0,12,'lock_own',1),(0,12,'delete_own',1),(-1,12,'poll_view',1),(0,12,'mark_any_notify',1),(0,12,'mark_notify',1),(0,12,'modify_own',1),(0,12,'poll_add_own',1),(0,12,'poll_edit_own',1),(0,12,'poll_lock_own',1),(0,12,'poll_post',1),(0,12,'poll_view',1),(0,12,'post_reply_own',1),(2,21,'post_attachment',1),(2,21,'view_attachments',1),(2,21,'mark_notify',1),(2,21,'report_any',1),(2,21,'poll_view',1),(2,21,'poll_vote',1),(2,21,'poll_post',1),(2,21,'poll_add_own',1),(2,21,'poll_add_any',1),(2,21,'poll_edit_own',1),(20,21,'modify_own',1),(20,22,'poll_vote',1),(20,22,'post_attachment',1),(20,22,'poll_view',1),(20,22,'poll_post',1),(20,22,'poll_lock_own',1),(20,22,'poll_edit_own',1),(20,22,'poll_add_own',1),(0,22,'lock_own',1),(0,22,'delete_own',1),(-1,22,'poll_view',1),(0,22,'mark_any_notify',1),(0,22,'mark_notify',1),(0,22,'modify_own',1),(0,22,'poll_add_own',1),(0,22,'poll_edit_own',1),(0,22,'poll_lock_own',1),(0,22,'poll_post',1),(0,22,'poll_view',1),(0,22,'post_reply_own',1),(0,22,'post_reply_any',1),(20,22,'send_topic',1),(20,22,'report_any',1),(20,22,'remove_own',1),(20,22,'post_reply_own',1),(20,22,'post_reply_any',1),(20,22,'post_new',1),(20,22,'delete_own',1),(20,22,'mark_notify',1),(2,22,'poll_lock_any',1),(2,22,'poll_remove_own',1),(2,22,'poll_lock_own',1),(2,22,'make_sticky',1),(2,22,'move_own',1),(2,22,'move_any',1),(2,22,'lock_own',1),(2,22,'lock_any',1),(2,22,'remove_own',1),(2,22,'remove_any',1),(2,22,'post_reply_own',1),(20,22,'mark_any_notify',1),(20,22,'lock_own',1),(2,21,'modify_own',1),(2,21,'delete_any',1),(2,12,'move_own',1),(2,12,'make_sticky',1),(2,12,'poll_lock_own',1),(2,12,'poll_remove_own',1),(2,18,'move_any',1),(2,18,'delete_own',1),(2,18,'post_new',1),(2,18,'report_any',1),(20,18,'delete_own',1),(20,18,'lock_own',1),(20,18,'mark_any_notify',1),(20,18,'mark_notify',1),(20,18,'modify_own',1),(20,18,'poll_add_own',1),(20,18,'poll_edit_own',1),(20,18,'poll_lock_own',1),(20,18,'poll_post',1),(20,18,'poll_view',1),(20,18,'poll_vote',1),(20,18,'post_attachment',1),(20,18,'post_new',1),(20,18,'post_reply_any',1),(20,18,'post_reply_own',1),(20,18,'remove_own',1),(20,18,'report_any',1),(20,18,'send_topic',1),(20,18,'view_attachments',1),(2,18,'lock_any',1),(2,18,'modify_any',1),(2,18,'merge_any',1),(2,18,'modify_own',1),(3,18,'modify_any',1),(3,18,'remove_any',1),(3,18,'split_any',1),(3,18,'merge_any',1),(3,18,'move_any',1),(3,18,'delete_any',1),(3,18,'lock_any',1),(3,18,'make_sticky',1),(3,18,'modify_own',1),(3,18,'remove_own',1),(3,18,'mark_notify',1),(3,18,'mark_any_notify',1),(3,18,'send_topic',1),(3,18,'lock_own',1),(3,18,'report_any',1),(3,18,'poll_vote',1),(3,18,'poll_view',1),(3,18,'poll_remove_any',1),(3,18,'poll_add_own',1),(3,18,'poll_post',1),(3,18,'post_reply_any',1),(3,18,'post_reply_own',1),(3,18,'post_new',1),(2,21,'moderate_board',1),(2,21,'post_new',1),(2,21,'merge_any',1),(2,21,'split_any',1),(2,21,'send_topic',1),(3,21,'modify_any',1),(3,18,'moderate_board',1),(2,18,'remove_any',1),(2,18,'remove_own',1),(2,18,'post_reply_own',1),(2,18,'post_reply_any',1),(2,18,'send_topic',1),(2,18,'split_any',1),(2,18,'make_sticky',1),(2,18,'poll_view',1),(2,18,'delete_any',1),(0,18,'view_attachments',1),(0,18,'send_topic',1),(0,18,'report_any',1),(0,18,'remove_own',1),(0,18,'post_reply_own',1),(0,18,'post_reply_any',1),(0,18,'post_new',1),(0,18,'post_attachment',1),(0,18,'poll_vote',1),(0,18,'poll_view',1),(0,18,'poll_post',1),(0,18,'poll_lock_own',1),(0,18,'poll_edit_own',1),(0,18,'poll_add_own',1),(0,18,'modify_own',1),(0,18,'mark_notify',1),(0,18,'mark_any_notify',1),(0,18,'lock_own',1),(0,18,'delete_own',1),(-1,18,'poll_view',1),(2,12,'poll_lock_any',1),(3,21,'remove_any',1),(3,21,'merge_any',1),(3,21,'split_any',1),(3,21,'move_any',1),(3,21,'delete_any',1),(3,21,'lock_any',1),(3,21,'make_sticky',1),(3,21,'modify_own',1),(3,21,'remove_own',1),(3,21,'mark_notify',1),(3,21,'mark_any_notify',1),(3,21,'send_topic',1),(3,21,'lock_own',1),(3,21,'report_any',1),(3,21,'poll_vote',1),(3,21,'poll_view',1),(3,21,'poll_remove_any',1),(3,21,'poll_add_own',1),(3,21,'poll_post',1),(3,21,'post_reply_any',1),(3,21,'post_reply_own',1),(3,21,'post_new',1),(20,12,'mark_notify',1),(3,21,'moderate_board',1),(2,21,'mark_any_notify',1),(2,21,'poll_edit_any',1),(2,21,'post_reply_any',1),(2,21,'modify_replies',1),(2,21,'delete_replies',1),(2,21,'announce_topic',1),(2,21,'delete_own',1),(0,21,'view_attachments',1),(0,21,'send_topic',1),(0,21,'report_any',1),(0,21,'remove_own',1),(0,21,'poll_vote',1),(0,21,'post_attachment',1),(0,21,'post_new',1),(0,21,'post_reply_any',1),(0,21,'post_reply_own',1),(0,21,'poll_view',1),(0,21,'poll_post',1),(0,21,'poll_lock_own',1),(0,21,'poll_edit_own',1),(0,21,'poll_add_own',1),(0,21,'modify_own',1),(0,21,'mark_notify',1),(0,21,'mark_any_notify',1),(-1,21,'poll_view',1),(0,21,'delete_own',1),(0,21,'lock_own',1),(20,21,'poll_add_own',1),(20,21,'poll_edit_own',1),(20,21,'poll_lock_own',1),(20,21,'poll_post',1),(20,21,'poll_view',1),(20,21,'post_attachment',1),(20,21,'poll_vote',1),(3,22,'post_reply_any',1),(2,22,'poll_view',1),(3,22,'post_new',1),(3,22,'post_reply_own',1),(3,22,'poll_remove_any',1),(3,22,'poll_add_own',1),(3,22,'poll_post',1),(2,22,'poll_vote',1),(2,22,'poll_post',1),(2,22,'poll_add_own',1),(2,22,'poll_add_any',1),(2,22,'poll_edit_own',1),(20,22,'modify_own',1),(2,22,'modify_own',1),(2,22,'delete_any',1),(2,22,'moderate_board',1),(2,22,'post_new',1),(2,22,'merge_any',1),(2,22,'split_any',1),(2,22,'send_topic',1),(3,22,'modify_any',1),(3,22,'remove_any',1),(3,22,'merge_any',1),(3,22,'split_any',1),(3,22,'move_any',1),(3,22,'delete_any',1),(3,22,'lock_any',1),(3,22,'make_sticky',1),(3,22,'modify_own',1),(3,22,'remove_own',1),(3,22,'mark_notify',1),(3,22,'mark_any_notify',1),(3,22,'send_topic',1),(3,22,'lock_own',1),(3,22,'report_any',1),(3,22,'poll_vote',1),(3,22,'poll_view',1),(2,0,'modify_replies',1),(2,0,'make_sticky',1),(20,12,'poll_vote',1),(20,12,'post_attachment',1),(20,12,'poll_view',1),(20,12,'poll_post',1),(20,12,'poll_lock_own',1),(20,12,'poll_edit_own',1),(2,0,'delete_replies',1),(20,0,'post_new',1),(20,0,'send_topic',1),(20,0,'lock_own',1),(20,0,'remove_own',1),(20,0,'post_reply_own',1),(20,0,'post_reply_any',1),(20,0,'delete_own',1),(20,0,'modify_own',1),(20,0,'report_any',1),(20,0,'poll_view',1),(20,0,'poll_vote',1),(20,0,'poll_post',1),(2,0,'modify_own',1),(2,0,'delete_own',1),(2,0,'delete_any',1),(2,0,'post_new',1),(-1,1,'poll_view',1),(0,1,'poll_view',1),(0,1,'poll_vote',1),(0,1,'poll_add_own',1),(0,1,'report_any',1),(0,1,'modify_own',1),(0,1,'remove_own',1),(0,1,'post_reply_own',1),(0,1,'delete_own',1),(0,1,'post_reply_any',1),(0,1,'lock_own',1),(2,1,'report_any',1),(2,1,'poll_view',1),(2,1,'poll_vote',1),(2,1,'poll_post',1),(2,1,'poll_add_own',1),(2,1,'poll_add_any',1),(2,1,'poll_edit_own',1),(2,1,'poll_edit_any',1),(2,1,'poll_lock_own',1),(3,1,'moderate_board',1),(3,1,'post_new',1),(3,1,'post_reply_own',1),(3,1,'post_reply_any',1),(3,1,'poll_post',1),(3,1,'poll_add_own',1),(3,1,'poll_remove_any',1),(3,1,'poll_view',1),(3,1,'poll_vote',1),(3,1,'report_any',1),(3,1,'lock_own',1),(3,1,'send_topic',1),(3,1,'mark_any_notify',1),(3,1,'mark_notify',1),(3,1,'remove_own',1),(3,1,'modify_own',1),(3,1,'make_sticky',1),(3,1,'lock_any',1),(3,1,'delete_any',1),(3,1,'move_any',1),(3,1,'merge_any',1),(3,1,'split_any',1),(3,1,'remove_any',1),(3,1,'modify_any',1),(2,1,'poll_remove_own',1),(2,1,'poll_remove_any',1),(2,1,'delete_replies',1),(2,1,'delete_own',1),(2,1,'view_attachments',1),(2,1,'post_attachment',1),(2,1,'modify_any',1),(2,1,'moderate_board',1),(2,1,'post_new',1),(2,1,'merge_any',1),(2,1,'split_any',1),(2,1,'send_topic',1),(2,1,'poll_lock_any',1),(2,1,'mark_any_notify',1),(2,1,'modify_replies',1),(20,1,'view_attachments',1),(20,1,'send_topic',1),(20,1,'report_any',1),(20,1,'remove_own',1),(20,1,'post_reply_own',1),(20,1,'post_reply_any',1),(20,1,'post_new',1),(20,1,'post_attachment',1),(20,1,'poll_vote',1),(20,1,'poll_view',1),(20,1,'poll_post',1),(20,1,'poll_lock_own',1),(20,1,'poll_edit_own',1),(20,1,'poll_add_own',1),(20,1,'modify_own',1),(20,1,'mark_notify',1),(20,1,'mark_any_notify',1),(20,1,'lock_own',1),(20,1,'delete_own',1),(2,1,'mark_notify',1),(2,1,'delete_any',1),(2,1,'modify_own',1),(2,1,'make_sticky',1),(2,1,'move_own',1),(2,1,'move_any',1),(2,1,'lock_own',1),(2,1,'lock_any',1),(2,1,'remove_own',1),(2,1,'remove_any',1),(2,1,'post_reply_own',1),(2,1,'post_reply_any',1),(2,15,'modify_any',1),(2,15,'modify_own',1),(2,15,'modify_replies',1),(2,15,'move_any',1),(2,15,'move_own',1),(2,15,'poll_add_any',1),(2,15,'poll_add_own',1),(2,15,'poll_edit_any',1),(2,15,'poll_edit_own',1),(2,15,'poll_lock_any',1),(2,15,'poll_lock_own',1),(2,15,'poll_post',1),(2,15,'poll_remove_any',1),(2,15,'poll_remove_own',1),(2,15,'poll_view',1),(2,15,'poll_vote',1),(2,15,'post_attachment',1),(2,15,'post_new',1),(2,15,'post_reply_any',1),(2,15,'post_reply_own',1),(2,15,'remove_any',1),(2,15,'remove_own',1),(2,15,'report_any',1),(2,15,'send_topic',1),(2,15,'split_any',1),(2,15,'view_attachments',1),(3,15,'delete_any',1),(3,15,'lock_any',1),(3,15,'lock_own',1),(3,15,'make_sticky',1),(3,15,'mark_any_notify',1),(3,15,'mark_notify',1),(3,15,'merge_any',1),(3,15,'moderate_board',1),(3,15,'modify_any',1),(3,15,'modify_own',1),(3,15,'move_any',1),(3,15,'poll_add_own',1),(3,15,'poll_post',1),(3,15,'poll_remove_any',1),(3,15,'poll_view',1),(3,15,'poll_vote',1),(3,15,'post_new',1),(3,15,'post_reply_any',1),(3,15,'post_reply_own',1),(3,15,'remove_any',1),(3,15,'remove_own',1),(3,15,'report_any',1),(3,15,'send_topic',1),(3,15,'split_any',1),(20,15,'delete_own',1),(20,15,'lock_own',1),(20,15,'mark_any_notify',1),(20,15,'mark_notify',1),(20,15,'modify_own',1),(20,15,'poll_add_own',1),(20,15,'poll_edit_own',1),(20,15,'poll_lock_own',1),(2,16,'modify_any',1),(2,16,'modify_own',1),(2,16,'modify_replies',1),(2,16,'move_any',1),(2,16,'move_own',1),(2,16,'poll_add_any',1),(2,16,'poll_add_own',1),(2,16,'poll_edit_any',1),(2,16,'poll_edit_own',1),(2,16,'poll_lock_any',1),(2,16,'poll_lock_own',1),(2,16,'poll_post',1),(2,16,'poll_remove_any',1),(2,16,'poll_remove_own',1),(2,16,'poll_view',1),(2,16,'poll_vote',1),(2,16,'post_attachment',1),(2,16,'post_new',1),(2,16,'post_reply_any',1),(2,16,'post_reply_own',1),(2,16,'remove_any',1),(2,16,'remove_own',1),(2,16,'report_any',1),(2,16,'send_topic',1),(2,16,'split_any',1),(2,16,'view_attachments',1),(3,16,'delete_any',1),(3,16,'lock_any',1),(3,16,'lock_own',1),(3,16,'make_sticky',1),(3,16,'mark_any_notify',1),(3,16,'mark_notify',1),(3,16,'merge_any',1),(3,16,'moderate_board',1),(3,16,'modify_any',1),(3,16,'modify_own',1),(3,16,'move_any',1),(3,16,'poll_add_own',1),(3,16,'poll_post',1),(3,16,'poll_remove_any',1),(3,16,'poll_view',1),(3,16,'poll_vote',1),(3,16,'post_new',1),(3,16,'post_reply_any',1),(3,16,'post_reply_own',1),(3,16,'remove_any',1),(3,16,'remove_own',1),(3,16,'report_any',1),(3,16,'send_topic',1),(3,16,'split_any',1),(20,16,'delete_own',1),(20,16,'lock_own',1),(20,16,'mark_any_notify',1),(20,16,'mark_notify',1),(20,16,'modify_own',1),(20,16,'poll_add_own',1),(20,16,'poll_edit_own',1),(20,16,'poll_lock_own',1),(0,1,'poll_edit_own',1),(0,1,'send_topic',1),(2,15,'moderate_board',1),(2,15,'merge_any',1),(2,15,'mark_notify',1),(2,15,'mark_any_notify',1),(2,15,'make_sticky',1),(2,15,'lock_own',1),(2,15,'lock_any',1),(2,15,'delete_replies',1),(2,15,'delete_own',1),(2,15,'delete_any',1),(0,15,'view_attachments',1),(0,15,'send_topic',1),(0,15,'report_any',1),(0,15,'remove_own',1),(0,15,'post_reply_own',1),(0,15,'post_reply_any',1),(0,15,'post_attachment',1),(0,15,'poll_vote',1),(0,15,'poll_view',1),(0,15,'poll_lock_own',1),(0,15,'poll_edit_own',1),(0,15,'poll_add_own',1),(0,15,'modify_own',1),(0,15,'mark_notify',1),(0,15,'mark_any_notify',1),(0,15,'lock_own',1),(0,15,'delete_own',1),(-1,15,'poll_view',1),(2,16,'moderate_board',1),(2,16,'merge_any',1),(2,16,'mark_notify',1),(2,16,'mark_any_notify',1),(2,16,'make_sticky',1),(2,16,'lock_own',1),(2,16,'lock_any',1),(2,16,'delete_replies',1),(2,16,'delete_own',1),(2,16,'delete_any',1),(0,16,'view_attachments',1),(0,16,'send_topic',1),(0,16,'report_any',1),(0,16,'remove_own',1),(0,16,'post_reply_own',1),(0,16,'post_reply_any',1),(0,16,'post_attachment',1),(0,16,'poll_vote',1),(0,16,'poll_view',1),(0,16,'poll_lock_own',1),(0,16,'poll_edit_own',1),(0,16,'poll_add_own',1),(0,16,'modify_own',1),(0,16,'mark_notify',1),(0,16,'mark_any_notify',1),(0,16,'lock_own',1),(0,16,'delete_own',1),(-1,16,'poll_view',1),(0,1,'poll_lock_own',1),(0,1,'mark_any_notify',1),(0,1,'mark_notify',1),(0,1,'view_attachments',1),(0,1,'post_attachment',1),(20,15,'poll_post',1),(20,15,'poll_view',1),(20,15,'poll_vote',1),(20,15,'post_attachment',1),(20,15,'post_new',1),(20,15,'post_reply_any',1),(20,15,'post_reply_own',1),(20,15,'remove_own',1),(20,15,'report_any',1),(20,15,'send_topic',1),(20,15,'view_attachments',1),(20,16,'poll_post',1),(20,16,'poll_view',1),(20,16,'poll_vote',1),(20,16,'post_attachment',1),(20,16,'post_new',1),(20,16,'post_reply_any',1),(20,16,'post_reply_own',1),(20,16,'remove_own',1),(20,16,'report_any',1),(20,16,'send_topic',1),(20,16,'view_attachments',1),(-1,20,'poll_view',1),(0,20,'delete_own',1),(0,20,'lock_own',1),(0,20,'mark_any_notify',1),(0,20,'mark_notify',1),(0,20,'modify_own',1),(0,20,'poll_add_own',1),(0,20,'poll_edit_own',1),(0,20,'poll_lock_own',1),(0,20,'poll_post',1),(0,20,'poll_view',1),(0,20,'poll_vote',1),(0,20,'post_attachment',1),(0,20,'post_new',1),(0,20,'post_reply_any',1),(0,20,'post_reply_own',1),(0,20,'remove_own',1),(0,20,'report_any',1),(0,20,'send_topic',1),(0,20,'view_attachments',1),(2,20,'report_any',1),(2,20,'poll_view',1),(2,20,'poll_vote',1),(2,20,'poll_post',1),(2,20,'poll_add_own',1),(2,20,'poll_add_any',1),(2,20,'poll_edit_own',1),(2,20,'poll_edit_any',1),(2,20,'poll_lock_own',1),(3,20,'moderate_board',1),(3,20,'post_new',1),(3,20,'post_reply_own',1),(3,20,'post_reply_any',1),(3,20,'poll_post',1),(3,20,'poll_add_own',1),(3,20,'poll_remove_any',1),(3,20,'poll_view',1),(3,20,'poll_vote',1),(3,20,'report_any',1),(3,20,'lock_own',1),(3,20,'send_topic',1),(3,20,'mark_any_notify',1),(3,20,'mark_notify',1),(3,20,'remove_own',1),(3,20,'modify_own',1),(3,20,'make_sticky',1),(3,20,'lock_any',1),(3,20,'delete_any',1),(3,20,'move_any',1),(3,20,'merge_any',1),(3,20,'split_any',1),(3,20,'remove_any',1),(3,20,'modify_any',1),(2,20,'poll_remove_own',1),(2,20,'poll_remove_any',1),(2,20,'delete_replies',1),(2,20,'delete_own',1),(2,20,'view_attachments',1),(2,20,'post_attachment',1),(2,20,'modify_any',1),(2,20,'moderate_board',1),(2,20,'post_new',1),(2,20,'merge_any',1),(2,20,'split_any',1),(2,20,'send_topic',1),(2,20,'poll_lock_any',1),(2,20,'mark_any_notify',1),(2,20,'modify_replies',1),(20,20,'view_attachments',1),(20,20,'send_topic',1),(20,20,'report_any',1),(20,20,'remove_own',1),(20,20,'post_reply_own',1),(20,20,'post_reply_any',1),(20,20,'post_new',1),(20,20,'post_attachment',1),(20,20,'poll_vote',1),(20,20,'poll_view',1),(20,20,'poll_post',1),(20,20,'poll_lock_own',1),(20,20,'poll_edit_own',1),(20,20,'poll_add_own',1),(20,20,'modify_own',1),(20,20,'mark_notify',1),(20,20,'mark_any_notify',1),(20,20,'lock_own',1),(20,20,'delete_own',1),(2,20,'mark_notify',1),(2,20,'delete_any',1),(2,20,'modify_own',1),(2,20,'make_sticky',1),(2,20,'move_own',1),(2,20,'move_any',1),(2,20,'lock_own',1),(2,20,'lock_any',1),(2,20,'remove_own',1),(2,20,'remove_any',1),(2,20,'post_reply_own',1),(2,20,'post_reply_any',1),(2,0,'merge_any',1),(2,0,'move_own',1),(2,0,'move_any',1),(2,0,'lock_own',1),(2,0,'lock_any',1),(2,0,'remove_own',1),(2,0,'remove_any',1),(2,0,'post_reply_own',1),(2,0,'post_reply_any',1),(2,0,'moderate_board',1),(20,0,'post_attachment',1),(20,0,'mark_any_notify',1),(20,0,'mark_notify',1),(20,0,'view_attachments',1),(20,0,'poll_add_own',1),(20,0,'poll_edit_own',1),(20,0,'poll_lock_own',1),(0,0,'post_new',1),(2,0,'poll_view',1),(2,0,'poll_vote',1),(2,0,'poll_post',1),(2,0,'poll_add_own',1),(2,0,'poll_add_any',1),(2,0,'poll_edit_own',1),(2,0,'poll_edit_any',1),(2,0,'poll_lock_own',1),(2,0,'poll_lock_any',1),(2,0,'poll_remove_own',1),(2,0,'poll_remove_any',1),(2,0,'mark_any_notify',1),(2,0,'mark_notify',1),(2,0,'view_attachments',1),(2,0,'post_attachment',1),(0,0,'poll_edit_own',1),(0,0,'poll_lock_own',1),(0,0,'mark_any_notify',1),(0,0,'mark_notify',1),(0,0,'view_attachments',1),(0,0,'post_attachment',1),(3,0,'delete_any',1),(3,0,'modify_own',1),(3,0,'modify_any',1),(3,0,'report_any',1),(3,0,'poll_view',1),(3,0,'poll_vote',1),(3,0,'poll_post',1),(3,0,'poll_add_own',1),(3,0,'poll_remove_any',1),(3,0,'mark_any_notify',1),(3,0,'mark_notify',1),(-1,33,'poll_view',1),(0,33,'send_topic',1),(0,33,'lock_own',1),(0,33,'remove_own',1),(0,33,'post_reply_own',1),(0,33,'post_reply_any',1),(0,33,'delete_own',1),(0,33,'modify_own',1),(0,33,'report_any',1),(0,33,'poll_view',1),(0,33,'poll_vote',1),(0,33,'poll_post',1),(0,33,'poll_add_own',1),(2,33,'report_any',1),(2,33,'split_any',1),(3,33,'post_reply_own',1),(3,33,'lock_own',1),(3,33,'lock_any',1),(3,33,'remove_own',1),(3,33,'remove_any',1),(3,33,'merge_any',1),(3,33,'post_new',1),(3,33,'post_reply_any',1),(3,33,'split_any',1),(3,33,'send_topic',1),(3,33,'make_sticky',1),(3,33,'move_any',1),(3,33,'moderate_board',1),(2,33,'send_topic',1),(2,33,'modify_any',1),(2,33,'modify_replies',1),(2,33,'make_sticky',1),(2,33,'delete_replies',1),(20,33,'post_new',1),(20,33,'send_topic',1),(20,33,'lock_own',1),(20,33,'remove_own',1),(20,33,'post_reply_own',1),(20,33,'post_reply_any',1),(20,33,'delete_own',1),(20,33,'modify_own',1),(20,33,'report_any',1),(20,33,'poll_view',1),(20,33,'poll_vote',1),(20,33,'poll_post',1),(2,33,'modify_own',1),(2,33,'delete_own',1),(2,33,'delete_any',1),(2,33,'post_new',1),(2,33,'merge_any',1),(2,33,'move_own',1),(2,33,'move_any',1),(2,33,'lock_own',1),(2,33,'lock_any',1),(2,33,'remove_own',1),(2,33,'remove_any',1),(2,33,'post_reply_own',1),(2,33,'post_reply_any',1),(2,33,'moderate_board',1),(20,33,'post_attachment',1),(20,33,'mark_any_notify',1),(20,33,'mark_notify',1),(20,33,'view_attachments',1),(20,33,'poll_add_own',1),(20,33,'poll_edit_own',1),(20,33,'poll_lock_own',1),(0,33,'post_new',1),(2,33,'poll_view',1),(2,33,'poll_vote',1),(2,33,'poll_post',1),(2,33,'poll_add_own',1),(2,33,'poll_add_any',1),(2,33,'poll_edit_own',1),(2,33,'poll_edit_any',1),(2,33,'poll_lock_own',1),(2,33,'poll_lock_any',1),(2,33,'poll_remove_own',1),(2,33,'poll_remove_any',1),(2,33,'mark_any_notify',1),(2,33,'mark_notify',1),(2,33,'view_attachments',1),(2,33,'post_attachment',1),(0,33,'poll_edit_own',1),(0,33,'poll_lock_own',1),(0,33,'mark_any_notify',1),(0,33,'mark_notify',1),(0,33,'view_attachments',1),(0,33,'post_attachment',1),(3,33,'delete_any',1),(3,33,'modify_own',1),(3,33,'modify_any',1),(3,33,'report_any',1),(3,33,'poll_view',1),(3,33,'poll_vote',1),(3,33,'poll_post',1),(3,33,'poll_add_own',1),(3,33,'poll_remove_any',1),(3,33,'mark_any_notify',1),(3,33,'mark_notify',1),(-1,33,'post_reply_any',1),(0,34,'post_new',1),(0,34,'post_attachment',1),(0,34,'poll_vote',1),(0,34,'remove_own',1),(0,34,'report_any',1),(0,34,'send_topic',1),(0,34,'view_attachments',1),(2,34,'post_reply_any',1),(2,34,'poll_edit_any',1),(2,34,'mark_any_notify',1),(3,34,'moderate_board',1),(2,34,'delete_own',1),(2,34,'delete_replies',1),(2,34,'modify_replies',1),(2,34,'announce_topic',1),(2,34,'report_any',1),(2,34,'mark_notify',1),(2,34,'view_attachments',1),(2,34,'post_attachment',1),(2,34,'modify_any',1),(2,34,'poll_remove_any',1),(20,34,'view_attachments',1),(20,34,'poll_vote',1),(20,34,'post_attachment',1),(20,34,'poll_view',1),(20,34,'poll_post',1),(20,34,'poll_lock_own',1),(20,34,'poll_edit_own',1),(20,34,'poll_add_own',1),(0,34,'lock_own',1),(0,34,'delete_own',1),(-1,34,'poll_view',1),(0,34,'mark_any_notify',1),(0,34,'mark_notify',1),(0,34,'modify_own',1),(0,34,'poll_add_own',1),(0,34,'poll_edit_own',1),(0,34,'poll_lock_own',1),(0,34,'poll_post',1),(0,34,'poll_view',1),(0,34,'post_reply_own',1),(0,34,'post_reply_any',1),(20,34,'send_topic',1),(20,34,'report_any',1),(20,34,'remove_own',1),(20,34,'post_reply_own',1),(20,34,'post_reply_any',1),(20,34,'post_new',1),(20,34,'delete_own',1),(20,34,'mark_notify',1),(2,34,'poll_lock_any',1),(2,34,'poll_remove_own',1),(2,34,'poll_lock_own',1),(2,34,'make_sticky',1),(2,34,'move_own',1),(2,34,'move_any',1),(2,34,'lock_own',1),(2,34,'lock_any',1),(2,34,'remove_own',1),(2,34,'remove_any',1),(2,34,'post_reply_own',1),(20,34,'mark_any_notify',1),(20,34,'lock_own',1),(3,34,'post_reply_any',1),(2,34,'poll_view',1),(3,34,'post_new',1),(3,34,'post_reply_own',1),(3,34,'poll_remove_any',1),(3,34,'poll_add_own',1),(3,34,'poll_post',1),(2,34,'poll_vote',1),(2,34,'poll_post',1),(2,34,'poll_add_own',1),(2,34,'poll_add_any',1),(2,34,'poll_edit_own',1),(20,34,'modify_own',1),(2,34,'modify_own',1),(2,34,'delete_any',1),(2,34,'moderate_board',1),(2,34,'post_new',1),(2,34,'merge_any',1),(2,34,'split_any',1),(2,34,'send_topic',1),(3,34,'modify_any',1),(3,34,'remove_any',1),(3,34,'merge_any',1),(3,34,'split_any',1),(3,34,'move_any',1),(3,34,'delete_any',1),(3,34,'lock_any',1),(3,34,'make_sticky',1),(3,34,'modify_own',1),(3,34,'remove_own',1),(3,34,'mark_notify',1),(3,34,'mark_any_notify',1),(3,34,'send_topic',1),(3,34,'lock_own',1),(3,34,'report_any',1),(3,34,'poll_vote',1),(3,34,'poll_view',1),(-1,4,'poll_view',1),(0,4,'send_topic',1),(0,4,'lock_own',1),(0,4,'remove_own',1),(0,4,'post_reply_own',1),(0,4,'post_reply_any',1),(0,4,'delete_own',1),(0,4,'modify_own',1),(0,4,'report_any',1),(0,4,'poll_view',1),(0,4,'poll_vote',1),(0,4,'poll_post',1),(0,4,'poll_add_own',1),(2,4,'report_any',1),(2,4,'split_any',1),(3,4,'post_reply_own',1),(3,4,'lock_own',1),(3,4,'lock_any',1),(3,4,'remove_own',1),(3,4,'remove_any',1),(3,4,'merge_any',1),(3,4,'post_new',1),(3,4,'post_reply_any',1),(3,4,'split_any',1),(3,4,'send_topic',1),(3,4,'make_sticky',1),(3,4,'move_any',1),(3,4,'moderate_board',1),(2,4,'send_topic',1),(2,4,'modify_any',1),(2,4,'modify_replies',1),(2,4,'make_sticky',1),(2,4,'delete_replies',1),(20,4,'post_new',1),(20,4,'send_topic',1),(20,4,'lock_own',1),(20,4,'remove_own',1),(20,4,'post_reply_own',1),(20,4,'post_reply_any',1),(20,4,'delete_own',1),(20,4,'modify_own',1),(20,4,'report_any',1),(20,4,'poll_view',1),(20,4,'poll_vote',1),(20,4,'poll_post',1),(2,4,'modify_own',1),(2,4,'delete_own',1),(2,4,'delete_any',1),(2,4,'post_new',1),(2,4,'merge_any',1),(2,4,'move_own',1),(2,4,'move_any',1),(2,4,'lock_own',1),(2,4,'lock_any',1),(2,4,'remove_own',1),(2,4,'remove_any',1),(2,4,'post_reply_own',1),(2,4,'post_reply_any',1),(2,4,'moderate_board',1),(20,4,'post_attachment',1),(20,4,'mark_any_notify',1),(20,4,'mark_notify',1),(20,4,'view_attachments',1),(20,4,'poll_add_own',1),(20,4,'poll_edit_own',1),(20,4,'poll_lock_own',1),(0,4,'post_new',1),(2,4,'poll_view',1),(2,4,'poll_vote',1),(2,4,'poll_post',1),(2,4,'poll_add_own',1),(2,4,'poll_add_any',1),(2,4,'poll_edit_own',1),(2,4,'poll_edit_any',1),(2,4,'poll_lock_own',1),(2,4,'poll_lock_any',1),(2,4,'poll_remove_own',1),(2,4,'poll_remove_any',1),(2,4,'mark_any_notify',1),(2,4,'mark_notify',1),(2,4,'view_attachments',1),(2,4,'post_attachment',1),(0,4,'poll_edit_own',1),(0,4,'poll_lock_own',1),(0,4,'mark_any_notify',1),(0,4,'mark_notify',1),(0,4,'view_attachments',1),(0,4,'post_attachment',1),(3,4,'delete_any',1),(3,4,'modify_own',1),(3,4,'modify_any',1),(3,4,'report_any',1),(3,4,'poll_view',1),(3,4,'poll_vote',1),(3,4,'poll_post',1),(3,4,'poll_add_own',1),(3,4,'poll_remove_any',1),(3,4,'mark_any_notify',1),(3,4,'mark_notify',1),(-1,35,'poll_view',1),(0,35,'send_topic',1),(0,35,'lock_own',1),(0,35,'remove_own',1),(0,35,'post_reply_own',1),(0,35,'post_reply_any',1),(0,35,'delete_own',1),(0,35,'modify_own',1),(0,35,'report_any',1),(0,35,'poll_view',1),(0,35,'poll_vote',1),(0,35,'poll_post',1),(0,35,'poll_add_own',1),(2,35,'report_any',1),(2,35,'split_any',1),(3,35,'post_reply_own',1),(3,35,'lock_own',1),(3,35,'lock_any',1),(3,35,'remove_own',1),(3,35,'remove_any',1),(3,35,'merge_any',1),(3,35,'post_new',1),(3,35,'post_reply_any',1),(3,35,'split_any',1),(3,35,'send_topic',1),(3,35,'make_sticky',1),(3,35,'move_any',1),(3,35,'moderate_board',1),(2,35,'send_topic',1),(2,35,'modify_any',1),(2,35,'modify_replies',1),(2,35,'make_sticky',1),(2,35,'delete_replies',1),(20,35,'post_new',1),(20,35,'send_topic',1),(20,35,'lock_own',1),(20,35,'remove_own',1),(20,35,'post_reply_own',1),(20,35,'post_reply_any',1),(20,35,'delete_own',1),(20,35,'modify_own',1),(20,35,'report_any',1),(20,35,'poll_view',1),(20,35,'poll_vote',1),(20,35,'poll_post',1),(2,35,'modify_own',1),(2,35,'delete_own',1),(2,35,'delete_any',1),(2,35,'post_new',1),(2,35,'merge_any',1),(2,35,'move_own',1),(2,35,'move_any',1),(2,35,'lock_own',1),(2,35,'lock_any',1),(2,35,'remove_own',1),(2,35,'remove_any',1),(2,35,'post_reply_own',1),(2,35,'post_reply_any',1),(2,35,'moderate_board',1),(20,35,'post_attachment',1),(20,35,'mark_any_notify',1),(20,35,'mark_notify',1),(20,35,'view_attachments',1),(20,35,'poll_add_own',1),(20,35,'poll_edit_own',1),(20,35,'poll_lock_own',1),(0,35,'post_new',1),(2,35,'poll_view',1),(2,35,'poll_vote',1),(2,35,'poll_post',1),(2,35,'poll_add_own',1),(2,35,'poll_add_any',1),(2,35,'poll_edit_own',1),(2,35,'poll_edit_any',1),(2,35,'poll_lock_own',1),(2,35,'poll_lock_any',1),(2,35,'poll_remove_own',1),(2,35,'poll_remove_any',1),(2,35,'mark_any_notify',1),(2,35,'mark_notify',1),(2,35,'view_attachments',1),(2,35,'post_attachment',1),(0,35,'poll_edit_own',1),(0,35,'poll_lock_own',1),(0,35,'mark_any_notify',1),(0,35,'mark_notify',1),(0,35,'view_attachments',1),(0,35,'post_attachment',1),(3,35,'delete_any',1),(3,35,'modify_own',1),(3,35,'modify_any',1),(3,35,'report_any',1),(3,35,'poll_view',1),(3,35,'poll_vote',1),(3,35,'poll_post',1),(3,35,'poll_add_own',1),(3,35,'poll_remove_any',1),(3,35,'mark_any_notify',1),(3,35,'mark_notify',1),(-1,36,'poll_view',1),(0,36,'send_topic',1),(0,36,'lock_own',1),(0,36,'remove_own',1),(0,36,'post_reply_own',1),(0,36,'post_reply_any',1),(0,36,'delete_own',1),(0,36,'modify_own',1),(0,36,'report_any',1),(0,36,'poll_view',1),(0,36,'poll_vote',1),(0,36,'poll_post',1),(0,36,'poll_add_own',1),(2,36,'report_any',1),(2,36,'split_any',1),(3,36,'post_reply_own',1),(3,36,'lock_own',1),(3,36,'lock_any',1),(3,36,'remove_own',1),(3,36,'remove_any',1),(3,36,'merge_any',1),(3,36,'post_new',1),(3,36,'post_reply_any',1),(3,36,'split_any',1),(3,36,'send_topic',1),(3,36,'make_sticky',1),(3,36,'move_any',1),(3,36,'moderate_board',1),(2,36,'send_topic',1),(2,36,'modify_any',1),(2,36,'modify_replies',1),(2,36,'make_sticky',1),(2,36,'delete_replies',1),(20,36,'post_new',1),(20,36,'send_topic',1),(20,36,'lock_own',1),(20,36,'remove_own',1),(20,36,'post_reply_own',1),(20,36,'post_reply_any',1),(20,36,'delete_own',1),(20,36,'modify_own',1),(20,36,'report_any',1),(20,36,'poll_view',1),(20,36,'poll_vote',1),(20,36,'poll_post',1),(2,36,'modify_own',1),(2,36,'delete_own',1),(2,36,'delete_any',1),(2,36,'post_new',1),(2,36,'merge_any',1),(2,36,'move_own',1),(2,36,'move_any',1),(2,36,'lock_own',1),(2,36,'lock_any',1),(2,36,'remove_own',1),(2,36,'remove_any',1),(2,36,'post_reply_own',1),(2,36,'post_reply_any',1),(2,36,'moderate_board',1),(20,36,'post_attachment',1),(20,36,'mark_any_notify',1),(20,36,'mark_notify',1),(20,36,'view_attachments',1),(20,36,'poll_add_own',1),(20,36,'poll_edit_own',1),(20,36,'poll_lock_own',1),(0,36,'post_new',1),(2,36,'poll_view',1),(2,36,'poll_vote',1),(2,36,'poll_post',1),(2,36,'poll_add_own',1),(2,36,'poll_add_any',1),(2,36,'poll_edit_own',1),(2,36,'poll_edit_any',1),(2,36,'poll_lock_own',1),(2,36,'poll_lock_any',1),(2,36,'poll_remove_own',1),(2,36,'poll_remove_any',1),(2,36,'mark_any_notify',1),(2,36,'mark_notify',1),(2,36,'view_attachments',1),(2,36,'post_attachment',1),(0,36,'poll_edit_own',1),(0,36,'poll_lock_own',1),(0,36,'mark_any_notify',1),(0,36,'mark_notify',1),(0,36,'view_attachments',1),(0,36,'post_attachment',1),(3,36,'delete_any',1),(3,36,'modify_own',1),(3,36,'modify_any',1),(3,36,'report_any',1),(3,36,'poll_view',1),(3,36,'poll_vote',1),(3,36,'poll_post',1),(3,36,'poll_add_own',1),(3,36,'poll_remove_any',1),(3,36,'mark_any_notify',1),(3,36,'mark_notify',1);
/*!40000 ALTER TABLE `ia_smf_board_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_boards`
--

DROP TABLE IF EXISTS `ia_smf_boards`;
CREATE TABLE `ia_smf_boards` (
  `ID_BOARD` smallint(5) unsigned NOT NULL auto_increment,
  `ID_CAT` tinyint(4) unsigned NOT NULL default '0',
  `childLevel` tinyint(4) unsigned NOT NULL default '0',
  `ID_PARENT` smallint(5) unsigned NOT NULL default '0',
  `boardOrder` smallint(5) NOT NULL default '0',
  `ID_LAST_MSG` int(10) unsigned NOT NULL default '0',
  `ID_MSG_UPDATED` mediumint(8) unsigned NOT NULL default '0',
  `lastUpdated` int(11) unsigned NOT NULL default '0',
  `memberGroups` varchar(128) collate latin1_general_ci NOT NULL default '-1,0',
  `name` tinytext collate latin1_general_ci NOT NULL,
  `description` text collate latin1_general_ci NOT NULL,
  `numTopics` mediumint(8) unsigned NOT NULL default '0',
  `numPosts` mediumint(8) unsigned NOT NULL default '0',
  `countPosts` tinyint(4) NOT NULL default '0',
  `ID_THEME` tinyint(4) unsigned NOT NULL default '0',
  `permission_mode` tinyint(4) unsigned NOT NULL default '0',
  `override_theme` tinyint(4) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_BOARD`),
  UNIQUE KEY `categories` (`ID_CAT`,`ID_BOARD`),
  KEY `ID_PARENT` (`ID_PARENT`),
  KEY `ID_MSG_UPDATED` (`ID_MSG_UPDATED`)
) ENGINE=MyISAM AUTO_INCREMENT=37 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_boards`
--

LOCK TABLES `ia_smf_boards` WRITE;
/*!40000 ALTER TABLE `ia_smf_boards` DISABLE KEYS */;
INSERT INTO `ia_smf_boards` VALUES (9,1,0,0,1,11865,11865,1143797508,'-1,0,2,20','Concursuri','Accesibil doar in timpul concursurilor online infoarena; aici adresezi comisiei intrebari si contestatii',152,815,0,0,0,0),(35,1,1,9,2,11670,11670,0,'-1,0,2,20','preONI 2007','',10,67,0,0,1,0),(36,1,1,9,3,11835,11835,0,'-1,0,2,20','Unirea 2007','',10,93,0,0,1,0),(29,1,1,9,4,0,0,0,'-1,0,2,20,9,10,11,13,17,18','Arhiva concursuri','Arhiva cu forumuri dedicate concursurilor de pe infoarena',0,0,0,0,0,0),(30,1,2,29,5,10799,10799,0,'-1,0,2,20','Happy Coding 2006','',22,129,0,0,0,0),(27,1,2,29,6,9733,9733,0,'-1,0,2,20','Summer Challenge Trei','Discutii despre concursul \"Summer Challenge Trei\" - finalul trilogiei :)',4,56,0,0,0,0),(28,1,2,29,7,10012,10012,0,'-1,0,2,20','Autumn WarmUp 2006','',9,103,0,0,0,0),(26,1,2,29,8,9387,0,0,'-1,0,2,20','Summer Challenge Doi','Discutii despre concursul \"Summer Challenge Doi\" - continuarea primului \"Summer Challenge\"',4,57,0,0,0,0),(25,1,2,29,9,9856,9856,0,'-1,0,2,20,9,10,11,13,17,18','Summer Challenge','',5,80,0,0,0,0),(24,1,2,29,10,4218,0,0,'-1,0,2,20','Happy coding','Despre concursul Happy Coding.\r\nHappy Coding inseamna programare cu zambetul pe buze, pace, idei, placere si distractie pura! :)',23,211,0,0,0,0),(23,1,2,29,11,7450,0,0,'-1,0,2,20','Grigore Moisil','Despre concursul Grigore Moisil by Net , 2006.',13,102,0,0,0,0),(20,1,2,29,12,8202,7232,1143651151,'-1,0,2,20','preONI 2006','Concursul <b>preONI</b> este  o initiativa indrazneata a echipei <i>info-arena</i> menita sa ii ajute pe cei pasionati de informatica in pregatirea pentru performanta la Olimpiada Nationala. Acest forum este dedicat exclusiv acestui concurs.',69,465,0,0,1,0),(1,1,0,0,13,11866,11866,1143796633,'-1,0,2,20','Arhiva de probleme','Cere sau ofera sfaturi despre rezolvarea problemelor insa nu oferi solutii complete.',321,3715,0,0,1,0),(15,1,1,1,14,10740,10740,1141477266,'-1,0,2,20','Probleme pentru bacalaureat','',7,75,0,0,1,0),(16,1,1,1,15,5286,5286,1134678019,'','Teste grila','Aici aveti posibilitatea sa discutati despre testele de tip grila disponibile. \r\n',3,22,0,0,1,0),(3,1,0,0,16,11860,11860,1143697607,'-1,0,2,20','Informatica','Informatica, algoritmi, structuri de date, matematica... stii tu ;)',183,1482,0,0,0,0),(5,1,0,0,17,11690,11690,1143021767,'-1,0,2,20','Articole','',21,117,0,0,0,0),(6,1,1,5,18,11285,11285,1143565697,'-1,0,2,20','Downloads','Discuta despre download-urile oferite pe site; cere sau propune download-uri noi',15,128,0,0,0,0),(33,3,0,0,19,11850,11850,0,'-1,0,2,20','Feedback infoarena','Asteptam feedback / sugestii / bug-uri / opinii despre site si evaluator.',13,274,0,0,1,0),(14,3,1,33,20,11732,11732,1143162536,'-1,0,2,20','Sondaje','',17,103,0,0,0,0),(11,3,1,33,21,10805,10805,1143797245,'-1,0,2,20','Arhiva','Arhiva cu discutii despre vechiul site infoarena.',97,621,0,0,0,0),(22,3,0,0,22,0,0,0,'2,20','Discutii intime','Vizibil numai pentru administratori si moderatori',0,0,0,0,1,0),(21,3,1,22,23,10749,10749,1143625468,'2,20','Proiecte, idei','Aici propunem discutam idei noi de proiecte. Forum-ul este vizibil moderatorilor, colaboratorilor si administratorilor.',18,130,0,0,1,0),(18,3,1,22,24,10938,10938,1143741632,'','Discutii administratori','Doar pentru administratori (infoarena inner-circle)',27,82,0,0,1,0),(31,3,1,22,25,0,11368,0,'2,20','Arhiva cu discutii intime','Aici ajung <em>discutiile intime</em> care nu mai sunt de actualitate.',0,0,0,0,0,0),(19,3,2,31,26,11368,11368,1143112148,'','preONI 2006','Selectarea problemelor pentru concursul preONI 2006.',100,387,0,0,1,0),(12,3,2,31,27,4563,4563,1132336365,'2,20','Articole info.devNet.ro','Un forum pentru cei ce pot scrie articole la info.devNet.',8,43,0,0,1,0),(13,3,2,31,28,2305,2305,1111598043,'','ONI 2005 Bootcamp @ Prahova','Aceasta este o sectiunea pe care am creat-o pentru a discuta probleme pentru ONI cu cei din lotul judetului Prahova si este hidden pentru majoritatea lumii. (domino)',16,167,0,0,1,0),(34,3,1,22,29,11609,11609,0,'','preONI 2007','',49,152,0,0,1,0),(4,3,0,0,30,11862,11862,1143789745,'-1,0,2,20','Off topic','<em>Viata e complicata si are multe aspecte ...</em>',132,1486,0,0,1,0);
/*!40000 ALTER TABLE `ia_smf_boards` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_calendar`
--

DROP TABLE IF EXISTS `ia_smf_calendar`;
CREATE TABLE `ia_smf_calendar` (
  `ID_EVENT` smallint(5) unsigned NOT NULL auto_increment,
  `startDate` date NOT NULL default '0001-01-01',
  `ID_BOARD` smallint(5) unsigned NOT NULL default '0',
  `ID_TOPIC` mediumint(8) unsigned NOT NULL default '0',
  `title` varchar(48) collate latin1_general_ci NOT NULL default '',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `endDate` date NOT NULL default '0001-01-01',
  PRIMARY KEY  (`ID_EVENT`),
  KEY `startDate` (`startDate`),
  KEY `endDate` (`endDate`),
  KEY `topic` (`ID_TOPIC`,`ID_MEMBER`)
) ENGINE=MyISAM AUTO_INCREMENT=97 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_calendar`
--

LOCK TABLES `ia_smf_calendar` WRITE;
/*!40000 ALTER TABLE `ia_smf_calendar` DISABLE KEYS */;
INSERT INTO `ia_smf_calendar` VALUES (1,'2006-04-07',9,984,'TopCoder SRM 297',3,'2006-04-07'),(2,'2006-04-11',9,985,'TopCoder SRM 298',3,'2006-04-11'),(3,'2006-04-15',9,986,'ONI 2006',3,'2006-04-22'),(4,'2006-04-22',9,987,'TopCoder SRM 299',154,'2006-04-22'),(5,'2006-04-26',9,996,'20 de ani de la Cernobal',121,'2006-04-26'),(6,'2006-04-27',9,997,'Finala .campion 2006',3,'2006-04-30'),(7,'2006-04-22',9,998,'Timus Top Coders 2',3,'2006-04-22'),(8,'2006-04-28',9,1049,'US Open 2006',3,'2006-05-01'),(9,'2006-05-13',9,1058,'Baraje lot 1',59,'2006-05-20'),(10,'2006-05-21',9,1059,'Bacul special',59,'2006-05-30'),(11,'2006-05-10',9,1061,'TopCoder SRM 301',59,'2006-05-10'),(12,'2006-05-17',9,1063,'IPSC',59,'2006-05-18'),(14,'2006-05-11',9,1070,'TopCoder SRM 302',3,'2006-05-11'),(15,'2006-05-13',9,1071,'UVA',59,'2006-05-13'),(16,'2006-05-28',9,1072,'PKU',59,'2006-05-28'),(17,'2006-05-27',9,1083,'Topcoder SRM 304',154,'2006-05-27'),(18,'2006-06-01',9,1085,'SRM 305',59,'2006-06-01'),(19,'2006-06-03',9,1086,'UVA',59,'2006-06-03'),(20,'2006-06-03',9,1087,'TOJ',59,'2006-06-03'),(21,'2006-06-06',9,1096,'TopCoder HS SRM 1',154,'2006-06-06'),(22,'2006-06-12',9,1097,'TopCoder HS SRM 2',154,'2006-06-12'),(23,'2006-06-15',9,1100,'SRM 307',59,'2006-06-15'),(24,'2006-06-19',9,1104,'TopCoder HS SRM 3',154,'2006-06-19'),(25,'2006-06-24',9,1108,'TopCoder SRM 308',154,'2006-06-24'),(26,'2006-06-26',9,1110,'TopCoder HS SRM 4',154,'2006-06-26'),(27,'2006-07-01',9,1119,'CEOI 2006',154,'2006-07-08'),(28,'2006-07-06',9,1122,'TopCoder HS SRM 5',154,'2006-07-06'),(29,'2006-07-17',9,1137,'TopCoder HS SRM 7',10,'2006-07-17'),(30,'2006-07-22',9,1138,'Topcoder SRM 312',10,'2006-07-22'),(31,'2006-07-24',9,1142,'TopCoder HS SRM 8',10,'2006-07-24'),(32,'2006-08-03',25,1143,'Summer Challenge 2006',3,'2006-08-03'),(33,'2006-08-07',9,1158,'Topcoder HS SRM 10',10,'2006-08-07'),(34,'2006-08-10',9,1161,'Topcoder SRM 315',27,'2006-08-10'),(35,'2006-08-12',9,1162,'URAL SU - training camp',27,'2006-08-12'),(36,'2006-08-11',9,1163,'Summer Challenge Doi',27,'2006-08-11'),(37,'2006-08-14',9,1165,'Topcoder HS SRM 11',154,'2006-08-14'),(38,'2006-08-19',9,1179,'TopCoder SRM 316',27,'2006-08-19'),(39,'2006-08-13',9,1175,'IOI 2006',3,'2006-08-20'),(40,'2006-08-28',9,1197,'SCU 110-year-celebration',154,'2006-08-28'),(41,'2006-08-29',9,1198,'Topcoder HS SRM 13',154,'2006-08-29'),(42,'2006-08-30',9,1199,'Topcoder SRM 318',154,'2006-08-30'),(43,'2006-09-02',9,1202,'UVa - A Bangladeshi Contest',154,'2006-09-02'),(44,'2006-09-05',9,1204,'Google Code Jam - calificare',154,'2006-09-06'),(45,'2006-09-07',9,1207,'TCCC - Qualification Round #1',154,'2006-09-07'),(46,'2006-09-09',9,1208,'TCCC - Qualification Round #2',154,'2006-09-09'),(47,'2006-09-13',9,1209,'TCCC - Qualification Round #3',154,'2006-09-13'),(48,'2006-09-09',9,1210,'UVa - IIUC Programming Contest',154,'2006-09-09'),(49,'2006-09-11',9,1213,'Topcoder HS SRM 14',154,'2006-09-11'),(50,'2006-09-14',9,1215,'Google Code Jam 2006 - Round 1',154,'2006-09-14'),(51,'2006-09-19',9,1216,'Google Code Jam 2006 - Round 2',154,'2006-09-19'),(52,'2006-09-10',9,1231,'TJU 2006 Exercise Contest 9',154,'2006-09-10'),(53,'2006-09-13',9,1232,'TJU 2006 Exercise Contest 10',154,'2006-09-13'),(54,'2006-09-15',9,1233,'TJU 2006 Exercise Contest 11',154,'2006-09-15'),(55,'2006-09-16',9,1244,'PKU 2006 warmup 2',154,'2006-09-16'),(58,'2006-09-19',9,1247,'Topcoder SRM 319',154,'2006-09-19'),(57,'2006-09-17',9,1246,'TJU 2006 Exercise Contest 12',154,'2006-09-17'),(59,'2006-09-23',9,1250,'ZOJ Monthly, September 2006',154,'2006-09-23'),(60,'2006-09-23',9,1251,'UVa - ACM ICPC Dhaka Regional',154,'2006-09-23'),(61,'2006-09-21',9,1252,'Concurs acm.uva.es',154,'2006-09-21'),(62,'2006-09-23',9,1255,'PKU 2006 warmup 3',154,'2006-09-23'),(63,'2006-09-24',9,1257,'Timus contest, august 2006',154,'2006-09-24'),(64,'2006-09-24',9,1258,'Waterloo Fall Contest 1',154,'2006-09-24'),(65,'2006-09-28',9,1259,'TCCC 2006 - Online Round 1C',154,'2006-09-28'),(66,'2006-09-25',9,1260,'Topcoder HS SRM 15',154,'2006-09-25'),(67,'2006-09-25',9,1261,'TJU Exercise Contest 15',3,'2006-09-25'),(68,'2006-09-30',9,1262,'UVa - Waterloo contest II',154,'2006-09-30'),(69,'2006-09-27',9,1263,'TJU 2006 Exercise Contest 16',154,'2006-09-27'),(70,'2006-09-30',9,1264,'TJU 2006 Exercise Contest 17',154,'2006-09-30'),(71,'2006-09-29',9,1265,'POJ Monthly - September 2006',154,'2006-09-29'),(72,'2006-10-01',9,1266,'Petr Mitrichev Contest 1',154,'2006-10-01'),(73,'2006-09-30',9,1267,'Topcoder SRM 320',154,'2006-09-30'),(74,'2006-10-02',9,1269,'TJU Exercise Contests 18-22',154,'2006-10-06'),(75,'2006-10-03',9,1270,'Topcoder SRM 321',154,'2006-10-03'),(76,'2006-10-10',9,1278,'TopCoder SRM 322',154,'2006-10-10'),(77,'2006-10-14',9,1283,'Timus-USU Junior Contest OCT06',154,'2006-10-14'),(78,'2006-10-14',9,1287,'UVa ACM ICPC Regional-Warmup 1',154,'2006-10-14'),(80,'2006-10-15',9,1307,'TJU 2006 ACM ICPC Regionals WI',154,'2006-10-15'),(81,'2006-10-15',9,1308,'9th Southern Subregional SGU',154,'2006-10-15'),(82,'2006-10-20',9,1331,'Topcoder SRM 323',154,'2006-10-20'),(83,'2006-10-25',9,1335,'Topcoder SRM 324',154,'2006-10-25'),(84,'2006-10-30',9,1345,'Topcoder HS SRM 18',154,'2006-10-30'),(85,'2006-11-02',9,1346,'Topcoder SRM 325',154,'2006-11-02'),(86,'2006-11-01',9,1347,'TJU 2006 Exercise Contest 28',154,'2006-11-01'),(87,'2006-11-05',9,1349,'TJU 2006 ACM ICPC Warmup II',154,'2006-11-05'),(88,'2006-11-07',9,1351,'TJU 2006 Exercise Contest 30',154,'2006-11-07'),(89,'2006-11-19',9,1356,'UVa ACM ICPC - NWERC 2006',154,'2006-11-19'),(90,'2007-01-20',9,1446,'UVa Next Generation Contest 3',154,'2007-01-20'),(91,'2007-01-26',9,1447,'Topcoder SRM 336',154,'2007-01-26'),(92,'2007-01-21',9,1460,'preONI 2007, Runda 1',3,'2007-01-21'),(93,'2007-01-30',9,1472,'SGU Petr Mitrichev Contest 2',154,'2007-01-30'),(95,'2007-01-27',0,0,'Unirea 2007',154,'2007-01-27'),(96,'2007-01-27',9,1498,'Unirea 2007',47,'2007-01-27');
/*!40000 ALTER TABLE `ia_smf_calendar` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_calendar_holidays`
--

DROP TABLE IF EXISTS `ia_smf_calendar_holidays`;
CREATE TABLE `ia_smf_calendar_holidays` (
  `ID_HOLIDAY` smallint(5) unsigned NOT NULL auto_increment,
  `eventDate` date NOT NULL default '0001-01-01',
  `title` varchar(30) collate latin1_general_ci NOT NULL default '',
  PRIMARY KEY  (`ID_HOLIDAY`),
  KEY `eventDate` (`eventDate`)
) ENGINE=MyISAM AUTO_INCREMENT=186 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_calendar_holidays`
--

LOCK TABLES `ia_smf_calendar_holidays` WRITE;
/*!40000 ALTER TABLE `ia_smf_calendar_holidays` DISABLE KEYS */;
INSERT INTO `ia_smf_calendar_holidays` VALUES (1,'0004-01-01','New Year\'s'),(2,'0004-12-25','Christmas'),(3,'0004-02-14','Valentine\'s Day'),(4,'0004-03-17','St. Patrick\'s Day'),(5,'0004-04-01','April Fools'),(6,'0004-04-22','Earth Day'),(7,'0004-10-24','United Nations Day'),(8,'0004-10-31','Halloween'),(9,'2002-05-12','Mother\'s Day'),(10,'2003-05-11','Mother\'s Day'),(11,'2004-05-09','Mother\'s Day'),(12,'2005-05-08','Mother\'s Day'),(13,'2006-05-14','Mother\'s Day'),(14,'2007-05-13','Mother\'s Day'),(15,'2008-05-11','Mother\'s Day'),(16,'2009-05-10','Mother\'s Day'),(17,'2010-05-09','Mother\'s Day'),(18,'2002-06-16','Father\'s Day'),(19,'2003-06-15','Father\'s Day'),(20,'2004-06-20','Father\'s Day'),(21,'2005-06-19','Father\'s Day'),(22,'2006-06-18','Father\'s Day'),(23,'2007-06-17','Father\'s Day'),(24,'2008-06-15','Father\'s Day'),(25,'2009-06-21','Father\'s Day'),(26,'2010-06-20','Father\'s Day'),(27,'2002-06-21','Summer Solstice'),(28,'2003-06-21','Summer Solstice'),(29,'2004-06-20','Summer Solstice'),(30,'2005-06-20','Summer Solstice'),(31,'2006-06-21','Summer Solstice'),(32,'2007-06-21','Summer Solstice'),(33,'2008-06-20','Summer Solstice'),(34,'2009-06-20','Summer Solstice'),(35,'2010-06-21','Summer Solstice'),(36,'2002-03-20','Vernal Equinox'),(37,'2003-03-20','Vernal Equinox'),(38,'2004-03-19','Vernal Equinox'),(39,'2005-03-20','Vernal Equinox'),(40,'2006-03-20','Vernal Equinox'),(41,'2007-03-20','Vernal Equinox'),(42,'2008-03-19','Vernal Equinox'),(43,'2009-03-20','Vernal Equinox'),(44,'2010-03-20','Vernal Equinox'),(45,'2002-12-21','Winter Solstice'),(46,'2003-12-22','Winter Solstice'),(47,'2004-12-21','Winter Solstice'),(48,'2005-12-21','Winter Solstice'),(49,'2006-12-22','Winter Solstice'),(50,'2007-12-22','Winter Solstice'),(51,'2008-12-21','Winter Solstice'),(52,'2009-12-21','Winter Solstice'),(53,'2010-12-21','Winter Solstice'),(54,'2002-09-22','Autumnal Equinox'),(55,'2003-09-23','Autumnal Equinox'),(56,'2004-09-22','Autumnal Equinox'),(57,'2005-09-22','Autumnal Equinox'),(58,'2006-09-22','Autumnal Equinox'),(59,'2007-09-23','Autumnal Equinox'),(60,'2008-09-22','Autumnal Equinox'),(61,'2009-09-22','Autumnal Equinox'),(62,'2010-09-22','Autumnal Equinox'),(63,'0004-07-04','Independence Day'),(64,'0004-05-05','Cinco de Mayo'),(65,'0004-06-14','Flag Day'),(66,'0004-11-11','Veterans Day'),(67,'0004-02-02','Groundhog Day'),(68,'2002-11-28','Thanksgiving'),(69,'2003-11-27','Thanksgiving'),(70,'2004-11-25','Thanksgiving'),(71,'2005-11-24','Thanksgiving'),(72,'2006-11-23','Thanksgiving'),(73,'2007-11-22','Thanksgiving'),(74,'2008-11-27','Thanksgiving'),(75,'2009-11-26','Thanksgiving'),(76,'2010-11-25','Thanksgiving'),(77,'2002-05-27','Memorial Day'),(78,'2003-05-26','Memorial Day'),(79,'2004-05-31','Memorial Day'),(80,'2005-05-30','Memorial Day'),(81,'2006-05-29','Memorial Day'),(82,'2007-05-28','Memorial Day'),(83,'2008-05-26','Memorial Day'),(84,'2009-05-25','Memorial Day'),(85,'2010-05-31','Memorial Day'),(86,'2002-09-02','Labor Day'),(87,'2003-09-01','Labor Day'),(88,'2004-09-06','Labor Day'),(89,'2005-09-05','Labor Day'),(90,'2006-09-04','Labor Day'),(91,'2007-09-03','Labor Day'),(92,'2008-09-01','Labor Day'),(93,'2009-09-07','Labor Day'),(94,'2010-09-06','Labor Day'),(95,'0004-06-06','D-Day'),(96,'2011-05-08','Mother\'s Day'),(97,'2012-05-13','Mother\'s Day'),(98,'2013-05-12','Mother\'s Day'),(99,'2014-05-11','Mother\'s Day'),(100,'2015-05-10','Mother\'s Day'),(101,'2016-05-08','Mother\'s Day'),(102,'2017-05-14','Mother\'s Day'),(103,'2018-05-13','Mother\'s Day'),(104,'2019-05-12','Mother\'s Day'),(105,'2020-05-10','Mother\'s Day'),(106,'2011-06-19','Father\'s Day'),(107,'2012-06-17','Father\'s Day'),(108,'2013-06-16','Father\'s Day'),(109,'2014-06-15','Father\'s Day'),(110,'2015-06-21','Father\'s Day'),(111,'2016-06-19','Father\'s Day'),(112,'2017-06-18','Father\'s Day'),(113,'2018-06-17','Father\'s Day'),(114,'2019-06-16','Father\'s Day'),(115,'2020-06-21','Father\'s Day'),(116,'2011-06-21','Summer Solstice'),(117,'2012-06-20','Summer Solstice'),(118,'2013-06-21','Summer Solstice'),(119,'2014-06-21','Summer Solstice'),(120,'2015-06-21','Summer Solstice'),(121,'2016-06-20','Summer Solstice'),(122,'2017-06-20','Summer Solstice'),(123,'2018-06-21','Summer Solstice'),(124,'2019-06-21','Summer Solstice'),(125,'2020-06-20','Summer Solstice'),(126,'2011-03-20','Vernal Equinox'),(127,'2012-03-20','Vernal Equinox'),(128,'2013-03-20','Vernal Equinox'),(129,'2014-03-20','Vernal Equinox'),(130,'2015-03-20','Vernal Equinox'),(131,'2016-03-19','Vernal Equinox'),(132,'2017-03-20','Vernal Equinox'),(133,'2018-03-20','Vernal Equinox'),(134,'2019-03-20','Vernal Equinox'),(135,'2020-03-19','Vernal Equinox'),(136,'2011-12-22','Winter Solstice'),(137,'2012-12-21','Winter Solstice'),(138,'2013-12-21','Winter Solstice'),(139,'2014-12-21','Winter Solstice'),(140,'2015-12-21','Winter Solstice'),(141,'2016-12-21','Winter Solstice'),(142,'2017-12-21','Winter Solstice'),(143,'2018-12-21','Winter Solstice'),(144,'2019-12-21','Winter Solstice'),(145,'2020-12-21','Winter Solstice'),(146,'2011-09-23','Autumnal Equinox'),(147,'2012-09-22','Autumnal Equinox'),(148,'2013-09-22','Autumnal Equinox'),(149,'2014-09-22','Autumnal Equinox'),(150,'2015-09-23','Autumnal Equinox'),(151,'2016-09-22','Autumnal Equinox'),(152,'2017-09-22','Autumnal Equinox'),(153,'2018-09-22','Autumnal Equinox'),(154,'2019-09-23','Autumnal Equinox'),(155,'2020-09-22','Autumnal Equinox'),(156,'2011-11-24','Thanksgiving'),(157,'2012-11-22','Thanksgiving'),(158,'2013-11-21','Thanksgiving'),(159,'2014-11-20','Thanksgiving'),(160,'2015-11-26','Thanksgiving'),(161,'2016-11-24','Thanksgiving'),(162,'2017-11-23','Thanksgiving'),(163,'2018-11-22','Thanksgiving'),(164,'2019-11-21','Thanksgiving'),(165,'2020-11-26','Thanksgiving'),(166,'2011-05-30','Memorial Day'),(167,'2012-05-28','Memorial Day'),(168,'2013-05-27','Memorial Day'),(169,'2014-05-26','Memorial Day'),(170,'2015-05-25','Memorial Day'),(171,'2016-05-30','Memorial Day'),(172,'2017-05-29','Memorial Day'),(173,'2018-05-28','Memorial Day'),(174,'2019-05-27','Memorial Day'),(175,'2020-05-25','Memorial Day'),(176,'2011-09-05','Labor Day'),(177,'2012-09-03','Labor Day'),(178,'2013-09-09','Labor Day'),(179,'2014-09-08','Labor Day'),(180,'2015-09-07','Labor Day'),(181,'2016-09-05','Labor Day'),(182,'2017-09-04','Labor Day'),(183,'2018-09-03','Labor Day'),(184,'2019-09-09','Labor Day'),(185,'2020-09-07','Labor Day');
/*!40000 ALTER TABLE `ia_smf_calendar_holidays` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_categories`
--

DROP TABLE IF EXISTS `ia_smf_categories`;
CREATE TABLE `ia_smf_categories` (
  `ID_CAT` tinyint(4) unsigned NOT NULL auto_increment,
  `catOrder` tinyint(4) NOT NULL default '0',
  `name` tinytext collate latin1_general_ci NOT NULL,
  `canCollapse` tinyint(1) NOT NULL default '1',
  PRIMARY KEY  (`ID_CAT`)
) ENGINE=MyISAM AUTO_INCREMENT=7 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_categories`
--

LOCK TABLES `ia_smf_categories` WRITE;
/*!40000 ALTER TABLE `ia_smf_categories` DISABLE KEYS */;
INSERT INTO `ia_smf_categories` VALUES (1,0,'infoarena - concursuri, probleme, evaluator, articole',1),(3,1,'Comunitate - feedback, proiecte si distractie',1);
/*!40000 ALTER TABLE `ia_smf_categories` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_collapsed_categories`
--

DROP TABLE IF EXISTS `ia_smf_collapsed_categories`;
CREATE TABLE `ia_smf_collapsed_categories` (
  `ID_CAT` tinyint(4) unsigned NOT NULL default '0',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_CAT`,`ID_MEMBER`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_collapsed_categories`
--

LOCK TABLES `ia_smf_collapsed_categories` WRITE;
/*!40000 ALTER TABLE `ia_smf_collapsed_categories` DISABLE KEYS */;
INSERT INTO `ia_smf_collapsed_categories` VALUES (1,0),(1,69),(1,3926),(1,5796),(1,5943),(3,0),(3,461),(3,516),(3,599),(3,5943);
/*!40000 ALTER TABLE `ia_smf_collapsed_categories` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_actions`
--

DROP TABLE IF EXISTS `ia_smf_log_actions`;
CREATE TABLE `ia_smf_log_actions` (
  `ID_ACTION` int(10) unsigned NOT NULL auto_increment,
  `logTime` int(10) unsigned NOT NULL default '0',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `ip` varchar(16) collate latin1_general_ci NOT NULL default '',
  `action` varchar(30) collate latin1_general_ci NOT NULL default '',
  `extra` text collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`ID_ACTION`),
  KEY `logTime` (`logTime`),
  KEY `ID_MEMBER` (`ID_MEMBER`)
) ENGINE=MyISAM AUTO_INCREMENT=810 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_actions`
--

LOCK TABLES `ia_smf_log_actions` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_actions` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_log_actions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_activity`
--

DROP TABLE IF EXISTS `ia_smf_log_activity`;
CREATE TABLE `ia_smf_log_activity` (
  `date` date NOT NULL default '0001-01-01',
  `hits` mediumint(8) unsigned NOT NULL default '0',
  `topics` smallint(5) unsigned NOT NULL default '0',
  `posts` smallint(5) unsigned NOT NULL default '0',
  `registers` smallint(5) unsigned NOT NULL default '0',
  `mostOn` smallint(5) unsigned NOT NULL default '0',
  PRIMARY KEY  (`date`),
  KEY `hits` (`hits`),
  KEY `mostOn` (`mostOn`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_activity`
--

LOCK TABLES `ia_smf_log_activity` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_activity` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_log_activity` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_banned`
--

DROP TABLE IF EXISTS `ia_smf_log_banned`;
CREATE TABLE `ia_smf_log_banned` (
  `ID_BAN_LOG` mediumint(8) unsigned NOT NULL auto_increment,
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `ip` varchar(16) collate latin1_general_ci NOT NULL default '',
  `email` tinytext collate latin1_general_ci NOT NULL,
  `logTime` int(10) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_BAN_LOG`),
  KEY `logTime` (`logTime`)
) ENGINE=MyISAM AUTO_INCREMENT=22 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_banned`
--

LOCK TABLES `ia_smf_log_banned` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_banned` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_log_banned` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_boards`
--

DROP TABLE IF EXISTS `ia_smf_log_boards`;
CREATE TABLE `ia_smf_log_boards` (
  `ID_BOARD` smallint(5) unsigned NOT NULL default '0',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `ID_MSG` mediumint(8) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_MEMBER`,`ID_BOARD`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_boards`
--

LOCK TABLES `ia_smf_log_boards` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_boards` DISABLE KEYS */;
INSERT INTO `ia_smf_log_boards` VALUES (20,47,8224),(19,3,11728),(15,3,11654),(20,3,10976),(14,3,11733),(1,3,11866),(14,47,11802),(1,47,11857),(9,47,11858),(15,47,10979),(16,47,10979),(11,47,10987),(3,47,11802),(5,47,11691),(6,47,11285),(12,47,10979),(21,47,10881),(18,47,11714),(19,47,11373),(13,47,7432),(4,47,11857),(13,3,10976),(3,3,11861),(4,3,11866),(5,3,11690),(6,3,11297),(9,3,11866),(11,3,10976),(12,3,10976),(16,3,11654),(18,3,10976),(21,3,10976),(22,3,11728),(23,3,10976),(23,47,9003),(20,27,9022),(23,27,9617),(14,27,9265),(1,370,11861),(11,370,11732),(4,370,11863),(5,370,11690),(9,370,11863),(20,370,8203),(14,370,11732),(1,43,10432),(1,441,11027),(15,441,7761),(4,441,11315),(1,20,10979),(4,20,11692),(1,154,11861),(4,154,11862),(3,154,11861),(16,154,10643),(11,154,11414),(14,154,11732),(15,154,11655),(5,154,11694),(9,154,11863),(20,154,11414),(23,154,11414),(6,154,11414),(3,505,11807),(9,460,11838),(11,20,10979),(1,505,11866),(11,460,11039),(11,505,11032),(3,53,11861),(1,53,11861),(15,53,10746),(9,53,11859),(20,53,9194),(11,53,10994),(5,53,11695),(6,53,11290),(4,53,11829),(16,53,7414),(23,53,7477),(14,53,11733),(11,121,10832),(22,121,11715),(19,121,11402),(1,465,11530),(4,121,11862),(18,121,10938),(1,121,11864),(5,121,11715),(1,55,11733),(11,520,10307),(14,520,8813),(4,520,10944),(1,250,11854),(23,465,7738),(11,308,11301),(20,520,10150),(1,308,11823),(20,465,9947),(11,250,7503),(11,43,10325),(1,520,10938),(3,20,11692),(16,20,10979),(15,20,10979),(9,20,11692),(20,20,10979),(23,20,10979),(14,20,10979),(5,20,11692),(6,20,11692),(21,20,10979),(12,20,10979),(1,460,11838),(4,460,11838),(9,554,8533),(1,590,8261),(1,27,11671),(5,27,11284),(4,308,11820),(3,69,10755),(1,96,10979),(1,69,10746),(22,69,11460),(18,69,10960),(4,69,11229),(16,96,7820),(15,96,7820),(11,96,10390),(16,69,10118),(15,69,10168),(9,69,10745),(20,69,8248),(23,69,7706),(11,69,11028),(14,69,10745),(4,96,10390),(5,69,9649),(6,69,10879),(21,69,10763),(19,69,9798),(12,69,7423),(13,69,7423),(3,463,8542),(4,17,9047),(3,547,11861),(1,463,11609),(15,463,7423),(5,463,8462),(11,463,8542),(5,17,7423),(1,569,11023),(1,394,11861),(4,546,8392),(5,546,8496),(5,505,11691),(3,546,8213),(1,546,7845),(16,546,7834),(15,546,7834),(9,546,7834),(20,546,7834),(23,546,7834),(11,546,7834),(14,546,7834),(6,546,7978),(11,132,10083),(6,370,11286),(3,370,11861),(4,412,11863),(1,412,11861),(1,132,10962),(9,132,11804),(1,257,11315),(3,558,11861),(3,440,9664),(1,440,11278),(9,440,11805),(20,440,8135),(23,440,7601),(16,440,7959),(15,440,7959),(11,440,8233),(14,440,7601),(5,440,7958),(6,440,10863),(4,440,11281),(11,554,8382),(22,47,11714),(1,574,11850),(3,506,11864),(9,506,11866),(20,506,11414),(23,506,10282),(1,506,11866),(16,506,7452),(15,506,10759),(11,506,11003),(5,506,11692),(6,506,11286),(14,506,11733),(4,506,11864),(1,544,11373),(6,308,11300),(1,558,11861),(5,55,11495),(4,55,11733),(11,55,11207),(14,132,10011),(16,257,10979),(15,257,11178),(1,37,7918),(1,447,7869),(3,55,11733),(9,55,11799),(1,140,9663),(9,140,11668),(20,140,7450),(3,140,11665),(5,140,11668),(6,140,9663),(16,55,7445),(6,55,11299),(23,140,7450),(23,250,7451),(23,10,7453),(4,10,11864),(11,10,11543),(14,10,11736),(4,140,10863),(14,55,8810),(23,55,7451),(22,27,11608),(18,27,10938),(6,27,11290),(9,10,11865),(3,27,11431),(20,10,9529),(9,27,11671),(3,10,11860),(11,27,11153),(4,27,11857),(1,10,11866),(16,10,7453),(15,10,10807),(15,27,10744),(6,10,11287),(16,27,7810),(19,27,11396),(21,27,10749),(5,10,11804),(12,27,7452),(13,27,9132),(12,10,8683),(21,10,10807),(23,554,8171),(11,547,11285),(23,547,8409),(11,79,11422),(9,239,11854),(20,239,7946),(4,43,11836),(22,43,11560),(13,43,7463),(1,130,8810),(22,154,11482),(21,154,11414),(12,154,11482),(3,43,11836),(16,43,7888),(15,43,8704),(9,43,11836),(20,43,8476),(23,43,7458),(14,43,8810),(5,43,11483),(6,43,10325),(5,257,11215),(6,257,11178),(6,460,11426),(5,460,11694),(3,460,11733),(23,121,10832),(9,257,11736),(23,257,11178),(1,239,7946),(16,140,7462),(11,239,7901),(4,394,11863),(18,43,10325),(21,43,9179),(19,43,9779),(12,43,7463),(4,132,11573),(9,520,10885),(3,520,10944),(5,520,9758),(6,520,10944),(23,520,10150),(15,520,10745),(16,520,9969),(23,460,7665),(4,554,8565),(6,554,8643),(3,554,8572),(5,308,11706),(4,547,11834),(1,362,7558),(3,362,7559),(4,362,7478),(22,10,11787),(4,454,11865),(6,362,7558),(5,362,7481),(11,362,7481),(9,362,7481),(20,362,7481),(23,362,7481),(14,362,7481),(16,362,7481),(15,362,7481),(1,454,11864),(3,454,11859),(16,454,7782),(15,454,11300),(9,454,11859),(20,454,9449),(23,454,8915),(11,454,10997),(14,454,11733),(5,454,11691),(6,454,11413),(6,547,11285),(16,250,7492),(15,250,11177),(3,250,11733),(9,408,11861),(23,408,7495),(1,570,11694),(1,408,11177),(6,121,11290),(9,250,11819),(14,250,11733),(9,308,11820),(15,55,10752),(3,499,7512),(15,370,10761),(16,370,8337),(23,370,8412),(1,499,11231),(9,547,11859),(5,239,11639),(1,79,11866),(6,132,10118),(4,79,11866),(9,465,11802),(4,250,11831),(6,488,7541),(1,496,10724),(4,332,11460),(1,332,10214),(15,332,8643),(15,140,7546),(11,140,7546),(22,20,10979),(1,592,7556),(15,592,7556),(9,593,7557),(20,554,8213),(3,493,10979),(3,308,11823),(3,121,11862),(9,121,11864),(9,505,11809),(20,460,10823),(11,353,11495),(14,353,11495),(20,55,8203),(1,595,11680),(4,337,11550),(9,337,11572),(20,121,10832),(15,570,7582),(3,484,10975),(1,484,11660),(3,79,11861),(6,79,11422),(20,505,9373),(3,408,9141),(4,530,8431),(1,530,10587),(19,353,11495),(1,353,11837),(20,337,7604),(22,353,11657),(21,353,11495),(1,495,8604),(20,547,8224),(21,121,11095),(4,328,10846),(3,257,11268),(13,121,10832),(12,121,10832),(3,596,7626),(1,596,7626),(1,328,7626),(1,554,8516),(3,539,10932),(1,539,11859),(1,597,8373),(9,597,7640),(5,496,7940),(5,132,9757),(1,103,11677),(14,460,11733),(1,598,7650),(9,598,11609),(23,598,7650),(15,460,10771),(16,460,7665),(3,495,11299),(6,495,11142),(4,465,11327),(3,328,10846),(9,79,11866),(20,79,11422),(9,328,11802),(15,505,9348),(16,505,7667),(5,495,11142),(9,495,11299),(4,495,11299),(20,496,7909),(3,332,9753),(1,547,11861),(1,599,7879),(3,122,11608),(4,122,8043),(11,122,7712),(11,332,8914),(1,601,11854),(23,601,7721),(18,353,11495),(15,353,11495),(16,353,11495),(3,353,11495),(9,353,11861),(20,353,11495),(23,353,11495),(4,353,11495),(5,353,11837),(6,353,11495),(12,353,11495),(13,353,11495),(4,505,11526),(3,96,10976),(3,220,7737),(9,220,7737),(6,220,7737),(5,220,7737),(1,122,11338),(3,553,7742),(4,130,8915),(3,130,8914),(15,130,8474),(16,130,8474),(9,130,9327),(20,130,8474),(23,130,7853),(11,130,8915),(14,130,7853),(5,130,8586),(6,130,8655),(5,332,8341),(1,152,11426),(1,587,11677),(9,441,11771),(23,441,7761),(5,558,11854),(3,441,10277),(16,441,7761),(6,441,10361),(1,553,7761),(15,553,7761),(23,328,7768),(11,343,11726),(4,343,11864),(3,86,7782),(9,602,11857),(3,602,11733),(1,602,11854),(6,602,11297),(5,441,7808),(11,602,11560),(14,121,11823),(15,121,10832),(16,121,10832),(4,239,7947),(3,544,9276),(5,602,11695),(20,602,9610),(23,602,7819),(3,412,11861),(6,412,11285),(4,602,11837),(1,177,7844),(1,603,7839),(6,343,11290),(3,343,11864),(15,152,11426),(3,37,11498),(11,495,11146),(3,39,7863),(5,328,7928),(3,604,7874),(4,605,8356),(1,605,7878),(9,605,9323),(11,605,7879),(1,478,8344),(1,593,7896),(4,37,7895),(1,471,11861),(3,471,11861),(4,471,11831),(20,471,7907),(3,496,7909),(15,496,7909),(16,496,7909),(9,496,10507),(23,496,7909),(11,496,7909),(14,496,7909),(6,496,7909),(4,496,7940),(1,608,11544),(6,608,8149),(4,608,8313),(9,608,11745),(11,608,8160),(3,608,8264),(5,608,8075),(5,343,11690),(20,328,7928),(5,547,11692),(9,96,10967),(3,609,7961),(1,609,7961),(15,609,7961),(16,609,7961),(9,609,7961),(20,609,7961),(23,609,7961),(11,609,7961),(14,609,7961),(5,609,7961),(6,609,7961),(4,609,7961),(22,103,7956),(4,103,7956),(9,103,11762),(14,569,7959),(16,412,7960),(15,412,11219),(1,611,11866),(9,544,7961),(5,544,8914),(6,544,7961),(4,569,11023),(5,574,11428),(3,66,11301),(4,544,10666),(4,257,11396),(6,613,7985),(9,463,10552),(4,615,8343),(6,463,8542),(3,615,9063),(4,611,11802),(9,451,8581),(4,451,10283),(1,615,8085),(33,179,10994),(4,617,11829),(9,617,11838),(9,343,11864),(1,606,10978),(15,606,10339),(33,154,11850),(15,558,8050),(14,257,11178),(33,5627,11009),(33,370,11854),(22,486,8044),(3,486,8044),(1,486,8529),(11,451,8581),(16,463,8046),(20,615,8046),(9,615,11757),(5,451,8342),(3,451,8352),(1,451,8554),(15,451,8204),(16,451,8204),(23,451,8060),(9,332,9895),(20,332,8247),(20,451,8204),(14,451,8581),(6,451,8060),(6,332,8247),(3,601,11811),(20,257,11178),(33,3,11854),(9,599,8091),(3,599,8091),(4,599,8091),(11,601,8288),(6,606,8499),(3,606,10800),(3,103,10424),(4,620,11847),(9,620,9844),(5,620,11236),(33,121,11854),(20,343,11245),(3,337,11550),(22,79,11695),(18,79,11422),(4,574,8154),(5,96,9745),(11,620,8488),(1,620,9739),(3,620,11395),(1,337,10932),(11,337,8161),(11,257,11178),(19,79,11422),(3,98,8163),(4,606,9914),(3,60,8170),(11,615,8176),(21,79,11422),(15,122,8191),(33,325,10997),(3,132,10120),(16,620,8204),(14,343,11733),(20,544,8224),(16,332,8247),(23,332,8247),(14,332,8247),(3,569,8251),(9,569,8251),(6,620,11236),(15,620,8255),(6,96,9443),(4,590,8261),(1,624,8267),(5,605,8273),(24,460,8279),(24,3,10976),(24,10,8279),(24,53,8481),(24,506,8279),(24,154,11414),(24,370,8279),(24,332,8281),(24,69,8283),(24,43,8283),(24,520,10150),(24,47,9003),(24,27,9022),(24,20,10979),(24,554,8283),(14,554,8283),(24,606,10173),(11,606,9969),(24,55,8283),(24,451,8285),(5,478,8344),(11,452,9529),(5,452,11402),(24,132,9821),(4,626,8329),(33,394,11854),(5,626,8331),(5,615,8317),(5,554,8425),(9,412,11863),(23,412,10055),(24,121,10832),(11,412,10909),(24,454,11436),(33,2,11854),(15,132,8338),(16,132,8338),(20,132,10120),(23,132,8338),(3,478,8344),(11,478,8344),(9,478,8344),(15,478,8344),(4,478,8344),(13,79,11422),(4,629,8436),(1,343,11864),(24,79,11422),(16,465,8357),(31,2,10979),(9,558,11823),(5,597,8373),(6,558,8375),(1,634,8377),(15,634,8377),(16,634,8377),(9,634,8377),(20,634,8377),(11,634,8377),(14,634,8377),(5,634,8377),(4,634,8377),(1,629,8380),(9,5625,10979),(24,257,11178),(31,10,11398),(20,394,10951),(5,412,11692),(20,412,8996),(3,465,10979),(4,463,8542),(3,605,8394),(1,187,10668),(22,2,11662),(21,2,11095),(18,2,11033),(4,2,11836),(15,343,11426),(16,343,10868),(23,343,11245),(24,343,11245),(15,530,8429),(18,10,11738),(31,1567,11671),(9,2,11321),(4,319,8433),(4,518,11319),(11,518,11237),(14,79,11422),(9,603,11659),(1,639,8624),(15,639,8436),(20,605,8438),(3,2,11321),(1,2,11321),(11,2,11016),(5,2,11321),(6,2,10979),(20,2,8643),(23,2,8643),(24,2,8643),(14,2,9368),(19,2,9151),(12,2,10979),(13,2,8440),(16,2,8729),(15,2,11321),(4,187,8529),(24,463,8470),(24,130,8474),(9,39,8477),(5,606,8499),(1,644,8499),(3,187,8518),(5,187,8529),(4,472,11862),(3,472,10964),(11,472,9795),(5,465,11530),(9,394,11863),(9,187,10668),(6,187,10881),(24,353,11495),(30,1567,11539),(5,471,11537),(1,472,11863),(6,650,9389),(29,1567,11539),(1,652,8569),(1,653,8569),(15,653,8569),(3,654,11861),(1,654,11857),(23,654,8572),(28,1567,10979),(16,654,8572),(5,654,11695),(6,654,11285),(9,654,11861),(4,654,11831),(15,654,10745),(20,654,8572),(24,654,9288),(11,654,11207),(14,654,11804),(3,650,8572),(6,655,10908),(4,655,11215),(3,655,11553),(1,656,8624),(15,656,8624),(20,639,8624),(4,650,9764),(1,335,11864),(12,79,11422),(15,657,9912),(1,657,11854),(3,658,8811),(1,166,11797),(24,412,8726),(22,599,9060),(12,599,8744),(21,599,9050),(3,657,11854),(22,8,9020),(21,8,9020),(14,412,11733),(3,660,8841),(6,660,8841),(5,660,8841),(1,660,8841),(3,661,8856),(11,661,8856),(3,587,8869),(4,657,9924),(11,587,8872),(1,662,11507),(4,664,8950),(15,662,10745),(27,1567,10979),(3,394,11861),(1,665,10979),(25,47,10155),(25,520,10150),(25,20,10979),(25,3,11022),(25,654,9203),(25,454,9861),(25,154,11482),(25,10,10093),(25,53,10005),(25,43,9856),(25,79,11422),(25,27,9856),(25,412,9878),(25,69,10745),(25,620,9289),(25,37,9014),(14,662,10558),(25,441,9227),(25,121,10832),(25,343,11245),(25,505,9337),(4,335,11072),(25,662,9856),(25,96,9191),(25,506,9856),(23,394,10951),(25,335,9194),(4,662,11478),(25,484,9860),(25,370,9858),(9,335,11854),(3,662,11340),(20,662,9723),(26,1567,10979),(3,371,9079),(25,574,11111),(11,371,9079),(14,371,9079),(4,371,9079),(25,652,9084),(4,667,9087),(25,657,9320),(25,257,11178),(25,55,9862),(3,668,9091),(24,1567,10979),(25,602,9856),(25,539,9104),(25,140,9108),(4,669,11643),(6,669,9110),(5,669,11643),(9,669,11787),(25,669,11276),(24,669,9111),(3,669,11638),(1,669,11831),(11,662,11507),(15,544,9118),(3,118,11693),(11,118,9136),(25,408,9141),(6,484,10909),(4,484,11222),(6,275,9137),(25,394,10951),(1,275,9138),(20,408,9138),(25,130,9227),(25,587,9181),(6,394,11290),(14,394,11732),(9,657,11846),(9,484,11838),(20,96,9150),(5,394,11691),(24,394,10951),(25,2,9155),(25,670,9180),(25,332,9271),(24,602,9191),(25,671,9197),(25,353,11495),(23,484,11153),(26,47,9617),(26,53,9392),(26,370,9392),(26,412,9439),(26,55,9389),(26,662,9413),(23,662,9413),(26,43,9479),(26,27,9575),(26,394,10951),(26,602,9410),(26,257,11178),(26,10,9440),(26,520,10150),(26,484,9406),(26,454,9392),(9,662,11246),(25,132,9230),(26,69,9480),(26,343,11245),(23,1567,10979),(15,394,11819),(16,394,10951),(11,394,11095),(26,154,11414),(26,121,10832),(26,20,10979),(24,662,10118),(16,662,9413),(26,505,9382),(22,1567,11733),(1,118,10650),(9,118,10085),(24,118,10085),(23,118,9256),(20,118,9256),(25,118,9256),(5,118,9256),(26,452,9410),(25,667,9269),(26,657,9320),(4,6,9274),(26,620,9465),(26,3,10976),(26,441,9320),(14,484,9296),(26,408,9320),(9,6,10649),(26,6,9309),(26,96,9352),(26,130,9327),(9,530,11572),(26,530,9320),(25,605,9323),(6,662,11259),(21,1567,11560),(3,452,9793),(14,452,9438),(6,452,11306),(4,452,11422),(1,452,11422),(20,1567,10979),(26,654,9461),(9,677,11861),(26,677,10118),(25,677,10118),(20,677,10118),(23,677,10118),(24,677,10118),(4,677,11837),(6,677,11527),(5,677,11837),(11,677,11116),(14,677,9805),(1,677,11861),(15,677,10839),(16,677,10641),(3,677,11861),(19,1567,11368),(26,140,9384),(5,650,9389),(26,460,9389),(26,506,9545),(5,662,11340),(6,505,11301),(9,655,11553),(11,655,10685),(26,353,11495),(1,138,11836),(26,79,11422),(1,684,9809),(3,684,9461),(25,684,9466),(18,1567,10979),(15,452,9529),(3,138,11528),(20,484,9552),(4,689,10960),(9,689,10965),(5,689,11224),(11,689,10742),(5,484,9750),(27,27,9733),(27,3,10976),(16,1567,10979),(27,454,9821),(27,20,10979),(27,53,9747),(27,79,11422),(27,412,10084),(27,654,9729),(27,43,9739),(27,506,9734),(27,154,11414),(27,394,10951),(27,602,9910),(27,662,10376),(27,121,10832),(27,10,9736),(27,689,10742),(27,370,9733),(27,47,9821),(27,484,9734),(25,689,10742),(26,689,10742),(1,689,10968),(27,677,10118),(3,689,10979),(27,257,11178),(3,518,11501),(1,518,11638),(27,96,9761),(27,620,9749),(27,353,11495),(27,69,9798),(27,140,9733),(4,312,10790),(27,343,11245),(27,440,9664),(27,132,9820),(9,312,10790),(27,312,10005),(27,332,9718),(9,518,11804),(27,518,9745),(9,684,9908),(27,684,9739),(27,408,9694),(27,586,9757),(9,586,11609),(23,586,9688),(6,518,11398),(20,518,9693),(15,1567,10979),(6,586,11204),(4,586,11635),(3,586,11226),(27,452,9713),(1,312,10744),(26,684,9723),(15,484,10745),(6,684,9723),(27,671,9727),(27,520,10271),(4,395,10508),(16,484,9754),(13,1567,10979),(1,586,11574),(25,518,11057),(1,516,11374),(3,262,10806),(4,467,10954),(3,617,11838),(27,55,9787),(1,695,11838),(9,452,11422),(11,484,10302),(28,3,11300),(28,27,10026),(28,408,9812),(28,43,10019),(28,121,10832),(28,154,11414),(28,132,10118),(28,620,9844),(28,454,11823),(28,10,10093),(28,394,10951),(28,55,10013),(28,79,11422),(28,484,10039),(28,617,10036),(28,506,10013),(28,602,10018),(28,47,10012),(28,20,10979),(28,662,10356),(28,257,11178),(28,655,10026),(28,695,10016),(28,518,10037),(28,677,10118),(1,698,11609),(28,520,10271),(11,695,10422),(5,695,11694),(6,695,10887),(4,695,11631),(28,343,11245),(28,332,9895),(20,456,9824),(1,456,11673),(26,617,10127),(12,1567,10979),(3,516,11306),(27,657,9846),(28,657,10005),(27,617,9848),(24,617,10394),(23,617,9856),(28,370,10026),(1,617,11838),(28,684,9908),(6,617,10691),(28,412,10013),(9,700,10605),(28,700,9910),(1,700,9869),(28,570,9947),(28,440,9908),(28,574,11111),(28,481,9883),(9,262,10807),(28,262,10807),(28,312,10040),(28,465,10979),(9,516,11823),(28,516,10037),(9,570,10650),(11,700,9901),(15,312,9901),(27,700,9908),(28,530,9908),(28,606,9913),(20,700,9908),(28,586,10606),(9,472,11609),(28,472,9913),(9,606,10634),(1,655,11529),(6,1567,11340),(28,460,10169),(27,100,9939),(1,100,11694),(28,505,10042),(9,695,11820),(5,518,11398),(28,96,9968),(14,606,9969),(28,654,10592),(28,53,10399),(16,518,10005),(15,518,11299),(1,104,10062),(4,104,10064),(3,104,10063),(5,617,11455),(14,602,11560),(4,516,11301),(6,516,11573),(15,516,10739),(11,516,10037),(25,516,10037),(5,516,11573),(24,655,10037),(23,655,10037),(28,452,10504),(11,220,10048),(9,104,10049),(11,104,10064),(3,671,10336),(9,665,10882),(1,531,11678),(11,617,10756),(28,69,10108),(5,1567,11706),(1,705,10961),(1,706,10124),(27,702,10127),(1,361,10932),(3,361,10932),(4,361,10131),(25,100,10147),(29,47,10155),(29,20,10979),(29,695,10737),(23,695,10164),(29,3,11733),(29,121,10832),(27,460,10173),(3,710,10332),(25,496,10186),(1,711,11176),(3,577,10606),(29,602,11542),(4,1567,11863),(1,671,11694),(4,671,10264),(1,712,10825),(1,710,11428),(29,520,10271),(6,710,10332),(11,710,10242),(29,394,10951),(3,700,10259),(1,715,10264),(3,715,10264),(28,353,11495),(29,353,11495),(1,714,10278),(3,1567,11861),(29,505,10333),(1,1567,11866),(4,705,10287),(29,257,11178),(29,460,10823),(25,460,10329),(6,712,10890),(9,710,11412),(29,454,11823),(4,712,11709),(4,118,10951),(15,712,10384),(3,695,11543),(29,617,10756),(20,617,10756),(9,611,11866),(28,611,11838),(9,138,11728),(11,1567,10979),(11,138,10742),(5,138,11728),(6,138,11340),(1,467,10429),(1,379,11430),(14,471,10436),(30,370,11266),(30,394,10951),(30,53,10803),(30,10,10807),(30,484,10813),(30,154,11414),(30,79,11721),(30,454,11543),(30,3,11725),(30,655,10800),(30,611,10822),(30,412,10799),(9,705,10534),(30,705,10534),(1,725,10863),(30,460,10800),(30,606,10804),(30,506,10803),(30,602,11542),(30,257,11178),(30,55,10803),(30,465,10979),(30,20,10979),(1,726,11557),(30,121,10832),(1,727,10474),(30,103,10573),(27,103,10474),(28,103,10474),(11,103,10474),(30,505,10832),(30,27,10799),(30,662,10846),(30,527,10932),(30,138,10803),(30,654,10803),(30,343,11245),(3,712,10979),(30,677,10814),(30,520,10805),(30,438,10539),(30,728,10487),(9,728,10487),(4,728,10487),(30,47,11017),(30,695,10678),(30,391,10490),(30,471,10504),(9,260,11767),(30,260,10494),(30,96,10650),(9,437,11161),(30,437,10497),(20,437,10495),(9,714,10817),(30,714,10817),(30,726,10495),(30,731,10495),(4,714,10817),(9,379,11608),(30,379,10643),(6,731,10502),(30,701,10560),(30,617,11583),(30,452,10504),(6,471,11315),(30,496,10542),(30,467,10507),(4,733,10508),(6,733,10508),(30,516,10848),(30,735,10587),(30,702,10815),(29,654,10733),(3,714,10512),(1,736,11662),(30,585,10603),(30,706,10523),(9,585,11588),(30,308,10808),(30,312,10534),(30,530,10641),(30,737,10532),(1,738,10925),(30,547,10808),(30,441,10698),(27,606,10534),(30,353,11495),(30,518,10803),(6,585,10536),(5,585,10536),(3,585,11398),(11,585,10536),(29,547,11195),(3,438,10538),(1,438,11671),(9,438,11837),(30,166,10541),(30,433,10542),(30,689,10800),(30,440,10608),(30,740,10547),(1,260,11637),(30,586,10608),(30,463,10552),(3,735,11424),(9,527,11805),(1,744,10583),(30,380,10882),(9,380,11637),(27,380,10587),(3,380,11560),(1,380,11671),(15,380,10932),(16,380,10603),(30,408,10641),(14,1567,11733),(30,700,10605),(3,607,10606),(27,465,10608),(16,586,10608),(9,726,10608),(29,726,10608),(27,611,11838),(30,335,10640),(1,731,10641),(1,735,10794),(16,602,10641),(4,380,11131),(3,749,11374),(3,750,10967),(30,750,10643),(5,750,10643),(1,750,10794),(9,750,10934),(3,751,10647),(1,6,10649),(30,6,10649),(30,570,10650),(15,547,10741),(15,187,10668),(1,527,11671),(1,752,11313),(33,1567,11850),(3,752,10680),(15,752,10680),(16,752,10680),(9,752,10680),(30,752,10680),(28,752,10680),(27,752,10680),(29,752,10680),(26,752,10680),(25,752,10680),(24,752,10680),(23,752,10680),(20,752,10680),(11,752,10680),(14,752,10680),(5,752,10680),(6,752,10680),(4,752,10680),(5,655,11252),(3,665,10720),(15,432,10737),(15,308,11315),(15,695,10744),(1,228,11499),(4,138,11728),(15,689,10742),(16,689,10742),(28,689,10742),(29,689,10742),(24,689,10742),(23,689,10742),(20,689,10742),(14,689,10742),(6,689,10868),(30,69,10745),(29,69,10745),(4,379,11212),(3,312,10746),(20,379,10778),(1,757,10750),(15,757,10749),(6,757,10752),(21,312,10763),(30,758,10763),(1,758,10764),(1,236,11340),(3,761,10784),(15,762,10783),(1,762,10783),(4,761,10784),(1,256,11214),(11,761,10785),(1,171,10794),(30,725,10797),(1,670,11841),(1,607,11061),(1,708,11332),(29,412,10803),(5,527,10806),(4,527,11641),(1,262,10806),(30,262,10807),(6,262,10807),(20,531,10808),(3,702,10815),(30,256,10821),(29,655,10821),(29,677,10821),(3,437,10822),(4,437,10822),(3,611,11733),(1,767,10840),(15,767,10824),(3,335,10825),(11,335,10825),(1,437,11531),(3,767,10831),(9,712,10879),(5,712,10837),(25,1567,10979),(4,670,10839),(1,522,10960),(6,767,10840),(16,767,10840),(5,670,10846),(9,1567,11865),(3,56,10846),(14,56,10846),(9,56,10846),(28,771,10847),(9,670,11841),(30,670,10853),(1,702,11672),(1,580,10867),(1,775,11108),(29,343,11245),(29,527,10869),(20,527,10869),(5,380,11637),(1,777,10879),(28,380,10882),(6,775,10882),(29,665,10882),(26,665,10882),(25,665,10882),(27,665,10882),(3,256,10882),(1,220,11560),(4,775,10922),(30,337,10932),(33,47,11854),(6,380,10932),(30,132,10933),(29,611,11838),(3,737,10940),(1,737,10940),(1,785,10940),(1,786,10941),(3,740,10942),(29,788,10945),(1,788,10947),(3,708,11307),(11,569,10963),(1,493,11424),(29,380,10965),(25,380,10965),(20,380,10965),(11,380,10965),(1,789,10967),(1,740,10970),(11,527,10979),(9,471,11840),(4,228,11111),(5,569,10979),(33,53,11850),(33,497,11680),(1,497,11694),(4,497,11139),(33,454,11857),(33,10,11857),(33,55,11802),(33,1568,11666),(4,1568,11639),(3,1568,11639),(33,471,11850),(33,412,11850),(33,506,11854),(33,2527,11838),(33,1931,11009),(33,4720,11009),(33,205,11014),(33,611,11861),(33,558,11861),(14,558,11014),(33,275,11285),(33,1619,11854),(9,1619,11863),(4,1619,11862),(1,1619,11862),(3,1619,11862),(33,461,11861),(1,461,11861),(14,461,11838),(33,159,11017),(14,159,11017),(33,353,11495),(33,518,11630),(33,695,11694),(33,505,11675),(33,460,11733),(33,569,11024),(33,441,11628),(33,69,11550),(33,343,11854),(1,2527,11866),(33,4158,11376),(33,79,11850),(1,371,11057),(14,1568,11325),(4,461,11838),(4,2527,11834),(33,308,11823),(33,335,11834),(5,31,11074),(33,337,11482),(33,5,11090),(4,5,11857),(4,1490,11837),(9,1490,11837),(33,5631,11098),(4,558,11861),(1,5065,11823),(1,4792,11831),(6,5632,11108),(24,5632,11108),(33,5632,11108),(33,654,11857),(6,122,11108),(33,3636,11733),(33,27,11609),(1,2059,11609),(1,1135,11535),(9,5532,11109),(9,5636,11671),(30,5636,11108),(29,5636,11108),(27,5636,11108),(28,5636,11108),(26,5636,11108),(25,5636,11108),(24,5636,11108),(23,5636,11108),(20,5636,11108),(1,5636,11671),(15,5636,11671),(3,5636,11671),(5,5636,11671),(6,5636,11290),(33,5636,11683),(14,5636,11683),(11,5636,11683),(4,5636,11733),(33,5351,11560),(11,5351,11396),(1,5480,11146),(1,5117,11778),(33,711,11108),(4,5532,11108),(33,5532,11109),(1,5532,11298),(14,3636,11150),(9,488,11110),(9,781,11110),(1,4386,11110),(9,1493,11299),(29,1493,11110),(1,1493,11309),(33,3932,11111),(3,5036,11111),(1,1498,11315),(5,5036,11111),(3,456,11111),(1,5036,11111),(33,516,11630),(33,547,11861),(14,547,11114),(5,109,11114),(33,657,11256),(4,1284,11116),(9,3354,11572),(1,3354,11143),(3,1284,11116),(6,2774,11116),(33,332,11116),(19,10,11398),(13,10,11116),(33,677,11861),(4,2318,11116),(1,749,11374),(33,740,11117),(33,5266,11142),(33,662,11507),(1,2373,11120),(3,497,11539),(5,497,11120),(33,4897,11120),(33,488,11226),(33,726,11230),(4,488,11124),(1,4001,11124),(1,3888,11124),(33,5643,11157),(33,1493,11131),(1,5351,11609),(4,1493,11421),(1,1561,11693),(1,5643,11159),(29,749,11132),(28,749,11132),(23,749,11132),(33,453,11183),(1,2566,11136),(1,5651,11532),(6,453,11140),(1,4720,11230),(4,453,11184),(30,5650,11142),(33,495,11327),(1,3369,11430),(33,3354,11268),(14,495,11144),(14,3354,11144),(11,3354,11146),(33,602,11719),(3,5643,11146),(3,5351,11609),(33,43,11163),(5,453,11146),(9,5351,11609),(4,5351,11609),(5,5351,11561),(33,448,11146),(5,448,11146),(5,1875,11146),(1,4595,11146),(3,3636,11733),(9,5239,11150),(11,3636,11150),(1,3636,11786),(15,3636,11150),(9,3636,11786),(30,3636,11150),(29,3636,11150),(27,3636,11150),(28,3636,11150),(26,3636,11150),(25,3636,11150),(24,3636,11150),(23,3636,11150),(20,3636,11150),(5,3636,11726),(6,3636,11333),(4,3636,11854),(1,4748,11152),(9,601,11854),(33,250,11854),(15,5643,11157),(33,5676,11157),(1,5593,11157),(1,5115,11203),(1,464,11510),(33,228,11573),(33,464,11495),(9,5643,11158),(1,2969,11158),(1,1616,11854),(3,453,11159),(1,2127,11827),(5,749,11363),(15,669,11627),(3,1493,11339),(1,5681,11161),(4,431,11161),(1,5683,11161),(3,5683,11161),(33,437,11161),(11,437,11161),(1,5684,11161),(3,207,11161),(1,5340,11168),(9,1807,11168),(30,1807,11168),(29,1807,11168),(27,1807,11168),(28,1807,11168),(26,1807,11168),(25,1807,11168),(24,1807,11168),(23,1807,11168),(20,1807,11168),(1,1807,11480),(15,1807,11168),(3,1807,11480),(5,1807,11480),(6,1807,11168),(33,1807,11480),(14,1807,11168),(11,1807,11168),(4,1807,11480),(1,585,11334),(9,4882,11816),(1,4882,11859),(3,4882,11860),(4,4882,11170),(33,1616,11854),(33,5650,11396),(1,5650,11476),(9,711,11174),(3,711,11184),(33,5109,11177),(33,5688,11177),(14,5688,11177),(1,1475,11177),(33,874,11177),(1,3790,11177),(1,874,11177),(1,221,11560),(1,5690,11178),(4,5515,11177),(1,5688,11177),(3,5688,11177),(9,5688,11177),(29,5688,11177),(33,752,11178),(33,586,11636),(33,257,11179),(14,5351,11396),(1,4128,11327),(14,453,11183),(1,1245,11866),(3,1245,11733),(33,1245,11810),(33,472,11716),(1,1782,11213),(9,4792,11618),(3,1616,11820),(1,911,11186),(1,5703,11192),(1,5709,11192),(3,2059,11192),(3,4840,11192),(33,5065,11193),(1,2342,11325),(27,547,11195),(28,547,11195),(33,2342,11195),(33,3276,11199),(11,3276,11199),(1,3276,11199),(14,518,11199),(3,3276,11199),(1,5668,11208),(9,3445,11199),(15,3445,11199),(1,3445,11430),(33,3666,11200),(1,3666,11200),(5,2527,11690),(4,166,11202),(1,5577,11204),(3,5577,11204),(15,166,11204),(5,586,11226),(4,1616,11716),(33,256,11215),(4,256,11207),(5,1616,11716),(1,5166,11207),(5,5746,11207),(3,5746,11207),(1,5746,11207),(1,1136,11284),(1,1819,11208),(3,1490,11732),(1,5694,11531),(33,5748,11211),(3,5748,11561),(1,5171,11212),(1,5673,11215),(3,1379,11215),(1,3444,11215),(3,5673,11525),(5,166,11215),(33,5750,11215),(30,1490,11231),(33,1490,11807),(1,5750,11863),(1,5739,11710),(33,5651,11552),(33,166,11822),(33,484,11854),(5,1379,11222),(33,670,11334),(1,77,11224),(1,4840,11298),(3,5672,11223),(3,2527,11733),(33,5752,11226),(3,726,11528),(5,250,11685),(9,1522,11778),(1,5672,11621),(1,5262,11412),(33,5262,11231),(1,1490,11721),(33,5075,11233),(25,5083,11233),(3,5689,11295),(3,5532,11276),(6,5532,11235),(5,5689,11235),(9,1616,11838),(1,5083,11236),(6,2527,11237),(15,1619,11237),(33,655,11553),(14,655,11239),(33,493,11424),(1,4712,11241),(1,5689,11250),(33,775,11250),(14,775,11250),(11,775,11250),(33,24,11253),(1,24,11253),(33,4840,11253),(1,565,11253),(1,5757,11253),(1,2312,11528),(4,1245,11460),(5,1245,11460),(1,4353,11256),(1,5723,11290),(33,1522,11264),(3,5757,11260),(4,5757,11260),(1,1522,11264),(29,370,11266),(15,1135,11266),(1,431,11281),(9,431,11266),(1,5765,11266),(1,5355,11304),(33,5739,11266),(1,5701,11269),(6,5701,11269),(15,1122,11273),(9,1122,11273),(1,1122,11599),(33,5771,11273),(29,471,11273),(24,471,11273),(1,5771,11282),(1,1890,11273),(3,3374,11802),(4,5774,11854),(33,5774,11276),(9,5774,11276),(5,5774,11290),(3,5774,11290),(1,5774,11284),(30,5774,11276),(29,5774,11276),(27,5774,11276),(28,5774,11276),(26,5774,11276),(25,5774,11276),(24,5774,11276),(23,5774,11276),(20,5774,11276),(15,5774,11276),(6,5774,11276),(14,5774,11276),(11,5774,11276),(5,5532,11276),(23,669,11276),(9,1245,11863),(1,5777,11276),(3,5775,11280),(1,5780,11299),(9,1568,11816),(30,1568,11282),(5,461,11838),(9,461,11861),(15,461,11854),(33,5779,11284),(33,5674,11284),(1,5674,11297),(30,5674,11284),(3,236,11285),(5,236,11285),(33,236,11285),(4,275,11285),(9,4496,11836),(30,4496,11286),(1,2259,11300),(15,2259,11288),(5,1490,11695),(1,5782,11290),(6,1490,11291),(11,1490,11291),(33,5791,11293),(3,5791,11294),(33,5028,11298),(14,5028,11298),(1,3452,11299),(1,5796,11299),(4,5796,11299),(3,461,11861),(3,5796,11299),(1,426,11299),(31,353,11495),(3,5028,11300),(1,4669,11658),(1,417,11300),(1,3443,11694),(33,3443,11300),(14,1490,11300),(33,3780,11848),(1,3780,11849),(9,5650,11398),(1,5107,11300),(3,5675,11300),(1,3514,11300),(1,5028,11300),(33,5806,11301),(1,5806,11304),(14,472,11301),(9,2527,11866),(33,617,11305),(4,5643,11305),(1,56,11305),(5,1619,11854),(6,1619,11307),(1,5299,11309),(11,1568,11325),(14,497,11312),(33,5119,11312),(33,4128,11318),(14,308,11823),(15,471,11315),(6,1245,11315),(14,1619,11784),(11,1619,11317),(30,1619,11317),(29,1619,11820),(9,4247,11318),(1,3353,11672),(3,3353,11319),(5,3353,11319),(15,3353,11319),(20,3353,11319),(11,3353,11319),(1,707,11669),(15,707,11319),(33,5814,11319),(1,5816,11327),(9,5814,11320),(1,5814,11320),(15,5814,11320),(4,4669,11671),(3,4669,11671),(33,911,11325),(33,574,11411),(1,1568,11467),(3,5820,11337),(1,5820,11326),(9,5816,11327),(4,5650,11398),(4,4128,11327),(33,3353,11330),(3,5809,11330),(4,5809,11395),(33,708,11334),(5,4669,11448),(9,4669,11671),(6,4669,11334),(33,4669,11671),(1,5759,11543),(5,1568,11544),(6,1568,11334),(1,5826,11337),(3,5826,11339),(29,5826,11337),(1,5827,11337),(9,749,11339),(30,749,11339),(33,456,11672),(11,456,11339),(9,5827,11339),(30,5827,11339),(29,3381,11339),(3,3381,11339),(1,5828,11339),(30,1245,11340),(1,724,11340),(6,5650,11340),(34,3,11728),(31,3,11728),(34,1567,11701),(1,3448,11659),(31,47,11714),(34,47,11714),(33,4882,11373),(3,5650,11460),(30,5351,11396),(33,452,11374),(3,5834,11379),(33,138,11728),(3,5308,11686),(33,3681,11383),(34,79,11695),(34,121,11617),(1,5809,11395),(9,5809,11557),(5,5809,11395),(1,5836,11395),(3,5836,11396),(29,5351,11440),(27,5351,11396),(28,5351,11396),(26,5351,11396),(25,5351,11396),(24,5351,11396),(23,5351,11396),(20,5351,11440),(15,5351,11396),(6,5351,11396),(31,27,11396),(34,27,11609),(34,353,11657),(3,5838,11398),(9,5838,11398),(1,5838,11398),(9,2467,11398),(29,506,11414),(1,4320,11398),(31,121,11715),(1,351,11408),(5,351,11408),(23,710,11412),(26,710,11412),(4,456,11414),(29,154,11482),(31,154,11482),(3,422,11556),(22,1568,11415),(21,1568,11415),(31,1568,11415),(12,1568,11415),(1,5779,11665),(1,5010,11418),(34,43,11560),(33,4539,11421),(1,4539,11422),(34,10,11763),(5,79,11694),(15,79,11422),(16,79,11422),(23,79,11422),(29,79,11721),(31,79,11525),(15,464,11424),(9,735,11424),(1,5191,11450),(1,3832,11430),(1,86,11432),(1,15,11446),(3,5859,11440),(1,5859,11440),(1,5860,11440),(3,15,11446),(33,351,11448),(15,4669,11460),(29,4669,11631),(3,5863,11452),(1,2580,11452),(3,5065,11453),(33,5855,11454),(1,5160,11668),(33,929,11460),(1,372,11523),(34,69,11460),(3,523,11462),(1,5776,11690),(1,3785,11483),(3,5887,11525),(1,5885,11838),(33,5885,11710),(5,337,11608),(3,166,11491),(14,464,11495),(33,221,11560),(4,221,11557),(9,464,11495),(4,464,11495),(3,5056,11499),(15,5056,11499),(20,5056,11499),(1,5056,11534),(23,5056,11499),(25,5056,11499),(26,5056,11499),(24,5056,11499),(28,5056,11499),(24,228,11499),(25,228,11499),(30,228,11499),(5,269,11501),(9,5887,11838),(3,5897,11638),(1,5897,11665),(4,5897,11550),(33,5897,11665),(14,5897,11508),(11,5897,11510),(9,5897,11637),(5,5897,11528),(6,5897,11512),(1,4605,11717),(29,5887,11514),(28,5887,11514),(1,4728,11514),(5,4728,11514),(9,4728,11514),(6,4728,11514),(3,4728,11515),(15,1490,11514),(4,4728,11515),(33,140,11666),(5,320,11525),(1,320,11525),(1,3722,11662),(5,5887,11525),(1,5887,11525),(1,5490,11526),(33,767,11527),(29,5897,11526),(20,5897,11526),(11,767,11527),(1,577,11529),(1,4140,11529),(1,5914,11531),(3,5694,11531),(27,250,11532),(28,250,11532),(26,250,11532),(25,250,11532),(9,4535,11535),(1,4535,11535),(3,4535,11535),(5,4535,11535),(15,5885,11715),(4,5776,11537),(1,5793,11539),(29,775,11539),(3,5776,11539),(3,4378,11539),(4,4378,11539),(33,527,11627),(33,5909,11560),(4,5909,11541),(9,5909,11847),(1,5924,11541),(9,5928,11543),(3,5932,11543),(1,3536,11543),(1,4851,11550),(15,4851,11544),(5,4851,11544),(1,279,11698),(15,279,11544),(1,1931,11546),(4,5343,11726),(3,5779,11547),(3,5343,11726),(5,5779,11547),(15,702,11548),(4,4265,11549),(1,234,11552),(3,234,11609),(33,260,11552),(3,260,11552),(3,4543,11556),(1,4094,11560),(33,3886,11557),(4,3889,11557),(3,221,11557),(9,5832,11802),(9,497,11557),(30,5809,11557),(1,3852,11758),(20,4094,11560),(29,4094,11560),(15,602,11560),(20,611,11560),(20,558,11561),(9,5748,11561),(1,5748,11561),(33,4851,11561),(35,1567,11861),(35,3,11725),(35,308,11706),(4,3722,11571),(35,1987,11671),(35,47,11671),(35,4827,11572),(35,654,11671),(35,343,11671),(35,587,11733),(9,587,11866),(35,454,11837),(35,3327,11823),(35,530,11572),(9,3327,11823),(35,335,11785),(35,154,11733),(35,132,11639),(35,607,11616),(35,3354,11572),(9,874,11572),(35,2527,11681),(35,166,11637),(35,4607,11572),(9,166,11822),(35,337,11572),(35,408,11662),(35,516,11608),(35,221,11573),(35,412,11670),(9,221,11572),(35,547,11671),(35,5651,11609),(35,695,11669),(35,79,11721),(9,5308,11824),(35,5308,11609),(9,775,11573),(35,2089,11573),(35,53,11804),(35,4792,11617),(35,3889,11609),(35,505,11733),(35,602,11670),(35,613,11668),(35,10,11671),(35,5909,11662),(30,775,11573),(35,657,11573),(35,701,11659),(35,5155,11573),(35,497,11630),(35,5848,11612),(35,4608,11608),(35,440,11573),(35,461,11854),(35,790,11573),(35,472,11609),(35,2510,11573),(35,611,11733),(35,370,11670),(35,3790,11573),(9,2510,11573),(30,2510,11573),(35,5911,11573),(35,5311,11573),(35,394,11725),(9,4608,11608),(35,608,11573),(9,5911,11573),(35,228,11588),(4,4216,11573),(35,5917,11573),(33,2089,11573),(9,5917,11573),(9,234,11609),(30,2527,11573),(35,234,11609),(5,5748,11573),(35,2509,11573),(35,353,11695),(35,3538,11573),(35,1619,11854),(35,471,11725),(35,543,11574),(1,3449,11574),(35,586,11635),(9,3448,11802),(35,3448,11600),(9,228,11588),(35,518,11683),(35,441,11631),(35,5900,11580),(9,363,11801),(35,363,11659),(35,3636,11726),(35,5333,11580),(35,506,11671),(35,617,11585),(35,731,11590),(35,5739,11609),(35,585,11588),(35,523,11613),(35,3446,11609),(35,527,11671),(35,669,11643),(35,250,11658),(35,417,11592),(35,484,11733),(33,698,11595),(14,698,11595),(35,5262,11600),(9,698,11609),(35,698,11609),(35,1279,11832),(35,595,11655),(1,4827,11608),(9,3852,11608),(3,3852,11733),(35,3852,11608),(9,740,11608),(35,740,11608),(35,467,11662),(35,260,11608),(35,379,11608),(1,5348,11708),(35,177,11608),(3,5348,11683),(35,1245,11619),(35,1246,11610),(35,5897,11637),(35,598,11609),(9,574,11823),(35,574,11609),(9,2259,11823),(35,2259,11631),(33,790,11609),(1,2435,11609),(9,2435,11609),(35,2435,11609),(9,2059,11609),(35,2059,11609),(1,5941,11609),(4,523,11609),(3,698,11609),(4,698,11609),(33,5669,11609),(4,5669,11609),(3,5669,11609),(35,702,11609),(35,5351,11609),(9,3889,11733),(35,3536,11609),(35,460,11671),(35,2127,11628),(3,5917,11610),(1,5936,11610),(1,5669,11612),(5,5943,11612),(9,523,11643),(35,328,11614),(1,5943,11628),(35,121,11671),(35,138,11668),(35,652,11621),(33,570,11632),(35,5885,11638),(6,461,11627),(33,463,11820),(1,3327,11823),(35,4669,11671),(5,2259,11631),(15,527,11631),(3,527,11660),(30,4669,11631),(35,71,11631),(9,71,11631),(33,530,11631),(33,4827,11660),(35,380,11638),(3,239,11639),(35,239,11643),(35,5945,11640),(1,523,11643),(1,1987,11683),(33,5171,11645),(11,5171,11645),(35,603,11659),(35,5157,11659),(1,5157,11659),(33,3448,11659),(33,1379,11660),(1,1379,11660),(9,1379,11660),(35,1379,11660),(4,5885,11660),(33,669,11660),(9,5885,11805),(3,5885,11805),(35,2312,11660),(35,677,11673),(1,1279,11834),(1,5954,11715),(9,531,11662),(29,531,11662),(35,140,11668),(35,1568,11666),(1,4383,11668),(33,5955,11668),(1,1052,11668),(35,1052,11668),(15,1052,11668),(9,1052,11668),(35,707,11668),(1,2461,11694),(35,1616,11733),(3,5966,11671),(35,43,11836),(5,5348,11671),(9,1987,11767),(30,1987,11671),(29,1987,11671),(27,1987,11671),(20,1987,11671),(28,1987,11671),(25,1987,11671),(3,1987,11672),(35,27,11671),(35,5636,11671),(3,5970,11671),(29,438,11671),(1,5970,11671),(33,5686,11671),(33,5970,11671),(1,5724,11672),(3,5724,11672),(5,5724,11672),(33,5057,11831),(1,5980,11675),(9,4027,11695),(1,4027,11695),(23,4027,11676),(9,5968,11857),(35,5968,11678),(1,4099,11678),(3,2123,11680),(1,5988,11847),(3,5988,11733),(14,5968,11680),(3,5968,11681),(1,25,11712),(6,279,11681),(9,6000,11805),(33,6001,11683),(4,5348,11683),(33,5348,11683),(5,122,11684),(33,5200,11685),(3,5160,11686),(15,2657,11686),(3,2657,11716),(5,5308,11686),(33,5308,11686),(4,5308,11686),(35,5887,11686),(1,5990,11819),(5,472,11691),(33,20,11692),(5,5885,11693),(15,1561,11693),(9,3536,11792),(33,100,11694),(11,100,11694),(9,100,11804),(35,100,11694),(4,3443,11694),(5,4605,11694),(9,4605,11694),(35,4027,11695),(33,652,11795),(1,5200,11709),(35,4882,11713),(1,3374,11863),(1,5176,11713),(33,4693,11714),(3,5978,11714),(1,5978,11714),(9,4710,11804),(33,2127,11716),(3,6028,11718),(1,6057,11716),(4,352,11716),(24,5988,11720),(9,6028,11796),(36,79,11861),(36,1567,11854),(36,154,11837),(36,471,11836),(36,611,11836),(5,611,11725),(36,3,11836),(36,394,11863),(33,5343,11726),(14,5343,11726),(11,5343,11726),(9,5,11726),(36,5,11726),(36,3636,11786),(36,1490,11837),(36,343,11836),(36,654,11836),(36,370,11859),(36,454,11837),(36,460,11838),(36,138,11728),(36,353,11836),(36,239,11854),(29,239,11728),(36,10,11839),(33,6065,11733),(14,6065,11733),(9,3352,11732),(30,3352,11732),(3,6065,11733),(36,412,11838),(36,506,11838),(9,6087,11733),(36,6087,11802),(36,3889,11733),(36,670,11841),(1,4710,11733),(36,5757,11805),(36,618,11733),(36,5308,11824),(35,570,11733),(36,53,11838),(36,6075,11733),(36,6005,11733),(36,6060,11733),(36,5883,11804),(36,6017,11733),(36,5965,11733),(35,2123,11733),(36,6065,11733),(35,6065,11733),(36,463,11733),(36,1522,11778),(36,55,11799),(33,498,11733),(36,5988,11733),(36,461,11838),(36,5117,11733),(36,602,11837),(36,3448,11802),(36,601,11836),(36,5861,11733),(36,4710,11804),(36,441,11771),(36,547,11839),(33,6024,11733),(36,6000,11805),(9,2123,11733),(36,2123,11733),(14,695,11733),(36,5111,11804),(35,4710,11733),(9,5111,11804),(35,5982,11733),(36,740,11733),(9,192,11824),(35,25,11733),(35,3780,11746),(36,250,11831),(36,192,11824),(36,5057,11833),(36,558,11823),(36,1616,11841),(36,3932,11733),(36,428,11802),(36,5311,11861),(35,6096,11733),(36,5983,11733),(36,6016,11733),(36,6037,11733),(36,6007,11733),(36,6024,11740),(36,484,11838),(36,257,11736),(36,617,11838),(36,5885,11805),(3,6024,11740),(9,6024,11740),(20,6024,11740),(36,1245,11863),(36,256,11799),(36,166,11822),(36,608,11745),(36,103,11762),(36,6076,11746),(36,308,11823),(36,3443,11838),(36,518,11804),(9,3780,11799),(36,3780,11799),(36,438,11837),(36,574,11823),(36,3536,11792),(36,695,11820),(36,2657,11796),(36,615,11757),(36,6006,11847),(36,1987,11767),(9,2657,11796),(36,363,11801),(36,6078,11841),(36,527,11805),(36,5116,11767),(36,260,11767),(36,657,11846),(36,5750,11807),(35,438,11769),(36,47,11854),(9,6006,11847),(36,1568,11816),(36,4399,11802),(36,6072,11773),(9,5990,11778),(36,1279,11832),(36,5942,11805),(36,6056,11805),(36,6089,11802),(36,3684,11781),(3,6089,11783),(36,669,11787),(36,1619,11854),(36,6093,11784),(36,335,11838),(36,652,11787),(36,132,11804),(36,4720,11792),(36,6033,11792),(36,100,11804),(9,428,11802),(36,6028,11796),(36,5058,11798),(36,587,11866),(36,5832,11802),(36,6036,11800),(33,5111,11801),(9,4827,11802),(36,4827,11802),(9,5942,11805),(1,6089,11802),(36,3374,11802),(36,6051,11802),(9,3374,11802),(36,5947,11802),(36,328,11802),(25,611,11802),(36,408,11861),(36,465,11802),(36,2527,11835),(33,3979,11802),(36,3549,11802),(36,5572,11802),(36,5978,11804),(3,5942,11804),(36,3979,11804),(4,192,11804),(36,6096,11805),(3,6088,11805),(33,6078,11809),(3,6078,11805),(36,440,11805),(9,5750,11807),(36,5968,11857),(36,3327,11823),(9,6078,11841),(36,4882,11816),(4,6078,11805),(35,601,11810),(1,5308,11806),(1,6083,11807),(9,6083,11807),(36,6083,11807),(33,618,11808),(36,505,11809),(29,601,11809),(9,4216,11825),(36,4216,11824),(14,1245,11810),(3,4216,11810),(36,5901,11810),(33,3549,11810),(36,2127,11827),(36,6102,11819),(1,6104,11819),(27,1619,11820),(28,1619,11820),(25,1619,11820),(20,1619,11820),(33,122,11820),(5,6102,11820),(36,2259,11823),(1,192,11823),(35,558,11823),(33,380,11823),(36,4496,11836),(3,4496,11823),(36,516,11823),(36,121,11854),(9,5065,11823),(1,4216,11825),(36,5950,11834),(33,6058,11829),(35,2128,11831),(9,5057,11833),(9,1279,11832),(33,5068,11835),(35,5111,11834),(1,5068,11835),(3,5068,11835),(1,6002,11854),(3,5950,11835),(4,5950,11836),(36,43,11836),(4,2657,11837),(33,2657,11837),(11,2657,11837),(36,677,11838),(5,5988,11838),(35,5988,11838),(14,2527,11838),(1,5116,11838),(3,5116,11838),(33,363,11838),(4,6006,11838),(33,3684,11838),(14,1616,11838),(33,3374,11843),(33,5965,11843),(11,5965,11843),(35,6006,11847),(1,3494,11857),(1,6107,11854),(33,6002,11854),(1,5968,11857),(1,6006,11858),(3,5837,11859),(9,279,11861),(9,5311,11861),(1,503,11861),(3,6115,11861),(5,6115,11861),(1,6115,11861),(1,6060,11866);
/*!40000 ALTER TABLE `ia_smf_log_boards` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_errors`
--

DROP TABLE IF EXISTS `ia_smf_log_errors`;
CREATE TABLE `ia_smf_log_errors` (
  `ID_ERROR` mediumint(8) unsigned NOT NULL auto_increment,
  `logTime` int(10) unsigned NOT NULL default '0',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `ip` varchar(16) collate latin1_general_ci NOT NULL default '',
  `url` text collate latin1_general_ci NOT NULL,
  `message` text collate latin1_general_ci NOT NULL,
  `session` varchar(32) collate latin1_general_ci NOT NULL default '',
  PRIMARY KEY  (`ID_ERROR`),
  KEY `logTime` (`logTime`),
  KEY `ID_MEMBER` (`ID_MEMBER`),
  KEY `ip` (`ip`)
) ENGINE=MyISAM AUTO_INCREMENT=125724 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_errors`
--

LOCK TABLES `ia_smf_log_errors` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_errors` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_log_errors` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_floodcontrol`
--

DROP TABLE IF EXISTS `ia_smf_log_floodcontrol`;
CREATE TABLE `ia_smf_log_floodcontrol` (
  `ip` char(16) collate latin1_general_ci NOT NULL default '',
  `logTime` int(10) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ip`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_floodcontrol`
--

LOCK TABLES `ia_smf_log_floodcontrol` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_floodcontrol` DISABLE KEYS */;
INSERT INTO `ia_smf_log_floodcontrol` VALUES ('87.239.161.135',1170097669);
/*!40000 ALTER TABLE `ia_smf_log_floodcontrol` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_karma`
--

DROP TABLE IF EXISTS `ia_smf_log_karma`;
CREATE TABLE `ia_smf_log_karma` (
  `ID_TARGET` mediumint(8) unsigned NOT NULL default '0',
  `ID_EXECUTOR` mediumint(8) unsigned NOT NULL default '0',
  `logTime` int(10) unsigned NOT NULL default '0',
  `action` tinyint(4) NOT NULL default '0',
  `Description` tinytext collate latin1_general_ci NOT NULL,
  `link` text collate latin1_general_ci NOT NULL,
  `is_read` int(11) NOT NULL default '0',
  KEY `logTime` (`logTime`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_karma`
--

LOCK TABLES `ia_smf_log_karma` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_karma` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_log_karma` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_mark_read`
--

DROP TABLE IF EXISTS `ia_smf_log_mark_read`;
CREATE TABLE `ia_smf_log_mark_read` (
  `ID_BOARD` smallint(5) unsigned NOT NULL default '0',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `logTime` int(10) unsigned NOT NULL default '0',
  `ID_MSG` mediumint(8) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_MEMBER`,`ID_BOARD`),
  KEY `logTime` (`logTime`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_mark_read`
--

LOCK TABLES `ia_smf_log_mark_read` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_mark_read` DISABLE KEYS */;
INSERT INTO `ia_smf_log_mark_read` VALUES (1,3,0,11654),(3,3,0,10976),(4,3,0,10976),(5,3,0,10976),(6,3,0,10976),(9,3,0,11725),(11,3,0,10976),(12,3,0,10976),(13,3,0,10976),(14,3,0,10976),(15,3,0,10976),(16,3,0,10976),(18,3,0,10976),(19,3,0,10976),(20,3,0,10976),(21,3,0,10976),(3,154,0,11414),(1,154,0,11655),(16,154,0,7413),(15,154,0,11414),(9,154,0,11414),(20,154,0,11414),(23,154,0,11414),(11,154,0,11414),(14,154,0,11414),(5,154,0,11414),(6,154,0,11414),(4,154,0,11414),(3,53,0,7414),(1,53,0,7414),(16,53,0,7414),(15,53,0,7414),(9,53,0,7414),(20,53,0,7414),(23,53,0,7414),(11,53,0,7414),(14,53,0,7414),(5,53,0,7414),(6,53,0,7414),(4,53,0,7414),(3,20,0,10979),(1,20,0,10979),(16,20,0,10979),(15,20,0,10979),(9,20,0,10979),(20,20,0,10979),(23,20,0,10979),(11,20,0,10979),(14,20,0,10979),(5,20,0,10979),(6,20,0,10979),(21,20,0,10979),(12,20,0,10979),(4,20,0,10979),(31,1567,0,10979),(1,96,0,7820),(30,1567,0,10979),(3,546,0,7834),(1,546,0,7834),(16,546,0,7834),(15,546,0,7834),(9,546,0,7834),(20,546,0,7834),(23,546,0,7834),(11,546,0,7834),(14,546,0,7834),(5,546,0,7834),(6,546,0,7834),(4,546,0,7999),(29,1567,0,10979),(3,440,0,7739),(1,440,0,7959),(16,440,0,7601),(15,440,0,7601),(9,440,0,7601),(20,440,0,7601),(23,440,0,7601),(11,440,0,7601),(14,440,0,7601),(5,440,0,7601),(6,440,0,7601),(4,440,0,7601),(1,47,0,10979),(3,47,0,7432),(4,47,0,7432),(5,47,0,7432),(6,47,0,7432),(9,47,0,7432),(11,47,0,7432),(12,47,0,7432),(13,47,0,7432),(14,47,0,7432),(15,47,0,7432),(16,47,0,7432),(28,1567,0,10979),(18,47,0,7432),(19,47,0,7432),(20,47,0,7432),(21,47,0,7432),(22,47,0,7432),(23,47,0,7432),(1,257,0,11178),(27,1567,0,10979),(3,506,0,7452),(1,506,0,7452),(16,506,0,7452),(15,506,0,7452),(9,506,0,7452),(20,506,0,7452),(23,506,0,7452),(11,506,0,7452),(14,506,0,7452),(5,506,0,7452),(6,506,0,7452),(4,506,0,7452),(26,1567,0,10979),(3,10,0,7453),(1,10,0,7453),(16,10,0,7453),(15,10,0,7453),(9,10,0,7453),(20,10,0,7453),(23,10,0,7453),(11,10,0,7453),(14,10,0,7453),(5,10,0,7453),(6,10,0,7453),(21,10,0,7453),(12,10,0,7453),(4,10,0,7453),(25,1567,0,10979),(21,154,0,11414),(12,154,0,11414),(1,43,0,7888),(9,43,0,7458),(11,43,0,7458),(5,43,0,7459),(6,43,0,7459),(1,69,0,10118),(9,69,0,7706),(22,43,0,7463),(4,43,0,7475),(24,1567,0,10979),(3,454,0,7675),(1,454,0,7782),(16,454,0,7675),(15,454,0,7675),(9,454,0,7675),(20,454,0,7675),(23,454,0,7675),(11,454,0,7675),(14,454,0,7675),(5,454,0,7675),(6,454,0,7675),(4,454,0,7675),(1,250,0,11177),(3,43,0,7531),(1,27,0,7810),(22,20,0,10979),(4,27,0,7558),(3,27,0,7569),(9,27,0,9022),(23,1567,0,10979),(3,520,0,7581),(1,520,0,9969),(16,520,0,7581),(15,520,0,7581),(9,520,0,10271),(20,520,0,7581),(23,520,0,7581),(11,520,0,7581),(14,520,0,7581),(5,520,0,7581),(6,520,0,7581),(4,520,0,9763),(20,69,0,7626),(20,43,0,7636),(3,69,0,9798),(4,460,0,7665),(11,460,0,7665),(9,460,0,7665),(1,460,0,7665),(3,460,0,7665),(14,460,0,7665),(22,1567,0,10979),(15,460,0,7665),(16,460,0,7665),(20,460,0,7665),(23,460,0,7665),(5,460,0,7665),(6,460,0,7665),(1,505,0,7667),(11,69,0,10745),(21,69,0,7706),(5,505,0,7727),(18,353,0,11495),(1,353,0,11495),(3,353,0,11495),(21,1567,0,10979),(9,353,0,11495),(4,353,0,11495),(5,353,0,11495),(6,353,0,11495),(11,353,0,11495),(12,353,0,11495),(13,353,0,11495),(14,353,0,11495),(15,353,0,11495),(16,353,0,11495),(19,353,0,11495),(20,353,0,11495),(21,353,0,11495),(22,353,0,11495),(23,353,0,11495),(4,130,0,8493),(20,1567,0,10979),(3,130,0,7853),(1,130,0,8474),(15,130,0,7853),(16,130,0,7853),(9,130,0,7853),(20,130,0,7853),(23,130,0,7853),(11,130,0,7853),(14,130,0,7853),(5,130,0,7853),(6,130,0,7853),(4,69,0,10763),(4,441,0,7761),(1,441,0,7761),(1,121,0,10832),(19,1567,0,11368),(3,496,0,7909),(1,496,0,7909),(15,496,0,7909),(16,496,0,7909),(9,496,0,7909),(20,496,0,7909),(23,496,0,7909),(11,496,0,7909),(14,496,0,7909),(5,496,0,7909),(6,496,0,7909),(4,496,0,7909),(6,69,0,8553),(18,1567,0,10979),(3,609,0,7961),(1,609,0,7961),(15,609,0,7961),(16,609,0,7961),(9,609,0,7961),(20,609,0,7961),(23,609,0,7961),(11,609,0,7961),(14,609,0,7961),(5,609,0,7961),(6,609,0,7961),(4,609,0,7961),(16,1567,0,10979),(3,451,0,8060),(1,451,0,8204),(15,451,0,8060),(16,451,0,8060),(9,451,0,8060),(20,451,0,8060),(23,451,0,8060),(11,451,0,8060),(14,451,0,8060),(5,451,0,8060),(6,451,0,8060),(4,451,0,8060),(15,1567,0,10979),(3,332,0,8247),(1,332,0,8247),(15,332,0,8247),(16,332,0,8247),(9,332,0,8247),(20,332,0,8247),(23,332,0,8247),(11,332,0,8247),(14,332,0,8247),(5,332,0,8247),(6,332,0,8247),(4,332,0,8247),(24,20,0,10979),(14,1567,0,10979),(3,132,0,8338),(1,132,0,8338),(15,132,0,8338),(16,132,0,8338),(9,132,0,8338),(20,132,0,8338),(23,132,0,8338),(24,132,0,8338),(11,132,0,8338),(14,132,0,8338),(5,132,0,8338),(6,132,0,8338),(4,132,0,8338),(6,343,0,11245),(5,343,0,11245),(11,343,0,11245),(1,343,0,11426),(9,343,0,11245),(13,1567,0,10979),(18,69,0,8518),(24,353,0,11495),(4,2,0,8519),(1,2,0,8729),(9,2,0,8643),(5,2,0,8528),(6,2,0,8540),(3,2,0,8559),(12,1567,0,10979),(3,654,0,8572),(1,654,0,8572),(15,654,0,8572),(16,654,0,8572),(9,654,0,8572),(20,654,0,8572),(23,654,0,8572),(24,654,0,8572),(11,654,0,8572),(14,654,0,8572),(5,654,0,8572),(6,654,0,8572),(4,654,0,8572),(22,3,0,10976),(23,3,0,10976),(24,3,0,10976),(14,69,0,8822),(3,661,0,8856),(3,121,0,10832),(4,121,0,10832),(5,121,0,10832),(6,121,0,10832),(9,121,0,10832),(11,121,0,10832),(12,121,0,10832),(13,121,0,10832),(14,121,0,10832),(15,121,0,10832),(16,121,0,10832),(11,1567,0,10979),(18,121,0,10832),(19,121,0,10832),(20,121,0,10832),(21,121,0,10832),(22,121,0,10832),(23,121,0,10832),(24,121,0,10832),(25,20,0,10979),(4,257,0,11178),(25,3,0,10976),(25,121,0,10832),(25,353,0,11495),(9,257,0,11178),(9,1567,0,11539),(3,394,0,11430),(1,394,0,11819),(15,394,0,10951),(16,394,0,10951),(9,394,0,10951),(26,394,0,10951),(25,394,0,10951),(20,394,0,10951),(23,394,0,10951),(24,394,0,10951),(11,394,0,10951),(14,394,0,10951),(5,394,0,10951),(6,394,0,10951),(4,394,0,10951),(26,121,0,10832),(26,20,0,10979),(26,677,0,9805),(25,677,0,9805),(20,677,0,9805),(23,677,0,9805),(24,677,0,9805),(9,677,0,10118),(4,677,0,10941),(6,677,0,10333),(5,677,0,9805),(11,677,0,9805),(1,677,0,10641),(3,677,0,10642),(6,1567,0,10979),(3,662,0,9413),(1,662,0,9413),(15,662,0,9413),(16,662,0,9413),(9,662,0,9413),(26,662,0,9413),(25,662,0,9413),(20,662,0,9413),(23,662,0,9413),(24,662,0,9413),(11,662,0,9413),(14,662,0,9413),(5,662,0,9413),(6,662,0,9413),(4,662,0,9413),(6,257,0,11178),(26,353,0,11495),(27,20,0,10979),(5,1567,0,10979),(3,257,0,11178),(15,257,0,11178),(16,257,0,10979),(27,257,0,11178),(26,257,0,11178),(25,257,0,11178),(20,257,0,11178),(23,257,0,11178),(24,257,0,11178),(11,257,0,11178),(14,257,0,11178),(5,257,0,11178),(27,353,0,11495),(27,394,0,10951),(27,684,0,9694),(27,121,0,10832),(4,1567,0,10979),(15,677,0,9805),(16,677,0,9805),(27,677,0,9805),(14,677,0,9805),(27,69,0,9798),(15,69,0,9798),(3,1567,0,10979),(3,343,0,11245),(15,343,0,11245),(16,343,0,10868),(27,343,0,11245),(26,343,0,11245),(25,343,0,11245),(20,343,0,11245),(23,343,0,11245),(24,343,0,11245),(14,343,0,11245),(4,343,0,11245),(28,20,0,10979),(28,257,0,11178),(28,343,0,11245),(28,394,0,10951),(28,3,0,10976),(28,520,0,9907),(3,602,0,10036),(26,3,0,10976),(27,3,0,10976),(29,20,0,10979),(28,121,0,10832),(29,121,0,10832),(29,394,0,10951),(28,353,0,11495),(29,353,0,11495),(29,257,0,11178),(30,154,0,11414),(30,394,0,10951),(30,10,0,10470),(30,257,0,11178),(30,20,0,10979),(30,121,0,10832),(29,3,0,10976),(30,3,0,10976),(30,677,0,10487),(30,353,0,11495),(30,520,0,10554),(1,1567,0,10979),(3,752,0,10680),(1,752,0,10680),(15,752,0,10680),(16,752,0,10680),(9,752,0,10680),(30,752,0,10680),(28,752,0,10680),(27,752,0,10680),(29,752,0,10680),(26,752,0,10680),(25,752,0,10680),(24,752,0,10680),(23,752,0,10680),(20,752,0,10680),(11,752,0,10680),(14,752,0,10680),(5,752,0,10680),(6,752,0,10680),(4,752,0,10680),(33,1567,0,10979),(3,689,0,10742),(1,689,0,10742),(15,689,0,10742),(16,689,0,10742),(9,689,0,10742),(30,689,0,10742),(28,689,0,10742),(27,689,0,10742),(29,689,0,10742),(26,689,0,10742),(25,689,0,10742),(24,689,0,10742),(23,689,0,10742),(20,689,0,10742),(11,689,0,10742),(14,689,0,10742),(5,689,0,10742),(6,689,0,10742),(4,689,0,10742),(25,69,0,10745),(30,343,0,11245),(29,343,0,11245),(4,1568,0,11001),(14,1568,0,11060),(9,5636,0,11108),(29,5636,0,11108),(1,5636,0,11671),(3,5636,0,11671),(5,5636,0,11201),(33,5636,0,11683),(4,5636,0,11108),(33,3354,0,11144),(11,495,0,11146),(1,3636,0,11150),(9,3636,0,11150),(30,3636,0,11150),(29,3636,0,11150),(27,3636,0,11150),(28,3636,0,11150),(26,3636,0,11150),(25,3636,0,11150),(24,3636,0,11150),(23,3636,0,11150),(20,3636,0,11150),(15,3636,0,11150),(3,3636,0,11150),(5,3636,0,11150),(6,3636,0,11150),(33,3636,0,11150),(14,3636,0,11150),(11,3636,0,11150),(4,3636,0,11150),(9,1807,0,11168),(30,1807,0,11168),(29,1807,0,11168),(27,1807,0,11168),(28,1807,0,11168),(26,1807,0,11168),(25,1807,0,11168),(24,1807,0,11168),(23,1807,0,11168),(20,1807,0,11168),(1,1807,0,11168),(15,1807,0,11168),(3,1807,0,11168),(5,1807,0,11168),(6,1807,0,11168),(33,1807,0,11168),(14,1807,0,11168),(11,1807,0,11168),(4,1807,0,11168),(33,257,0,11178),(33,343,0,11245),(33,775,0,11250),(1,1135,0,11266),(9,5774,0,11276),(30,5774,0,11276),(29,5774,0,11276),(27,5774,0,11276),(28,5774,0,11276),(26,5774,0,11276),(25,5774,0,11276),(24,5774,0,11276),(23,5774,0,11276),(20,5774,0,11276),(1,5774,0,11276),(15,5774,0,11276),(3,5774,0,11276),(5,5774,0,11276),(6,5774,0,11276),(33,5774,0,11276),(14,5774,0,11276),(11,5774,0,11276),(4,5774,0,11276),(6,5636,0,11290),(33,353,0,11495),(31,353,0,11495),(1,5814,0,11320),(33,1568,0,11325),(5,1568,0,11334),(9,5351,0,11396),(30,5351,0,11396),(29,5351,0,11396),(27,5351,0,11396),(28,5351,0,11396),(26,5351,0,11396),(25,5351,0,11396),(24,5351,0,11396),(23,5351,0,11396),(20,5351,0,11396),(1,5351,0,11396),(15,5351,0,11396),(3,5351,0,11396),(5,5351,0,11396),(6,5351,0,11396),(33,5351,0,11396),(14,5351,0,11396),(11,5351,0,11396),(4,5351,0,11396),(29,154,0,11414),(27,154,0,11414),(28,154,0,11414),(26,154,0,11414),(25,154,0,11414),(24,154,0,11414),(33,154,0,11414),(22,154,0,11414),(31,154,0,11414),(3,422,0,11415),(3,1568,0,11415),(21,1568,0,11415),(12,1568,0,11415),(1,79,0,11422),(3,79,0,11422),(4,79,0,11422),(5,79,0,11422),(6,79,0,11422),(9,79,0,11422),(11,79,0,11422),(12,79,0,11422),(13,79,0,11422),(14,79,0,11422),(15,79,0,11422),(16,79,0,11422),(18,79,0,11422),(19,79,0,11422),(20,79,0,11422),(21,79,0,11422),(22,79,0,11422),(23,79,0,11422),(24,79,0,11422),(25,79,0,11422),(26,79,0,11422),(27,79,0,11422),(28,79,0,11422),(29,79,0,11422),(30,79,0,11422),(31,79,0,11422),(33,79,0,11422),(34,79,0,11422),(1,464,0,11424),(34,353,0,11495),(9,602,0,11542),(1,702,0,11548),(33,602,0,11560),(35,3,0,11570),(35,602,0,11612),(35,154,0,11573),(35,353,0,11657),(35,3636,0,11608),(35,1567,0,11608),(35,5636,0,11671),(36,3,0,11725),(36,394,0,11771),(36,1568,0,11807);
/*!40000 ALTER TABLE `ia_smf_log_mark_read` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_notify`
--

DROP TABLE IF EXISTS `ia_smf_log_notify`;
CREATE TABLE `ia_smf_log_notify` (
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `ID_TOPIC` mediumint(8) unsigned NOT NULL default '0',
  `ID_BOARD` smallint(5) unsigned NOT NULL default '0',
  `sent` tinyint(1) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_MEMBER`,`ID_TOPIC`,`ID_BOARD`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_notify`
--

LOCK TABLES `ia_smf_log_notify` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_notify` DISABLE KEYS */;
INSERT INTO `ia_smf_log_notify` VALUES (24,15,0,0),(52,53,0,0),(40,15,0,0),(40,16,0,0),(40,20,0,0),(40,19,0,0),(40,9,0,0),(51,51,0,0),(41,51,0,0),(51,76,0,0),(41,22,0,0),(40,24,0,0),(40,23,0,0),(51,53,0,0),(40,50,0,0),(40,53,0,0),(64,58,0,0),(51,58,0,0),(41,58,0,0),(40,60,0,0),(38,107,0,0),(40,59,0,0),(40,63,0,0),(41,63,0,0),(51,64,0,0),(159,632,0,0),(94,67,0,1),(40,14,0,0),(40,68,0,0),(73,69,0,0),(8,69,0,0),(64,70,0,0),(40,71,0,0),(10,717,0,0),(14,72,0,0),(14,76,0,0),(37,67,0,1),(37,77,0,0),(154,640,0,1),(55,640,0,0),(103,14,0,0),(102,67,0,1),(112,114,0,0),(154,650,0,0),(10,712,0,0),(394,901,0,0),(119,29,0,1),(69,121,0,0),(10,122,0,0),(69,122,0,0),(10,519,0,0),(119,115,0,0),(69,124,0,0),(10,125,0,0),(69,126,0,0),(6,125,0,0),(69,125,0,0),(119,143,0,0),(55,157,0,0),(119,127,0,0),(10,434,0,0),(69,130,0,0),(69,148,0,0),(10,157,0,0),(10,158,0,0),(10,148,0,0),(69,160,0,0),(147,163,0,0),(69,165,0,0),(127,165,0,0),(69,150,0,0),(69,170,0,0),(69,186,0,0),(69,171,0,0),(10,171,0,0),(10,165,0,0),(10,181,0,0),(137,175,0,0),(22,178,0,0),(22,179,0,0),(22,177,0,0),(162,175,0,0),(162,174,0,0),(10,187,0,0),(10,190,0,0),(208,631,0,0),(10,50,0,0),(10,154,0,0),(69,192,0,0),(46,94,0,1),(155,30,0,1),(10,194,0,0),(149,29,0,1),(10,193,0,0),(532,764,0,0),(69,199,0,0),(69,200,0,0),(10,201,0,0),(69,99,0,0),(210,213,0,0),(10,192,0,0),(244,226,0,0),(69,226,0,0),(8,224,0,0),(69,225,0,0),(104,223,0,0),(10,211,0,0),(201,231,0,0),(10,231,0,0),(55,213,0,0),(122,16,0,0),(285,133,0,0),(292,247,0,0),(122,891,0,1),(10,249,0,0),(297,36,0,1),(10,251,0,0),(55,251,0,0),(69,240,0,1),(10,250,0,0),(69,249,0,0),(10,348,0,0),(10,256,0,0),(10,258,0,0),(278,96,0,1),(155,260,0,0),(69,244,0,0),(201,261,0,0),(155,254,0,0),(10,438,0,0),(8,265,0,0),(155,89,0,0),(46,89,0,0),(8,269,0,0),(10,267,0,0),(8,272,0,0),(8,271,0,0),(323,88,0,0),(46,88,0,0),(8,279,0,0),(34,278,0,0),(10,634,0,0),(10,282,0,0),(10,280,0,0),(408,634,0,0),(10,286,0,0),(10,273,0,0),(278,273,0,0),(8,284,0,0),(8,287,0,0),(10,288,0,0),(155,347,0,0),(10,594,0,0),(278,89,0,0),(336,238,0,0),(10,294,0,0),(154,450,0,0),(55,305,0,0),(25,136,0,1),(10,322,0,0),(8,266,0,0),(10,329,0,0),(10,325,0,0),(10,326,0,0),(278,140,0,0),(343,816,0,0),(8,327,0,0),(130,905,0,0),(10,333,0,0),(10,691,0,0),(10,347,0,0),(239,579,0,1),(55,91,0,0),(399,370,0,0),(55,38,0,0),(10,355,0,0),(20,441,0,0),(46,356,0,1),(10,356,0,0),(10,357,0,0),(122,36,0,1),(343,608,0,0),(154,706,0,0),(10,368,0,0),(10,882,0,0),(10,868,0,0),(239,851,0,0),(394,655,0,0),(154,323,0,0),(10,377,0,0),(37,36,0,1),(154,293,0,0),(395,382,0,0),(10,622,0,0),(154,307,0,0),(154,202,0,0),(10,382,0,0),(20,382,0,0),(431,38,0,1),(154,762,0,0),(154,193,0,0),(422,391,0,1),(20,379,0,0),(10,413,0,0),(20,404,0,0),(257,214,0,1),(257,212,0,0),(10,408,0,0),(257,91,0,1),(10,215,0,0),(275,519,0,0),(154,40,0,0),(96,411,0,0),(257,393,0,0),(10,683,0,0),(154,389,0,0),(257,85,0,1),(10,579,0,1),(154,414,0,0),(10,1200,0,0),(20,414,0,0),(10,520,0,0),(10,761,0,0),(394,48,0,0),(408,88,0,0),(408,426,0,0),(408,396,0,1),(154,88,0,0),(10,37,0,0),(408,46,0,0),(154,46,0,0),(408,41,0,1),(154,308,0,0),(10,446,0,0),(408,383,0,0),(10,608,0,0),(154,517,0,0),(55,452,0,0),(154,387,0,0),(55,581,0,0),(239,803,0,0),(10,450,0,0),(453,489,0,0),(452,498,0,0),(452,491,0,0),(452,486,0,0),(154,487,0,0),(257,487,0,0),(408,489,0,0),(154,482,0,0),(278,500,0,0),(408,33,0,1),(408,475,0,1),(154,471,0,0),(452,482,0,0),(154,500,0,0),(10,508,0,0),(154,509,0,0),(452,506,0,0),(408,511,0,0),(154,512,0,0),(408,506,0,1),(452,515,0,0),(10,425,0,0),(452,518,0,0),(408,519,0,0),(452,520,0,0),(408,43,0,0),(154,43,0,0),(10,552,0,0),(154,462,0,0),(343,715,0,0),(408,553,0,0),(442,558,0,0),(408,564,0,0),(452,557,0,0),(453,561,0,0),(257,564,0,0),(257,561,0,0),(453,564,0,0),(452,562,0,0),(408,569,0,0),(452,571,0,0),(408,571,0,0),(154,571,0,0),(55,574,0,0),(154,574,0,0),(452,574,0,1),(154,580,0,0),(452,584,0,0),(239,584,0,0),(452,581,0,0),(154,45,0,0),(239,460,0,0),(275,580,0,0),(27,216,0,0),(27,243,0,0),(10,457,0,0),(487,580,0,0),(209,504,0,1),(154,243,0,0),(154,576,0,0),(20,613,0,0),(239,617,0,0),(239,568,0,0),(275,621,0,0),(343,829,0,0),(10,88,0,0),(8,655,0,1),(10,655,0,0),(501,639,0,0),(239,639,0,0),(10,607,0,0),(394,475,0,0),(10,308,0,1),(239,673,0,1),(20,673,0,0),(239,679,0,0),(154,679,0,0),(10,679,0,0),(10,624,0,0),(154,668,0,0),(275,681,0,0),(10,681,0,0),(10,684,0,0),(154,642,0,0),(154,671,0,0),(154,655,0,0),(154,683,0,0),(154,502,0,0),(154,519,0,0),(154,49,0,0),(10,281,0,0),(154,624,0,0),(154,688,0,0),(394,45,0,0),(394,871,0,0),(10,716,0,0),(452,361,0,0),(10,31,0,0),(10,361,0,0),(154,36,0,0),(239,720,0,0),(239,727,0,0),(239,620,0,0),(55,727,0,0),(496,669,0,1),(20,624,0,0),(10,737,0,0),(10,746,0,0),(154,744,0,0),(275,593,0,0),(527,88,0,0),(527,29,0,1),(394,729,0,0),(154,729,0,0),(10,710,0,0),(10,747,0,0),(10,33,0,0),(452,702,0,1),(538,773,0,1),(154,641,0,0),(8,777,0,0),(275,780,0,0),(8,781,0,0),(154,776,0,0),(154,797,0,0),(394,731,0,0),(257,706,0,0),(544,791,0,0),(394,243,0,0),(154,791,0,0),(538,391,0,1),(20,812,0,0),(394,424,0,0),(10,97,0,0),(527,641,0,0),(154,803,0,0),(394,835,0,0),(10,830,0,0),(546,716,0,0),(154,790,0,0),(154,140,0,0),(154,29,0,0),(55,852,0,0),(10,853,0,0),(10,851,0,0),(10,855,0,0),(55,98,0,0),(10,857,0,0),(275,737,0,0),(154,853,0,0),(10,702,0,0),(179,734,0,1),(10,884,0,0),(538,34,0,1),(20,884,0,0),(20,883,0,0),(275,868,0,0),(10,34,0,1),(122,885,0,0),(10,885,0,0),(122,855,0,1),(20,396,0,0),(122,880,0,0),(122,889,0,1),(394,452,0,0),(10,880,0,0),(532,893,0,0),(275,872,0,0),(122,93,0,1),(20,733,0,0),(154,421,0,0),(394,582,0,0),(10,897,0,0),(37,166,0,1),(37,765,0,1),(505,742,0,0),(505,899,0,0),(530,30,0,1),(394,706,0,0),(10,898,0,0),(10,214,0,1),(394,513,0,0),(505,897,0,0),(154,897,0,0),(10,1047,0,0),(10,900,0,1),(546,900,0,0),(122,898,0,0),(505,49,0,0),(394,868,0,0),(505,894,0,0),(505,902,0,0),(154,913,0,0),(546,913,0,0),(154,884,0,0),(154,716,0,0),(154,916,0,0),(10,922,0,0),(579,919,0,0),(239,935,0,0),(488,120,0,1),(10,939,0,0),(10,940,0,0),(394,934,0,0),(10,912,0,0),(408,953,0,0),(343,949,0,0),(10,946,0,1),(154,961,0,0),(166,960,0,0),(10,957,0,0),(166,954,0,0),(408,956,0,0),(166,961,0,0),(154,966,0,0),(154,970,0,0),(10,972,0,0),(10,974,0,0),(488,931,0,1),(10,931,0,0),(122,975,0,1),(10,0,11,0),(10,756,0,0),(10,990,0,0),(10,979,0,0),(10,477,0,1),(10,973,0,1),(27,1011,0,0),(10,1013,0,0),(10,1038,0,1),(10,986,0,1),(10,1033,0,0),(10,1046,0,0),(608,1003,0,0),(10,997,0,0),(10,1066,0,0),(10,1088,0,0),(10,965,0,1),(10,891,0,0),(653,0,1,1),(10,0,9,0),(10,1105,0,0),(10,1114,0,1),(10,0,21,0),(10,1017,0,0),(10,1117,0,0),(10,1121,0,0),(10,1130,0,0),(10,315,0,0),(10,707,0,0),(10,1129,0,0),(10,1135,0,0),(10,1136,0,0),(10,1137,0,1),(10,1138,0,0),(10,874,0,0),(10,1139,0,0),(10,574,0,1),(10,1143,0,0),(441,1143,0,0),(662,86,0,0),(505,1001,0,0),(10,1149,0,1),(10,1154,0,0),(10,1164,0,0),(10,1173,0,0),(10,1176,0,0),(10,1177,0,0),(10,1178,0,0),(10,1182,0,0),(3,1066,0,0),(10,1183,0,0),(10,1198,0,0),(530,1194,0,1),(10,1218,0,1),(10,1220,0,1),(516,1224,0,0),(516,0,28,0),(602,1223,0,0),(3,0,13,0),(10,1236,0,0),(505,1241,0,0),(10,1241,0,0),(10,1240,0,0),(3,1205,0,0),(505,1249,0,0),(10,1254,0,0),(505,1183,0,0),(10,1272,0,0),(10,1271,0,0),(10,1276,0,0),(10,1275,0,0),(505,669,0,0),(505,1300,0,0),(505,663,0,0),(505,1311,0,0),(10,1353,0,0),(505,1098,0,0),(493,0,1,1),(10,1360,0,0),(10,1359,0,0),(10,1362,0,0),(10,1364,0,0),(10,1361,0,0),(726,1359,0,1),(586,37,0,1),(10,1303,0,0),(10,1373,0,0),(505,874,0,0),(10,1329,0,0),(10,1378,0,0),(10,1436,0,0),(5897,1443,0,0),(5897,0,5,1),(10,1449,0,0),(441,1462,0,1),(10,1463,0,0),(456,0,1,1),(10,1475,0,0),(10,1474,0,0),(10,1491,0,0),(10,1478,0,0),(10,1490,0,0),(10,1499,0,0),(10,988,0,0),(10,1494,0,0);
/*!40000 ALTER TABLE `ia_smf_log_notify` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_online`
--

DROP TABLE IF EXISTS `ia_smf_log_online`;
CREATE TABLE `ia_smf_log_online` (
  `session` varchar(32) collate latin1_general_ci NOT NULL default '',
  `logTime` timestamp NOT NULL default CURRENT_TIMESTAMP on update CURRENT_TIMESTAMP,
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `ip` int(10) unsigned NOT NULL default '0',
  `url` text collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`session`),
  KEY `online` (`logTime`,`ID_MEMBER`),
  KEY `ID_MEMBER` (`ID_MEMBER`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_online`
--

LOCK TABLES `ia_smf_log_online` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_online` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_log_online` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_polls`
--

DROP TABLE IF EXISTS `ia_smf_log_polls`;
CREATE TABLE `ia_smf_log_polls` (
  `ID_POLL` mediumint(8) unsigned NOT NULL default '0',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `ID_CHOICE` tinyint(3) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_POLL`,`ID_MEMBER`,`ID_CHOICE`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_polls`
--

LOCK TABLES `ia_smf_log_polls` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_polls` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_log_polls` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_search_messages`
--

DROP TABLE IF EXISTS `ia_smf_log_search_messages`;
CREATE TABLE `ia_smf_log_search_messages` (
  `ID_SEARCH` tinyint(3) unsigned NOT NULL default '0',
  `ID_MSG` mediumint(9) NOT NULL default '0',
  PRIMARY KEY  (`ID_SEARCH`,`ID_MSG`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_search_messages`
--

LOCK TABLES `ia_smf_log_search_messages` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_search_messages` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_log_search_messages` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_search_results`
--

DROP TABLE IF EXISTS `ia_smf_log_search_results`;
CREATE TABLE `ia_smf_log_search_results` (
  `ID_SEARCH` tinyint(3) unsigned NOT NULL default '0',
  `ID_TOPIC` mediumint(8) unsigned NOT NULL default '0',
  `ID_MSG` int(10) unsigned NOT NULL default '0',
  `relevance` smallint(5) unsigned NOT NULL default '0',
  `num_matches` smallint(5) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_SEARCH`,`ID_TOPIC`),
  KEY `relevance` (`relevance`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_search_results`
--

LOCK TABLES `ia_smf_log_search_results` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_search_results` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_log_search_results` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_search_subjects`
--

DROP TABLE IF EXISTS `ia_smf_log_search_subjects`;
CREATE TABLE `ia_smf_log_search_subjects` (
  `word` varchar(20) collate latin1_general_ci NOT NULL default '',
  `ID_TOPIC` mediumint(8) unsigned NOT NULL default '0',
  PRIMARY KEY  (`word`,`ID_TOPIC`),
  KEY `ID_TOPIC` (`ID_TOPIC`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_search_subjects`
--

LOCK TABLES `ia_smf_log_search_subjects` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_search_subjects` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_log_search_subjects` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_search_topics`
--

DROP TABLE IF EXISTS `ia_smf_log_search_topics`;
CREATE TABLE `ia_smf_log_search_topics` (
  `ID_SEARCH` tinyint(3) unsigned NOT NULL default '0',
  `ID_TOPIC` mediumint(9) NOT NULL default '0',
  PRIMARY KEY  (`ID_SEARCH`,`ID_TOPIC`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_search_topics`
--

LOCK TABLES `ia_smf_log_search_topics` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_search_topics` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_log_search_topics` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_log_topics`
--

DROP TABLE IF EXISTS `ia_smf_log_topics`;
CREATE TABLE `ia_smf_log_topics` (
  `ID_TOPIC` mediumint(8) unsigned NOT NULL default '0',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `ID_MSG` mediumint(8) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_MEMBER`,`ID_TOPIC`),
  KEY `ID_TOPIC` (`ID_TOPIC`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_log_topics`
--

LOCK TABLES `ia_smf_log_topics` WRITE;
/*!40000 ALTER TABLE `ia_smf_log_topics` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_log_topics` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_membergroups`
--

DROP TABLE IF EXISTS `ia_smf_membergroups`;
CREATE TABLE `ia_smf_membergroups` (
  `ID_GROUP` smallint(5) unsigned NOT NULL auto_increment,
  `groupName` varchar(80) collate latin1_general_ci NOT NULL default '',
  `onlineColor` varchar(20) collate latin1_general_ci NOT NULL default '',
  `minPosts` mediumint(9) NOT NULL default '-1',
  `maxMessages` smallint(5) unsigned NOT NULL default '0',
  `stars` tinytext collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`ID_GROUP`),
  KEY `minPosts` (`minPosts`)
) ENGINE=MyISAM AUTO_INCREMENT=22 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_membergroups`
--

LOCK TABLES `ia_smf_membergroups` WRITE;
/*!40000 ALTER TABLE `ia_smf_membergroups` DISABLE KEYS */;
INSERT INTO `ia_smf_membergroups` VALUES (1,'Echipa infoarena','#FF0000',-1,0,'5#staradmin.gif'),(2,'Moderatori infoarena','#0000FF',-1,0,'5#stargmod.gif'),(3,'Moderator','',-1,0,'5#starmod.gif'),(11,'Client obisnuit','',50,0,'2#star.gif'),(10,'Strain','',25,0,'1#star.gif'),(9,'Strain','',1,0,''),(13,'De-al casei','',100,0,'3#star.gif'),(17,'Vorbaret','',150,0,'4#star.gif'),(18,'Nu mai tace','',200,0,'5#star.gif'),(20,'Colaboratori infoarena','#006600',-1,0,'');
/*!40000 ALTER TABLE `ia_smf_membergroups` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_members`
--

DROP TABLE IF EXISTS `ia_smf_members`;
CREATE TABLE `ia_smf_members` (
  `ID_MEMBER` mediumint(8) unsigned NOT NULL auto_increment,
  `memberName` varchar(80) collate latin1_general_ci NOT NULL default '',
  `dateRegistered` int(10) unsigned NOT NULL default '0',
  `posts` mediumint(8) unsigned NOT NULL default '0',
  `ID_GROUP` smallint(5) unsigned NOT NULL default '0',
  `lngfile` tinytext collate latin1_general_ci NOT NULL,
  `lastLogin` int(10) unsigned NOT NULL default '0',
  `realName` tinytext collate latin1_general_ci NOT NULL,
  `instantMessages` smallint(5) NOT NULL default '0',
  `unreadMessages` smallint(5) NOT NULL default '0',
  `pm_ignore_list` text collate latin1_general_ci NOT NULL,
  `passwd` varchar(64) collate latin1_general_ci NOT NULL default '',
  `emailAddress` tinytext collate latin1_general_ci NOT NULL,
  `personalText` tinytext collate latin1_general_ci NOT NULL,
  `gender` tinyint(4) unsigned NOT NULL default '0',
  `birthdate` date NOT NULL default '0001-01-01',
  `websiteTitle` tinytext collate latin1_general_ci NOT NULL,
  `websiteUrl` tinytext collate latin1_general_ci NOT NULL,
  `location` tinytext collate latin1_general_ci NOT NULL,
  `ICQ` tinytext collate latin1_general_ci NOT NULL,
  `AIM` varchar(16) collate latin1_general_ci NOT NULL default '',
  `YIM` varchar(32) collate latin1_general_ci NOT NULL default '',
  `MSN` tinytext collate latin1_general_ci NOT NULL,
  `hideEmail` tinyint(4) NOT NULL default '0',
  `showOnline` tinyint(4) NOT NULL default '1',
  `timeFormat` varchar(80) collate latin1_general_ci NOT NULL default '',
  `signature` text collate latin1_general_ci NOT NULL,
  `timeOffset` float NOT NULL default '0',
  `avatar` tinytext collate latin1_general_ci NOT NULL,
  `pm_email_notify` tinyint(4) NOT NULL default '0',
  `karmaBad` smallint(5) unsigned NOT NULL default '0',
  `karmaGood` smallint(5) unsigned NOT NULL default '0',
  `usertitle` tinytext collate latin1_general_ci NOT NULL,
  `notifyAnnouncements` tinyint(4) NOT NULL default '1',
  `notifyOnce` tinyint(4) NOT NULL default '1',
  `memberIP` tinytext collate latin1_general_ci NOT NULL,
  `secretQuestion` tinytext collate latin1_general_ci NOT NULL,
  `secretAnswer` varchar(64) collate latin1_general_ci NOT NULL default '',
  `ID_THEME` tinyint(4) unsigned NOT NULL default '0',
  `is_activated` tinyint(3) unsigned NOT NULL default '1',
  `validation_code` varchar(10) collate latin1_general_ci NOT NULL default '',
  `ID_MSG_LAST_VISIT` int(10) unsigned NOT NULL default '0',
  `additionalGroups` tinytext collate latin1_general_ci NOT NULL,
  `smileySet` varchar(48) collate latin1_general_ci NOT NULL default '',
  `ID_POST_GROUP` smallint(5) unsigned NOT NULL default '0',
  `totalTimeLoggedIn` int(10) unsigned NOT NULL default '0',
  `passwordSalt` varchar(5) collate latin1_general_ci NOT NULL default '',
  `messageLabels` text collate latin1_general_ci NOT NULL,
  `buddy_list` tinytext collate latin1_general_ci NOT NULL,
  `notifySendBody` tinyint(4) NOT NULL default '0',
  `notifyTypes` tinyint(4) NOT NULL default '2',
  `memberIP2` tinytext collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`ID_MEMBER`),
  KEY `memberName` (`memberName`(30)),
  KEY `dateRegistered` (`dateRegistered`),
  KEY `ID_GROUP` (`ID_GROUP`),
  KEY `birthdate` (`birthdate`),
  KEY `posts` (`posts`),
  KEY `lastLogin` (`lastLogin`),
  KEY `ID_POST_GROUP` (`ID_POST_GROUP`),
  KEY `lngfile` (`lngfile`(24))
) ENGINE=MyISAM AUTO_INCREMENT=6124 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_members`
--

LOCK TABLES `ia_smf_members` WRITE;
/*!40000 ALTER TABLE `ia_smf_members` DISABLE KEYS */;
INSERT INTO `ia_smf_members` VALUES (2,'fluffy',1077052570,103,1,'',1170020966,'Crestez Dan-Leonard',2,1,'','7b1045aac728fec00a86a68aba993d6d85a74529','fluffy@example.com','',1,'1986-10-23','','','','','','crestez_leonard','',0,1,'','',0,'http://nobody.devnet.ro/pr0n.jpg',1,5,25,'',1,1,'','','',1,1,'',11669,'20','',13,34018,'d98b','','',0,2,''),(3,'domino',1077054064,840,1,'romanian',1170098443,'Mircea Pasoi',49,0,'','6bd0a33ee98c8bf6aed56c6fe710002bde6048b3','domino@example.com','',1,'1987-07-23','http://infoarena.devnet.ro','http://infoarena.devnet.ro','','324694544','','bogdanpasoi','mircea_pasoi',0,1,'','',0,'',1,30,92,'',1,1,'','','',1,1,'',11822,'20','',18,446722,'ba10','','',0,2,''),(10,'svalentin',1077384310,418,1,'english',1170097684,'Valentin Stanciu',24,0,'','dfdfb51287c0b7472c0c501394f0440f9dcf14c9','svalentin@example.com','',1,'1988-08-25','','','','','','','',1,1,'%d-%m-%Y, %H:%M:%S','',0,'',1,38,51,'',1,1,'','','',1,1,'',11686,'','',18,178731,'c918','','',1,2,''),(27,'Cosmin',1077805323,586,1,'',1170048860,'Cosmin',0,0,'','95ddb1caf1d978e1cce9074bb1affbea2dcb7421','Cosmin@example.com','',0,'0001-01-01','','','','','','','',1,1,'','',0,'',1,14,76,'',1,1,'','','',1,1,'',11857,'20','',18,267481,'6561','','',0,2,''),(31,'ira',1077974674,5,0,'',1165353946,'Irina Stanescu',2,2,'','091ff1ded7c806baf5c2a40b467a19c4e1123b01','ira@example.com','',0,'0001-01-01','','','','','','iri2812@yahoo.com','iri2812@hotmail.com',1,0,'','and i say romania is my country...',0,'',1,0,2,'',1,1,'','','',1,1,'',11074,'','',9,92,'','','',0,2,''),(43,'greco',1078267126,352,1,'english',1169942372,'Florea Tiberiu',23,0,'','aaf53667e069463f8c21f09642e068e526cad665','greco@example.com','',0,'0001-01-01','','','','','','','',1,1,'','Jump in the cockpit and start up the engines\r<br />Remove all the wheelblocks there\'s no time to waste\r<br />Gathering speed as we head down the runway\r<br />Gotta get airborne before it\'s too late.',0,'',1,16,56,'',1,1,'','','',1,1,'',11836,'','',18,91380,'72fd','','',0,2,''),(47,'wickedman',1078654068,408,1,'',1170059965,'Cristian George Strat',33,0,'','63e05201f16771dd6d4694b502a4fb0dbdac0780','wickedman@example.com','',1,'0001-01-01','raw creativity','http://cristi.devnet.ro/','','','','','',1,1,'','relax those patterns in your head<br />[url=http://infoarena.devnet.ro/]pregatire la informatica[/url] | [url=http://cristi.devnet.ro/]blog[/url]',0,'',1,5,57,'',1,1,'','','',1,1,'',11691,'20','',18,189345,'555a','','',0,2,''),(69,'silviug',1080394491,268,1,'',1169992427,'Silviu Ganceanu',24,0,'','9678b7723d81d9a0eab85832847123c6cfc0dda4','silviug@example.com','',1,'1985-05-03','','','','','','private','private',1,1,'','&quot;Don&#039;t gain the world and lose your soul, wisdom is better than silver or gold.&quot; [Bob Marley - Jamaican reggae musician &amp; singer (1945 - 1981)]',0,'',1,3,33,'',1,1,'','','',1,1,'',11845,'20','',18,56890,'22fd','','',0,2,''),(79,'filipb',1080409243,357,1,'romanian',1170100662,'Buruiana Filip Cristian',28,0,'','811bbf59e81ca6425274da0ef63e29dffd48d9a1','filipb@example.com','',1,'1989-03-17','','','','','','','',1,1,'','',0,'',1,19,41,'',1,1,'','','',1,1,'',11866,'','',18,379966,'a792','','',0,2,''),(121,'azotlichid',1094553845,174,1,'english',1170097846,'Adrian Vladu',5,0,'','c2e30bcb9a5615e5934d178c6fd7ebc15ac54006','azotlichid@example.com','',0,'1987-04-25','','','','','','','',1,1,'','',0,'',1,21,34,'',1,1,'','','',1,1,'',11862,'','',17,136930,'224d','','',0,2,''),(192,'szaki',1108644180,0,0,'',1169936069,'Stefan Szakats',0,0,'','6f60959e58f7ac643aee1f9b5b494dbd4ccd9093','szaki@example.com','',0,'0001-01-01','','','','','','','',1,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',11822,'','',0,7814,'','','',0,2,''),(240,'TBog',1109167481,0,0,'',1116485925,'Tautu Bogdan',0,0,'','d3cd3f696e3ecf520fb39d5b4e59a6712a1150f7','TBog@example.com','',0,'0001-01-01','','','','','','','',1,1,'','',0,'',0,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(262,'george126',1109182787,3,0,'',1168849109,'Rata Ioan George',1,0,'','f5a1b70ea2b39897b164d9603cc10ec1efff39be','george126@example.com','',1,'1988-01-06','','http://geo126.xhost.ro/site','','','','rata.george','',1,1,'','Geo R.',0,'Actors/Bruce_Willis.jpg',1,1,4,'',1,1,'','','',1,1,'',11499,'','',9,7197,'e0a5','','',0,2,''),(276,'vax187',1109238773,0,0,'',1109283218,'Corciova Cristin',0,0,'','83bfcfcca661287ce0724ac21afb18097e5752ff','vax187@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(305,'roberto',1109710973,0,0,'',1109711018,'Roberto Carlos',0,0,'','b15052dcc0ad77eed4e370b5e87b1bb08b2452ad','roberto@example.com','',0,'0001-01-01','','','','','','robertino_ro2004','',1,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(353,'danielp',1111485673,122,1,'',1170082440,'Daniel Pasaila',1,1,'','da35f7052906a790a80177483e34a86f358fa609','danielp@example.com','',0,'0001-01-01','','','','','','danielpasaila','',1,1,'','I can\'t get a life if my heart\'s not in it',0,'',0,0,13,'',1,1,'','','',1,1,'',11861,'','',13,25813,'ad40','','',0,2,''),(387,'_cont_',1114433439,0,0,'',1114433451,'sese',0,0,'','7516a713098f2bfd2a3b3c6c1cc6ee091487cc17','_cont_@example.com','',0,'0001-01-01','','','','','','','',1,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(484,'sims_gl',1130162914,14,0,'',1170005332,'Alexandru Simion',0,0,'','49a75456a54783f50575b2121358e8a58b234d3f','sims_gl@example.com','',1,'1989-03-10','','','','','','','',1,1,'','&quot;I want to know god&#039;s thoughts... the rest are details.&quot; Einstein',0,'',1,2,6,'',1,1,'','','',1,1,'',11854,'','',9,102706,'2beb','','',0,2,''),(610,'Gaby',1145194167,0,0,'',1145195692,'Bratu Gabriel',0,0,'','8360fb0079926132bcb207385774da4a8ee33378','Gaby@example.com','',2,'1990-09-15','','','','','','gabrielle_992','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',7961,'','',0,1891,'723a','','',0,2,''),(735,'snaked31',1160489595,1,0,'',1169904992,'Stanica Andrei',0,0,'','29cd62e2c753f2284315fd1bd9f14afcf3b9a6d9','snaked31@example.com','',0,'0001-01-01','','','','','','','',1,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',11733,'','',9,4901,'22bc','','',0,2,''),(931,'vali',1164253107,0,0,'',0,'Dobrota Valentin',0,0,'','8d86036107b9bb02eb7c1c7bc14247decec382c6','vali@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(934,'e_udrea',1164253107,0,0,'',0,'Udrea Emanuel',0,0,'','6b5130f8d7fbc134b85f03ab394a83dc343de0d9','e_udrea@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(1119,'monica',1164253108,0,0,'',0,'Bercea Monica',0,0,'','01d9da958624831fc6ed0d5da058fd22aa55a1a4','monica@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(1268,'hitandyrun',1164253108,0,0,'',0,'Andrei Baltuta',0,0,'','1dc20dd4d48f951e379ad75f4ac6e8c02b4fed25','hitandyrun@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(1298,'mirela lazar',1164253108,0,0,'',0,'lazar mirela claudia',0,0,'','ebe98599b5ddfd810cf7682b75a8985ab883549a','mirela lazar@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(1559,'domnina',1164253109,0,0,'',0,'ioana cristescu',0,0,'','1f219c282048034fd6b42cb2b1b499f13ed9fe52','domnina@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(1567,'DITzoneC',1164253109,46,1,'',1170101063,'Adrian Diaconu',0,0,'','bd0c869fdf51f004a547ad0a1a002be83c677b52','DITzoneC@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,1,15,'',1,1,'','','',1,1,'',11686,'','',10,45662,'','','',0,2,''),(1575,'MrMagic',1164253109,0,0,'',0,'Gabriel Rizuc',0,0,'','d9d7eddfe7a0719a062dd9f2fe574c9b7dc01dbd','MrMagic@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(1619,'Tabara',1164253109,15,0,'',1170092658,'Tabara Mihai',1,0,'','9639c299c429eaeb1c3df24e38690246aec5ca04','Tabara@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,4,9,'',1,1,'','','',1,1,'',11823,'','',9,32177,'','','',0,2,''),(1742,'hda',1164253109,0,0,'',0,'laura',0,0,'','571c45b87bd96a3ecef57ce5914f14cfd35fddf5','hda@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(1847,'bogdang1723',1164253109,0,0,'',0,'Gurau Bogdan',0,0,'','8c6653aeba7243a866886fcaf8cbe73664914883','bogdang1723@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(1879,'littleman',1164253109,0,0,'',0,'Petrovan Bogdan',0,0,'','461d547d7c4a30c5e21f5013d25701b2b9ebd962','littleman@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(1897,'expertu',1164253109,0,0,'',0,'Cristian Mezei',0,0,'','f70261eea90ea29f0625695b5e8b78cb1fcca5b6','expertu@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2027,'misha',1164253110,0,0,'',0,'Flutur Mihaela',0,0,'','d5df58fbe05dee2569ce09a637ba679c12046763','misha@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2168,'Drroty',1164253110,0,0,'',0,'Adi Drotar',0,0,'','93545aa0dae2ba5788a11bfafdfde7de2d484ab6','Drroty@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2172,'DianaH',1164253110,0,0,'',0,'Hodea Diana',0,0,'','87f28f7a629d44d91bb09f58ef437eece3c7457a','DianaH@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2267,'xlf',1164253110,0,0,'',0,'Eftimie Alexandru',0,0,'','76143f60f3965d72112938822c957ab54e845520','xlf@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2397,'_darlene_',1164253110,0,0,'',0,'popa roxana',0,0,'','2bb13ef4f081a8573e9f8857aefb894927673f80','_darlene_@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2427,'K_ionutz',1164253110,0,0,'',0,'Bostan Ionut',0,0,'','042ef18e2684bfbe9bd16d7deec1cc9c4497d143','K_ionutz@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2434,'slayerdme',1164253110,0,0,'',1166031738,'Mihai Dumitrescu',0,0,'','acf0d9ecebb8abac6e9c9cbe12ec31d6c9fa28c7','slayerdme@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',11183,'','',0,0,'','','',0,2,''),(2476,'ltugmaria',1164253110,0,0,'',0,'Maria Voicu',0,0,'','bc73f2d4b90b29299b2339c4e46ff203c9c58054','ltugmaria@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2527,'astronomy',1164253111,15,0,'',1170101556,'Airinei Adrian',0,0,'','b796ebf62bc3cfea237ef0eb21e77051f436f3bb','astronomy@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,4,'',1,1,'','','',1,1,'',11864,'','',9,75191,'','','',0,2,''),(2602,'tudorel',1164253111,0,0,'',0,'Tudor Curelaru',0,0,'','824634bf3c0fe9c0263f9880b53e04e636d0bbb1','tudorel@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2608,'sarge',1164253111,0,0,'',0,'Domide Sergiu',0,0,'','44452dff19b2cbb4ad15b67ec5b5a0f5ebda9d67','sarge@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2676,'ionelya15',1164253111,0,0,'',0,'pop laura ionelia',0,0,'','67434699fee90a6d3d41c56f188d4570bb6cea61','ionelya15@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2727,'dandreica',1164253111,0,0,'',1169461633,'andreica dumitru',0,0,'','21976dc71301d779efaa45ad2c7f36953ee82ef3','dandreica@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',11659,'','',0,0,'','','',0,2,''),(2731,'bacinfo2005',1164253111,0,0,'',0,'Sofica Dan Adrian',0,0,'','572e339e4d639c8bb0b7e17db7dcddbb39e9d501','bacinfo2005@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2793,'veleavlad',1164253111,0,0,'',0,'Velea Vlad',0,0,'','f4d11097e2267eacd59469ee28b7248e3dee22e7','veleavlad@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2869,'alinutzu_vip',1164253111,0,0,'',0,'Constantin Alin Daniel',0,0,'','7b917b8fbead28ef18a8a81b38fe4ce3fec06c34','alinutzu_vip@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2922,'aln',1164253111,0,0,'',0,'aln dra',0,0,'','ded2ede8d328e7086364898b8713eeed067af9ec','aln@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2945,'sdmagor',1164253111,0,0,'',0,'Sch. Dukasz Magor',0,0,'','959836f88e702d6fad1c9160b35b0eccbebc5a8f','sdmagor@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2954,'cioryboy',1164253111,0,0,'',0,'CIORANU',0,0,'','c4a2d0dacf3c5f5327d9b8a1a8c80df43b079103','cioryboy@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(2987,'brenda',1164253111,0,0,'',0,'brenda',0,0,'','318705c55da0840f1063f321ec0739ef027dbbfc','brenda@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3037,'adrian_006',1164253111,0,0,'',0,'diaconu',0,0,'','9727f683ae4afd67afb1fcb32a56c012b1898708','adrian_006@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3195,'adinachiv',1164253112,0,0,'',0,'Adina Paraschiv',0,0,'','377986fd29ab4de6b3336fc4d6fec94d9010b932','adinachiv@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3207,'clau12345',1164253112,0,0,'',0,'clau',0,0,'','09e7f505754705d39bcb2b15a43e4a1db4ff4019','clau12345@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3326,'ana724',1164253112,0,0,'',0,'DAN ALEXANDRESCU',0,0,'','4606e3da59138da67cc9f2794af1161df3b35587','ana724@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3375,'marius_902002',1164253112,0,0,'',1169393395,'Cocis Marius Gabriel',0,0,'','f781e86f4ece9605f6f5c5f8faa280a9b66e182b','marius_902002@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',11630,'','',0,211,'','','',0,2,''),(3430,'POPMAR72',1164253112,0,0,'',0,'POPES MAR',0,0,'','075073808f37bd3a9b7b5dcb1586f95f157e4b8d','POPMAR72@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3473,'victor_onaga',1164253112,0,0,'',0,'Victor Onaga',0,0,'','0f93db5c0819e7d8a66b722a4292594273faea9b','victor_onaga@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3624,'BogdanBl',1164253113,0,0,'',0,'Blaga Bogdan',0,0,'','82444a066900c9a1198df737fa500d3a672b3ea5','BogdanBl@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3645,'dragosh',1164253113,0,0,'',0,'vasilcanu',0,0,'','8992c6af6b9931bb97f63622abc5ddf6924a92f8','dragosh@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3710,'Skynet',1164253113,0,0,'',0,'Marian Ciortea',0,0,'','a4f68d3c5200951a6d730fc9f19972b603337497','Skynet@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3726,'Alexxxx',1164253113,0,0,'',0,'Eh...',0,0,'','b806b9bb5321f36481b215d7e5893e46206ea809','Alexxxx@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3756,'ursusevastian',1164253113,0,0,'',0,'ursu sevastian',0,0,'','4ae223c075690a1920137a58e4fd6c3510c67d8c','ursusevastian@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3816,'faxmodem',1164253113,0,0,'',0,'Razvan Coman',0,0,'','536fbb8912f15d81cfd072d1f58831362bec5278','faxmodem@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(3830,'filipman',1164253113,0,0,'',0,'n-am nume',0,0,'','04af9f4c1df0026397f770292f6481d608797c27','filipman@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4211,'smi',1164253114,0,0,'',0,'Simi',0,0,'','730d3e142b507c6b977d9e94d17c01d122506376','smi@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4262,'daysleeper',1164253114,0,0,'',0,'Radu Ciurlea',0,0,'','11666aa401e8f49ec4606f196b9176f2a03990bc','daysleeper@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4284,'bmihai',1164253114,0,0,'',0,'Baba Sebastian Mihai',0,0,'','e457cba182bb7946fb744797833aca36a9dbf026','bmihai@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4292,'denis',1164253114,0,0,'',0,'Cozman Denis',0,0,'','c6ce6834c2430b5189ce2798ae8909fc016bef12','denis@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4352,'adrienne',1164253114,0,0,'',0,'Garfileld Adrienne',0,0,'','0c35e22a38be147b769a8aa0b3dca3faf6bb5a6d','adrienne@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4368,'redskirt',1164253114,0,0,'',0,'Joe Black',0,0,'','ea8e3fc62c66966b270f64d1b6460e0b5beec14d','redskirt@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4429,'lrazvan',1164253114,0,0,'',0,'Lica Razvan',0,0,'','1495241efefbc61226c7147cbe4a2c2e6a9a0207','lrazvan@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4452,'irina_marincas',1164253114,0,0,'',0,'irina marincas',0,0,'','2159566118b8df2aea1cf3fd783c82a35873aeb9','irina_marincas@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4470,'Febra_OJI',1164253115,0,0,'',0,'caut antidot pentru febra',0,0,'','60a9ab05fdbd218d9c28d3225feff7b22e84ef72','Febra_OJI@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4505,'testall',1164253115,0,0,'',0,'MARIAN',0,0,'','14502895092e0c0cc14590268713f58586175c8e','testall@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4612,'nicol',1164253115,0,0,'',0,'hadryanys',0,0,'','196a3df5e04a56015420a9c6f53250f38a6bbbf1','nicol@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4617,'moraru',1164253115,0,0,'',0,'moraru ionut',0,0,'','1ba340a12d7872cab0bc588fc8e38151258c6bd2','moraru@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4639,'Villy_the_first',1164253115,0,0,'',0,'Varlan Daniel',0,0,'','cc508f1c7f0a7ae9f46a58d91dd1b9b3a3b1ca06','Villy_the_first@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4648,'moldi',1164253115,0,0,'',0,'Moldovan Andrei',0,0,'','393569aa417422c8c9c03546ff12cae534d7bd31','moldi@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4654,'Pleasure',1164253115,0,0,'',0,'Downward Spiral',0,0,'','91866f97b0f5b37095ddda5825eee84bdbb4c3f5','Pleasure@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4721,'tudor_tudy',1164253115,0,0,'',0,'Mihuta Tudor',0,0,'','0e3dc1e1296831427217f5d848b50697a90ac58a','tudor_tudy@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4764,'vinete',1164253115,0,0,'',0,'budau tiberiu',0,0,'','20cf664c14826c67725f90d8f69e4b466a87dfb5','vinete@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4940,'eta_trial',1164253116,0,0,'',0,'Colac Alexandru',0,0,'','3987c06a19ed8e76a33f9dd966ed158080ff2b97','eta_trial@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(4957,'voronoi',1164253116,0,0,'',0,'Costin Radu',0,0,'','f120069ac28c903c8295739052a0f43c3fda92a0','voronoi@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(5036,'stancovz',1164253116,0,0,'',1165834351,'Stankov Zeljko',0,0,'','f091d349e07aa8b95d9ad63f6301589f09833724','stancovz@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',11111,'','',0,785,'','','',0,2,''),(5286,'cristinutza_g1989',1164253116,0,0,'',0,'Goicea Cristina',0,0,'','28a032d519ee3629929ed4e08a7a065be23b68fb','cristinutza_g1989@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(5327,'madutza',1164253117,0,0,'',0,'Anton Madalina',0,0,'','508876496a936aa1dc724ab91bd1b8024de90cbb','madutza@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(5388,'Ivanescu_miruna',1164253117,0,0,'',0,'Ivanescu Miruna',0,0,'','f0206af2eb597560d1e4eebb8c767cbc70b4128f','Ivanescu_miruna@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(5477,'yourlove',1164253117,0,0,'',0,'anghelache andreea',0,0,'','db0d671288660992c437caed094dd2cd265e5183','yourlove@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(5491,'iuliavls',1164253117,0,0,'',0,'iulia vlasceanu',0,0,'','9394221f5207163ba15877e1fd958c705ce839a8','iuliavls@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(5531,'hajek_hajni',1164253117,0,0,'',0,'hajek hajnalka',0,0,'','51162492aa56c7586b3cbfb66f4eba37ed053aa5','hajek_hajni@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(5617,'jsin',1164253117,0,0,'',0,'Joe Sinapsa',0,0,'','5619141d385331cc1e0ad9199d6f1dff29edaffa','jsin@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',1,1,'',0,'','',0,0,'','','',0,2,''),(5628,'eval',1165175672,0,0,'',0,'Evaluatorul infoarena',0,0,'','99f84d9f2e99cba220e37d9e293f295da6e5c3f4','eval@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',0,1,'',0,'','',0,0,'','','',0,2,''),(5661,'meREMY',1165915823,0,0,'',0,'Marinescu Remus',0,0,'','e8bf95439de5eaf21372936d967bad9d7edd03e0','meREMY@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',0,1,'',0,'','',0,0,'','','',0,2,''),(5710,'tanasefl0rin9',1166082196,0,0,'',0,'tanaseflorin',0,0,'','b161fa228675cad15dbb468ebaa9152ea6fa4b1d','tanasefl0rin9@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',0,1,'',0,'','',0,0,'','','',0,2,''),(5822,'anchidinraluca',1167841550,0,0,'',1167901951,'anchidin raluca florentina',0,0,'','c02fcb7fc00320c2e52c03c062cf1a28250f203e','anchidinraluca@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',0,1,'',11330,'','',0,0,'','','',0,2,''),(5931,'vali_mi',1169198457,0,0,'',0,'Mihai Valentin',0,0,'','c45b2d6f5ec1260b1005be549cbc39d09cc72126','vali_mi@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',0,1,'',0,'','',0,0,'','','',0,2,''),(6091,'birsan',1169895323,0,0,'',0,'Andrei Birsan',0,0,'','451b7fd27d9e6dc26163cebc46cf16dfe56b2e3e','birsan@example.com','',0,'0001-01-01','','','','','','','',0,1,'','',0,'',1,0,0,'',1,1,'','','',0,1,'',0,'','',0,0,'','','',0,2,'');
/*!40000 ALTER TABLE `ia_smf_members` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_message_icons`
--

DROP TABLE IF EXISTS `ia_smf_message_icons`;
CREATE TABLE `ia_smf_message_icons` (
  `ID_ICON` smallint(5) unsigned NOT NULL auto_increment,
  `title` varchar(80) collate latin1_general_ci NOT NULL default '',
  `filename` varchar(80) collate latin1_general_ci NOT NULL default '',
  `ID_BOARD` mediumint(8) unsigned NOT NULL default '0',
  `iconOrder` smallint(5) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_ICON`),
  KEY `ID_BOARD` (`ID_BOARD`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_message_icons`
--

LOCK TABLES `ia_smf_message_icons` WRITE;
/*!40000 ALTER TABLE `ia_smf_message_icons` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_message_icons` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_messages`
--

DROP TABLE IF EXISTS `ia_smf_messages`;
CREATE TABLE `ia_smf_messages` (
  `ID_MSG` int(10) unsigned NOT NULL auto_increment,
  `ID_TOPIC` mediumint(8) unsigned NOT NULL default '0',
  `ID_BOARD` smallint(5) unsigned NOT NULL default '0',
  `posterTime` int(10) unsigned NOT NULL default '0',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `ID_MSG_MODIFIED` mediumint(8) unsigned NOT NULL default '0',
  `subject` tinytext collate latin1_general_ci NOT NULL,
  `posterName` tinytext collate latin1_general_ci NOT NULL,
  `posterEmail` tinytext collate latin1_general_ci NOT NULL,
  `posterIP` tinytext collate latin1_general_ci NOT NULL,
  `smileysEnabled` tinyint(4) NOT NULL default '1',
  `modifiedTime` int(10) unsigned NOT NULL default '0',
  `modifiedName` tinytext collate latin1_general_ci NOT NULL,
  `body` text collate latin1_general_ci NOT NULL,
  `icon` varchar(16) collate latin1_general_ci NOT NULL default 'xx',
  `edit_reason` tinytext collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`ID_MSG`),
  UNIQUE KEY `topic` (`ID_TOPIC`,`ID_MSG`),
  UNIQUE KEY `ID_BOARD` (`ID_BOARD`,`ID_MSG`),
  UNIQUE KEY `ID_MEMBER` (`ID_MEMBER`,`ID_MSG`),
  KEY `ID_TOPIC` (`ID_TOPIC`),
  KEY `participation` (`ID_MEMBER`,`ID_TOPIC`),
  KEY `showPosts` (`ID_MEMBER`,`ID_BOARD`),
  KEY `ipIndex` (`posterIP`(15),`ID_TOPIC`),
  FULLTEXT KEY `body` (`body`)
) ENGINE=MyISAM AUTO_INCREMENT=11867 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_messages`
--

LOCK TABLES `ia_smf_messages` WRITE;
/*!40000 ALTER TABLE `ia_smf_messages` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_messages` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_moderators`
--

DROP TABLE IF EXISTS `ia_smf_moderators`;
CREATE TABLE `ia_smf_moderators` (
  `ID_BOARD` smallint(5) unsigned NOT NULL default '0',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_BOARD`,`ID_MEMBER`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_moderators`
--

LOCK TABLES `ia_smf_moderators` WRITE;
/*!40000 ALTER TABLE `ia_smf_moderators` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_moderators` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_package_servers`
--

DROP TABLE IF EXISTS `ia_smf_package_servers`;
CREATE TABLE `ia_smf_package_servers` (
  `ID_SERVER` smallint(5) unsigned NOT NULL auto_increment,
  `name` tinytext collate latin1_general_ci NOT NULL,
  `url` tinytext collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`ID_SERVER`)
) ENGINE=MyISAM AUTO_INCREMENT=5 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_package_servers`
--

LOCK TABLES `ia_smf_package_servers` WRITE;
/*!40000 ALTER TABLE `ia_smf_package_servers` DISABLE KEYS */;
INSERT INTO `ia_smf_package_servers` VALUES (1,'Simple Machines Mod Site','http://mods.simplemachines.org'),(2,'[Unknown]\'s Packages','http://www.unknownbrackets.com/smf'),(3,'Jack.R.Abbit\'s Package Server','http://www.modsbydesign.com/mods.by.jack'),(4,'Grudge\'s Package Server','http://www.mymods.co.uk/Packages');
/*!40000 ALTER TABLE `ia_smf_package_servers` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_permissions`
--

DROP TABLE IF EXISTS `ia_smf_permissions`;
CREATE TABLE `ia_smf_permissions` (
  `ID_GROUP` smallint(6) NOT NULL default '0',
  `permission` varchar(30) collate latin1_general_ci NOT NULL default '',
  `addDeny` tinyint(4) NOT NULL default '1',
  PRIMARY KEY  (`ID_GROUP`,`permission`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_permissions`
--

LOCK TABLES `ia_smf_permissions` WRITE;
/*!40000 ALTER TABLE `ia_smf_permissions` DISABLE KEYS */;
INSERT INTO `ia_smf_permissions` VALUES (20,'search_posts',1),(-1,'view_stats',1),(0,'view_stats',1),(2,'search_posts',1),(0,'karma_edit',1),(0,'calendar_view',1),(2,'pm_send',1),(0,'pm_read',1),(0,'view_mlist',1),(0,'who_view',1),(0,'search_posts',1),(0,'view_stafflist',1),(20,'profile_server_avatar',1),(2,'profile_view_any',1),(2,'view_stafflist',1),(2,'who_view',1),(20,'profile_remote_avatar',1),(0,'profile_remove_own',1),(20,'profile_upload_avatar',1),(2,'view_stats',1),(0,'pm_send',1),(2,'view_mlist',1),(20,'profile_remove_own',1),(20,'profile_extra_own',1),(20,'profile_view_any',1),(0,'profile_server_avatar',1),(20,'profile_identity_own',1),(20,'profile_view_own',1),(20,'pm_send',1),(20,'pm_read',1),(2,'profile_identity_own',1),(2,'karma_edit',1),(0,'profile_identity_own',1),(-1,'view_stafflist',1),(2,'profile_view_own',1),(2,'pm_read',1),(2,'edit_news',1),(2,'calendar_view',1),(2,'calendar_post',1),(2,'calendar_edit_own',1),(20,'calendar_view',1),(20,'karma_edit',1),(20,'view_stafflist',1),(-1,'calendar_view',1),(20,'who_view',1),(20,'view_mlist',1),(20,'view_stats',1),(0,'profile_view_own',1),(0,'profile_view_any',1),(0,'profile_extra_own',1),(2,'profile_extra_own',1),(2,'profile_remove_own',1),(2,'profile_server_avatar',1),(2,'profile_upload_avatar',1),(2,'profile_remote_avatar',1),(-1,'profile_view_any',1),(0,'profile_upload_avatar',1),(0,'profile_remote_avatar',1);
/*!40000 ALTER TABLE `ia_smf_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_personal_messages`
--

DROP TABLE IF EXISTS `ia_smf_personal_messages`;
CREATE TABLE `ia_smf_personal_messages` (
  `ID_PM` int(10) unsigned NOT NULL auto_increment,
  `ID_MEMBER_FROM` mediumint(8) unsigned NOT NULL default '0',
  `deletedBySender` tinyint(3) unsigned NOT NULL default '0',
  `fromName` tinytext collate latin1_general_ci NOT NULL,
  `msgtime` int(10) unsigned NOT NULL default '0',
  `subject` tinytext collate latin1_general_ci NOT NULL,
  `body` text collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`ID_PM`),
  KEY `ID_MEMBER` (`ID_MEMBER_FROM`,`deletedBySender`),
  KEY `msgtime` (`msgtime`)
) ENGINE=MyISAM AUTO_INCREMENT=1334 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_personal_messages`
--

LOCK TABLES `ia_smf_personal_messages` WRITE;
/*!40000 ALTER TABLE `ia_smf_personal_messages` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_personal_messages` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_pm_recipients`
--

DROP TABLE IF EXISTS `ia_smf_pm_recipients`;
CREATE TABLE `ia_smf_pm_recipients` (
  `ID_PM` int(10) unsigned NOT NULL default '0',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `bcc` tinyint(3) unsigned NOT NULL default '0',
  `is_read` tinyint(3) unsigned NOT NULL default '0',
  `deleted` tinyint(3) unsigned NOT NULL default '0',
  `labels` varchar(60) collate latin1_general_ci NOT NULL default '-1',
  PRIMARY KEY  (`ID_PM`,`ID_MEMBER`),
  UNIQUE KEY `ID_MEMBER` (`ID_MEMBER`,`deleted`,`ID_PM`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_pm_recipients`
--

LOCK TABLES `ia_smf_pm_recipients` WRITE;
/*!40000 ALTER TABLE `ia_smf_pm_recipients` DISABLE KEYS */;
INSERT INTO `ia_smf_pm_recipients` VALUES (2,3,0,1,1,'-1'),(3,119,0,0,0,'-1'),(634,239,0,1,1,'-1'),(364,228,0,1,1,'-1'),(6,3,0,1,1,'-1'),(7,119,0,0,0,'-1'),(642,486,0,0,1,'-1'),(363,228,0,1,0,'-1'),(10,3,0,1,1,'-1'),(11,119,0,0,0,'-1'),(728,454,0,1,1,'-1'),(14,3,0,1,1,'-1'),(16,27,0,1,1,'-1'),(17,98,0,1,0,'-1'),(18,69,0,1,0,'-1'),(19,69,0,1,1,'-1'),(21,140,0,1,1,'-1'),(362,56,0,1,1,'-1'),(23,3,0,1,1,'-1'),(24,69,0,1,0,'-1'),(25,69,0,1,1,'-1'),(26,154,0,1,0,'-1'),(27,154,0,1,1,'-1'),(28,69,0,1,0,'-1'),(29,69,0,1,1,'-1'),(30,34,0,0,0,'-1'),(31,141,0,0,0,'-1'),(34,57,0,0,0,'-1'),(33,11,0,0,1,'-1'),(35,69,0,1,0,'-1'),(1226,370,0,3,0,'-1'),(37,43,0,1,0,'-1'),(38,43,0,1,1,'-1'),(39,69,0,1,0,'-1'),(626,3,0,1,1,'-1'),(41,43,0,1,0,'-1'),(42,43,0,1,1,'-1'),(43,69,0,1,0,'-1'),(44,69,0,1,1,'-1'),(45,43,0,1,0,'-1'),(46,43,0,1,1,'-1'),(47,69,0,1,0,'-1'),(48,69,0,1,1,'-1'),(49,69,0,1,0,'-1'),(50,69,0,1,1,'-1'),(51,43,0,1,0,'-1'),(52,43,0,1,1,'-1'),(53,69,0,1,0,'-1'),(54,69,0,1,1,'-1'),(55,43,0,1,0,'-1'),(57,43,0,1,1,'-1'),(61,134,0,0,0,'-1'),(65,126,0,0,0,'-1'),(68,40,0,0,0,'-1'),(69,174,0,0,0,'-1'),(70,69,0,1,0,'-1'),(73,104,0,0,0,'-1'),(1224,394,1,1,0,'-1'),(1227,337,0,3,0,'-1'),(77,97,0,0,0,'-1'),(143,24,0,1,0,'-1'),(79,140,0,1,1,'-1'),(82,3,0,1,1,'-1'),(361,56,0,1,0,'-1'),(84,105,0,0,0,'-1'),(85,3,0,1,1,'-1'),(86,43,0,1,0,'-1'),(87,43,0,1,1,'-1'),(360,27,0,1,1,'-1'),(109,69,0,1,0,'-1'),(90,3,0,1,1,'-1'),(91,47,0,1,0,'-1'),(92,47,0,1,1,'-1'),(93,177,0,1,0,'-1'),(94,55,0,1,0,'-1'),(95,84,0,0,0,'-1'),(96,177,0,1,1,'-1'),(97,47,0,1,0,'-1'),(358,20,0,1,1,'-1'),(100,3,0,1,1,'-1'),(101,43,0,1,0,'-1'),(102,43,0,1,1,'-1'),(103,6,0,0,0,'-1'),(105,3,0,1,1,'-1'),(875,332,0,3,0,'-1'),(107,187,0,1,1,'-1'),(356,27,0,1,1,'-1'),(110,174,0,0,1,'-1'),(111,3,0,1,1,'-1'),(877,3,0,1,0,'-1'),(113,69,0,1,1,'-1'),(114,2,0,1,1,'-1'),(115,43,0,1,0,'-1'),(116,43,0,1,1,'-1'),(117,69,0,1,0,'-1'),(118,69,0,1,1,'-1'),(119,69,0,1,0,'-1'),(120,69,0,1,1,'-1'),(121,43,0,1,0,'-1'),(122,43,0,1,1,'-1'),(355,177,0,1,0,'-1'),(124,47,0,1,0,'-1'),(125,47,0,1,1,'-1'),(126,47,0,1,1,'-1'),(127,43,0,1,0,'-1'),(128,43,0,1,1,'-1'),(129,3,0,1,1,'-1'),(130,141,0,0,1,'-1'),(131,11,0,0,0,'-1'),(132,11,0,0,1,'-1'),(140,69,0,1,1,'-1'),(134,69,0,1,0,'-1'),(135,69,0,1,1,'-1'),(136,70,0,0,0,'-1'),(137,70,0,0,1,'-1'),(138,69,0,1,0,'-1'),(139,121,0,1,1,'-1'),(142,75,0,0,0,'-1'),(145,251,0,0,0,'-1'),(146,251,0,0,1,'-1'),(147,278,0,0,0,'-1'),(148,278,0,0,1,'-1'),(149,251,0,0,0,'-1'),(150,251,0,0,1,'-1'),(354,177,0,1,0,'-1'),(157,251,0,0,0,'-1'),(153,278,0,0,0,'-1'),(154,278,0,0,1,'-1'),(155,3,0,1,1,'-1'),(156,3,0,1,1,'-1'),(158,251,0,0,1,'-1'),(159,278,0,0,0,'-1'),(160,278,0,0,1,'-1'),(163,46,0,0,0,'-1'),(162,3,0,1,1,'-1'),(164,279,0,0,0,'-1'),(165,31,0,0,0,'-1'),(166,11,0,0,0,'-1'),(168,46,0,0,1,'-1'),(169,69,0,1,0,'-1'),(170,69,0,1,1,'-1'),(171,43,0,1,0,'-1'),(172,43,0,1,1,'-1'),(173,221,0,0,0,'-1'),(175,55,0,1,0,'-1'),(176,55,0,1,1,'-1'),(177,292,0,0,0,'-1'),(178,292,0,0,1,'-1'),(179,55,0,1,0,'-1'),(180,55,0,1,1,'-1'),(181,31,0,0,1,'-1'),(183,153,0,0,1,'-1'),(209,43,0,1,0,'-1'),(186,155,0,0,1,'-1'),(187,155,0,0,1,'-1'),(188,177,0,1,0,'-1'),(195,153,0,0,1,'-1'),(196,153,0,0,1,'-1'),(197,153,0,0,1,'-1'),(198,153,0,0,1,'-1'),(208,177,0,1,1,'-1'),(206,3,0,1,1,'-1'),(207,136,0,0,0,'-1'),(202,155,0,0,1,'-1'),(203,155,0,0,1,'-1'),(204,155,0,0,1,'-1'),(222,177,0,1,1,'-1'),(211,43,0,1,1,'-1'),(212,177,0,1,0,'-1'),(213,121,0,1,1,'-1'),(214,70,0,0,0,'-1'),(215,177,0,1,0,'-1'),(216,70,0,0,1,'-1'),(292,204,0,0,0,'-1'),(218,153,0,0,1,'-1'),(353,43,0,1,1,'-1'),(221,121,0,1,1,'-1'),(224,166,0,1,0,'-1'),(227,3,0,1,1,'-1'),(229,60,0,0,0,'-1'),(231,6,0,0,1,'-1'),(232,202,0,0,0,'-1'),(234,26,0,1,0,'-1'),(291,25,0,0,0,'-1'),(236,133,0,0,0,'-1'),(238,188,0,0,0,'-1'),(239,174,0,0,0,'-1'),(240,93,0,0,0,'-1'),(242,82,0,0,0,'-1'),(243,70,0,0,0,'-1'),(247,172,0,0,0,'-1'),(249,138,0,1,0,'-1'),(254,67,0,0,0,'-1'),(256,75,0,0,1,'-1'),(352,43,0,1,0,'-1'),(258,3,0,1,1,'-1'),(351,177,0,1,1,'-1'),(262,3,0,1,1,'-1'),(263,95,0,0,0,'-1'),(264,16,0,0,0,'-1'),(265,43,0,1,0,'-1'),(267,43,0,1,1,'-1'),(268,177,0,1,0,'-1'),(1233,505,0,1,0,'-1'),(271,43,0,1,0,'-1'),(272,177,0,1,1,'-1'),(273,43,0,1,0,'-1'),(274,172,0,0,0,'-1'),(275,43,0,1,1,'-1'),(276,177,0,1,0,'-1'),(278,124,0,0,0,'-1'),(350,177,0,1,1,'-1'),(283,69,0,1,1,'-1'),(282,69,0,1,0,'-1'),(285,179,0,0,1,'-1'),(286,69,0,1,0,'-1'),(287,69,0,1,1,'-1'),(288,101,0,0,0,'-1'),(289,3,0,1,1,'-1'),(298,177,0,1,1,'-1'),(299,177,0,1,0,'-1'),(300,352,0,0,0,'-1'),(301,352,0,0,1,'-1'),(302,106,0,0,0,'-1'),(303,106,0,0,1,'-1'),(304,291,0,0,0,'-1'),(305,154,0,1,0,'-1'),(306,154,0,1,1,'-1'),(307,352,0,0,0,'-1'),(308,352,0,0,1,'-1'),(309,154,0,1,0,'-1'),(310,154,0,1,1,'-1'),(311,352,0,0,0,'-1'),(312,352,0,0,1,'-1'),(313,154,0,1,0,'-1'),(314,154,0,1,1,'-1'),(315,291,0,0,1,'-1'),(316,352,0,0,0,'-1'),(317,352,0,0,1,'-1'),(318,291,0,0,0,'-1'),(319,291,0,0,0,'-1'),(320,154,0,1,0,'-1'),(321,47,0,1,0,'-1'),(322,154,0,1,1,'-1'),(323,47,0,1,1,'-1'),(324,47,0,1,0,'-1'),(325,47,0,1,0,'-1'),(326,47,0,1,1,'-1'),(327,47,0,1,1,'-1'),(328,352,0,0,0,'-1'),(329,352,0,0,1,'-1'),(349,43,0,1,1,'-1'),(334,3,0,1,1,'-1'),(336,20,0,1,1,'-1'),(338,177,0,1,1,'-1'),(339,43,0,1,0,'-1'),(340,43,0,1,1,'-1'),(341,177,0,1,0,'-1'),(342,177,0,1,0,'-1'),(348,43,0,1,0,'-1'),(346,3,0,1,1,'-1'),(347,3,0,1,1,'-1'),(365,70,0,0,0,'-1'),(823,3,0,1,0,'-1'),(367,46,0,0,0,'-1'),(368,46,0,0,1,'-1'),(369,47,0,1,0,'-1'),(370,47,0,1,1,'-1'),(371,46,0,0,0,'-1'),(372,46,0,0,1,'-1'),(373,47,0,1,0,'-1'),(374,46,0,0,0,'-1'),(375,46,0,0,1,'-1'),(376,328,0,1,0,'-1'),(377,47,0,1,0,'-1'),(378,328,0,1,1,'-1'),(379,47,0,1,1,'-1'),(380,47,0,1,1,'-1'),(381,46,0,0,0,'-1'),(382,46,0,0,1,'-1'),(383,10,0,1,0,'-1'),(384,10,0,1,1,'-1'),(385,46,0,0,0,'-1'),(386,46,0,0,0,'-1'),(387,122,0,1,0,'-1'),(389,46,0,0,1,'-1'),(390,46,0,0,1,'-1'),(391,10,0,1,0,'-1'),(392,177,0,1,1,'-1'),(393,177,0,1,1,'-1'),(394,10,0,1,1,'-1'),(395,46,0,0,0,'-1'),(396,46,0,0,1,'-1'),(397,10,0,1,0,'-1'),(398,10,0,1,0,'-1'),(399,43,0,1,0,'-1'),(400,11,0,0,0,'-1'),(402,154,0,1,0,'-1'),(403,43,0,1,1,'-1'),(404,10,0,1,1,'-1'),(405,10,0,1,1,'-1'),(406,3,0,1,0,'-1'),(407,154,0,1,1,'-1'),(408,3,0,1,1,'-1'),(409,10,0,1,0,'-1'),(410,10,0,1,1,'-1'),(411,3,0,1,0,'-1'),(412,3,0,1,1,'-1'),(413,154,0,1,0,'-1'),(414,11,0,0,1,'-1'),(415,3,0,1,0,'-1'),(416,154,0,1,1,'-1'),(417,3,0,1,0,'-1'),(418,3,0,1,1,'-1'),(419,3,0,1,1,'-1'),(420,11,0,0,0,'-1'),(421,154,0,1,0,'-1'),(422,154,0,1,1,'-1'),(423,11,0,0,1,'-1'),(1232,3,0,1,0,'-1'),(426,3,0,1,0,'-1'),(430,332,0,1,1,'-1'),(431,154,0,1,0,'-1'),(432,154,0,1,1,'-1'),(510,46,0,0,1,'-1'),(1231,1543,0,3,0,'-1'),(438,332,0,1,1,'-1'),(439,154,0,1,0,'-1'),(440,154,0,1,1,'-1'),(443,332,0,1,1,'-1'),(444,10,0,1,0,'-1'),(445,10,0,1,1,'-1'),(446,3,0,1,0,'-1'),(447,154,0,1,0,'-1'),(448,154,0,1,1,'-1'),(449,31,0,0,0,'-1'),(450,31,0,0,1,'-1'),(451,154,0,1,0,'-1'),(452,154,0,1,1,'-1'),(453,3,0,1,1,'-1'),(1230,370,0,1,0,'-1'),(460,3,0,1,1,'-1'),(1229,4093,0,0,0,'-1'),(463,138,0,1,0,'-1'),(465,138,0,1,0,'-1'),(1228,1475,0,0,0,'-1'),(469,47,0,1,0,'-1'),(470,47,0,1,0,'-1'),(606,47,0,1,1,'-1'),(472,47,0,1,0,'-1'),(605,47,0,1,0,'-1'),(474,47,0,1,1,'-1'),(475,352,0,0,0,'-1'),(476,352,0,0,1,'-1'),(477,3,0,1,0,'-1'),(478,3,0,1,1,'-1'),(479,438,0,1,0,'-1'),(480,438,0,1,1,'-1'),(482,43,0,1,0,'-1'),(486,43,0,1,0,'-1'),(488,154,0,1,0,'-1'),(1217,1379,0,3,0,'-1'),(492,154,0,1,0,'-1'),(1216,655,0,1,0,'-1'),(496,257,0,1,0,'-1'),(497,257,0,1,1,'-1'),(498,242,0,0,0,'-1'),(499,10,0,1,0,'-1'),(811,79,0,1,0,'-1'),(1224,154,0,1,0,'-1'),(504,46,0,0,0,'-1'),(507,154,0,1,0,'-1'),(508,154,0,1,1,'-1'),(511,332,0,1,0,'-1'),(514,332,0,1,1,'-1'),(515,46,0,0,0,'-1'),(516,242,0,0,1,'-1'),(1223,1379,0,0,0,'-1'),(519,46,0,0,1,'-1'),(521,332,0,1,0,'-1'),(523,3,0,1,0,'-1'),(1222,2342,1,0,0,'-1'),(527,3,0,1,0,'-1'),(529,3,0,1,0,'-1'),(690,103,0,1,0,'-1'),(536,46,0,0,0,'-1'),(537,46,0,0,1,'-1'),(538,332,0,1,0,'-1'),(539,332,0,1,1,'-1'),(540,46,0,0,0,'-1'),(541,46,0,0,1,'-1'),(543,47,0,1,0,'-1'),(545,456,0,1,0,'-1'),(551,456,0,1,0,'-1'),(554,47,0,1,0,'-1'),(557,440,0,1,0,'-1'),(558,440,0,1,1,'-1'),(559,452,0,1,0,'-1'),(560,452,0,1,1,'-1'),(561,440,0,1,0,'-1'),(562,47,0,1,0,'-1'),(564,440,0,1,1,'-1'),(565,452,0,1,0,'-1'),(566,452,0,1,1,'-1'),(567,47,0,1,0,'-1'),(1222,493,0,0,0,'-1'),(571,55,0,1,0,'-1'),(575,47,0,1,0,'-1'),(576,47,0,1,1,'-1'),(577,275,0,1,0,'-1'),(579,275,0,1,1,'-1'),(1225,431,1,1,1,'-1'),(581,47,0,1,0,'-1'),(583,47,0,1,0,'-1'),(584,47,0,1,1,'-1'),(585,371,0,1,0,'-1'),(586,371,0,1,1,'-1'),(810,505,0,1,0,'-1'),(592,3,0,1,0,'-1'),(593,3,0,1,1,'-1'),(596,154,0,1,0,'-1'),(597,154,0,1,1,'-1'),(598,47,0,1,0,'-1'),(599,47,0,1,1,'-1'),(643,156,0,0,1,'-1'),(602,60,0,0,0,'-1'),(603,60,0,0,1,'-1'),(604,448,0,1,0,'-1'),(607,10,0,1,0,'-1'),(608,10,0,1,1,'-1'),(610,27,0,1,1,'-1'),(615,3,0,1,0,'-1'),(616,3,0,1,1,'-1'),(617,460,0,1,0,'-1'),(618,460,0,1,1,'-1'),(619,3,0,1,0,'-1'),(620,3,0,1,1,'-1'),(621,96,0,1,0,'-1'),(625,3,0,1,0,'-1'),(627,239,0,1,0,'-1'),(628,239,0,1,1,'-1'),(629,3,0,1,0,'-1'),(630,3,0,1,0,'-1'),(631,3,0,1,1,'-1'),(632,3,0,1,1,'-1'),(633,239,0,1,0,'-1'),(635,228,0,1,0,'-1'),(636,103,0,1,0,'-1'),(638,156,0,0,0,'-1'),(639,47,0,1,0,'-1'),(640,47,0,1,1,'-1'),(641,503,0,0,0,'-1'),(644,448,0,1,1,'-1'),(645,332,0,1,0,'-1'),(646,332,0,1,0,'-1'),(648,520,0,1,1,'-1'),(649,332,0,1,1,'-1'),(650,332,0,1,1,'-1'),(651,417,0,1,0,'-1'),(652,417,0,1,1,'-1'),(1225,5480,0,1,0,'-1'),(655,417,0,1,0,'-1'),(658,10,0,1,0,'-1'),(945,370,0,3,0,'-1'),(661,520,0,1,1,'-1'),(662,10,0,1,0,'-1'),(921,3,0,1,0,'-1'),(665,520,0,1,1,'-1'),(666,10,0,1,0,'-1'),(920,69,0,1,0,'-1'),(669,520,0,1,1,'-1'),(670,10,0,1,0,'-1'),(672,472,0,1,0,'-1'),(673,536,0,0,0,'-1'),(675,291,0,0,1,'-1'),(1224,1136,1,0,0,'-1'),(677,472,0,1,1,'-1'),(678,370,0,1,0,'-1'),(679,370,0,1,1,'-1'),(680,370,0,1,0,'-1'),(681,370,0,1,1,'-1'),(682,370,0,1,0,'-1'),(683,370,0,1,1,'-1'),(684,3,0,1,0,'-1'),(685,3,0,1,1,'-1'),(1040,10,0,3,0,'-1'),(688,103,0,1,1,'-1'),(1221,493,0,0,0,'-1'),(699,370,0,1,0,'-1'),(698,471,0,1,1,'-1'),(1220,493,0,0,0,'-1'),(1219,655,0,3,0,'-1'),(696,103,0,1,0,'-1'),(700,460,0,1,0,'-1'),(703,505,0,1,1,'-1'),(1328,471,0,3,0,'-1'),(705,103,0,1,0,'-1'),(899,505,0,1,0,'-1'),(736,79,0,1,0,'-1'),(1221,2342,1,0,0,'-1'),(738,79,0,1,1,'-1'),(739,505,0,1,0,'-1'),(740,505,0,1,1,'-1'),(741,79,0,1,0,'-1'),(742,79,0,1,1,'-1'),(743,96,0,1,0,'-1'),(744,96,0,1,1,'-1'),(745,529,0,1,0,'-1'),(748,96,0,1,0,'-1'),(750,529,0,1,1,'-1'),(751,96,0,1,0,'-1'),(752,96,0,1,0,'-1'),(753,96,0,1,1,'-1'),(754,529,0,1,0,'-1'),(755,96,0,1,1,'-1'),(756,529,0,1,0,'-1'),(757,529,0,1,1,'-1'),(758,529,0,1,1,'-1'),(759,96,0,1,0,'-1'),(760,96,0,1,1,'-1'),(761,529,0,1,0,'-1'),(762,529,0,1,1,'-1'),(763,3,0,1,0,'-1'),(764,3,0,1,1,'-1'),(1218,3,0,1,0,'-1'),(767,505,0,1,0,'-1'),(824,505,0,1,0,'-1'),(773,79,0,1,0,'-1'),(777,79,0,1,0,'-1'),(779,69,0,1,0,'-1'),(780,69,0,1,1,'-1'),(781,96,0,1,0,'-1'),(782,96,0,1,1,'-1'),(783,119,0,0,0,'-1'),(784,503,0,0,1,'-1'),(786,27,0,1,1,'-1'),(787,332,0,1,0,'-1'),(788,332,0,1,1,'-1'),(790,47,0,1,0,'-1'),(791,47,0,1,1,'-1'),(792,96,0,1,0,'-1'),(1224,711,1,0,0,'-1'),(794,503,0,0,0,'-1'),(795,96,0,1,1,'-1'),(796,79,0,1,0,'-1'),(797,79,0,1,1,'-1'),(799,3,0,1,0,'-1'),(800,3,0,1,1,'-1'),(802,505,0,1,1,'-1'),(1150,505,0,1,0,'-1'),(805,27,0,1,1,'-1'),(807,505,0,1,1,'-1'),(808,79,0,3,0,'-1'),(827,113,0,0,0,'-1'),(829,505,0,1,0,'-1'),(834,3,0,3,0,'-1'),(836,154,0,1,0,'-1'),(900,69,0,1,0,'-1'),(842,10,0,1,0,'-1'),(843,3,0,1,0,'-1'),(919,3,0,1,0,'-1'),(846,370,0,1,0,'-1'),(847,121,0,3,0,'-1'),(848,121,0,3,0,'-1'),(849,524,0,3,0,'-1'),(850,69,0,3,0,'-1'),(851,615,0,3,0,'-1'),(852,69,0,1,0,'-1'),(853,451,0,1,0,'-1'),(854,615,0,1,0,'-1'),(1209,1616,0,1,0,'-1'),(856,337,0,1,0,'-1'),(859,47,0,3,0,'-1'),(866,506,0,3,0,'-1'),(860,451,0,3,0,'-1'),(861,47,0,1,0,'-1'),(863,332,0,3,0,'-1'),(865,332,0,1,0,'-1'),(868,132,0,1,0,'-1'),(869,506,0,3,0,'-1'),(871,506,0,1,0,'-1'),(872,47,0,1,0,'-1'),(873,69,0,3,0,'-1'),(874,308,0,1,0,'-1'),(879,3,0,1,0,'-1'),(880,121,0,3,0,'-1'),(881,653,0,0,0,'-1'),(882,639,0,1,0,'-1'),(883,154,0,3,0,'-1'),(884,506,0,1,0,'-1'),(887,96,0,1,0,'-1'),(888,96,0,1,0,'-1'),(889,558,0,1,0,'-1'),(891,79,0,3,0,'-1'),(892,132,0,1,0,'-1'),(893,394,0,1,1,'-1'),(895,55,0,3,0,'-1'),(897,96,0,3,0,'-1'),(901,43,0,1,0,'-1'),(936,370,0,3,0,'-1'),(906,505,0,1,0,'-1'),(996,79,0,3,0,'-1'),(905,257,0,3,0,'-1'),(907,132,0,1,0,'-1'),(908,10,0,3,0,'-1'),(910,10,0,3,0,'-1'),(911,505,0,3,0,'-1'),(912,10,0,3,0,'-1'),(913,505,0,1,0,'-1'),(914,10,0,3,0,'-1'),(915,505,0,1,0,'-1'),(916,3,0,1,0,'-1'),(918,412,0,3,0,'-1'),(924,412,0,3,0,'-1'),(1056,122,0,1,0,'-1'),(926,412,0,1,0,'-1'),(927,79,0,1,0,'-1'),(928,3,0,1,0,'-1'),(929,3,0,1,0,'-1'),(930,3,0,1,0,'-1'),(931,3,0,1,0,'-1'),(932,3,0,1,0,'-1'),(933,3,0,1,0,'-1'),(934,3,0,1,0,'-1'),(935,47,0,1,0,'-1'),(937,505,0,1,0,'-1'),(938,370,0,1,0,'-1'),(939,370,0,3,0,'-1'),(940,505,0,3,0,'-1'),(942,505,0,1,0,'-1'),(1009,43,0,3,0,'-1'),(992,79,0,3,0,'-1'),(991,79,0,3,0,'-1'),(955,47,0,3,0,'-1'),(958,47,0,1,0,'-1'),(960,257,0,1,0,'-1'),(963,505,0,1,0,'-1'),(985,79,0,3,0,'-1'),(976,79,0,1,0,'-1'),(977,79,0,3,0,'-1'),(979,79,0,3,0,'-1'),(980,79,0,1,0,'-1'),(989,79,0,3,0,'-1'),(988,79,0,3,0,'-1'),(987,79,0,1,0,'-1'),(998,79,0,3,0,'-1'),(1010,689,0,1,0,'-1'),(1002,79,0,1,0,'-1'),(1013,96,0,1,0,'-1'),(1018,3,0,1,0,'-1'),(1019,505,0,1,0,'-1'),(1020,662,0,1,0,'-1'),(1050,662,0,3,0,'-1'),(1022,505,0,1,0,'-1'),(1049,79,0,1,0,'-1'),(1024,617,0,3,1,'-1'),(1025,617,0,1,1,'-1'),(1026,662,0,3,0,'-1'),(1027,617,0,1,1,'-1'),(1028,617,0,1,1,'-1'),(1029,617,0,3,1,'-1'),(1030,662,0,1,0,'-1'),(1032,394,0,1,0,'-1'),(1033,394,0,1,0,'-1'),(1034,662,0,3,0,'-1'),(1035,505,0,1,0,'-1'),(1036,79,0,1,0,'-1'),(1038,394,0,1,0,'-1'),(1039,154,0,1,0,'-1'),(1041,520,0,3,0,'-1'),(1043,154,0,3,0,'-1'),(1052,505,0,3,0,'-1'),(1045,154,0,3,0,'-1'),(1051,505,0,1,0,'-1'),(1047,10,0,3,0,'-1'),(1048,520,0,1,0,'-1'),(1053,662,0,1,0,'-1'),(1054,3,0,1,0,'-1'),(1055,3,0,3,0,'-1'),(1057,506,0,3,0,'-1'),(1058,712,0,3,0,'-1'),(1059,662,0,3,0,'-1'),(1060,394,0,1,0,'-1'),(1061,695,0,3,0,'-1'),(1208,257,0,3,0,'-1'),(1063,10,0,3,0,'-1'),(1065,662,0,3,0,'-1'),(1207,5166,1,1,0,'-1'),(1067,506,0,1,0,'-1'),(1068,662,0,1,0,'-1'),(1069,662,0,3,0,'-1'),(1070,506,0,3,0,'-1'),(1207,2059,1,0,0,'-1'),(1075,662,0,1,0,'-1'),(1207,1136,1,0,0,'-1'),(1078,505,0,1,0,'-1'),(1081,96,0,1,0,'-1'),(1084,505,0,1,0,'-1'),(1085,328,0,3,0,'-1'),(1086,620,0,3,0,'-1'),(1089,328,0,3,0,'-1'),(1090,620,0,3,0,'-1'),(1092,328,0,3,0,'-1'),(1093,606,0,1,0,'-1'),(1094,620,0,3,0,'-1'),(1095,154,0,1,0,'-1'),(1104,3,0,1,0,'-1'),(1105,328,0,3,0,'-1'),(1106,55,0,1,0,'-1'),(1107,620,0,1,0,'-1'),(1108,55,0,1,0,'-1'),(1215,1379,0,3,0,'-1'),(1110,714,0,3,0,'-1'),(1111,714,0,1,0,'-1'),(1214,726,0,0,0,'-1'),(1113,606,0,1,0,'-1'),(1114,606,0,1,0,'-1'),(1213,79,0,3,0,'-1'),(1116,714,0,3,0,'-1'),(1212,121,0,1,0,'-1'),(1118,188,0,0,0,'-1'),(1119,505,0,1,0,'-1'),(1120,617,0,3,1,'-1'),(1121,662,0,1,0,'-1'),(1122,662,0,3,0,'-1'),(1123,617,0,3,1,'-1'),(1124,662,0,3,0,'-1'),(1125,617,0,3,1,'-1'),(1126,662,0,1,0,'-1'),(1128,505,0,1,0,'-1'),(1129,758,0,3,0,'-1'),(1130,758,0,1,0,'-1'),(1131,412,0,3,0,'-1'),(1133,412,0,3,0,'-1'),(1135,412,0,1,0,'-1'),(1136,412,0,1,0,'-1'),(1139,262,0,1,0,'-1'),(1140,394,0,3,0,'-1'),(1141,758,0,3,0,'-1'),(1142,394,0,1,0,'-1'),(1159,308,0,3,0,'-1'),(1144,370,0,3,0,'-1'),(1145,505,0,3,0,'-1'),(1146,662,0,3,0,'-1'),(1211,726,0,1,0,'-1'),(1148,370,0,3,0,'-1'),(1149,505,0,1,0,'-1'),(1152,580,0,1,0,'-1'),(1154,662,0,3,0,'-1'),(1155,580,0,0,0,'-1'),(1156,580,0,0,0,'-1'),(1160,79,0,3,0,'-1'),(1210,655,0,3,0,'-1'),(1163,689,0,3,0,'-1'),(1164,505,0,1,0,'-1'),(1165,8,0,0,0,'-1'),(1224,471,1,1,1,'-1'),(1166,531,0,3,0,'-1'),(1167,3,0,1,0,'-1'),(1168,505,0,3,0,'-1'),(1169,662,0,3,0,'-1'),(1170,505,0,3,0,'-1'),(1171,662,0,1,0,'-1'),(1172,412,0,3,0,'-1'),(1173,493,0,3,0,'-1'),(1174,531,0,1,0,'-1'),(1175,662,0,1,0,'-1'),(1176,121,0,3,0,'-1'),(1177,5,0,1,0,'-1'),(1178,2390,0,0,0,'-1'),(1179,257,0,1,0,'-1'),(1180,505,0,1,0,'-1'),(1181,2,0,3,0,'-1'),(1182,3,0,3,0,'-1'),(1183,5652,0,0,0,'-1'),(1184,3,0,1,0,'-1'),(1185,10,0,3,0,'-1'),(1186,47,0,3,0,'-1'),(1187,553,0,0,0,'-1'),(1188,495,0,1,0,'-1'),(1189,337,0,1,0,'-1'),(1190,1568,0,3,0,'-1'),(1191,3,0,1,0,'-1'),(1192,47,0,1,0,'-1'),(1193,4840,0,1,0,'-1'),(1207,1616,0,1,0,'-1'),(1195,3,0,1,0,'-1'),(1196,1379,0,1,0,'-1'),(1197,3,0,3,0,'-1'),(1198,5,0,1,0,'-1'),(1199,5,0,1,0,'-1'),(1200,166,0,3,0,'-1'),(1200,1616,1,3,0,'-1'),(1201,394,0,1,0,'-1'),(1202,394,0,1,0,'-1'),(1203,1616,0,3,0,'-1'),(1204,394,0,1,0,'-1'),(1205,256,0,3,0,'-1'),(1206,1616,0,1,0,'-1'),(1234,3,0,1,0,'-1'),(1235,48,0,0,0,'-1'),(1235,154,1,1,0,'-1'),(1236,308,0,1,0,'-1'),(1237,617,0,3,0,'-1'),(1238,1543,0,3,0,'-1'),(1239,617,0,3,0,'-1'),(1240,1543,0,0,0,'-1'),(1241,461,0,3,0,'-1'),(1242,4669,0,3,0,'-1'),(1243,1987,0,0,0,'-1'),(1244,1987,0,0,0,'-1'),(1254,5056,0,0,0,'-1'),(1246,3636,0,1,0,'-1'),(1251,394,0,3,0,'-1'),(1248,308,0,1,0,'-1'),(1249,3,0,1,0,'-1'),(1250,3780,0,0,0,'-1'),(1252,308,0,0,0,'-1'),(1253,464,0,0,0,'-1'),(1255,4689,0,0,0,'-1'),(1256,353,0,0,0,'-1'),(1257,10,0,1,0,'-1'),(1258,10,0,3,0,'-1'),(1259,757,0,1,0,'-1'),(1260,652,0,0,0,'-1'),(1261,79,0,3,0,'-1'),(1262,1619,0,1,0,'-1'),(1263,2435,0,0,0,'-1'),(1264,5929,0,0,0,'-1'),(1265,3448,0,3,0,'-1'),(1266,516,0,3,0,'-1'),(1267,5232,0,0,0,'-1'),(1268,5911,0,0,0,'-1'),(1269,3889,0,3,0,'-1'),(1270,3889,0,1,0,'-1'),(1271,3448,0,3,0,'-1'),(1272,5739,0,0,0,'-1'),(1273,3889,0,3,0,'-1'),(1274,3448,0,1,0,'-1'),(1275,585,0,0,0,'-1'),(1276,408,0,1,0,'-1'),(1277,1987,0,0,0,'-1'),(1278,328,0,0,0,'-1'),(1280,531,0,1,0,'-1'),(1281,79,0,3,0,'-1'),(1282,154,0,1,0,'-1'),(1283,531,0,3,0,'-1'),(1284,3257,0,3,0,'-1'),(1285,154,0,1,0,'-1'),(1286,3257,0,1,0,'-1'),(1287,531,0,1,0,'-1'),(1288,461,0,1,0,'-1'),(1289,4669,0,1,0,'-1'),(1290,531,0,1,0,'-1'),(1291,506,0,1,0,'-1'),(1292,47,0,1,0,'-1'),(1293,825,0,0,0,'-1'),(1294,503,0,0,0,'-1'),(1295,154,0,1,0,'-1'),(1296,5971,0,0,0,'-1'),(1297,5343,0,3,0,'-1'),(1298,5934,0,1,0,'-1'),(1303,615,0,3,0,'-1'),(1300,5343,0,1,0,'-1'),(1301,5343,0,3,0,'-1'),(1304,3352,0,3,0,'-1'),(1305,615,0,3,0,'-1'),(1306,3352,0,3,0,'-1'),(1307,615,0,3,0,'-1'),(1308,3352,0,1,0,'-1'),(1309,6065,0,0,0,'-1'),(1310,47,0,3,0,'-1'),(1311,460,0,0,0,'-1'),(1312,5917,0,1,0,'-1'),(1313,5928,0,3,0,'-1'),(1314,5241,0,1,0,'-1'),(1315,5928,0,1,0,'-1'),(1316,602,0,1,0,'-1'),(1317,825,0,0,0,'-1'),(1318,10,0,3,0,'-1'),(1319,5750,0,1,0,'-1'),(1320,428,0,0,0,'-1'),(1321,6002,0,1,0,'-1'),(1322,4710,0,3,0,'-1'),(1323,602,0,0,0,'-1'),(1324,343,0,1,0,'-1'),(1325,343,0,1,0,'-1'),(1326,2,0,0,0,'-1'),(1327,412,0,3,0,'-1'),(1329,412,0,1,0,'-1'),(1330,335,0,0,0,'-1'),(1331,3,0,3,0,'-1'),(1333,825,0,0,0,'-1');
/*!40000 ALTER TABLE `ia_smf_pm_recipients` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_poll_choices`
--

DROP TABLE IF EXISTS `ia_smf_poll_choices`;
CREATE TABLE `ia_smf_poll_choices` (
  `ID_POLL` mediumint(8) unsigned NOT NULL default '0',
  `ID_CHOICE` tinyint(3) unsigned NOT NULL default '0',
  `label` tinytext collate latin1_general_ci NOT NULL,
  `votes` smallint(5) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_POLL`,`ID_CHOICE`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_poll_choices`
--

LOCK TABLES `ia_smf_poll_choices` WRITE;
/*!40000 ALTER TABLE `ia_smf_poll_choices` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_poll_choices` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_polls`
--

DROP TABLE IF EXISTS `ia_smf_polls`;
CREATE TABLE `ia_smf_polls` (
  `ID_POLL` mediumint(8) unsigned NOT NULL auto_increment,
  `question` tinytext collate latin1_general_ci NOT NULL,
  `votingLocked` tinyint(1) NOT NULL default '0',
  `maxVotes` tinyint(3) unsigned NOT NULL default '1',
  `expireTime` int(10) unsigned NOT NULL default '0',
  `hideResults` tinyint(3) unsigned NOT NULL default '0',
  `changeVote` tinyint(3) unsigned NOT NULL default '0',
  `ID_MEMBER` mediumint(8) unsigned NOT NULL default '0',
  `posterName` tinytext collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`ID_POLL`)
) ENGINE=MyISAM AUTO_INCREMENT=38 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_polls`
--

LOCK TABLES `ia_smf_polls` WRITE;
/*!40000 ALTER TABLE `ia_smf_polls` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_polls` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_sessions`
--

DROP TABLE IF EXISTS `ia_smf_sessions`;
CREATE TABLE `ia_smf_sessions` (
  `session_id` varchar(32) collate latin1_general_ci NOT NULL default '',
  `last_update` int(10) unsigned NOT NULL default '0',
  `data` text collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`session_id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_sessions`
--

LOCK TABLES `ia_smf_sessions` WRITE;
/*!40000 ALTER TABLE `ia_smf_sessions` DISABLE KEYS */;
/*!40000 ALTER TABLE `ia_smf_sessions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_settings`
--

DROP TABLE IF EXISTS `ia_smf_settings`;
CREATE TABLE `ia_smf_settings` (
  `variable` tinytext collate latin1_general_ci NOT NULL,
  `value` text collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`variable`(30))
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_settings`
--

LOCK TABLES `ia_smf_settings` WRITE;
/*!40000 ALTER TABLE `ia_smf_settings` DISABLE KEYS */;
INSERT INTO `ia_smf_settings` VALUES ('smfVersion','1.1 RC3'),('news',''),('compactTopicPagesContiguous','5'),('compactTopicPagesEnable','1'),('enableStickyTopics','1'),('todayMod','1'),('karmaMode','1'),('karmaTimeRestrictAdmins','1'),('enablePreviousNext','1'),('pollMode','1'),('enableVBStyleLogin','1'),('enableCompressedOutput','0'),('karmaWaitTime','12'),('karmaMinPosts','1'),('karmaLabel','Karma:'),('karmaSmiteLabel','[-]'),('karmaApplaudLabel','[+]'),('attachmentSizeLimit','128'),('attachmentPostLimit','192'),('attachmentNumPerPostLimit','4'),('attachmentDirSizeLimit','10240'),('attachmentUploadDir','/www/ftp.devnet.ro/devnet.ro/infoarena/forum/attachments'),('attachmentExtensions','txt,doc,pdf,jpg,gif,mpg,png'),('attachmentCheckExtensions','1'),('attachmentShowImages','1'),('attachmentEnable','1'),('attachmentEncryptFilenames','1'),('karmaApplaudImage','up.gif'),('censorIgnoreCase','1'),('mostOnline','84'),('mostOnlineToday','19'),('mostDate','1169363812'),('allow_disableAnnounce','1'),('trackStats','1'),('userLanguage','1'),('titlesEnable','1'),('topicSummaryPosts','50'),('enableErrorLogging','1'),('max_image_width','0'),('max_image_height','0'),('onlineEnable','1'),('topbottomEnable','1'),('cal_holidaycolor','000080'),('cal_bdaycolor','920AC4'),('cal_eventcolor','078907'),('cal_enabled','1'),('cal_maxyear','2666'),('cal_minyear','2002'),('cal_daysaslink','1'),('cal_defaultboard','9'),('cal_showeventsonindex','1'),('cal_showbdaysonindex','1'),('cal_showholidaysonindex','0'),('cal_showweeknum','1'),('cal_allowspan','1'),('cal_maxspan','666'),('smtp_host',''),('smtp_port','25'),('smtp_username',''),('smtp_password',''),('mail_type','0'),('timeLoadPageEnable','0'),('totalTopics','1348'),('totalMessages','11162'),('simpleSearch','1'),('censor_vulgar','popular\nmuie\ncurva\npizda\ncacat\nbulangi\npoponar\npula'),('enablePostHTML','0'),('theme_allow','0'),('theme_default','0'),('theme_guests','1'),('enableEmbeddedFlash','0'),('xmlnews_enable','1'),('xmlnews_maxlen','255'),('hotTopicPosts','25'),('hotTopicVeryPosts','50'),('registration_method','1'),('send_validation_onChange','1'),('send_welcomeEmail','1'),('allow_editDisplayName','1'),('allow_hideEmail','1'),('guest_hideContacts','1'),('spamWaitTime','15'),('reserveWord','0'),('reserveCase','1'),('reserveUser','1'),('reserveName','1'),('reserveNames',''),('autoLinkUrls','1'),('banLastUpdated','1147978074'),('smileys_dir','/home/infoarena/live/smf/Smileys'),('smileys_url','http://www.infoarena.ro/forum/Smileys'),('avatar_directory','/www/ftp.devnet.ro/devnet.ro/infoarena/forum/avatars'),('avatar_url','http://infoarena.devnet.ro/forum/avatars'),('avatar_max_height_external','100'),('avatar_max_width_external','100'),('avatar_action_too_large','option_download_and_resize'),('avatar_max_height_upload','100'),('avatar_max_width_upload','100'),('avatar_resize_upload','1'),('avatar_download_png','1'),('failed_login_threshold','5'),('enableSpellChecking','0'),('queryless_urls','1'),('edit_wait_time','90'),('autoFixDatabase','1'),('allow_guestAccess','1'),('time_format','%B %d, %Y, %H:%M:%S'),('number_format','1.234,00'),('enableBBC','1'),('enableNewReplyWarning','1'),('max_messageLength','50000'),('max_signatureLength','255'),('autoOptDatabase','7'),('autoOptMaxOnline','0'),('autoOptLastOpt','1169768268'),('defaultMaxMessages','25'),('defaultMaxTopics','25'),('defaultMaxMembers','50'),('enableParticipation','1'),('recycle_enable','0'),('recycle_board','0'),('maxMsgID','11866'),('enableAllMessages','0'),('fixLongWords','0'),('knownThemes','1'),('who_enabled','1'),('time_offset','2'),('cookieTime','60'),('lastActive','15'),('smiley_sets_known','default'),('smiley_sets_names','Default'),('smiley_sets_default','default'),('smiley_enable','1'),('modlog_enabled','1'),('cal_days_for_index','7'),('requireAgreement','1'),('unapprovedMembers','13'),('default_personalText',''),('package_make_backups','1'),('databaseSession_enable','1'),('databaseSession_loose','1'),('databaseSession_lifetime','3600'),('messageIcons_enable','1'),('search_results_per_page','50'),('search_weight_frequency','30'),('search_weight_age','25'),('search_weight_length','20'),('search_weight_subject','15'),('search_weight_first_message','10'),('latestMember','5745'),('latestRealName','Claudiu Cheles'),('mostOnlineUpdated','2007-01-29'),('censor_proper','popular\nm**e\nc***a\np***a\nc***t\nb******\np*****r\np**a'),('disabledBBC',''),('securityDisable','0'),('cal_today_updated','20070129'),('cal_today_holiday','a:1:{s:10:\"2007-02-02\";a:1:{i:0;s:13:\"Groundhog Day\";}}'),('enableReportPM','1'),('cal_today_birthday','a:3:{s:10:\"2007-02-05\";a:1:{i:0;a:4:{s:2:\"id\";s:3:\"140\";s:4:\"name\";s:12:\"Radu Grigore\";s:3:\"age\";i:27;s:7:\"is_last\";b:1;}}s:10:\"2007-02-04\";a:1:{i:0;a:4:{s:2:\"id\";s:3:\"256\";s:4:\"name\";s:12:\"Lain Iwakura\";s:3:\"age\";i:18;s:7:\"is_last\";b:1;}}s:10:\"2007-01-31\";a:1:{i:0;a:4:{s:2:\"id\";s:3:\"670\";s:4:\"name\";s:23:\"Mierla Laurentiu Marian\";s:3:\"age\";i:19;s:7:\"is_last\";b:1;}}}'),('cal_today_event','a:1:{s:10:\"2007-01-30\";a:1:{i:0;a:9:{s:2:\"id\";s:2:\"93\";s:5:\"title\";s:28:\"SGU Petr Mitrichev Contest 2\";s:5:\"topic\";s:4:\"1472\";s:3:\"msg\";s:5:\"11677\";s:6:\"poster\";s:3:\"154\";s:10:\"start_date\";s:10:\"2007-01-30\";s:8:\"end_date\";s:10:\"2007-01-30\";s:7:\"is_last\";b:0;s:14:\"allowed_groups\";a:4:{i:0;s:2:\"-1\";i:1;s:1:\"0\";i:2;s:1:\"2\";i:3;s:2:\"20\";}}}}'),('totalMembers','5511'),('permission_enable_deny','0'),('permission_enable_postgroups','0'),('permission_enable_by_board','1'),('edit_disable_time','0'),('oldTopicDays','120'),('cal_showeventsoncalendar','1'),('cal_showbdaysoncalendar','1'),('cal_showholidaysoncalendar','1'),('attachmentThumbnails','1'),('attachmentThumbWidth','150'),('attachmentThumbHeight','150'),('max_pm_recipients','10'),('approveAccountDeletion','1'),('package_path','devnet.ro/infoarena/forum'),('chatLanguage','embedded'),('chatRoomName','roomName'),('chatWidth','700'),('chatHeight','500'),('chatAppend','_abbrv'),('chatRoomsTab','FALSE'),('chatPassword','NULL'),('chatAds','TRUE'),('chatShowUsers','TRUE'),('chatShowTop','TRUE'),('chatNumUsers','4'),('chatUsersList','wickedman_abbrv, Zitterbacke_abbrv, Gattograsso_abbrv, mercenario_abbrv'),('chatLastUpdated','1143821594'),('chatUpdateInterval','180'),('search_pointer','170'),('cal_allow_unlinked','1'),('allow_sm_stats','1230477bfc'),('karmaSmiteImage','down.gif'),('karmaImagePos','0'),('er_who','anyone'),('memberlist_updated','1166134536'),('search_force_index','1'),('search_index','fulltext'),('search_custom_index_config',''),('karmamaxmembers','10'),('karmawhatwrite','Explanation was disabled'),('karmaidmember','1');
/*!40000 ALTER TABLE `ia_smf_settings` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_smileys`
--

DROP TABLE IF EXISTS `ia_smf_smileys`;
CREATE TABLE `ia_smf_smileys` (
  `ID_SMILEY` smallint(5) unsigned NOT NULL auto_increment,
  `code` varchar(30) collate latin1_general_ci NOT NULL default '',
  `filename` varchar(48) collate latin1_general_ci NOT NULL default '',
  `description` varchar(80) collate latin1_general_ci NOT NULL default '',
  `smileyRow` tinyint(4) unsigned NOT NULL default '0',
  `smileyOrder` smallint(5) unsigned NOT NULL default '0',
  `hidden` tinyint(4) unsigned NOT NULL default '0',
  PRIMARY KEY  (`ID_SMILEY`)
) ENGINE=MyISAM AUTO_INCREMENT=288 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_smileys`
--

LOCK TABLES `ia_smf_smileys` WRITE;
/*!40000 ALTER TABLE `ia_smf_smileys` DISABLE KEYS */;
INSERT INTO `ia_smf_smileys` VALUES (151,':peacefingers:','peacefingers.gif','peacefingers',0,8,0),(94,':indifferent:','indifferent17.gif','Indifferent',1,11,0),(64,':weightlift:','weightlift.gif','Weightlift',1,4,0),(69,':aggressive:','aggressive.gif','Aggressive',2,12,2),(80,':surrender:','surrender.gif','Surrender',1,5,2),(81,':thumbdown:','thumbdown.gif','Thumb down',1,13,0),(75,':dontgetit:','dontgetit.gif','Don\'t get it',2,2,2),(101,':spiteful:','icon_spiteful.gif','Spiteful',2,9,2),(93,':fighting:','fighting25.gif','Fighting',1,17,0),(160,':readthis:','icon_readthis.gif','Read This!',0,9,0),(202,':medieval:','medieval.gif','medieval',0,7,2),(30,':twisted:','evilgrin.gif','Twisted Evil',1,7,2),(41,':neutral:','mellow.gif','Neutral',1,3,1),(82,':thumbup:','thumbsup.gif','Thumb up',1,14,0),(83,':walkman:','walkman.gif','Walkman',1,0,2),(84,':winner1:','winner_first_h4h.gif','Winner 1st place',0,18,0),(85,':winner2:','winner_second_h4h.gif','Winner 2nd place',0,19,0),(86,':winner3:','winner_third_h4h.gif','Winner 3rd place',0,20,0),(87,':yinyang:','yinyang.gif','Yinyang',2,15,2),(72,':annoyed:','annoyed.gif','Annoyed',0,16,0),(89,':cartman:','character03.gif','Cartman',0,10,2),(42,':mrgreen:','mrgreen.gif','Mr. Green',1,15,2),(76,':eyebrow:','eheyebrow.gif','Raised eyebrow',1,6,0),(95,':guitar:','guitar.gif','Guitar',1,1,2),(98,':doctor:','icon_doctor.gif','Doctor',2,7,2),(100,':tomato:','icon_tomato.gif','Tomato',1,6,2),(74,':clover:','clover.gif','Clover',2,11,2),(78,':harhar:','harhar.gif','Har har',1,12,0),(143,':boxing:','icon_boxing.gif','Boxing',0,1,2),(47,':angry:','mad2.gif','Angry',0,17,0),(79,':sleep:','sleep2.gif','Sleep',2,8,2),(49,'[-o&lt;','notworthy.gif','Pray',2,6,2),(65,':yahoo:','yahoo.gif','Yahoo!',1,9,0),(97,':dance:','icon_smile2.gif','Dance',2,16,2),(6,':smile:','smile.gif','Smile',0,3,1),(13,':shock:','w00t.gif','Shocked',0,3,0),(67,':rotfl:','rotfl.gif','Rolling on the Floor Laughing',0,15,0),(68,':alien:','alien_grn.gif','Alien',2,13,2),(38,':arrow:','arrow_2.gif','Arrow',2,14,2),(73,':bored:','boredlook.gif','Bored',1,16,2),(90,':santa:','character17.gif','Santa Claus',2,10,2),(77,':peace:','peace.gif','Peace',2,5,2),(116,':Bruce:','icon_bruce.gif','Bruce Lee',0,0,2),(155,':rambo:','rambo.gif','rambo',0,3,2),(169,':agent:','agent.gif','agent',0,4,2),(27,':oops:','newblush.gif','Embarassed',0,14,0),(63,':book:','book.gif','Book',1,4,2),(3,':grin:','biggrin.gif','Very Happy',0,1,1),(29,':evil:','devil.gif','Evil or Very Mad',1,3,0),(31,':roll:','rolleyes.gif','Rolling Eyes',0,21,0),(37,':idea:','icon_lightbulb.gif','Idea',1,14,2),(71,':nuke:','nuke.gif','Nuke',1,12,2),(56,':pimp:','icon_pimp.gif','Pimp',0,11,2),(58,':-({|=','violin.gif','Boo hoo!',0,9,2),(43,'=D&gt;','clap2.gif','Applause',1,5,0),(91,':fish:','character52.gif','Fish',0,12,2),(92,':guns:','fighting02.gif','Guns',0,13,2),(46,':flex:','flex.gif','Flex',2,3,2),(144,':bomb:','bomb.gif','bomb',0,2,2),(156,':read:','read.gif','read',1,3,2),(184,':baby:','icon_baby.gif','Baby',0,6,2),(240,':wink:','wink.gif','wink',0,11,0),(213,':puke:','puke.gif','puke',0,5,2),(286,':fool:','fool.gif','Fool',0,23,0),(96,':aha:','icon_aha.gif','Aha',0,13,0),(66,':dry:','dry.gif','Dry',2,4,2),(99,':poc:','icon_poc.gif','Poc',0,8,2),(53,'](*,)','wallbash.gif','Brick wall',1,1,0),(12,':eek:','ohmy.gif','Surprised',0,7,1),(70,':bye:','byebye.gif','Bye bye',2,17,2),(23,':mad:','mad.gif','Mad',0,13,1),(244,':sad:','sad.gif','sad',0,12,0),(88,':ok:','ok.gif','Ok',1,0,0),(61,'\\:D/','yeah.gif','Dancing',1,7,0),(284,':-(','sad.gif','Sad',0,0,1),(2,':-D','biggrin.gif','Very Happy',0,0,1),(48,'[-X','nono.gif','Shame on you',1,10,0),(5,':-)','smile.gif','Smile',0,2,1),(40,':-|','mellow.gif','Neutral',1,2,1),(50,'8-[','look_.gif','Anxious',2,1,2),(51,'[-(','closedeyes.gif','Not talking',0,14,2),(52,':-k','scratchchin.gif','Think',1,15,0),(11,':-o','ohmy.gif','Surprised',0,6,1),(35,':!:','exclamation.gif','Exclamation',1,10,2),(36,':?:','question2.gif','Question',1,11,2),(54,':-\'','whistling.gif','Whistle',1,2,0),(15,':-?','unsure.gif','Confused',0,8,1),(55,'O:)','angel.gif','Angel',1,8,2),(57,':-&','sick.gif','Sick',1,13,2),(22,':-x','mad.gif','Mad',0,12,1),(59,':-$','tie.gif','Shhh',1,2,2),(44,'#-o','ewpu.gif','d\'oh!',1,16,0),(60,':-s','huh.gif','Eh?',1,8,0),(45,'=P~','drool.gif','Drool',1,9,2),(62,':-#','censored2.gif','Silenced',1,17,2),(9,'???','huh.gif','Huh',0,7,0),(16,':\'(','cry.gif','Cry',0,10,0),(282,':-p','tongue.gif','Tongue',0,0,1),(285,';-)','wink.gif','Wink',0,0,1),(280,';)','wink.gif','Wink',0,19,1),(1,':D','biggrin.gif','Very Happy',0,0,0),(4,':)','smile.gif','Smile',0,1,0),(10,':o','ohmy.gif','Surprised',0,2,0),(14,':?','unsure.gif','Confused',0,4,0),(21,':x','mad.gif','Mad',0,5,0),(39,':|','mellow.gif','Neutral',2,0,2),(8,'8)','cool.gif','Cool',0,6,0),(281,':P','tongue.gif','Tongue',0,22,0),(283,':(','sad.gif','Sad',0,0,1),(287,':banana:','banana.gif','Banana',0,24,0);
/*!40000 ALTER TABLE `ia_smf_smileys` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_themes`
--

DROP TABLE IF EXISTS `ia_smf_themes`;
CREATE TABLE `ia_smf_themes` (
  `ID_MEMBER` mediumint(8) NOT NULL default '0',
  `ID_THEME` tinyint(4) unsigned NOT NULL default '1',
  `variable` tinytext collate latin1_general_ci NOT NULL,
  `value` text collate latin1_general_ci NOT NULL,
  PRIMARY KEY  (`ID_THEME`,`ID_MEMBER`,`variable`(30)),
  KEY `ID_MEMBER` (`ID_MEMBER`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_themes`
--

LOCK TABLES `ia_smf_themes` WRITE;
/*!40000 ALTER TABLE `ia_smf_themes` DISABLE KEYS */;
INSERT INTO `ia_smf_themes` VALUES (0,1,'name','ia2'),(0,1,'theme_url','http://infoarena.ro/forum/Themes/infoarena2'),(0,1,'images_url','http://infoarena.ro/forum/Themes/infoarena2/images'),(0,1,'theme_dir','/home/infoarena/live/smf/Themes/infoarena2'),(0,1,'show_bbc','1'),(0,1,'show_latest_member','0'),(0,1,'show_modify','1'),(0,1,'show_user_images','1'),(0,1,'show_blurb','0'),(0,1,'show_gender','0'),(0,1,'show_newsfader','0'),(0,1,'number_recent_posts','0'),(0,1,'show_member_bar','1'),(0,1,'linktree_link','1'),(0,1,'show_profile_buttons','0'),(0,1,'show_mark_read','1'),(0,1,'show_sp1_info','0'),(0,1,'linktree_inline','1'),(0,1,'show_board_desc','1'),(0,1,'newsfader_time','5000'),(0,1,'allow_no_censored','1'),(0,1,'additional_options_collapsable','1'),(0,1,'use_image_buttons','1'),(0,1,'enable_news','1'),(0,1,'display_who_viewing','2'),(0,1,'smiley_sets_default',''),(0,1,'hide_post_group','0'),(47,1,'collapse_header','0'),(47,1,'display_quick_mod','1'),(2,1,'collapse_header_ic','1'),(0,1,'display_recent_bar','0'),(0,1,'return_to_post','0'),(0,1,'header_logo_url',''),(154,1,'collapse_header','0'),(47,1,'collapse_header_ic','1'),(154,1,'show_board_desc','1'),(154,1,'show_children','1'),(154,1,'show_no_avatars','0'),(154,1,'show_no_signatures','0'),(154,1,'return_to_post','1'),(154,1,'no_new_reply_warning','0'),(154,1,'view_newest_first','0'),(154,1,'view_newest_pm_first','1'),(154,1,'calendar_start_day','1'),(154,1,'display_quick_reply','2'),(154,1,'display_quick_mod','2'),(154,1,'auto_notify','0'),(154,1,'collapse_header_ic','0'),(53,1,'show_board_desc','0'),(53,1,'show_children','0'),(53,1,'show_no_avatars','0'),(53,1,'show_no_signatures','0'),(53,1,'return_to_post','0'),(53,1,'no_new_reply_warning','0'),(53,1,'view_newest_first','0'),(53,1,'view_newest_pm_first','0'),(53,1,'calendar_start_day','1'),(53,1,'display_quick_reply','0'),(53,1,'display_quick_mod','0'),(53,1,'collapse_header','0'),(520,1,'show_board_desc','0'),(520,1,'show_children','0'),(520,1,'show_no_avatars','0'),(520,1,'show_no_signatures','0'),(520,1,'return_to_post','0'),(520,1,'no_new_reply_warning','0'),(520,1,'view_newest_first','0'),(520,1,'view_newest_pm_first','0'),(520,1,'calendar_start_day','1'),(520,1,'display_quick_reply','0'),(520,1,'display_quick_mod','0'),(308,1,'copy_to_outbox','1'),(308,1,'popup_messages','0'),(370,1,'show_board_desc','0'),(370,1,'show_children','0'),(370,1,'show_no_avatars','0'),(370,1,'show_no_signatures','0'),(370,1,'return_to_post','0'),(370,1,'no_new_reply_warning','0'),(370,1,'view_newest_first','0'),(370,1,'view_newest_pm_first','0'),(370,1,'calendar_start_day','1'),(370,1,'display_quick_reply','0'),(370,1,'display_quick_mod','0'),(132,1,'collapse_header','0'),(10,1,'show_board_desc','1'),(10,1,'show_children','0'),(10,1,'show_no_avatars','0'),(10,1,'show_no_signatures','0'),(10,1,'return_to_post','1'),(10,1,'no_new_reply_warning','0'),(10,1,'view_newest_first','0'),(10,1,'view_newest_pm_first','0'),(10,1,'calendar_start_day','1'),(10,1,'display_quick_reply','1'),(10,1,'display_quick_mod','2'),(10,1,'auto_notify','1'),(520,1,'collapse_header','0'),(520,1,'collapse_header_ic','0'),(10,1,'collapse_header_ic','0'),(10,1,'collapse_header','0'),(10,1,'copy_to_outbox','1'),(10,1,'popup_messages','0'),(69,1,'show_board_desc','0'),(69,1,'show_children','0'),(69,1,'show_no_avatars','0'),(69,1,'show_no_signatures','0'),(69,1,'return_to_post','0'),(69,1,'no_new_reply_warning','0'),(69,1,'view_newest_first','0'),(69,1,'view_newest_pm_first','0'),(69,1,'calendar_start_day','0'),(69,1,'display_quick_reply','0'),(69,1,'display_quick_mod','0'),(308,1,'collapse_header','0'),(530,1,'auto_notify','0'),(530,1,'copy_to_outbox','0'),(530,1,'popup_messages','0'),(441,1,'collapse_header','0'),(553,1,'show_board_desc','0'),(553,1,'show_children','0'),(553,1,'show_no_avatars','0'),(553,1,'show_no_signatures','0'),(553,1,'return_to_post','0'),(553,1,'no_new_reply_warning','0'),(553,1,'view_newest_first','0'),(553,1,'view_newest_pm_first','0'),(553,1,'calendar_start_day','1'),(553,1,'display_quick_reply','0'),(553,1,'display_quick_mod','0'),(441,1,'copy_to_outbox','1'),(441,1,'popup_messages','0'),(86,1,'show_board_desc','0'),(86,1,'show_children','0'),(86,1,'show_no_avatars','0'),(86,1,'show_no_signatures','0'),(86,1,'return_to_post','0'),(86,1,'no_new_reply_warning','0'),(86,1,'view_newest_first','0'),(86,1,'view_newest_pm_first','0'),(86,1,'calendar_start_day','1'),(86,1,'display_quick_reply','2'),(86,1,'display_quick_mod','0'),(39,1,'show_board_desc','0'),(39,1,'show_children','0'),(39,1,'show_no_avatars','0'),(39,1,'show_no_signatures','0'),(39,1,'return_to_post','1'),(39,1,'no_new_reply_warning','0'),(39,1,'view_newest_first','0'),(39,1,'view_newest_pm_first','0'),(39,1,'calendar_start_day','1'),(39,1,'display_quick_reply','0'),(39,1,'display_quick_mod','0'),(39,1,'auto_notify','0'),(152,1,'show_board_desc','0'),(152,1,'show_children','0'),(152,1,'show_no_avatars','0'),(152,1,'show_no_signatures','0'),(152,1,'return_to_post','0'),(152,1,'no_new_reply_warning','0'),(152,1,'view_newest_first','0'),(152,1,'view_newest_pm_first','0'),(152,1,'calendar_start_day','1'),(152,1,'display_quick_reply','0'),(152,1,'display_quick_mod','0'),(615,1,'show_board_desc','1'),(615,1,'show_children','0'),(615,1,'show_no_avatars','0'),(615,1,'show_no_signatures','0'),(615,1,'return_to_post','1'),(615,1,'no_new_reply_warning','0'),(615,1,'view_newest_first','1'),(615,1,'view_newest_pm_first','1'),(615,1,'calendar_start_day','1'),(615,1,'display_quick_reply','2'),(615,1,'display_quick_mod','0'),(615,1,'auto_notify','0'),(615,1,'copy_to_outbox','1'),(615,1,'popup_messages','1'),(495,1,'show_board_desc','0'),(495,1,'show_children','0'),(495,1,'show_no_avatars','0'),(495,1,'show_no_signatures','0'),(495,1,'return_to_post','0'),(495,1,'no_new_reply_warning','0'),(495,1,'view_newest_first','0'),(495,1,'view_newest_pm_first','0'),(495,1,'calendar_start_day','1'),(495,1,'display_quick_reply','1'),(495,1,'display_quick_mod','0'),(250,1,'auto_notify','0'),(250,1,'copy_to_outbox','0'),(250,1,'popup_messages','0'),(451,1,'collapse_header_ic','0'),(606,1,'copy_to_outbox','0'),(606,1,'popup_messages','0'),(608,1,'show_board_desc','1'),(608,1,'show_children','1'),(608,1,'show_no_avatars','0'),(608,1,'show_no_signatures','0'),(608,1,'return_to_post','1'),(608,1,'no_new_reply_warning','0'),(608,1,'view_newest_first','1'),(608,1,'view_newest_pm_first','1'),(608,1,'calendar_start_day','0'),(608,1,'display_quick_reply','0'),(608,1,'display_quick_mod','0'),(343,1,'show_board_desc','0'),(343,1,'show_children','0'),(343,1,'show_no_avatars','0'),(343,1,'show_no_signatures','0'),(343,1,'return_to_post','1'),(343,1,'no_new_reply_warning','0'),(343,1,'view_newest_first','0'),(343,1,'view_newest_pm_first','0'),(343,1,'calendar_start_day','1'),(343,1,'display_quick_reply','0'),(343,1,'display_quick_mod','0'),(343,1,'auto_notify','0'),(343,1,'copy_to_outbox','0'),(343,1,'popup_messages','1'),(451,1,'collapse_header','0'),(3,1,'collapse_header','0'),(574,1,'copy_to_outbox','0'),(574,1,'popup_messages','0'),(620,1,'collapse_header','0'),(177,1,'auto_notify','0'),(177,1,'copy_to_outbox','0'),(177,1,'popup_messages','0'),(121,1,'collapse_header','0'),(3,1,'collapse_header_ic','0'),(55,1,'show_board_desc','0'),(55,1,'show_children','0'),(55,1,'show_no_avatars','0'),(55,1,'show_no_signatures','0'),(55,1,'return_to_post','0'),(55,1,'no_new_reply_warning','0'),(55,1,'view_newest_first','0'),(55,1,'view_newest_pm_first','0'),(55,1,'calendar_start_day','1'),(55,1,'display_quick_reply','0'),(55,1,'display_quick_mod','0'),(587,1,'show_board_desc','0'),(587,1,'show_children','0'),(587,1,'show_no_avatars','0'),(587,1,'show_no_signatures','0'),(587,1,'return_to_post','0'),(587,1,'no_new_reply_warning','0'),(587,1,'view_newest_first','0'),(587,1,'view_newest_pm_first','0'),(587,1,'calendar_start_day','1'),(587,1,'display_quick_reply','0'),(587,1,'display_quick_mod','0'),(664,1,'show_board_desc','0'),(664,1,'show_children','0'),(664,1,'show_no_avatars','0'),(664,1,'show_no_signatures','0'),(664,1,'return_to_post','0'),(664,1,'no_new_reply_warning','0'),(664,1,'view_newest_first','1'),(664,1,'view_newest_pm_first','1'),(664,1,'calendar_start_day','1'),(664,1,'display_quick_reply','0'),(664,1,'display_quick_mod','0'),(394,1,'collapse_header','0'),(0,1,'spoiler_tag','0'),(371,1,'collapse_header_ic','0'),(652,1,'show_board_desc','0'),(652,1,'show_children','0'),(652,1,'show_no_avatars','0'),(652,1,'show_no_signatures','0'),(652,1,'show_no_censored','0'),(652,1,'return_to_post','0'),(652,1,'no_new_reply_warning','0'),(652,1,'view_newest_first','1'),(652,1,'view_newest_pm_first','0'),(652,1,'calendar_start_day','1'),(652,1,'display_quick_reply','0'),(652,1,'display_quick_mod','0'),(454,1,'collapse_header','0'),(505,1,'show_board_desc','0'),(505,1,'show_children','0'),(505,1,'show_no_avatars','0'),(505,1,'show_no_signatures','0'),(505,1,'show_no_censored','0'),(505,1,'return_to_post','0'),(505,1,'no_new_reply_warning','0'),(505,1,'view_newest_first','0'),(505,1,'view_newest_pm_first','1'),(505,1,'calendar_start_day','0'),(505,1,'display_quick_reply','0'),(505,1,'display_quick_mod','0'),(159,1,'auto_notify','0'),(662,1,'show_board_desc','0'),(662,1,'show_children','0'),(662,1,'show_no_avatars','0'),(662,1,'show_no_signatures','0'),(662,1,'show_no_censored','0'),(662,1,'return_to_post','0'),(662,1,'no_new_reply_warning','0'),(662,1,'view_newest_first','0'),(662,1,'view_newest_pm_first','0'),(662,1,'calendar_start_day','0'),(662,1,'display_quick_reply','0'),(662,1,'display_quick_mod','0'),(662,1,'copy_to_outbox','1'),(662,1,'popup_messages','1'),(516,1,'collapse_header','0'),(312,1,'collapse_header','0'),(454,1,'collapse_header_ic','0'),(516,1,'copy_to_outbox','1'),(516,1,'popup_messages','1'),(394,1,'auto_notify','0'),(394,1,'collapse_header_ic','0'),(451,1,'show_board_desc','0'),(451,1,'show_children','0'),(451,1,'show_no_avatars','0'),(451,1,'show_no_signatures','0'),(451,1,'show_no_censored','0'),(451,1,'return_to_post','0'),(451,1,'no_new_reply_warning','0'),(451,1,'view_newest_first','0'),(451,1,'view_newest_pm_first','0'),(451,1,'calendar_start_day','1'),(451,1,'display_quick_reply','0'),(451,1,'display_quick_mod','0'),(103,1,'collapse_header','0'),(662,1,'collapse_header','0'),(159,1,'copy_to_outbox','0'),(159,1,'popup_messages','0'),(714,1,'show_board_desc','0'),(714,1,'show_children','0'),(714,1,'show_no_avatars','0'),(714,1,'show_no_signatures','0'),(714,1,'show_no_censored','1'),(714,1,'return_to_post','1'),(714,1,'no_new_reply_warning','0'),(714,1,'view_newest_first','0'),(714,1,'view_newest_pm_first','0'),(714,1,'calendar_start_day','1'),(714,1,'display_quick_reply','2'),(714,1,'display_quick_mod','0'),(714,1,'copy_to_outbox','1'),(714,1,'popup_messages','1'),(440,1,'collapse_header','0'),(611,1,'collapse_header','0'),(262,1,'show_board_desc','1'),(262,1,'show_children','0'),(262,1,'show_no_avatars','0'),(262,1,'show_no_signatures','0'),(262,1,'show_no_censored','1'),(262,1,'return_to_post','0'),(262,1,'no_new_reply_warning','0'),(262,1,'view_newest_first','0'),(262,1,'view_newest_pm_first','0'),(262,1,'calendar_start_day','0'),(262,1,'display_quick_reply','0'),(262,1,'display_quick_mod','0'),(654,1,'collapse_header','0'),(3354,1,'collapse_header_ic','0'),(412,1,'collapse_header_ic','0'),(495,1,'collapse_header_ic','0'),(775,1,'collapse_header_ic','1'),(5343,1,'collapse_header_ic','0');
/*!40000 ALTER TABLE `ia_smf_themes` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_smf_topics`
--

DROP TABLE IF EXISTS `ia_smf_topics`;
CREATE TABLE `ia_smf_topics` (
  `ID_TOPIC` mediumint(8) unsigned NOT NULL auto_increment,
  `isSticky` tinyint(4) NOT NULL default '0',
  `ID_BOARD` smallint(5) unsigned NOT NULL default '0',
  `ID_FIRST_MSG` int(10) unsigned NOT NULL default '0',
  `ID_LAST_MSG` int(10) unsigned NOT NULL default '0',
  `ID_MEMBER_STARTED` mediumint(8) unsigned NOT NULL default '0',
  `ID_MEMBER_UPDATED` mediumint(8) unsigned NOT NULL default '0',
  `ID_POLL` mediumint(8) unsigned NOT NULL default '0',
  `numReplies` int(10) unsigned NOT NULL default '0',
  `numViews` int(10) unsigned NOT NULL default '0',
  `locked` tinyint(4) NOT NULL default '0',
  PRIMARY KEY  (`ID_TOPIC`),
  UNIQUE KEY `poll` (`ID_POLL`,`ID_TOPIC`),
  UNIQUE KEY `firstMessage` (`ID_FIRST_MSG`,`ID_BOARD`),
  UNIQUE KEY `lastMessage` (`ID_LAST_MSG`,`ID_BOARD`),
  KEY `isSticky` (`isSticky`),
  KEY `ID_BOARD` (`ID_BOARD`)
) ENGINE=MyISAM AUTO_INCREMENT=1500 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_smf_topics`
--

LOCK TABLES `ia_smf_topics` WRITE;
/*!40000 ALTER TABLE `ia_smf_topics` DISABLE KEYS */;
INSERT INTO `ia_smf_topics` VALUES (8,0,3,9,21,3,26,1,5,573,0),(9,0,3,10,464,10,47,0,18,1186,0),(37,0,1,97,11300,2,454,0,61,3807,0),(35,0,1,95,10832,2,767,0,63,3757,0),(36,0,1,96,10702,2,710,0,52,3929,0),(40,0,1,100,9043,2,454,0,20,988,0),(11,0,3,14,81,0,47,0,2,415,0),(38,0,1,98,9029,2,79,0,35,2617,0),(34,0,1,94,10802,2,412,0,68,3983,0),(14,0,4,29,706,26,6,0,16,1110,0),(15,0,3,30,175,24,40,0,5,382,0),(16,0,4,31,1705,0,156,0,5,355,0),(33,0,1,93,10334,2,10,0,109,5065,1),(18,0,4,35,65,0,0,0,2,273,0),(19,0,3,36,115,30,46,0,23,1269,0),(20,0,3,58,150,0,47,0,3,387,0),(32,0,1,92,11838,2,4882,0,52,2409,0),(22,0,4,72,112,41,41,0,7,415,0),(23,0,4,77,529,0,69,0,8,431,0),(24,0,3,79,165,13,10,0,4,304,0),(39,0,1,99,8337,2,0,0,24,1468,0),(27,0,1,87,5259,2,520,0,28,1911,0),(28,0,1,88,11157,2,5643,0,8,531,0),(29,0,1,89,11715,2,4605,0,44,3193,0),(30,0,1,90,8876,2,0,0,38,2001,0),(31,0,1,91,5279,2,375,0,12,995,0),(41,0,1,101,11194,2,662,0,37,2104,0),(42,0,1,102,7911,2,154,0,25,1440,0),(43,0,1,103,3878,2,154,0,25,1236,0),(44,0,1,104,5902,2,545,0,18,1387,0),(45,0,1,105,5152,2,103,0,36,2026,0),(46,0,1,106,10167,2,3,0,30,1339,0),(47,0,1,107,7658,2,454,0,13,736,0),(48,0,1,108,11540,2,4792,0,24,1186,0),(49,0,1,109,6916,2,0,0,29,1623,0),(50,0,3,116,1852,13,0,0,20,895,0),(51,0,3,118,160,41,2,0,8,487,0),(52,0,3,120,121,13,3,0,1,249,0),(53,0,3,125,435,52,52,2,8,600,0),(55,0,4,142,142,57,57,0,0,169,0),(56,0,4,153,161,47,2,0,1,182,0),(57,0,3,170,187,0,3,0,3,343,0),(58,0,3,178,266,64,30,0,6,374,0),(59,0,3,183,205,0,10,0,3,343,0),(60,0,4,184,210,0,40,0,8,458,0),(108,0,4,440,442,103,47,0,1,198,0),(62,0,4,203,204,0,0,0,1,158,0),(63,0,4,206,217,40,40,0,5,331,0),(64,0,3,213,711,51,11,0,10,594,0),(65,0,4,223,247,3,3,0,13,1021,1),(85,0,1,378,11552,2,412,0,38,1647,0),(67,1,4,226,8168,3,606,0,51,5063,0),(68,0,4,262,264,40,3,0,1,159,0),(69,0,4,273,327,3,3,0,33,1065,1),(70,0,4,274,322,3,69,0,13,741,1),(71,0,4,296,452,40,103,0,4,312,0),(72,0,3,339,517,91,47,0,15,833,0),(73,0,4,352,2134,47,0,4,3,473,0),(74,0,4,359,489,2,69,5,3,382,0),(107,0,3,433,436,38,27,0,1,246,0),(76,0,4,366,652,13,3,6,9,681,1),(77,0,4,370,3237,0,47,0,6,411,0),(78,0,3,374,401,43,43,0,2,276,0),(111,0,3,480,480,109,109,0,0,147,0),(113,0,3,483,492,0,13,0,2,270,0),(115,0,3,493,538,77,119,0,2,235,0),(114,0,4,484,484,112,112,0,0,238,0),(84,0,1,377,3863,2,460,0,11,736,1),(86,0,1,379,9046,2,662,0,29,1598,0),(87,0,1,380,11325,2,505,0,35,1729,0),(88,0,1,381,5529,2,79,0,39,2555,0),(89,0,1,382,6177,2,0,0,27,1242,0),(90,0,1,383,9829,2,257,0,4,551,0),(91,0,1,384,8686,2,558,0,25,1275,0),(92,0,1,385,7909,2,496,0,19,1937,0),(93,0,1,386,7714,2,257,0,21,1040,0),(94,0,1,387,10194,2,531,0,19,1263,0),(95,0,1,388,11221,2,749,0,3,354,0),(96,0,1,389,9073,2,454,0,12,694,0),(97,0,1,390,7637,2,0,0,58,2040,0),(98,0,1,391,10923,2,606,0,11,691,0),(99,0,1,392,2150,2,322,0,7,477,0),(102,0,3,410,425,26,47,0,3,321,0),(110,0,4,471,475,103,47,0,2,214,0),(103,0,4,415,418,98,98,0,1,177,0),(104,0,4,416,3236,98,0,0,4,357,0),(105,0,4,419,423,27,0,0,2,243,0),(112,0,3,481,482,109,47,0,1,194,0),(116,0,4,511,511,0,0,0,0,177,0),(117,0,3,514,515,0,43,0,1,212,0),(118,0,4,518,525,0,69,0,3,289,0),(119,0,11,526,526,47,47,0,0,478,1),(120,0,6,527,7915,47,0,0,21,1742,0),(121,0,11,530,531,0,69,0,1,257,0),(122,0,11,533,535,10,47,0,2,199,0),(123,0,11,536,728,10,10,0,4,286,0),(124,0,3,539,1013,103,100,0,5,335,0),(125,0,9,544,612,47,69,0,15,811,1),(126,0,9,545,614,47,69,0,29,996,1),(127,0,9,615,645,69,3,7,8,389,1),(128,0,9,616,653,69,136,8,8,461,1),(129,0,9,625,722,132,3,0,14,732,1),(130,0,5,635,643,6,69,0,2,432,0),(131,0,11,648,661,97,60,0,2,195,0),(132,0,11,649,651,0,0,0,1,158,1),(133,0,11,656,1381,137,285,0,5,384,0),(134,0,3,659,683,0,47,0,6,380,0),(135,0,3,662,1245,11,156,0,6,348,0),(136,0,1,666,9277,3,505,0,20,936,0),(137,0,1,667,10963,3,0,0,9,570,0),(138,0,1,668,3579,3,27,0,4,380,0),(139,0,1,669,5935,3,103,0,8,640,0),(140,0,1,670,6296,3,154,0,16,638,0),(141,0,1,671,671,3,3,0,0,190,0),(142,0,4,672,686,0,20,0,1,187,0),(143,0,5,674,676,119,3,0,1,401,0),(144,1,12,682,682,2,2,0,0,79,0),(145,0,12,694,774,3,47,0,6,66,0),(146,0,12,695,710,6,6,0,4,35,0),(147,0,5,698,699,13,47,0,1,306,0),(148,0,3,704,2912,132,0,0,61,2199,0),(149,0,11,705,712,6,11,0,2,270,0),(150,0,5,709,3801,139,375,0,4,738,0),(151,0,5,716,742,140,27,9,6,665,0),(152,0,12,717,753,2,3,0,4,43,0),(153,0,12,730,731,2,47,0,1,23,0),(154,0,3,743,2217,0,47,0,31,1085,0),(155,0,12,744,754,27,140,0,3,37,0),(156,0,3,749,977,103,66,0,2,246,0),(157,0,3,750,805,0,0,0,10,481,0),(158,0,11,756,763,10,10,0,2,201,0),(159,0,11,759,3523,125,132,0,17,902,0),(160,0,3,766,792,0,140,0,5,270,0),(161,0,3,780,781,103,125,0,1,142,0),(162,0,3,783,814,103,0,0,2,217,0),(163,0,3,795,799,147,47,0,1,219,0),(164,0,11,800,801,132,3,0,1,215,0),(165,0,3,802,907,0,10,0,25,940,0),(166,0,3,808,7988,66,0,0,3,473,0),(167,0,11,815,815,46,46,0,0,177,0),(168,0,3,816,857,27,27,0,7,278,0),(169,0,11,831,832,140,47,0,1,195,0),(170,0,3,833,845,47,69,0,3,175,0),(171,0,3,874,897,140,10,0,11,414,0),(172,0,4,881,881,140,140,0,0,133,0),(173,0,4,882,882,140,140,0,0,185,0),(174,0,9,891,955,2,3,0,6,373,1),(175,0,9,892,944,2,3,0,15,544,1),(176,0,9,893,958,2,3,0,7,355,1),(177,0,9,894,894,2,2,0,0,178,1),(178,0,9,895,956,2,3,0,16,580,1),(179,0,9,896,953,2,3,0,4,299,1),(180,0,11,900,902,156,47,0,1,172,0),(181,0,11,905,905,10,10,0,0,159,0),(182,0,3,908,1578,27,220,0,3,306,0),(183,0,9,939,940,0,3,0,1,141,0),(188,0,1,979,1050,0,0,0,5,333,1),(185,0,9,960,960,27,27,0,0,162,1),(186,0,9,961,972,0,69,0,1,155,0),(187,0,9,962,985,103,103,10,15,538,0),(190,0,3,991,993,0,10,11,2,153,0),(191,0,1,996,1004,168,168,0,2,282,1),(192,0,9,1017,1382,69,10,0,21,600,0),(193,0,3,1044,2967,153,0,0,25,895,0),(194,0,3,1054,1070,0,10,0,5,206,0),(195,0,1,1081,1084,60,60,0,2,256,1),(1120,0,3,8709,8813,658,3,0,5,265,0),(197,0,5,1109,1223,0,3,0,6,523,0),(198,0,3,1114,1114,27,27,0,0,146,0),(199,0,1,1125,1128,106,106,0,2,199,1),(200,0,9,1132,1133,0,69,0,1,124,0),(201,0,3,1135,3825,96,462,0,10,493,0),(202,0,3,1137,1164,154,154,0,8,251,0),(203,0,5,1157,1158,60,3,0,1,269,0),(207,0,1,1171,1172,187,3,0,1,181,1),(205,0,1,1162,1192,177,3,0,1,253,1),(206,0,3,1163,1224,154,3,0,13,453,0),(208,0,1,1176,1181,189,3,0,1,168,1),(239,0,9,1370,1406,0,47,0,4,203,0),(240,0,1,1369,8925,273,412,0,27,955,0),(211,0,9,1205,1344,154,26,0,19,626,0),(212,0,1,1206,6103,3,505,0,24,1207,0),(213,0,1,1207,1360,210,55,0,9,477,1),(214,0,1,1210,11426,3,5779,0,36,1611,0),(215,0,1,1213,8667,3,558,0,34,1157,0),(216,0,1,1214,3927,3,25,0,4,287,0),(217,0,1,1215,9097,3,505,0,42,1449,0),(218,0,1,1216,8884,3,587,0,15,649,0),(219,0,1,1220,6147,3,27,0,1,688,0),(220,0,3,1230,1248,156,43,0,4,182,0),(221,0,9,1236,1318,3,3,0,15,453,1),(222,0,9,1237,1328,3,3,0,6,269,1),(223,0,9,1238,1336,3,0,0,8,305,1),(224,0,9,1239,1321,3,239,0,5,307,1),(225,0,9,1240,1329,3,69,0,10,360,1),(226,0,9,1241,1337,3,3,0,18,665,1),(227,0,3,1243,1573,220,220,0,4,217,0),(228,0,9,1279,1281,201,153,0,1,117,0),(245,0,1,1377,4273,3,79,0,6,332,0),(230,0,9,1323,1323,3,3,0,0,328,0),(231,0,9,1338,1350,201,154,0,7,262,0),(238,0,9,1365,1485,3,154,0,5,676,0),(244,0,1,1376,3408,3,0,0,18,705,0),(243,0,1,1375,7742,3,27,0,13,500,0),(242,0,1,1374,7761,3,257,0,8,445,0),(236,0,5,1356,1411,0,27,0,3,484,0),(241,0,1,1373,10949,3,569,0,13,531,0),(246,0,9,1393,1412,0,0,0,4,189,0),(247,0,3,1404,1407,292,3,0,1,169,0),(248,0,11,1417,1708,154,154,0,4,232,0),(249,0,9,1420,3255,26,0,0,22,903,0),(250,0,3,1443,2496,292,332,0,13,472,0),(251,0,3,1455,1481,292,156,0,7,320,0),(252,0,11,1457,1477,292,47,0,4,254,0),(253,0,4,1459,1461,292,0,0,1,218,0),(254,0,9,1489,1789,0,27,0,32,1391,0),(255,0,9,1490,1490,140,140,0,0,115,0),(256,0,11,1511,3740,0,0,0,8,492,0),(257,0,5,1512,1524,70,292,0,4,339,0),(258,0,9,1525,1536,292,292,0,2,274,0),(259,0,3,1530,1532,43,3,0,1,122,0),(260,0,4,1534,1663,155,156,0,2,183,0),(261,0,11,1547,1547,201,201,0,0,124,0),(262,0,3,1574,1587,156,156,0,3,183,0),(263,0,13,1584,1584,3,3,0,0,37,0),(264,0,13,1585,1634,3,3,0,5,125,0),(265,0,13,1600,1646,3,3,0,7,91,0),(266,1,13,1603,2246,3,3,0,4,124,0),(267,1,4,1615,11283,0,461,0,8,1149,0),(268,0,9,1619,1620,70,3,0,1,178,0),(269,0,13,1632,1691,3,27,0,7,73,0),(270,0,9,1640,2048,103,43,0,5,276,0),(271,0,13,1647,1750,3,3,0,12,124,0),(272,1,13,1648,1881,3,0,0,12,105,0),(273,0,3,1653,1931,322,278,0,17,468,0),(274,0,9,1686,1817,103,47,0,4,279,0),(275,0,13,1693,1848,3,3,0,14,147,0),(276,0,11,1700,1814,0,47,0,8,279,0),(277,0,9,1737,1737,311,311,0,0,167,0),(278,0,9,1747,2186,11,27,0,20,642,0),(279,0,13,1758,1934,27,27,0,33,232,0),(280,0,9,1795,1987,0,156,0,16,559,0),(281,0,3,1802,5261,328,489,0,40,2487,0),(282,0,3,1809,1961,232,20,0,12,277,0),(283,0,13,1821,1827,132,3,0,2,33,0),(284,0,13,1847,2033,3,3,0,12,132,0),(285,0,9,1857,3210,0,0,0,15,644,0),(286,0,3,1879,2445,0,156,0,14,380,0),(287,0,13,1895,1914,3,3,0,5,70,0),(288,0,9,1903,2358,132,106,0,29,866,0),(289,0,13,1935,2257,27,130,0,11,103,0),(290,0,11,1948,2478,154,47,0,6,264,0),(291,0,11,1986,2216,250,250,0,5,233,0),(292,0,13,2001,2214,27,27,0,17,115,0),(293,0,3,2005,7169,320,154,0,42,2214,0),(294,0,9,2013,2051,3,10,0,3,336,1),(295,0,9,2014,2100,3,153,0,10,522,1),(296,0,9,2015,2092,3,3,0,4,293,1),(297,0,9,2016,2084,3,69,0,11,504,1),(298,0,9,2017,2086,3,69,0,14,522,1),(299,0,9,2018,2018,3,3,0,0,156,1),(300,0,9,2101,2173,47,69,0,10,449,0),(301,0,9,2102,2105,0,308,0,1,164,0),(302,0,14,2103,2312,47,0,12,1,377,0),(303,0,1,2106,4703,3,3,0,6,359,0),(304,0,1,2107,11253,3,1490,0,3,282,0),(305,0,1,2108,3319,3,132,0,4,301,0),(306,0,1,2109,10821,3,256,0,37,1495,0),(307,0,1,2111,2938,3,69,0,5,325,0),(308,0,1,2112,10505,3,27,0,41,1464,0),(309,0,14,2117,2178,3,47,13,2,376,0),(310,0,14,2118,2183,3,156,14,3,328,0),(311,0,14,2119,2193,3,156,15,6,434,0),(312,0,14,2122,2122,3,3,16,0,254,0),(313,0,14,2124,2124,3,3,17,0,220,0),(314,0,14,2126,2132,3,69,18,2,361,0),(315,0,14,2127,8809,3,79,0,14,650,0),(316,0,3,2140,2151,0,0,0,8,214,0),(317,0,5,2153,2154,154,3,0,1,251,0),(318,0,11,2162,2169,345,345,0,2,199,0),(319,0,11,2163,2469,0,26,0,6,299,0),(320,0,13,2197,2235,3,3,0,5,63,0),(321,0,14,2199,2348,27,106,0,11,572,0),(322,0,11,2218,2265,10,10,0,3,206,0),(323,0,11,2252,2986,96,47,0,19,703,0),(325,0,11,2266,2600,10,106,0,4,260,0),(326,0,4,2267,2314,10,47,0,4,224,0),(327,0,13,2290,2305,3,6,0,5,78,0),(328,0,11,2355,2357,79,27,0,1,160,0),(329,0,4,2389,2437,352,27,19,23,751,1),(330,0,4,2402,2408,0,47,0,3,169,0),(331,0,9,2415,2432,26,26,0,3,258,0),(442,0,3,3479,3662,60,60,0,4,247,0),(333,0,9,2430,2448,156,10,0,8,434,0),(334,0,11,2440,2990,291,6,0,3,270,0),(441,0,3,3438,3503,132,0,0,16,553,0),(336,0,4,2446,2446,156,156,0,0,146,0),(337,0,4,2447,2591,0,0,0,2,218,0),(338,0,9,2450,2450,0,0,0,0,234,0),(339,0,3,2451,3800,0,3,0,4,317,0),(341,0,3,2455,2467,0,26,0,3,176,0),(342,0,3,2461,2466,0,26,0,3,228,0),(343,0,3,2476,2481,0,27,0,3,227,0),(344,0,4,2486,5189,332,0,0,15,586,0),(345,0,3,2491,2762,96,47,0,5,272,0),(346,0,11,2489,4974,220,0,0,71,2442,0),(347,0,11,2501,2510,155,47,0,2,167,0),(348,0,3,1467,2484,292,27,0,7,216,0),(349,0,11,1912,1912,155,155,0,0,101,0),(350,0,4,2529,8194,17,17,0,9,631,0),(351,0,11,2533,2539,332,3,0,2,192,0),(353,0,4,2589,3188,156,140,0,2,211,0),(354,0,4,2592,2592,140,140,0,0,121,0),(355,0,3,2609,2627,0,0,0,17,478,0),(356,0,4,2634,9996,46,0,0,28,1250,0),(357,0,4,2659,8225,3,332,0,9,759,0),(358,0,11,2661,2690,0,47,0,4,224,0),(359,0,15,2685,10740,3,394,0,23,1578,0),(360,0,15,2686,10735,3,432,0,10,711,0),(361,0,16,2687,5286,3,452,0,10,924,0),(362,0,16,2688,2805,3,47,0,8,801,0),(363,0,11,2696,2703,0,47,0,2,153,0),(364,1,1,2697,10958,3,454,0,3,1150,0),(365,1,15,2698,2698,3,3,0,0,334,0),(366,1,16,2700,2774,3,203,0,1,313,0),(367,0,11,2705,2719,43,0,0,3,219,0),(368,0,11,2726,2726,10,10,0,0,124,0),(369,0,5,2771,8339,0,69,0,14,917,0),(370,0,4,2780,2780,399,399,0,0,133,0),(371,0,12,2781,4337,0,0,0,16,197,0),(373,0,14,2798,2798,47,47,20,0,386,0),(374,0,3,2811,2811,0,0,0,0,148,0),(375,0,3,2817,2857,0,0,0,14,433,0),(431,0,6,3303,7930,0,547,0,1,433,0),(377,0,4,2837,2866,332,332,0,14,532,0),(378,0,3,2862,2863,60,47,0,1,172,0),(379,0,3,2911,3003,153,20,0,4,271,0),(380,0,4,2913,2913,140,140,0,0,166,0),(381,0,11,2933,2933,428,428,0,0,132,0),(382,0,4,2936,2997,0,395,0,7,659,0),(383,0,1,2940,4543,3,370,0,19,663,0),(384,0,1,2941,8571,3,558,0,21,758,0),(385,0,1,2942,5467,3,0,0,1,159,0),(386,0,1,2943,5112,3,460,0,6,273,0),(387,0,1,2944,7540,3,520,0,27,627,0),(388,0,1,2945,3923,3,43,0,4,228,0),(389,0,1,2946,6476,3,463,0,13,577,0),(390,0,1,2947,2947,3,3,0,0,89,0),(391,0,15,2949,10736,3,432,0,5,519,0),(392,0,15,2950,10737,3,432,0,10,724,0),(393,0,15,2951,3168,3,257,0,1,368,0),(521,0,18,3895,3895,3,3,0,0,14,0),(395,0,6,2979,2988,0,0,0,4,521,0),(396,0,1,2998,8896,3,454,0,29,1049,0),(398,0,1,3007,3007,3,3,0,0,103,0),(399,0,4,3017,3069,0,332,0,1,179,0),(400,1,3,3019,3056,27,140,0,19,1624,0),(605,0,19,4397,5640,43,27,0,20,106,1),(403,0,1,3045,7108,3,370,0,7,352,0),(404,0,11,3064,3229,79,47,0,10,383,0),(405,0,14,3080,3250,69,0,22,4,464,0),(407,0,4,3089,3101,0,47,0,4,248,0),(408,0,4,3091,3119,46,10,0,6,345,0),(409,0,4,3093,3105,328,328,0,3,183,0),(411,0,6,3154,3159,96,96,0,2,339,0),(412,0,11,3191,3191,47,47,0,0,207,0),(413,0,4,3201,3329,10,0,0,8,419,0),(414,0,9,3207,3271,0,27,0,25,1038,1),(415,0,4,3232,7757,332,547,0,12,639,0),(416,0,1,3242,10827,3,0,0,22,701,0),(417,0,1,3243,10850,3,394,0,8,370,0),(418,0,1,3244,3244,3,3,0,0,108,0),(419,0,1,3245,4566,3,79,0,4,237,0),(420,0,1,3246,10922,3,236,0,4,310,0),(421,0,1,3247,7459,3,37,0,26,890,0),(422,0,9,3256,3256,0,0,0,0,184,0),(423,0,1,3263,9198,3,370,0,10,448,0),(424,0,1,3264,5985,3,394,0,1,179,0),(425,0,1,3265,4464,3,0,0,3,200,0),(426,0,1,3266,6107,3,79,0,20,733,0),(427,0,1,3267,7716,3,3,0,3,291,0),(428,0,1,3268,3268,3,3,0,0,124,0),(429,0,4,3269,5925,332,370,0,3,262,0),(430,0,3,3272,3321,0,27,0,5,350,0),(432,0,11,3322,3327,445,3,0,5,231,0),(434,0,11,3330,3337,445,10,0,3,191,0),(439,0,11,3371,3373,79,0,0,1,171,0),(438,0,11,3353,3378,0,47,0,6,286,0),(440,0,3,3382,3383,0,27,0,1,329,0),(443,0,11,3484,3485,0,47,0,1,167,0),(444,0,9,3489,3489,69,69,0,0,217,0),(445,0,9,3496,3499,79,43,0,3,306,0),(446,0,11,3515,7126,10,10,0,3,261,0),(447,0,3,3520,3537,153,43,0,7,337,0),(450,0,14,3530,3597,3,10,0,7,473,0),(452,0,1,3540,11313,3,505,0,12,578,0),(453,0,1,3542,6035,3,0,0,2,188,0),(454,0,1,3545,3549,3,3,0,2,148,0),(455,0,1,3548,6520,3,0,0,2,156,0),(456,0,1,3550,8569,3,121,0,8,363,0),(457,0,6,3558,4270,0,47,0,8,713,0),(458,0,1,3559,5113,3,0,0,1,143,0),(459,0,1,3573,3573,3,3,0,0,114,0),(460,0,1,3574,4235,3,239,0,2,179,0),(486,0,24,3663,3735,3,451,0,10,576,1),(462,0,1,3582,6979,3,0,0,7,287,0),(463,0,1,3583,6333,3,370,0,2,229,0),(464,0,1,3586,7588,3,154,0,3,188,0),(465,0,1,3587,3587,3,3,0,0,120,0),(466,0,1,3588,7554,3,0,0,4,224,0),(467,0,1,3598,3598,3,3,0,0,106,0),(468,0,1,3599,3599,3,3,0,0,98,0),(469,0,1,3600,3600,3,3,0,0,110,0),(471,0,1,3603,7852,3,394,0,22,965,0),(472,0,1,3604,3604,3,3,0,0,105,0),(473,0,1,3607,3607,3,3,0,0,103,0),(474,0,1,3608,3608,3,3,0,0,105,0),(475,0,1,3610,7607,3,0,0,16,485,0),(476,0,1,3618,9611,3,394,0,2,235,0),(477,0,1,3619,10757,3,0,0,14,379,0),(478,0,1,3620,3774,3,0,0,1,126,0),(479,0,3,3621,3782,209,27,0,3,233,0),(480,0,1,3628,3628,3,3,0,0,111,0),(481,0,1,3629,8389,3,0,0,9,363,0),(482,0,24,3631,3776,0,452,0,25,1145,0),(483,0,11,3634,7339,27,0,0,7,694,0),(484,0,11,3639,3655,79,3,0,12,367,0),(487,0,24,3664,3720,3,0,0,9,494,1),(489,0,24,3666,3732,3,408,0,17,803,1),(490,0,24,3667,3676,3,3,0,2,295,1),(491,0,24,3668,3712,3,452,0,3,329,1),(492,0,24,3669,3693,3,3,0,2,273,1),(493,1,11,3670,3670,47,47,0,0,595,1),(494,0,11,3671,3671,47,47,0,0,362,1),(495,0,11,3672,4557,3,3,0,1,636,0),(496,0,11,3673,8004,47,451,0,1,621,0),(498,0,24,3697,3702,452,452,0,2,226,0),(499,0,24,3723,3723,103,103,0,0,211,0),(500,0,3,3748,3779,278,27,0,7,307,0),(501,0,11,3605,3605,3,3,0,0,316,0),(502,0,1,3783,6227,3,0,0,9,496,0),(503,0,1,3784,4542,3,0,0,2,198,0),(504,0,1,3785,8042,3,0,0,12,524,0),(505,0,1,3786,3786,3,3,0,0,149,0),(506,0,1,3787,10366,3,505,0,14,493,0),(507,0,1,3788,5725,3,0,0,7,400,0),(508,0,4,3794,3794,10,10,0,0,223,0),(509,0,3,3799,3813,375,0,0,4,204,0),(510,0,3,3827,3840,0,0,0,2,215,0),(511,0,3,3828,3829,375,408,0,1,158,0),(512,0,11,3841,3842,454,154,0,1,130,0),(513,0,1,3843,6822,3,250,0,13,577,0),(514,0,1,3844,11561,3,1619,0,4,303,0),(515,0,11,3856,3869,452,103,0,1,193,0),(518,0,4,3866,3875,452,452,0,2,193,0),(517,0,1,3862,3887,154,79,0,2,215,0),(519,0,3,3867,5120,156,10,0,10,417,0),(520,0,3,3876,5568,452,520,0,13,590,0),(522,0,18,3896,3896,3,3,0,0,8,0),(523,0,18,3897,3897,3,3,0,0,10,0),(524,0,18,3898,3898,3,3,0,0,4,0),(525,0,18,3899,4247,3,47,0,4,37,0),(526,0,18,3900,3900,3,3,0,0,9,0),(527,0,18,3901,3901,3,3,0,0,9,0),(528,0,18,3902,4221,3,3,0,1,16,0),(531,1,18,3905,3905,3,3,0,0,49,0),(530,0,18,3904,4010,3,3,0,2,54,0),(532,0,18,3907,5132,3,3,0,6,57,0),(533,1,34,3911,11370,3,3,0,1,51,0),(534,0,19,3912,4229,3,43,0,4,53,1),(535,0,34,3913,4454,3,27,0,2,74,1),(536,0,19,3914,4803,3,121,0,1,37,1),(537,0,19,3915,4457,3,0,0,1,48,1),(538,0,19,3916,4823,27,121,0,4,48,1),(539,0,19,3922,4345,3,27,0,1,31,1),(540,0,34,3931,4810,27,121,0,5,68,0),(541,0,19,3933,4225,27,3,0,2,40,1),(542,0,34,3940,4241,353,353,0,9,73,0),(588,0,18,4245,4245,47,47,0,0,9,0),(543,0,11,3950,3961,470,470,0,3,190,0),(544,0,3,3953,4736,96,0,0,6,353,0),(545,0,19,3963,3963,3,3,0,0,31,1),(546,0,34,3964,3964,3,3,0,0,31,0),(547,0,34,3965,3984,43,27,0,3,58,0),(548,0,19,3966,3966,43,43,0,0,46,1),(549,0,3,3967,3972,0,47,0,1,192,0),(550,0,34,3970,3970,0,0,0,0,25,0),(551,0,19,3973,4380,353,353,0,10,122,1),(587,0,19,4240,4240,353,353,0,0,34,1),(552,0,11,3996,3999,10,3,0,1,225,0),(553,0,24,4005,4093,0,0,0,10,565,0),(554,0,34,4006,4806,0,121,0,5,67,1),(555,0,19,4007,4827,0,3,0,3,44,1),(556,0,24,4011,4129,3,3,0,15,822,1),(557,0,24,4012,4118,3,3,0,5,370,1),(558,0,24,4013,4073,3,27,0,6,384,1),(559,0,24,4014,4100,3,43,0,2,282,1),(560,0,24,4015,4051,3,3,0,4,359,1),(561,0,24,4016,4122,3,3,0,18,867,1),(562,0,24,4017,4135,3,3,0,11,755,1),(563,0,24,4018,4095,3,479,0,11,574,1),(564,0,24,4019,4126,3,453,0,12,694,1),(565,0,24,4020,4079,0,3,0,3,310,1),(566,0,4,4048,4052,0,3,0,1,157,0),(567,0,34,4101,5277,43,43,0,2,31,0),(568,0,4,4099,4514,479,239,0,6,344,0),(569,0,24,4125,4134,3,239,0,4,419,0),(601,0,19,4382,4382,43,43,0,0,34,1),(571,0,14,4137,4285,3,488,23,14,822,0),(572,0,24,4143,4161,103,103,0,4,327,0),(573,0,1,4147,6710,0,478,0,5,220,0),(574,0,1,4148,9127,0,412,0,45,1292,0),(575,0,1,4149,11207,0,256,0,11,475,0),(576,0,1,4150,8821,0,79,0,14,519,0),(577,0,1,4151,11453,0,394,0,6,356,0),(578,0,1,4152,6777,0,505,0,10,376,0),(579,0,1,4153,11419,0,394,0,17,550,0),(580,0,1,4154,4254,0,275,0,17,617,0),(581,0,1,4155,4433,0,0,0,23,950,0),(582,0,1,4156,8455,0,187,0,5,249,0),(583,0,18,4189,4189,2,2,0,0,14,0),(584,0,24,4192,4218,0,239,0,13,613,0),(585,0,18,4204,4211,43,43,0,2,19,0),(586,0,11,4231,4231,0,0,0,0,139,0),(589,0,18,4248,5661,47,47,0,5,44,0),(590,0,9,4263,4314,103,0,0,2,461,0),(593,0,1,4296,6109,3,0,0,11,472,0),(592,0,3,4286,4468,489,472,0,3,269,0),(594,0,3,4307,4483,0,0,0,9,332,0),(595,0,11,4330,4480,187,47,0,2,220,0),(596,0,19,4339,4339,27,27,0,0,25,1),(597,0,19,4340,4456,353,3,0,14,128,1),(598,0,19,4341,4455,0,0,0,8,77,1),(599,0,19,4343,4347,3,43,0,1,22,1),(600,0,19,4346,4465,43,27,0,5,70,1),(602,0,19,4386,4802,3,121,0,1,29,1),(603,0,19,4387,4387,3,3,0,0,15,1),(604,0,34,4389,4882,3,121,0,12,66,0),(606,0,19,4401,4401,0,0,0,0,24,1),(607,0,11,4415,5984,0,460,0,12,688,0),(608,0,3,4444,8970,343,121,0,8,534,0),(609,0,4,4447,4452,0,3,0,1,130,0),(610,0,19,4460,4460,0,0,0,0,25,1),(611,0,18,4470,4470,3,3,0,0,22,0),(612,0,11,4473,4498,0,353,0,4,259,0),(613,0,11,4478,4478,20,20,0,0,132,0),(614,0,4,4492,4512,103,0,0,3,200,0),(615,0,20,4493,4493,47,47,0,0,255,0),(616,0,18,4499,4499,27,27,0,0,11,0),(617,0,11,4502,4504,239,47,0,1,198,0),(619,0,20,4520,4564,0,501,0,2,292,0),(620,0,20,4523,7069,0,454,0,17,900,0),(621,0,3,4524,5053,275,472,0,1,165,0),(622,0,11,4531,4531,10,10,0,0,131,0),(623,0,21,4545,4547,0,0,0,2,59,0),(624,0,21,4553,5632,486,3,0,21,204,0),(625,0,12,4561,4563,43,3,0,1,34,0),(660,0,19,4840,5207,3,121,0,2,36,1),(626,0,20,4569,4605,3,43,0,1,186,1),(627,0,20,4570,4602,3,43,0,5,230,1),(628,0,20,4571,4603,3,43,0,1,154,1),(629,0,20,4572,4581,502,27,0,4,215,0),(630,0,20,4573,4613,3,332,0,6,280,1),(631,0,20,4575,4604,3,0,0,7,375,1),(632,0,20,4576,4608,3,3,0,5,320,1),(633,0,20,4578,4601,3,3,0,5,271,1),(634,0,11,4615,7279,408,250,0,6,450,0),(635,0,20,4617,4633,456,0,0,10,394,0),(636,0,20,4619,4637,0,0,0,3,215,0),(637,0,20,4620,4625,375,375,0,2,199,0),(638,0,20,4631,4746,96,43,0,9,458,0),(639,0,20,4634,4816,166,370,0,29,1097,0),(640,0,1,4638,8342,0,478,0,17,676,0),(641,0,1,4639,6161,0,154,0,13,437,0),(642,0,1,4640,7059,0,250,0,18,805,0),(643,0,1,4641,6016,0,447,0,3,194,0),(644,0,1,4642,6288,0,79,0,2,146,0),(645,0,1,4643,8474,0,0,0,10,388,0),(646,0,1,4644,6832,0,79,0,4,258,0),(647,0,19,4652,4704,121,121,0,3,33,1),(648,0,20,4654,4660,27,3,0,2,221,0),(649,0,19,4656,4945,121,121,0,8,54,1),(650,0,20,4657,4772,3,27,0,21,1007,0),(651,0,34,4659,4859,121,121,0,2,48,0),(652,0,34,4667,4667,121,121,0,0,29,0),(653,0,20,4668,4701,506,3,0,1,270,0),(654,0,20,4677,4684,79,79,0,3,232,0),(655,0,4,4717,11721,0,1619,24,145,7253,0),(656,0,4,4745,5009,0,460,0,16,632,0),(657,0,19,4783,6047,353,353,0,4,71,1),(658,0,34,4794,4799,43,121,0,1,56,1),(659,0,19,4796,5124,27,3,0,8,51,0),(661,0,1,4843,8861,0,520,0,8,298,0),(662,0,19,4845,5217,0,0,0,7,81,1),(663,0,1,4847,10955,0,394,0,16,803,0),(664,0,19,4848,6537,3,27,0,7,79,1),(665,0,34,4849,11369,3,3,0,2,44,1),(666,0,19,4854,5218,27,27,0,6,62,1),(667,0,19,4866,4931,353,353,0,6,69,1),(668,0,1,4883,5586,0,0,0,13,522,0),(669,0,1,4895,10479,43,505,0,15,491,0),(670,0,1,4896,4896,43,43,0,0,95,0),(671,0,1,4898,5084,0,43,0,4,162,0),(672,0,5,4899,11478,100,3,0,6,509,0),(673,0,11,4906,10199,239,2,0,21,951,0),(675,0,34,4949,4973,0,121,0,5,63,0),(676,0,1,4954,8152,103,370,0,23,1128,0),(677,0,18,4957,4959,121,353,0,1,14,0),(678,0,19,4963,4963,121,121,0,0,17,1),(679,0,11,4967,5045,0,0,0,22,851,0),(680,0,18,4998,4998,27,27,0,0,12,0),(681,0,3,5031,5167,275,156,0,5,248,0),(683,0,4,5037,8361,2,0,0,41,2099,0),(684,0,11,5040,7213,10,0,0,2,346,0),(685,0,20,5050,5330,472,3,0,10,503,0),(686,0,14,5062,5063,25,0,0,1,261,0),(687,0,18,5131,5177,3,43,0,5,34,0),(688,0,1,5140,5145,154,103,0,1,187,0),(689,0,3,5148,5150,0,0,0,2,179,0),(690,0,3,5160,5191,0,3,0,5,355,0),(691,0,11,5161,5194,79,43,0,4,315,0),(693,0,18,5195,5198,43,0,0,2,19,0),(694,0,21,5201,5266,47,2,0,4,91,0),(696,0,3,5204,5206,0,0,0,2,213,0),(701,0,1,5224,10091,3,0,0,17,567,0),(699,0,4,5213,5213,6,6,0,0,169,0),(700,0,21,5214,5214,27,27,0,0,20,0),(702,0,15,5225,8683,3,657,0,19,888,0),(703,0,1,5230,5622,3,520,0,3,207,0),(704,0,1,5231,9478,3,43,0,9,413,0),(705,0,1,5232,10759,3,257,0,6,339,0),(706,0,1,5233,8673,3,505,0,13,498,0),(707,0,1,5234,8831,3,10,0,18,603,0),(708,0,1,5235,5282,3,394,0,2,230,0),(709,0,1,5236,5872,3,79,0,8,312,0),(710,0,1,5238,6467,3,3,0,7,295,0),(711,0,1,5239,7643,3,154,0,8,360,0),(712,0,1,5240,5591,3,250,0,6,226,0),(713,0,1,5241,5518,3,486,0,1,136,0),(714,0,1,5242,5242,3,3,0,0,103,0),(715,0,3,5243,5243,343,343,0,0,199,0),(716,0,3,5252,7065,448,43,0,14,421,0),(717,0,3,5262,5269,26,10,0,5,279,0),(718,0,21,5280,5280,27,27,0,0,25,0),(719,0,20,5296,5325,0,0,0,1,142,1),(720,0,20,5297,5326,0,0,0,4,226,1),(721,0,20,5298,5322,3,3,0,1,128,1),(722,0,20,5299,5319,0,0,0,2,159,1),(723,0,20,5300,5318,3,3,0,5,203,1),(724,0,20,5301,5323,0,0,0,5,220,1),(725,0,20,5302,5320,3,3,0,3,187,1),(726,0,20,5307,5308,523,0,0,1,121,0),(727,0,20,5331,5378,0,55,0,22,946,1),(728,0,1,5333,6115,0,0,0,3,162,0),(729,0,1,5334,6128,0,154,0,9,381,0),(730,0,1,5335,5335,0,0,0,0,95,0),(731,0,1,5336,8637,0,412,0,11,576,0),(732,0,1,5337,9624,0,0,0,6,300,0),(733,0,1,5338,7787,0,79,0,11,406,0),(734,0,1,5339,11423,0,464,0,3,220,0),(735,0,19,5350,5380,27,27,0,2,22,1),(736,0,19,5365,5431,3,121,0,10,63,1),(737,0,1,5382,6453,3,10,0,18,673,0),(738,0,3,5389,7732,43,47,0,2,292,0),(739,0,3,5392,5407,322,322,0,2,180,0),(740,0,34,5394,5596,3,121,0,1,37,0),(741,0,3,5395,5395,0,0,0,0,149,0),(742,0,3,5399,8432,0,370,0,26,1162,1),(743,0,4,5402,5458,0,69,0,10,443,0),(744,0,14,5410,5539,375,520,0,5,466,0),(745,0,21,5429,5440,27,47,0,3,34,0),(746,0,3,5434,5454,27,10,0,2,177,0),(747,0,4,5465,5537,370,520,0,11,432,0),(748,0,11,5489,5489,0,0,0,0,125,0),(749,0,19,5523,5523,27,27,0,0,19,1),(750,0,34,5544,5544,0,0,0,0,29,0),(751,0,34,5545,5545,0,0,0,0,22,0),(752,0,19,5592,5702,121,69,0,10,89,1),(753,0,19,5593,5689,0,0,0,1,29,1),(754,0,19,5594,5705,3,3,0,4,55,1),(755,0,34,5598,5603,121,27,0,3,56,1),(756,0,3,5610,7525,505,10,0,14,606,0),(757,0,34,5616,5624,121,27,0,1,31,0),(758,0,21,5626,5633,43,47,0,2,30,0),(762,0,4,5643,5651,291,154,0,4,310,1),(760,0,19,5630,5630,3,3,0,0,29,1),(761,0,3,5634,5636,489,43,0,2,143,0),(901,0,1,6878,11290,3,461,0,14,498,0),(764,0,3,5652,5657,532,0,0,5,220,0),(765,0,3,5658,7980,56,608,0,6,400,0),(766,0,34,5666,5674,121,121,0,2,36,0),(767,0,34,5668,5673,353,3,0,1,38,0),(768,0,19,5669,5672,353,353,0,2,16,1),(769,0,19,5675,5675,3,3,0,0,30,1),(770,0,1,5677,10344,103,0,0,12,387,0),(771,0,19,5680,5709,353,27,0,8,57,1),(772,0,19,5688,5688,0,0,0,0,9,1),(773,0,6,5717,7914,538,608,0,3,320,0),(809,0,3,5947,5954,100,3,0,4,234,0),(775,0,20,5739,5777,43,43,0,3,126,1),(776,0,20,5740,5794,43,3,0,4,230,1),(777,0,20,5741,5773,43,3,0,15,482,1),(778,0,20,5742,5790,43,503,0,6,220,1),(779,0,20,5743,5779,43,43,0,1,119,1),(780,0,20,5744,5776,43,69,0,9,239,1),(781,0,20,5745,5783,43,370,0,3,161,1),(782,0,20,5753,5757,530,3,0,1,121,1),(786,0,19,5791,5883,69,353,0,5,48,1),(785,0,20,5789,5789,0,0,0,0,107,0),(787,0,20,5795,5803,0,47,0,5,222,0),(788,0,20,5802,5950,0,100,0,15,584,1),(789,0,20,5805,5864,520,47,0,9,298,0),(790,0,1,5806,10374,0,27,0,12,487,0),(791,0,1,5807,5940,0,154,0,7,296,0),(792,0,1,5808,6134,0,520,0,11,475,0),(793,0,1,5809,6614,0,0,0,15,661,0),(794,0,1,5810,6165,0,505,0,5,233,0),(795,0,1,5811,6028,0,79,0,6,189,0),(796,0,1,5812,8498,0,27,0,3,173,0),(797,0,11,5828,5857,100,47,0,7,316,0),(798,0,4,5834,6396,0,3,0,9,508,0),(799,0,34,5852,5860,27,27,0,2,36,0),(800,0,20,5854,5865,440,47,0,2,223,0),(801,0,19,5880,6129,3,3,0,7,76,1),(802,0,34,5884,5884,353,353,0,0,42,1),(803,0,20,5885,6181,0,154,0,25,1052,0),(804,0,3,5895,5903,0,69,0,4,205,0),(805,0,4,5907,6932,460,460,0,7,421,0),(806,0,4,5909,8025,79,608,25,14,583,0),(807,0,1,5918,9028,0,79,0,11,455,0),(808,0,19,5921,6014,0,69,0,7,54,1),(810,0,19,5958,6055,353,43,0,8,81,1),(811,0,19,5959,6067,3,3,0,2,45,1),(812,0,6,5966,6058,0,0,0,13,776,0),(813,0,19,5986,6074,69,69,0,2,35,1),(814,0,19,5988,5988,69,69,0,0,32,1),(815,0,19,5989,5989,69,69,0,0,18,1),(816,0,11,5990,7273,370,343,0,2,196,0),(817,0,4,6002,6015,0,69,0,2,172,0),(818,0,20,6009,6081,47,520,0,3,249,1),(819,0,3,6029,6031,0,0,0,1,150,0),(820,0,11,6032,6050,96,47,0,3,226,0),(821,0,19,6038,6152,121,121,0,1,29,1),(822,0,19,6039,6041,3,0,0,2,22,1),(824,0,19,6072,6072,69,69,0,0,12,1),(823,0,19,6043,6043,353,353,0,0,15,1),(825,0,19,6073,6073,69,69,0,0,12,1),(826,0,34,6116,6117,3,3,0,1,33,0),(827,0,4,6144,6174,332,520,0,8,378,0),(828,0,3,6155,6156,79,43,0,1,169,0),(829,0,3,6171,6334,343,343,0,8,322,0),(830,0,3,6176,6441,6,0,0,5,235,0),(831,0,20,6182,6236,69,547,0,6,282,1),(832,0,20,6183,6225,0,0,0,1,174,1),(833,0,20,6184,6222,69,0,0,7,300,1),(834,0,20,6185,6224,69,0,0,1,156,1),(835,0,20,6186,6234,0,3,0,9,428,1),(836,0,20,6187,6220,0,0,0,7,284,1),(837,0,20,6188,6219,0,0,0,5,280,1),(838,0,20,6239,6358,0,79,0,19,893,1),(839,0,19,6252,6277,47,69,0,2,31,1),(840,0,19,6254,6950,3,69,0,4,54,1),(841,0,19,6255,6953,3,353,0,30,175,1),(842,0,19,6256,6680,3,47,0,2,45,1),(843,0,19,6257,6951,3,47,0,6,76,1),(844,0,1,6262,8708,3,412,0,7,293,0),(845,0,1,6263,6865,3,250,0,7,291,0),(846,0,1,6264,6322,3,454,0,7,252,0),(847,0,1,6265,6265,3,3,0,0,71,0),(848,0,1,6266,11374,3,2527,0,21,717,0),(849,0,1,6267,6267,3,3,0,0,67,0),(850,0,1,6268,6268,3,3,0,0,62,0),(851,0,3,6280,6560,505,121,0,15,501,0),(852,0,20,6290,6335,69,69,0,10,435,0),(853,0,3,6336,6458,0,10,0,13,392,0),(854,0,3,6338,6338,0,0,0,0,81,0),(855,0,4,6376,7942,0,0,26,22,864,0),(856,0,19,6413,6948,43,43,0,5,46,1),(857,0,3,6426,6451,0,3,0,11,320,0),(858,0,3,6477,6478,0,3,0,1,133,0),(859,0,19,6483,6882,47,121,0,9,60,1),(860,0,19,6484,7044,3,353,0,24,170,1),(861,0,19,6485,6692,69,69,0,4,64,1),(862,0,1,6486,6700,3,27,0,14,443,0),(863,0,1,6487,8557,3,79,0,6,298,0),(864,0,19,6494,6666,0,0,0,1,26,1),(865,0,19,6496,6496,121,121,0,0,18,1),(866,0,34,6499,11454,3,353,0,2,34,0),(867,0,3,6500,6511,6,6,0,2,143,0),(868,0,1,6524,6959,0,103,0,18,603,0),(869,0,1,6525,7892,0,496,0,14,461,0),(870,0,1,6526,7835,0,130,0,7,213,0),(871,0,1,6527,7737,0,0,0,8,277,0),(872,0,1,6528,6723,0,353,0,2,110,0),(873,0,1,6529,6529,0,0,0,0,44,0),(874,0,1,6530,11262,0,154,0,6,250,0),(875,0,1,6531,6531,0,0,0,0,50,0),(876,0,1,6532,6532,0,0,0,0,53,0),(877,0,19,6533,6543,27,121,0,2,23,1),(878,0,1,6561,6670,353,0,0,4,174,0),(880,0,3,6580,6714,96,10,0,6,313,0),(881,0,19,6581,6581,43,43,0,0,22,1),(882,0,21,6592,6636,3,353,0,11,110,0),(883,0,21,6593,6633,3,0,0,2,42,0),(884,1,21,6594,8278,3,47,0,12,171,0),(885,0,3,6640,6645,122,122,27,4,195,0),(886,0,19,6658,6658,69,69,0,0,17,1),(887,0,34,6659,6682,43,69,0,5,56,0),(888,0,19,6662,6662,0,0,0,0,12,1),(889,0,6,6664,9439,122,0,0,16,805,0),(890,0,20,6688,6688,3,3,0,0,155,1),(891,0,5,6704,8547,122,10,0,16,990,0),(892,0,19,6705,6743,353,47,0,1,26,1),(893,0,3,6715,6724,532,0,0,1,160,0),(894,0,3,6740,7987,503,0,0,9,504,0),(895,0,1,6759,6759,353,353,0,0,82,0),(896,0,3,6761,6772,96,503,0,2,185,0),(897,0,3,6781,6834,0,0,0,12,359,0),(898,0,3,6800,7109,0,520,0,11,419,0),(899,0,5,6802,6803,505,0,0,1,164,0),(900,0,5,6835,6856,546,546,0,9,441,0),(902,0,1,6879,6965,3,454,0,23,608,0),(903,0,3,6897,7187,503,520,0,30,981,0),(906,0,5,6952,7017,0,47,0,4,386,0),(905,0,11,6925,6941,130,130,0,5,191,0),(907,0,11,6956,6956,0,0,0,0,97,0),(908,0,14,6957,7068,0,0,0,16,509,0),(909,0,19,6973,6973,353,353,0,0,15,1),(910,0,3,6986,7028,96,3,0,5,243,0),(911,0,11,6992,7000,2,0,0,2,196,0),(912,0,11,7001,7476,0,47,0,16,455,0),(913,0,4,7005,8069,0,121,28,14,424,0),(915,0,3,7062,7569,493,27,0,5,324,0),(916,0,11,7066,7398,0,0,0,9,531,0),(917,0,20,7073,7096,0,121,0,3,189,1),(918,0,20,7074,7092,0,69,0,2,159,1),(919,0,20,7075,7098,0,121,0,3,131,1),(920,0,20,7076,7095,0,121,0,1,112,1),(921,0,20,7077,7097,0,121,0,3,142,1),(922,0,20,7078,7110,0,0,0,6,296,1),(923,0,20,7079,7103,0,79,0,3,167,1),(924,0,20,7080,7099,0,121,0,1,124,1),(925,0,1,7111,7111,0,0,0,0,59,0),(926,0,1,7112,8606,0,639,0,4,214,0),(927,0,1,7113,7113,0,0,0,0,64,0),(928,0,1,7114,7390,0,0,0,2,82,0),(929,0,1,7115,8451,0,79,0,7,261,0),(930,0,1,7116,9866,0,132,0,2,100,0),(931,0,1,7117,7552,0,0,0,10,323,0),(932,0,1,7118,7517,0,154,0,6,285,0),(933,0,1,7119,7119,0,0,0,0,40,0),(934,1,20,7121,7232,0,0,0,8,501,0),(935,1,20,7127,7152,3,239,0,3,524,0),(936,1,20,7128,7128,3,3,0,0,215,0),(937,0,23,7135,7303,454,27,0,27,775,0),(938,0,3,7136,11545,547,412,0,11,657,0),(939,0,11,7149,7156,0,10,0,3,166,0),(940,0,4,7150,7157,0,10,0,1,133,1),(941,0,20,7155,7155,580,580,0,0,149,0),(942,0,4,7160,8062,554,608,0,43,1295,0),(944,0,1,7184,7760,103,103,0,9,234,0),(1044,0,4,8063,8063,608,608,0,0,99,0),(946,0,11,7215,8996,10,3,0,5,451,0),(947,0,1,7228,8698,103,257,0,13,458,0),(948,0,11,7245,7377,20,506,0,13,374,0),(949,0,11,7261,7399,343,343,0,5,237,0),(951,0,23,7286,7332,27,27,0,2,106,0),(952,0,23,7287,7287,27,27,0,0,71,0),(953,0,23,7288,7310,27,27,0,2,125,0),(954,0,23,7289,7333,27,27,0,6,185,0),(955,0,23,7291,7298,27,27,0,2,125,0),(956,0,23,7292,7350,27,408,0,15,419,0),(957,0,23,7293,7323,27,27,0,2,138,0),(958,0,23,7294,7300,27,27,0,2,125,0),(959,0,23,7296,7380,27,0,0,5,205,0),(960,0,23,7314,7319,585,585,0,2,124,0),(961,0,23,7341,7408,27,0,0,19,497,0),(962,0,18,7344,8426,47,2,0,2,27,0),(963,0,11,7358,7358,0,0,0,0,105,0),(964,0,1,7362,8887,0,257,0,6,270,0),(965,0,1,7363,9820,0,0,0,12,507,0),(966,0,11,7364,7375,587,154,0,1,170,0),(967,0,1,7365,7535,0,0,0,2,86,0),(968,0,1,7366,10018,0,606,0,4,248,0),(969,0,1,7367,8372,0,0,0,4,189,0),(970,0,1,7368,9238,0,662,0,16,415,0),(971,0,1,7369,8999,0,96,0,5,253,0),(972,0,1,7370,7653,0,308,0,8,256,0),(973,0,1,7371,8922,0,257,0,11,328,0),(974,0,23,7400,7450,588,10,0,5,223,0),(975,0,11,7407,7407,122,122,0,0,93,0),(976,0,1,7410,7458,43,37,0,10,222,0),(977,0,1,7411,7461,43,370,0,1,145,0),(978,0,1,7412,7487,43,0,0,2,132,0),(979,0,11,7414,10148,154,3,0,26,710,0),(980,0,1,7430,8711,0,257,0,11,273,0),(981,0,1,7431,7439,0,394,0,4,124,0),(982,0,11,7465,7524,3,0,0,7,288,0),(983,0,11,7481,7481,154,154,0,0,184,1),(984,0,9,7504,7504,3,3,0,0,116,0),(985,0,9,7506,7506,3,3,0,0,114,0),(986,0,9,7507,8380,3,465,0,37,1454,0),(987,0,9,7508,7508,154,154,0,0,114,0),(988,1,9,7509,11865,3,10,0,21,1023,0),(990,0,4,7534,7994,79,615,0,6,291,0),(991,0,1,7545,7545,0,0,0,0,49,0),(992,0,1,7547,10789,0,394,0,6,237,0),(993,0,1,7549,8899,0,43,0,9,302,0),(994,0,1,7550,9747,0,27,0,18,515,0),(995,0,9,7557,7558,593,308,0,1,109,0),(996,0,9,7567,7577,121,43,0,2,199,0),(997,0,9,7590,8275,3,460,0,5,422,0),(998,0,9,7602,7602,3,3,0,0,143,0),(999,1,20,7604,7657,69,454,0,3,344,0),(1000,0,3,7638,7683,0,0,0,9,331,0),(1001,0,3,7669,9209,0,0,0,15,650,0),(1002,0,4,7676,7717,0,520,0,7,269,0),(1003,0,4,7681,8315,154,626,0,42,1236,0),(1004,0,1,7709,7709,0,0,0,0,58,0),(1005,0,3,7712,10371,122,122,0,23,870,0),(1006,0,1,7746,8491,0,370,0,4,172,0),(1007,0,1,7751,7751,0,0,0,0,69,0),(1008,0,1,7765,7840,3,0,0,5,255,0),(1009,0,1,7780,7780,0,0,0,0,60,0),(1010,0,1,7782,8881,0,257,0,2,116,0),(1011,1,4,7785,10954,0,467,0,24,1128,0),(1014,0,1,7811,7811,27,27,0,0,65,0),(1013,0,21,6625,7817,0,0,0,11,44,0),(1015,0,1,7812,7853,27,0,0,2,132,0),(1016,0,11,7833,7978,39,441,0,4,322,0),(1017,0,1,7836,8689,0,506,0,21,670,0),(1018,0,1,7837,7837,0,0,0,0,90,0),(1019,0,1,7841,10302,27,0,0,13,332,0),(1020,0,1,7844,8626,27,79,0,10,409,0),(1021,0,1,7864,11519,27,154,0,7,274,0),(1022,0,1,7865,9392,27,394,0,4,224,0),(1023,0,1,7866,8446,27,187,0,6,312,0),(1024,0,1,7868,7868,27,27,0,0,72,0),(1026,0,3,7905,7948,471,69,0,4,234,0),(1027,0,6,7912,7917,608,43,0,1,193,0),(1030,0,6,7921,7927,608,608,0,2,161,0),(1033,1,20,7928,8202,0,454,0,7,422,0),(1032,0,5,7925,7947,608,47,0,1,310,0),(1034,0,4,7967,8064,569,608,0,2,148,0),(1047,0,4,8085,11862,451,472,0,55,2312,0),(1039,0,3,7981,7986,608,0,0,1,115,0),(1037,0,6,7974,7976,608,47,0,1,229,0),(1041,0,3,8002,8005,608,0,31,1,171,0),(1042,0,4,8024,8255,608,0,32,32,854,0),(1043,0,11,8032,8046,96,47,0,1,371,0),(1046,0,4,8075,9533,608,0,0,30,793,0),(1149,1,21,9126,9154,47,2,0,3,49,0),(1049,0,9,8145,8154,3,608,0,4,241,0),(1051,0,3,8161,8224,0,27,0,7,479,0),(1054,0,1,8179,8179,79,79,0,0,70,0),(1055,0,4,8191,8191,454,454,0,0,95,0),(1056,0,1,8197,8197,79,79,0,0,72,0),(1057,0,1,8223,8223,79,79,0,0,97,0),(1058,0,9,8228,8439,0,69,0,3,429,0),(1059,0,9,8229,8467,0,43,0,7,449,0),(1060,0,4,8236,10880,332,620,33,60,1695,0),(1061,0,9,8252,8268,0,69,0,3,195,0),(1062,0,21,8276,8281,27,121,0,2,27,0),(1063,0,9,8279,8279,0,0,0,0,133,0),(1064,0,4,8288,8311,620,620,0,16,403,0),(1068,0,3,8344,8344,0,0,0,0,137,0),(1066,0,5,8316,9564,626,0,0,10,984,1),(1067,0,3,8319,8519,0,353,0,5,334,0),(1069,0,1,8355,8355,0,0,0,0,77,0),(1070,0,9,8363,8363,3,3,0,0,80,0),(1071,0,9,8365,8365,0,0,0,0,93,0),(1072,0,9,8366,8366,0,0,0,0,134,0),(1073,0,11,8376,8483,0,0,0,7,935,0),(1074,0,6,8383,8390,96,96,0,3,310,0),(1075,0,4,8394,8400,569,451,0,1,162,0),(1076,0,3,8399,8417,0,0,0,2,213,0),(1083,0,9,8454,8454,154,154,0,0,108,0),(1084,0,18,8461,8473,79,47,0,5,35,0),(1085,0,9,8479,8479,0,0,0,0,103,0),(1086,0,9,8480,8480,0,0,0,0,101,0),(1087,0,9,8481,8481,0,0,0,0,124,0),(1088,0,11,8486,8493,0,10,0,3,236,0),(1089,0,1,8506,8506,79,79,0,0,72,0),(1090,0,1,8507,10968,27,27,0,17,500,0),(1091,0,3,8512,8513,0,47,0,1,171,0),(1093,0,1,8518,10361,79,0,0,6,252,0),(1096,0,9,8522,8522,154,154,0,0,82,0),(1097,0,9,8523,8549,154,506,0,4,224,0),(1098,0,1,8524,9479,0,43,0,11,393,0),(1099,0,4,8548,8548,121,121,0,0,145,0),(1100,0,9,8554,8554,0,0,0,0,104,0),(1101,0,3,8555,8555,0,0,0,0,124,0),(1102,0,3,8566,8580,0,0,0,2,228,0),(1103,0,1,8570,8570,79,79,0,0,54,0),(1104,0,9,8572,8572,154,154,0,0,93,0),(1105,0,6,8578,8635,655,10,0,2,356,0),(1106,0,3,8581,8608,0,654,0,16,362,0),(1107,0,3,8611,8630,96,0,0,8,329,0),(1108,0,9,8631,8631,154,154,0,0,69,0),(1110,0,9,8634,8634,154,154,0,0,88,0),(1248,0,18,10126,10822,3,3,0,2,36,0),(1114,1,21,8649,9129,3,10,0,30,296,0),(1115,1,21,8650,8700,3,3,0,4,65,0),(1116,0,21,8655,8732,79,47,0,3,55,0),(1117,0,21,8676,8684,47,10,0,1,21,0),(1119,0,9,8691,8752,154,79,0,8,500,0),(1121,0,11,8717,9585,257,132,0,38,1118,0),(1122,0,9,8720,8720,154,154,0,0,84,0),(1123,0,1,8723,8723,79,79,0,0,50,0),(1124,0,1,8725,8843,79,79,0,2,140,0),(1125,0,1,8728,11241,79,4882,0,8,294,0),(1126,0,1,8730,8936,79,335,0,12,409,0),(1127,0,1,8743,10433,79,0,0,25,564,0),(1128,0,1,8751,10928,79,471,0,24,542,0),(1129,0,3,8753,8860,122,122,0,14,533,0),(1130,0,1,8762,8806,79,454,0,6,204,0),(1131,0,1,8763,10747,79,412,0,5,214,0),(1132,0,1,8767,9752,79,370,0,8,267,0),(1133,0,4,8782,8833,454,121,0,10,295,0),(1134,0,3,8849,8866,122,122,0,5,346,0),(1135,0,3,8875,8949,520,520,0,12,311,0),(1136,0,4,8889,9823,332,332,0,7,269,0),(1137,0,9,8902,8932,10,10,0,6,233,0),(1138,0,9,8933,8935,10,10,0,2,145,0),(1139,0,11,8948,8992,0,506,0,8,281,0),(1140,0,4,8950,8952,664,43,0,1,108,0),(1141,0,4,8986,8987,0,0,0,1,116,0),(1142,0,9,9003,9021,10,0,0,3,143,0),(1143,0,25,9004,9191,47,96,0,37,1004,0),(1144,0,4,9012,9012,0,0,0,0,149,0),(1146,0,11,9059,10805,27,0,0,13,405,0),(1147,0,11,9060,9558,27,0,0,8,549,0),(1148,0,3,9063,9803,0,0,0,18,477,0),(1150,0,25,9139,9182,0,27,0,11,301,0),(1151,0,25,9140,9144,0,257,0,1,178,0),(1152,0,25,9141,9197,0,671,0,15,381,0),(1153,0,25,9158,9856,27,79,0,11,346,0),(1154,0,1,9183,9356,0,27,0,31,513,0),(1155,0,1,9184,9643,0,79,0,6,209,0),(1156,0,1,9185,9267,0,394,0,10,252,0),(1157,1,26,9211,9387,47,0,0,24,609,0),(1158,0,9,9221,9221,10,10,0,0,52,0),(1161,0,9,9224,9224,27,27,0,0,55,0),(1162,0,9,9225,9225,27,27,0,0,120,0),(1163,0,9,9226,9226,27,27,0,0,79,0),(1164,0,4,9265,9298,650,650,0,13,214,0),(1165,0,9,9275,9275,154,154,0,0,73,0),(1166,0,4,9278,9290,662,662,0,3,95,0),(1167,0,26,9300,9317,0,0,0,9,302,0),(1168,0,26,9301,9343,0,154,0,9,305,0),(1169,0,26,9302,9361,0,27,0,11,359,0),(1170,0,1,9344,10338,154,0,0,11,376,0),(1171,0,1,9345,9410,154,662,0,17,294,0),(1172,0,1,9346,9380,154,454,0,6,145,0),(1173,0,4,9368,9441,27,10,0,11,432,0),(1175,0,9,9432,9561,27,454,0,24,827,0),(1176,0,4,9463,9530,0,520,0,10,213,0),(1177,0,4,9481,9577,0,0,0,16,250,0),(1178,0,4,9483,9487,0,10,0,2,114,0),(1179,0,9,9484,9484,27,27,0,0,70,0),(1181,0,4,9509,9509,3,3,0,0,107,1),(1182,0,4,9517,9544,394,10,0,13,234,0),(1183,1,4,9549,10508,132,395,0,63,1823,0),(1184,0,27,9575,9729,27,27,0,11,581,0),(1186,0,4,9626,9753,662,394,0,16,299,0),(1187,0,3,9628,9661,0,0,0,6,223,0),(1190,0,3,9669,9690,394,43,0,2,145,0),(1191,0,27,9671,9728,0,394,0,9,270,0),(1192,0,27,9672,9722,0,43,0,16,418,1),(1193,0,27,9673,9733,0,154,0,16,473,0),(1194,0,1,9697,11532,0,5885,0,7,383,0),(1195,0,1,9698,9698,0,0,0,0,61,0),(1196,0,1,9699,10264,0,370,0,6,263,0),(1197,0,9,9724,9724,154,154,0,0,66,0),(1198,0,9,9725,9725,154,154,0,0,43,0),(1199,0,9,9726,9726,154,154,0,0,51,0),(1200,0,4,9740,9800,454,10,0,14,313,0),(1201,0,4,9759,9759,343,343,0,0,112,2),(1202,0,9,9774,9785,154,3,0,2,106,0),(1203,0,4,9778,10956,620,0,0,29,645,0),(1204,0,9,9791,9859,154,27,0,8,224,0),(1205,0,18,9793,10394,3,353,0,12,104,0),(1206,1,28,9811,9920,3,132,0,20,598,0),(1207,0,9,9813,9813,154,154,0,0,60,0),(1208,0,9,9814,9814,154,154,0,0,55,0),(1209,0,9,9815,9815,154,154,0,0,45,0),(1210,0,9,9816,9990,154,3,0,4,141,0),(1247,0,9,10122,10124,154,154,0,2,94,0),(1212,0,4,9828,9828,520,520,0,0,48,0),(1213,0,9,9831,9831,154,154,0,0,56,0),(1215,0,9,9852,9852,154,154,0,0,68,0),(1216,0,9,9860,9860,154,154,0,0,67,0),(1217,0,28,9872,9907,79,79,0,3,171,1),(1218,0,28,9873,9906,79,79,0,15,337,1),(1219,0,28,9874,9908,79,79,0,1,131,1),(1220,0,28,9875,9904,79,79,0,3,147,1),(1221,0,28,9876,9905,79,79,0,3,133,1),(1222,0,4,9896,9896,27,27,0,0,128,0),(1223,0,28,9911,9995,132,602,0,38,611,0),(1224,0,28,9921,10012,516,47,0,6,270,2),(1225,0,1,9925,9925,79,79,0,0,70,0),(1238,0,1,10035,10917,79,0,0,46,975,0),(1227,0,1,9927,10602,79,0,0,3,181,0),(1228,0,1,9928,9928,79,79,0,0,54,0),(1229,0,1,9930,10399,79,79,0,2,127,0),(1230,0,28,9934,9978,394,394,36,5,304,0),(1231,0,9,9938,10039,154,0,0,5,172,0),(1232,0,9,9939,9939,154,154,0,0,47,0),(1233,0,9,9940,9940,154,154,0,0,66,0),(1234,0,3,9982,9993,677,27,0,4,201,0),(1235,0,4,9994,9997,662,0,0,1,107,0),(1236,0,6,9999,11140,655,453,0,34,1050,0),(1237,0,4,10008,10339,617,712,0,17,383,0),(1240,0,4,10057,10104,662,520,0,9,220,0),(1241,0,11,10059,10290,505,0,0,12,471,0),(1243,0,4,10071,10101,79,620,0,3,137,0),(1244,0,9,10095,10095,154,154,0,0,53,0),(1246,0,9,10097,10097,154,154,0,0,72,0),(1249,0,3,10132,11531,505,2527,0,9,354,0),(1250,0,9,10139,10139,154,154,0,0,47,0),(1251,0,9,10140,10227,154,3,0,6,213,0),(1252,0,9,10153,10166,154,0,0,3,99,0),(1253,0,4,10159,10159,0,0,0,0,97,0),(1254,0,4,10168,10324,27,0,0,23,564,0),(1255,0,9,10172,10172,154,154,0,0,65,0),(1256,0,3,10176,10236,710,0,0,17,478,0),(1257,0,9,10200,10200,154,154,0,0,37,0),(1258,0,9,10202,10202,154,154,0,0,43,0),(1259,0,9,10203,10203,154,154,0,0,40,0),(1260,0,9,10204,10204,154,154,0,0,39,0),(1261,0,9,10220,10220,3,3,0,0,46,0),(1262,0,9,10246,10246,154,154,0,0,64,0),(1263,0,9,10247,10247,154,154,0,0,48,0),(1264,0,9,10248,10248,154,154,0,0,39,0),(1265,0,9,10249,10249,154,154,0,0,59,0),(1266,0,9,10250,10250,154,154,0,0,90,0),(1267,0,9,10329,10329,154,154,0,0,66,0),(1268,0,3,10347,10357,0,0,0,4,195,0),(1269,0,9,10351,10351,154,154,0,0,80,0),(1270,0,9,10352,10352,154,154,0,0,80,0),(1271,0,4,10353,10384,662,10,37,16,390,0),(1273,0,4,10386,10388,328,328,0,2,130,0),(1274,0,3,10391,10392,96,154,0,1,121,0),(1275,0,4,10401,10470,0,0,0,6,150,0),(1276,0,3,10406,10424,617,617,0,13,245,0),(1277,1,30,10437,10799,0,3,0,28,953,0),(1278,0,9,10444,10444,154,154,0,0,53,0),(1279,0,30,10445,10585,0,505,0,2,139,1),(1280,0,30,10446,10446,0,0,0,0,47,1),(1281,0,30,10447,10447,0,0,0,0,65,1),(1282,0,30,10448,10448,0,0,0,0,55,1),(1283,0,9,10449,10449,154,154,0,0,69,0),(1284,0,30,10450,10450,0,0,0,0,46,1),(1285,0,30,10451,10451,0,0,0,0,37,1),(1286,0,30,10452,10452,0,0,0,0,58,1),(1287,0,9,10453,10453,154,154,0,0,72,0),(1288,0,30,10454,10519,0,0,0,2,160,1),(1289,0,30,10455,10583,0,516,0,3,132,1),(1290,0,30,10456,10520,0,0,0,2,229,1),(1291,0,30,10457,10577,0,0,0,6,223,1),(1292,0,30,10458,10563,0,547,0,9,335,1),(1293,0,30,10459,10533,0,312,0,3,190,1),(1294,0,30,10460,10460,0,0,0,0,50,1),(1295,0,30,10461,10574,0,520,0,9,400,1),(1296,0,30,10462,10501,0,257,0,1,171,1),(1297,0,30,10463,10463,0,0,0,0,59,1),(1298,0,30,10464,10573,0,55,0,8,406,1),(1299,0,30,10477,10566,0,617,0,3,271,1),(1300,0,4,10478,10486,505,505,0,2,116,0),(1301,0,30,10482,10605,0,394,0,22,718,1),(1303,0,3,10553,11287,0,10,0,3,195,0),(1304,0,30,10557,10635,0,602,0,9,454,0),(1305,0,3,10578,10578,617,617,0,0,88,0),(1306,0,4,10586,10586,0,0,0,0,61,0),(1307,0,9,10588,10588,154,154,0,0,43,0),(1308,0,9,10589,10589,154,154,0,0,60,0),(1309,0,3,10594,10758,0,654,0,18,530,0),(1310,0,1,10615,10615,0,0,0,0,41,0),(1311,0,1,10616,11507,0,2527,0,4,168,0),(1312,0,1,10617,10809,0,0,0,14,340,0),(1313,0,1,10618,10618,0,0,0,0,23,0),(1314,0,1,10619,10709,0,547,0,7,236,0),(1315,0,1,10620,10620,0,0,0,0,29,0),(1316,0,1,10621,10951,0,394,0,6,198,0),(1317,0,1,10622,11333,0,3636,0,7,347,0),(1318,0,1,10623,10623,0,0,0,0,46,0),(1319,0,1,10624,10803,0,370,0,5,176,0),(1320,0,1,10625,10708,0,547,0,2,98,0),(1321,0,1,10626,10626,0,0,0,0,31,0),(1322,0,1,10627,10627,0,0,0,0,35,0),(1323,0,1,10628,10628,0,0,0,0,33,0),(1324,0,1,10629,10877,0,154,0,8,244,0),(1325,0,1,10630,10681,0,96,0,7,143,0),(1326,0,1,10631,10631,0,0,0,0,29,0),(1327,0,1,10632,10944,0,471,0,2,120,0),(1328,0,1,10633,10767,0,408,0,12,352,0),(1329,0,1,10634,11270,0,2527,0,13,400,0),(1330,0,3,10642,10642,677,677,0,0,103,0),(1331,0,9,10710,10710,154,154,0,0,63,0),(1332,0,4,10711,10814,617,0,0,10,315,0),(1333,0,4,10732,10778,27,0,0,11,360,0),(1334,0,21,10733,10749,47,3,0,1,33,0),(1335,0,9,10770,10770,154,154,0,0,44,0),(1336,0,3,10777,10784,761,761,0,2,146,0),(1337,0,9,10780,10780,27,27,0,0,130,0),(1338,0,3,10781,10800,343,343,0,2,218,0),(1344,0,9,10817,10817,47,47,0,0,95,1),(1345,0,9,10818,10818,154,154,0,0,34,0),(1341,0,3,10793,10797,0,27,0,1,189,1),(1343,0,4,10816,10816,0,0,0,0,100,0),(1346,0,9,10819,10819,154,154,0,0,54,0),(1347,0,9,10820,10820,154,154,0,0,77,0),(1348,1,18,10835,10883,47,47,0,1,34,0),(1349,0,9,10852,10852,154,154,0,0,85,0),(1350,0,3,10869,10882,0,121,0,3,241,0),(1351,0,9,10878,10878,154,154,0,0,90,0),(1353,0,4,10898,11304,0,617,0,26,555,0),(1354,0,18,10926,10938,79,47,0,5,36,0),(1355,0,4,10931,11181,138,654,0,11,333,0),(1356,0,9,10961,10961,154,154,0,0,144,0),(1357,0,3,10969,11211,96,655,0,6,175,0),(1359,1,33,10981,11850,47,2,0,130,2427,0),(1360,1,33,10982,11223,47,670,0,37,792,0),(1361,1,33,10983,11716,47,472,0,28,853,0),(1362,0,33,11004,11151,1568,47,0,12,389,0),(1364,0,33,11030,11095,47,370,0,13,292,0),(1365,0,33,11112,11839,516,611,0,14,450,0),(1366,0,33,11146,11156,3354,2,0,4,189,0),(1368,0,5,11200,11282,547,454,0,2,143,0),(1369,0,3,11209,11227,5636,5636,0,4,81,0),(1370,0,4,11212,11219,452,412,0,2,98,0),(1373,0,6,11235,11285,5532,47,0,2,114,0),(1374,0,3,11236,11297,5689,662,0,15,361,0),(1375,0,33,11243,11255,493,1245,0,4,118,0),(1376,0,3,11280,11550,5775,47,0,3,118,0),(1377,0,3,11326,11326,5820,5820,0,0,53,0),(1378,0,3,11327,11396,585,454,0,5,120,0),(1379,0,3,11334,11341,585,394,0,3,93,0),(1380,0,3,11337,11338,5826,412,0,1,59,0),(1381,0,19,11342,11342,3,3,0,0,0,1),(1382,0,19,11343,11343,3,3,0,0,0,1),(1383,0,19,11344,11344,3,3,0,0,0,1),(1384,0,19,11345,11345,3,3,0,0,1,1),(1385,0,19,11346,11346,3,3,0,0,0,1),(1386,0,19,11347,11347,3,3,0,0,0,1),(1387,0,19,11348,11348,3,3,0,0,0,1),(1388,0,19,11349,11349,3,3,0,0,0,1),(1389,0,19,11350,11350,3,3,0,0,0,1),(1390,0,19,11351,11351,3,3,0,0,0,1),(1391,0,19,11352,11352,3,3,0,0,0,1),(1392,0,19,11353,11353,3,3,0,0,0,1),(1393,0,19,11354,11354,3,3,0,0,0,1),(1394,0,19,11355,11355,3,3,0,0,0,1),(1395,0,19,11356,11356,3,3,0,0,0,1),(1396,0,19,11357,11357,3,3,0,0,0,1),(1397,0,19,11358,11358,3,3,0,0,0,1),(1398,0,19,11359,11359,3,3,0,0,0,1),(1399,0,19,11360,11360,3,3,0,0,0,1),(1400,0,19,11361,11361,3,3,0,0,0,1),(1401,0,19,11362,11362,3,3,0,0,0,1),(1402,0,19,11363,11363,3,3,0,0,0,1),(1403,0,19,11364,11364,3,3,0,0,0,1),(1404,0,19,11365,11365,3,3,0,0,0,1),(1405,0,19,11366,11366,3,3,0,0,1,1),(1406,0,19,11367,11367,3,3,0,0,2,1),(1407,0,19,11368,11368,3,3,0,0,3,1),(1408,1,34,11371,11446,3,3,0,2,36,0),(1409,0,34,11372,11372,3,3,0,0,10,0),(1410,0,34,11373,11373,3,3,0,0,17,1),(1411,0,34,11375,11375,3,3,0,0,15,1),(1412,0,3,11378,11415,5834,1490,0,3,89,0),(1415,0,34,11387,11388,79,79,0,1,26,1),(1416,0,34,11389,11390,79,79,0,1,16,0),(1417,0,34,11391,11406,79,79,0,3,24,0),(1418,0,34,11393,11410,79,79,0,6,25,0),(1419,0,34,11395,11407,79,79,0,2,15,0),(1420,0,34,11397,11449,1567,3,0,5,50,1),(1423,0,34,11411,11452,3,3,0,2,40,1),(1422,0,34,11401,11402,79,79,0,1,17,0),(1424,0,34,11413,11464,353,353,0,8,65,1),(1425,0,34,11414,11414,3,3,0,0,11,1),(1426,0,3,11416,11424,422,506,0,2,82,0),(1427,0,4,11417,11417,1568,1568,0,0,71,0),(1428,1,34,11428,11465,353,353,0,4,34,0),(1432,0,34,11457,11457,353,353,0,0,12,1),(1433,0,34,11458,11458,353,353,0,0,12,1),(1435,0,34,11462,11489,3,3,0,1,30,1),(1436,0,3,11471,11529,2527,370,0,18,239,0),(1437,0,34,11485,11485,3,3,0,0,6,0),(1438,0,34,11486,11486,3,3,0,0,6,0),(1439,0,34,11488,11488,3,3,0,0,12,1),(1440,0,1,11496,11518,3,3,0,7,141,0),(1441,0,1,11497,11497,3,3,0,0,46,0),(1442,0,1,11498,11498,3,3,0,0,59,0),(1443,0,3,11508,11527,5897,5897,0,8,145,0),(1444,0,4,11517,11526,121,1619,0,1,93,0),(1445,0,5,11524,11535,47,3,0,3,150,0),(1446,0,9,11538,11538,154,154,0,0,48,0),(1447,0,9,11539,11539,154,154,0,0,83,0),(1448,0,33,11546,11546,140,140,0,0,62,0),(1449,0,3,11549,11560,5897,5897,0,2,88,0),(1450,0,33,11553,11728,1619,47,0,8,341,0),(1451,0,35,11562,11605,1567,1567,0,1,87,1),(1452,0,35,11563,11606,1567,79,0,3,139,1),(1453,0,35,11564,11601,1567,79,0,7,199,1),(1454,0,35,11565,11607,1567,1567,0,1,105,1),(1455,0,35,11566,11602,1567,79,0,5,189,1),(1456,0,35,11567,11617,1567,484,0,8,363,1),(1457,0,35,11568,11603,1567,79,0,3,171,1),(1458,0,35,11569,11608,1567,79,0,1,234,1),(1459,1,35,11570,11595,3,47,0,3,265,0),(1460,0,9,11571,11571,3,3,0,0,76,0),(1461,1,34,11609,11609,79,79,0,0,10,0),(1462,1,35,11610,11670,79,3,0,25,500,0),(1463,0,33,11633,11644,4827,10,0,8,90,0),(1464,0,1,11646,11821,1567,412,0,4,130,0),(1465,0,1,11647,11647,1567,1567,0,0,19,0),(1466,0,1,11648,11648,1567,1567,0,0,13,0),(1467,0,1,11649,11671,1567,1567,0,2,116,0),(1468,0,1,11650,11650,1567,1567,0,0,19,0),(1469,0,1,11652,11652,1567,1567,0,0,23,0),(1470,0,1,11653,11729,1567,353,0,7,117,0),(1471,0,1,11654,11696,1567,353,0,7,113,0),(1472,0,9,11677,11677,154,154,0,0,68,0),(1473,0,3,11683,11691,6001,370,0,2,94,0),(1474,0,5,11684,11690,122,10,0,1,63,0),(1475,0,33,11685,11692,5200,454,0,3,81,0),(1476,0,33,11689,11689,10,10,0,0,48,1),(1477,0,3,11693,11694,5885,79,0,1,60,0),(1478,0,4,11695,11708,394,394,0,3,80,0),(1490,0,36,11796,11833,428,1619,0,19,315,0),(1480,0,36,11722,11794,1567,6056,0,13,322,1),(1481,0,36,11723,11790,1567,1567,0,17,321,1),(1482,0,36,11724,11810,1567,412,0,15,370,1),(1483,0,36,11725,11791,1567,1567,0,9,312,1),(1484,0,3,11730,11731,6065,154,0,1,69,0),(1485,0,14,11732,11732,154,154,0,0,29,1),(1488,0,36,11765,11775,2657,47,0,3,86,0),(1487,0,36,11740,11741,6024,79,0,1,107,0),(1489,0,36,11793,11795,2657,1567,0,1,94,0),(1491,0,36,11803,11835,454,3,0,4,164,0),(1492,0,36,11809,11816,1245,1567,0,1,71,0),(1493,0,1,11811,11811,1567,1567,0,0,36,0),(1494,0,1,11813,11866,1567,10,0,7,130,0),(1495,0,1,11814,11854,1567,2527,0,8,160,0),(1496,0,1,11815,11842,1567,677,0,1,62,0),(1498,0,9,11858,11858,47,47,0,0,32,0),(1499,0,3,11859,11860,5837,10,0,1,46,0);
/*!40000 ALTER TABLE `ia_smf_topics` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_task`
--

DROP TABLE IF EXISTS `ia_task`;
CREATE TABLE `ia_task` (
  `id` varchar(64) collate latin1_general_ci default NULL,
  `author` varchar(64) collate latin1_general_ci default NULL,
  `user_id` int(11) NOT NULL,
  `source` varchar(64) collate latin1_general_ci default NULL,
  `hidden` tinyint(4) NOT NULL default '1',
  `title` varchar(64) collate latin1_general_ci default NULL,
  `page_name` varchar(64) collate latin1_general_ci default NULL,
  `order` int(11) NOT NULL auto_increment COMMENT 'Used for preserving task order',
  `type` enum('classic','output-only') collate latin1_general_ci default NULL,
  PRIMARY KEY  (`order`),
  UNIQUE KEY `id` (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=314 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_task`
--

LOCK TABLES `ia_task` WRITE;
/*!40000 ALTER TABLE `ia_task` DISABLE KEYS */;
INSERT INTO `ia_task` VALUES ('adunare','anonim',0,'info-arena 1.0',0,'A+B','problema/adunare',1,'classic'),('cmmdc','anonim',0,'info-arena 1.0',0,'CMMDC','problema/cmmdc',2,'classic'),('flip','Mircea Pasoi',0,'info-arena 1.0',0,'Jocul Flip','problema/flip',3,'classic'),('fractii','Mircea Pasoi',0,'info-arena 1.0',0,'Fractii','problema/fractii',4,'classic'),('biti','Mircea Pasoi',0,'info-arena 1.0',0,'Biti','problema/biti',5,'classic'),('perm','Mircea Pasoi',0,'info-arena 1.0',0,'Permutari','problema/perm',6,'classic'),('fact','Cristian George Strat (culeasa din folclor)',0,'info-arena 1.0',0,'Factorial','problema/fact',7,'classic'),('datorii','Cristian George Strat',0,'info-arena 1.0',0,'Datorii','problema/datorii',8,'classic'),('cifra','Mircea Pasoi',0,'info-arena 1.0',0,'Cifra','problema/cifra',9,'classic'),('tabela','Gheorghe Stefan',0,'info-arena 1.0',0,'Tabela','problema/tabela',10,'classic'),('stramosi','Mircea Pasoi',0,'info-arena 1.0',0,'Stramosi','problema/stramosi',11,'classic'),('copaci','Gheorghe Stefan',0,'info-arena 1.0',0,'Copaci','problema/copaci',12,'classic'),('pietre','Gheorghe Stefan',0,'info-arena 1.0',0,'Pietre','problema/pietre',13,'classic'),('petrica','Silviu Ganceanu',0,'info-arena 1.0',0,'Petrica','problema/petrica',14,'classic'),('secventa','Mircea Pasoi',0,'info-arena 1.0',0,'Secventa','problema/secventa',15,'classic'),('perm2','Cristian George Strat',0,'info-arena 1.0',0,'Permutari II','problema/perm2',16,'classic'),('joc','Mircea Pasoi',0,'info-arena 1.0',0,'Joc','problema/joc',17,'classic'),('triunghi','Mircea Pasoi',0,'info-arena 1.0',0,'Triunghi','problema/triunghi',18,'classic'),('sir23','adaptat de Cristian George Strat',0,'info-arena 1.0',0,'Siruri 2-3-monotone','problema/sir23',19,'classic'),('pavare','Mircea Pasoi',0,'info-arena 1.0',0,'Pavare','problema/pavare',20,'classic'),('tort','Gheorghe Stefan',0,'info-arena 1.0',0,'Tort','problema/tort',21,'classic'),('zero','Gheorghe Stefan',0,'info-arena 1.0',0,'Zero','problema/zero',22,'classic'),('perle','Marius Andrei',0,'info-arena 1.0',0,'Perle','problema/perle',23,'classic'),('prim','Dan Popovici',0,'info-arena 1.0',0,'Numere Prime','problema/prim',24,'classic'),('sume','Liviu Ciortea',0,'info-arena 1.0',0,'Sume','problema/sume',25,'classic'),('munte','Dan Popovici',0,'info-arena 1.0',0,'Munte','problema/munte',26,'classic'),('energii','Danci Robert',0,'info-arena 1.0',0,'Energii','problema/energii',27,'classic'),('loto','Mircea Pasoi',0,'info-arena 1.0',0,'Loto','problema/loto',28,'classic'),('secv2','Mircea Pasoi',0,'info-arena 1.0',0,'Secventa 2','problema/secv2',29,'classic'),('lapte','Adrian Vladu',0,'info-arena 1.0',0,'Lapte','problema/lapte',30,'classic'),('secv3','Mircea Pasoi',0,'info-arena 1.0',0,'Secventa 3','problema/secv3',31,'classic'),('traseu','Mircea Pasoi',0,'info-arena 1.0',0,'Traseu','problema/traseu',32,'classic'),('lacate','Dana Lica',0,'info-arena 1.0',0,'Lacate','problema/lacate',33,'classic'),('bool','Adrian Vladu',0,'info-arena 1.0',0,'Bool','problema/bool',34,'classic'),('fractal','Cosmin Negruseri',0,'info-arena 1.0',0,'Fractal','problema/fractal',35,'classic'),('party','Cosmin Negruseri',0,'info-arena 1.0',0,'Party','problema/party',36,'classic'),('cutii','Silviu Ganceanu',0,'info-arena 1.0',0,'Cutii','problema/cutii',37,'classic'),('atac','Silviu Ganceanu',0,'info-arena 1.0',0,'Atac','problema/atac',38,'classic'),('tribute','Mihai Stroe, Silviu Ganceanu',0,'info-arena 1.0',0,'Tribute','problema/tribute',39,'classic'),('coins','Vladu Adrian',0,'info-arena 1.0',0,'Coins','problema/coins',40,'classic'),('zaharel','Mircea Pasoi',0,'info-arena 1.0',0,'Zaharel','problema/zaharel',41,'classic'),('sobo','Silviu Ganceanu',0,'info-arena 1.0',0,'Sobo','problema/sobo',42,'classic'),('xormax','Vladu Adrian',0,'info-arena 1.0',0,'Xor Max','problema/xormax',43,'classic'),('boom','Silviu Ganceanu',0,'info-arena 1.0',0,'Boom','problema/boom',44,'classic'),('petsoft','Silviu Ganceanu',0,'info-arena 1.0',0,'PetSoft','problema/petsoft',45,'classic'),('subsir','Mircea Pasoi',0,'info-arena 1.0',0,'Subsir','problema/subsir',46,'classic'),('text','Adrian Vladu',0,'info-arena 1.0',0,'Text','problema/text',47,'classic'),('trapez','Mircea Pasoi',0,'info-arena 1.0',0,'Trapez','problema/trapez',48,'classic'),('adn','Cosmin Negruseri',0,'info-arena 1.0',0,'ADN','problema/adn',49,'classic'),('barbar','Adrian Vladu',0,'info-arena 1.0',0,'Barbar','problema/barbar',50,'classic'),('iepuri','Mircea Pasoi',0,'info-arena 1.0',0,'Iepuri','problema/iepuri',51,'classic'),('pascal','Dan Popovici',0,'info-arena 1.0',0,'Pascal','problema/pascal',52,'classic'),('secv','Dan Popovici',0,'info-arena 1.0',0,'Secv','problema/secv',53,'classic'),('car','Cosmin Negruseri',0,'info-arena 1.0',0,'Car','problema/car',54,'classic'),('indep','Silviu Ganceanu',0,'info-arena 1.0',0,'Indep','problema/indep',55,'classic'),('cerere','Dan Ionut Fechete',0,'info-arena 1.0',0,'Cerere','problema/cerere',56,'classic'),('rubarba','Adrian Vladu',0,'info-arena 1.0',0,'Rubarba','problema/rubarba',57,'classic'),('barman','Adrian Vladu',0,'info-arena 1.0',0,'Barman','problema/barman',58,'classic'),('cifre','Mircea Pasoi',0,'info-arena 1.0',0,'Cifre','problema/cifre',59,'classic'),('farfurii','Mircea Pasoi',0,'info-arena 1.0',0,'Farfurii','problema/farfurii',60,'classic'),('critice','Silviu Ganceanu',0,'info-arena 1.0',0,'Critice','problema/critice',61,'classic'),('ferma','Mircea Pasoi',0,'info-arena 1.0',0,'Ferma','problema/ferma',62,'classic'),('poligon','Cosmin Silvestru Negruseri',0,'info-arena 1.0',0,'Poligon','problema/poligon',63,'classic'),('bombar','Adrian Vladu',0,'info-arena 1.0',0,'Bombar','problema/bombar',64,'classic'),('cobai','Horatiu Cristurean',0,'info-arena 1.0',0,'Cobai','problema/cobai',65,'classic'),('concert','Andrei Gnczi',0,'info-arena 1.0',0,'Concert','problema/concert',66,'classic'),('perm3','Eugen Neamtiu',0,'info-arena 1.0',0,'Permutari 3','problema/perm3',67,'classic'),('triang','Dimitriu Alexandru',0,'info-arena 1.0',0,'Triang','problema/triang',68,'classic'),('patrate','Negruseri Silvestru Cosmin (problema de la selectia lotului, 200',0,'info-arena 1.0',0,'Patrate','problema/patrate',69,'classic'),('regine','Marius Andrei (problema de la selectia lotului, 2005)',0,'info-arena 1.0',0,'Regine','problema/regine',70,'classic'),('robot','Stefan Ciobaca (problema de la selectia lotului, 2005)',0,'info-arena 1.0',0,'Robot','problema/robot',71,'classic'),('concurs','Ionel Corneliu Gog',0,'info-arena 1.0',0,'Concurs','problema/concurs',72,'classic'),('tri','Stelian Ciurea (problema de la selectia lotului, 2005)',0,'info-arena 1.0',0,'Tri','problema/tri',73,'classic'),('perechi','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Perechi','problema/perechi',74,'classic'),('homm','Mihai Scortaru (finala GInfo 2005)',0,'info-arena 1.0',0,'Heroes of Might & Magic','problema/homm',75,'classic'),('colectie','Cosmin Negruseri, Leonard Crestez (finala GInfo 2005)',0,'info-arena 1.0',0,'Colectie','problema/colectie',76,'classic'),('drumuri','Cosmin Negruseri, Leonard Crestez (finala GInfo 2005)',0,'info-arena 1.0',0,'Drumuri','problema/drumuri',77,'classic'),('tj','Mugurel Ionut Andreica (problema de la selectia lotului, 2005)',0,'info-arena 1.0',0,'Tom & Jerry','problema/tj',78,'classic'),('trapeze','Marius Andrei (problema de la selectia lotului, 2005)',0,'info-arena 1.0',0,'Trapeze','problema/trapeze',79,'classic'),('frac','Filip Cristian Buruiana',0,'info-arena 1.0',0,'Frac','problema/frac',80,'classic'),('tvshow','Silviu Ganceanu (.campion 2005)',0,'info-arena 1.0',0,'TVShow','problema/tvshow',81,'classic'),('pal','Silviu Ganceanu (ONI 2005)',0,'info-arena 1.0',0,'Pal','problema/pal',82,'classic'),('bifo','Silviu Ganceanu (ONI 2005)',0,'info-arena 1.0',0,'Bifo','problema/bifo',83,'classic'),('evantai','Silviu Ganceanu (ONI 2005)',0,'info-arena 1.0',0,'Evantai','problema/evantai',84,'classic'),('algola','Silviu Ganceanu (finala .campion 2005)',0,'info-arena 1.0',0,'Algola','problema/algola',85,'classic'),('camion','Dana Lica (finala .campion 2005)',0,'info-arena 1.0',0,'Camion','problema/camion',86,'classic'),('luna','Patcas Csaba',0,'info-arena 1.0',0,'Luna','problema/luna',87,'classic'),('gard','Mugurel Ionut Andreica (ONI 2002)',0,'info-arena 1.0',0,'Gard','problema/gard',88,'classic'),('gard2','Mugurel Ionut Andreica (Lot 2002)',0,'info-arena 1.0',0,'Gard2','problema/gard2',89,'classic'),('otilia','Silviu Ganceanu (.campion 2005)',0,'info-arena 1.0',0,'Otilia','problema/otilia',90,'classic'),('delay','Mugurel Ionut Andreica (Lot 2002)',0,'info-arena 1.0',0,'Delay','problema/delay',91,'classic'),('gard3','Mugurel Ionut Andreica (Lot 2002)',0,'info-arena 1.0',0,'Gard3','problema/gard3',92,'classic'),('sistem','Mugurel Ionut Andreica (ONI 2002)',0,'info-arena 1.0',0,'Sistem','problema/sistem',93,'classic'),('doipatru','Mugurel Ionut Andreica (Lot 2002)',0,'info-arena 1.0',0,'DoiPatru','problema/doipatru',94,'classic'),('hotel','Mugurel Ionut Andreica (Lot 2002)',0,'info-arena 1.0',0,'Hotel','problema/hotel',95,'classic'),('color','Mugurel Ionut Andreica (Lot 2002)',0,'info-arena 1.0',0,'Color','problema/color',96,'classic'),('asmin','Mugurel Ionut Andreica (ONI 2003)',0,'info-arena 1.0',0,'Asmin','problema/asmin',97,'classic'),('proc','Mugurel Ionut Andreica (ONI 2003)',0,'info-arena 1.0',0,'Proc','problema/proc',98,'classic'),('parcele','Mugurel Ionut Andreica, Mihai Stroe (Lot 2003)',0,'info-arena 1.0',0,'Parcele','problema/parcele',99,'classic'),('soc','Mugurel Ionut Andreica (Lot 2003)',0,'info-arena 1.0',0,'Soc','problema/soc',100,'classic'),('ecu','Mugurel Ionut Andreica (Lot 2003)',0,'info-arena 1.0',0,'Ecu','problema/ecu',101,'classic'),('tri2','Mugurel Ionut Andreica (Lot 2003)',0,'info-arena 1.0',0,'Tri2','problema/tri2',102,'classic'),('lanterna','Mugurel Ionut Andreica (OJI 2004)',0,'info-arena 1.0',0,'Lanterna','problema/lanterna',103,'classic'),('trans','Mugurel Ionut Andreica (ONI 2004)',0,'info-arena 1.0',0,'Trans','problema/trans',104,'classic'),('color2','Mugurel Ionut Andreica (ONI2004)',0,'info-arena 1.0',0,'Color2','problema/color2',105,'classic'),('base3','Mugurel Ionut Andreica (ONI2004)',0,'info-arena 1.0',0,'Base3','problema/base3',106,'classic'),('prefix','Mugurel Ionut Andreica (Stelele Informaticii 2003)',0,'info-arena 1.0',0,'Prefix','problema/prefix',107,'classic'),('comp','Mugurel Ionut Andreica (BOI 2003)',0,'info-arena 1.0',0,'Compania','problema/comp',108,'classic'),('sediu','Mugurel Ionut Andreica (campion 2003)',0,'info-arena 1.0',0,'Sediu','problema/sediu',109,'classic'),('echipe','Mugurel Ionut Andreica (campion 2005)',0,'info-arena 1.0',0,'Echipe','problema/echipe',110,'classic'),('granita','Mugurel Ionut Andreica (campion 2003)',0,'info-arena 1.0',0,'Granita','problema/granita',111,'classic'),('asmax','Mugurel Ionut Andreica (campion 2003)',0,'info-arena 1.0',0,'Asmax','problema/asmax',112,'classic'),('arie','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Arie','problema/arie',113,'classic'),('bile','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Bile','problema/bile',114,'classic'),('muzeu','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Muzeu','problema/muzeu',115,'classic'),('transport','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Transport','problema/transport',116,'classic'),('suma','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Suma','problema/suma',117,'classic'),('poligon2','Mugurel Ionut Andreica (.campion 2003)',0,'info-arena 1.0',0,'Poligon 2','problema/poligon2',118,'classic'),('string','Mugurel Ionut Andreica (.campion 2003)',0,'info-arena 1.0',0,'String','problema/string',119,'classic'),('zoo','Mugurel Ionut Andreica (.campion 2003)',0,'info-arena 1.0',0,'Zoo','problema/zoo',120,'classic'),('numere','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Numere','problema/numere',121,'classic'),('expresii','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Expresii algebrice','problema/expresii',122,'classic'),('calatorie','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Calatorie interplanetara','problema/calatorie',123,'classic'),('razboi','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Razboiul lumilor','problema/razboi',124,'classic'),('divmul','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Divizor si multiplu','problema/divmul',125,'classic'),('palind','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Palindroame','problema/palind',126,'classic'),('linterv','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Lungimi de interval','problema/linterv',127,'classic'),('resturi','Mugurel Andreica',0,'info-arena 1.0',0,'Resturi','problema/resturi',128,'classic'),('cai','Mugurel Andreica',0,'info-arena 1.0',0,'Curse de cai','problema/cai',129,'classic'),('cercuri','Mugurel Andreica',0,'info-arena 1.0',0,'Cercuri','problema/cercuri',130,'classic'),('jarbore','Mugurel Ionut Andreica, Bogdan Piloca',0,'info-arena 1.0',0,'J-Arbore','problema/jarbore',131,'classic'),('geamuri','Giurgea Mihnea',0,'info-arena 1.0',0,'Geamuri','problema/geamuri',132,'classic'),('distante','Mircea Pasoi',0,'info-arena 1.0',0,'Distante','problema/distante',133,'classic'),('zebughil','Negruseri Cosmin',0,'info-arena 1.0',0,'Zebughil','problema/zebughil',134,'classic'),('balans','Mircea Pasoi',0,'info-arena 1.0',0,'Balans','problema/balans',135,'classic'),('dreptunghiuri','Negruseri Cosmin',0,'info-arena 1.0',0,'Dreptunghiuri','problema/dreptunghiuri',136,'classic'),('invers','Mircea Pasoi',0,'info-arena 1.0',0,'Invers','problema/invers',137,'classic'),('reuniune','Mircea Pasoi',0,'info-arena 1.0',0,'Reuniune','problema/reuniune',138,'classic'),('patrate2','Daniel Pasaila',0,'info-arena 1.0',0,'Patrate2','problema/patrate2',139,'classic'),('harta','Stefan Ciobaca & Adrian Diaconu',0,'info-arena 1.0',0,'Taramul Nicaieri','problema/harta',140,'classic'),('adapost','Ciucu Mihai',0,'info-arena 1.0',0,'Adapost','problema/adapost',141,'classic'),('sortari','Vlad Dascalu & Adrian Diaconu',0,'info-arena 1.0',0,'Sortari','problema/sortari',142,'classic'),('ciclu','Berinde Radu',0,'info-arena 1.0',0,'Ciclu','problema/ciclu',143,'classic'),('expr','Berinde Radu',0,'info-arena 1.0',0,'Expr','problema/expr',144,'classic'),('coach','Berinde Radu',0,'info-arena 1.0',0,'Coach','problema/coach',145,'classic'),('insula','Bogdan A. Stoica',0,'info-arena 1.0',0,'Insula','problema/insula',146,'classic'),('sticle','Giurgea Mihnea',0,'info-arena 1.0',0,'Sticle','problema/sticle',147,'classic'),('ben','Silviu Ganceanu (Stelele Informaticii 2005, clasele 9-10)',0,'info-arena 1.0',0,'Ben','problema/ben',148,'classic'),('numere2','Alexandru Mosoi (Stelele Informaticii 2005, clasele 9-10)',0,'info-arena 1.0',0,'Numere 2','problema/numere2',149,'classic'),('soldati','Mugurel Andreica (Stelele Informaticii 2005, clasele 9-10)',0,'info-arena 1.0',0,'Soldati','problema/soldati',150,'classic'),('monezi','Silviu Ganceanu (Stelele Informaticii 2005, clasele 9-10)',0,'info-arena 1.0',0,'Monezi','problema/monezi',151,'classic'),('superp','Marius Dumitran (Stelele Informaticii 2005, clasele 9-10)',0,'info-arena 1.0',0,'SuperP','problema/superp',152,'classic'),('zapada','Alexandru Mosoi (Stelele Informaticii 2005, clasele 9-10)',0,'info-arena 1.0',0,'Zapada','problema/zapada',153,'classic'),('siruri','Alexandru Mosoi (Stelele informaticii 2005, clasele 11-12)',0,'info-arena 1.0',0,'Siruri','problema/siruri',154,'classic'),('dmg','Sorin Stancu Mara (Stelele Informaticii 2005, clasele 11-12)',0,'info-arena 1.0',0,'Dmg','problema/dmg',155,'classic'),('turneu','Florin Manea (Stelele Informaticii 2005, clasele 11-12)',0,'info-arena 1.0',0,'Turneu','problema/turneu',156,'classic'),('reg','Silviu Ganceanu (Stelele Informaticii 2005, clasele 11-12)',0,'info-arena 1.0',0,'Reg','problema/reg',157,'classic'),('santa','Sorin Stancu-Mara (Stelele Informaticii 2005, clasele 11-12)',0,'info-arena 1.0',0,'Santa','problema/santa',158,'classic'),('supersf','Silviu Ganceanu, Alexandru Mosoi (Stelele Informaticii 2005, cla',0,'info-arena 1.0',0,'Supersf','problema/supersf',159,'classic'),('dame','Mircea Pasoi',0,'info-arena 1.0',0,'Dame','problema/dame',160,'classic'),('zc','Adrian Vladu',0,'info-arena 1.0',0,'Zota & Chidil','problema/zc',161,'classic'),('grupuri','Mircea Pasoi',0,'info-arena 1.0',0,'Grupuri','problema/grupuri',162,'classic'),('12perm','Tiberiu Florea',0,'info-arena 1.0',0,'12-Perm','problema/12perm',163,'classic'),('desc','Adrian Diaconu',0,'info-arena 1.0',0,'Descompuneri','problema/desc',164,'classic'),('struti','Filip Cristian Buruiana',0,'info-arena 1.0',0,'Struti','problema/struti',165,'classic'),('camera','Negruseri Cosmin',0,'info-arena 1.0',0,'Camera','problema/camera',166,'classic'),('invsc','Teodorescu Andrei',0,'info-arena 1.0',0,'Invsc','problema/invsc',167,'classic'),('timbre','Bogdan A. Stoica',0,'info-arena 1.0',0,'Timbre','problema/timbre',168,'classic'),('nrtri','Daniel Pasaila',0,'info-arena 1.0',0,'Numarare triunghiuri','problema/nrtri',169,'classic'),('divprim','Adrian Diaconu',0,'info-arena 1.0',0,'Divizori Primi','problema/divprim',170,'classic'),('subsir2','Mircea Pasoi',0,'info-arena 1.0',0,'Subsir 2','problema/subsir2',171,'classic'),('sum','Florea Tiberiu-Lucian',0,'info-arena 1.0',0,'Sum','problema/sum',172,'classic'),('pavare2','Daniel Pasaila',0,'info-arena 1.0',0,'Pavare2','problema/pavare2',173,'classic'),('count','Silviu Ionut Ganceanu',0,'info-arena 1.0',0,'Count','problema/count',174,'classic'),('cowfood','Adrian Vladu',0,'info-arena 1.0',0,'Cowfood','problema/cowfood',175,'classic'),('demolish','Filip Cristian Buruiana',0,'info-arena 1.0',0,'Demolish','problema/demolish',176,'classic'),('nextseq','Silviu Ganceanu',0,'info-arena 1.0',0,'NextSeq','problema/nextseq',177,'classic'),('gfact','Silviu Ganceanu',0,'info-arena 1.0',0,'GFact','problema/gfact',178,'classic'),('matrix','Silviu Ganceanu, Tiberiu Florea',0,'info-arena 1.0',0,'Matrix','problema/matrix',179,'classic'),('nrcuv','Daniel Pasaila',0,'info-arena 1.0',0,'Lista lui Andrei','problema/nrcuv',180,'classic'),('dmin','Daniel Pasaila',0,'info-arena 1.0',0,'Drumuri minime','problema/dmin',181,'classic'),('calcul','Mircea Pasoi',0,'info-arena 1.0',0,'Calcul','problema/calcul',182,'classic'),('popandai','Cosmin Negruseri, Adrian Vladu',0,'info-arena 1.0',0,'Popandai','problema/popandai',183,'classic'),('adapost2','Ciucu Mihai',0,'info-arena 1.0',0,'Adapost 2','problema/adapost2',184,'classic'),('mult','Ciucu Mihai',0,'info-arena 1.0',0,'Mult','problema/mult',185,'classic'),('seti','Mihai Patrascu (ONI 2002)',0,'info-arena 1.0',0,'SETI','problema/seti',186,'classic'),('banana','Roxana Tamplaru, Mihai Patrascu (ONI 2002)',0,'info-arena 1.0',0,'Banana','problema/banana',187,'classic'),('eqs','Mihai Patrascu (ONI 2002)',0,'info-arena 1.0',0,'Ecuatii','problema/eqs',188,'classic'),('sumdiv','Mihai Patrascu (ONI 2002)',0,'info-arena 1.0',0,'Suma divizorilor','problema/sumdiv',189,'classic'),('sortnet','Mihai Patrascu (lot 2002)',0,'info-arena 1.0',0,'Sortnet','problema/sortnet',190,'classic'),('telegraf','Mihai Patrascu (baraj ONI 2003)',0,'info-arena 1.0',0,'Telegraf','problema/telegraf',191,'classic'),('substr','Mihai Patrascu (lot 2003)',0,'info-arena 1.0',0,'Substr','problema/substr',192,'classic'),('trib','Mihai Patrascu (BOI 2003)',0,'info-arena 1.0',0,'Consiliul tribului','problema/trib',193,'classic'),('euro','Mihai Patrascu, Mugurel Ionut Andreica (BOI 2003)',0,'info-arena 1.0',0,'Euro','problema/euro',194,'classic'),('invsort','Mihai Patrascu (baraj ONI 2004)',0,'info-arena 1.0',0,'Invsort','problema/invsort',195,'classic'),('caraibe','Mihai Patrascu (lot 2004)',0,'info-arena 1.0',0,'Caraibe','problema/caraibe',196,'classic'),('farey','Mihai Patrascu (BOI 2003)',0,'info-arena 1.0',0,'Secventa Farey','problema/farey',197,'classic'),('semne','Ciucu Mihai',0,'info-arena 1.0',0,'Semne','problema/semne',198,'classic'),('custi','Dumitriu Vlad',0,'info-arena 1.0',0,'Custi','problema/custi',199,'classic'),('graf','Victor Manz',0,'info-arena 1.0',0,'Graf','problema/graf',200,'classic'),('divk','Filip Cristian Buruiana',0,'info-arena 1.0',0,'Divk','problema/divk',201,'classic'),('lupu','Adrian Diaconu',0,'info-arena 1.0',0,'Lupul Urias si Rau','problema/lupu',202,'classic'),('overlap','Cosmin Negruseri & Adrian Diaconu & Tiberiu Florea',0,'info-arena 1.0',0,'Overlap','problema/overlap',203,'classic'),('iv','Adrian Vladu',0,'info-arena 1.0',0,'Iv','problema/iv',204,'classic'),('robotei','Silviu Ganceanu',0,'info-arena 1.0',0,'Robotei','problema/robotei',205,'classic'),('pscnv','Negruseri Cosmin',0,'info-arena 1.0',0,'PScNv','problema/pscnv',206,'classic'),('arbore','Daniel Pasaila',0,'info-arena 1.0',0,'Arbore','problema/arbore',207,'classic'),('pedefe','Mircea Pasoi',0,'info-arena 1.0',0,'Pedefe','problema/pedefe',208,'classic'),('cercuri2','Bogdan A. Stoica',0,'info-arena 1.0',0,'Cercuri 2','problema/cercuri2',209,'classic'),('sir','Alexandru Dimitriu',0,'info-arena 1.0',0,'Sir','problema/sir',210,'classic'),('minim','Clara Ionescu',0,'info-arena 1.0',0,'Minim','problema/minim',211,'classic'),('spirala','Clara Ionescu',0,'info-arena 1.0',0,'Spirala','problema/spirala',212,'classic'),('figuri','Clara Ionescu',0,'info-arena 1.0',0,'Figuri','problema/figuri',213,'classic'),('jocul','Clara Ionescu',0,'info-arena 1.0',0,'Jocul','problema/jocul',214,'classic'),('subsiruri','Clara Ionescu',0,'info-arena 1.0',0,'Subsiruri','problema/subsiruri',215,'classic'),('numar','Clara Ionescu',0,'info-arena 1.0',0,'Numar','problema/numar',216,'classic'),('domino','Csaba Patcas',0,'info-arena 1.0',0,'Domino','problema/domino',217,'classic'),('popandai2','Negruseri Cosmin',0,'info-arena 1.0',0,'Popandai2','problema/popandai2',218,'classic'),('z','Mihai Pantis',0,'info-arena 1.0',0,'ZParcurgere','problema/z',219,'classic'),('paralelograme','Negruseri Cosmin',0,'info-arena 1.0',0,'Paralelograme','problema/paralelograme',220,'classic'),('sequencequery','Negruseri Cosmin',0,'info-arena 1.0',0,'SequenceQuery','problema/sequencequery',221,'classic'),('biti2','Alexandru Dimitriu',0,'info-arena 1.0',0,'Biti2','problema/biti2',222,'classic'),('aladdin','Negruseri Cosmin',0,'info-arena 1.0',0,'Aladdin','problema/aladdin',223,'classic'),('srevni','Negruseri Cosmin',0,'info-arena 1.0',0,'Srevni','problema/srevni',224,'classic'),('joc2','Negruseri Cosmin',0,'info-arena 1.0',0,'Joc2','problema/joc2',225,'classic'),('lesbulan','Negruseri Cosmin',0,'info-arena 1.0',0,'Lesbulan','problema/lesbulan',226,'classic'),('colorare','Negruseri Cosmin',0,'info-arena 1.0',0,'Colorare','problema/colorare',227,'classic'),('geom','Negruseri Cosmin',0,'info-arena 1.0',0,'Geometrie','problema/geom',228,'classic'),('grazing','Negruseri Cosmin',0,'info-arena 1.0',0,'Grazing','problema/grazing',229,'classic'),('apdm','Negruseri Cosmin',0,'info-arena 1.0',0,'APDM','problema/apdm',230,'classic'),('divizori','Negruseri Cosmin',0,'info-arena 1.0',0,'Divizori','problema/divizori',231,'classic'),('cifru','Stelian Ciurea',0,'info-arena 1.0',0,'Secretul Cifrului','problema/cifru',232,'classic'),('fold','Negruseri Cosmin',0,'info-arena 1.0',0,'Fold','problema/fold',233,'classic'),('hallway','Negruseri Cosmin',0,'info-arena 1.0',0,'Hallway','problema/hallway',234,'classic'),('game','Negruseri Cosmin',0,'info-arena 1.0',0,'Game','problema/game',235,'classic'),('pawns','Negruseri Cosmin',0,'info-arena 1.0',0,'Pawns','problema/pawns',236,'classic'),('biscuiti','Adrian Airinei',0,'info-arena 1.0',0,'Biscuiti','problema/biscuiti',237,'classic'),('invcs','Teodorescu Andrei',0,'info-arena 1.0',0,'Invcs','problema/invcs',238,'classic'),('order','Negruseri Cosmin',0,'info-arena 1.0',0,'Order','problema/order',239,'classic'),('points','Negruseri Cosmin',0,'info-arena 1.0',0,'Points','problema/points',240,'classic'),('aladdin2','Negruseri Cosmin',0,'info-arena 1.0',0,'Aladdin2','problema/aladdin2',241,'classic'),('bmatrix','Negruseri Cosmin',0,'info-arena 1.0',0,'BMatrix','problema/bmatrix',242,'classic'),('password','Negruseri Cosmin',0,'info-arena 1.0',0,'Password','problema/password',243,'classic'),('path','Negruseri Cosmin',0,'info-arena 1.0',0,'Path','problema/path',244,'classic'),('omizi','Emilian Miron (.campion 2005)',0,'info-arena 1.0',0,'Omizi','problema/omizi',245,'classic'),('avere','Emilian Miron (ONI 2005)',0,'info-arena 1.0',0,'Avere','problema/avere',246,'classic'),('acolor','Emilian Miron (Lot 2006)',0,'info-arena 1.0',0,'Acolor','problema/acolor',247,'classic'),('csir','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Csir','problema/csir',248,'classic'),('map','Stancu-Mara Sorin',0,'info-arena 1.0',0,'Map','problema/map',249,'classic'),('panouri','Tucu Galatan (ONI 2006)',0,'info-arena 1.0',0,'Panouri','problema/panouri',250,'classic'),('drumuri2','Emilian Miron (Lot 2005)',0,'info-arena 1.0',0,'Drumuri2','problema/drumuri2',251,'classic'),('mine','Stancu-Mara Sorin',0,'info-arena 1.0',0,'Mine','problema/mine',252,'classic'),('arbfind','Emilian Miron (Lot 2006)',0,'info-arena 1.0',0,'Arbfind','problema/arbfind',253,'classic'),('bcolor','Emilian Miron (Lot 2006)',0,'info-arena 1.0',0,'Bcolor','problema/bcolor',254,'classic'),('senat','Cristian Cadar',0,'info-arena 1.0',0,'Senat','problema/senat',255,'classic'),('vila','Cristian Cadar',0,'info-arena 1.0',0,'Vila','problema/vila',256,'classic'),('puternic','Cristian Cadar',0,'info-arena 1.0',0,'Puternic','problema/puternic',257,'classic'),('catun','Catalin Francu',0,'info-arena 1.0',0,'Catun','problema/catun',258,'classic'),('alpin','Cristian Cadar',0,'info-arena 1.0',0,'Alpin','problema/alpin',259,'classic'),('euler','Catalin Francu',0,'info-arena 1.0',0,'Euler','problema/euler',260,'classic'),('note','Catalin Francu',0,'info-arena 1.0',0,'Note','problema/note',261,'classic'),('bilete','Catalin Francu',0,'info-arena 1.0',0,'Bilete','problema/bilete',262,'classic'),('free','Din Folclor',0,'info-arena 1.0',0,'Free','problema/free',263,'classic'),('patrol','Filip Cristian Buruiana',0,'info-arena 1.0',0,'Patrol','problema/patrol',264,'classic'),('pscpld','Negruseri Cosmin',0,'info-arena 1.0',0,'PScPld','problema/pscpld',265,'classic'),('sah','Din Folclor',0,'info-arena 1.0',0,'Sah','problema/sah',266,'classic'),('plimbare','Din Folclor',0,'info-arena 1.0',0,'Plimbare','problema/plimbare',267,'classic'),('treid','Negruseri Cosmin',0,'info-arena 1.0',0,'TreiD','problema/treid',268,'classic'),('abc','Liviu Ciortea',0,'info-arena 1.0',0,'ABC','problema/abc',269,'classic'),('oras','Din Folclor',0,'info-arena 1.0',0,'Oras','problema/oras',270,'classic'),('gold','Filip Cristian Buruiana & Adrian Diaconu',0,'info-arena 1.0',0,'Gold','problema/gold',271,'classic'),('poly','Vlad Dumitriu',0,'info-arena 1.0',0,'Poly','problema/poly',272,'classic'),('bridge','Tiberiu Savin',0,'info-arena 1.0',0,'Bridge','problema/bridge',273,'classic'),('secv4','Paul Dan-Baltescu',0,'info-arena 1.0',0,'Secventa 4','problema/secv4',274,'classic'),('parcare','Vlad Saveluc',0,'info-arena 1.0',0,'Parcare','problema/parcare',275,'classic'),('eq','Vlad Berteanu',0,'info-arena 1.0',0,'Easy Query','problema/eq',276,'classic'),('avd','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'AVD','problema/avd',277,'classic'),('ct','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'CT','problema/ct',278,'classic'),('swap','Mugurel Ionut Andreica, Vlad Slavici',0,'info-arena 1.0',0,'Swap','problema/swap',279,'classic'),('int','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Int','problema/int',280,'classic'),('obj','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Obj','problema/obj',281,'classic'),('1expr','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'1expr','problema/1expr',282,'classic'),('hanoi4','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Hanoi4','problema/hanoi4',283,'classic'),('cc','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Cc','problema/cc',284,'classic'),('joc3','Daniel Pasaila',0,'info-arena 1.0',0,'Joc3','problema/joc3',285,'classic'),('geometry','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Geometry','problema/geometry',286,'classic'),('itree','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Itree','problema/itree',287,'classic'),('hprob','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Hprob','problema/hprob',288,'classic'),('nodiv','Adrian Vladu',0,'info-arena 1.0',0,'Nodiv','problema/nodiv',289,'classic'),('arbciclu','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Arbore de cicluri','problema/arbciclu',290,'classic'),('java','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Gandaci Java','problema/java',291,'classic'),('rf','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Roy-Floyd','problema/rf',292,'classic'),('biomech','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Biomech','problema/biomech',293,'classic'),('emm','Mugurel Ionut Andreica',0,'info-arena 1.0',0,'Expresii min-max','problema/emm',294,'classic'),('zeap','Mircea Pasoi',0,'info-arena 1.0',0,'Zeap','problema/zeap',295,'classic'),('noroc','Adrian Vladu',0,'info-arena 1.0',0,'Noroc','problema/noroc',296,'classic'),('nr','Mircea Pasoi',1,'.campion 2006-2007, Runda 1',0,'Nr','problema/nr',297,'classic'),('perm4','Mircea Pasoi',1,'.campion 2006-2007, Runda 2',0,'Permutari 4','problema/perm4',298,'classic'),('criptare','Mircea Pasoi',1,'.campion 2006-2007, Runda 4',0,'Criptare','problema/criptare',299,'classic'),('elimin','Filip Cristian Buruiana',256,'preONI 2007, Runda 1',0,'Elimin','problema/elimin',300,'classic'),('diviz','Filip Cristian Buruiana',256,'preONI 2007, Runda 1',0,'Diviz','problema/diviz',301,'classic'),('pachete','Mircea Pasoi',1,'preONI 2007, Runda 1',0,'Pachete','problema/pachete',302,'classic'),('radiatie','Mircea Pasoi',1,'preONI 2007, Runda 1',0,'Radiatie','problema/radiatie',304,'classic'),('patrate3','Daniel Pasaila',48,'preONI 2007',0,'Patrate3','problema/patrate3',308,'classic'),('test-p1','Cristian George Strat',13,'ad-hoc',0,'test-p1','problema/test-p1',309,'classic'),('1-sir','Florea Tiberiu',66,'preONI 2007, runda 1',0,'1-sir','problema/1-sir',305,'classic'),('triplete','Mircea Pasoi',1,'preONI 2007, Runda 1',0,'Triplete','problema/triplete',306,'classic'),('aprindere','Daniel Pasaila',48,'preONI 2007',0,'Aprindere','problema/aprindere',307,'classic'),('maxsecv','Daniel Pasaila',48,'Unirea2007',0,'Maxsecv','problema/maxsecv',310,'classic'),('amenzi','Adrian Diaconu',961,'Unirea 2007',0,'Amenzi','problema/amenzi',311,'classic'),('chernel','Adrian Vladu',18,'Unirea 2007',0,'Chernel','problema/chernel',312,'classic'),('secv5','Mircea Pasoi',1,'Unirea 2007, clasele 11-12',0,'Secventa 5','problema/secv5',313,'classic');
/*!40000 ALTER TABLE `ia_task` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_textblock`
--

DROP TABLE IF EXISTS `ia_textblock`;
CREATE TABLE `ia_textblock` (
  `name` varchar(64) collate latin1_general_ci NOT NULL default '',
  `title` varchar(64) collate latin1_general_ci default NULL,
  `timestamp` datetime NOT NULL,
  `text` longtext collate latin1_general_ci,
  `user_id` int(10) unsigned NOT NULL,
  `security` varchar(64) collate latin1_general_ci default NULL,
  PRIMARY KEY  (`name`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_textblock`
--

LOCK TABLES `ia_textblock` WRITE;
/*!40000 ALTER TABLE `ia_textblock` DISABLE KEYS */;
INSERT INTO `ia_textblock` VALUES ('preoni-2005/runda-1','preONI 2005 (Runda 1)','2006-11-25 03:08:57','h1. preONI 2005 (Runda 1)\r\n\r\nConcursul s-a desfasurat Duminica, 23 ianuarie 2005, ora 15:00. Pe parcursul celor 4 ore de concurs participantii au avut de rezolvat 3 probleme. \r\n\r\nSolutiile problemelor le puteti gasi \"aici\":preoni-2005/runda-1/solutii\r\n\r\nh2. Clasele 9-10 (\'Clasament\':preoni-2005/runda-1/clasament-9-10)\r\n\r\n!>preoni-2005/runda-1?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni51a\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':preoni-2005/runda-1/clasament-11-12)\r\n\r\n!>preoni-2005/runda-1?logo2.gif!\r\n\r\n== Tasks(round_id=\"preoni51b\" pager_style=\"none\") ==',961,'protected'),('preoni-2005/runda-2','preONI 2005 (Runda 2)','2006-11-25 03:09:10','h1. preONI 2005 (Runda 2)\r\n\r\nConcursul s-a desfasurat Miercuri, 23 februarie, ora 16:00. Pe parcursul celor 4 ore de concurs participantii au avut de rezolvat 3 probleme. \r\n\r\nSolutiile problemelor le puteti gasi \"aici\":preoni-2005/runda-2/solutii\r\n\r\nh2. Clasele 9-10 (\'Clasament\':preoni-2005/runda-2/clasament-9-10)\r\n\r\n!>preoni-2005/runda-2?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni52a\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':preoni-2005/runda-2/clasament-11-12)\r\n\r\n!>preoni-2005/runda-2?logo2.gif!\r\n\r\n== Tasks(round_id=\"preoni52b\" pager_style=\"none\") ==',961,'protected'),('preoni-2005/runda-3','preONI 2005 (Runda 3)','2006-11-25 03:09:36','h1. preONI 2005 (Runda 3)\r\n\r\nConcursul s-a desfasurat Duminica, 20 martie la ora 10:00. Pe parcursul celor 4 ore de concurs participantii au avut de rezolvat 3 probleme. \r\n\r\nSolutiile problemelor le puteti gasi \"aici\":preoni-2005/runda-3/solutii\r\n\r\nh2. Clasele 9-10 (\'Clasament\':preoni-2005/runda-3/clasament-9-10)\r\n\r\n!>preoni-2005/runda-3?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni53a\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':preoni-2005/runda-3/clasament-11-12)\r\n\r\n!>preoni-2005/runda-3?logo2.gif!\r\n\r\n== Tasks(round_id=\"preoni53b\" pager_style=\"none\") ==',961,'protected'),('usaco-oct-2005-divizia-gold','USACO oct 2005, divizia GOLD','2006-11-22 02:29:02','h1. USACO oct 2005, divizia GOLD\r\n\r\n(Categoria _Competitii_, autor(i) _Florea Tiberiu_)\r\n\r\nCa de obicei, USACO debuteaza in luna octombrie cu un concurs prin care oricine se poate califica la o divizie superioara celei in care se afla.\r\n\r\nRomania a avut $8$ concurenti care s-au calificat (sau recalificat) la divizia GOLD, fiind depasita in acest clasament doar de China ({$16$}) si SUA ({$10$}). Bineinteles, acest clasament nu este foarte relevant, deoarece multi dintre cei calificati deja au preferat sa nu participe sau sa nu ia concursul foarte in serios.\r\n\r\nElevii romani care au obtinut punctajul necesar pentru (re)calificare sunt:\r\n\r\n* Andrei Teodorescu (andreit1)\r\n* Vladu Adrian (azotlic1)\r\n* Andrei Blanaru (blanaru1)\r\n* Sorin Fagateanu (cyronon1)\r\n* Ionel Corneliu Gog (gogione1)\r\n* Tiberiu Florea (greco2)\r\n* Pasoi Mircea (mircea_1)\r\n* Vlad Berteanu (vladcyb1)\r\n\r\nProba a constat in $2$ probleme de nivel mediu care trebuiau rezolvate in $2$ ore.\r\n\r\nh2. Skiing\r\n\r\nPrima rezolvare care ne vine in minte citind o astfel de problema este transformarea matricii intr-un graf cu R * C noduri si calcularea drumului minim dintre nodurile ({$1, 1$}) si ({$R, C$}). O observatie destul de evidenta este ca toate muchiile care intra intr-un nod (a, b) vor avea acelasi cost, adica {$V * 2 ^ H{~1,1~} - H{~a,b~}^$}. Deoarece implementarea obisnuita a algoritmului Dijkstra are complexitatea $O (N^2^ + M)$ considerand $N$ = numarul de pozitii si $M$ numarul de muchii dintre acestea ({$N = R * C, M = 4 * R * C - 2 * (R + C)$}) va trebui implementata varianta in care se foloseste o coada de prioritate pentru nodurile care nu au fost explorate deja: implementand varianta cu heap-uri vom obtine complexitatea {$O((N + M) * lg N)$}, care se incadreaza in timp.\r\n\r\nPentru cei care nu sunt familiari cu aceasta varianta a algoritmului, ea arata cam asa:\r\n\r\np(pre). D{~sursa~} <- 0\r\nheap_sz = 1\r\nheap{~heap_sz~} <- sursa\r\npentru $i$ de la $1$ la $N$\r\n    daca i != sursa\r\n        D{~i~} <- oo\r\n        heap_sz <- heap_sz + 1\r\n        heap[heap_sz] <- i\r\ncat timp heap_sz > 0\r\n    x <- extrage_min (heap)\r\n    daca x = destinatie\r\n        returneaza D{~x~}\r\n    altfel\r\n        pentru i de la 1 la N\r\n            daca D{~i~} > D{~x~} + cost (x, i)\r\n                descreste_cheie (i, D{~x~} + cost (x,i))\r\n\r\nFiecare nod este extras cel mult o data din heap, si pentru fiecare muchie este apelata cel mult o data functia descreste_cheie. Fiecare dintre aceste operatii se efectueaza in {$O(lg N)$}, de aici rezultand complexitatea dorita.\r\n\r\nDe asemenea, putea fi aplicata o alta varianta a algoritmului Dijkstra, care profita mai mult de specificul problemei: In afara de vectorul estimarilor distantelor pana la fiecare nod, se memoreaza si nodul cu estimarea minima de pe fiecare din cele $R$ linii. Astfel, in momentul in care se extrage fiecare nod, cautam minimul in acest vector de dimensiune {$R$}, iar apoi reactualizam valoarea liniei pe care se afla nodul curent. Complexitatea acestui algoritm este {$O(N * R)$}, adica {$O(R^2^ * C)$}.\r\n\r\nIn implementarea oricaruia dintre acesti algoritmi trebuiau avute in vedere eventualele probleme cu precizia calculelor; o idee buna era ca numai costul final sa se inmulteasca cu {$V$}.\r\n\r\nh2. Flying right\r\n\r\nAceasta problema poate fi rezolvata cu ajutorul unui algoritm greedy, ideea nu este greu de gasit sau demonstrat, insa la implementare pot aparea unele probleme. In primul rand trebuie sa remarcam ca cele doua parti ale problemei se vor rezolva independent una de cealalta, drumurile se vor imparti in $2$ multimi (cele de dimineata, si cele de seara), si se va aplica aceeasi rezolvare pentru fiecare din cele doua multimi, raspunsul final fiind suma celor doua rezultate partiale. Rezolvarea urmatoare trateaza calcularea rezultatului optim pentru drumurile de dimineata.\r\n\r\nPentru fiecare din cele $N$ ferme tinem o lista de grupuri care doresc sa plece din orasul respectiv si sortam aceste liste crescator dupa indicele destinatiei fiecarui grup. Parcurgem in ordine cele $N$ ferme, memorand numarul si destinatiile vacilor care se afla la un moment dat in avion, sortate in ordine descrescatoare. In momentul in care am ajuns la ferma {$i$}, primul lucru pe care trebuie sa il facem este sa dam jos vacile care au ajuns la destinatie, incrementand corespunzator solutia de pana atunci. Evident, vacile care coboara la ferma respectiva se vor afla pe ultimele pozitii in ordinea descrisa din avion. Urmatorul pas este sa luam in avion din vacile care pleaca de la ferma $i$ pana cand acestea sunt epuizate sau capacitatea avionului este saturata. Daca au mai ramas vaci care nu au avut loc in avion, atata timp cat putem lua o vaca a carei destinatie este mai apropiata decat cea mai departata dintre destinatiile vacilor care se afla deja in avion, consideram ca vaca respectiva din avion nu a fost luata deloc, si ca alocam locul ei noii vaci, care va cobori mai repede.\r\n\r\nEste usor de vazut ca algoritmul de mai sus produce o solutie optima, insa implementarea sa nu este foarte lejera. Putem folosi urmatoarea metoda ({$v$} este un vector in care retinem destinatiile vacilor care se afla in avion, sortate descrescator):\r\n\r\np(pre). sol = 0, nr <- 0\r\npentru i de la 1 la N\r\n    cat timp nr > 0 si v{~nr~} = i\r\n        sol <- sol + 1\r\n        nr <- nr - 1\r\n        pentru j <- 1, j &le; C si j &le; nr vaci ce asteapta sa plece de la ferma i\r\n            nr <- nr + 1\r\n        v{~nr + 1~} = distanta celei de-a j-a vaci (in ordinea crescatoare a destinatiilor) de la ferma i\r\n        sorteaza v\r\n        pastreaza primele maxim C pozitii din v\r\n\r\nLa fiecare pas, vectorul $v$ poate fi sortat folosind {@qsort (stdlib.h)@} sau {@sort (algorithm)@}. Este necesar sa adaugam in $v$ doar primele $C$ vaci de la ferma {$i$}, deoarece daca o vaca nu este intre primele $C$ din multimea vacilor de la ferma {$i$}, este evident ca nu va fi nici intre primele $C$ din reuniunea acestei multimi cu multimea vacilor aflate deja in avion.\r\n\r\nSa recapitulam pasii algoritmului, alaturi de complexitatea fiecaruia dintre ei:\r\n\r\n* sortarea tuturor grupurilor dupa destinatie: $O(K * lg K)$\r\n* parcurgerea grupurilor si inserarea in listele corespunzatoare: $O(K)$\r\n* parcurgerea fermelor de la 1 la N, aplicand procedeul descris: $O(N * C * lg C)$\r\n\r\nAsadar, complexitatea totala a algoritmului este de {$O(K * lg K + N * C * lg C)$}, dand un timp de rulare rezonabil si o implementare fara mari batai de cap.\r\n\r\n',1,'public'),('problema/homm','Heroes of Might & Magic','2006-12-22 06:06:15','==Include(page=\"template/taskheader\" task_id=\"homm\")==\r\n\r\nHarta Erathiei este data sub forma unui caroiaj cu $M$ linii si $N$ coloane. Terenul este impartit in celule care pot fi accesibile (au valoarea 0) sau inaccesibile (au valoare diferita de 0). Sir Christian doreste sa ajunga din celula de coordonate $(x{~1~}, y{~1~})$ unde a avut loc ultima batalie in celula $(x{~2~}, y{~2~})$ unde se afla Capitala regatului sau. Pentru aceasta el are la dispozitie $K$ mutari. O mutare consta in deplasarea din celula curenta intr-o celula invecinata (pe orizontala sau verticala, nu si pe diagonala).\r\nVa trebui sa determinati numarul variantelor pe care le poate alege Sir Christian. Un drum trebuie sa contina cel mult $K$ mutari, iar Sir Christian poate trece de oricate ori prin aceeasi celula, inclusiv prin celulele $(x{~1~}, y{~1~})$ si $(x{~2~}, y{~2~})$.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $homm.in$ se afla doua numere naturale $M, N$ si $K$, reprezentand numarul liniilor si coloanelor caroiajului, respectiv numarul mutarilor pe care Sir Christian le are la dispozitie; aceste numere sunt separate printr-un spatiu. Urmatoarele $M$ linii contin cate $N$ numere intregi, separate printr-un spatiu, reprezentand elementele caroiajului. Pe ultima linie se vor afla patru numere intregi, reprezentand valorile $x{~1~}, y{~1~}, x{~2~}$ si $y{~2~}$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $homm.out$ se va scrie un singur numar care va reprezenta numarul total al drumurilor posibile.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; M, N &le; 100$\r\n* $1 &le; K &le; 20$\r\n* Numarul total al drumurilor este intotdeauna mai mic decat $1.000.000.000$\r\n* Toate coordonatele sunt date in ordinea linie ({$x$}), coloana ({$y$}).\r\n\r\nExemple\r\n\r\ntable(example). |_. homm.in |_. homm.out |\r\n| 5 5 10 \r\n0 0 0 0 0\r\n0 2 0 3 0\r\n0 0 1 0 0\r\n0 2 0 0 0\r\n0 0 0 0 0\r\n1 1 5 5 | 34 |\r\n| 5 5 10 \r\n0 0 4 0 0\r\n0 2 0 3 0\r\n4 0 1 0 0\r\n0 2 0 0 0\r\n0 0 0 0 0\r\n1 1 5 5 | 0&nbsp; |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"homm\")==',1142,'task: homm'),('problema/colectie','Colectie','2006-11-11 19:51:20','==Include(page=\"template/taskheader\" task_id=\"colectie\")==\r\n\r\nTudor s-a gandit ca, deja, colectia lui de CD-uri si DVD-uri a devenit destul de impresionanta si, pentru a organiza mai usor discurile, vrea sa le numeroteze cu etichete. El vrea sa cumpere cutii care contin etichete cu cifre.\r\n\r\nLa magazinul din apropiere se gasesc k asemenea pachete care contin etichete cu cateva cifre de $0$, cateva cifre de $1$ si asa mai departe (pachete diferite pot avea continut diferit).\r\n\r\nTudor ar vrea sa cumpere cateva dintre pachete si sa poata forma din etichete toate numerele de la $1$ la $K$ ({$K$} fiind numarul de CD-uri si DVD-uri din colectie).\r\n\r\nO conditie pentru a realiza etichetarea este ar fi sa nu ramana etichete care nu sunt folosite pentru ca Tudor nu ar avea ce face cu ele. Acest lucru nu este tot timpul posibil. Daca este posibil, atunci ne intereseaza solutia care foloseste un numar minim de pachete.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $colectie.in$ se afla doua numere naturale $N$ si $K$, reprezentand numarul de pachete de la magazin, respectiv numarul de CD-uri si DVD-uri din colectia lui Tudor. Pe urmatoarele $N$ linii se vor afla cate zece numere intregi separate prin spatii; linia $i + 1$ contine numarul de etichete cu cifrele $0, 1, ... 9$ din pachetul $i$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire colectie.out se va scrie pe prima linie valoarea $1$ daca exista o solutie, sau valoarea $0$ daca problema nu are solutie. Daca problema are solutie atunci pe urmatoarea linie va fi scris numarul $L$ al pachetelor folosite intr-o solutie optima, iar urmatoarea linie va contine $L$ numere intregi, reprezentand pachetele alese.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 32$\r\n* $1 &le; K &le; 100.000.000$\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. colectie.in |_. colectie.out |\r\n|4 11\r\n0 1 0 0 0 0 1 1 0 0\r\n1 2 1 1 1 1 0 0 0 0\r\n0 1 0 0 0 0 0 0 1 1\r\n0 2 0 0 0 0 1 1 1 1\r\n| 1\r\n2\r\n2 4 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"colectie\")==',18,'task: colectie'),('problema/drumuri2','Drumuri2','2006-11-12 16:20:49','==Include(page=\"template/taskheader\" task_id=\"drumuri2\")==\r\n\r\nSe da un graf orientat fara circuite cu $N$ noduri (numerotate de la $1$ la {$N$}) si $M$ arce.\r\nUn drum in graf este o succesiune de unul sau mai multe varfuri $D=(x{~1~}, x{~2~}, ..., x{~k~})$ astfel incat pentru orice i din {${1, 2, ..., k-1}$}, exista arcul ({$x{~i~}, x{~i+1~}$}).\r\nNumim acoperire a grafului o multime de drumuri din graf, cu proprietatea ca fiecare varf al grafului apartine cel putin unui drum din multime.\r\nNu este necesar ca drumurile dintr-o acoperire sa fie disjuncte (nici relativ la varfuri, nici relativ la arce).\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul minim de drumuri cu care se poate acoperi un graf dat.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul de intrare $drumuri.in$ se afla pe prima linie numerele naturale $N$ si {$M$}, separate printr-un spatiu.\r\nPe fiecare dintre urmatoarele $M$ linii se gaseste cate o pereche de numere naturale {$i$}, $j$ $(1 &le; i, j &le; N)$ separate printr-un spatiu, cu semnificatia ca exista arc de la varful $i$ la varful {$j$}.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $drumuri.out$ va contine o singura linie reprezentand numarul minim de drumuri cu care se poate acoperi graful din fisierul de intrare.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 100$\r\n* $1 &le; M &le; 5000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. drumuri.in |_. drumuri.out |\r\n| 7 7\r\n1 2\r\n7 2\r\n2 3\r\n2 4\r\n3 5\r\n4 5\r\n4 6\r\n| 2 |\r\n\r\nh3. Explicatii\r\n\r\n$D1: 1->2->3->5$\r\n$D2: 7->2->4->6$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"drumuri2\")==',13,'task: drumuri2'),('problema/acolor','Acolor','2006-11-24 16:02:01','==Include(page=\"template/taskheader\" task_id=\"acolor\")==\r\n\r\nOmida-agent Smith s-a saturat sa tot distruga arborii si acum isi dezvolta simtul artistic - ii place mult mai mult sa-i coloreze.\r\nDe fiecare data cand vrea sa creeze o noua arbo-pictura isi ia cu el cele $K$ creioane colorate, isi alege un arbore din gradina si porneste la lucru.\r\nArborele ales de Smith este alcatuit din $N$ noduri, are ca radacina nodul $R$ si o forma potrivita pentru pictura:\r\n\r\n* fiecare nod are cel mult doua crengi care duc spre doua noduri: unul la stanga si/sau unul la dreapta;\r\n* intre oricare doua noduri exista un drum unic format din crengi distincte, pe care omida se poate plimba pentru a ajunge de la un nod la celalalt;\r\n* nodurile din subarborele stang al unui nod sunt toate plasate mai la stanga decat acesta, iar cele din subarborele drept sunt toate mai la dreapta, de aceea nodurile au fost etichetate de la $1$ la $N$ de la cel mai din stanga pana la cel mai din dreapta.\r\n\r\nOmida a observat ca picturile sale sunt frumoase doar daca respecta unele reguli de baza pe care le-a citit intr-o carte:\r\n\r\n* orice nod trebuie sa fie colorat cu exact una dintre cele $K$ culori;\r\n* un nod trebuie sa fie colorat diferit fata de parintele dinspre radacina (adica fata de nodul care preceda nodul respectiv atunci cand omida se plimba pe drumul de la radacina la nod);\r\n* privit din exterior arborele trebuie sa fie colorat diferit de la stanga la dreapta: orice nod are o culoare diferita de cel mai apropiat nod la stanga de el si fata de cel mai apropiat nod la dreapta (cu alte cuvinte culoarea nodului etichetat cu $i$ trebuie sa fie diferita de culoarea nodurilor etichetate cu $i-1$, $i+1$).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine pentru un arbore dat in cate picturi frumoase (picturi care sa respecte criteriile din enunt) poate fi transformat acesta. Deoarece numarul cerut poate fi foarte mare, este suficient sa aflati restul impartirii la $10007$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $acolor.in$ va contine pe prima linie numerele intregi $N, R, K$ separate prin cate un spatiu. Pe urmatoarele $N$ linii este descrisa structura arborelui. Mai exact, pe linia $i+1$ vor exista doua numere $st{~i~}, dr{~i~}$ separate printr-un spatiu, reprezentand nodul fiu spre stanga si respectiv nodul fiu spre dreapta al nodului $i$. Daca un nod nu are fiu spre stanga si/sau fiu spre dreapta atunci numarul corespunzator va fi $0$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $acolor.out$ va contine o singura linie pe care va fi scris numarul de picturi frumoase care se pot obtine pentru arborele dat.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 < N &le; 100 000, 1 &le; R &le; N, 1 &le; K &le; 100$\r\n* In $40%$ din teste sunt indeplinite relatiile $N &le; 100$ si $K &le; 10$\r\n* In $60%$ din teste sunt indeplinite relatiile $N &le; 400 si K &le; 150$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. acolor.in |_. acolor.out |_. figura  |\r\n| 9 5 4\r\n0 0\r\n1 3\r\n0 4\r\n0 0\r\n2 6\r\n0 7\r\n0 9\r\n0 0\r\n8 0\r\n| 3601\r\n| !problema/acolor?image001.gif! |\r\n| 3 1 2\r\n0 3\r\n0 0\r\n2 0\r\n| 0\r\n| &nbsp; |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"acolor\")==',1142,'task: acolor'),('problema/note','Note','2006-11-22 02:49:10','==Include(page=\"template/taskheader\" task_id=\"note\")==\r\n\r\nO partitura muzicala este scrisa pe $V$ voci, fiecare voce avand cate $N$ note. Spunem ca un solfegiu se brodeste peste aceasta partitura daca solfegiul are tot lungimea de $N$ note si fiecare din notele solfegiului coincide cu nota de pe pozitia corespunzatoare a partiturii, pe cel putin una dintre voci.\r\nDe exemplu, solfegiul\r\n$mi re la do si fa sol la$\r\nse brodeste partiturii pe $2$ voci cu $8$ note\r\n$mi re do do si fa fa si$\r\n$sol si la do sol mi sol la$\r\n, pentru ca notele $1, 2, 5$ si $6$ din solfegiu sunt cantate conform vocii $I$, iar notele $3, 7$ si $8$ sunt cantate dupa vocea a doua. Se observa ca nota a patra ({$do$}) este cantata conform ambelor voci.\r\nSpunem ca un solfegiu de o lungime oarecare falseaza in $K$ locuri daca este nevoie de exact $K$ modificari asupra lui pentru a-l face sa se brodeasca peste partitura. O modificare poate fi:\r\n1) Stergerea unei note din solfegiu\r\n2) Adaugarea unei note in solfegiu\r\n3) Inlocuirea unei note in solfegiu.\r\nDe exemplu, solfegiul\r\n$mi re sol do si fa si$\r\nfalseaza in doua locuri, pentru ca trebuie sa modificam nota $sol$ in $la$ si sa inseram inca un $fa$ intre $si$ si $fa$ pentru a-l aduce la forma:\r\n$mi re la do si fa fa si$\r\ncare se brodeste peste partitura.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine daca un solfegiu dat se brodeste peste o partitura data, sau, in caz contrar, care este numarul minim de locuri in care falseaza. Notele vor fi reprezentate prin numere de la $1$ la $100$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $note.in$ va avea urmatoarea structura: pe prima linie se vor afla $V$ si $N$, separate de exact un spatiu, numarul de voci si numarul de note. Urmatoarele $V$ linii contin cate $N$ numere, simbolizand partitura cu $V$ voci si $N$ note pe fiecare voce. Numerele vor fi naturale si intre $1$ si $100$. Linia $V+2$ va contine numarul $M$ de note ale solfegiului. Linia $V+3$ va contine $M$ numere naturale cuprinse in intervalul $[1, 100]$, reprezentand notele solfegiului.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $note.out$ va contine numarul minim de locuri in care solfegiul falseaza, in functie de partitura data. Daca solfegiul se brodeste peste partitura numarul afisat va fi $0$.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; V &le; 512$\r\n* $1 &le; M, N &le; 1024$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. note.in |_. note.out |\r\n| 2 8\r\n  3 2 1 1 7 4 4 7\r\n  5 7 6 1 5 3 5 6\r\n  7\r\n  3 2 5 1 7 4 7\r\n| 2 |\r\n\r\nh3. Explicatii\r\n\r\nNota a 3a din solfegiu se va inlocui cu 1 sau cu 6, iar intre ultimele doua note se va adauga una din notele 4 sau 5.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"note\")==',1,'task: note'),('problema/bilete','Bilete','2006-11-24 15:59:21','==Include(page=\"template/taskheader\" task_id=\"bilete\")==\r\n\r\nIntr-o mare metropola a unei tari din SE Europei inca se circula fara sa se plateasca biletele... Biletele de autobuz din orasul respectiv au o grila de $N x N$ patratele, dintre care aparatele de taxat composteaza exact $K$ patratele. Biletul poate fi introdus in aparat numai cu un capat (celalalt capat fiind prins in cotor), dar poate fi introdus fie pe fata, fie pe dos. In acest fel, unele din configuratiile posibile de K gauri in grila de $N x N$ sunt oglindiri stanga - dreapta ale altor configuratii. Pentru $N = 3$ si $K = 2$, biletele de mai jos sunt oglindiri unul pentru celalalt (patratelele negre se considera compostate):\r\n\r\n!problema/bilete?bilete.jpg!\r\n\r\nUn blatist inveterat face colectie de bilete perforate si doreste sa catalogheze toate configuratiile posibile de gauri, ignorand insa oglindirile (pentru ca teoretic reprezinta aceeasi configuratie). In acest scop, el codifica fiecare configuratie printr-un sir de forma $l{~1~}c{~1~}]l{~2~}c{~2~}...l{~k~}c{~k~}$, unde ({$l{~i~}, c{~i~}$}) sunt coordonatele gaurii a $i$-a relativ la coltul din stanga-sus al biletului. Gaurile sunt deci enumerate de la stanga la dreapta si de sus in jos. Daca blatistul intalneste doua configuratii care sunt una oglindirea celeilalte, dintre cele doua el va clasifica numai pe cea care este minim lexicografica. De exemplu, dintre cele doua bilete de mai sus, el il va pastra pe cel cu codul $1123$, pentru ca, alfabetic, este mai mic.\r\n\r\nh2. Cerinta\r\n\r\nSa se tipareasca in ordine lexicografica (alfabetica) codurile biletelor pe care le catalogheaza blatistul.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $bilete.in$ se vor afla doua numere naturale $N$ si $K$, dimensiunea unui bilet, respectiv numarul de gauri pe care le poate da compostorul din orice autobuz al metropolei. Cele doua numere sunt despartite de exact un spatiu.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bilete.out$ va contine toate configuratiile posibile care sunt pastrate de catre blatist, ordonate alfabetic.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 9$\r\n* $1 &le; K &le; 3$\r\n* Orice tentativa de a nu plati bilet se sanctioneaza cu amenda\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bilete.in |_. bilete.out |\r\n| 3 2\r\n| 1112\r\n1113\r\n1121\r\n1122\r\n1123\r\n1131\r\n1132\r\n1133\r\n1221\r\n1222\r\n1231\r\n1232\r\n2122\r\n2123\r\n2131\r\n2132\r\n2133\r\n2231\r\n2232\r\n3132\r\n3133 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bilete\")==',1142,'task: bilete'),('problema/frac','Frac','2006-11-12 13:21:02','==Include(page=\"template/taskheader\" task_id=\"frac\")==\r\n\r\nPatratel este mare pasionat de fractii. Intr-o zi el se gandeste sa scrie pe o foaie de hartie, in ordine crescatoare, toate fractiile ireductibile cu numitorul $N$. Observand insa la timp ca sunt o infinitate de astfel de fractii, el nu se mai oboseste si doreste sa afle doar a $P$-a fractie din sirul la care s-a gandit.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine numaratorul celei de a $P$-a fractii din sirul construit dupa regulile de mai sus.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $frac.in$ contine doua numere intregi $N$ si $P$, separate prin cate un spatiu, avand semnificatia descrisa in enunt.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului $frac.out$ contine un numar natural care reprezinta numaratorul celei de a $P$-a fractii din sirul fractiilor ireductibile cu numitorul $N$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 12 000 000 000$ ( $12$ miliarde )\r\n* $1 &le; P &le; 10^14^$\r\n* Se garanteaza ca rezultatul nu depaseste $2^61^$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. frac.in |_. frac.out |\r\n| 12 5 | 13 |\r\n\r\nh3. Explicatie\r\n\r\nFractiile sirului sunt: $1/12, 5/12, 7/12, 11/12, 13/12, 17/12$, etc. A $5$-a fractie din acest sir este $13/12$ si are numaratorul $13$.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"frac\")==',1,'task: frac'),('problema/pal','Pal','2006-11-11 22:01:43','==Include(page=\"template/taskheader\" task_id=\"pal\")==\r\n\r\nPrintul Algorel este in incurcatura din nou: a fost prins de Spanul cel Negru in incercarea sa de a o salva pe printesa si acum este inchis in Turnul cel Mare. Algorel poate evada daca gaseste combinatia magica cu care poate deschide poarta turnului. Printul stie cum se formeaza aceasta combinatie magica: trebuie sa utilizeze toate cifrele scrise pe usa turnului pentru a obtine doua numere palindroame, astfel incat suma lor sa fie minima, iar aceasta suma este combinatia magica ce va deschide usa. Primul numar palindrom trebuie sa aiba cel putin $L$ cifre, iar cel de-al doilea poate avea orice lungime diferita de $0$. Numerele palindroame formate nu pot incepe cu cifra $0$. Acum interveniti dumneavoastra in poveste, fiind prietenul sau cel mai priceput in algoritmi. Prin noul super-telefon al sau, printul transmite numarul de aparitii a fiecarei cifre de pe usa turnului precum si lungimea minima $L$ a primului numar, iar dumneavoastra trebuie sa-i trimiteti cat mai repede numerele cu care poate obtine\r\ncombinatia magica.\r\n\r\nh2. Cerinta\r\n\r\nAvand datele necesare, aflati doua numere palindroame cu care se poate obtine combinatia magica.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $pal.in$ contine un numar intreg $L$ reprezentand lungimea minima a primului numar. Urmeaza 10 linii: pe linia $i+2$ se va afla un numar intreg reprezentand numarul de aparitii ale cifrei $i$, pentru $i$ cu valori de la $0$ la $9$.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului de iesire $pal.out$ contine primul numar palidrom, iar cea de-a doua linie contine cel de-al doilea numar palindrom. Daca exista mai multe solutii se va scrie doar una dintre ele.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* In total vor fi cel mult $100$ de cifre\r\n* $1 &le; L < 100$ si $L$ va fi mai mic decat numarul total de cifre\r\n* Pentru datele de test va exista intotdeauna solutie: se vor putea forma din cifrele scrise pe usa turnului doua numere care incep cu o cifra diferita de $0$, iar primul numar sa aiba cel putin $L$ cifre\r\n* Un numar este palindrom daca el coincide cu rasturnatul sau. De exemplu $12321$ si $7007$ sunt numere palindroame, in timp ce $109$ si $35672$ nu sunt.\r\n* Pentru $30%$ dintre teste, numarul total de cifre va fi cel mult $7$; pentru alte $40%$ din teste numarul total de cifre va fi cel mult $18$, iar pentru restul de $30%$ din teste numarul total de cifre va fi mai mare sau egal cu $30$\r\n* Fiecare linie din fisierul de intrare si din fisierul de iesire se termina cu marcaj de sfarsit de linie.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. pal.in |_. pal.out |\r\n| 5 \r\n  3\r\n  2\r\n  3\r\n  0\r\n  0\r\n  0\r\n  0\r\n  0\r\n  0\r\n  0\r\n| 10001\r\n  222 |\r\n\r\nh3. Explicatii\r\n\r\nPentru acest exemplu avem L = 5, 3 cifre de 0, 2 cifre de 1 si 3 cifre de 2. Cifrele de la 3 la 9 lipsesc de pe usa turnului.\r\nCele doua palindroame cu care se genereaza combinatia magica sunt 10001 si 222. Combinatia magica va fi suma acestora si anume 10223 (care este suma minima pe care o putem obtine).\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"pal\")==',15,'task: pal'),('problema/camion','Camion','2006-11-11 17:09:24','==Include(page=\"template/taskheader\" task_id=\"camion\")==\r\n\r\nLa firma la care lucreaza Gigel exista $M$ tipuri de camioane, din fiecare tip existand $N$ exemplare. Gigel aseaza camioanele firmei pe $N$ randuri, asezand pe fiecare coloana numai camioane de acelasi tip. Se formeaza astfel o matrice in care liniile sunt numerotate de sus in jos de la $1$ la $N$, iar coloanele sunt numerotate de la stanga la dreapta de la $1$ la $M$.\r\n\r\nIn fiecare noapte vine o banda de hoti. Seful bandei anunta: \"in noaptea aceasta vom fura toate camioanele care se afla in zona dreptunghiulara avand coltul stanga-sus pe linia $x{~1~}$ si coloana $y{~1~}$, iar coltul opus pe linia $x{~2~}$ si coloana $y{~2~}$.\r\n\r\nIn dimineata urmatoare, Gigel vede acest lucru, si \"acopera\" furtul: pe fiecare linie in care exista spatii libere deplaseaza spre stanga toate camioanele care se afla in dreapta locului liber ramas.\r\n\r\nDe exemplu, pentru $N = 3$ si $M = 5$ initial avem urmatoarea amplasare:\r\n$1 2 3 4 5$\r\n$1 _*2 3*_ 4 5$\r\n$1 _*2 3*_ 4 5$\r\n\r\nIn prima noapte hotii fura camioane, din dreptunghiul cu coltul stanga-sus in linia $2$,coloana $2$ si coltul dreapta-jos linia $3$ coloana $3$. Astfel, in ziua urmatoare, dupa ce Gigel deplaseaza camioanele, amplasarea este urmatoarea:\r\n$_*1 2*_ 3 4 5$\r\n$_*1 4*_ 5$\r\n$_*1 4*_ 5$\r\n\r\nDaca in a doua noapte hotii fura din nou din dreptunghiul cu coltul stanga-sus in linia $1$, coloana $1$ si coltul dreapta-jos in linia $3$, coloana $2$, dupa deplasarile facute ziua de Gigel, amplasarea este urmatoarea:\r\n$3 4 5$\r\n$5$\r\n$5$\r\n\r\nh2. Cerinta\r\n\r\nCunoscand cate tipuri de camioane exista la firma initial, pe cate randuri au fost asezate, numarul $K$ de zile in care au loc furturi si coordonatele dreptunghiurilor din care fura hotii in fiecare noapte, determinati ce tipuri de camioane se afla pe o anumita coloana din amplasarea finala.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $camion.in$ contine pe prima linie $4$ numere naturale: $N M K$ si $C$, reprezentand numarul de randuri pe care au fost asezate camioanele, numarul de coloane, numarul de nopti in care vor fura hotii camioane, respectiv numarul coloanei pentru care se doreste sa se afle ce tipuri de camioane contine la final. Pe fiecare dintre urmatoarele $K$ linii se vor afla cate $4$ numere naturale. Pe linia $i+1$ se afla $x{~1~} y{~1~} x{~2~} y{~2~}$, {$(x{~1~},y{~1~})$} reprezentand linia si coloana coltului stanga-sus, iar {$(x{~2~},y{~2~})$} linia si coloana coltului dreapta-jos al dreptunghiului din care fura hotii in noaptea $i$. Numerele situate pe aceeasi linie sunt separate prin cate un spatiu.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $camion.out$ va contine $N$ linii, pe fiecare cate un numar intreg. Numarul de pe linia $i$ va reprezenta tipul camionului de pe linia $i$ si coloana $C$, dupa $K$ zile. In caz ca pe linia $i$ nu se gaseste nici un camion, se va afisa valoarea $0$ pe linia respectiva.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $1 &le; N &le; 600$\r\n* $1 &le; C &le; M &le; 600$\r\n* $0 &le; K &le; 30000$\r\n\r\nNu este obligatoriu ca dreptunghiul din care se va efectua un furt sa contina camioane in fiecare loc.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. camion.in |_. camion.out |\r\n| 3 5 3 1\r\n2 2 3 3\r\n1 1 3 2\r\n1 2 3 4\r\n| 3\r\n5\r\n5 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"camion\")==',18,'task: camion'),('problema/perle','Perle','2006-11-12 15:39:19','==Include(page=\"template/taskheader\" task_id=\"perle\")==\r\n\r\nGranita nu se trece usor. Asta pentru ca Balaurul Arhirel (mare pasionat de informatica) nu lasa pe nimeni sa treaca decat dupa ce raspunde la niste intrebari!\r\n\r\nIn acea tara exista $3$ tipuri de perle normale (le vom nota cu {$1$}, {$2$} si {$3$}) si $3$ tipuri de perle magice (le vom nota cu {$A$}, {$B$} si {$C$}). Perlele magice sunt deosebite prin faptul ca se pot transforma in alte perle (una sau mai multe, normale sau magice).\r\n\r\nPerla magica de tipul $A$ se poate transforma in orice perla normala (una singura).\r\n\r\nPerla magica de tipul $B$ se poate transforma intr-o perla normala de tipul $2$ si una magica de tipul {$B$}, sau intr-o perla normala de tipul {$1$}, una magica de tipul {$A$}, una normala de tipul {$3$}, una magica de tipul {$A$} si una magica de tipul {$C$}.\r\n\r\nPerla magica de tipul {$C$} se poate transforma intr-o perla normala de tipul {$2$} sau intr-o perla normala de tipul {$3$}, una magica de tipul {$B$} si una magica de tipul {$C$} sau intr-o perla normala de tipul {$1$}, una normala de tipul {$2$} si una magica de tipul {$A$}.\r\n\r\nCa sa rezumam cele de mai sus putem scrie:\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {$A -> 1 | 2 | 3$}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {$B -> 2B | 1A3AC$}\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {$C -> 2 | 3BC | 12A$}\r\n\r\nBalaurul Arhirel ne lasa la inceput sa ne alegem o perla magica (una singura), iar apoi folosind numai transformarile de mai sus trebuie sa obtinem un anumit sir de perle normale. Cand o perla magica se transforma, perlele din stanga si din dreapta ei raman la fel (si in aceeasi ordine). De asemenea ordinea perlelor rezultate din transformare este chiar cea prezentata mai sus.\r\n\r\nDe exemplu, daca balaurul ne cere sa facem sirul de perle {$21132123$}, putem alege o perla magica de tipul {$B$} si urmatorul sir de transformari: {$B$} -> {$2B$} -> {$21A3AC$} -> {$21A3A12A$} -> {$21132123$}.\r\n\r\nDeoarece Balaurul nu are prea multa rabdare, el nu ne cere decat sa spunem daca se poate sau nu obtine sirul respectiv de perle.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine pentru fiecare sir de intrare daca se poate obtine prin transformarile de mai sus sau nu (alegand orice prima perla magica, la fiecare sir).\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $perle.in$ are urmatoarea structura: pe prima linie numarul {$N$}, reprezentand numarul de siruri din fisierul de intrare. Urmeaza $N$ linii; a $i$-a linie dintre cele $N$ descrie sirul {$i$}, printr-o succesiune de numere naturale despartite de cate un spatiu. Primul numar reprezinta lungimea sirului, {$L{~i~}$}, iar urmatoarele {$L{~i~}$} numere sunt tipurile de perle normale, in ordine, de la stanga la dreapta.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $perle.out$ va contine $N$ linii. Pe linia $i$ se va scrie un singur numar $1$ sau $0$ ({$1$} daca se poate obtine sirul al $i$-lea si $0$ daca nu se poate).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 < N < 11$\r\n* $0 < L{~i~} < 10 001$, pentru $i$ de la $1$ la $N$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. perle.in|_. perle.out|\r\n|3\r\n8 2 1 1 3 2 1 2 3\r\n2 2 2\r\n1 3\r\n|1\r\n0\r\n1|\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"perle\")==',256,'task: perle'),('problema/gard','Gard','2006-11-12 13:45:53','==Include(page=\"template/taskheader\" task_id=\"gard\")==\r\n\r\nO echipa de $K$ muncitori a fost angajata sa vopseasca un gard format din $N$ scanduri numerotate de la $1$ la $N$, de la stanga spre dreapta. Fiecare muncitor $i (1 &le; i &le; K)$ se aseaza in fata scandurii $S{~i~}$ si poate vopsi numai un interval compact (adica numerele de ordine ale scandurilor din interval sunt consecutive) avand maxim $L{~i~}$ scanduri, interval care trebuie sa contina scandura $S{~i~}$. Pentru fiecare scandura vopsita, acesta este platit cu suma $P{~i~}$. Din motive de eficienta, oricare 2 muncitori din echipa trebuie sa vopseasca intervale de scanduri disjuncte (adica oricare scandura a gardului poate fi vopsita de cel mult un membru al echipei).\r\nFiind conducatorul echipei de muncitori, dumneavoastra doriti sa determinati pentru fiecare membru al echipei intervalul de scanduri pe care acesta va trebui sa il vopseasca, astfel incat castigul total sa fie maxim. Castigul total este egal cu suma castigurilor realizate de fiecare membru al echipei. Castigul realizat de fiecare muncitor este egal cu numarul de scanduri vopsite de acesta inmultit cu $P{~i~}$ (pentru muncitorul cu numarul $i$).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care determina castigul maxim obtinut de cei $K$ muncitori.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $gard.in$ contine:\r\n\r\ntable(example). |gard.in | Semnificatie |\r\n| N K N \r\n L{~1~} P{~1~} S{~1~} \r\n L{~2~} P{~2~} S{~2~} \r\n ... \r\n L{~K~} P{~K~} S{~K~} | N - numarul de scanduri; K - numarul de muncitori \r\n L{~i~} - numarul maxim de scanduri ce pot fi vopsite de muncitorul cu numarul $i$ \r\n P{~i~} - suma primita de muncitorul $i$ pentru fiecare scandura vopsita de acesta \r\n S{~i~} - scandura din gard in fata careia se aseaza muncitorul i |\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $gard.out$ veti afisa castigul maxim obtinut de intreaga echipa de muncitori.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 16.000$\r\n* $1 &le;K &le; 100$\r\n* $1 &le; P{~i~} &le; 10.000$\r\n* $1 &le; L{~i~},S{~i~} &le; N$\r\n* Toate numerele $S{~i~}$ vor fi distincte.\r\n* Nu trebuie vopsite neaparat toate cele $N$ scanduri ale gardului.\r\n* Este permis ca unul sau mai multi dintre membrii echipei sa nu vopseasca nici o scandura, caz in care scandura in fata careia s-au asezat initial poate fi vopsita, eventual, de catre alt muncitor.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. gard.in |_. gard.out |\r\n| 8 4\r\n3 2 2\r\n3 2 3\r\n3 3 5\r\n1 1 7 | 17 |\r\n\r\nh3. Explicatie\r\n\r\nMuncitorul $1$ vopseste intervalul de scanduri $[1, 2]$; muncitorul $2$ vopseste intervalul de scanduri $[3, 4]$; muncitorul $3$ vopseste intervalul de scanduri $[5, 7]$; muncitorul $4$ nu vopseste nici o scandura.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"gard\")==',1,'task: gard'),('problema/proc','Proc','2006-11-12 14:30:28','==Include(page=\"template/taskheader\" task_id=\"proc\")==\r\n\r\n\r\nO aplicatie ce trebuie executata pe un calculator multi-procesor consta din $N$ fragmente de cod independente, ce pot fi rulate in paralel. Fiecare fragment trebuie executat in totalitate pe un singur procesor. Din dorinta de a paraleliza cat mai mult aplicatia, fragmentele de cod au dimensiuni mici si, in consecinta, timpi de executie mici. Mai precis, executia fiecarui fragment dureaza UNUL sau DOUA cicluri de ceas pe un procesor de tipul Pentium IV.\r\n\r\nSistemul pe care urmeaza sa fie executata aplicatia consta din $P$ procesoare. Spre deosebire de majoritatea sistemelor de acest fel, insa, cele $P$ procesoare au viteze de executie diferite. Primul procesor este un Pentium IV si este cel mai rapid. Al doilea procesor este de doua ori mai lent decat primul, al treilea de trei ori mai lent ... al $i$-lea procesor este de $i$ ori mai incet decat primul. In aceste conditii, timpul de executie al fiecarui fragment de cod difera, in functie de procesorul pe care va fi executat. Sa prespunem ca un segment de cod are timpul de executie $T$ (unde $T$ este $1$ sau {$2$}) pe primul procesor. Atunci pe un procesor $i$, timpul sau de executie va fi $i*T$.\r\n\r\nh2. Cerinta\r\n\r\nStiind ca fragmentele de cod pot fi executate in orice ordine si pe orice procesor si ca orice procesor poate executa, la un moment dat, un singur fragment de cod, determinati timpul minim dupa care se va termina executia aplicatiei (adica a tuturor fragmentelor de cod). Timpul dupa care se termina aplicatia este egal cu maximul dintre timpii dupa care fiecare procesor redevine disponibil. Timpul dupa care un procesor redevine disponibil este egal cu suma timpilor de executie a fragmentelor de cod rulate pe procesorul respectiv.\r\n\r\nh2. Date de intrare\r\n\r\nPrima (si singura) linie a fisierului de intrare $proc.in$ contine trei numere intregi, separate prin spatii: $N$ - numarul de fragmente de cod, $K$ - numarul de fragmente de cod care au timpul de executie pe un Pentium IV egal cu $1$ (implicit, $N-K$ au timpul de executie egal cu $2$) si $P$ - numarul de procesoare ale sistemului.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul $proc.out$ va contine o singura linie pe care se afla timpul minim dupa care se termina de executat aplicatia.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 &le; K &le; N &le; 1.000.000.000$\r\n* $1 &le; P &le; 65.535$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. proc.in |_. proc.out |\r\n| 4 3 2 | 4 |\r\n\r\nh3. Explicatie\r\n\r\nPe primul procesor se executa un fragment de cod cu timpul de executie (calculat pe un Pentium IV) egal cu $1$ si un fragment de cod cu timpul de executie egal cu $2$ => timpul dupa care acest procesor devine disponibil este $1*1 + 1*2 = 3$. Pe al doilea procesor se executa doua fragmente de cod cu timpul de executie (calculat pe un Pentium IV) egal cu $1$ => timpul dupa care acest procesor devine disponibil este $2$ [numarul de fragmente] * $(2*1)$ [timpul de executie al fiecarui fragment pe procesorul $2$] = $4$.\r\n==Include(page=\"template/taskfooter\" task_id=\"proc\")==',15,'task: proc'),('problema/joc2','Joc2','2007-01-15 16:47:04','==Include(page=\"template/taskheader\" task_id=\"joc2\")==\r\n\r\nDoi participanti mananca alternant din niste tablete de ciocolata dupa urmatoarele reguli:\r\n\r\n# taie o tableta in doua, taietura trebuie sa fie paralela cu una din laturile tabletei si trebuie sa nu taie patratelele de ciocolata\r\n# poate sa rupa si sa manance orice linie sau coloana de patratele care nu se afla pe marginea tabletei\r\n# poate sa rupa si sa manance toate patratelele de pe marginea tabletei, cu conditia ca tableta ramasa sa aiba cel putin dimensiunea {$1 x 1$}\r\n\r\nNici una dintre aceste trei mutari nu poate fi efectuata asupra unei tablete de dimensiune {$1 x 1$}.\r\nPierde jucatorul care nu mai poate efectua nici o mutare.\r\n\r\nh2. Date de intare\r\n\r\nIn fisierul de intrare $joc2.in$ se va afla numarul $N$ de tablete, iar pe urmatoarele $N$ linii se afla perechi de numere intregi care reprezinta dimensiunile tabletelor.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $joc2.out$ va contine un singur numar intreg, care reprezinta numarul de moduri in care poate face prima mutare astfel incat sa existe o strategie ca sa poata castiga partida.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100$\r\n* dimensiunile tabletelor sunt cuprinse intre $1$ si $100$\r\n* primul jucator muta intotdeauna primul\r\n* se presupune ca ambii participanti joaca optim\r\n* mutare este identificata prin tableta asupra careia se efectueaza, prin tip, si prin linia/coloana pe care o afecteaza.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. joc2.in |_. joc2.out |\r\n| 2\r\n1 2\r\n2 2 | 0 |\r\n\r\nh3. Explicatie\r\n\r\nLa prima mutare, primul jucator poate sa rupa fie prima tableta in doua, obtinandu-se astfel doua tablete de $1$ patratel si una de $4$ patratele.\r\nLa a doua mutare, al doilea jucator poate rupe in doua (fie orizontal fie vertical) tableta de $4$ patratele, obtinandu-se $2$ tablete de $2$ patratele.\r\nLa a treia mutare, primul jucator poate sa rupa in doua una dintre cele $2$ tablete de $2$ patratele, obtinandu-se astfel doua tablete de $1$ patratel si una de $2$ patratele.\r\nLa a patra mutare, al doilea jucator poate rupe in doua singura tableta de $2$ patratele care a mai ramas, obtinandu-se astfel doua tablete de $1$ patratel.\r\nPrimul jucator nu mai poate efectua nici o mutare.\r\n\r\nO alta varianta de joc ar putea fi:\r\nLa prima mutare, primul jucator poate rupe in doua (orizontal sau vertical) tableta de $4$ patratele, obtinandu-se astfel trei tablete de $2$ patratele.\r\nLa a doua mutare, al doile jucator poate sa rupa in doua una dintre cele $3$ tablete de $2$ patratele, obtinandu-se astfel doua tablete de $1$ patratel si $2$ de $2$ patratele.\r\nLa a treia mutare, primul jucator poate sa rupa in doua una dintre cele $2$ tablete de $2$ patratele, obtinandu-se astfel doua tablete de $1$ patratel si una de $2$ patratele.\r\nLa a patra mutare, al doilea jucator poate rupe in doua singura tableta de $2$ patratele care a mai ramas, obtinandu-se astfel doua tablete de $1$ patratel.\r\nPrimul jucator nu mai poate efectua nici o mutare.\r\n\r\nIn concluzie indiferent ce muta primul jucator la prima mutare, acesta va pierde partida de fiecare data. \r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"joc2\")==',18,'task: joc2'),('problema/delay','Delay','2006-11-11 23:19:39','==Include(page=\"template/taskheader\" task_id=\"delay\")==\r\n\r\nGigel a cumparat $N$ calculatoare cu care vrea sa deschida un Internet Cafe. Pentru aceasta, el trebuie sa conecteze toate calculatoarele in retea, in asa fel incat oricare doua calculatoare sa poata comunica intre ele, direct sau indirect. Comunicatia dintre calculatoare se realizeaza prin intermediul cablurilor de legatura. Un cablu leaga doua calculatoare, iar transferul de date prin cablu se poate realiza in ambele sensuri. Fiind la inceput si neavand prea multi bani, Gigel a legat calculatoarele intre ele astfel incat intre oricare doua calculatoare exista un singur traseu pe care se pot transmite date.\r\nCurand si-a dat seama ca transferul de date se realizeaza cu viteza foarte mica. Acest lucru se datoreaza faptului ca fiecare pachet de date care trece prin calculatorul $i$ este pus sa astepte un timp {$T{~i~}$}. In aceste conditii, timpul dupa care un pachet de date ajunge de la un calculator la altul este egal cu suma timpilor de asteptare ai fiecarui calculator de pe traseu (inclusiv ai calculatoarelor sursa si destinatie).\r\nDin cand in cand, configuratia anumitor calculatoare este modificata si timpii de asteptare corespunzatori acelor calculatoare se schimba. Cum Gigel are grija foarte mare de calculatoarele sale, el trebuie sa fie mereu informat in legatura cu starea retelei. Mai precis, el trebuie sa poata afla repede care este timpul de transmitere a unui pachet de date intre oricare doua calculatoare din reteaua sa.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care trateaza in mod eficient urmatoarele doua tipuri de operatii:\r\n\r\n* tipul 1: modificarea timpului de asteptare al unui calculator\r\n* tipul 2: determinarea timpului de transmitere a unui pachet de date intre doua calculatoare specificate.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $delay.in$ se afla numarul $N$ de calculatoare. Pe fiecare dintre urmatoarele $N$ linii se afla cate un numar intreg {$T{~i~}$}, reprezentand timpul initial de asteptare al calculatorului corespunzator. Pe urmatoarele $N-1$ linii se afla cate doua numere intregi $a$ si {$b$}, reprezentand numerele a doua calculatoare legate printr-un cablu direct. Pe urmatoarea linie se afla numarul intreg {$M$}, reprezentand numarul de operatii descrise in continuare. Fiecare dintre urmatoarele $M$ linii contine cate $3$ numere intregi separate prin spatii: {$a b c$}.\r\n\r\n* Daca {$a=1$}, atunci $b$ reprezinta numarul de ordine al unui calculator nou configurat, iar $c$ reprezinta noul timp de asteptare al calculatorului $b$\r\n* Daca {$a=2$}, atunci $b$ si $c$ reprezinta numerele de ordine a doua calculatoare diferite, iar programul va trebui sa afiseze in fisierul de iesire timpul de transmitere a unui pachet de date intre calculatoarele $b$ si $c$\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $delay.out$ veti afisa, pe cate o linie separata, timpii determinati in cazul fiecarei operatii de tipul {$2$}, in ordinea in care sunt intalnite in fisierul de intrare. Atunci cand calculati timpul de transmitere a unui pachet de date intre doua calculatoare, trebuie sa considerati timpii de asteptare de la momentul respectiv (care sunt determinati de valorile initiale sau de operatiile de tipul $1$ descrise in fisierul de intrare inaintea operatiei curente).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 16.000$\r\n* $0 &le; T{~i~} &le; 1.000$\r\n* $2 &le; M &le; 200.000$\r\n* Calculatoarele sunt numerotate de la $1$ la $N$\r\n* In fisierul de intrare va exista cel putin o operatie de tipul $2$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. delay.in |_. delay.out |\r\n| 5\r\n1\r\n2\r\n3\r\n4\r\n5\r\n1 2\r\n1 3\r\n2 4\r\n3 5\r\n6\r\n2 1 4\r\n2 3 1\r\n1 1 100\r\n2 1 4\r\n2 2 4\r\n2 2 3\r\n| 7\r\n4\r\n106\r\n6\r\n105 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"delay\")==',961,'task: delay'),('problema/gard3','Gard3','2006-11-12 16:37:05','==Include(page=\"template/taskheader\" task_id=\"gard3\")==\r\n\r\nFermierul Ion mai avea o ferma in forma de poligon convex cu $N$ laturi. Intr-o buna zi, el se hotaraste s-o imparta in $K$ regiuni, de asemenea poligoane convexe. Dupa impartire, el va folosi fiecare zona intr-un anumit scop (de exemplu, in zona $1$ va planta vita de vie, in zona $2$ va creste vaci etc.) Pentru aceasta, el va construi $K-1$ garduri. Fiecare gard va fi un segment care va uni doua varfuri din poligon. Gardurile nu se vor intersecta decat, eventual, in varfurile poligonului.\r\nInainte de a se apuca de treaba, fermierul Ion doreste sa afle in cate moduri poate imparti ferma sa in $K$ regiuni (pentru a le examina si a alege un anumit mod de impartire).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care, pentru valorile $N$ si $K$ date, va afisa numarul de moduri in care fermierul Ion poate imparti ferma sa in $K$ regiuni.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $gard3.in$ contine pe prima linie numerele naturale $N$ si {$K$}, separate printr-un spatiu.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $gard3.out$ se va afisa numarul de moduri in care se poate imparti ferma in $K$ regiuni.\r\n\r\nh2. Restrictii\r\n\r\n* $3 &le; N &le; 50$\r\n* $1 &le; K &le; N-2$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. gard3.in |_. gard3.out |\r\n| 5 2 | 5 |\r\n\r\nh3. Explicatie\r\n\r\nSe construieste un singur gard. Acesta va uni una dintre  perechile de varfuri: \r\n$(1, 3) (1, 4) (2, 4) (2, 5) (3, 5)$.\r\n\r\ntable(example). |_. gard3.in |_. gard3.out |\r\n| 10 7 | 5005 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"gard3\")==',15,'task: gard3'),('problema/sistem','Sistem','2006-11-12 14:53:40','==Include(page=\"template/taskheader\" task_id=\"sistem\")==\r\n\r\nIntr-un judet exista $N$ orase, numerotate de la $1$ la $N$. Fiecare dintre cele $N$ orase ale judetului este legat de exact alte 2 orase, prin strazi bidirectionale. Si mai ciudat este faptul ca, in cadrul acestui sistem stradal, nu este intotdeauna posibil sa ajungi din orice oras in oricare alt oras mergand pe strazi. Oricum, locuitorii judetului sunt mandri de acest sistem al lor si sunt de parere ca nu mai exista altul la fel. Dumneavoastra vreti sa le demonstrati contrariul si pentru aceasta vreti sa calculati cate sisteme stradale distincte cu proprietatea de mai sus exista. Doua sisteme sunt considerate distincte daca exista cel putin o strada intre o pereche de orase $i$ si $j$ in cadrul primului sistem, care nu exista in cadrul celui de-al doilea.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa calculeze cate sisteme stradale distincte exista.\r\n\r\nh2. Date de intrare\r\n\r\nDin fisierul $sistem.in$ veti citi valoarea intreaga $N$, reprezentand numarul de orase ale judetului.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $sistem.out$ veti afisa o valoare intreaga, reprezentand numarul de sisteme stradale distincte, cu proprietatea ca orice oras este legat prin strazi directe de exact alte 2 orase.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; N &le; 100$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. sistem.in|_. sistem.out|_. sistem.in|_. sistem.out|\r\n|4|3|6|70|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sistem\")==',256,'task: sistem'),('problema/doipatru','DoiPatru','2006-11-12 00:07:47','==Include(page=\"template/taskheader\" task_id=\"doipatru\")==\r\n\r\n\r\nMembrii Lotului National de Informatica sunt foarte mandri de noul joc inventat de ei, pe care l-au denumit asemanator cu o problema de la Olimpiada Internationala de Informatica din anul 2001, care le-a placut foarte mult. Astfel, jocul se numeste DoiPatru.\r\n\r\nPentru acest joc se folosesc $N$ gramezi, fiecare continand cel putin $0$ si cel mult $4$ bile. Numarul total de bile din toate gramezile este $2N$. Doi jucatori muta alternativ. Atunci cand ii vine randul, fiecare jucator este obligat sa efectueze o mutare valida.\r\n\r\nO mutare valida consta din alegerea a doua gramezi, dintre care prima gramada are mai multe bile decat cea de a doua. Jucatorul ia o bila din prima gramada si o muta in cealalta. Mutarea se considera valida, doar daca numarul de bile rezultat in a doua gramada dupa mutarea bilei nu este mai mare decat numarul de bile ramas in prima gramada.\r\n\r\nJocul se termina atunci cand nu mai poate fi efectuata nici o mutare valida (daca va ganditi putin, veti constata ca acest lucru se intampla atunci cand fiecare gramada contine doua bile).\r\n\r\nCastigatorul jocului este desemnat cel care detine mai multe gramezi la sfarsitul jocului. Bineinteles, daca cei doi jucatori detin un numar egal de gramezi, jocul se considera a fi remiza.\r\n\r\nUn jucator detine o gramada daca gramada are doua bile, iar acest numar (de doua bile) a rezultat in urma unei mutari efectuate de jucatorul respectiv. De exemplu, daca un jucator alege o gramada cu $4$ bile si una cu o bila, in urma efectuarii mutarii, el va detine cea de-a doua gramada (care va avea doua bile), dar prima nu va apartine deocamdata nici unuia dintre jucatori. Daca alege o gramada cu $3$ bile si una cu $0$ bile, jucatorul va deveni proprietarul primei gramezi, deoarece, in urma mutarii efectuate, gramada respectiva va ramane cu doua bile. In cazul in care alege o gramada cu $3$ bile si una cu o bila, dupa efectuarea mutarii, el va detine ambele gramezi (amandoua au acum doua bile).\r\n\r\nDaca un jucator este proprietarul unei gramezi la un moment dat in timpul jocului, nu inseamna ca aceasta gramada va ramane in posesia lui pana la sfarsit. De exemplu, sa presupunem ca jucatorul $1$ detine o gramada cu doua bile si este randul jucatorului $2$ sa mute. Daca acesta alege o gramada cu $4$ bile si gramada cu doua bile ce apartine jucatorului $1$, dupa efectuarea mutarii, ambele gramezi vor avea $3$ bile, iar numarul de gramezi aflate in posesia jucatorului $1$ va scadea cu $1$ (gramada detinuta de el anterior nu mai apartine nici unuia din cei doi jucatori, caci nu mai are doua bile).\r\n\r\nDaca la inceputul jocului exista unele gramezi avand doua bile, acestea sunt distribuite in mod egal celor doi jucatori. Daca numarul de gramezi cu doua bile este impar, atunci jucatorul $2$ va primi cu o gramada mai mult decat jucatorul $1$. Jucatorul $1$ este cel care efectueaza prima mutare.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care, pentru un $N$ dat si un set de configuratii initiale ale jocului cu $N$ gramezi, decide rezultatul fiecarei configuratii de joc.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $doipatru.in$ se afla doi intregi: $N$ si $S$, reprezentand numarul de gramezi folosite in joc, respectiv numarul de configuratii initiale ale jocului, descrise in continuare. Pe urmatoarele $S$ linii se afla cate $N$ valori intregi din intervalul $[0, 4]$, a caror suma este egala cu $2N$, reprezentand cate o configuratie initiala a jocului.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $doipatru.out$, pentru fiecare configuratie initiala a jocului descrisa in fisierul de intrare, in ordinea in care sunt descrise acestea, afisati rezultatul final al jocului, in conditiile in care ambii jucatori joaca optim. Veti afisa valoarea $1$, daca jocul este castigat de primul jucator, valoarea $2$, daca jocul este castigat de cel de-al doilea sau valoarea $0$, daca jocul se termina remiza.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; N &le; 30$\r\n* $1 &le; S &le; 1000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. doipatru.in |_. doipatru.out |\r\n| 5 4\r\n0 3 4 1 2\r\n2 2 2 2 2\r\n1 1 2 2 4\r\n4 3 2 1 0\r\n| 1\r\n2\r\n1\r\n1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"doipatru\")==',15,'task: doipatru'),('problema/hotel','Hotel','2006-11-12 15:18:40','==Include(page=\"template/taskheader\" task_id=\"hotel\")==\r\n\r\n\r\nHotelul \"Informatica\" este unul dintre cele mai luxoase hoteluri din Galaciuc. De-a lungul anului multe grupuri de turisti sosesc la acest hotel sau il parasesc la sfarsitul sejurului, asa ca situatia exacta a camerelor libere si ocupate este destul de greu de aflat, mai ales ca hotelul are un numar mare de camere. Dar anul acesta proprietarul hotelului s-a decis ca are nevoie de o schimbare. De aceea v-a angajat pe dumneavoastra pentru a scrie un program eficient, care sa raspunda necesitatilor sale.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa trateze in mod eficient urmatoarele $3$ tipuri de instructiuni:\r\n\r\n* tipul $1$: sosirea unui grup nou de turisti\r\n\r\nUn grup de turisti avand $M$ membri vrea sa ocupe $M$ camere libere numerotate consecutiv. Programului $i$ se va furniza numarul $i$ al camerei de inceput al secventei de camere ocupate de grup si numarul $M$ de membri ai grupului. Se garanteaza ca oricare din camerele $i,i+1,.., i+M-1$ este libera la momentul respectiv.\r\n\r\n* tipul $2$: plecarea unui grup de turisti\r\n\r\nAtunci cand pleaca, turistii pleaca in grupuri (nu neaparat cele cu care au venit). Un grup care pleaca si care are $M$ membri paraseste $M$ camere (anterior ocupate) numerotate consecutiv. Programului $i$ se va furniza numarul $i$ al camerei de inceput al secventei de camere eliberate, precum si numarul $M$ de membri ai grupului. Se garanteaza ca toate camerele cu numerele de ordine $i,i+1,..,i+M-1$ sunt deja ocupate de turisti.\r\n\r\n* tipul $3$: intrebarea proprietarului\r\n\r\nProprietarul hotelului poate sa intrebe, din cand in cand, care este lungimea maxima a unei secvente de camere libere numerotate consecutiv. El are nevoie de acest numar pentru a putea sti care este numarul maxim posibil de membri ai unui grup care ar putea fi cazati la hotelul \"Informatica\".\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $hotel.in$ se vor afla numerele $N$ si $P$, reprezentand numarul de camere ale hotelului (numerotate de la $1$ la {$N$}), respectiv numarul de instructiuni care urmeaza. Pe fiecare din urmatoarele $P$ linii se va afla un numar $c$, reprezentand tipul instructiunii ce va fi descrisa pe linia respectiva:\r\n\r\n* daca $c$ are valoarea $1$, atunci el va fi urmat (pe aceeasi linie) de alte $2$ numere, $i$ si $M$, reprezentand numarul primei camere distribuite grupului abia sosit si numarul de membri ai grupului\r\n* daca $c$ are valoarea $2$, atunci el va fi urmat (pe aceeasi linie) de alte $2$ numere, $i$ si $M$, reprezentand numarul primei camere care va fi eliberata de grupul care tocmai pleaca, precum si numarul de membri ai grupului care paraseste hotelul\r\n* daca $c$ are valoarea $3$, el nu va fi urmat de nici un alt numar pe linia respectiva; programul va trebui, insa, sa afiseze in fisierul de iesire lungimea maxima a unei secvente de camere libere numerotate consecutiv.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul hotel.out veti afisa, pentru fiecare instructiune de tipul 3, pe cate o linie separata, lungimea maxima a unei secvente de camere libere numerotate consecutiv, luand in considerare instructiunile de tipul 1 si 2 aflate in fisierul de intrare inaintea instructiunii de tip 3 la care se raspunde. Inaintea primei instructiuni, toate camerele sunt libere.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; N &le; 100.000$\r\n* $3 &le; P &le; 200.000$\r\n* In orice camera poate fi cazat la un moment dat un singur turist.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. hotel.in |_. hotel.out |\r\n| 12 10\r\n3\r\n1 2 3\r\n1 9 4\r\n3\r\n2 2 1\r\n3\r\n2 9 2\r\n3\r\n2 3 2\r\n3\r\n| 12\r\n4\r\n4\r\n6\r\n10 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"hotel\")==',15,'task: hotel'),('problema/sah','Sah','2006-11-12 15:22:18','==Include(page=\"template/taskheader\" task_id=\"sah\")==\r\n\r\n\r\nCiobanasul Eduard are o tabla de sah de dimensiuni $NxN$. El cauta o modalitate de a imparti tabla de sah in cat mai multe regiuni dreptunghiulare (cu laturile paralele cu axele de coordonate) disjuncte, astfel incat toate regiunile sa aibe arii diferite, iar intr-o regiune numarul casutelor albe sa fie egal cu numarul casutelor negre. Deoarece vrea sa se intoarca cat mai repede la oitele sale Eduard va cere voua ajutorul.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se $N$ dimensiunea tablei de sah ajutati-l pe Eduard sa gaseasca o impartire in regiuni.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $sah.in$ se afla $N$, dimensiunea tablei de sah.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $sah.out$ va contine $N$ linii cu cate $N$ numere naturale. Al $j$-lea numar de pe linia $i$ va reprezenta regiunea din care face parte casuta de la coordonatele $i, j$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 1000$\r\n* $N$ este par\r\n* Fiecare casuta face parte dintr-o singura regiune\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. sah.in |_. sah.out |\r\n| 4\r\n| 1 1 1 1\r\n1 1 1 1\r\n2 3 3 3\r\n2 3 3 3 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sah\")==',15,'task: sah'),('problema/asmin','Asmin','2006-11-12 16:09:18','==Include(page=\"template/taskheader\" task_id=\"asmin\")==\r\n\r\nSe considera un arbore (graf conex aciclic) cu $N$ varfuri, fara radacina fixata. Drept radacina, poate fi ales oricare dintre varfuri. Sa presupunem ca a fost ales varful cu numarul {$T$}. Intre oricare varf si $T$ exista un drum unic care contine fiecare varf al arborelui cel mult o singura data (un drum intre varfurile $i$ si $j$ este o secventa de varfuri, care incepe cu {$i$}, se termina cu {$j$}, iar intre oricare doua varfuri consecutive exista o muchie in arbore). Fiecarui varf {$i$}(inclusiv {$T$}) trebuie sa i se asocieze o valoare {$V{~i~}$}, mai mare sau egala cu {$0$}, astfel incat suma valorilor varfurilor de pe drumul dintre $i$ si radacina {$T$}, impartita la {$K$}, sa dea restul {$R{~i~}$}. Se defineste costul arborelui cu radacina fixata in {$T$}, {$C{~T~}$}, ca fiind suma valorilor asociate fiecarui nod. Dintre toate posibilitatile de alegere a valorilor $V{~i~}$ care respecta conditia precizata anterior, se va alege aceea pentru care $C{~T~}$ este minim.\r\nSe constata usor ca alegand alt varf drept radacina, de exemplu, varful {$S$}(diferit de {$T$}), $C{~S~}$ nu este neaparat egal cu {$C{~T~}$}.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un arbore cu $N$ varfuri, un numar intreg $K$ si valorile {$R{~i~}$}, {$i=1,2,..,N$}, corespunzatoare fiecarui varf, determinati acele varfuri $T$ care pot fi alese drept radacina, pentru care costul $C{~T~}$ este minim (adica {$C{~T~} &le; C{~S~}$}, oricare ar fi $S$ diferit de {$T$}), precum si costul respectiv.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $asmin.in$ se afla doua valori intregi: $N$ si {$K$}. Pe urmatoarele $N-1$ linii se afla cate doua numere intregi {$a b$}, separate printr-un spatiu, avand semnificatia ca exista muchie intre varfurile $a$ si {$b$}. Varfurile sunt numerotate de la $1$ la {$N$}. Pe urmatoarea linie se afla $N$ numere intregi, reprezentand valorile {$R{~i~}$}, {$i=1,2,..,N$}.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului de iesire $asmin.out$ se vor afisa doua valori intregi: $C$ si {$M$}. $C$ reprezinta costul minim posibil al arborelui. $M$ reprezinta numarul de varfuri care pot fi alese drept radacina si pentru care se obtine costul {$C$}. Pe a doua linie se afla $M$ numere intregi separate prin cate un spatiu, scrise in ordine crescatoare, reprezentand numerele varfurilor ce pot fi alese ca radacina astfel incat sa se obtina costul {$C$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 16.000$\r\n* $2 &le; K &le; 1.000$\r\n* $0 &le; R{~i~} &le; K-1$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. asmin.in |_. asmin.out |\r\n| 5 3\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n0 1 2 1 0\r\n| 5 2\r\n1 5\r\n| \r\n\r\nh3. Explicatii\r\n\r\nValorile asociate varfurilor celor doi arbori sunt urmatoarele:\r\n$V{~1~}=0   V{~2~}=1  V{~3~}=2   V{~4~}=0   V{~5~}=2$\r\n$V{~1~}=2   V{~2~}=1  V{~3~}=2   V{~4~}=0   V{~5~}=0$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"asmin\")==',1,'task: asmin'),('problema/avd','AVD','2006-11-12 16:11:12','==Include(page=\"template/taskheader\" task_id=\"avd\")==\r\n\r\nUn arbore este un graf neorientat, conex cu $N$ noduri si $N-1$ muchii. Se numeste arbore AVD un arbore care pentru fiecare partitie a lui $N  = n{~1~} + n{~2~} + ... + n{~k~}$ nodurile arborelui se pot imparti in $k$ multimi astfel incat multimea $i$ are n{~i~} noduri si fiecare multime ramane conexa, $n{~i~} &le; n{~j~}$ pentru $i < j$. Gradul AVD al unui arbore este numarul de partitii care indeplinesc conditiile anterioare impartit la numarul total de partitii existente pentru $N$.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un arbore cu $N$ noduri, calculati gradul AVD al acestuia.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $avd.in$ contine $T$, numarul de teste din fisier apoi vor urma cele $T$ teste. Pe prima linie a fiecarui test se afla $N$ numarul de noduri, urmand apoi $N-1$ linii continand cate doua numere $x, y$ cu semnificatia exista muchie intre nodurile $x$ si $y$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $avd.out$ vor exista $T$ linii fiecare continand gradul AVD al arborelui descris la testului respectiv.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 13$\r\n* $1 &le; T &le; 50$\r\n* rezultatul se va afisa cu $5$ zecimale (prin rotunjire)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. avd.in |_. avd.out |\r\n| 3\r\n4\r\n1 2\r\n1 3\r\n1 4\r\n5\r\n1 2\r\n2 3\r\n3 4\r\n4 5\r\n1\r\n| 0.80000\r\n1.00000\r\n1.00000 |\r\n\r\nh3. Explicatii\r\n\r\nPentru primul test, exista in total $5$ partitii pentru $4: 1+1+1+1, 1+1+2, 1+3, 2+2, 4$ din care doar partitia $2+2$ nu poate fi obtinuta. Deci gradul AVD al arborelui este $4/5=0.80000$. \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"avd\")==',1,'task: avd'),('problema/avere','Avere','2006-11-11 15:40:34','==Include(page=\"template/taskheader\" task_id=\"avere\")==\r\n\r\nItalag a fost toata viata pasionat de speculatii bursiere reusind sa adune o avere considerabila. Fiind un tip original si pasiont de matematica a scris un testament inedit. Testamentul contine doua numere naturale: $S$ reprezentand averea ce trebuie impartita mostenitorilor si $N$ reprezentand alegerea sa pentru impartirea averii. Italag decide sa-si imparta toata averea, iar sumele pe care le acorda mostenitorilor sa fie in ordine strict descrescatoare.\r\nDe exemplu daca averea ar fi $7$ unitati monetare, ar putea fi impartita astfel:\r\n\r\n* $4$ (unitati primului mostenitor) $3$ (unitati celui de-al doilea), sau\r\n* $6$ (unitati primului mostenitor) $1$ (unitati celui de-al doilea), sau\r\n* $7$ (doar primului mostenitor), sau\r\n* $5$ (unitati primului mostenitor) $2$ (unitati celui de-al doilea), sau\r\n* $4$ (unitati primului mostenitor) $2$ (unitati celui de-al doilea) $1$ ( unitate celui de-al treilea ).\r\n\r\nVazand ca ii este foarte greu sa verifice daca nu cumva a omis vreo varianta de impartire , Italag le-a scris in ordine lexicografica. Pentru exemplul de mai sus: {$4 2 1$}; {$4 3$}; {$5 2$}; {$6 1$}; {$7$}.\r\nA hotarat ca banii sa fie distribuiti conform celei de a {$N$}-a posibilitati din ordinea lexicografica.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care pentru numerele {$S$}, $N$ date sa calculeze si sa afiseze numarul total de posibilitati de impartire a averii, precum si modul in care se face aceasta impartire conform cu a {$N$}-a posibilitate din ordinea lexicografica.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $avere.in$ contine o singura linie pe care se afla doua numere naturale separate printr-un singur spatiu:\r\n\r\n* primul numar $S$ reprezinta suma totala\r\n* cel de-al doilea $N$ reprezinta numarul de ordine al pozitiei cautate\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $avere.out$ va contine doua linii:\r\n\r\n* pe prima linie va fi afisat numarul total de modalitati de impartire a averii\r\n* pe cea de a doua linie va fi afisata a {$N$}-a posibilitate de impartire a lui $S$ conform cerintei in ordine lexicografica. Elementele sale vor fi separate prin cate un spatiu.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 < S < 701$\r\n* $0 < N <$ numarul total de posibilitati cu suma $S$\r\n* Se acorda punctaj partial pentru fiecare test: $5$ puncte pentru determinarea corecta a numarului de posibilitati de impartire a lui $S$ si $5$ puncte pentru determinarea corecta a posibilitatii {$N$}, din ordinea lexicografica\r\n* Posibilitatile de impartire a averii sunt numerotate incepand cu $1$\r\n* Fie $x = (x{~1~}, x{~2~} ..., x{~m~})$ si $y = (y{~1~}, y{~2~} ..., y{~p~})$ doua siruri. Spunem ca $x$ preceda pe $y$ din punct de vedere lexicografic, daca exista {$1 &le; k$}, astfel incat {$x{~i~} = y{~i~}$}, pentru orice {$1 &le; i &le; k-1$} si {$x{~k~} < y{~k~}$}.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. avere.in |_. avere.out |\r\n| 7 2\r\n| 5\r\n4 3 |\r\n| 12 5\r\n| 15\r\n6 5 1 |\r\n| 700 912345678912345678\r\n| 962056220379782044\r\n175 68 63 58 54 45 40 36 34 32 20 18 17 14 11 9 3 2 1 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"avere\")==',961,'task: avere'),('problema/parcele','Parcele','2006-11-12 16:17:34','==Include(page=\"template/taskheader\" task_id=\"parcele\")==\r\n\r\nPe o campie intinsa se afla $N$ copaci situati in puncte de coordonate intregi. Fermierul Ion doreste sa cumpere cateva parcele pe acea campie. Ion poate cumpara numai parcele de forma dreptunghiulara, cu laturile paralele cu axele de coordonate de pe harta zonei, cu dimensiunile intregi fixate ({$DX$} pentru axa $OX$ si $DY$ pentru axa $OY$) si avand colturile situate in puncte de coordonate intregi. Cumpararea unei parcele va trece in proprietatea lui Ion interiorul ei (se considera ca laturile parcelei fac parte din interior).\r\nNumarandu-si banii, Ion s-a hotarat sa cumpere exact DOUA parcele care, evident, sa nu aiba nici un punct comun. Deoarece lui Ion ii plac foarte mult copacii, el isi va alege o modalitate de amplasare a celor doua parcele astfel incat in interiorul lor (inclusiv pe laturi) sa se afle cat mai multi copaci. In acest scop, Ion va cere ajutorul.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine o modalitate de amplasare a parcelelor, astfel incat Ion sa detina cat mai multi copaci!\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $parcele.in$ contine:\r\n- pe prima linie doua numere intregi $DX$ si $DY$, reprezentand dimensiunile unei parcele;\r\n- pe cea de a doua linie un numar intreg $N$, reprezentand numarul de copaci;\r\n- pe fiecare dintre urmatoarele $N$ linii cate doua numere intregi $X{~i~}$ si $Y{~i~}$, reprezentand coordonatele copacului cu numarul $i$.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $parcele.out$ veti afisa pe prima linie numarul maxim de copaci pe care ii poate detine Ion.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; DX, DY &le; 99.999$\r\n* $1 &le; N &le; 100.000$\r\n* coordonatele copacilor sunt numere intregi intre $0$ si $99999$ inclusiv\r\n* nu exista doi copaci situati in acelasi punct\r\n* parcelele pot fi plasate oriunde, cu conditia ca sa nu se intersecteze\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. parcele.in |_. parcele.out |\r\n| 2 1\r\n7\r\n0 0\r\n1 0\r\n1 1\r\n3 0\r\n3 1\r\n4 0\r\n1000 1000\r\n| 6 |\r\n\r\nh3. Explicatii\r\n\r\nO solutie posibila este: prima parcela are colturile $(-1, 0)$ si $(1, 1)$ iar a doua parcela are colturile $(3, 0)$ si $(5, 1)$\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"parcele\")==',15,'task: parcele'),('problema/ecu','Ecu','2006-11-12 00:42:41','==Include(page=\"template/taskheader\" task_id=\"ecu\")==\r\n\r\nGigel are de rezolvat un sistem complicat de ecuatii neliniare si pentru aceasta intentioneaza sa foloseasca o metoda iterativa care, spera el, va converge catre solutie dupa un numar rezonabil de iteratii. Mai intai, el alege niste valori initiale pentru cele $N$ necunoscute ale sistemului. Aceste valori se noteaza cu $x{~1~}^(0)^ x{~2~}^(0)^ ... x{~N~}^(0)^$. In continuare, dupa fiecare iteratie, el va modifica valorile necunoscutelor, conform urmatoarelor relatii:\r\n* $x{~k~}^(i)^=p{~k~}*x{~k~}^(i-1)^+(1-p{~k+1~})*x{~k+1~}^(i-1)^+y{~k~}$ pentru $1&le; k < N$\r\n* $x{~N~}^(i)^=p{~N~}*x{~N~}^(i-1)^+(1-p{~1~})*x{~1~}^(i-1)^+y{~N~}$\r\nunde prin $x{~k~}^(i)^$ s-a notat valoarea necunoscutei $k$ dupa $i$ iteratii. $p{~k~}$ reprezinta ponderea asociata necunoscutei $k$, iar $y{~k~}$ reprezinta corectia aplicata necunoscutei $k$, dupa fiecare iteratie. Gigel nu este un programator prea bun si nu stie sa implementeze algoritmul iterativ descris. De aceea, are nevoie de ajutorul dumneavoastra.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se valorile initiale ale celor $N$ necunoscute, ponderile asociate si corectiile aplicate, sa se determine valorile necunoscutelor dupa $M$ iteratii.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $ecu.in$ se afla doua numere intregi, separate printr-un spatiu, $N$ si $M$. Pe urmatoarea linie se afla $N$ numere reale, reprezentand valorile initiale ale necunoscutelor, in ordinea $x{~1~}^(0)^,...,x{~N~}^(0)^$. Pe urmatoarea linie se afla alte $N$ numere reale, reprezentand ponderile asociate necunoscutelor, in ordine de la $x{~1~}^(0)^$ la $x{~N~}^(0)^$. Pe ultima linie a fisierului se afla $N$ numere reale, descriind corectiile ce vor fi aplicate necunoscutelor $x{~1~}^(0)^,...,x{~N~}^(0)^$, dupa fiecare iteratie. Toate numerele reale sunt date cu cel mult 3 zecimale.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului $ecu.out$ se vor afisa $N$ numere reale, rotunjite la trei zecimale, reprezentand valorile necunoscutelor dupa $M$ iteratii.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 30$\r\n* $0 &le; M &le; 1.000.000.000$\r\n* $-1000 &le; x{~i~}^(0)^ &le;1000$, pentru $k$ de la $1$ la $N$\r\n* $0 &le; p{~k~} &le; 1$, pentru $k$ de la $1$ la $N$\r\n* $-0.1 &le; y{~k~} &le; 0.1$, pentru $k$ de la $1$ la $N$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. ecu.in |_. ecu.out |\r\n| 3 2 \r\n1.0 2.0 3.0\r\n0.1 0.2 0.3\r\n0.001 0.002 0.003 | 2.173 1.765 2.075 |\r\n\r\nh3. Explicatie\r\n\r\nDupa prima iteratie, valorile necunoscutelor sunt: 1.701; 2.502; 1.803. Dupa cea de-a doua iteratie, valorile necunoscutelor sunt: 2.173; 1.765; 2.075.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"ecu\")==',1,'task: ecu'),('problema/tri2','Tri2','2006-11-11 17:52:05','==Include(page=\"template/taskheader\" task_id=\"tri2\")==\r\n\r\nMicutul Gigel a marcat pe hartie $N$ puncte, avand coordonate intregi. Apoi a inceput sa deseneze triunghiuri, avand varfurile in trei puncte diferite dintre cele $N$. Pentru fiecare triunghi desenat, Gigel ar dori sa stie cate dintre cele $N-3$ puncte ramase se afla strict in interiorul triughiului.\r\n\r\nh2. Cerinta\r\n\r\nPentru fiecare triunghi dat (prin indicii celor 3 puncte care sunt varfurile sale), determinati cate dintre celelalte puncte se afla strict in interiorul triunghiului.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $tri2.in$ se afla numarul intreg $N$, reprezentand numarul de puncte marcate de Gigel pe hartie. Pe fiecare dintre urmatoarele $N$ linii se afla coordonatele fiecarui punct, in ordine, de la cel numerotat cu 1, la cel numerotat cu $N$. Coordonatele sunt descrise prin doi intregi $x$ si $y$, separati printr-un spatiu. Urmatoarea linie contine numarul intreg $M$ de triunghiuri pe care le-a desenat Gigel. Pe urmatoarele $M$ linii se afla cate trei numere intregi, $a$, $b$ si $c$, separate prin spatii, reprezentand indicii a trei puncte diferite dintre cele $N$.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $tri2.out$ veti afisa $M$ linii. Pe fiecare linie se va afla un numar intreg, reprezentand numarul de puncte dintre cele $N-3$ ramase, care se afla strict in interiorul triunghiului corespunzator liniei (prima linie va contine raspunsul corespunzator primului triunghi descris in fisierul de intrare, a doua linie raspunsul corespunzator celui de-al doilea triunghi, etc.).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; N &le; 1 000$\r\n* $1 &le; M &le; 500 000$\r\n* Coordonatele $x$, $y$ sunt numere intregi din intervalul $[0, 2 000 000 000]$\r\n* Oricare doua puncte au coordonatele $x$, respectiv $y$, distincte\r\n* Oricare trei puncte sunt necoliniare\r\n* Daca doriti sa folositi numere reale in programul vostru, se recomanda folosirea tipurilor long double pt. C/C++, respectiv extended pt. Pascal. Pentru testarea egalitatii a doua numere reale se recomanda folosirea unei precizii de {$10^-14^$}\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. tri2.in|_. tri2.out|\r\n|5\r\n0 0\r\n1 10\r\n2 4\r\n3 7\r\n10 1\r\n3\r\n1 2 3\r\n5 1 2\r\n5 3 2\r\n|0\r\n2\r\n1|\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"tri2\")==',256,'task: tri2'),('problema/lanterna','Lanterna','2006-11-12 15:37:47','==Include(page=\"template/taskheader\" task_id=\"lanterna\")==\r\n\r\nUn agent secret are o harta pe care sunt marcate $N$ obiective militare. El se afla, initial, langa obiectivul numerotat cu 1 (baza militara proprie) si trebuie sa ajunga la obiectivul numerotat cu $N$ (baza militara inamica). Pentru aceasta, el va folosi drumurile existente, fiecare drum legand 2 obiective distincte. Fiind o misiune secreta, deplasarea agentului va avea loc noaptea; de aceea, el are nevoie de o lanterna. Pentru aceasta, el are de ales intre $K$ tipuri de lanterne - o lanterna de tipul $W (1 &le; W &le; K)$ are baterii care permit consumul a $W$ watti; dupa consumul acestor watti, lanterna nu mai lumineaza. Din fericire, unele dintre obiective sunt baze militare prietene, astfel ca, o data ajuns acolo, el isi poate reincarca complet bateriile. Agentul trebuie sa aiba grija ca, inainte de merge pe un drum intre doua obiective, cantitatea de watti pe care o mai poate consuma sa fie mai mare sau egala cu cantitatea de watti pe care o va consuma pe drumul respectiv.\r\nCunoscand drumurile dintre obiective si, pentru fiecare drum, durata necesara parcurgerii drumului si numarul de watti consumati de lanterna, determinati tipul de lanterna cu numarul cel mai mic, astfel incat durata deplasarii sa fie minima (sa presupunem ca acest tip este $W$; aceasta inseamna ca daca ar alege o lanterna de un tip mai mic decat $W$, durata deplasarii ar fi strict mai mare, iar daca ar alege o lanterna de un tip mai mare decat $W$, durata deplasarii ar fi mai mare sau egala).\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $lanterna.in$ se afla numerele intregi $N$ si $K$, separate printr-un spatiu. Pe urmatoarea linie se afla $N$ numere intregi din multimea ${0,1}$. Daca al $i$-lea numar este $1$, aceasta inseamna ca obiectivul cu numarul $i$ este o baza militara prietena (adica agentul isi poate reincarca bateriile lanternei daca ajunge la acest obiectiv); daca numarul este 0, agentul nu isi va putea reincarca bateriile. Pe cea de-a treia linie a fisierului se afla numarul $M$ de drumuri dintre obiective. Fiecare din urmatoarele $M$ linii contine cate 4 numere intregi separate prin spatii: $a b T W$, avand semnificatia ca exista un drum bidirectional intre obiectivele $a$ si $b$ $(a<>b)$, care poate fi parcurs intr-un timp $T$ si cu un consum de $W$ watti.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $lanterna.out$ veti afisa doua numere intregi, separate printr-un spatiu : $Tmin$ si $W$. Tmin reprezinta durata minima posibila a deplasarii de la obiectivul 1 la obiectivul $N$, iar $W$ reprezinta tipul de lanterna cu numarul cel mai mic pentru care se obtine acest timp.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 50$\r\n* $1 &le; K &le; 1000$\r\n* $1 &le; M &le; N*(N-1)/2$\r\n* Intre doua orase diferite poate exista maxim un drum direct.\r\n* Pentru fiecare drum, durata parcurgerii este un numar intreg intre $1$ si $100$, iar numarul de watti consumati este un numar intreg intre $0$ si $1000$\r\n* Se garanteaza ca exista cel putin un tip de lanterna pentru care deplasarea sa fie posibila.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. lanterna.in |_. lanterna.out |\r\n| 7 10\r\n0 0 1 0 0 0 0\r\n7\r\n1 2 10 3\r\n1 4 5 5\r\n2 3 10 3\r\n4 3 15 1\r\n3 6 4 3\r\n6 5 2 2\r\n5 7 1 0 | 27 6 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"lanterna\")==',1,'task: lanterna'),('problema/color2','Color2','2006-11-11 20:00:30','==Include(page=\"template/taskheader\" task_id=\"color2\")==\r\n\r\nIon si Vasile joaca un joc. Ei au la dispozitie un arbore binar strict (adica fiecare nod are $0$ sau $2$ fii) cu $N$ noduri, numerotate de la $1$ la $N$ (nodul numerotat cu $1$ este radacina arborelui). Initial, toate nodurile sunt colorate in alb. Jucatorii vor efectua mutari alternativ, iar jucatorul aflat la mutare va colora in negru un nod colorat in alb. Ion efectueaza prima mutare si poate colora in negru orice nod al arborelui. Considerand ca ultimul nod colorat de unul dintre jucatori este $P$, jucatorul care urmeaza la mutare poate colora in negru unul din urmatoarele noduri (daca nu au fost deja colorate in negru):\r\n\r\n* unul din cei doi fii ai lui $P$ (daca $P$ nu este frunza in arbore)\r\n* tatal lui $P$ (daca $P$ nu este radacina arborelui)\r\n\r\nJocul continua pana cand unul dintre jucatori nu mai poate efectua nici o mutare. Atunci, jucatorul care a efectuat ultima mutare este considerat castigator.\r\n\r\nh2. Cerinta\r\n\r\nConsiderand ca ambii jucatori joaca optim, determinati toate nodurile din arbore pe care le poate colora Ion la prima mutare, astfel incat sa fie sigur de victorie.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $color2.in$ contine numarul intreg $N$, reprezentand numarul de noduri din arbore. Urmatoarele $N-1$ linii contin cate doua numere intregi separate printr-un spatiu, $a$ si $b$, avand semnificatia ca $a$ este tatal lui $b$.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului $color2.out$ veti afisa numarul intreg $M$, reprezentand numarul de noduri pe care le poate colora Ion la prima mutare, astfel incat sa fie sigur de victorie. Pe urmatoarea linie veti afisa numerele acestor noduri, in ordine crescatoare.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 16 000$, $N$ impar\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. color2.in |_. color2.out |\r\n| 9\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n4 6\r\n4 7\r\n3 8\r\n3 9\r\n| 6\r\n1 5 6 7 8 9 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"color2\")==',18,'task: color2'),('problema/base3','Base3','2006-11-11 15:57:39','==Include(page=\"template/taskheader\" task_id=\"base3\")==\r\n\r\nSe dau trei numere scrise in baza $3$ (folosind cifrele {$0$}, $1$ si {$2$}). Se doreste gasirea unui numar $N$ in baza {$3$}, care sa aiba un numar impar de cifre, iar cifra de pe pozitia din mijloc sa aiba valoarea {$1$}. Acest numar $N$ trebuie obtinut prin concatenarea celor trei numere date; in aceasta concatenare, fiecare din cele trei numere poate fi folosit de zero sau mai multe ori.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul minim de cifre pe care il poate avea un numar avand proprietatile precizate mai sus.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $base3.in$ contine trei linii. Pe fiecare linie se afla scris un numar in baza {$3$}.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $base3.out$ va contine numarul minim de cifre pe care il poate avea un numar $N$ cu proprietatile specificate. Daca nu se poate obtine nici un astfel de numar, afisati in fisier valoarea {$0$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Numarul de cifre al fiecaruia din cele trei numere este un numar intreg intre $1$ si {$16000$}.\r\n* Numerele date pot contine zerouri la inceput; acestea trebuie luate in considerare, daca numarul respectiv este folosit in concatenare.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. base3.in |_. base3.out |\r\n| 001\r\n020\r\n2020\r\n| 13 |\r\n\r\nh3. Explicatie:\r\n\r\nSe poate obtine numarul {$2020001001001$}.\r\n\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"base3\")==',961,'task: base3'),('problema/prefix','Prefix','2006-11-12 14:47:11','==Include(page=\"template/taskheader\" task_id=\"prefix\")==\r\n\r\nSe considera un sir format din literele mici $\'a\', \'b\', ...,\'z\'$. Sa se determine cel mai lung prefix periodic al sau. Un sir $X$ este periodic daca se poate scrie sub forma $P + P + ... + P$, unde prin $A + B$ s-a notat concatenarea sirurilor $A$ si $B$. Sirul $P$ se numeste perioada lui $X$ si trebuie sa fie strict mai scurt decat $X$.\r\nDe exemplu, sirurile $\"abcaabcaabcaabca\", \"xyyxyy\" si \"wwwww\"$ sunt periodice, iar sirurile $\"abcaabcaabcaz\", \"xyxyxz\" si \"wwwaawww\"$ nu sunt periodice.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $prefix.in$ contine numarul intreg $T$ de siruri prezente in fisier. Fiecare din urmatoarele $T$ linii contine cate un sir.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $prefix.out$ se va afisa, pentru fiecare din cele $T$ siruri din fisierul de intrare, lungimea celui mai lung prefix periodic.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; T &le; 10$\r\n* Fiecare sir va avea cel putin unul si cel mult $1.000.000$ de caractere\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. prefix.in |_. prefix.out |\r\n| 10\r\nabcdefgh\r\nz\r\nxxxuxxxu\r\nabbcaabbcaabbcaabbcaxyzxyzxyzxyz\r\nhellohellohellohellauhellohello\r\naaaaaaaaazaaaaaaaaazaaaaaaaaa\r\nuvwuvwuvwuvwu\r\nsirperiodicsirperiodicsirperiodicsir\r\naababcabcdabcdeabcdefabcdefgaerror\r\nmamatatabunicubunicaunchiumatusa | 0\r\n0\r\n8\r\n20\r\n15\r\n20\r\n12\r\n33\r\n2\r\n4 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"prefix\")==',1,'task: prefix'),('problema/comp','Compania','2006-11-11 20:18:11','==Include(page=\"template/taskheader\" task_id=\"comp\")==\r\n\r\nO companie internationala are $N$ angajati, numerotati de la $1$ la $N$. Acestia sunt organizati intr-o structura ierarhica cu urmatoarele proprietati:\r\n\r\n* fiecare angajat are un superior direct, cu exceptia angajatului cu numarul $1$ care este managerul companiei\r\n* fiecare angajat poate fi superiorul direct a $0$, $1$ sau cel mult $2$ alti angajati.\r\n\r\nPentru a imbunatati eficienta afacerii lor, detinatorii companiei au decis sa o imparta in trei companii mai mic. Pe langa alte probleme pe care le-au avut de rezolvat a aparut una foarte importanta: cum trebuie distribuiti angajatii la cele trei companii nou create? Trebuie luate in considerare urmatoarele conditii:\r\n\r\n* fiecare angajat trebuie distribuit la una dintre cele trei companii\r\n* un angajat si superiorul sau nu trebuie sa fie distribuiti la aceeasi companie\r\n* daca doi angajati au acelasi superior, atunci ei trebuie sa fie distribuiti la companii diferite\r\n\r\nPentru ca cele trei companii sa fie la fel de eficiente a mai aparut o conditie suplimentara. Sa presupunem ca $N{~1~}$ este numarul de angajati distribuiti la prima companie, $N{~2~}$ este numarul de angajati distribuiti la cea de-a doua companie si $N{~3~}$ este numarul de angajati distribuiti la cea de-a treia companie $(N{~1~} + N{~2~} + N{~3~} = N)$. Cu aceste notatii, trebuie ca diferenta $max(N{~1~},N{~2~},N{~3~})-min(N{~1~},N{~2~},N{~3~})$ sa fie cat mai mica posibil.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $comp.in$ contine pe prima linie un singur numar natural $N$, care reprezinta numarul de angajati ai companiei. Fiecare dintre urmatoarele $N-1$ linii contine doua numere naturale $a$ si $b$ cuprinse intre $1$ si $N$, separate printrun singur spatiu, care semnifica faptul ca angajatul $b$ este superiorul direct al angajatului $a$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $comp.out$ va avea o singura linie pe care se vor afla $N$ numere, separate prin spatii, din multimea ${1,2,3}$. Primul numar reprezinta numarul companiei la care a fost distribuit angajatul cu numarul $1$, al doilea numar reprezinta numarul companiei la care a fost distribuit angajatul cu numarul $2$, al treilea numar reprezinta numarul companiei la care a fost distribuit angajatul cu numarul $3$ etc.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 &le; N &le; 16.000$\r\n* $max(a,b,c)$ reprezinta maximul dintre valorile $a, b$ si $c$\r\n* $min(a,b,c)$ reprezinta minimul dintre valorile $a, b$ si $c$\r\n* este acceptata orice solutie care minimizeaza diferenta specificata in enunt\r\n* datele de intrare sunt corecte\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. comp.in |_. comp.out |\r\n| 6\r\n2 1\r\n3 2\r\n4 2\r\n5 3\r\n6 3 \r\n| 3 1 3 2 1 2 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"comp\")==',18,'task: comp'),('problema/echipe','Echipe','2006-11-12 00:35:09','==Include(page=\"template/taskheader\" task_id=\"echipe\")==\r\n\r\n\r\nFC Campion Romania se pregateste pentru finala Ligii Campionilor Europeni. Pentru aceasta, cei $N$ jucatori ai sai se antreneaza zilnic. Pentru fiecare dintre ei se cunoaste intervalul $[T1,T2)$ cand este prezent la antrenament. Pentru ca antrenamentul sa fie mai eficient, jucatorii nu se antreneaza toti la un loc, ci sunt impartiti in $K$ echipe. Fiecare jucator face parte din exact o echipa, dar este posibil ca din unele echipe sa nu faca parte nici un jucator. Deoarece munca in echipa este foarte importanta, antrenamentul fiecareia dintre cele $K$ echipe se poate desfasura numai daca sunt prezenti toti jucatorii care fac parte din acea echipa. In aceste conditii, durata de antrenament a fiecarei echipe este egala cu lungimea intervalului de timp in care sunt prezenti la antrenament toti jucatorii din echipa respectiva. Intrucat finala se apropie, conducerea clubului doreste ca suma duratelor de antrenament ale fiecarei echipe sa fie maxima.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati o impartire in $K$ echipe a celor $N$ jucatori, astfel incat suma duratelor de antrenament sa fie maxima.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $echipe.in$ se afla doua numere intregi, separate prin spatii: $N$ si $K$. Pe urmatoarele $N$ linii se afla cate doua numere intregi separate prin spatii, $A$ si $B$, reprezentand intervalele de timp in care sunt prezenti jucatorii la antrenament.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $echipe.out$ veti afisa suma maxima a duratelor de antrenament corespunzatoare unei impartiri pe echipe optime.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; K &le; N &le; 250$\r\n* $0 &le; A &lt; B &le; 1.000.000$\r\n* Daca o echipa contine $0$ jucatori, durata ei de antrenament este $0$.\r\n* Daca nu exista nici un moment in care toti jucatorii unei echipe sa fie prezenti simultan la antrenament, atunci durata de pregatire a echipei respective este $0$.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. echipe.in |_. echipe.out |\r\n| 8 4\r\n0 11\r\n0 10\r\n1 11\r\n2 12\r\n3 13\r\n4 14\r\n5 15\r\n19 28\r\n| 36 |\r\n\r\nh3. Explicatie\r\n\r\nDin prima echipa fac parte jucatorii $1$, $2$ si $3$. Din a doua echipa vor face parte jucatorii $4$ si $5$. Din a treia echipa fac parte jucatorii $6$ si $7$, iar a patra echipa il va contine doar pe jucatorul $8$. Intervalele de antrenament pentru fiecare din cele $4$ echipe sunt: $[1,10)$, $[3,12)$, $[5,14)$, $[19,28)$.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"echipe\")==',15,'task: echipe'),('problema/granita','Granita','2006-11-12 13:54:21','==Include(page=\"template/taskheader\" task_id=\"granita\")==\r\n\r\nLa granita statului A cu statul B se afla $N$ dispozitive de aparare. Pentru fiecare dispozitiv $k$ se cunoaste intervalul de lungime $[A{~k~}, B{~k~}]$ in care actioneaza (granita se considera a fi o linie dreapta, iar fiecare dispozitiv acopera un anumit segment de pe aceasta linie). Pentru a reduce costurile de intretinere, presedintele statului A a decis ca unele dintre cele $N$ dispozitive de aparare sa fie desfiintate. Mai precis, vor fi desfiintate dispozitivele redundante. Un dispozitiv $i$ este redundant, daca exista cel putin un alt dispozitiv $j$, astfel incat intervalul $[A{~i~}, B{~i~}]$ sa fie inclus in intervalul $[A{~j~}, B{~j~}]$ (adica $A{~j~}<A{~i~}$ si $B{~i~}<B{~j~}$).\r\n\r\nh2. Cerinta\r\n\r\nDeterminati cate dintre cele $N$ dispozitive de aparare sunt redundante.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $granita.in$ se afla numarul intreg $N$, reprezentand numarul dispozitivelor de aparare. Pe urmatoarele N linii se afla cate doua numere intregi, $a$ si $b (a<b)$, reprezentand capetele intervalelor in care actioneaza fiecare dispozitiv.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $granita.out$ contine o singura linie pe care veti afisa un singur numar intreg, reprezentand numarul dispozitivelor redundante.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 16.000$\r\n* $0 &le; A{~i~} < B{~i~} &le; 2.000.000.000$\r\n* Toate numerele $A{~i~}$ vor fi diferite intre ele\r\n* Toate numerele $B{~i~}$ vor fi diferite intre ele\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. granita.in |_. granita.out |\r\n|5 \r\n0 10\r\n2 9\r\n3 8\r\n1 15\r\n6 11 | 3 |\r\n\r\nh3. Explicatie\r\n\r\nDispozitivele redundante sunt: al doilea, al treilea si al cincilea.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"granita\")==',1,'task: granita'),('problema/transport','Transport','2006-11-11 18:30:59','==Include(page=\"template/taskheader\" task_id=\"transport\")==\r\n\r\nO firma ce produce saltele cu apa are $N$ astfel de saltele intr-un depozit, asezate una peste alta (intr-o stiva). Fiecare saltea este caracterizata prin volumul sau (un numar intreg, exprimat in decimetri cubi). Pentru a le transporta la magazin, in vederea comercializarii, firma va inchiria un camion care va avea o capacitate egala cu $C$ decimetri cubi. Acest camion va trebuie sa efectueze cel mult $K$ transporturi (s-a estimat durata fiecarui transport si s-a ajuns la concluzia ca daca s-ar efectua mai mult de $K$ transporturi, camionul ar ajunge la magazin in afara orelor de aprovizionare, astfel ca saltelele nu ar putea fi comercializate). La fiecare transport, camionul poate fi incarcat cu saltele, cu conditia ca suma volumelor saltelelor incarcate in camion sa nu depaseasca capacitatea camionului. Deoarece saltele sunt asezate intr-o stiva, nu este posibil sa se incarce in camion o saltea decat dupa ce au fost incarcate (si eventual transportate) toate saltelele de deasupra ei. Intrucat costul inchirierii camionului depinde de capacitatea acestuia, firma doreste sa inchirieze un camion cu capacitatea cat mai mica care sa poata transporta toate cele $N$ saltele, efectuand maxim $K$ transporturi.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $transport.in$ se afla numerele intregi $N$ si $K$ (separate printr-un spatiu). Pe fiecare din urmatoarele $N$ linii se afla un numar intreg, reprezentand volumul unei saltele. Prima din aceste $N$ linii contine volumul saltelei din varful stivei, a doua linie contine volumul celei de-a doua saltele, etc.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $transport.out$ veti afisa un singur numar intreg, reprezentand capacitatea minima pe care trebuie sa o aiba camionul pentru a putea transporta cele $N$ saltele efectuand maxim $K$ transporturi.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 16 000$\r\n\r\n* $1 &le; K &le; 16 000$\r\n\r\n* $1 &le; volumul oricarei saltele &le; 16 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. transport.in|_. transport.out|\r\n|6 3\r\n7\r\n3\r\n2\r\n3\r\n1\r\n4\r\n|8|\r\n\r\n_Explicatie_: la primul transport este incarcata prima saltea (care are volumul 7). La cel de-al doilea transport sunt incarcate saltele 2 si 3 (volumul total este 3 + 2 = 5). La cel de-al treilea transport sunt incarcate saltele 4, 5 si 6 (volumul total este 3 + 1 + 4 = 8).\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"transport\")==',256,'task: transport'),('problema/poligon2','Poligon 2','2006-11-12 15:37:27','==Include(page=\"template/taskheader\" task_id=\"poligon2\")==\r\n\r\nGigel a desenat pe hartie un poligon (nu neaparat convex si care se poate chiar autointersecta) cu $N$ varfuri si a marcat mijlocul fiecarei laturi. Fratele lui, insa, a sters poligonul desenat, pe hartie ramanand marcate numai mijloacele laturilor. Gigel ar dori, totusi, sa redeseneze poligonul, asa cum era el initial. Se considera ca poligonul are varfurile numerotate de la $1$ la $N$, in ordinea in care apar pe conturul poligonului. Cu aceasta numerotare a varfurilor, se defineste si o numerotare a laturilor. Latura $i (1 &le; i &le; N)$ este segmentul ce uneste varfurile $i$ si $i + 1$. Latura $N$ uneste varfurile $1$ si $N$.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se coordonatele mijloacelor laturilor unui poligon, determinati coordonatele varfurilor sale.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare poligon2.in se afla numarul intreg $N$, de laturi (si varfuri) ale poligonului. Pe urmatoarele $N$ linii se afla cate doua numere reale (cu maxim trei zecimale), separate printr-un spatiu, $x$ si $y$, reprezentand coordonatele mijloacelor fiecarei laturi, in ordine, de la $1$ la $N$.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $poligon2.out$ va contine mesajul $fara solutie$, in cazul in care Gigel a marcat gresit mijloacele laturilor si nu se poate forma nici un poligon avand mijloacele laturilor date. In cazul in care exista cel putin o solutie, veti afisa $N$ linii. Fiecare linie va contine doua numere reale, afisate cu trei zecimale, reprezentand coordonatele $(x,y)$ ale unui varf. Pe prima linie se vor afisa coordonatele varfului numerotat cu $1$, pe a doua linie, coordonatele varfului numerotat cu $2$ s.a.m.d.\r\n\r\nh2. Restrictii\r\n\r\n* $3 &le; N &le; 10.000$\r\n* Coordonatele mijloacelor laturilor sunt din intervalul $[0, 2.000.000.000]$.\r\n* In cazul in care problema admite cel putin o solutie, cu coordonatele varfurilor afisate in fisierul de iesire, se va calcula, pentru fiecare latura, coordonatele mijlocului acesteia. Veti primi punctaj maxim pentru testul respectiv, daca diferenta dintre valoarile calculate ale coordonatelor mijlocului si cele date in fisierul de intrare este cel mult $0,001$, pentru oricare latura. Altfel, nu veti primi nici un punct.\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. poligon2.in |_. poligon2.out |\r\n| 4\r\n0 0\r\n2 0\r\n2 2\r\n0 2\r\n| -1.000  1.000\r\n 1.000 -1.000\r\n 3.000  1.000\r\n 1.000  3.000 |\r\n| 4\r\n0 0\r\n2 0\r\n2 2\r\n1 3\r\n| fara solutie |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"poligon2\")==',18,'task: poligon2'),('problema/santa','Santa','2006-11-12 15:37:18','==Include(page=\"template/taskheader\" task_id=\"santa\")==\r\n\r\nHO HO HO... Max Damage a ajuns in Laponia, mai precis la fabrica de tractorase a lui Mos Craciun. Acum, toata lumea stie ca Mos Craciun are o lista cu copiii care au fost cuminti si ca le aduce in noaptea de ajun cate o jucarie, dar... sa zicem ca Max Damage nu mai e copil. El stie ca jucariile sunt gata si ca spiridusii vor trebui sa le duca de la atelierul lor (aflat in intersectia notata cu $S$ ) la casuta Mosului (aflata in intersectia notata cu $E$ ). Max Damage are o harta a orasului. Pe ea apar $N$ intersectii, numerotate de la $1$ la $N$ , unite de $M$ strazi. Acum Max Damage isi face urmatorul plan si are nevoie de ajutorul nostru. Stie ca maine spiridusii vor transporta jucariile de la atelier la casuta lui Mos Craciun. Problema este ca nu stie exact pe ce drum vor merge spiridusii, insa este cert ca ei nu vor trece de doua ori printr-o intersectie. Tot ce mai ramane de facut este ca Max sa sara in masina si sa verifice toate intersectiile in care s-ar putea gasi transportul de jucarii. Fiind si econom el nu trebuie sa treaca printr-o intersectie de doua ori sau prin intersectiile in care se stie sigur ca transportul de jucarii nu poate ajunge (sa fim seriosi, benzina costa destul de mult). Astfel el va pleca din \"sediul\" sau (intersectia notata cu $Q$ ) trecand prin toate si numai prin intersectiile unde transportul de jucarii ar putea ajunge. Turul de verificare facut de Max poate sa se sfarseasca in orice intersectie.\r\n\r\nh2. Cerinta\r\n\r\nDaca este posibila realizarea unui astfel de drum Max Damage va cere unul dintre ele.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $santa.in$ contine doua numere intregi $N$ , $M$ reprezentand numarul de intersectii, respectiv de strazi. Urmatoarele M linii contin cate doua numere $X{~i~}$ , $Y{~i~}$ reprezentand faptul ca exista o strada, care poate fi parcursa in ambele directii, intre intersectiile $X{~i~}$ si {$Y{~i~}$}. Pe ultima linie se afla trei numere $S$ , $E$ , $Q$ cu semnificatia de mai sus.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $santa.out$ veti afisa {@No chance@} daca Max nu isi poate realiza planul pentru fisierul de intrare corespunzator, sau numarul $X$ de intersectii (aflat pe prima linie) ce trebuie vizitate pentru a-si realiza planul, iar pe linia urmatoare numerele $A{~1~} A{~2~} ... A{~x~}$ separate prin spatii reprezentand intersectiile, in ordinea in care Max Damage treace pentru verificare.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 45.000$\r\n* $1 &le; M &le; 130.000$\r\n* oricum am alege un set de $16$ sau mai multe intersectii exista doua intersectii in set $A$ si $B$ astfel incat este imposibil sa gasim un drum care pleaca din $A$ , trece prin $B$ si revine in $A$ trecand printr-o intersectie cel mult odata(drumul poate sa treaca prin orice intersectie nu neaparat prin cele din setul ales).\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. santa.in |_. santa.out |\r\n| 5 5\r\n1 2\r\n1 4\r\n2 3\r\n3 4\r\n4 5\r\n1 4 2\r\n| 4\r\n2 1 4 3 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"santa\")==',961,'task: santa'),('problema/bifo','Bifo','2006-11-11 22:04:03','==Include(page=\"template/taskheader\" task_id=\"bifo\")==\r\n\r\nPentru a-si vindeca rana provocata de Spanul cel Negru, printul Algorel are nevoie de leacul miraculos aflat in posesia vrajitoarei din padurea intunecata. Aceasta i-a promis leacul daca ii rezolva urmatoarea problema, la care ea s-a gandit zadarnic o mie de ani: pornind de la doua cuvinte initiale $A{~1~}$ si $A{~2~}$ si aplicand \"formula bifo\" $A{~n~} = A{~n-2~}A{~n-1~}$ pentru {$3 &le; n$}, se obtin cuvintele $A{~3~}, A{~4~}, A{~5~}$ s.a.m.d. Prin $A{~n-2~}A{~n-1~}$ intelegem concatenarea cuvintelor $A{~n-2~}$ si $A{~n-1~}$ in aceasta ordine. Toate aceste cuvinte ({$A{~1~} A{~2~}, A{~3~} A{~4~}, A{~5~}$} s.a.m.d), sunt la randul lor concatenate, in ordine, formand un sir de caractere infinit denumit sir magic. Formula leacului miraculos are $M$ caractere, pe care vrajitoarea nu le stie. Se stiu insa cele $M$ pozitii din sirul magic in care apar, in ordine, caracterele din formula.\r\n\r\nh2. Cerinta\r\n\r\nCu toata inteligenta lui, Algorel nu poate rezolva aceasta problema. Ajutati-l pe print sa iasa din incurcatura afland formula leacului magic.\r\n\r\nh2. Date de Intrare\r\n\r\nPrimele doua linii ale fisierului $bifo.in$ contin fiecare cate un sir de cel mult $100$ de caractere reprezentand cuvintele $A{~1~}$ (pe prima linie) si respectiv $A{~2~}$ (pe a doua linie). A treia linie contine un numar intreg {$M$}, reprezentand numarul de caractere din formula leacului miraculos. Urmeaza $M$ linii descriind, in ordine, pozitiile din sirul magic unde se gasesc caracterele din formula.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bifo.out$ va contine pe prima linie un sir de $M$ caractere reprezentand formula leacului miraculos.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; M &le; 100$\r\n* $A{~1~}$ si $A{~2~}$ contin doar litere mici ale alfabetului englez\r\n* Numerotarea pozitiilor din sirul infinit incepe cu $1$\r\n* Cele $M$ pozitii vor fi numere intregi (nu neaparat distincte) de maxim $100$ de cifre\r\n* Pentru $60%$ din teste pozitiile vor fi numere intregi intre $1$ si $1.000.000.000$\r\n* Fiecare linie din fisierul de intrare si din fisierul de iesire se termina cu marcaj de sfarsit de linie\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bifo.in |_. bifo.out |\r\n| ab\r\ncdx\r\n3\r\n10\r\n4\r\n15\r\n| xdb |\r\n\r\nh3. Explicatii\r\n\r\nPrimele 5 siruri de caractere ob&#254;inute folosind formula bifo sunt:\r\n*ab, cdx, abcdx, cdxabcdx, abcdxcdxabcdx*\r\nConcatenand aceste siruri se ob&#254;ine sirul magic:\r\n{*abcdxabcdxcdxabcdxabcdxcdxabcdx*}...\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bifo\")==',15,'task: bifo'),('problema/calatorie','Calatorie interplanetara','2006-11-11 16:51:34','==Include(page=\"template/taskheader\" task_id=\"calatorie\")==\r\n\r\nO nava spatiala trebuie sa calatoreasca de la planeta $1$ la planeta $2$, apoi de la planeta $2$ la planeta $3$ si tot asa pana cand ajunge la planeta $N$. Cand calatoreste de la planeta $K$ la planeta $K+1$ nava spatiala are doua optiuni: viteza normala sau superviteza. Folosind viteza normala, timpul calatoriei de la planeta $K$ la planeta $K+1$ este $N{~k~}$ unitati de timp. Folosind superviteza, timpul calatoriei dintre planetele $K$ si $K+1$ este $H{~k~}$ unitati de timp. Pilotul navei spatiale este interesat sa consume cat mai putin combustibil in calatoria sa. El stie ca formula pentru consumul de combustibil este: {$N{~TOTAL~} + H{~TOTAL~}^4^$}, unde {$N{~TOTAL~}$} este totalul unitatilor de timp in care a folosit viteza normala, iar H{~TOTAL~} este totalul unitatilor de timp in care a folosit superviteza. De exemplu, sa presupunem ca sunt $5$ planete. De la planeta $1$ la planeta $2$ nava spatiala calatoreste $60$ unitati de timp folosind viteza normala. De la planeta $2$ la planeta $3$ nava spatiala calatoreste $3$ unitati de timp folosind superviteza.\r\nDe la planeta $3$ la planeta $4$ nava spatiala calatoreste $40$ de unitati de timp folosind viteza normala. De la planeta $4$ la planeta $5$ nava spatiala calatoreste $7$ unitati de timp folosind superviteza. {$N{~TOTAL~} = 60 + 40 = 100$} si {$H{~TOTAL~} = 3 + 7 = 10$}. Consumul de combustibil este {$100 + 10^4^ = 10100$}.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati Consumul minim de combustibil necesar calatoriei de la planeta $1$ la planeta $N$.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $calatorie.in$ contine numarul de teste $T$. Urmatoarele linii descriu cele $T$ teste. Prima linie a fiecarui test contine numarul de planete $N$. Urmatoarele $N-1$ linii contin $2$ numere intregi, $N{~K~}$ si $H{~K~}$, pentru $K = 1,2,..,N-1$.\r\n\r\nh2. Date de Iesire\r\n\r\nPentru fiecare test afisati in fisierul $calatorie.out$ o singura linie care sa respecte urmatorul format: $Consumul minim = XXX.$, unde $XXX$ trebuie inlocuit cu numarul gasit de programul vostru.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 50$\r\n* $1 &le; T &le; 155$\r\n* $1 &le; N{~k~} &le; 10^8^$\r\n* $1 &le; H{~k~} &le; 10$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. calatorie.in |_. calatorie.out |\r\n| 2\r\n4\r\n1000 3\r\n5000 2\r\n8000 4\r\n6\r\n10000 1\r\n3547 2\r\n36782 7\r\n2178 4\r\n67428 9\r\n| Consumul minim = 2296.\r\nConsumul minim = 52507. |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"calatorie\")==',18,'task: calatorie'),('problema/razboi','Razboiul lumilor','2006-11-12 15:27:47','==Include(page=\"template/taskheader\" task_id=\"razboi\")==\r\n\r\nTara A are $N$ orase numerotate de la $1$ la {$N$}. Aceste orase sunt conectate prin strazi bidirectionale in asa fel incat exista exact un singur drum intre orice pereche de orase. Deoarece tara A a fost atacata de tara B, tara A vrea sa pozitioneze intr-unul din orasele ei comandamentul armatei. Din motive defensive, comandamentul trebuie plasat in orasul cu proprietatea ca maximul distantei dintre orasul ales si oricare alt oras este minima (in cazul in care un oras oarecare este atacat, comandamentul trebuie sa ajunga acolo cat mai repede posibil; folosind proprietatea de mai sus se incearca minimizarea pagubelor in cazul cel mai defavorabil).\r\n\r\nh2. Cerinta\r\n\r\nGasiti toate orasele in care poate fi plasat comandamentul.\r\n\r\nh2. Data de intrare\r\n\r\nFisierul de intrare $razboi.in$ contine pe prima linie numarul $T$ de teste. Urmatoarele linii descriu cele $T$ teste. Prima linie a fiecarui test contine numarul {$N$}, reprezentand numarul de orase din tara A. Urmatoarele $N-1$ linii contin descrierea unei strazi - trei numere intregi separate prin spatii: {$A, B, D$}. $A$ si $B$ reprezinta numarul oraselor conectate de acea strada iar $D$ reprezinta lungimea strazii.\r\n\r\nh2. Date de iesire\r\n\r\nPentru fiecare test afisati in fisierul $razboi.out$ urmatoarea linie: \"Testul nr #{$XXX$}\", unde $XXX$ reprezinta numarul testului respectiv. Afisati apoi pe urmatoarele linii numarul oraselor in care ar putea fi plasat comandamentul. Aceste numere trebuie afisate in ordine crescatoare.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 16000$\r\n* $1 &le; D &le; 10000$\r\n* $1 &le; T &le; 20$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. razboi.in |_. razboi.out |\r\n| 3\r\n5\r\n1 2 1\r\n1 3 2\r\n1 4 3\r\n4 5 4\r\n2\r\n1 2 19\r\n3\r\n1 2 1\r\n2 3 1\r\n| Testul nr #1\r\n4\r\nTestul nr #2\r\n1\r\n2\r\nTestul nr #3\r\n2 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"razboi\")==',961,'task: razboi'),('problema/dmg','Dmg','2006-11-11 23:46:17','==Include(page=\"template/taskheader\" task_id=\"dmg\")==\r\n\r\nMax Damage s-a trezit intr-o zi pe varful stancii sale ... s-a uitat in zare si a vazut ca politia i-a dat de urma. Fuga nu ar fi o problema, oricum are o masina mai buna, dar Max doreste sa se distreze un pic. El stie ca daca ar merge de-a lungul unei drepte, politistii (care pot fi considerati niste puncte) ar cauta drumul minim pana la directia sa de mers, chiar daca s-ar intersecta cu aceasta mult dupa ce Max a trecut. Asa ca Max se gandeste daca nu cumva ii poate face pe politisti sa se loveasca doi cate doi, unul de celalalt (drumurile celor doi sa aiba directii opuse si sa se intersecteze cu drumul lui Damage in acelasi timp si in acelasi loc). Evident ca Max nu isi pune pune problema daca isi strica masina, deci drumul sau poate trece si prin politististi; evident, acestia sunt loviti de Damage deci nu mai trebuie sa se loveasca de nimeni. Din fericire, Max are un calculator de bord si ne-a trimis un email cuprinzand pozitiile politistilor. El cere un program care sa ii spuna in cate feluri poate\r\nrealiza ceea ce si-a propus.\r\n\r\nh2. Cerinta\r\n\r\nCate traiectorii care satisfac cerintele lui Max Damage exista si care sunt acestea.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $dmg.in$ contine un numar intreg $N$ reprezentand numarul de politisti. Urmatoarele $N$ linii contin cate doua numere reale cu $8$ zecimale, $X{~i~}, Y{~i~}$ reprezintand pozitia unui politist.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $dmg.out$ va contine numarul de traiectorii posibile pentru masina lui Max. Urmatoarele linii contin fiecare cate trei numere reale cu $8$ zecimale, {$A$}, $B$ si {$C$}, ce descriu o traiectorie de ecuatie {$A*X + B*Y + C = 0$}, ce indeplineste conditiile dorite de Max.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 1500$\r\n* $|X{~i~}| &le; 1000, |Y{~i~}| &le; 1000$\r\n* Max Damage nu e foarte \"stiintific\" si va verifica daca dreapta indeplineste conditiile sale cu o precizie de $0.01$\r\n* Pentru $25%$ din teste $N &le; 100$\r\n* Ce se intampla daca doi politisti sunt in acelasi punct ?\r\n* Politistii se deplaseaza cu aceeasi viteza constanta\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. dmg.in |_. dmg.out |\r\n| 2\r\n0 0\r\n10 0\r\n| 2\r\n-10.00000000 -0.00000000 50.00000000\r\n0.00000000 -5.00000000 0.00000000 |\r\n\r\nh3. Explicatii\r\n\r\nMax Damage poate merge perpendicular pe dreapta Ox, iar cei doi politisti se vor lovi la pozitia {$(0,5)$}, sau poate merge pe dreapta Ox lovind masinile celor doi politisti. Orice alta dreapta nu indeplineste cerintele lui Max.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"dmg\")==',961,'task: dmg'),('problema/palind','Palindroame','2006-11-11 19:02:35','==Include(page=\"template/taskheader\" task_id=\"palind\")==\r\n\r\nUn palindrom este un sir de caractere care este egal cu inversul sau. De exemplu $\"aerisirea\"$ este un palindrom. Dandu-se un sir de caractere vi se cere sa spuneti numarul minim de inversiuni ce trebuie efectuate pentru a-l transforma in palindrom. O inversiune reprezinta schimbarea intre ele a doua caractere adiacente. Pentru a transforma in palindrom $\"aeriseair\"$ sunt necesare $4$ inversiuni:\r\n* schimbam $\"ai\"$ : $\"aeriseiar\"$\r\n* schimbam $\"ei\"$ : $\"aerisiear\"$\r\n* schimbam $\"ar\"$ : $\"aerisiera\"$\r\n* schimbam $\"er\"$ : $\"aerisirea\"$\r\n\r\nh2. Date de Intrare (fisierul: $palind.in$)\r\n\r\nFisierul de intrare va contine mai multe teste. Pe prima linie se va afla numarul $T$ de teste.\r\nPe fiecare din urmatoarele $T$ teste se va afla un sir de caractere (litere mici ale alfabetului latin). Fiecare linie se termina cu enter.\r\n\r\nh2. Date de Iesire (fisierul $palind.out$)\r\n\r\nFisierul de iesire va contine $T$ linii. Pe linia $i$ se va afla numarul minim pentru a obtine palindrom din sirul de caractere aflat pe linia $i+1$ in fisierul de intrare sau $-1$ in cazul in care nu se poate obtine palindrom.\r\n\r\nh2. Restrictii\r\n\r\n* Numarul de caractere dintr-un sir nu va depasi $105$\r\n* T &le; 105\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. palind.in |_. palind.out |\r\n| 4\r\n  aeriseair\r\n  mamad\r\n  asd\r\n  aabb\r\n| 4\r\n  3\r\n  -1\r\n  2 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"palind\")==',48,'task: palind'),('problema/lesbulan','Lesbulan','2006-11-12 13:24:17','==Include(page=\"template/taskheader\" task_id=\"lesbulan\")==\r\n\r\n\r\nServicile secrete ale SUA au informatii despre zona unde se invarte teroristul Lesbulan. Acesta se ascunde intr-o serie de $N$ buncare care nu pot fi infiltrate. Buncarele sunt legate prin $M$ drumuri. Singura solutie pentru neutralizarea lui ar fi bombardarea buncarelor. Pentru a nu cauza scandal international, doar un buncar poate fi bombardat intr-o noapte, dupa bombardare buncarul nu va fi distrus ci refacut imediat pentru ca Lesbulan este un om plin de resurse. Serviciile secrete au mai aflat ca pentru a nu ii fi desconspirata locatia el schimba in fiecare seara buncarul in care isi va petrece noaptea si se va deplasa intr-un buncar vecin celui din noaptea anterioara.\r\n\r\nh2. Cerinta\r\n\r\nAjutati serviciile secrete sa determine daca exista o strategie de neutralizare a lui Lesbulan!\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul de intrare $lesbulan.in$ vom avea pe prima linie un numar intreg $T$ care corespunde numarului de configuratii de buncare din fisier. Pe urmatoarele linii se vor afla $T$ configuratii posibile ale buncarelor. Prima linie a fiecarui test va contine doua numere intregi $N$ si $M$. Pe urmatoarele $M$ linii vor fi situate cate doua numere intregi $X$ si $Y$, separate intre ele printr-un spatiu reprezentand existenta unui drum intre buncarele $X$ si $Y$. Testele vor fi separate de o linie goala asa cum se vede in exemplu.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $lesbulan.out$ va contine $T$ linii, linia a i-a avand numarul $1$ daca pentru configuratia a $i$-a din fisierul de intrare exista o strategie de neutralizare a lui Lesbulan sau un $0$ in caz contrar.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; T &le; 10$\r\n* $1 &le; N &le; 50$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. lesbulan.in |_. lesbulan.out |\r\n| 2\r\n2 1\r\n1 2\r\n&nbsp;\r\n4 6\r\n1 2\r\n1 3\r\n1 4\r\n2 3\r\n2 4\r\n3 4\r\n| 1\r\n0 |\r\n\r\nh3. Explicatie\r\n\r\nO strategie pentru primul caz este bombardarea de doua ori a orasului 1.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"lesbulan\")==',15,'task: lesbulan'),('problema/resturi','Resturi','2006-11-12 15:28:41','==Include(page=\"template/taskheader\" task_id=\"resturi\")==\r\n\r\n\r\nSe dau $N$ numere prime distincte $p{~1~}, p{~2~}, .. p{~N~}$ si $N$ resturi distincte $r{~1~}, r{~2~}, .. r{~N~}$.\r\n\r\nh2. Cerinta\r\n\r\nAflati cel mai mic numar nenegativ $X$ cu proprietatea $X mod p{~k~} = r{~k~}$, pentru orice $k$ intre $1$ si $N$.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare $resturi.in$ contine $T$, numarul de teste. Urmatoarele linii contin descrierea celor $T$ teste. Fiecare test incepe cu o linie pe care se afla $N$. Pe urmatoarele linii se afla cate $2$ intregi $p{~k~}$ si $r{~k~}$.\r\n\r\nh2. Date de iesire\r\n\r\nPentru fiecare test, afisati in fisierul de iesire $resturi.out$ o linie care contine un singur numar, $X$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $N &le; 30$\r\n* $1 < p{~k~} < 1000$ si $0 <= r{~k~} <= p{~k~}-1$, pentru $k$ intre $1$ si $N$\r\n* $a mod b$ reprezinta restul impartirii numarului $a$ la $b$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. resturi.in |_. resturi.out |\r\n| 3\r\n1\r\n2 1\r\n2\r\n2 0\r\n3 1\r\n3\r\n5 4\r\n11 3\r\n19 8\r\n| 1\r\n4\r\n179 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"resturi\")==',15,'task: resturi'),('problema/cai','Curse de cai','2006-11-11 22:49:39','==Include(page=\"template/taskheader\" task_id=\"cai\")==\r\n\r\nGigel si Ionel au fiecare cate $N$ cai. Acestia au hotarat sa se ia la intrecere si sa asiste la $N$ curse $1$ la $1$ intre caii lor. Fiecare cal va participa la exact o cursa, si fiecare cursa va pune fata in fata $2$ cai cu proprietari diferiti. Fiecare cal are o anumita viteza, iar o lupta este castigata de calul cu viteza mai mare. Pentru fiecare victorie, Gigel va primi $200$ de lei, pentru fiecare infrangere va fi nevoit sa plateasca aceeasi suma, iar in caz de remiza nu va plati si nu va primi nimic.\r\n\r\nh2. Cerinta\r\n\r\nStiind ca Gigel poate decide pentru fiecare din caii sai impotriva carui cal al lui Ionel va concura (respectand conditiile concursului), ajutati-l sa obtina o suma cat mai mare de bani de la Ionel.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $cai.in$ contine $T$, numarul de teste. Urmatoarele linii contin descrierea celor $T$ teste. Fiecare test incepe cu o linie pe care se afla N, numarul de cai dintr-o tabara. Pe linia a doua se afla $N$ intregi reprezentand vitezele cailor lui Gigel. Pe linia a treia se afla $N$ intregi reprezentand vitezele cailor lui Ionel.\r\n\r\nh2. Date de Iesire\r\n\r\nPentru fiecare test, afisati in fisierul de iesire $cai.out$ o linie care contine un singur numar, suma maxima pe care o poate obtine Gigel, in lei.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $N &le; 1.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. cai.in |_. cai.out |\r\n| 4 \r\n3 \r\n92 83 71\r\n95 87 74\r\n2\r\n20 20\r\n20 20\r\n2\r\n20 19\r\n22 18\r\n1\r\n13\r\n20 | 200\r\n0\r\n0\r\n-200 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cai\")==',1,'task: cai'),('problema/reg','Reg','2006-11-11 22:52:19','==Include(page=\"template/taskheader\" task_id=\"reg\")==\r\n\r\n\r\nAlgostorm a inceput sa programeze satelitii intergalactici intr-un limbaj de programare denumit SuperP++ . Un program in SuperP++ consta dintr-o serie de instructiuni (numele acestor instructiuni sunt niste numere intregi) care trebuiesc executate in ordine. Pentru a fi executata, o instructiune trebuie citita din registri (acestia sunt in numar de $K$ si fiecare registru poate retine cel mult o instructiune la un moment dat). Daca o instructiune nu exista in registri, aceasta trebuie incarcata inainte de a fi executata. O instructiune poate fi incarcata intr-un registru gol sau intr-un registru folosit caz in care instructiunea curenta este stearsa din registru (pentru eliberarea acestuia). Odata stearsa, o instructiune nu mai poate fi incarcata in nici un registru si la intalnirea ei in executarea programului acesta se intrerupe.\r\n\r\nh2. Cerinta\r\n\r\nAlgostorm a scris un program compus din $N$ instructiuni. Stiind numarul de registri, $K$, aflati care este numarul maxim de instructiuni din programul lui Algostorm care pot fi executate pana la intreruperea lui, respectand regulile de incarcare si citire.\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul $reg.in$ se afla pe prima linie un numar $T$ reprezentand numarul de teste care vor urma. Pe urmatoarele $T$ linii se afla cate $5$ numere: $A$, $B$, $C$, $N$, $K$. Programul lui Algostorm va fi descris de urmatoarele relatii ({$X{~i~}$} fiind instructiunea cu numarul $i$, {$i = 1..N$})\r\n\r\n$X{~1~} = 1$, $X{~i~} = (X{~i-1~} * A + B * i)$ mod $C$ pentru $i = 2..N$\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $reg.out$ va contine $T$ linii: pentru fiecare test se va afisa pe cate o linie numarul maxim de instructiuni din programul lui Algostorm care pot fi executate utilizand exact $K$ registri.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 2 000 000$\r\n* $1 &le; T &le; 10$\r\n* $1 &le; A, B, C, K &le; 500 000$\r\n* C este mereu prim\r\n* Suma numarului de instructiuni ale tuturor programelor dintr-un fisier de intrare nu va depasi $4 000 000$\r\n* Pentru $70%$ din fisierele de intrare $N &le; 400 000$\r\n* Instructiunile se vor executa in ordine, de la $1$ catre $N$\r\n* In timpul concursului s-a impus o limita de memorie de $7MB$ pentru segmentul de date si $1MB$ pentru stiva.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. reg.in |_. reg.out |\r\n| 2\r\n1 1 7 5 1\r\n2 3 5 8 2\r\n| 3\r\n6 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"reg\")==',15,'task: reg'),('problema/geamuri','Geamuri','2006-11-12 16:12:19','==Include(page=\"template/taskheader\" task_id=\"geamuri\")==\r\n\r\nEnervat de atatea probleme de pe InfoArena care nu-i ieseau si de atatea runde de GInfo cu probleme indentice, Geminski isi ia pistolul si pleaca sa impuste niste geamuri. Ajuns la fata locului, constata ca se afla in fata a $N$ geamuri dreptungiulare, fiecare bine delimitat in raport cu sistemul cartezian ortogonal. Geminski are la el $M$ gloante. Cand se decide sa traga un glont, el isi stabileste un punct bine delimitat in raport cu sistemul cartezian ortogonal, dupa care trage! Geminski are totusi une limitari, astfel ca nu poate trage decat din puncte cu coordonate cuprinse intre $1$ si {$C$}. Fiecare geam ce contine acel punct se va sparge. Geminski vrea ca atunci cand trage cu glontul al {$i$}-lea, sa sparga exact $K{~i~}$ geamuri.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine pentru fiecare glont pe care il trage Geminski din cate pozitii il poate trage astfel incat sa sparga exact $K{~i~}$ geamuri.\r\n\r\n\r\nDate intrare\r\n\r\nPrimele doua linii ale fisierului de intrare $geamuri.in$ contin numarele intregi {$C$}, respectiv {$N$}. Urmatoarele $N$ linii contin cate $4$ numere intregi $x{~0~}, y{~0~}, x{~1~}, y{~1~}$ reprezentand coordonatele geamurilor date prin coltul stanga-jos si dreapta-sus ({$1 &le; x{~0~} &le; x{~1~} &le; C, 1 &le; y{~0~} &le; y{~1~} &le; C$}). Urmatoare linie contine numarul intreg {$M$}, iar urmatoarele $M$ linii numerele $K{~i~}$ ({$1 &le; i &le; M$}), cate unul pe linie.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $geamuri.out$ va contine $M$ linii, cu numarul cautat pe fiecare linie.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; C &le; 1024$\r\n* $0 &le; K{~i~} &le; N &le; 50.000$\r\n* $1 &le; M &le; 50.000$\r\n* Geamurile se pot suprapune\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. geamuri.in |_. geamuri.out |\r\n| 8\r\n3\r\n2 2 5 4\r\n5 3 6 8\r\n4 4 7 6\r\n2\r\n3\r\n2\r\n| 1\r\n7 |\r\n\r\nh3. Explicatii\r\n\r\nPrimul glont poate fi tras doar din $({*5, 4*})$\r\nAl doilea din coordonatele {$({*4, 4*}), ({*5, 3*}), ({*5, 5*}), ({*5, 6*}), ({*6, 4*}), ({*6, 5*}), ({*6, 6*})$}\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"geamuri\")==',961,'task: geamuri'),('problema/distante','Distante','2006-11-11 23:27:54','==Include(page=\"template/taskheader\" task_id=\"distante\")==\r\n\r\nUn bun prieten de-al lui Zaharel, Bronzarel este la spital bolnav de tifos. Fiind buni prieteni, Zaharel se duce sa-l viziteze pe acesta. Ultima data cand a fost in vizita, Bronzarel desenase pe peretii spitalului mai multe grafuri neorientate conexe cu costuri (da, si Bronzarel este pasionat de informatica!) si mai mult de atat calculase pentru fiecare dintre acestea distantele minime de la un nod sursa ales la toate celelalte. Zaharel, curios ca intotdeana, a decis ca vrea sa vada daca Bronzarel delireaza sau nu si si-a notat pe o foaie de hartie ceea ce scrisese acesta pe pereti. Cand a ajuns acasa, el s-a decis sa vada pentru care din grafuri distantele minime calculate de Bronzarel erau corecte.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care-l ajuta pe Zaharel sa determine pentru fiecare graf daca distantele minime au fost calculate correct.\r\n\r\nh2. Date de intare\r\n\r\nPe prima linie din fisierul de intrare $distante.in$ se va gasi un numar {$T$}, reprezetand cate grafuri sunt pe foaie. Urmatoarele linii vor descrie succesiv cate un graf. Prima linie din descrierea unui graf va contine numerele {$N$}, {$M$}, si $S$ reprezentand numarul de noduri , numarul de muchii si, respectiv, nodul sursa de la care se calculeaza distantele minime. A doua linie din descriere contine $N$ elemente $D{~1~} D{~2~} ... D{~N~}$ reprezentand distantele minime calculate de Bronzarel. Urmatoarele $M$ linii vor contine cate trei numere naturale $a b c$ reprezentand faptul ca exista o muchie de cost $c$ de la $a$ la {$b$}.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $distante.out$ va contine $T$ linii, fiecare cu cate un cuvant: $DA$ daca distantele minime au fost calculate correct pentru graful respective, sau $NU$ altfel.\r\n\r\nh2. Restrictii\r\n\r\n* $0 &le; T &le; 10$\r\n* $1 &le; a,b,S &le; N &le; 50.000$\r\n* $0 &le; M &le; 100.000$\r\n* $0 &le; c &le; 1.000$\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. distante.in |_. distante.out |\r\n| 2\r\n5 6 1\r\n0 1 7 3 6\r\n1 2 1\r\n1 3 7\r\n1 4 3\r\n3 4 4\r\n2 5 5\r\n4 5 6\r\n4 4 2\r\n1 0 2 3\r\n1 2 1\r\n2 3 1\r\n2 4 1\r\n3 4 1\r\n| DA\r\nNU |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"distante\")==',961,'task: distante'),('problema/zebughil','Zebughil','2006-11-11 16:35:31','==Include(page=\"template/taskheader\" task_id=\"zebughil\")==\r\n\r\nZebu la ferma lui de gaini, in momentele de pauza in care nu trebuie sa hraneasca gainile sau sa faca curatenie, planuieste creearea unui monopol ovo-lactarian in judetul Bistrita Nasaud. Primul pas pentru indeplinirea acestui vis consta in construirea unei noi hale pentru gaini. Pentru a-si construi hala mult visata el a cumparat $N$ blocuri mari de piatra care vrea sa le aduca la el la firma pentru a le prelucra. Prietenul sau Ghilau are o firma de transporturi si isi ofera serviciile lui gratuit cu conditia ca Zebu sa foloseasca numarul minim de camioane pentru a transporta blocurile de piatra. Fiecare camion de la firma lui Ghilau are aceiasi capacitate maxima de transport $G$, iar blocurile lui Zebu au greutatile {$z{~i~}$}. Un camion va fi folosit o singura data pentru a nu se uza prea mult, iar o piatra nu poate fi taiata.\r\n\r\nh2. Cerinta\r\n\r\nAflati pentru Zebu care este numarul minim de camioane pe care trebuie sa le foloseasca pentru transportul blocurilor.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $zebughil.in$ va contine cate trei teste. Pe prima linie a fisierului se vor afla doi intregi $N$ si $G$ separati printr-un spatiu, reprezentand numarul de blocuri de piatra respectiv greutatea maxima suportata de un camion. Pe urmatoarea linie vor fi $N$ intregi separate prin cate un singur spatiu reprezentand dimensiunile blocurilor. Al doilea test va incepe de pe linia 3 si va fi structurat la fel, iar testul trei va incepe de pe linia 5.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $zebughil.out$ va contine pe trei linii cate un singur numar intreg reprezentand numarul minim de camioane cerut de pe testul corespunzator liniei respective.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 17$\r\n* $0 &le; z{~i~} &le; G &le; 2000000000$\r\n* Pentru teste in valoare cumulata de 70 de puncte, 0 &le; z{~i~} &le; G &le; 500\r\n* Nu se acorda punctaje partiale\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. zebughil.in |_. zebughil.out |\r\n|4 10\r\n6 7 5 4\r\n4 4\r\n2 3 1 2\r\n1 5\r\n1\r\n|3\r\n2\r\n1|\r\n\r\n_Explicatie_: pentru primul test putem repartiza blocurile in grupurile ${6, 4} {7} {5}$, pentru al doilea test in ${2, 2} {3, 1}$, iar pentru al treilea in ${1}$.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"zebughil\")==',256,'task: zebughil'),('problema/balans','Balans','2006-11-12 16:13:07','==Include(page=\"template/taskheader\" task_id=\"balans\")==\r\n\r\nBronzarel a iesit din spital si este sanatos acum. Imediat dupa ce a iesit s-a intalnit din nou cu bunul sau prieten Zaharel si acestia s-au pus pe rezolvat probleme! Una din problemele pe care au incercat s-o rezolve s-a dovedit prea dificila pentru ei, de aceea vor avea nevoie de ajutorul tau.\r\n\r\nFie $A$ o matrice de numere naturale cu $N$ linii si $M$ coloane. Vom defini o matrice $B$ de marime $P*Q$ ca fiind o submatrice a matricii $A$ daca exista numerele $(x,y)$ astfel incat $B{~i,j~} = A{~i+x,j+y~}$ pentru $1&le;i&le;P$ si $1&le;j&le;Q$. De asemenea, vom defini balansul unei matrici ca fiind raportul dintre suma tuturor elementelor din matrice si numarul acestora.\r\n\r\nProblema la care s-au chinuit Zaharel si Bronzarel cere sa se determine o submatrice de balans maxim a matrici $A$, care are cel putin $R$ randuri si $C$ coloane. Fiindca lucrurile nu sunt niciodata asa de \"simple\", matricea $A$ nu este o matrice oarecare, ci una chiar foarte speciala, si anume randurile si coloanele matricii pot fi permutate circular.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati submatricea de balans maxim dintr-o matrice data, tinand cont ca randurile si coloanele pot fi permutate circular inainte pentru a obtine un rezultat cat mai favorabil.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie din fisierul $balans.in$ va contine numerele $N,M,R,C$ reprezetand dimensiunea matricii $A$ si limitele inferioare ale dimensiunilor submatricii cerute. Urmatoarele $N$ linii vor contine cate $M$ numere naturale.\r\n\r\nh2. Date de Iesire\r\n\r\nFiserul $balans.out$ va contine pe o singura linie o valoare reprezentand balansul maxim posibil al unei submatrici. Rezultatul va fi afisat cu 3 zecimale exacte.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $1 &le; N, M &le; 150$\r\n* $0 &le; R &le; N$\r\n* $0 &le; C &le; M$\r\n* $0 &le; A{~i,j~} &le; 100.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. balans.in |_. balans.out |\r\n| 3 4 2 1\r\n 15 5 15 8\r\n 1 2 1 3\r\n 4 8 8 4 | 11.500 | \r\n\r\nh3. Explicatie\r\n\r\nSe permuta circular odata randurile si se obtine matricea:\r\n{$1&nbsp; 2 1&nbsp; 3$}\r\n{$4&nbsp; 8 *8*&nbsp; 4$}\r\n{$15 5 *15* 8$}\r\nSubmatricea de balans maxim este ingrosata. \r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"balans\")==',1,'task: balans'),('problema/euler','Euler','2006-11-12 00:59:48','==Include(page=\"template/taskheader\" task_id=\"euler\")==\r\n\r\nFie un arbore general cu radacina fixata. Arborele are $N$ noduri numerotate de la $1$ la $N$. O parcurgere euler a acestui arbore se face astfel: se tipareste radacina arborelui curent iar pentru fiecare din fii radacinii se afiseaza parcurgerea euler a subarborelui respectiv dupa care se afiseaza si radacina. De exemplu, pentru arborele cu $7$ noduri, cu radacina in nodul $5$ si cu lista de muchii $(5 3), (5 7), (3 6), (3 1), (3 2), (7 4)$, parcurgerea euler este $5 3 6 3 1 3 2 3 5 7 4 7 5$.\r\n\r\nh2. Cerinta\r\n\r\nProblema cere ca, dandu-se un numar $N$ si o succesiune de numere, sa se spuna daca succesiunea reprezinta o parcurgere euler corecta a unui arbore cu $N$ noduri si, in caz afirmativ, sa se reconstituie arborele.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul de intrare $euler.in$ se va afla pe prima linie numarul $N$, iar pe a doua linie o succesiunea de numere naturale cuprinse intre $1$ si $N$. Numarul de numere este necunoscut.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $euler.out$ va contine pe prima linie unul din mesajele $DA$ sau $NU$, in functie daca secventa de numere este sau nu o secventa euler a unui arbore cu $N$ noduri. Daca raspunsul este $DA$, a doua linie va contine $N$ numere naturale, unde al $i$-lea numar va fi tatal nodului $i$. Daca nodul $i$ este radacina, se va afisa pe pozitia corespunzatoare $0$.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 262 144$\r\n* Numarul de numere date nu depaseste $524 288$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. euler.in |_. euler.out |\r\n| 7 \r\n5 3 6 3 1 3 2 3 5 7 4 7 5 | DA\r\n3 3 5 7 0 3 5 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"euler\")==',1,'task: euler'),('problema/harta','Taramul Nicaieri','2006-11-12 13:31:48','==Include(page=\"template/taskheader\" task_id=\"harta\")==\r\n\r\nHarta \"Taramului nicaieri\" a fost pierduta, dar din fericire se mai stiu cateva date despre ea. Se stie ca exista $N$ orase intre care se afla diferite drumuri. Drumurile \"Taramului nicaieri\" sunt un pic mai ciudate deoarece daca exista un drum care pleaca din orasul $i$ si ajunge in orasul $j$ nu exista in mod obligatoriu si un drum care pleaca din orasul $j$ si ajunge in orasul {$i$}. Deasemenea nu vor exista drumuri care pleaca si ajung in acelasi oras. Si nu vor exista mai multe drumuri identice(adica sa coincida si orasul din care pleaca si cel in care se ajunge).Pentru fiecare oras se stiu cate drumuri pleaca din el si cate drumuri ajung in el.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care determina drumurile de pe harta initiala.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $harta.in$ contine numarul intreg {$N$}, reprezentand numarul de orase. Urmeaza apoi $N$ linii, linia $i$ continand doua numere $x,y$ numarul de drumuri care pleaca din orasul $i$ respectiv numarul de drumuri care intra in orasul {$i$}.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $harta.out$ veti afisa pe prima linie numarul $M$ de drumuri construite, apoi vor urma $M$ linii pe fiecare aflandu-se o pereche de numere $a,b$ cu semnificatia exista un drum care pleaca din $a$ si ajunge in {$b$}.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 100$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. harta.in |_. harta.out |\r\n| 4\r\n2 1\r\n0 2\r\n2 1\r\n1 1\r\n| 5\r\n1 2\r\n1 3\r\n3 2\r\n3 4\r\n4 1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"harta\")==',961,'task: harta'),('problema/sortari','Sortari','2006-11-12 14:37:23','==Include(page=\"template/taskheader\" task_id=\"sortari\")==\r\n\r\nIon si Vasile se joaca cu numerele. Ei au un sir de $N$ numere naturale si decid sa faca asupra lui $M$ operatii. O operatie consta in alegerea a doua pozitii $i$ si $j$ astfel incat $i &le; j$ si interschimbarea valorilor lor in cazul in care valoarea indicata de $i$ este mai mare decat cea indicata de $j$.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care determina (pentru mai multe subteste) daca operatiile alese de Ion si Vasile vor sorta crescator orice sir de $N$ numere, indiferent de asezarea lor initiala.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare $sortari.in$ contine numarul $T$ de teste, in continuare fiind descris fiecare test. Pe prima linie a fiecarui test vor exista 2 numere $N$ si {$M$}, reprezentand numarul de elemente din sirul lor, respectiv numarul de operatii alese. Urmeaza apoi $M$ linii, pe fiecare fiind cate 2 numere {$a{~i~},b{~i~}$}, descriind pozitiile alese pentru operatia respectiva.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $sortari.out$ vor exista $T$ linii, fiecare continand valoarea $1$ in cazul in care operatiile alese de Ion si Vasile sorteaza crescator orice sir de numere de lungime $N$ sau $0$ in caz contrar.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 17$\r\n* $1 &le; M &le; 600$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. sortari.in|_. sortari.out|\r\n|2\r\n4 6\r\n1 2\r\n2 3\r\n3 4\r\n1 2\r\n2 3\r\n1 2\r\n3 2\r\n2 3\r\n1 2\r\n|1\r\n0|\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sortari\")==',256,'task: sortari'),('problema/ciclu','Ciclu','2006-11-11 18:22:28','==Include(page=\"template/taskheader\" task_id=\"ciclu\")==\r\n\r\nAcarie, fericit ca a trecut examenul la algebra pleaca in oras sa sarbatoreasca. Este atat de fericit, incat nu se multumeste cu un simplu traseu intre terase, ci vrea un ciclu pentru a fi sigur ca poate continua sa petreaca cat timp doreste. Din pacate, drumurile dintre terase au costuri diferite si nu sunt bidirectionale. Acarie nu este interesat neaparat sa minimizeze costul acestui ciclu, ci doreste sa minimizeze costul mediu al ciclului (evident, vrea sa mearga cat mai putin intre terase, adica costul ciclului imparit la numarul de terase sa fie minim).\r\n\r\nAjutati-l si de aceasta data pe Acarie si va va cinsti toata ziua.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care determina costul mediu minim al unui ciclu de terase.\r\n\r\nh2. Date de Intrare\r\n\r\nDin fisierul $ciclu.in$ se citesc $N$ (numarul de terase), $M$ (numarul de drumuri unidirectionale) si cele $M$ drumuri directe dintre terase. Acestea sunt date fiecare pe cate o linie, reprezentate de trei intregi - terasa de unde porneste drumul, terasa unde ajunge drumul (numere intre $1$ si $N$) si costul drumului (intreg strict pozitiv mai mic decat $100.000$)\r\n\r\nh2. Date de Iesire\r\n\r\nSa se afiseze in fisierul ciclu.out costul mediu minim al ciclului gasit, cu o precizie de $2$ zecimale.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 1000$\r\n* $2 &le; M &le; 4000$\r\n* Se garanteaza ca exista cel putin un ciclu\r\n* Rezultatul se va verifica cu o precizie de $0.1$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. ciclu.in |_. ciclu.out |\r\n| 4 5\r\n1 2 1\r\n2 3 1\r\n1 3 1\r\n3 4 2\r\n4 1 3\r\n| 1.75 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"ciclu\")==',18,'task: ciclu'),('problema/coach','Coach','2006-11-11 18:45:06','==Include(page=\"template/taskheader\" task_id=\"Coach\")==\r\n\r\nSunteti antrenorul ciclistului Adirem Onamihs care, in ciuda numelui ciudat, este foarte talentat. In curant va avea loc un eveniment sportiv, un prilej foarte bun de a-l antrena pe ciclist. Pentru organizarea evenimentului s-au amenajat $N$ intersectii si $M$ drumuri bidirectionale intre aceste intersectii. Pentru fiecare drum se cunosc numarul de minute necesare pentru parcurgerea lui. La fiecare intersectie ciclistul care trece pe acolo este obligat sa serveasca o bautura energizanta si racoritoare. Bautura difera de la intersectie la intersectie si se cunosc deja numarul de calorii ale fiecarei bauturi.\r\n\r\nCa un mare antrenor, aveti un plan special pentru Adirem. Doriti ca durata traseului pe care il alege Adirem sa aiba exact $T$ ore, insa nu vreti sa-i planuiti intregul traseu (Adirem trebuie sa isi antreneze si mintea, nu numai corpul). Ii veti preciza lui Adirem doar intersectia de unde isi incepe traseul si intersectia unde il termina. Adirem invata repede - el stie intotdeauna sa aleaga traseul optim (drumul cel mai scurt dintre cele doua intersectii). Atunci cum il puteti face sa mearga exact $T$ ore? Dupa cateva portii de creatina, va vine ideea salvatoare: ii veti interzice trecerea prin anumite intersectii, sub pretextul ca valoarea calorica a bauturii servite in intersectia respectiva nu este benefica pentru antrenamentul lui. Astfel, ii veti preciza o limita inferioara si una superioara pentru numarul de calorii ale bauturilor pe care el are voie sa le bea. Adirem nu va trece decat prin intersectiile unde se serveste o bautura cu valoare calorica intre limitele date.\r\n\r\nCum numarul de intersectii este destul de mare, va trebui sa scrieti un program care sa calculeze cele patru variabile in antrenamentul lui Adirem: intersectia de start, intersectia de finish, valoarea calorica minima pe care poate sa o consume si valoarea calorica maxima, astfel incat drumul cel mai scurt dintre cele doua intersectii (care sa respecte restrictiile) sa dureze $T$ minute.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $coach.in$ contine trei numere intregi $N, M$ si $T$ reprezentand numarul de intersectii, drumuri, respectiv timpul dorit. Urmatoarele $N$ linii contin cate un numar - valoarile calorice a bauturilor din intersectii, in ordine (de la $1$ la $N$). Urmatoarele $M$ linii contin cate un triplet de numere: doua intersectii si durata drumului dintre ele.\r\n\r\nh2. Date de Iesire\r\n\r\nFiserul $coach.out$ va contine o linie, pe care se vor afla cele patru valori gasite: nodul de start, nodul de finish, valoarea calorica minima si valoarea calorica maxima. Nodurile vor fi intregi intre $1$ si $N$, iar valorile calorice vor fi intregi intre $1$ si $10.000$ (inclusiv).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N <= 100, 1 &le; M &le; 4.950, 1 &le; T &le; 1.000.000$\r\n* Costurile muchiilor sunt numere intregi intre $1$ si $10.000$ (inclusiv)\r\n* Caloriile bauturilor sunt numere intregi intre $1$ si $10.000$ (inclusiv)\r\n* Intersectiile gasite (de start si de finish) trebuie sa respecte si ele restrictiile calorice\r\n* O bautura cu valoarea calorica $x$ poate fi bauta daca si numai daca $cmin &le; x &le; cmax$, unde $cmin$ si $cmax$ sunt valorile calorice minime si maxime gasite\r\n* Intre doua intersectii exista maxim un drum\r\n* Valorile calorice sunt distincte\r\n* Exista intotdeauna solutie\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. coach.in |_. coach.out |\r\n| 6 9 11\r\n40\r\n10\r\n20\r\n30\r\n60\r\n50\r\n1 2 2\r\n1 3 2\r\n1 4 4\r\n1 6 10\r\n2 3 3\r\n2 4 1\r\n4 5 1\r\n4 6 5\r\n5 6 2\r\n| 3 6 20 55 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"Coach\")==',18,'task: coach'),('problema/insula','Insula','2006-11-12 13:56:32','==Include(page=\"template/taskheader\" task_id=\"insula\")==\r\n\r\nIntr-o zi, pe cand era in vizita la bunica ei, Adriana cauta ca de obicei carti vechi prin biblioteca. Deodata se opri asupra unei carti pe care erau inscriptionate intialele BA. Fetita curioasa, Adriana o deschise si incepu sa citeasca. Astfel afla ca intr-o tara foarte indepartata, unde totul e fermecat (inclusiv perlele), cresc niste arbori cu o proprietate ciudata : prin simpla rostire a unei formule magice, toti copacii isi modifica raza trunchiului. Cercetand mai in amanunt, Adriana descopera ca tara este de fapt o insula care are forma unui cerc. Mai mult, ea afla ca arborii de pe acea insula sunt plantati numai in puncte de coordonate intregi si numai in interiorul si pe marginile insulei. Pe ultima pagina, Adriana gasi harta tarii schitata intr-un sistem de axe ortogonale. Fiind convinsa ca ceva lipseste, se desena in centrul insulei si duse creionul la gura, gandindu-se : \"Ce frumos ar fi sa am si eu un astfel de loc al meu. Daca as sta in mijloc si as rosti forumula magica de un numar de\r\nori, as reusi sa ma fac nevazuta pentru orice privitor aflat pe marginea insulei\". Si tot gandindu-se, Adriana, fetita desteapta, reusi sa determine raza minima pe care trebuie sa o aiba trunchiurile astfel incat ea sa devina nevazuta. Voi puteti face acest lucru?\r\n\r\nh2. Cerinta\r\n\r\nDandu-se raza insulei, aflati raza minima $G$ pe care trebuie sa o aiba trunchiurlie arborilor astfel incat centrul sa nu poata fi vazut (implicit nici Adriana) din nici un punct de pe marginea insulei.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $insula.in$ contine numarul intreg $T$ , numarul de teste. Urmeaza apoi $T$ linii, pe fiecare aflandu-se cate un numar $Ri$ raza insulei.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $insula.out$ veti afisa $T$ linii pe fiecare aflandu-se raza minima $G$ pentru testul respectiv cu $3$ zecimale exacte.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; T &le; 10$\r\n* $1 &le; Ri &le; 100$\r\n* dupa rostirea formulei magice raza fiecarui arbore se va mari cu aceeasi unitate de lungime\r\n* initial arborii sunt punctiformi (raza lor tinde spre $0$ )\r\n* prin raza minima $G$ se intelege ca pentru orice alta raza $G\'(G\' < G)$ exista cel putin un punct de pe marginea insulei din care, daca privesti, o poti vedea pe Adriana\r\n* fiind o fetita mica de inaltime, Adriana va neglija coroana arborilor, interesand-o doar trunchiul acestora\r\n* centrul insulei va fi mereu un punct de coordonate intregi in care se afla doar Adriana\r\n* in interiorul insulei va fi plantat cel putin un arbore\r\n* pentru a evita aproximarile ( $0.09967$ sa fie scris ca $0.100$ ) rezultatul va fi afisat dupa urmatorul model : scrie ( $floor(G*1000)/1000.0$ )\r\n* gasirea cartii nu a fost mana destinului, ci doar mana Blaurului Arhirel, care inca sta la panda\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. insula.in |_. insula.out |\r\n| 2\r\n1\r\n2\r\n| 0.707\r\n0.447 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"insula\")==',961,'task: insula'),('problema/sticle','Sticle','2006-11-12 14:07:05','==Include(page=\"template/taskheader\" task_id=\"sticle\")==\r\n\r\nDupa ce a impuscat toate geamurile, Geminski se intoarce acasa unde gaseste un bilet de la domnisoara C., in care scria : \"Pe masa din bucatarie vei gasi $N$ sticle de vin, dintre care exact una este otravita. Oricine bea din acea sticla va muri sigur in 24 de ore. Pana ma intorc acasa sa afli care este sticla otravita!\"\r\n\r\nFiind foarte pasionat de animale, Geminski are pe balconul locuintei sale un numar practic nelimitat de chitosvarte. El vrea sa gaseasca sticla otravita testand sticlele de vin pe chitosvarte, insa doreste sa foloseasca cat mai putine animale posibil. Deasemenea, Geminski nu poate folosi aceeasi chitosvarta de mai multe ori, pentru ca domnisoara C. va sosi in mai putin de 47 de ore.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine pentru un $N$ dat numarul minim de chitosvarte necesar pentru a gasi sticla otravita.\r\n\r\nh2. Date intrare\r\n\r\nPrima linie a fisierului de intrare $sticle.in$ contine numarul de teste $T$. Urmatoarele $T$ linii contin cate un numar $N$ pe linie, reprezentand numarul de sticle pentru testul respectiv.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $sticle.out$ va contine $T$ linii, cu numarul cautat pe fiecare linie.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, T &le; 50 000$\r\n* Geminski are la dispozitie o singura zi\r\n* O singura chitosvarta poate bea din mai multe sticle in aceeasi zi\r\n\r\ntable(example). |_. sticle.in|_. sticle.out|\r\n|2\r\n3\r\n47\r\n|2\r\n6|\r\n\r\n_Explicatie_: Pentru primul test, Geminski da de baut din sticlele 1 si 3 unei chitosvarte si din sticlele 2 si 3 urmatoarei chitosvarte. Daca prima sticla e otravita, moare doar prima chitosvarta, daca sticla a doua e otravita moare a doua, daca sticla a treia e otravita mor ambele. Al doilea test e ceva mai complicat...\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sticle\")==',256,'task: sticle'),('problema/soldati','Soldati','2006-11-12 14:41:12','==Include(page=\"template/taskheader\" task_id=\"soldati\")==\r\n\r\n$N$ soldati sunt asezati in linie, de la stanga la dreapta. O parte dintre soldati au fata indreptata catre dreapta, ceilalti catre stanga. In fiecare unitate de timp (incepand de la momentul de timp {$0$}), daca 2 soldati de pe pozitii consecutive se uita unul catre celalalt (soldatul de pe pozitia din stanga se uita catre dreapta, iar soldatul de pe pozitia din dreapta se uita catre stanga), atunci ei se intorc in directii opuse (cel din stanga se intoarce cu fata catre dreapta, iar cel din dreapta se intoarce cu fata catre stanga). Toate perechile de soldati care se afla fata in fata se intorc in directii opuse simultan (in aceeasi unitate de timp). In mod evident, dupa un anumit numar de unitati de timp, nu vor mai exista perechi de soldati care se afla fata in fata (si, deci, nu se vor mai efectua intoarceri).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care determina dupa cate unitati de timp nu se mai efectueaza intoarceri.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului $soldati.in$ contine numarul intreg $T$ reprezentand numarul de teste din fisier. Pe urmatoarele $T$ linii se afla cate un sir de caractere din multimea {{$<$}, {$>$}}, care nu contine spatii si care este terminat cu caracterul de sfarsit de linie. Un caracter $<$ denota un soldat cu fata indreptata spre stanga, iar un caracter $>$ denota un soldat cu fata indreptata spre dreapta. Caracterele care descriu soldatii sunt scrise pe linie in ordinea in care se afla soldatii asezati in sir (de la stanga la dreapta).\r\n\r\nh2. Date de iesire\r\n\r\nPentru fiecare din cele $T$ teste, afisati in fisierul de iesire $soldati.out$ o linie care contine un numar intreg, reprezentand numarul de unitati de timp dupa care nu se mai efectueaza nici o intoarcere in cazul testului respectiv.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; T &le; 10$\r\n* Pe o linie se afla maxim $100 000$ de caractere din multimea {{$<$},{$>$}}\r\n* Pentru $20%$ din fisierele de test sirurile vor avea maxim $1 000$ de caractere\r\n\r\nh2. Exemplu:\r\n\r\ntable(example). |_. soldati.in|_. soldati.out|\r\n|3\r\n<<<>>>\r\n>>>><\r\n>>><<<         \r\n|0\r\n4\r\n5|\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"soldati\")==',256,'task: soldati'),('problema/monezi','Monezi','2006-11-11 20:42:42','==Include(page=\"template/taskheader\" task_id=\"monezi\")==\r\n\r\nPrintul Algorel are in trezoreria castelului $N$ tipuri de monezi de aur. Pentru fiecare tip se stie valoarea monezilor de tipul respectiv. Averea printului este imensa, deci se poate considera ca are un numar infinit de monezi de fiecare tip. Pentru a elibera printesa din mainile spanului cel lacom el nu trebuie sa faca vreun act de vitejie ci doar sa-i dea spanului monezi cu valoarea totala $S$. Desi doreste sa-si vada printesa cat mai repede, Algorel incepe sa se gandeasca la tot felul de probleme legate de trezoreria lui. De exemplu, el defineste pentru un subset de tipuri de monede, sa-l numim $X$, capacitatea de acoperire a acestuia ca fiind numarul de sume cuprinse intre $1$ si $S$ (inclusiv) pe care le poate obtine folosind numai monede de tipuri aflate in subsetul $X$. De la acest gand si pana la a calcula suma capacitatilor de acoperire a tutoror subseturilor de monede posibile nu a mai fost decat un pas.\r\n\r\nh2. Cerinta\r\n\r\nCalculati pentru Algorel suma capacitatilor de acoperire a tuturor subseturilor de tipuri de monede din trezoreria sa (in total sunt $2^N-1$ seturi posibile). Numai dupa ce afla raspunsul la problema aceasta Algorel se poate ocupa de eliberarea printesei.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $monezi.in$ contine doua numere intregi separate printr-un spatiu, $N$ si $S$, reprezentand numarul de tipuri de monezi si suma ce trebuie platita spanului. Urmatoarele $N$ linii contin cate un numar intreg, $V[i]$, reprezintand valoarea unei monezi din tipul $i$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $monezi.out$ va contine numarul pe care Algorel vrea sa-l afle, reprezentand suma capacitatilor de acoperire a tuturor subseturile de monede din trezoreria sa.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 17$\r\n* $1 &le; S &le; 512$\r\n* Valorile monezilor vor fi numere naturale intre $1$ si $500$\r\n* Nu vor exista doua tipuri de monezi cu aceeasi valoare\r\n* Se pot utiliza mai multe monezi de acelasi tip\r\n* Pentru $50%$ din teste $N &le; 10$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. monezi.in |_. monezi.out |\r\n| 2 10\r\n  2\r\n  3\r\n| 17 |\r\n\r\nh3. Explicatii\r\n\r\nCu subsetul {2} se pot obtine 5 sume: 2, 4, 6, 8, 10\r\nCu subsetul {3} se pot obtine 3 sume: 3, 6, 9\r\nCu subsetul {2,3} se pot obtine 9 sume: 2, 3, 4, 5, 6, 7, 8, 9, 10\r\nObservati ca nu e obligatoriu ca toate tipurile de moneda dintr-un subset sa fie folosite: de  exemplu suma 6 pentru ultimul subset se obtine folosind numai monede de tip &#8220;2&#8221; sau numai monede de tip &#8220;3&#8221; (daca le folosim pe amandoua nu putem obtine suma 6).\r\nNumarul cautat de Algorel va fi astfel 5+3+9=17.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"monezi\")==',48,'task: monezi'),('problema/mult','Mult','2006-11-12 16:20:24','==Include(page=\"template/taskheader\" task_id=\"mult\")==\r\n\r\nDoi copii (a caror identitate nu va fi dezvaluita pentru a le proteja intimitatea) au ajuns sa se joace cu o foaia de hartie pe care era scris un numar cu $N$ cifre. Primul dintre ei, din lipsa de ocupatie, anunta ca a aflat ca sunt $X$ moduri prin care se poate obtine un multiplu al unui numar $K$ din numarul de pe foaie, stergand una, mai multe sau nici o cifran din el. Cel de-al doilea sustine ca sunt $Y$ moduri si in felul acesta cei doi copii au inceput sa se certe toata ziua.\r\n\r\nh2. Cerinta\r\n\r\nAflati numarul de posibilitati de a obtine un multiplu a lui $K$ din numarul initial daca singura operatie permisa este stergerea unei cifre pentru ca cei doi copii sa se impace.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului $mult.in$ contine doua numere intregi $N$ si $K$ cu semnificatia din enunt. Urmatoarea linie contine $N$ cifre separate prin spatiu, care reprezinta numarul de pe foaie.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $mult.out$ se va scrie numarul pe care cei doi copii incearca sa-l afle.\r\n\r\nh2. Restrictii si precizari:\r\n\r\n* $1 &le; N &le; 2500$\r\n* $3 &le; K &le; 500$\r\n* Un numar se considera corect scris chiar daca are prima cifra $0$.\r\n\r\nh2. Exemplu:\r\n\r\ntable(example). |_. mult.in |_. mult.out |\r\n| 5 3\r\n  5 4 7 0 3\r\n| 11 |\r\n\r\nh3. Explicatii\r\n\r\nMultiplii care se pot obtine sunt: $0, 3, 03, 54 , 57, 540, 543, 570, 573, 5403, 5703$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"mult\")==',15,'task: mult'),('problema/car','Car','2006-11-11 17:05:12','==Include(page=\"template/taskheader\" task_id=\"car\")==\r\n\r\nIonel a implinit 18 ani si a luat permisul de conducere, azi vrea sa mearga de la el acasa pana la scoala cu masina si singura conditie pe care i-a impus-o tatal sau e aceea de a nu lua foarte multe curbe! Pentru a primi masina si alta data, Ionel vrea sa il impresioneze pe tatal sau si sa mearga pe drumul cel mai putin costisitor din punct de vedere al curbelor. Orasul e reprezentat de o matrice de $N$ linii si $M$ coloane, un element al matricii fiind $0$ daca pe acolo poate trece masina si $1$ daca nu. Masina se poate misca dintr-o celula a matricii in toate cele $8$ celule adiacente, daca ele sunt libere. Costul unui drum de la pozitia initiala la pozitia finala este data de suma costurilor miscarilor. O miscare in directia de mers are costul {$0$}, o miscare la $45$ de grade fata de directia de mers are costul {$1$}, o miscare la $90$ de grade are costul {$2$}, una la $135$ de grade are costul $3$ iar una la $180$ de grade are costul {$4$}. La momentul initial masina poate porni in oricare dintre cele $8$ directii, daca celula din\r\ndirectia respectiva este marcata cu {$0$}.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati pentru Ionel costul minim din punct de vedere al curbelor de la o pozitie initiala la o pozitie finala.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $car.in$ se gasesec doua numere naturale: $N$ (numarul de linii al matricii) si $M$ (numarul de coloane al matricii). Pe urmatoarea linie sunt numerele $Si$ - linia pozitiei initiale a masinii lui Ionel, $Sj$ - coloana pozitiei initiale ale masinii lui Ionel, $Fi$ - linia pozitiei finale, $Fj$ - coloana pozitiei finale. Pe urmatoarele $N$ linii sunt cate $M$ numere de $0$ sau {$1$}.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului de iesire $car.out$ se va gasi costul minim al unui drum de la pozitia initiala la pozitia finala. Daca nu exista nici un drum se va afisa {$-1$}.\r\n\r\nh2. Restrictii\r\n\r\n* $0 &le; N, M &le; 500$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. car.in |_. car.out |\r\n| 5 5\r\n1 1 1 4\r\n0 1 1 0 1\r\n1 0 1 0 1\r\n0 1 1 1 0\r\n1 0 1 0 1\r\n1 1 0 1 1\r\n| 9 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"car\")==',961,'task: car'),('problema/zapada','Zapada','2006-11-12 15:51:46','==Include(page=\"template/taskheader\" task_id=\"zapada\")==\r\n\r\nAlba-ca-zapada trebuie sa aiba grija de cei $N$ pitici si a strans din padure $N*(N+1)/2$ ciuperci pentru masa de pranz. Ea stie ca trebuie sa dea fiecarui pitic cate un numar de ciuperci astfel incat sa nu existe doi pitici care au acelasi numar de ciuperci. In plus, unii pitici merita mai multe ciuperci decat altii pentru ca au fost mai cuminti. Ea a notat in agenda ei $M$ perechi ({$u$}, {$v$}) indicand faptul ca piticul $u$ merita mai multe ciuperci decat piticul $v$. Imediat a realizat ca ea nu poate sa tina cont de toate notitele ei asa ca va elimina niste perechi cu urmatoarea coditie: daca piticul $u$ merita mai multe ciuperci decat piticii $v{~1~}$, $v{~2~}$, ..., $v{~k~}$ atunci ea va alege o modalitate de impartire a ciupercilor astfel incat cel putin unul din piticii $v{~1~}$, $v{~2~}$, ..., $v{~k~}$ sa primeasca mai putin decat piticul $u$. Evident aceasta conditie nu poate fi satisfacuta de piticul care va primi cele mai putine ciuperci, dar Alba-ca-zapada stie ca acest lucru este inevitabil si il accepta atata timp cat pentru ceilalti pitici conditia e satisfacuta.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati cate ciuperci va primi fiecare pitic astfel incat dorinta Albei-ca-zapada sa fie indeplinita.\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul $zapada.in$ se afla pe prima linie scris numarul $N$ de pitici, iar pe cea de a doua linie numarul $M$. Pe urmatoarele $M$ linii se vor afla cate doua numere intregi $u$ si $v$ cu semnificatia ca piticul $u$ merita mai multe ciuperci decat piticul $v$.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $zapada.out$ contine $N$ linii, linia $i$ continand un numar intreg {$X{~i~}$} reprezentand numarul de ciuperci primite de piticul numarul $i$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 < N < 100 000$\r\n\r\n* $0 < M < 350 000$\r\n\r\n* $0 < u, v &le; N$\r\n\r\n* Piticii sunt numerotati cu numerele de la $1$ la $N$\r\n\r\n* Pe toate testele de intrare va exista solutie. Daca exista mai mute solutii se va afisa doar una (oricare dintre ele)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. zapada.in |_. zapada.out |\r\n|5\r\n8\r\n1 2\r\n1 4\r\n1 3\r\n5 2\r\n2 5\r\n3 5\r\n4 3\r\n2 3\r\n|5\r\n3\r\n1\r\n2\r\n4\r\n|\r\n\r\n_Explicatie_: Piticul numarul 3 va primi o ciuperca, piticul numarul 4 va primi 2 ciuperci, piticul numarul 2 va primi 3 ciuperci, piticul numarul 5 va primi 4 ciuperci, piticul numarul 1 va primi 5 ciuperci. Piticul 3 a primit o ciuperca si deci nu va exista un alt pitic care sa primeasca mai putin decat el.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"zapada\")==',256,'task: zapada'),('problema/calcul','Calcul','2006-11-12 16:23:51','==Include(page=\"template/taskheader\" task_id=\"calcul\")==\r\n\r\nBronzarel a crescut mare si in curand va merge la facultate. Totusi, admiterea la facultate nu este asa de simpla, avand probe dificile precum matematica. Ca sa se pregateasca, Bronzarel lucreaza zilnic la matematica, efectuand diverse calcule. Zaharel vrea sa-i arate lui Bronzarel ca poate rezolva orice problema de matematica cu ajutorul calculatorului si a indemanarii lui de programator, si i-a cerut acestuia sa-i dea sa rezolve cea mai grea problema pe care o stie! Bronzarel a scris imediat pe o foaie de hartie urmatoarea suma:\r\n$S(A,B) = A^1^ + A^2^ + A^3^ + ... A^B^$\r\nsi i-a spus ca trebuie doar sa calculeze valoarea ei. Fiindca rezultatul poate fi un numar foarte mare, Bronzarel se multumeste daca Zaharel determina doar ultimele $C$ cifre ale sumei.\r\n\r\nh2. Cerinta\r\n\r\nImaginati-va ca sunteti in locul lui Zaharel si scrieti programul care ii va arata lui Bronzarel ca problemele dificile de matematica pot fi rezolvate cu ajutorul calculatorului!\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $calcul.in$ va contine numarul natural {$A$}, in baza {$10$}. A doua linie va contine numarul natural {$B$}, care va fi dat in baza {$16$}, iar a treia linie va contine numarul natural {$C$}.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului $calcul.out$ va contine ultimele $C$ cifre ale sumei mentionate mai sus.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $0 &le; A &le; 10^100.000^$\r\n* $1 &le; B &le; 16^50.000^$\r\n* $1 &le; C &le; 9$\r\n* Cifrele in baza $16$ sunt $0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F$ (doar majuscule)\r\n* Pentru $20%$ din teste $A &le; 10^9^$ si $B &le; 16^4^$\r\n* Pentru $60%$ din teste $B &le; 16^1.000^$\r\n* Pentru $50%$ din teste $cmmdc(A-1, 10^C^)=1$\r\n\r\n\r\nExemple\r\n\r\ntable(example). |_. calcul.in |_. calcul.out |\r\n|2\r\n7\r\n2\r\n| 54 |\r\n\r\nh3. Explicatii\r\n\r\n2^1^ + 2^2^ + 2^3^ + 2^4^ + 2^5^ + 2^6^ + 2^7^ = 254\r\n\r\ntable(example). |_. calcul.in |_. calcul.out |\r\n| 47\r\nC\r\n6\r\n| 851680 | \r\n\r\nh3. Explicatii\r\n\r\n47^1^+47^2^+47^3^+47^4^+47^5^+47^6^+47^7^+47^8^+47^9^+47^10^+47^11^+47^12^ = 118.717.384.915.664.851.680 \r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"calcul\")==',961,'task: calcul'),('problema/dmin','Drumuri minime','2006-11-11 23:54:58','==Include(page=\"template/taskheader\" task_id=\"dmin\")==\r\n\r\nIn anul 3000 oamenii locuiesc pe $N$ planete. Pentru a putea calatori mai usor, oamenii au construit legaturi galactice bidirectionale intre anumite perechi de planete. Aceste legaturi sunt alimentate de un generator spatial, si se stie cate unitati energetice consuma transportul prin fiecare legatura. Se poate calatori intre oricare doua planete fie prin legaturi directe, fie trecand prin planete intermediare. Totusi, din motive inca necunoscute, se intampla ca atunci cand se circula consecutiv prin mai multe legaturi se consuma o cantitate de energie egala cu produsul costului energetic al fiecarei legaturi in parte. Pentru a face o statistica, conducatorul fortelor armate doreste sa stie cate drumuri distincte cu consum minim de energie exista intre planeta $1$ si celelalte planete. Doua drumuri sunt distincte daca difera prin cel putin o legatura.\r\n\r\nh2. Cerinta\r\n\r\nCunoscand numarul de planete, precum si legaturile dintre acestea impreuna cu costurile lor energetice, se cere sa afisati numarul de drumuri minime intre planeta $1$ si celelalte planete. Fiecare numar va fi afisat modulo {$104659$}.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului dmin.in se afla numerele $N$ si $M$ reprezentand numarul de planete, respectiv numarul de legaturi. Urmeaza $M$ linii ce descriu legaturile dintre planete. Pe fiecare linie $i$ sunt afisate cate trei numere $x{~i~}, y{~i~}, c{~i~}$ cu semnificatia \"exista o legatura intre planetele $x{~i~}$ si $y{~i~}$ ce are costul energetic {$c{~i~}$}\".\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului dmin.out sunt afisate $N-1$ numere ce reprezinta numarul de drumuri minime intre planeta $1$ si celelalte planete, numarul $i$ reprezentand restul impartirii numarului de drumuri minime dintre planeta $1$ si planeta $i+1$ la {$104659$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 1500$\r\n* $1 &le; M &le; 2500$\r\n* costul energetic al unei legaturi este un numar intreg din intervalul [{$2, 10^9^$}]\r\n* intre oricare doua planete poate exista cel mult o legatura\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. dmin.in |_. dmin.out |\r\n| 8 9\r\n1 2 2\r\n1 3 3\r\n2 4 3\r\n3 4 2\r\n4 5 4\r\n5 6 2\r\n5 7 3\r\n6 8 3\r\n7 8 2\r\n| 1 1 2 2 2 2 4 |\r\n\r\nh3. Explicatie\r\n\r\n* Intre planetele $1$ si $2$ exista un singur drum minim de cost {$2$}.\r\n* Intre planetele $1$ si $3$ exista un singur drum minim de cost {$3$}.\r\n* Intre planetele $1$ si $4$ exista $2$ drumuri minime de cost {$6$}.\r\n* Intre planetele $1$ si $5$ exista $2$ drumuri minime de cost {$24$}.\r\n* Intre planetele $1$ si $6$ exista $2$ drumuri minime de cost {$48$}.\r\n* Intre planetele $1$ si $7$ exista $2$ drumuri minime de cost {$72$}.\r\n* Intre planetele $1$ si $8$ exista $4$ drumuri minme de cost {$144$}.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"dmin\")==',961,'task: dmin'),('problema/turneu','Turneu','2006-11-11 17:29:32','==Include(page=\"template/taskheader\" task_id=\"turneu\")==\r\n\r\nLa un turneu de fotbal participa $N$ echipe, intre fiecare doua dintre acestea avand loc un singur meci. Echipa castigatoare a unui meci acumuleaza un punct, iar in cazul in care un meci se incheie la egalitate fiecare echipa acumuleaza jumatate de punct. La sfarsitul turneului se contabilizeaza numarul de puncte acumulat de fiecare echipa, si se formeaza un clasament. Datorita numarului mare de echipe exista insa posibilitatea ca nu intotdeauna punctele sa fie contabilizate corect.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care, primind ca intrare un sir de $N$ numere rationale, sa decida daca acestea pot fi sau nu punctajele obtinute in urma unui turneu de fotbal.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului $turneu.in$ contine un numar intreg $T$ reprezentand numarul de siruri de punctaje care trebuie analizate. Urmatoarele $T$ linii contin fiecare cate un numar natural $N$ reprezentand numarul de echipe aflate in turneu si apoi $N$ numere rationale cu cel mult o zecimala, in ordine crescatoare, reprezentand punctajele fiecarei echipe.\r\n\r\nh2. Date de iesire\r\n\r\nPentru fiecare din cele $T$ teste afisati in fisierul de iesire $turneu.out$ o linie continand $YES$ daca sirul poate fi rezultatul unui turneu sau $NO$ altfel.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100 000$\r\n* $1 &le; T &le; 10$\r\n* Pentru $50%$ din teste $N &le; 1500$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. turneu.in |_. turneu.out |\r\n|7\r\n4 0 1 2 3 \r\n4 0 1 2.5 2.5 \r\n4 1.5 1.5 2 2\r\n4 0 2 2 2 \r\n4 0 1 1 4\r\n5 0 1 2 3 3\r\n10 1 1 1 1 5 5 7 7 8 9\r\n|YES \r\nYES \r\nNO\r\nYES\r\nNO\r\nNO\r\nNO|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"turneu\")==',256,'task: turneu'),('problema/gfact','GFact','2006-11-11 23:06:56','==Include(page=\"template/taskheader\" task_id=\"gfact\")==\r\n\r\nh2. Cerinta\r\n\r\nFiind dat un numar natural $A$ aflati cel mai mic numar natural $B$ astfel incat $B!$ se divide la $A$.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare contine pe prima linie doua numere intregi separate printr-un spatiu, $P$ si $Q$, astfel incat $A = P^Q^$.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire va contine numarul natural $B$ cu propietatea din enunt.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; P &le; 2.000.000.000$\r\n* $1 &le; Q &le; 30.000$\r\n* Pentru $70%$ din teste $Q = 1$, din care $30%$ au $P &le; 1.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. gfact.in |_. gfact.out |\r\n| 2 3\r\n| 4 |\r\n\r\nh3. Explicatii\r\n\r\nA = 2^3^ = 8; 4! = 24 (care se divide la 8)\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"gfact\")==',15,'task: gfact'),('problema/trapeze','Trapeze','2006-11-11 18:22:37','==Include(page=\"template/taskheader\" task_id=\"trapeze\")==\r\n\r\nDaca te joci cu $N$ obiecte identice de forma rotunda si incerci sa formezi diferite forme cu toate obiectele, apar figuri interesante. Una dintre figurile cele mai frumoase este trapezul. El este format din mai multe linii (cel putin una). Pe prima linie stau $A$ obiecte ({$A &ge; 1$}). Pe urmatoarea linie (daca exista) stau $A+1$ obiecte, si tot asa pana se folosesc toate obiectele. De exemplu, cu $15$ obiecte putem forma $4$ trapeze distincte:\r\n\r\n1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* *\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * * *\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp; * * * *\r\n\r\n&nbsp;&nbsp;&nbsp; * * * * *\r\n\r\n\r\n\r\n2 &nbsp;&nbsp; * * * *\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp; * * * * *\r\n\r\n&nbsp;&nbsp;&nbsp; * * * * * *\r\n\r\n\r\n\r\n3 &nbsp; * * * * * * *\r\n\r\n&nbsp;&nbsp; * * * * * * * *\r\n\r\n\r\n\r\n4 &nbsp; * * * * * * * * * * * * * * *\r\n\r\n\r\nEste important ca toate piesele sa fie folosite in constructia oricarui trapez si toate liniile sa fie complete. Este foarte usor sa determini pentru un numar dat de obiecte care este numarul total de trapeze distincte ce se pot forma. De exemplu, pentru $15$ obiecte numarul total de trapeze este $4$. Mai greu este sa determini care este numarul minim de obiecte necesare pentru a putea forma in total exact $K$ trapeze distincte.\r\n\r\nh2. Cerinta\r\n\r\nPentru valoarea lui $K$ data, determinati numarul minim de obiecte necesare pentru a forma exact $K$ trapeze.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $trapeze.in$ va contine pe prima linie numarul natural $K$.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $trapeze.out$ va contine o singura linie pe care va fi scris numarul minim de obiecte necesare pentru a forma in total exact $K$ trapeze.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; K &le; 100$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. trapeze.in |_. trapeze.out |_. trapeze.in |_. trapeze.out |\r\n|4|15|5|81|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"trapeze\")==',256,'task: trapeze'),('problema/barman','Barman','2006-11-12 16:06:01','==Include(page=\"template/taskheader\" task_id=\"barman\")==\r\n\r\nPaftenie a decis sa se faca barman. Inainte de asta trebuie sa dovedeasca abilitate in manevrarea bauturilor. Barul lui Paftenie este alcatuit din $N$ camere aliniate in cerc. In fiecare camera se afla un pahar cu bautura, fiecare bautura avand o anumita valoare (cuprinsa intre $1$ si $2.000.000.000$). El trebuie sa mute bauturile dintr-o camera in alta astfel incat la sfarsit, bauturile sa fie sortate dupa camere. Daca la sfarsit in camera $i$ se afla o bautura cu valoarea $a{~i~}$, sirul valorilor $a{~1~},a{~2~}...a{~N~}$ se considera sortat daca exista $1 &le; i &le; N$ astfel incat $a{~i~} &le; a{~i+1~} &le; ... &le; a{~N~} &le; a{~1~} &le; ... &le; a{~i-1~}$ (sirul este circular). In orice moment, Paftenie poate tine pe tava cel mult doua pahare. Pentru deplasarea bauturilor, poate efectua urmatoarele mutari:\r\n\r\n* poate lua un pahar din camera in care se afla si sa il aseze pe tava (il costa $10$ secunde)\r\n* poate lasa un pahar intr-o camera in care nu se afla nici o bautura (il costa $10$ secunde)\r\n* se poate deplasa din camera $i$ in camera $j$ avand pe tava $c$ pahare ({$0 &le; c &le; 2$}) (il costa $c*|i-j|$ secunde)\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Paftenie sa sorteze paharele intr-un timp minim!\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $barman.in$ este dat numarul $N$ al bauturilor. Pe urmatoarea linie se afla $N$ intregi reprezentand valorile bauturilor - al $i$-lea numar reprezinta valoarea bauturii aflate initial in camera $i$ ({$a{~i~}$}).\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $barman.out$ va contine pe prima linie un singur numar reprezentand timpul minim de sortare a bauturilor.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 600$\r\n* In orice moment, in afara de paharele care le are paftenie pe tava, intr-o camera poate exista maxim un pahar\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. barman.in |_. barman.out |\r\n| 4\r\n1 5 2 2\r\n| 42 |\r\n\r\nh3. Explicatii\r\n\r\n$o 5 2 2$ merge in camera $1$ si pune paharul de acolo pe tava ({$10$}s)\r\n$o 5 2 2$ merge din camera $1$ in camera $2$ cu un pahar pe tava ({$1$}s)\r\n$o o 2 2$ pune pe tava paharul din camera $2$ ({$10$}s)\r\n$o 1 2 2$ asaza pe masa din camera $2$ paharul cu bautura de valoare $1$ ({$10$}s)\r\n$o 1 2 2$ se intoarce in camera $1$ cu un pahar pe tava ({$1$}s)\r\n$5 1 2 2$ asaza pe masa din camera $1$ paharul cu bautura de valoare $5$ ({$10$}s)\r\n&#8594; $42$ de secunde\r\nsirul este sortat deoarece {$1 &le; 2 &le; 2 &le; 5 (a2 &le; a3 &le; a4 &le; a1)$}\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"barman\")==',961,'task: barman'),('problema/grupuri','Grupuri','2006-11-12 15:02:46','==Include(page=\"template/taskheader\" task_id=\"grupuri\")==\r\n\r\nInainte sa se apuce de informatica, Bronzarel avea alta ocupatie, si anume era negustor de animale. Fiindca a renuntat la acesta profesie pentru cea de informatician, trebuie acum sa-si vanda animalele. La targ, el nu poate vinde doar un animal, ci trebuie sa le vanda pe grupuri, fiecare grup fiind format din fix $K$ animale de tipuri {*distincte*}.\r\n\r\nh2. Cerinta\r\n\r\nStiind ca Bronzarel avea $N$ tipuri de animale, si cantitatea $A{~i~}$ din fiecare tip, determinati care este numarul maxim de grupuri pe care le poate forma, pentru a le vinde la targ.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $grupuri.in$ va contine numerele naturale $K$ si {$N$}. Urmatoarea linie va contine $N$ numere naturale $A{~1~},A{~2~},...A{~N~}$ reprezetand cantitatile disponibile din fiecare tip de animal. Cantitatile vor fi date in {*ordine crescatoare*} ({$A{~i~} &le; A{~i+1~}$}).\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie din fisierul $grupuri.out$ se va scrie o singura valoare reprezentand numarul maxim de grupuri care se pot forma.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $1 &le; K &le; N &le; 100.000$\r\n* $0 &le; A{~i~} &le; 1.000.000$\r\n* Pentru cel putin $60%$ din teste $N &le; 50$\r\n\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. grupuri.in |_. grupuri.out |\r\n| 3 4\r\n3 3 3 3\r\n| 4 |\r\n| 5 7\r\n1 2 3 4 5 6 7\r\n| 5 |\r\n\r\nh3. Explicatie\r\n\r\n# Presupunand ca animalele sunt vaci, cai, oi si gaini, o distribuire in grupuri ar putea fi:\r\n## ({$vaca,  cal,  oaie$})\r\n## ({$vaca,  cal, gaina$})\r\n## ({$vaca, oaie, gaina$})\r\n## ({$cal, oaie, gaina$})\r\n# Vom considera acum ca tipurile de animalele sunt numerotate de la $1$ la $7$\r\n## ({$1, 3, 5, 6, 7$})\r\n## ({$2, 4, 5, 6, 7$})\r\n## ({$2, 4, 5, 6, 7$})\r\n## ({$3, 4, 5, 6, 7$})\r\n## ({$3, 4, 5, 6, 7$})\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"grupuri\")==',961,'task: grupuri'),('problema/struti','Struti','2006-11-12 16:15:33','==Include(page=\"template/taskheader\" task_id=\"struti\")==\r\n\r\nPatratel s-a lasat de scoala si, pentru ca a aflat ca sunt foarte profitabile, s-a apucat de afaceri cu struti. Pentru a demara afacerea sa, el are nevoie mai intai de toate sa cumpere teren in regiune. Regiunea este dreptunghiulara si are dimensiunile de $M$ km x $N$ km, fiind impartita in zone de $1$ x $1$ km. Fiecare zona are o altitudine cunoscuta, specificata pe harta in metri fata de nivelul marii. Astfel, toate altitudinile sunt numere intregi nenegative. Terenul pe care Patratel vrea sa il cumpere in aceasta regiune trebuie sa fie de asemenea dreptunghiular si sa aiba laturile paralele cu ale regiunii. In plus, terenul nu trebuie ales la intamplare. Pentru ca a studiat comportamentul strutilor, el si-a dat seama ca sunt animale destul de pretentioase. Se defineste diferenta de altitudine a unui teren ca fiind diferenta dintre altitudinea maxima si altitudinea minima ale unor zone de $1$ km^2^ cuprinse in teren. Pentru ca strutii sa se dezvolte optim, diferenta de altitudine a terenului ales trebuie sa fie cat mai mica posibil.\r\n\r\nPatratel primeste $P$ oferte pe care trebuie sa le analizeze. O oferta este formata dintr-o pereche de numere naturale ({$DX DY$}), semnificand faptul ca Patratel poate alege oriunde in regiune un teren cu laturile de dimensiuni $DX$ si $DY$ ( nu neaparat in aceasta ordine ). Pentru fiecare oferta in parte Patratel ar dori sa stie care este diferenta de altitudine minima a unui teren cu laturile specificate in oferta.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati diferenta de altitudine mimima pentru fiecare oferta in parte.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului $struti.in$ contine $M$, $N$ si $P$, dimensiunile regiunii si numarul de oferte, despartite de cate un spatiu. Pe fiecare din urmatoarele $M$ linii se afla cate $N$ numere naturale nenegative, specificand altitudinea zonei respective. Urmatoarele $P$ linii descriu cate o oferta, compusa din doua numere naturale $DX$ si $DY$, cu semnificatiile descrise in enunt.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul $struti.out$ contine $P$ linii, pe linia $i$ aflandu-se $MIN$ si $NR$, diferenta de altitudine minima pentru oferta a $i$-a si numarul de terenuri posibile cu aceasta diferenta minima.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; M, N &le; 1 000$\r\n* $P &le; 10$\r\n* $1 < DX, DY &le; minim(M, N)$\r\n* Fiecare teren selectat trebuie sa fie inclus complet in regiune\r\n* Toate altitudinile sunt date in metri si nu depasesc $8 000$\r\n* Punctele pe un test se acorda doar daca fisierul de iesire este in intregime corect\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. struti.in|_. struti.out|\r\n|4 4 2\r\n1 4 3 2\r\n5 4 8 9\r\n3 8 5 8\r\n2 0 6 4\r\n2 3\r\n2 2\r\n|5 4 \r\n4 4\r\n|\r\n\r\nh3. Explicatii\r\n\r\nCele patru terenuri care pot fi selectate pentru prima oferta sunt cele ingrosate:\r\n{$1 4 3 2   1 4 3 2   1 4 3 2   1 **4 3** 2$}\r\n{$5 4 **8 9**   5 **4 8 9**   **5 4 8** 9   5 **4 8** 9$}\r\n{$3 8 **5 8**   3 **8 5 8**   **3 8 5** 8   3 **8 5** 8$}\r\n{$2 0 **6 4**   2 0 6 4   2 0 6 4   2 0 6 4|$}\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"struti\")==',1,'task: struti'),('problema/pawns','Pawns','2006-11-12 13:58:54','==Include(page=\"template/taskheader\" task_id=\"pawns\")==\r\n\r\n\r\nSe considera o tabla impartita in mai multe celule care contin pioni. Celulele sunt conectate intre ele prin sageti, si mergand de la orice celula in directia in care indica sagetile nu vom ajunge niciodata in locul din care am plecat. Deci, exista celule din care nu pleaca sageti si celule in care nu ajung sageti.\r\nConsideram doi jucatori. Fiecare jucator poate muta, cand ii vine randul, un pion din celula in care se afla intr-o celula spre care pleaca o sageata. Cel care nu mai poate muta atunci cand ii vine randul pierde partida. La inceputul unui joc, prima mutare o face jucatorul $1$.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine daca jucatorul $1$ are strategie sigura de castig.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $pawns.in$ contine pe prima linie doua numere intregi $n$ si $m$, separate printr-un singur spatiu, care reprezinta numarul de celule de pe tabla, respectiv numarul de sageti.\r\nPe fiecare dintre urmatoarele $m$ linii se afla cate doua numere intregi $x$ si $y$, separate intre ele printr-un singur spatiu, cu semnificatia ca exista o sageata care pleaca din celula cu numarul de ordine $x$ si ajunge in celula cu numarul de ordine $y$.\r\nPe linia urmatoare se afla un numar $t$ care reprezinta numarul de jocuri care se joaca.\r\nPe fiecare dintre urmatoarele $t$ linii se afla $n$ numere intregi, separate intre ele prin spatii, care reprezinta numarul de pioni din fiecare celula pentru un anumit joc.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $pawns.out$ trebuie sa contina $t$ linii. Fiecare dintre cele $t$ linii va contine valoarea $0$, daca pentru o configuratie jucatorul $1$ nu are strategie sigura de castig si valoarea $1$ in caz contrar.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; n, m &le; 500$\r\n* $1 &le; t &le; 15$\r\n* Numarul de pioni dintr-o celula nu va depasi valoarea $500$\r\n* Celulele sunt numerotate de la $1$ la $n$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. pawns.in |_. pawns.out |\r\n| 3 3\r\n1 2\r\n1 3\r\n2 3\r\n2\r\n1 0 0\r\n2 2 2\r\n| 1\r\n0 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"pawns\")==',15,'task: pawns'),('problema/stramosi','Stramosi','2006-11-12 14:03:11','==Include(page=\"template/taskheader\" task_id=\"stramosi\")==\r\n\r\nFamilia lui Gigel este foarte numeroasa, avand exact $N$ membri. Fiecare membru stie cine este stramosul lui direct, mai putin cativa membri care sunt foarte batrani si nu mai tin minte nici macar cine a fost stramosul lor direct. Gigel, fiind o fire curioasa a facut un inventar al familiei sale, in sensul ca a numerotat fiecare membru cu un numar distinct intre 1 si $N$ si stie de asemenea pentru fiecare membru, care este stramosul lui direct (daca acesta exista). Curiozitatea lui este si mai mare, in sensul ca isi pune $M$ intrebari de forma: _\"Care este al $P$-lea stramos al membrului cu numarul $Q$?\"_.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care raspunde corect la toate cele M intrebari ale lui Gigel.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linia a fisierului $stramosi.in$ se afla numerele $N$ si $M$. Pe a doua linie se afla $N$ numere intregi, reprezentand stramosii tuturor membrilor, incepand cu membrul $1$ si terminand cu membrul $N$. Daca un membru nu are stramos, atunci in fisier se va afla numarul $0$. Pe urmatoarele $M$ linii se afla perechi de numere $Q$ si $P$, reprezentand o intrebare de forma: _\"Care este al $P$-lea stramos al membrului cu numarul $Q$?\"_.\r\n\r\nh2. Date de iesire\r\n\r\nPe fiecare din cele $M$ linii ale fisierului $stramosi.out$ se vor afla raspunsurile la intrebari, adica numerele de ordine al stramosilor (sau $0$ daca identitatea stramosului nu este cunoscuta)\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 250 000$\r\n* $1 &le; M &le; 300 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. stramosi.in |_. stramosi.out |\r\n|13 7\r\n0 1 2 2 4 1 6 0 8 8 10 10 12\r\n5 2\r\n3 2\r\n7 1\r\n1 3\r\n13 3\r\n9 2\r\n11 1\r\n|2\r\n1\r\n6\r\n0\r\n8\r\n0\r\n10\r\n|\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"stramosi\")==',256,'task: stramosi'),('problema/invsc','Invsc','2006-11-12 13:48:49','==Include(page=\"template/taskheader\" task_id=\"invsc\")==\r\n\r\nGigel tocmai invatase la scoala algoritmul de calcul a celui mai lung subsir crescator a unui sir de numere naturale. Si atat de mult i-a placut, incat a stat cateva zile si a aplicat acest algoritm pe mai multe siruri de numere( distincte doua cate doua). Pentru asta el se folosea de un vector auxiliar $v$ cu semnficatia {$v{~i~}$}= lungimea celui mai lung subsir crescator din sirul initial care se termina pe pozitia {$i$}( evident rezultatul era reprezentat de maximul din acest vector). Vrand sa ia o nota buna pentru efortul depus e a vrut sa duca profesorului sau de informatica toate calculele sale. Doar ca exact inainte sa plece Gigel de acasa ,sora sa, Georgiana, a luat toate foile cu sirurile pe care acesta aplicase alogitmul tocmai invatat si le-a rupt in bucatele. Lui Gigel i-au ramas astfel doar foile cu vectorii auxiliari folositi.\r\n\r\nh2. Cerinta\r\n\r\nNeavand timp sa asambleze la loc toate foile, Gigel are nevoie de ajutorul vostru pentru a reconstitui vectorii initiali.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $invsc.in$ va contine numarul natural nenul $N$ reprezentand lungimea unui sir pe care Gigel a aplicat algoritmul tocmai invatat. Pe urmatoarele $N$ linii este dat vectorul auxiliar $v$ calculat de Gigel.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $invsc.out$ va contine sirul initial de la care a plecat Gigel, adica $N$ numere naturale nenule distincte cu maxim $8$ cifre, fiecare numar pe o linie separata.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $N &le; 200.000$\r\n* se garanteaza ca pentru fiecare test va exista cel putin o solutie\r\n* in cazul in care exista mai multe solutii se poate afisa oricare dintre ele\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. invsc.in |_. invsc.out |\r\n| 5\r\n1\r\n2\r\n2\r\n2\r\n3\r\n| 5\r\n10\r\n7\r\n6\r\n12 |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"invsc\")==',961,'task: invsc'),('problema/nrtri','Numarare triunghiuri','2006-12-03 00:16:37','==Include(page=\"template/taskheader\" task_id=\"nrtri\")==\r\n\r\nAndrei are $N$ betisoare de lungimi nu neaparat diferite. El vrea sa afle in cate moduri poate alege trei betisoare astfel incat sa poata forma cu ele un triunghi.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se lungimile betisoarelor aflati in cate moduri se pot alege trei dintre ele astfel incat sa se poata forma un triunghi cu ele.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $nrtri.in$ se afla $N$, numarul de betisoare. Pe urmatoarea linie se afla $N$ numere separate prin spatii ce reprezinta lungimile betisoarelor.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $nrtri.out$ contine un singur numar ce reprezinta numarul cerut de problema.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 800$\r\n* $1 &le; lungimea unui betisor &le; 30000$\r\n* se considera triunghiuri si cele care au un unghi de $180$ de grade si celelalte doua de $0$ grade ({$2$} segmente coliniare se confunda cu al $3-lea$)\r\n* pentru $75$ de puncte se garanteaza $1 &le; N &le; 150$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. nrtri.in |_. nrtri.out |\r\n| 4\r\n  2 3 6 2\r\n| 2 |\r\n\r\nh3. Explicatii\r\n\r\nSingurele triunghiuri care se pot forma sunt alcatuite din urmatoarele betisoare (date prin numarul de ordine): \r\n1, 2, 4\r\n2, 3, 4 \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"nrtri\")==',1142,'task: nrtri'),('problema/divprim','Divizori Primi','2006-11-11 23:39:36','==Include(page=\"template/taskheader\" task_id=\"divprim\")==\r\n\r\nSe doreste aflarea celui mai mare numar natural mai mic sau egal decat un numar $N$ si care are exact $K$ divizori primi.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $divprim.in$ contine un numar intreg $T$ reprezentand numarul de teste din fisier. Pe urmatoarele $T$ linii se afla doua numere $N$ si $K$ cu semnificatia de mai sus.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $divprim.out$ veti afisa $T$ linii fiecare continand numarul intreg $X$ care satisface propritatile respective sau $0$ in cazul in care nu exista un astfel de numar.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; T &le; 100.000$\r\n* $0 &le; K &le; 7$\r\n* $1 &le; N &le; 1.000.000$\r\n* $1$ nu este numar prim si are $0$ divizori primi.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. divprim.in |_. divprim.out |\r\n| 3\r\n10 1\r\n10 3\r\n9 2\r\n| 9\r\n0\r\n6 |\r\n\r\nh3. Explicatii\r\n\r\n$3$ este sigurul divizor prim al lui $9$\r\nNu exista numar mai mic sau egal cu $10$ care sa aiba $3$ divizori primi, primul astfel de numar fiind $30$\r\n$2$ si $3$ sunt singurii divizori primi ai lui $6$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"divprim\")==',961,'task: divprim'),('problema/pavare2','Pavare2','2006-11-12 15:44:52','==Include(page=\"template/taskheader\" task_id=\"pavare2\")==\r\n\r\nIn orasul Z exista un bulevard de latime $1$ metru si lungime $N$ metri care trebuie pavat. Primaria orasului dispune de placi albe si negre de $1$ metru lungime si $1$ metru latime in scopul pavarii bulevardului. Dupa cum va imaginati, bulevardul va fi pavat prin asezarea a $N$ placi din stocul primariei. Pentru a alege cea mai buna metoda de pavare, primarul vrea mai intai sa stie cate moduri de pavare sunt astfel incat sa nu existe mai mult de $A$ placi consecutive de culoare alba si $B$ placi consecutive de culoare neagra pe bulevard. Primarul vrea sa afle apoi care este a $K$-a posibilitate de pavare in ordine lexicografica, stiind ca o placa alba e mai mica din punct de vedere lexicografic decat o placa neagra.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se numarul $N$ ce reprezinta lungimea bulevardului si numerele $A$, $B$ si $K$ se cere sa se afle numarul de posibilitati de pavare ce respecta conditiile din enunt. De asemenea, se cere sa se afiseze a $K$-a posibilitate de pavare in ordine lexicografica, codificand cu $0$ o placa alba si cu $1$ o placa neagra.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $pavare2.in$ se gasesc numerele $N$, $A$, $B$, separate prin spatii. Pe cea de-a $2$-a linie a fisierului se gaseste numarul $K$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $pavare2.out$ se gaseste un singur numar ce reprezinta numarul de posibilitati de pavare, iar pe cea de-a doua linie trebuie sa se afiseze pavarea ceruta codificata ca in enunt, fara a afisa spatii intre caracterele de $0$ si $1$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100$\r\n* $1 &le; A, B &le; N$\r\n* Se garanteaza ca exista cel putin $K$ modalitati de a pava bulevardul si $K &ge; 1$\r\n* Pentru $50%$ din teste $K = 1$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. pavare2.in |_. pavare2.out |\r\n| 4 2 3\r\n7\r\n| 12\r\n1001 |\r\n\r\nh3. Explicatii\r\n\r\nCele $12$ posibilitati de pavare sunt, in ordine lexicografica :\r\n$0010 0011 0100 0101 0110 0111 1001 1010 1011 1100 1101 1110$\r\nSe observa ca a $7$-a posibilitate de pavare este $1001$.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"pavare2\")==',15,'task: pavare2'),('problema/count','Count','2006-11-11 20:16:12','==Include(page=\"template/taskheader\" task_id=\"count\")==\r\n\r\nFiind dat un graf planar cu $N$ noduri si $M$ muchii aflati numarul maxim de noduri pe care il poate avea un subgraf complet al sau (un graf neorientat se numeste complet daca exista muchie intre oricare doua noduri ale sale). De asemenea se cere si numarul de subgrafuri complete cu numar maxim de noduri care se gasesc in graful planar dat.\r\n\r\nh2. Cerinta\r\n\r\nFiind dat un graf planar aflati cele doua numere cautate.\r\n\r\nh2. Date de Intrare\r\n\r\nLinia 1 a fisierului de intrare contine doua numere naturale separate prin spatii $N$ si $M$ (numarul de noduri, respectiv numarul de muchii ale grafului planar).\r\nLiniile $2 .. M + 1$ contin cate doua numere $A$ si $B$ cu semnificatia: exista o muchie bidirectionala intre nodurile $A$ si $B$ (nodurile grafului sunt numerotate de la $1$ la $N$).\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire va contine pe prima linie doua numere $X$ si $Y$ reprezentand numarul maxim de noduri pe care il poate avea un subgraf complet si, respectiv, numarul de subgrafuri complete cu $X$ noduri din graful planar dat.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 30 000$\r\n* $1 &le; M &le; 60 000$\r\n* $Y &le; 2^30$\r\n* Pentru $70%$ din teste $N &le; 2000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. count.in |_. count.out |\r\n| 5 8\r\n1 2\r\n1 3\r\n1 5\r\n2 4\r\n2 5\r\n3 4\r\n3 5\r\n4 5\r\n| 3 4 |\r\n\r\nh3. Explicatii\r\n\r\nSe pot forma 4 subgrafuri complete cu 3 noduri. Acestea sunt:\r\n(1 2 5), (2 4 5), (3 4 5), (1 3 5)\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"count\")==',15,'task: count'),('problema/demolish','Demolish','2006-11-11 23:26:52','==Include(page=\"template/taskheader\" task_id=\"demolish\")==\r\n\r\nPatratel a strans profit serios din afacerile cu struti si acum doreste sa se extinda. Cu banii pe care ii are intentioneaza sa isi construiasca o ferma in regiune. Regiunea este de forma dreptunghiulara si are $M$ kilometri lungime si $N$ kilometri latime, iar ferma trebuie sa fie si ea dreptunghiulara si sa aiba laturile paralele cu ale regiunii. In regiune sunt insa construite alte $F$ ferme ale unor oameni la fel de bogati ca si Patratel, ferme tot dreptunghiulare si tot cu laturile paralele cu ale regiunii. Patratel este om pretentios ( ca si strutii sai, de altfel ), si doreste o ferma de $DX$ kilometri lungime si $DY$ kilometri latime. Constructia unei astfel de ferme nu este intotdeauna posibila pentru ca depinde de asezarea celorlalte $F$ ferme. Fiecare ferma are un cost de demolare ( costul pe care Patratel trebuie sa il plateasca sa demoleze ferma respectiva ). El doreste sa isi plaseze ferma proprie in regiune astfel incat suma costurilor de demolare ale fermelor intersectate de ferma sa fie minima.\r\nDoua ferme se intersecteaza daca si numai daca un punct de pe laturile primei ferme se gaseste strict in interiorul celei de a doua ferme ( adica ele nu se intersecteaza daca se ating doar laturile ).\r\n\r\nh2. Cerinta\r\n\r\nSa se determina costul minim pe care il plateste Patratel pentru a-si construi ferma.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $demolish.in$ contine cinci numere naturale $M, N, F, DX$ si $DY$ ( in aceasta ordine ), cu semnificatia din enunt. Fiecare din urmatoarele $F$ linii contine tot cate cinci numere, $(x1 y1 x2 y2 C)$, unde $(x1 y1)$ reprezinta coordonatele coltului stanga-jos ale unei ferme din regiune, $(x2 y2)$ coordonatele dreapta-sus ale aceleiasi ferme, iar C costul de demolare al fermei respective. Pentru un astfel de set avem intotdeauna $0 &le; x1 < x2 &le; M, 0 &le; y1 < y2 &le; N$ si $0 &le; C &le; 200 000$.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului demolish.out contine $COST$, costul minim cerut. A doua linie contine patru numere intregi separate de cate un spatiu, $(x1 y1 x2 y2)$, reprezentand pozitionarea fermei in regiune: $(x1 y1)$ - coordonatele coltului stanga-jos si $(x2 y2)$ - coordonatele dreapta-sus a fermei construite de Patratel pentru a obtine costul minim $COST$. Daca sunt mai multe posibilitati de amplasare, se va afisa cea care are $x1$ minim, iar daca si in acest caz sunt mai multe posibilitati, se va afisa cea care are $y1$ minim.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $4 < M, N < 500 001$\r\n* $0 < DX < M + 1, 0 < DY < N + 1$\r\n* $F < 30 001$\r\n* Evident, fermele deja construite in regiune nu se intersecteaza\r\n* Oricare doua ferme nu se intersecteaza daca se ating doar laturile\r\n* Pot exista doua ferme din cele $F$ care au acelasi cost de demolare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. demolish.in |_. demolish.out |\r\n| 12 10 6 7 8\r\n2 3 5 8 3 \r\n5 7 7 9 7\r\n8 4 12 8 22\r\n7 1 9 2 4\r\n0 0 1 2 10\r\n1 9 2 10 6 |  14\r\n1 0 8 8 |\r\n\r\nh3. Explicatie\r\n\r\nCostul minim se obtine daca ferma este dispusa conform coordonatelor (1 0 8 8), intersectand fermele 1, 2 si 4, care trebuiesc demolate. Suma costurilor tuturor demolarilor efectuate este de 3+7+4 = 14. O alta plasare posibila care duce tot la costul 14 este (1 1 8 9), dar aceasta nu duce la indeplinirea conditiei de minimalitate a coordonatelor.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"demolish\")==',1,'task: demolish'),('problema/nextseq','NextSeq','2006-11-11 22:59:28','==Include(page=\"template/taskheader\" task_id=\"nextseq\")==\r\n\r\nh2. Cerinta\r\n\r\nSe da un set de numere de numere distincte, $X$, si doua siruri, $A$ si $B$, cu elemente din setul $X$ astfel incat $B$ este mai mare decat $A$. Sa se determine cate siruri sunt mai mari decat $A$ dar mai mici decat $B$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare contine pe prima linie doua numere $N$, $M$ si $P$ reprezentand numarul de elemente din setul $X$, numarul de elemente al sirului $A$ si, respectiv, numarul de elemente ale sirului $B$. Linia a doua contine $N$ numere naturale reprezentand setul $X$. Linia a treia contine $M$ numere naturale separate prin spatii din setul $X$ reprezentand elementele sirului $A$. Linia a patra contine $P$ numere naturale separate prin spatii din setul $X$ reprezentand elementele sirului $B$.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linia a fisierului se va afla numarul cautat. Acest numar nu va fi mai mare decat $100$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M, P &le; 10.000$\r\n* Un sir $A$ este mai mare decat un sir $B$ daca are mai multe elemente decat acesta sau daca sirurile au acelasi numar de elemente si exista o pozitie $i$ astfel incat $A[i] &ge; B[i]$ iar $A[k] = B[k]$ pentru orice $k &ge; i$ (vezi exemplul)\r\n* Numarul de siruri dintre cuprinse intre $A$ si $B$ nu va depasi $100$\r\n* Numerele din setul $X$ sunt numere intregi in intervalul $[0 .. 10.000]$\r\n* Pentru $70%$ din teste $N, M, P &le; 100$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. nextseq.in |_. nextseq.out |\r\n| 4 2 3\r\n  8 3 9 1\r\n  9 3\r\n  1 3 8\r\n| 8 |\r\n\r\nh3. Explicatii \r\n\r\nSirurile care respecta conditiile din enunt (in ordine lexicografica) sunt:\r\n  {9, 8}, {9 9}, {1 1 1}, {1 1 3}, \r\n  {1 1 8}, {1 1 9}, {1 3 1}, {1, 3, 3}\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"nextseq\")==',15,'task: nextseq'),('problema/robotei','Robotei','2006-12-19 11:09:31','==Include(page=\"template/taskheader\" task_id=\"robotei\")==\r\n\r\n\r\nIn fiecare celula a unui caroiaj de dimensiuni $NxN$ se afla plasat cate un robotel. Coltul din stanga sus al caroiajului are coordonatele ({$0$}, {$0$}) iar cel din dreapta jos ({$N-1$}, {$N-1$}). Roboteii sunt programati sa se miste, in fiecare secunda, dupa urmatoarea regula:\r\n\r\np=. $newX{~i~} = (oldX{~i~}^2^ + offsetX) modulo modX$\r\n\r\np=. $newY{~i~} = (oldY{~i~}^2^ + offsetY) modulo modY$,\r\n\r\n\r\nunde ({$oldX{~i~}, oldY{~i~}$}) reprezinta pozitia veche a robotelului $i$ (modul de numerotare al roboteilor nu este important) si ({$newX{~i~}, newY{~i~}$}) noua lui pozitie. $offsetX$, $offsetY$, $modX$ si $modY$ sunt comune regulilor de miscare ale roboteilor.\r\n\r\nh2. Cerinta\r\n\r\nStiind ca fiecare robotel va efectua $M$ mutari, aflati cati roboti trec prin pozitia ({$X$}, {$Y$}) de $n$ ori, pentru fiecare $n$ intre $0$ si $M$.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare va contine $8$ numere intregi separate de spatii: $N$, $M$, $X$, $Y$, $modX$, $modY$, $offsetX$ si respectiv $offsetY$ cu semnificatiile din enunt.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire va contine cate o linie pentru fiecare $n$ cate doi intregi, $n$ si $C{~n~}$ cu semnificatia: \"$C{~n~}$ robotei trec prin pozitia ({$X$}, {$Y$}) de exact $n$ ori\". Perechile de numere vor fi afisate in ordine crescatoare dupa $n$ si vor fi afisate doar cele pentru care $C{~n~}$ este diferit de $0$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Toate numerele din fisierul de intrare sunt intregi din intervalul $[0, 1.000.000]$\r\n* Aceasta problema va fi testata cu $10$ de teste, fiecare valorand cate $10$ puncte. Valorile utilizate in teste pentru $N$, $M$, $modX$ si $modY$ se regasesc in tabelul de mai jos.\r\n* Pe parcurs, o celula poate contine mai multi robotei.\r\n\r\n\r\ntable(numbers). |_. Test | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\r\n|_. N | 20 | 33 | 61 | 43139 | 83 | 504 | 32668 | 906 | 1523 | 44339 |\r\n|_. M | 1000 | 2100 | 400745 | 337654 | 237891 | 367398 | 500000 | 325000 | 476388 | 666732 |\r\n|_. modX | 13 | 31 | 40 | 54 | 72 | 270 | 561 | 877 | 997 | 997 |\r\n|_. modY | 19 | 29 | 50 | 65 | 69 | 256 | 437 | 809 | 991 | 1000 |\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. robotei.in |_. robotei.out |\r\n| 3 4 1 2 2 3 1 1\r\n| 1 2\r\n2 6\r\n3 1 |\r\n\r\nh3. Explicatii\r\n\r\nSunt 3 x 3 = 9 robotei. Robotelul situat in celula (3 2) va avea urmatorul parcurs: (3 2) -> (0 2) -> ({%{color:red}1 2%}) -> (0 2) -> ({%{color:red}1 2%}). In consecinta, el trece de 2 ori prin pozitia ({%{color:red}1 2%}).\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"robotei\")==',1,'task: robotei'),('problema/timbre','Timbre','2006-11-12 16:26:30','==Include(page=\"template/taskheader\" task_id=\"timbre\")==\r\n\r\nDupa cum stiti cu totii, Adriana este o mare colectionara de timbre. In fiecare zi se duce la magazinul de pe strada ei pentru a-si mari colectia. Intr-o zi, vanzatorul (nimeni altul decat Balaurul Arhirel) s-a gandit sa-i faca o surpriza. A scos dintr-un dulap vechi niste timbre foarte valoroase pe care erau scrise cu fir de aur si de argint numere naturale. Stiind ca fetita nu are bani prea multi, Balaurul i-a spus urmatoarele: \"Eu pot sa impart timbrele in $M$ intervale de forma $[1,..,m{~i~}]$. Tu poti sa iei din orice interval o singura subsecventa de maxim $K$ elemente. Desigur, daca ai ales o subsecventa din intervalul $i$ vei plati o anumita suma...\"\r\n\r\nAdriana s-a gandit ca ar fi frumos sa-si numeroteze toate cele $N$ pagini ale clasorului ei cu astfel de timbre. Fiind si o fetita pofticioasa si-a zis : \"Tare as vrea sa mananc o inghetata din banii pe care ii am la mine, dar nu stiu daca o sa-mi ajunga sa platesc timbrele. Cum sa fac?\"\r\n\r\nh2. Cerinta\r\n\r\nStiind cele $M$ intervale, precum si costurile acestora, ajutati-o pe Adriana sa cumpere timbrele necesare numerotarii clasorului, platind o suma cat mai mica.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $timbre.in$ se afla $N$, $M$, si $K$. $N$ reprezinta numarul de pagini ale clasorului, $M$ reprezinta numarul de intervale, iar $K$ lungimea maxima a unei subsecvente. Pe urmatoarele $M$ linii se afla doua numere separate printr-un spatiu, $m{~i~}$ si $c{~i~}$, unde $m{~i~}$ reprezinta marginea superioara a intervalului $i$, iar $c{~i~}$ costul acestuia.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $timbre.out$ se va afla $Smin$, reprezentand suma minima pe care trebuie sa o plateasca Adriana pentru a cumpara timbrele necesare numerotarii clasorului.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 < N < 1 001$\r\n* $0 < M < 10 001$\r\n* $0 < K < 1 001$\r\n* $0 < m{~i~} < 100 000$\r\n* $0 < c{~i~} < 10 000$\r\n* pentru a numerota toate cele $N$ pagini ale clasorului, Adriana are nevoie de timbre cu numerele de la 1 la $N$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. timbre.in |_. timbre.out |\r\n|4 3 2\r\n5 3\r\n2 1\r\n6 2\r\n|3\r\n|\r\n\r\nh3. Explicatie\r\n\r\nLuam subsecventa ${1, 2}$ din al doilea interval si subsecventa ${3, 4}$ din al treilea interval. Obtinem astfel costul minim $3$.\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"timbre\")==',1,'task: timbre'),('problema/matrix','Matrix','2006-11-11 16:49:50','==Include(page=\"template/taskheader\" task_id=\"matrix\")==\r\n\r\nCercetatorii din tara lui Papura-Voda au descoperit harta genomului uman si au reprezantat-o ca matrice de dimensiuni $MxM$ ce contine litere mici ale alfabetului englez. O specie extrateresta a atacat umanitatea, utilizand un virus a carui definitie a fost identificata, de aceeasi bravi cercetatori, sub forma unei matrici de dimensiuni $NxN$ care contine tot litere mici ale alfabetului englez. Cercetatorii vor sa afle gradul de infestare a genomului uman, care se masoara in numarul de aparitii a definitiei virusului in harta acestuia. Problema este insa ceva mai complicata, deoarece virusul se poate deghiza interschimband de oricate ori, oricare doua pozitii din matricea care il defineste.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul de aparitii (incluzandu-le si pe cele deghizate) ale definitiei virusului in harta genomului uman.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie contine doua numere, $M$ si $N$, cu semnificatia de mai sus. Urmeaza $M$ linii continand cate $M$ caractere (fara spatii) reprezentand harta genomului uman. Urmatoarele $N$ linii contin $N$ caractere (fara spatii) reprezentand definitia virusului\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire va contine pe prima linie numarul de aparitii ale virusului (eventual deghizat) in harta genomului uman.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; M &le; 1000$\r\n* Ambele matrici contin litere mici ale alfabetului englez\r\n* Doua aparitii diferite ale virusului se pot suprapune partial (vezi exemplul)\r\n* Pentru $50%$ din teste $M &le; 200$\r\n* Nu stiu daca se poate identifica un virus analizand harta genomului uman. Povestea e pura fictiune. Orice asemanare cu realitatea este intamplatoare si neintentionata.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. matrix.in |_. matrix.out |\r\n| 3 2\r\n  acb\r\n  bda\r\n  acb\r\n  ab\r\n  cd\r\n| 4 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"matrix\")==',48,'task: matrix'),('problema/nrcuv','Lista lui Andrei','2006-11-12 14:03:43','==Include(page=\"template/taskheader\" task_id=\"nrcuv\")==\r\n\r\n\r\nFiind foarte pasionat de civilizatiile extraterestre, Andrei a inceput sa studieze limba martienilor pentru a putea comunica usor cu ei atunci cand va fi cazul. Oricat s-a documentat el a putut afla doar ca toate cuvintele acestei limbi contin $N$ litere mici din alfabetul englez si a mai gasit o lista cu perechi de litere ce nu pot aparea pe pozitii vecine intr-un cuvant. Pentru ca are de gand sa studieze fonetica fiecarui cuvant posibil in parte, Andrei ar vrea mai intai sa vada cat de voluminoasa este munca pe care si-o propune si va roaga sa determinati cate cuvinte poate avea limba.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati cate cuvinte de lungime $N$ se pot forma folosind doar litere mici ale alfabetului englez astfel incat oricare doua litere care formeaza o pereche in lista lui Andrei sa nu se afle pe pozitii vecine.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $nrcuv.in$ se afla numerele intregi $N$ si $M$, reprezentand numarul de litere din care este format un cuvant si numarul de perechi din lista lui Andrei. Urmatoarele $M$ linii contin o pereche de forma \"$l{~1~} l{~2~}$\" unde $l{~1~}$ si $l{~2~}$ sunt litere mici ale alfabetului englez.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul $nrcuv.out$ contine pe prima linie numarul cerut modulo $104659$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 1000$\r\n* $0 &le; M &le; 2000$\r\n* Pot exista perechi simetrice sau identice in lista\r\n* Doua pozitii sunt vecine daca modulul diferentei lor este $1$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. nrcuv.in |_. nrcuv.out |\r\n| 2 7\r\na a\r\na b\r\nb c\r\nc d\r\nc f\r\nb a\r\nc f\r\n| 667 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"nrcuv\")==',15,'task: nrcuv'),('problema/joc','Joc','2006-11-12 14:09:29','==Include(page=\"template/taskheader\" task_id=\"joc\")==\r\n\r\nGicu si Nicu, olimpici la informatica si buni prieteni, mereu incearca sa imbine activitatile lor cu informatica. Spre exemplu, cand se plictisesc in ore ei joaca un joc, bazat pe urmatoarele reguli:\r\n\r\n* fie o matrice cu numere intregi cu $N$ linii si $M$ coloane\r\n* fiecare jucator muta alternativ un jeton plasat pe un element din matrice\r\n* o mutare consta in plasarea jetonului pe o alta pozitie si adaugarea valorii din matrice de pe pozitia respectiva la scorul jucatorului care a facut mutarea; odata plasat jetonul pe o pozitie, jucatorul urmator poate sa mute jetonul doar pe o alta pozitie din dreptunghiul format de coltul stanga-sus si pozitia curenta a matricei\r\n* jocul se termina cand un jucator ajunge cu jetonul in coltul stanga-sus al matricei\r\n* la inceputul jocului, ambii jucatori au scor {$0$}, iar jucatorul care incepe alege pozitia initiala a jetonului\r\n\r\nh2. Cerinta\r\n\r\nPresupunand ca fiecare din cei doi joaca optim, si ca Gicu va incepe jocul, determinati pozitia initiala a jetonului, astfel incat diferenta de scor intre Gicu si Nicu sa fie maxima!\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $joc.in$ contine doua numere intregi $N$ si {$M$}, separate prin cate un spatiu, care reprezinta numarul de linii si coloane ale matricii. Urmatoarele $N$ linii contin cate $M$ numere intregi, separate prin cate un spatiu, care descriu matricea.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $joc.out$ va contine trei numere intregi separate prin cate un spatu: diferenta maxima de scor intre Gicu si Nicu si linia si coloana unde se va plasa jetonul la inceputul jocului.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 1.000$\r\n* Valorile din matrice sunt cuprinse in intervalul [{$-1.000, 1.000$}]\r\n* Liniile sunt numerotate de la $1$ la {$N$}, iar coloanele de la $1$ la $M$\r\n* Prin joc optim se intelege ca Gicu va incerca sa maximizeze diferenta de scor, in timp ce Nicu va incerca sa o minimizeze\r\n* Daca exista mai multe pozitii initiale pentru care se obtine diferenta maxima, atunci se va alege cea in care numarul liniei este cel mai mic, iar in caz de egalitate cea in care numarul coloanei este cel mai mic\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. joc.in |_. joc.out |\r\n| 1 6\r\n2 1 3 4 0 5\r\n| 3 1 6 | \r\n\r\nh3. Explicatii \r\n\r\nIncepand din ({$1, 6$}) jocul optim este: Gicu ia {$5$}, Nicu ia {$4$}, Gicu ia {$2$}. \r\nOrice alta pozitie initiala a jetonului ar fi dus la obtinerea unei diferente de scor mai mica.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"joc\")==',961,'task: joc'),('problema/domino','Domino','2006-11-12 00:13:25','==Include(page=\"template/taskheader\" task_id=\"domino\")==\r\n\r\nSe dau $N$ dominouri. Sa se determine o modalitate de construire al unui sir, care sa contina toate dominourile, respectand regula jocului domino. Aceasta regula inseamna ca numerele inscrise pe fetele corespunzatoare a doua dominouri consecutive trebuie sa fie egale. Dominourile pot fi alese in ordine oarecare si rotite.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare $domino.in$ se va afla numarul $N$ al dominourilor. Pe urmatoarele $N$ linii se vor afla cate doua numere separate printr-un singur spatiu, reprezintand cele doua numere inscrise pe dominoul corespunzator.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierul $domino.out$ va trebuie sa afisati $1$, daca exista solutie si $0$ daca nu. Daca exista solutie vor urma exact $N$ linii, care descriu sirul construit. Cele $N$ linii vor trebui sa contina numerele de ordine al dominourilor in ordinea in care apar in sir. Fiecare numar de ordine va fi urmat de un spatiu si de un numar, care poate fi $0$ sau $1$ si va fi egal cu $1$ in cazul in care dominoul corespunzator a fost rotit.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 50.000$\r\n* Numerele inscrise pe dominouri pot fi cuprinse intre $0$ si $9$ inclusiv\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. domino.in |_. domino.out |\r\n|12\r\n1 4\r\n3 7\r\n1 5\r\n2 4\r\n2 5\r\n2 6\r\n2 7\r\n3 4\r\n4 6\r\n5 6\r\n5 7\r\n6 7\r\n| 1\r\n3 0\r\n11 0\r\n12 1\r\n9 1\r\n8 1\r\n2 0\r\n7 1\r\n6 0\r\n10 1\r\n5 1\r\n4 0\r\n1 1 |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"domino\")==',15,'task: domino'),('problema/seti','SETI','2006-11-12 15:12:03','==Include(page=\"template/taskheader\" task_id=\"seti\")==\r\n\r\nSe pare ca in sfarsit cautatorii vietii extraterestre au descoperit ceva! In cursul proiectului SETI@home a fost izolata o secventa care ar putea reprezenta un semnal de la alte forme de viata inteligenta. Ca urmare, proiectul SETI@ONI isi propune sa verifice daca acel semnal provine intr-adevar de la extraterestri sau doar de la niste pusti care beau Fanta.\r\n\r\nh2. Cerinta\r\n\r\nPentru comoditate, portiunea de semnal ce trebuie analizata vi se pune la dispozitie sub forma unei succesiuni de litere ale alfabetului latin. Vi se mai pune la dispozitie si un dictionar de cuvinte extraterestre, codificate in acelasi mod. Scopul dumneavoastra este sa numarati de cate ori apare fiecare dintre aceste cuvinte in posibilul mesaj extraterestru. Pornind de la aceste date, lingvistii pot sa inceapa lucrul la traducerea mesajului.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $seti.in$ este scris numarul $N$ de linii ale mesajului. Urmeaza $N$ linii, fiecare continand exact $64$ de litere ale alfabetului latin urmate de marcajul de sfarsit de linie. Prin alipirea acestor bucati se obtine mesajul de analizat, format din {$64*N$} litere. \r\n\r\nPe urmatoarea linie a fisierului de intrare este scris numarul $M$ de cuvinte din dictionar. Urmeaza apoi $M$ linii, fiecare continand un cuvant din dictionar, reprezentat ca o secventa de cel putin una si cel mult $16$ litere. Cuvintele nu sunt neaparat distincte.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $seti.out$ va contine exact $M$ linii. Pe linia cu numarul $i$ va fi scris numarul de aparitii in mesajul extraterestru ale cuvantului cu numarul $i$ din dictionar. Numarul de aparitii nu va depasi niciodata {$65535$}. Orice aparitie a unui cuvant trebuie numarata, chiar daca se suprapune peste alte aparitii. Se va face diferenta intre litere mari si litere mici.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 &le; N < 2 048$\r\n* $0 &le; M &le; 32 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. seti.in|_. seti.out|\r\n|2\r\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaBaba\r\nbabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaBaB\r\n3\r\nb\r\nbab\r\nb\r\n|3\r\n2\r\n3|\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"seti\")==',256,'task: seti'),('problema/biti','Biti','2006-11-11 16:21:39','==Include(page=\"template/taskheader\" task_id=\"biti\")==\r\n\r\nGigel este pasionat de informatica, si mai ales de cifrele $0$ si {$1$}; asa de mult, incat a atribuit fiecarui din cei $2^N^$ prieteni ai lui cate o eticheta, sub forma unui sir de biti de lungime {$N$}. Toate etichetele sunt distincte intre ele.\r\nGigel s-a gandit intr-o zi ca vrea sa construiasca o eticheta pentru el insusi, de lungime cat mai mica, care sa contina o singura data, ca o subsecventa, fiecare din cele $2^N^$ etichete ale prietenilor lui.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care determina eticheta lui Gigel, de lungime minima.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $biti.in$ se va gasi numarul $N$\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului de iesire $biti.out$ se va gasi lungimea sirului. Pe a doua linie se va afisa un sir de biti $0$ sau $1$ care vor reprezenta eticheta gasita.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 20$\r\n* Daca exista mai multe solutii de lungime minima, se va afisa cea minima din punct de vedere lexicografic\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. biti.in |_. biti.out |\r\n| 3\r\n| 10\r\n0001011100 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"biti\")==',961,'task: biti'),('problema/zero','Zero','2006-11-11 16:23:59','==Include(page=\"template/taskheader\" task_id=\"zero\")==\r\n\r\nSe considera numai numerele de $L$ cifre scrise intr-o baza $B$ ({$2 &le; B < L &le; 20$}), in care prima cifra (cea mai semnificativa) este diferita de $0$.\r\n\r\nh2. Cerinta:\r\n\r\nDandu-se doua numere $P$ si $Q$ ({$2 &le; P,Q &le; L-1$}), se cere:\r\n\r\na) cate numere exista cu cel mult $P$ cifre $0$ (zero) consecutive.\r\n\r\nb) cate numere exista cu cel putin $Q$ cifre $0$ (zero) consecutive.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare $zero.in$ contine numerele $L$, $B$, $P$ si $Q$, separate prin spatii.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de iesire $zero.out$ contine numarul cerut la punctul a), in timp ce pe a doua linie a fisierului se va afla numarul cerut la punctul b).\r\n\r\nh2. Exemplu:\r\n\r\ntable(example). |_. zero.in |_. zero.out |\r\n|3 2 1 2\r\n|3|\r\n||1|\r\n\r\n\r\nPentru cel mult o cifra de zero avem numerele $101$, $110$ si $111$, iar pentru cel putin 2 de 0 consecutivi avem numarul $100$.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"zero\")==',256,'task: zero'),('problema/eqs','Ecuatii','2006-11-12 00:53:35','==Include(page=\"template/taskheader\" task_id=\"eqs\")==\r\n\r\nSe considera ecuatii de tipul:\r\n$a{~1~}*x{~1~}^3^$ {@+@} $a{~2~}*x{~2~}^3^$ {@+@} $a{~3~}*x{~3~}^3^$ {@+@} $a{~4~}*x{~4~}^3^$ {@+@} $a{~5~}*x{~5~}^3^$ {@+@} $a{~6~}*x{~6~}^3^=0$\r\nToate necunoscutele apar la puterea a treia. Coeficientii $a{~1~},a{~2~},a{~3~},a{~4~},a{~5~}$ sunt numere intregi date, din intervalul inchis $[-50,+50]$. Se considera solutie un pentuplu $(x{~1~},x{~2~},x{~3~},x{~4~},x{~5~})$ care verifica ecuatia.\r\n\r\nh2. Cerinta\r\n\r\nSa se gaseasca numarul de solutii ale ecuatiei, pentru care valorile necunoscutelor sunt numere intregi nenule din intervalul inchis $[-50,+50]$.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $eqs.in$ sunt scrisi cei $5$ coeficienti intregi $a{~1~},a{~2~},a{~3~},a{~4~},a{~5~}$ separati prin cate un spatiu.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului de iesire $eqs.out$ va contine numarul de solutii.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* coeficientii ecuatiei sunt numere intregi din intervalul $[-50, +50]$\r\n* un program care functioneaza perfect pentru $a{~4~}=a{~5~}=0$ va obtine cel putin $20$ de puncte. Un program care functioneaza perfect pentru $a{~5~}=0$ va obtine cel putin $40$ de puncte.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. eqs.in |_. eqs.out |\r\n| 37 29 41 43 47 | 654 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"eqs\")==',1,'task: eqs'),('problema/sumdiv','Suma divizorilor','2006-11-11 20:51:52','==Include(page=\"template/taskheader\" task_id=\"sumdiv\")==\r\n\r\nSe considera doua numere naturale $A$ si $B$. Fie $S$ suma tuturor divizorilor naturali ai lui $A^B^$ ({$A$} la puterea $B$).\r\n\r\nh2. Cerinta\r\n\r\nSa se afiseze restul impartirii lui $S$ la $9901$.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $sumdiv.in$ sunt scrise cele doua numere $A$ si $B$, separate prin cel putin un spatiu.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului $sumdiv.out$ va contine restul impartirii lui $S$ la $9901$.\r\n\r\nh2. Restrictii\r\n\r\n* $0 &le; A,B &le; 50 000 000$ (cincizeci de milioane)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. sumdiv.in |_. sumdiv.out |\r\n|2 3 |15 |\r\n\r\nh3. Explicatie\r\n$2^3^ = 8$. Divizorii naturali ai lui $8$ sunt: $1, 2, 4, 8$. Suma lor este $15$. Restul impartirii lui $15$ la $9901$ este $15$ (care trebuie sa apara in fisierul de iesire).\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sumdiv\")==',4895,'task: sumdiv'),('problema/telegraf','Telegraf','2006-11-12 12:45:42','==Include(page=\"template/taskheader\" task_id=\"telegraf\")==\r\n\r\nPana nu demult, comunicatia la distanta se facea cu ajutorul telegrafului. Folosind telegraful, se pot transmite doua tipuri de semnale: punct si linie. In general, dorim sa transmitem texte formate din litere ale alfabetului latin si cifre (in total $36$ de simboluri). Trebuie deci sa folosim o codificare, adica sa asociem fiecaruia din cele $36$ de simboluri o succesiune distincta de linii si puncte. Pentru a putea decodifica o succesiune receptionata de linii si puncte, este necesar ca nici un simbol sa nu aiba o codificare identica cu inceputul codificarii pentru un alt simbol. Sa consideram cateva exemple (presupunand ca nu vrem sa transmitem decat literele {$A$}, {$B$}, {$C$}):\r\n\r\n|_. Exemplul 1|_. Exemplul 2|_. Exemplul 3|\r\n|{$A = ..$}|{$A = .--$}|{$A = .-..$}|\r\n|{$B = .-$}|{$B = .-$}|{$B = -.$}|\r\n|{$C = -$}|{$C = -$}|{$C = .-.$}|\r\n\r\nExemplul $1$ reprezinta o codificare corecta. Exemplul $2$ reprezinta o codificare gresita, pentru ca inceputul codificarii pentru $A$ este identic cu codificarea pentru $B$ (deci, o secventa de genul $.--$ este ambigua, putand insemna si $A$ si $BC$). Exemplul $3$ este de asemenea o codificare gresita pentru ca inceputul codificarii pentru $A$ este identic cu codificarea pentru C (o secventa precum $.-..-.$ este ambigua, putand insemna fie $AB$, fie {$CC$}). Se stie ca intr-o transmisie telegrafica, punctul dureaza o secunda, iar linia 2 secunde. Putem calcula astfel timpul necesar transmiterii unui text. Folosind codificarea din exemplul $1$, transmiterea textului $CABCA$ = ${@-...--..@}$ dureaza $11$ secunde. Observati ca lungimea transmisiei se poate calcula si astfel: $2(A) + 1(B) + 2({@C@})$ = $2(..) + 1(.-) + 2(-)$ = $2*2 + 1*3 + 2*2 = 11$.\r\n\r\nh2. Cerinta\r\n\r\nSe considera un text, dat prin frecventa aparitiei fiecarui simbol (dintre cele $36$ considerate). Sa se gaseasca durata minima necesara transmiterii acelui text, folosind o codificare aleasa corespunzator.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul $telegraf.in$ contine o singura linie cu $36$ de numere intregi nenegative, separate prin cate un spatiu, reprezentand numarul de aparitii ale fiecarui simbol in textul ce trebuie transmis.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul $telegraf.out$ va contine un singur numar, si anume lungimea minima (in secunde) necesara pentru transmiterea textului.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Nici unul din cele $36$ de simboluri nu apare de mai mult de $1 000 000$ de ori in textul considerat\r\n* Exista cel putin doua simboluri cu numar de aparitii nenul\r\n* $40%$ dintre teste vor contine maxim $16$ simboluri cu frecventa de aparitie nenula\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. telegraf.in|_. telegraf.out|\r\n|2 1 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|11|\r\n\r\n_Explicatie_: Se constata ca este optim sa se transmita acest text folosind codificarea din Exemplul 1, obtinand o lungime minima a transmisiei de 11 secunde.\r\n\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"telegraf\")==',256,'task: telegraf'),('problema/substr','Substr','2006-11-12 13:07:27','==Include(page=\"template/taskheader\" task_id=\"substr\")==\r\n\r\nSe da un text format din $N$ caractere (litere mari, litere mici si cifre). Un _substring_ al acestui text este o secventa de caractere care apar pe pozitii consecutive in text.\r\n\r\nh2. Cerinta\r\n\r\nFiind dat un numar $K$, sa se determine lungimea celui mai lung _substring_ care apare in text de cel putin $K$ ori.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $substr.in$ contine pe prima linie numerele $N$ si $K$ separate prin spatiu. Pe cea de a doua linie se afla un text format din $N$ caractere (litere mari, mici si cifre), fara spatii si terminat cu caracterul de linie noua.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $substr.out$ trebuie sa contina o singura linie cu lungimea maxima a unui _substring_ care apare de cel putin $K$ ori in textul original.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 16 384$\r\n* $1 &le; K &le; N$\r\n* Pentru $30%$ din teste, $N &le; 1 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. substr.in|_. substr.out|\r\n|13 3\r\nyabadabadooba\r\n|2|\r\n\r\n_Explicatie_: Substringul _ba_ apare de trei ori in text. Orice substring de dimensiune mai mare (spre exemplu _aba_) apare de mai putin de trei ori.\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"substr\")==',256,'task: substr'),('problema/trib','Consiliul tribului','2006-11-11 22:33:26','==Include(page=\"template/taskheader\" task_id=\"trib\")==\r\n\r\nTribul Kazooba este format din $N$ oameni ce doresc sa se reuneasca pentru un consiliu al tribului. Oamenii sunt cu totii descendenti a unui singur om, care este seful tribului. Deoarece toti oamenii acestui trib au o viata lunga, ascendentii fiecarei persoane, chiar si seful tribului, sunt in viata si se vor prezenta la consiliu.\r\nOamenii ajung la consiliu intr-o anumita ordine si se aseaza la mese la venire. Ei stau intr-un rand de mese paralele. Prima masa este asezata la poalele Muntelui Sfant, si randul se extinde infinit spre vest (partea opusa muntelui). Pe de alta parte, fiecare om ar dori sa fie cat mai aproape de divinitate, asa ca, atunci cand soseste, el se aseaza catre masa cea mai apropiata de Muntele sfant la care nu s-a asezat nici unul dintre copii sau tatal lui.\r\nCa de obicei, zeii tribului au o inclinatie aparte pentru frumusete. Ei ar dori sa ceara membrilor tribului sa soseasca la consiliu intr-o ordine in care numarul de mese ocupate sa fie maxim. Din pacate, ei nu au nici un fel de inclinatie pentru programare, asa ca v-au cerut voua sa scrieti un program pentru asta.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care determina numarul maxim de mese ce poate fi ocupat la consiliu.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $trib.in$ contine un numar intreg $N$, reprezentand numarul de oameni din trib. Oamenii sunt numerotati de la 1 la $N$; seful lor este numarul 1. Fiecare dintre urmatoarele linii contin doua numere $A, B$ cu semnificatia \"exista o legatura directa de rudenie intre persoanele $A$ si $B$\". Relatiile descrise in fisierul de intrare sunt corecte (de exemplu nu exista cicluri, iar fiecare persoane este unul dintre descendentii sefului).\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $trib.out$ are o singura linie ce contine numarul maxim de mese care pot fi ocupate.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 < N &le; 100 000$\r\n* pentru $30%$ dintre teste $N &le; 1000$\r\n* orice masa are capacitate nelimitata\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. trib.in |_. trib.out |\r\n| 5\r\n1 4\r\n3 2\r\n1 3\r\n3 5 | 3 |\r\n\r\nh3. Explicatie\r\n\r\nDaca oamenii sosec in ordinea 2 4 1 5 3, ei se aseaza astfel:\r\n-2 se aseaza la prima masa\r\n-4 se aseaza la prima masa\r\n-1 are un fiu (4) la prima masa asa ca se aseaza la masa a 2-a\r\n-5 se aseaza la prima masa\r\n-3 are 2 fii la prima masa (2 si 5) si pe tatal sau (1) la a 2-a masa, asa ca se aseaza la a 3-a masa\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"trib\")==',1,'task: trib'),('problema/euro','Euro','2006-11-12 00:59:51','==Include(page=\"template/taskheader\" task_id=\"euro\")==\r\n\r\nTocmai v-ati deschis un nou cont in banca unde veti primi sume de bani in euro. Cand v-ati deschis contul nu ati avut nici euro sau lei in posesie. Pe parcursul urmatoarelor $N$ zile, veti primi diverse sume de euro; aceste sume pot fi negative, caz in care numarul total de euro din cont va scade. Este posibil ca uneori sa aveti o suma negativa de bani in contul vostru. La sfarsitul fiecarei zile banca va permite sa convertiti intreaga suma de euro pe care o aveti in cont in lei. Pretul unui euro variaza dupa urmatoarea regula: in timpul celei de-a {$K$}-a zile, un euro poate fi schimbat cu $K$ lei. Banca va cere un comision de $T$ lei pentru fiecare conversie. Astfel, daca la sfarsitul zilei $K$ aveti $S$ euro in cont si decideti sa ii convertiti veti primi $S*K-T$ lei in schimbul lor (bineinteles, $S$ poate fi negativ). La sfarsitul zilei $N$ veti fi obligati sa va convertiti toata suma de bani din cont in lei, chiar daca aceasta este nepozitiva.\r\n\r\nh2. Cerinta\r\n\r\nObiectivul vostru este sa maximizati suma de lei pe care o veti avea la sfarsitul zilei {$N$}.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $euro.in$ contine doua numere intregi, $N$ si {$T$}, separate prin spatii. Urmatoarea linie contine $N$ numere intregi ce reprezinta numarul de euro pe care il veti primi la inceputul fiecarei zile.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $euro.out$ contine un singur numar ce reprezinta suma maxima de lei pe care o puteti obtine.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 34567$\r\n* $0 &le; T &le; 34567$\r\n* $80%$ dintre teste vor avea $T &le; 255$\r\n* numarul de euro pe care il veti primii in fiecare zi este un intreg cuprins in intervalul [{$-1000, 1000$}]\r\n* este permis sa convertiti doar euro in lei, si nu lei in euro\r\n* pentru rezultat este recomandata folosirea tipurilor int64 sau extended in Pascal si long long sau long double in C/C++ (depinzand ce preferati, numere reale sau intregi); se garanteaza ca rezultatul se incadreaza in aceste tipuri de date, dar s-ar putea sa fie prea mare pentru alte tipuri de date mai mici\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. euro.in |_. euro.out |\r\n| 7 1\r\n-10 3 -2 4 -6 2 3\r\n| 17 |\r\n\r\nh3. Explicatii\r\n\r\nLa sfarsitul primei zile veti schimba cei $-10$ ce i-ati primit pentru $-11=-10*1-1$ lei. A doua conversie are loc la sfarsitul zilei $5$ cand veti avea $-1$  euro in cont ({$3-2+4-6$}). Suma de lei pe care o obtineti este {$-6=(3-2+4-6)*5-1$}. Veti efectua ultima conversie la sfarsitul zilei {$7$}, folosind ultimii $5$  euro din cont ({$2+3$}). Suma de lei pe care o obtineti este {$34=(2+3)*7-1$}. Suma finala de lei pe care o obtineti este {$17=-11-16+34$}.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"euro\")==',961,'task: euro'),('template/newuser','Profil %user_id%','2006-12-04 00:32:37','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',13,'protected'),('preoni-2006/comisie','Organizatori, preONI 2006','2006-11-27 16:14:08','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Organizatori\r\n\r\nEchipa care se ocupa de organizarea si desfasurarea concursului *preONI 2006* este \'echipa infoarena\':echipa-infoarena (faceti click pe link pentru a afla mai multe detalii despre echipa)\r\n\r\nh2. Organizare \r\n\r\n* \'Cristian George Strat\':utilizator/wickedman : coordonator, promovare concurs\r\n* Prof. Emil Onea : organizator \'finala in tabara\':preoni-2006/finala\r\n* \'Leonard Crestez\':utilizator/fluffy : asigura buna desfasurare a concursului din punct de vedere tehnic (site-ul, evaluatorul etc.)\r\n\r\nh2. Echipa stiintifica \r\n\r\nCei care se vor ocupa de buna desfasurarea a concursului din punct de vedere stiintific (redactarea si compunerea problemelor, realizarea testelor, clarificarea intrebarilor, etc.) sunt:\r\n\r\n* \'Mircea Pasoi\':utilizator/domino \r\n* \'Cosmin Negruseri\':utilizator/cosmin\r\n* \'Silviu Ganceanu\':utilizator/silviug\r\n* \'Adrian Diaconu\':utilizator/ditzonec\r\n* \'Daniel Pasaila\':utilizator/danielp\r\n* \'Tiberiu Florea\':utilizator/greco\r\n* \'Adrian Vladu\':utilizator/azotlichid\r\n\r\nh2. Colaboratori \r\n\r\n* Dan Burzo: sigla oficiala preONI 2006\r\n* \'Cristina Stancu-Mara\':utilizator/cimi : logo-uri runde preONI 2006\r\n* \'Filip Buruiana\':utilizator/filipb : propunator probleme\r\n\r\n==include(page=\"template/preoni-2006/footer\")==',13,'protected'),('preoni-2006/info','Informatii generale, preONI 2006','2006-11-27 16:13:59','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Informatii generale\r\n\r\nh2. Motivatia \r\n\r\nIndiferent de domeniul de activitate, concursurile reprezinta un element important in pregatirea indivizilor *competenti* deoarece promoveaza spiritul de *\"performer\"* si ajuta cu mult la perfectionarea cunostintelor acestora.\r\n\r\nIdeea care sta la baza proiectului _infoarena_ este aceea de a oferi tinerilor elevi sansa de a dobandi usor cunostinte valoroase si experienta in domeniul informaticii si al tehnologiei informatiei prin programe de pregatire eficiente. Proiectul s-a materializat intr-o platforma software ce permite *evaluarea automata* a mii de programe trimise de utilizatori si intr-o comunitate online aparte, devenind un adevarat motor de promovare si dezvoltare a performantei in informatica la cele mai inalte standarde. Nevoia de oameni bine pregatiti in acest domeniu este din ce in ce mai mare in societatea de azi. Asadar, pregatirea in acens sens pentru dezvoltarea unei gandiri algoritmice si a unor ablitati de programator devine necesara.\r\n\r\nComunitatea _infoarena_ cuprinde aproape totii elevii romani ce participa la concursuri de informatica nationale si internationale. Calitatea si valoarea concursurilor noastre precum si a materialelor educationale ce le punem la dispozitie este recunoscuta atat de elevi si studenti, cat si de profesori de renume in informatica. Suntem bucurosi ca am reusit sa contribuim la promovarea excelentei in randurile elevilor si ca am facut parte din programul de antrenament a celor mai de seama olimpici ai Romaniei. Ne mandrim cu reactiile pozitive pe care le-am primit de la elevi, studenti si profesori.\r\n\r\nDaca inca nu te-ai convins, afla mai multe detalii de pe pagina \'Despre infoarena\':despre-infoarena.\r\n\r\nh2. Ce a fost *preONI?*\r\n\r\nAnul 2005 a fost prima data cand concursul *preONI* a fost structurat in mai multe runde, pe parcursul a mai multor luni. Acesta a adunat, pe parcursul a 3 runde, un numar de participanti intre *1500* si *2700* la fiecare runda. Ultimele doua runde au fost sponsorizate de _Microsoft Romania_ care a oferit permii constand in carti de informatica primilor trei concurenti de la fiecare grupa (au existat grupa de clase 9-10 si grupa 11-12)\r\n\r\nh2. Ce este *preONI?* \r\n\r\nIn pragul inceperii olimpiadelor, alaturi de noi contribuitori, suntem determinati sa ducem _infoarena_ la urmatorul nivel. Ca si in anii anteriori \'echipa infoarena\':echipa-infoarena  vine in sprijinul elevilor din toata tara ce se pregatesc pentru olimpiada de informatica, in special _Olimpiada Judeteana de Informatica_ (OJI) si _Olimpiada Nationala de Informatica_ (ONI). Pornind de la aceasta idee ne-am asumat responsabilitatea sa organizam un concurs de pregatire, numit *preONI*. Acest concurs se afla deja la a 5-a editie, aceasta fiind a 3-a editie organizata de \'echipa infoarena\':echipa-infoarena.\r\n\r\nSelctionarea problemelor a fost atent facuta astfel incat nivelul de dificultate sa fie apropiat de cel de la concursuri asemanatoare, cu intentia de a acoperi cat mai bine materia de concurs si a evalua complet concuretii folosind probleme de dificultati gradate. Formatul concursului este asemanator cu acela al concursurilor nationale si internationale pentru a oferi participantilor o experienta realista.\r\n\r\nCum in fiecare an \'echipa infoarena\':echipa-infoarena  doreste sa imbunatateasca eficienta programelor sale de pregatire, noul format al concursului *preONI* de anul acesta este mult mai complex decat oricare din editiile anterioare, lucru cu siguranta imbucurator pentru toti utilizatorii. Asadar, navigheaza prin meniul din dreapta-sus daca vrei sa aflii ce suprize ti-au fost pregatite!\r\n\r\n==include(page=\"template/preoni-2006/footer\")==',13,'public'),('preoni-2006/regulament','Regulament, preONI 2006','2006-11-27 16:15:05','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Regulament\r\n\r\nSe recomanda, pe langa citirea acestui regulament, citirea \"regulamentului\":regulament general infoarena.\r\n\r\nEchipa infoarena isi rezerva dreptul de a modifica prezentul regulament pe parcursul desfasurarii concursului. Daca apar prevederi noi sau daca anumite prevederi ale regulamentului sunt modificate sau eliminate, atunci acestea vor fi anuntate pe site-ul concursului. Orice modificare a regulamentului va intra in vigoare, in functie de situatie, fie din momentul publicarii ei, fie dupa incheierea rundei aflate in desfasurare. In momentul anuntarii modificarii va fi precizat si momentul din care aceasta intra in vigoare.\r\n\r\nh2. Dreptul de participare\r\n\r\nPersoanele care fac parte din echipa infoarena cat si alti contribuitorii\r\nimplicati direct in organizarea concursului *preONI 2006* nu au dreptul de a participa. De asemenea, orice concurent care are un comportament considerat inadecvat fata de echipa infoarena sau fata de alti concurenti va fi descalificat. Un concurent se poate califica la finala doar daca se incadreaza in grupa la care a concurat (aceasta verificare se va face prin prezentarea unei dovezi legale care il incadreaza pe concurent la aceea grupa).\r\n\r\nh2. Repartizarea\r\n\r\nToti participantii vor fi repartizati in 3 grupe, in concordanta cu varsta lor. Repartizarii este asemanatoare cu acea facuta la olimpiadele de informatica.\r\n\r\n* Clasa a 9a (si gimnaziu)\r\n* Clasa a 10a\r\n* Clasele 11-12 \r\n\r\nOricine poate participa la o alta grupa decat cea la care se incadreaza, dar calificarea la finala cat si impartirea premiilor se va face conform regulamentului respectiv, fara nici o exceptie.\r\n\r\nh2. Inscriere\r\n\r\nTot ce trebuie sa faceti pentru a participa la concursul *preONI 2006* este sa aveti un cont la infoarena. Inregistrarea se poate face pe site-ul infoarena. Acelasi cont va fi folosit pentru a accesa forum-ul.\r\n\r\nh2. Runde\r\n\r\nVor exista 4 runde de calficare, iar in urma clasamentului stabilit primii de la fiecare grupa vor fi selectati pentru etapa finala desfasurata in cadrul unei tabere. Cele 4 runde vor avea loc sambata incepand cu ora 9:00, desi pot interveni exceptii. Durata lor va fi de 4 ore. Pentru un program detaliat al concursului \"click aici\":preoni-2006/program.\r\n\r\nh2. Intrebari\r\n\r\nIn prima ora vor putea fi formulate eventualele intrebari, pe forum, in topicurile special create. Orice intrebare pusa in alt mod (primita ca personal message, pe mail, etc.) va fi ignorata. Raspunsuri vor fi oferite doar la intrebarile puse in prima ora . Intrebarile trebuie formulate astfel incat sa se poate raspunda cu DA sau NU. In caz contrar sau in cazul in care raspunsul se afla in textul problemei se va raspunde cu NO COMMENT. Nu vor exista exceptii de la aceaste reguli. Daca echipa va considera ca raspunsul la o anumita intrebare este de interes general si clarifica anumite aspecte, atunci se va face un anunt general care va aparea atat pe forum cat si in sectiunea Mesaje de la organizatori a grupei respective. Fiecare grupa va avea doi administratori care se vor ocupa de raspunsul acestor intrebari.\r\n\r\nh2. Trimiterea solutiilor\r\n\r\nTrimitrea solutiile se va face prin intermediul interfetei site-ului infoarena.\r\nOdata logati in contul vostru, veti putea selecta arhiva la care doriti sa\r\nlucrati (in cazul acesta una din arhivele {*preONI 2006*}) si veti putea folosi link-ul trimite solutii.\r\n\r\nh2. Evaluare\r\n\r\nDupa expirarea timpului de trimitere a solutiilor acestea vor fi evaluate (\"mai multe detalii aici\":documentatie/evaluator). In mod normal, evaluarea se va face imediat dupa concurs, desi exista posibilitatea ca echipa infoarena sa amane evaluarea din motive obiective. Veti putea vizualiza pozitia ocupata in clasament dupa evaluarea in rubrica Clasamente si alte statistici.\r\n\r\nSe recomanda sa instalati pe calculatorul vostru aceleasi versiuni de compilatoare ca cele specificate la link-ul de mai sus. Echipa infoarena nu este responsabila pentru diferentele intre versiuni de compilatoare si nu va efectua reevaluaari in astfel de cazuri.\r\n\r\nh2. Contestatii\r\n\r\nEchipa infoarena isi rezerva dreptul de a reevalua orice problema in situatia in care se detecteaza erori in teste sau in programul de verificare dupa evaluare. Cum testele problemelor nu vor fi facute publice, posiblitatile de a contesta sunt limitate. Pentru a asigura o evaluarea corecta, echipa infoarena va garanteaza ca va testa intens toate problemele inainte de concurs si ca va verifica corectitudinea procesului de evaluare dupa terminare. In caz ca totusi aveti o contestatie, aceasta trebuie trimisa pe mail la adresa preONI2006 -at- gmail.com in termen de 24 de ore de la afisarea rezultatelor rundei curente pe site. Ele vor fi rezolvate in termen de maxim 5 zile, iar dupa rezolvarea lor rezultatele vor fi declarate finale.\r\n\r\nh2. Solutii\r\n\r\nLa scurt timp dupa terminarea evaluarii se va publica un articol cu solutiile pentru problemele rundei respective. Testele utilizate pentru evaluare nu vor fi facute publice.\r\n\r\nh2. Transferul problemelor\r\n\r\nProblemele vor fi mutate dupa evaluare in Arhiva de probleme infoarena, avand astfel la dispozitie un evaluator 24 din 24 si posiblitatea de a finisa solutiile la problemele nerezolvate in timpul concursului.\r\n\r\nh2. Trisare\r\n\r\n*preONI 2006* este un concurs individual, asadar orice tentativa de colaborare va aduce descalificarea celor implicati. echipa infoarena isi rezerva dreptul de a verifica sursele concurentilor, iar in caz ca se descopera surse aproximativ identice, concurentii respectivi vor fi descalificati din concurs iar user-ul lor de pe infoarena eliminat. Tentativele de frauda (concurarea sub un alt nume decat cel adevarat, etc.) sau orice atac asupra sistemului de evaluare sau asupra paginilor infoarena vor fi pedepsite in aceeasi masura. \r\n',13,'public'),('problema/invsort','Invsort','2006-11-12 14:27:14','==Include(page=\"template/taskheader\" task_id=\"invsort\")==\r\n\r\nSe da un sir de $N$ numere naturale, care trebuie ordonat crescator. Singura operatie permisa este sa considerati elementele de pe pozitiile $i, i+1, ..., j$ (pentru $i$ si $j$ arbitrare, $i<j$), si sa inversati ordinea acestor elemente (adica elementul de pe pozitia $i$ ajunge pe pozitia $j$, $i+1$ ajunge pe pozitia $j-1$, ..., $j$ ajunge pe pozitia $i$). Costul unei astfel de operatii este numarul de elemente din subsirul inversat, si anume $j-i+1$.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine o secventa de operatii care ordoneaza crescator sirul dat si are un cost total cat mai mic (dar nu obligatoriu minim).\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $invsort.in$ contine pe prima linie numarul $N$, si apoi $N$ linii cu elementele sirului dat (nu neaparat distincte).\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $invsort.out$ va contine pe fiecare linie descrierea unei operatii. O operatie este descrisa prin numerele $i$ si $j$, separate printr-un spatiu. Aceste numere satisfac $1 &le; i < j &le; N$.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 32000$\r\n* valorile sirului care trebuie ordonat sunt intre $0$ si $31999$\r\n\r\nh2. Punctaj\r\n\r\n* daca sirul de operatii (executate in ordinea din fisierul de iesire) nu ordoneaza intrarea, primiti $0$ puncte\r\n* in cazul in care costul total este cel mult $4000000$ (patru milioane) primiti punctaj maxim\r\n* in cazul in care costul total este cel mult $40000000$ (patruzeci de milioane) primiti $40%$ din punctajul pe test\r\n* in $50%$ din teste sirul de intrare contine numai elemente de $0$ si $1$\r\n* pentru toate testele folosite la corectare, $N=32000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. invsort.in |_. invsort.out |\r\n| 5\r\n1\r\n0\r\n1\r\n1\r\n0 | 3 5 \r\n1 3 |\r\n\r\nh3. Explicatie \r\n\r\n* prima operatie are efectul: $1 0 [1 1 0] -> 1 0 0 1 1$\r\n* a doua operatie are efectul: $[1 0 0] 1 1 ->  0 0 1 1 1$\r\n* costul total este $3 + 3 = 6$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"invsort\")==',1,'task: invsort'),('problema/caraibe','Caraibe','2006-11-11 22:46:41','==Include(page=\"template/taskheader\" task_id=\"caraibe\")==\r\n\r\nCei $N$ pirati de pe Perla Neagra au facut recent o captura foarte importanta: un cufar cu $10.000.000.000$ (zece miliarde) de banuti. Acum piratii au de rezolvat o problema si mai dificila: cum sa imparta banii.\r\nPentru impartire, piratii se aseaza in linie. Primul pirat va propune o schema de impartire a banilor. Daca un anumit numar de pirati nu sunt de acord cu aceasta schema, piratul va fi aruncat peste bord, si apoi urmatorul pirat va propune o schema de impartire, si tot asa. Piratii sunt foarte inteligenti: un pirat este de acord cu o schema de impartire doar daca aceasta ii aduce un avantaj strict (cel putin un banut) fata de ce ar obtine votand impotriva schemei. Pentru ca actioneaza numai pe baze rationale, piratii sunt si foarte predictibili. Cu alte cuvinte, un pirat poate anticipa decizia altor pirati pentru a lua o decizie proprie (aceasta inseamna si ca daca un pirat are mai multe posibilitati de a alege o schema de impartire, ceilalti pirati stiu ce varianta ar alege).\r\nDepinzand de caracteristicile fiecarui pirat (forta, popularitate), numarul de pirati care trebuie sa fie de acord cu schema lui pentru a nu fi aruncat peste bord variaza. Sa zicem ca pentru piratul $i (1 &le; i < N)$ acest numar este {$A{~i~}$}. Daca piratul $i$ propune o schema, stim ca toti piratii pana la $i-1$ au fost aruncati deja peste bord. In afara de piratul {$i$}, mai exista $N-i$ pirati. Daca cel putin $A{~i~}$ dintre acestia sunt de acord cu schema piratului {$i$}, comoara va fi impartita dupa aceasta schema. Altfel, piratul $i$ va fi aruncat peste bord, si piratul $i+1$ va propune o schema. Pentru orice {$i$}, avem {$0 &le; A{~i~} < N-i$}. Datorita acestei conditii {$A{~N-1~}=0$}, iar $A{~N~}$ nu este definit (pentru ca piratul $N$ este ultimul).\r\n\r\nh2. Cerinta\r\n\r\nPrimul pirat din linie doreste sa propuna o schema de impartire a banilor astfel incat sa nu fie aruncat peste bord, si el sa primeasca cat mai multi banuti. Determinati suma maxima pe care o poate primi. Se garanteaza ca exista o schema pe care o poate propune primul pirat, astfel incat el sa nu fie aruncat peste bord.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $caraibe.in$ contine pe prima linie numarul $N$ de pirati. Pe urmatoarele linii se gasesc valorile {$A{~1~}$}, {$A{~2~}$}, ..., {$A{~N-2~}$}, cate o valoare pe o linie. Asa cum se mentioneaza mai sus, $A{~N-1~}$ este intotdeauna zero, si nu apare in fisier.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $caraibe.out$ va contine numarul maxim de banuti pe care ii poate primi primul pirat.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 65 000$\r\n* $0 &le; A{~i~} < N-i$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. caraibe.in |_. caraibe.out |\r\n| 4\r\n1\r\n1\r\n| 9999999999 |\r\n\r\nh3. Explicatii\r\n\r\nSchema propusa de primul pirat este: *9999999999* de banuti pentru el insusi, *1* banut pentru al treilea pirat si *0* (zero) pentru ceilalti. Asta il face pe piratul al treilea sa fie de acord cu schema. El rationeaza astfel: \"piratii *2* si *4* nu sunt de acord; daca si eu sunt impotriva, piratul *1* va fi aruncat peste bord ({*A{~1~}=1*}); apoi piratul *2* va propune schema: *9999999999* de banuti pentru el insusi, *1* banut pentru piratul *4* si nimic pentru mine; piratul *4* va fi de acord, deci schema va fi acceptata ({*A{~2~}=1*}); motivul pentru care piratul *4* va fi de acord este ca in cazul in care piratul *2* e aruncat peste bord, eu imi voi acorda toti banii mie si el nu primeste nimic ({*A{~3~}=0*})\"\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"caraibe\")==',13,'task: caraibe'),('problema/farey','Secventa Farey','2006-11-12 13:13:14','==Include(page=\"template/taskheader\" task_id=\"farey\")==\r\n\r\nO secventa farey de ordinul $N$ este secventa tuturor fractiilor ireductibile $^P^/{~Q~}$ cu $0 < P < Q &le; N$, aranjate in ordine crescatoare. De exemplu, secventa Farey de ordinul 5 este:\r\n\r\np=. $^1^/{~5~} ^1^/{~4~} ^1^/{~3~} ^2^/{~5~} ^1^/{~2~} ^3^/{~5~} ^2^/{~3~} ^3^/{~4~} ^4^/{~5~}$\r\n\r\nVom numerota fractiile din secventa incepand cu $1$. De exemplu, a $6$-a fractie din secventa Farey de ordin $5$ este $^3^/{~5~}$.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se $N$ si un numar $K$, aflati a $K$-ua fractie dintr-o secventa Farey de ordin $N$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $farey.in$ contine o singura linie cu numerele $N$ si $K$ separate prin spatiu. $K$ va fi mereu un index valid, adica va fi cel putin $1$ si nu va fi mai mare decat numarul de fractii din secventa Farey de ordin $N$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $farey.out$ va contine o singura linie cu doua numere intregi $P$ si $Q$ separate prin spatiu. Fractia $^P^/{~Q~}$ trebuie sa fie a $K$-ua fractie din secventa Farey de ordin $N$. Fractia trebuie sa fie ireductibila, adica cel mai mare divizor comun dintre $P$ si $Q$ trebuie sa fie $1$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 < N &le; 40 000$\r\n* $40%$ din teste vor avea $K &le; 50 000$\r\n* toate datele de test folosite pentru evaluare vor avea $N &ge; 10 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. farey.in |_. farey.out |\r\n| 5 6 | 3 5 |\r\n\r\nh3. Sfat prietenesc \r\n\r\nAceasta nu este o problema de matematica; pentru a o rezolva sunt necesare doar cunostiinte matematice elementare. Trebuie in schimb sa gasiti un algoritm performant pentru a o rezolva.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"farey\")==',1,'task: farey'),('problema/cmmdc','CMMDC','2006-11-11 18:15:52','==Include(page=\"template/taskheader\" task_id=\"cmmdc\")==\r\n\r\nh2. Date de Intrare\r\n\r\nDatele de intrare se citesc din fisierul $cmmdc.in$:\r\n\r\n* pe prima linie: un numar natural, $a$\r\n* pe a doua linie: un numar natural, $b$\r\n\r\nh2. Date de Iesire\r\n\r\nDatele de iesire se tiparesc in fisierul $cmmdc.out$\r\n\r\n* pe prima linie: cel mai mare divizor comun pentru $a$ si $b$. Daca $a$ si $b$ sunt numere prime intre ele, atunci se va tipari $0$\r\n\r\nh2. Restrictii\r\n\r\n* Celor doua numere nu vor depasi niciodata valoarea 30000\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. cmmdc.in |_. cmmdc.out |\r\n|8 12| 4 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cmmdc\")==',15,'task: cmmdc'),('problema/flip','Jocul Flip','2006-11-12 16:24:59','==Include(page=\"template/taskheader\" task_id=\"flip\")==\r\n\r\nGigel a descoperit un nou joc pe care l-a numit \"Flip\". Acesta se joaca pe o tabla dreptunghiulara de dimensiuni $N*M$ care contine numere intregi. Fiecare linie si fiecare coloana are un comutator care schimba starea tuturor elementelor de pe acea linie sau coloana, inmultindu-le cu {$-1$}. Scopul jocului este ca pentru o configuratie data a tablei de joc sa se actioneze asupra liniilor si coloanelor astfel incat sa se obtina o tabla cu suma elementelor cat mai mare.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se o configuratie pentru tabla \"Flip\", realizati un program care sa determine suma maxima pe care Gigel o poate obtine.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $flip.in$ contine doua numere intregi $N$ si {$M$}, separate prin cate un spatiu, care reprezinta dimensiunea tablei. Urmatoarele $N$ linii contin cate $M$ numere intregi seperate prin cate un spatiu care descriu configuratia tablei de joc.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului $flip.out$ contine un numar care va reprezenta suma maxima pe care Gigel o poate obtine comutand liniile si coloanele tablei de joc.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 16$\r\n* Tabla de joc contine numere intregi din intervalul [{$-1.000.000,1.000.000$}]\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. flip.in |_. flip.out |\r\n| 5 3\r\n4 -2 2\r\n3 -1 5\r\n2 0 -3\r\n4 1 -3\r\n5 -3 2\r\n| 28 |\r\n\r\nh3. Explicatie\r\n\r\nSe comuta coloana a doua si linia a treia.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"flip\")==',961,'task: flip'),('problema/fractii','Fractii','2006-11-12 13:07:43','==Include(page=\"template/taskheader\" task_id=\"fractii\")==\r\n\r\n\r\n\r\nGigel, intr-o zi cand isi facea temele la matematica, s-a apucat sa scrie pe o foaie de hartie, un sir de fractii ireductibile de forma $^P^/{~Q~}$ cu $1 &le; P,Q &le; N$, unde $N$ este un numar natural ales de el. De exemplu, pentru $N = 4$ el a obtinut urmatorul sir:\r\n\r\np=. $^1^/{~1~}  ^1^/{~2~}  ^1^/{~3~}  ^1^/{~4~}  ^2^/{~1~}  ^2^/{~3~}  ^3^/{~1~}  ^3^/{~2~}  ^3^/{~4~}  ^4^/{~1~}  ^4^/{~3~}$\r\n\r\nGigel s-a apucat apoi sa numere cate fractii a obtinut pentru $N = 4$ si a vazut ca sunt $11$.\r\n\r\nh2. Cerinta\r\n\r\nFiind dat un numar natural $N$, sa se determine cate fractii sunt in sirul de fractii construit dupa regulile de mai sus.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $fractii.in$ contine pe prima linie numarul natural $N$.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $fractii.out$ trebuie sa contina un numar natural pe prima linie care reprezinta cate fractii sunt in sir.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 1.000.000$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. fractii.in |_. fractii.out |\r\n| 3 | 7 |\r\n| 4 | 11 |\r\n| 5 | 19 |\r\n| 10| 63 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"fractii\")==',1,'task: fractii'),('problema/perm','Permutari','2006-11-12 14:35:03','==Include(page=\"template/taskheader\" task_id=\"perm\")==\r\n\r\nO permutare de lungime $N$ este un sir de elemente distincte din multimea {${1,2,3 ... N}$}. Spunem ca o permutare are $K$ maxime daca exista fix $K$ pozitii distincte in permutare, pentru care elementul curent este mai mare decat toate elementele din stanga lui.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care determina cate permutari de lungime $N$ cu $K$ maxime exista.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierul $perm.in$ se vor gasi numerele $N$ si {$K$}, separate prin cate un spatiu.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierul $perm.out$ se va gasi numarul de permutari de lungime $N$ cu $K$ maxime.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; K &le; N &le; 200$\r\n\r\nExemple\r\n\r\ntable(example). |_. perm.in |_. perm.out |\r\n| 3 2 | 3 |\r\n| 5 3 | 35 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"perm\")==',961,'task: perm'),('problema/fact','Factorial','2006-11-11 23:27:44','==Include(page=\"template/taskheader\" task_id=\"fact\")==\r\n\r\nSe da un numar intreg $P$ ({$0<=P<=10^8^$}). Problema cere gasirea celui mai mic numar natural strict pozitiv $N$ pentru care $N!$ are exact $P$ cifre de $0$ la sfarsit.\r\n\r\nSe stie ca {$N! = 1*2*3*....*(n-1)*n$}.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul $fact.in$ va contine pe prima linie numarul intreg $P$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $fact.out$ se va scrie acel numar $N$ care indeplineste condiitle impuse sau $-1$ daca nu exista un astfel de $N$.\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. fact.in |_. fact.out |\r\n| 0&nbsp; | 1  |\r\n| 2 | 10 |\r\n|10 | 45 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"fact\")==',13,'task: fact'),('problema/datorii','Datorii','2006-11-11 23:22:46','==Include(page=\"template/taskheader\" task_id=\"datorii\")==\r\n\r\nTatal si mama lui Gigel se ocupa cu vanzarea de sisteme de calcul. Afacerea s-a dovedit a fi foarte profitabila datorita unui sistem incredibil de creditare a clientilor: un client care cumpara un calculator in ziua $X$ (in acest moment au trecut $N$ zile de la infiintarea magazinului, zilele se numeroteaza de la 1 la $N$, {$0<X&le;N$}) poate returna banii oricand doreste acesta, neexistand o limita de timp impusa. Astfel, aproape in fiecare zi, la magazinul familiei se prezinta diversi clienti care achita integral sau partial un sistem de calcul cumparat in zilele anterioare. Deoarece vor sa inceapa o noua afacere, Mama si Tata doresc sa il insarcineze pe Gigel cu administrarea magazinului de calculatoare. Pentru aceasta Gigel trebuie sa indeplineasca o conditie esentiala: in orice moment al sederii lui la magazin el poate fi solicitat prin telefon de catre tatal sa raspunda cat mai repede la urmatoarea familie de intrebari: ce suma de bani a ramas inca neachitata luand in considerare achizitiile facute de clienti in zilele $P$, $P+1$, {$P+2$}... {$Q-1$}, {$Q$} ({$0<P&le;Q&le;N$}). Se stie ca niciodata nu s-au cumparat doua calculatoare in aceeasi zi. Ajuta-l pe Gigel sa demonstreze parintilor ca poate administra magazinul.\r\n\r\nh2. Cerinta\r\n\r\nSe dau: $N$, $M$, un sir de numere {$A{~1~}$}, {$A{~2~}$}... {$A{~N~}$} si $M$ operatii. {$A{~i~}$} ({$1&le;A{~i~}&le;1000$}, {$1&le;i&le;N$}) reprezinta suma de bani inca neachitata pentru o comanda efectuata in ziua $i$. O operatie poate fi de doua feluri:\r\n\r\n* $A$ (achitare - se scade o valoare din suma restanta a unei zile anume)\r\n* $B$ (interogare - se cere suma tuturor sumelor restante ale unui interval de zile). Programul trebuie sa scrie in fisierul de iesire suma ceruta de fiecare operatie de tip $B$ in momentul interogarii.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul $datorii.in$ va contine pe prima linie numerele $N$ si $M$. Pe urmatoarea linie se afla valorile sirului {$A{~1~}$}, {$A{~2~}$}... {$A{~N~}$} separate prin cate un spatiu. Urmatoarele $M$ linii descriu operatiile (achitari sau interogari) efectuate in ordinea data. Fiecare linie care descrie o operatie incepe cu un cod binar (un numar intreg cu valoarea 0 sau 1) si continua cu 2 numere intregi.\r\n\r\n* Un cod 0 urmat de doua numere intregi $T$, $V$ ({$1&le;T&le;N$}, {$1&le;V&le;1000$}) reprezinta o operatie de tip $A$ (in momentul respectiv s-a achitat o valoare $V$ din suma restanta a zilei $T$)\r\n* Un cod 1 urmat de doua numere intregi $P$, $Q$ ({$1&le;P&le;Q&le;N$}) o operatie de tip $B$ (se cere suma tuturor sumelor restante din zilele $P$, {$P+1$}, {$P+2$}... $Q$ in momentul respectiv).\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $datorii.out$ se vor scrie pe cate o linie sumele cerute de fiecare operatie de tip $B$ (sumele se cer in ordinea aparitiei operatiilor in fisierul de intrare).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 15 000$\r\n* {$0 < M &le; 100 000$}\r\n* In orice moment, {$A{~i~}$} ({$1&le;i&le;N$}) este nenegativ.\r\n\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. datorii.in|_. datorii.out|\r\n|6 6\r\n1 3 2 0 0 10\r\n1 3 6\r\n1 1 4\r\n0 3 1\r\n1 1 6\r\n0 6 2\r\n1 1 6\r\n|12\r\n6\r\n15\r\n13|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"datorii\")==',13,'task: datorii'),('problema/desc','Descompuneri','2006-11-11 23:19:08','==Include(page=\"template/taskheader\" task_id=\"desc\")==\r\n\r\nSe defineste o descompunere a unui numar natural $N$ ca fiind o secventa crescatoare ( nu neaparat stricta ) de numere naturale al caror produs este $N$\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un numar natural $N$ si un numar natural $K$ calculati numarul de descompuneri ale lui $N$ precum si cea de-a $K$ -a descompunere a sa(in ordine lexicografica).\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $desc.in$ contine doua numere intregi $N$ , respectiv $K$ cu semnificatia de mai sus.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $desc.out$ veti afisa pe prima linie $X$ numarul de descompuneri ale lui $N$ , iar pe a doua linie veti afisa sirul care reprezinta cea de-a $K$ -a descompunere, numerele fiind despartite printr-un spatiu.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 10^12^$\r\n* $1 &le; K &le; 10^9^$\r\n* Un sir $A{~1~}, A{~2~},...,A{~s~}$ este mai mic lexicografic decat un alt sir $B{~1~}, B{~2~},...,B{~t~}$ daca exista $i &le; min(s,t)$ astfel incat $A{~1~}=B{~1~}, A{~2~}=B{~2~},...,A{~i-1~}=B{~i-1~}$ si $A{~i~} < B{~i~}$\r\n* Pentru fiecare test se se vor acorda $4$ puncte pentru aflarea corecta a numarului de descompuneri, si $6$ puncte pentru aflarea celei de-a {$K$}-a descompunere.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. desc.in |_. desc.out |\r\n| 36 5\r\n| 9\r\n3 3 4 |\r\n\r\nh3. Explicatii\r\n\r\nCele $9$ descompuneri sunt (in ordine lexicografica): $2 2 3 3 , 2 2 9 , 2 3 6 , 2 18 , 3 3 4 , 3 12 , 4 9 , 6 6 , 36$\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"desc\")==',961,'task: desc'),('problema/copaci','Copaci','2006-11-11 22:33:03','==Include(page=\"template/taskheader\" task_id=\"copaci\")==\r\n\r\nMacarie, dupa ce a muncit o viata intreaga, se decide la batranete sa se retraga pe o insula pentru a-si gasi linistea interioara si a se dedica naturii. Astfel el cumpara o insula pe care cultiva pomi fructiferi. Insula poate fi reprezentata ca un poligon (nu neaparat convex) intr-un sistem de axe de coordonate pozitive. Pomii sunt plantati doar la coordonate naturale.\r\n\r\nh2. Cerinta\r\n\r\nMacarie este interesat de numarul de copaci pe care il poate planta strict in interiorul insulei. In acest scop el va furnizeaza copacii care determina insula (varfurile poligonului).\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului copaci.in contine numarul intreg $N$ de copaci de pe linie. Urmatoarele $N$ linii contin cate doua numere intregi seperate prin cate un spatiu care descriu coordonatele celor $N$ pomi date intr-o anumita ordine (trigonometrica sau orara).\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului copaci.out contine un numar care va reprezenta numarul de copaci strict in interiorul insula.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; N &le; 100.000$\r\n* Coordonatele copacilor au valori intregi din intervalul [{$0, 2.000.000$}]\r\n* pot fi dati mai mult de $2$ copaci pe o latura a \"poligonului\" insulei (cum se vede si in exemplu, penultimul copac)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. copaci.in |_. copaci.out |\r\n| 13\r\n3 1\r\n6 3\r\n9 2\r\n8 4\r\n9 6\r\n9 9\r\n8 9\r\n6 5\r\n5 8\r\n4 4\r\n3 5\r\n2 4\r\n1 3\r\n| 21 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"copaci\")==',961,'task: copaci'),('problema/pietre','Pietre','2006-11-12 15:11:41','==Include(page=\"template/taskheader\" task_id=\"pietre\")==\r\n\r\nMacarie si Petronela joaca un joc foarte interesant care, spera ei, le va dezvolta inteligenta si mai mult. Astfel ei au in fata doua gramezi de pietre (cu $A$ respectiv $B$ pietre fiecare). Jocul se desfasoara alternativ (Macarie incepe), iar la un moment dat un jucator poate lua un numar oarecare de pietre dintr-o gramada sau poate lua acelasi numar de pietre din ambele gramezi. Pierde cel care nu mai poate lua pietre.\r\n\r\nh2. Cerinta\r\n\r\nVa trebui sa aflati castigatorul pentru $T$ jocuri stiind ca mereu Macarie incepe jocul.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $pietre.in$ contine numarul $T$ de teste. Urmatoarele $T$ linii contin cate 2 numere intregi $A$ si $B$ seperate prin cate un spatiu care descriu numarul de pietre din cele doua gramezi.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $pietre.out$ va contine $T$ linii corespunzatoare celor $T$ teste cu valoarea $1$ daca la testul respectiv castiga Macarie si $2$ daca invinge Petronela.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; A, B &le; 1.000.000$\r\n* $1 &le; T &le; 10$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. pietre.in |_. pietre.out |\r\n| 2 \r\n1 2\r\n2 3 | 2\r\n1 |\r\n\r\nh3. Explicatii\r\n\r\nIn primul test Macarie poate lua $1$ piatra din oricare gramada, $2$ pietre din a doua gramada sau o piatra din ambele gramezi, in toate cazurile Petronela putand lua toate pietrele ramase castigand jocul.\r\nIn testul $2$ Macarie castiga luand $2$ pietre din a doua gramada si Petronela va pierde conform acelorasi considerente de la exemplul $1$.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"pietre\")==',1,'task: pietre'),('problema/abc','ABC','2006-11-11 14:17:39','==Include(page=\"template/taskheader\" task_id=\"abc\")==\r\n\r\nHaralambie a primit ca tema la informatica urmatoarea problema: Fie un sir $A$ de $N$ numere naturale distincte, mai mici sau egale cu un numar natural $B$ dat. De asemenea, se mai da si un numar natural $C$. Se cere determinarea unui sir de $N$ numere naturale distincte $D$, mai mici sau egale cu $B$, astfel incat suma acestora sa fie egala cu $C$, iar termenul maxim al sirului $|A{~i~} - D{~i~}|$ sa fie minim.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Haralambie si determinati un sir $D$ care indeplineste conditiile impuse.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $abc.in$ contine pe prima linie numerele naturale $N$, $B$ si $C$ separate prin cate un spatiu. Pe urmatoarea linie se vor afla cele $N$ numere ale sirului $A$, separate prin cate un spatiu.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $abc.out$ va contine pe prima si singura linie elementele sirului $D$, separate prin cate un spatiu. In caz ca exista mai multe solutii, puteti afisa oricare dintre ele.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 30.000$\r\n* $1 &le; B &le; 65.535$\r\n* $1 &le; C &le; 2.147.483.647$\r\n* Pentru toate testele folosite la evaluare va exista solutie.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. abc.in |_. abc.out |\r\n| 6 10 38 \r\n  1 3 4 7 9 10\r\n| 2 4 5 8 9 10 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"abc\")==',1,'task: abc'),('template/newtask','%task_id%','2006-11-13 17:24:22','== include(page=\"template/taskheader\" task_id=\"%task_id%\") ==\r\n\r\nPoveste si cerinta...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n... &le; ...\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. %task_id%.in |_. %task_id%.out |\r\n| This is some\r\n  text written on\r\n  multiple lines.\r\n| This is another\r\n  text written on\r\n  multiple lines.\r\n| \r\n\r\nh3. Explicatie\r\n\r\n...\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"%task_id%\") ==\r\n',1,'protected'),('problema/prim','Numere Prime','2006-11-12 16:30:41','==Include(page=\"template/taskheader\" task_id=\"prim\")==\r\n\r\nGheorghe a invatat la scoala despre numere prime. A invatat ca un numar este prim, daca se divide doar cu $1$ si cu el insusi({$1$} nu este considerat numar prim). A aflat ca exista algoritimi foarte eficienti care pot determina daca un numar este prim sau nu, in timp chiar sub polinomial. Din pacate acesti algoritmi sunt foarte complicati, si Gheorghe s-a gandit la o aproximare. Idea lui este sa consideri un numar prim daca nu se divide la primele $K$ numere prime.\r\n\r\nh2. Cerinta\r\n\r\nDemonstreaza ca ideea lui Ghoerghe este doar o aproximare. Dandu-se un numar $K$, afla cel mai mic numar $N$ care nu este divisibil cu primele $K$ numele prime, dar nu este prim.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie din fisierul $prim.in$ se va afla numarul $K$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $prim.out$ se va gasi numarul $N$ cautat.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; K &le; 100.000$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. prim.in |_. prim.out |\r\n| 1\r\n| 9 |\r\n\r\nh3. Explicatii\r\n\r\n$9$ nu este divizibil cu $2$ si nu este nici prim.\r\n\r\ntable(example). |_. prim.in |_. prim.out |\r\n| 3\r\n| 49 |\r\n\r\nh3. Explicatii\r\n\r\nPrimele $3$ numere prime sunt $2, 3, 5$. Numerele care nu sunt divisibile cu $2, 3$ sau $5$ sunt : $7, 11, 13, 17, 19, 23, 31, 37, 41, 47, 49, .. 49$ este cel mai mic numar care nu este prim.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"prim\")==',15,'task: prim'),('problema/color','Color','2006-11-11 19:57:03','==Include(page=\"template/taskheader\" task_id=\"color\")==\r\n\r\nConsideram un graf complet cu $N$ varfuri in care muchiile sunt colorate fie in rosu, fie in negru. In acest graf se pot forma triunghiuri monocromatice (trei varfuri conectate prin muchii colorate cu aceeasi culoare).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine pentru un graf colorat dat numarul de triunghiuri monocromatice.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $color.in$ contine:\r\n\r\ntable(example). | N S \r\n x{~1~} y{~1~} \r\n x{~2~} y{~2~} \r\n ...\r\n x{~s~} y{~s~}\r\n| N - numarul de varfuri din graf, S - numarul de muchii rosii\r\n x{~i~} y{~i~} - extrmitatile celei de a i-a muchii rosii |\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $color.out$ contine pe prima linie numarul de triunghiuri monocromatice.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 4.000$\r\n* $1 &le; S &le; 500.000$\r\n* In fisierul de intrare nu apare de mai multe ori aceeasi muchie.\r\n* Muchiile care nu apar in fisierul de intrare sunt colorate, evident, in negru.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. color.in |_. color.out |\r\n| 4 4\r\n1 2\r\n2 3\r\n4 3\r\n4 2 \r\n| 1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"color\")==',18,'task: color'),('problema/cutii','Cutii','2006-11-11 20:09:55','==Include(page=\"template/taskheader\" task_id=\"cutii\")==\r\n\r\nSe dau $N$ cutii paralelipipedice prin dimensiunile lor ({$X, Y$} si {$Z$}). Se stie ca o cutie se poate pune in alta doar daca toate dimensiunile ei sunt strict mai mici cele ale cutiei in care va fi bagata. Se cere numarul maxim de cutii ce pot fi selectate din cele $N$ astfel incat ele sa poata fi \"cuibarite\" (o cutie va contine o cutie care la randul ei va contie o alta s.a.m.d. pana la cea mai mica care nu va mai contine nimic).\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $cutii.in$ va contine $N$ si $T$, reprezentand numarul de cutii si respectiv numarul de teste care vor urma. Pentru fiecare din cele $T$ teste vor urma cate $N$ linii continand $3$ numere reprezentand dimensiunile fiecarei cutii.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $cutii.out$ va contine $T$ linii pe fiecare linie un numar reprezentand numarul maxim de cutii ce pot fi alese pentru fiecare test.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 3500$\r\n* $1 &le; T &le; 100$\r\n* Dimensiunile cutiilor sunt date astfel fiecare dimensiune in parte (din cele trei posibile) ia toate valorile de la $1$ la $N$ in fiecare test din cele $T$ (valorile unei dimensiuni a cutiilor dintr-un test vor forma o permutare a numerelor de la $1$ la $N$).\r\n* Timpul de executie a fost ales astfel incat $20%$ din el va fi folosit pentru citire si restul de $80%$ pentru calcularea rezultatelor\r\n* $40%$ din teste vor avea $N &le; 100$ iar restul vor avea $N = 3500$ si $T = 100$\r\n* O cutie nu poate fi intoarsa in nici un fel (dimensiunile ei isi vor pastra ordinea)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. cutii.in |_. cutii.out |\r\n| 3 2\r\n1 1 1\r\n2 2 2\r\n3 3 3\r\n1 2 2\r\n2 1 1\r\n3 3 3\r\n| 3\r\n2 |\r\n\r\nh3. Explicatii\r\n\r\nPentru primul set de cutii se selecteaza toate cutiile deoarece cutia cu numarul 2 se poate pune in cutia 3 iar cutia 1 in cea de-a doua. Pentru cel de-al doilea set se selecteaza cutiile 1 si 3 sau cutiile 2 si 3 neexistand posibilitatea de a le lua pe toate. \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cutii\")==',13,'task: cutii'),('problema/patrol','Patrol','2006-11-11 23:23:41','==Include(page=\"template/taskheader\" task_id=\"patrol\")==\r\n\r\nO tara are $N$ orase si $M$ legaturi directe, bidirectionale, intre aceste orase. Fiecare oras percepe o taxa de sedere cunoscuta. Un infractor porneste din orasul numerotat cu $1$ si doreste sa ajunga in orasul numerotat cu $N$, folosind legaturile existente. Cum lucrurile nu sunt niciodata asa de simple, exista si $P$ politisti care il cauta. Un politist are un traseu de patrulare bine definit. Traseul sau este de fapt un drum simplu ( in care toate orasele sunt distincte ). El va parcurge un drum du-te vino, adica pleaca pe drumul stabilit, dupa care se intoarce pe acelasi drum, etc. De exemplu, daca traseul de patrulare al unui politist este $4 7 5$, el va merge intotdeuna pe $4 7 5 7 4 7 5 7 4...$. Parcurgerea unei legaturi intre oricare doua orase legate direct se realizeaza intr-o unitate de timp, pentru infractor si pentru oricare dintre politisti. Stationarea intr-un oras nu necesita timp suplimentar.\r\nInfractorul porneste din orasul numerotat cu $1$ si doreste sa ajunga in orasul numerotat cu $N$, platind o taxa de sedere minima prin orasele prin care trece, evitand intalnirea cu vreun politist. O intalnire se poate realiza atunci cand infractorul si unul din politisti se afla in acelasi timp in acelasi oras, sau in acelasi timp pe o legatura intre orase. Plecarea din orasul $1$ se realizeaza la momentul $1$, cand toti politistii isi incep patrularea.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine costul total minim de sedere in orase astfel incat sa se indeplineasca conditiile precizate.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $patrol.in$ are urmatoarea structura:\r\n\r\ntable(example). | $N M P$ \r\n${@C[1] C[2]...C[n]@}$ \r\n${@A[1] B[1]@}$\r\n${@A[2] B[2]@}$ \r\n$.......$     \r\n${@A[M] B[M]@}$\r\n${@L[1] T[1,1]...T[1,L[1]]@}$\r\n${@L[2] T[2,1]...T[2,L[2]]@}$ \r\n$.......$ \r\n${@L[P] T[P,1]...T[P,L[P]]@}$\r\n| numarul de orase, de legaturi si de politisti\r\ncosturile de sedere, pentru fiecare oras in parte\r\n&nbsp;\r\nlinia ${@A[i] B[i]@}$ semnifica faptul ca exista o\r\nlegatura directa intre orasele ${@A[i]@}$ si ${@B[i]@}$\r\n&nbsp;\r\nprimul numar de pe linie indica lungimea\r\ntraseului de patrulare, dupa care urmeaza\r\ndescrierea traseului propriu-zis | \r\n\r\n\r\nIn total, fisierul de intrare contine M+P+2 linii.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie a fisierului de iesire $patrol.out$ contine costul minim platit. Se garanteaza ca intotdeauna exista solutie.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 < N &le; 1 024$\r\n* $4 < M &le; 16 000$\r\n* $P &le; 512$\r\n* $2 &le; L[i] < 8$\r\n* Costurile de sedere sunt numere naturale din $[1, 1 600]$\r\n* In orice moment infractorul trebuie sa se deplaseze ( nu poate sta pe loc )\r\n* La costul total se vor calcula si taxele percepute in orasul de plecare si cel de sosire\r\n* Este posibil ca intr-un oras, in acelasi timp, sa fie mai mult de un politist\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. patrol.in |_. patrol.out |\r\n| 7 6 1\r\n10 4 9 1 2 5 2\r\n1 2\r\n2 3\r\n2 4\r\n2 6\r\n4 5\r\n6 7\r\n5 7 6 2 4 5\r\n| 34 |\r\n\r\nh3. Explicatie\r\n\r\nDrumul infractorului este 1 2 3 2 6 7. Se observa ca, de exemplu, la timpul 2, infractorul nu poate pleca spre orasul cu numarul 6 pentru ca s-ar intalni pe legatura dintre orasele 2 si 6 cu politistul. In plus, daca ar pleca spre orasul cu numarul 4, el ar fi prins in final de catre politist.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"patrol\")==',1,'task: patrol'),('problema/string','String','2006-11-11 20:48:07','==Include(page=\"template/taskheader\" task_id=\"string\")==\r\n\r\nSe considera alfabetul format numai din literele mici $a$ si $b$ si un sir $S$ format numai din caractere din acest alfabet. Pe acest alfabet, se defineste relatia de incluziune, astfel: un sir $S{~1~}$ este inclus in sirul $S{~2~}$, daca lungimea sirului $S{~2~}$ (egala cu numarul de caractere ale sirului) este mai mare sau egala decat a sirului $S{~1~}$ si exista o pozitie $k$ in sirul $S{~2~}$, astfel incat $S{~2, k~} = S{~1,1~}, S{~2,k+1~} = S{~1,2~}, ... , S{~2,k+L-1~} = S{~1,L~}$, unde $L$ este lungimea sirului $S{~1~}$, $k+L-1$ este mai mic sau egal decat lungimea sirului $S{~2~}$ , iar $X{~i~}$ reprezinta al $i$-lea caracter din sirul $X$. De exemplu, sirul $abba$ este inclus in sirul $babbaba$, dar nu este inclus in sirul $ababab$.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati cel mai scurt sir format numai din caractere din alfabetul considerat, care sa nu fie inclus in sirul $S$.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $string.in$ se afla numarul intreg $N$, reprezentand numarul de caractere ale sirului $S$. Pe urmatoarea linie se afla cele $N$ caractere, in ordinea pozitiei lor in sir.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului de iesire $string.out$ veti afisa numarul intreg $L$, reprezentand lungimea minima a unui sir care nu este inclus in sirul $S$. Pe a doua linie veti afisa un astfel de sir. Daca exista mai multe solutii, puteti afisa oricare dintre ele.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 500.000$\r\n* $0 < L$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. string.in |_. string.out |\r\n| 11\r\naabaaabbbab \r\n| 4 \r\naaaa |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"string\")==',18,'task: string'),('problema/secv3','Secventa 3','2006-11-12 15:29:27','==Include(page=\"template/taskheader\" task_id=\"secv3\")==\r\n\r\nGigel este o persoana cu o imaginatie foarte bogata, mai ales cand doarme! Intr-o noapte a visat ca are de indeplinit o sarcina foarte bizara: trebuie sa aleaga o secventa (adica un subsir de elemente care apar pe pozitii consecutive in sirul initial) din $N$ elemente pentru care se cunosc costul si timpul. Secventa aleasa trebuia sa fie de lungime minim $L$ si maxim $U$, iar suma costurilor elementelor secventei impartita la suma timpurilor elementelor secventei sa fie maxima.\r\n\r\nh2. Cerinta\r\n\r\nIn scurt timp, visul lui Gigel s-a transformat intr-un cosmar deoarece nu poate sa rezolve sarcina! Scrieti un program care sa-l ajute!\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie in fisierul de intrare $secv3.in$ se afla numere $N, L$ si $U$ separate prin cate un spatiu. Pe cea de a doua linie se vor gasi $N$ numere naturale reprezentand costurile elementelor secventei, iar pe cea de a treia linie se vor gasi $N$ numere naturale reprezentand timpurile elementelor secventei.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie din fisierul de iesire $secv3.out$ se va gasi un numar real cu prezicie de doua zecimale, reprezentand valoarea maxima a sumei costurilor elementelor din secventa impartita la suma timpurilor elementelor din secventa.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; L &le; U &le; N &le; 30.000$\r\n* Costul si timpul unui element sunt numere naturale din intervalul $[1, 1.000]$\r\n* Numarul scris in fisierul de iesire va fi considerat corect doar daca valoarea absoluta a diferentei dintre rezultatul tau si cel al comisiei este mai mica sau egala cu $10^-2^$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. secv3.in |_. secv3.out |\r\n| 5 1 2\r\n1 1 3 2 5\r\n4 2 5 3 6 | 0.83 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"secv3\")==',1,'task: secv3'),('arhiva','Arhiva de probleme','2006-12-11 00:49:58','h1. Arhiva de probleme\r\n\r\nArhiva de probleme infoarena contine peste 300 de probleme. Vezi si \'clasamentul arhivei\':clasament-arhiva.\r\n\r\nh2. Lista de probleme\r\n\r\n==Tasks(round_id=\"arhiva\" score=\"1\") ==\r\n\r\nh2. Ultimele discutii despre arhiva\r\n\r\n== SmfTopics(board_id=\"1\" count=\"10\") ==\r\n',13,'protected'),('preoni-2006/runda-2/solutii','Solutii preONI 2006 - Runda a 2-a','2006-11-25 14:50:40','h1. Solutii preONI 2006 - Runda a 2-a\r\n\r\n(Categoria _Competitii_, autor(i) _Echipa infoarena_)\r\n\r\nRunda a 2-a concursului preONI 2006 s-a incheiat. Acest articol va prezinta solutiile oficiale ale celor 7 probleme propuse.\r\n\r\nFiecare grupa a avut spre rezolvare 3 probleme, fiecare fiind catalogata de catre comisie ca fiind usoara, medie sau grea. Batalia pentru calificarea la finala este in toi!\r\n\r\nPentru mai multe detalii despre finala, cat si despre concursul preONI 2006 si sponsorii nostri va rugam sa consultati pagina \"preONI-2006\":preONI-2006.\r\n\r\nRezultatele finale sunt disponibile la:\r\n\r\n* \"Clasa a 9-a\":preoni-2006/runda-2/clasament-9\r\n* \"Clasa a 10-a\":preoni-2006/runda-2/clasament-10\r\n* \"Clasele 11-12\":preoni-2006/runda-2/clasament-11-12\r\n\r\nDificultatea problemelor nu a lasat nici de aceasta data de dorit. Desi ne-am fi asteptat la punctaje mai mari, rezultatele concurentilor au fost decente. Provocarile oferite de Infoarena sunt intr-adevar dificile, iar obtinerea unui punctaj apropiat de cel maxim nu este usor de realizat. In editiile ce vor urma vom tine cont de acest aspect. Pana atunci va invitam sa discutati despre aceasta runda de concurs pe \"forum-ul infoarena\":http://forum.infoarena.ro/index.php/board,20.0.html.\r\n\r\nCa de obicei, problemele din acest concurs au fost puse si in \"Arhiva de probleme\":arhiva, disponibile pentru rezolvare 24 de ore din 24. Va asteptam cu forte proaspete la runda a 3-a din 21 ianuarie 2006 !!!\r\n\r\nh2. Dame\r\n\r\nh3. (clasa a 9-a problema usoara)\r\n\r\nIn primul rand, numarul maxim de dame este $N$ pentru $N = 1$ si {$N &ge; 4$}, si $N-1$ pentru {$N = 2, 3$}. Putem codifica solutia ca o permutare de la $1$ la {$N$}, astfel asigurand ca nu exista doua dame pe aceeasi linie sau coloana. O solutie clasica care foloseste metoda backtracking si face verificarea daca o dama este atacata sau nu in $O(1)$ va obtine $30$ de puncte.\r\nVerificarea in $O(1)$ se face pastrand doi vectori pentru fiecare diagonala in functie de orientare, in care se marcheaza daca o diagonala este ocupata. O \"imbunatatire\" la backtracking este randomizarea ordinii in care se incearca completarea solutiei la fiecare pas. O astfel\r\nde solutie merge usor si pentru $N = 200$ si ar fi obtinut cel putin $60$ de puncte.\r\nExista mai multe metode prin care s-ar fi putut obtine $100$ de puncte. O solutie greedy este urmatoarea: se incepe cu o solutie oarecare si cat timp exista doua dame care, daca s-ar interschimba coloanele lor, se imbunatateste solutia, se aplica interschibarea. Daca\r\nnu s-a obtinut o solutie buna, se reinitializeaza solutia initiala si se reaplica algoritmul. In practica, complexitatea algoritmului tinde la {$O(N lg N)$}, desi teoretic este {$O(N^3^)$}. De asemenea pe masura ce $N$ este mai mare, numarul necesar de reinitializari ale algoritmului tinde catre {$0$}. Mai multe detalii gasiti \"aici\":http://www.cit.gu.edu.au/~sosic/nqueens.html\r\nO alta solutie , matematica, se bazeaza pe un sablon de construire a solutiei in functie de restul lui $N$ la {$12$}.\r\n\r\n* Se insereaza numerele pare de la $2$ la $N$ intr-o lista\r\n* Daca restul lui $N$ la $12$ este $3$ sau $9$ se muta $2$ la sfarsitul listei\r\n* Se insereaza numerele impare de la $1$ la $N$ in lista\r\n* Daca restul este $8$ se interschimba perechile ({$3 1$}, {$7 5$}, ...)\r\n* Daca restul este $2$ se interschimba $1$ cu $3$ si $5$ se muta la sfarsitul listei\r\n* Daca restul este $3$ sau $9$ se muta $1$ si $3$ la sfarsitul listei\r\n\r\nLista va codifica o solutie cum s-a precizat si inainte, al {$i$}-lea element reprezetand o dama pe randul $i$ si pe coloana {$lista{~i~}$}.\r\nAceasta solutie $O(N)$ este preluata de \"aici\":http://en.wikipedia.org/wiki/Eight_queens_puzzle\r\n\r\nh2. Zota & Chidil\r\n\r\nh3. (clasa a 9-a problema medie)\r\n\r\nO solutie de complexitate $O((M + N)lg N)$ este imediata. Se vor folosi doi vectori, fiecare continand coordonatele punctelor afectate de capcane, mai putin punctul de coordonate ({$0, 0$}), pentru a respecta conditia impusa in enunt. Primul vector $vx$ va fi sortat dupa coordonata {$x$}, iar in caz de egalitate dupa coordonata {$y$}. Al doilea, {$vy$}, va fi sortat dupa $y$ si, in caz de egalitate, dupa {$x$}.\r\n\r\nLa fiecare mutare executata de Chidil (un numar de pasi facut intr-o anume directie) se calculeaza numarul de celule afectate prin care trece. Pentru aceasta se vor aplica doua cautari binare in vectorul corespunzator.\r\n\r\nDaca se deplaseaza inspre $N$ sau {$S$}, cautarea se va face in {$vx$}, altel, in {$vy$}. Diferenta dintre cele doua valori returnate de cautarile binare furnizeaza numarul de celule afectate prin care Chidil trece la acea mutare.\r\n\r\nPentru un timp de executie bun, se recomanda folosirea functiei $sort()$ din STL pentru sortare si a containerului $pair<int, int>$ pentru pastrarea coordonatelor in cei doi vectori.\r\n\r\nh2. Grupuri\r\n\r\nh3. (clasa a 9-a problema grea, clasa a 10-a problema medie)\r\n\r\nO limita superioara pentru numarul de grupuri este $S / K$ unde $S$ reprezinta suma canitatilor de animale. Este evident ca, daca putem construi $X$ grupuri, putem construi si $Y &le; X$ grupuri, fapt care ne duce la ideea sa cautam binar numarul de grupuri. Pentru a verifica daca putem construi un numar de grupuri $X$ ne imaginam completarea unei matrice cu $X$ linii si $K$ coloane, fiecare linie reprezetand un grup. Din restrictiile problemei elementele de pe fiecare linie trebuie sa fie distincte. Vom completa aceasta matrice coloana cu coloana, pentru fiecare cantitate de animale daca este $&le; X$ le punem pe toate in matrice, daca este $> X$ punem doar $X$ in matrice (deoarece daca punem mai multe vor fi cel putin doua pe aceeasi linie). Pentru primul exemplu din enunt, matricea se va completa astfel:\r\n\r\np(pre). {@1 * *    1 2 *    1 2 3    1 2 3@}\r\n{@1 * *    1 2 *    1 2 *    1 2 4@}\r\n{@1 * *    1 * *    1 3 *    1 3 4@}\r\n{@* * *    2 * *    2 3 *    2 3 4@}\r\n\r\nAsadar , daca in final am putut completa toata matricea se pot forma $X$ grupuri. Este evident ca strategia folosita de verificare este optima. Completarea matricei se face doar conceptual, verificarea avand complexitatea $O(N)$ prin parcurgerea vectorului {$A$}, rezultand un algoritm de complexitate {$O(N lg(S/K))$}.Pe baza algoritmului descris mai sus, se poate obtine un algoritm {$O(N)$}, desi acesta n-ar fi fost necesar pentru $100$ de puncte.\r\n\r\nAlgoritmul lucreaza astfel: daca cel mai mare element este $&le; S/K$ , verificarea prezentata mai sus ne garanteaza ca vom putea obtine $S/K$ grupuri, toate elementele fiind $&le; S/K$ se vor folosi toate {$S$}, iar matricea este {$(S/K)*K = S$}. Daca cel mai mare element este $> S$ atunci putem rezolva aceeasi problema recursiv pentru cantitatile existente mai putin cea mai mare si grupuri de marime {$K-1$}. Acest rezultat va fi mai mic sau egal cu cel mai mare element, deci ne va ajunge pentru a completa grupurile la marimea {$K$}. Deoarece canitatile sunt date sortate, complexitatea este {$O(N)$}.\r\n\r\nh2. 1-2 perm\r\n\r\nh3. (clasa a 10-a problema usoara)\r\n\r\nProblema a fost incadrata in categoria usoara deoarece la majoritatea problemelor de acest tip concurentii genereaza cu backtracking valorile pentru primele numere si deduc formula generala. In cazul acesta, formula se putea vedea destul de usor:\r\n\r\n== code(cpp) |T[1] = 1, T[2] = 2, T[3] = 6, T[4] = 12;\r\nT[i] = T[i - 1] + T[i - 3] + 2 * (i - 2)\r\n==\r\n\r\nPentru cei mai curiosi din fire, vom demonstra cum se ajunge la aceasta formula. Fie $A{~i~}$ numarul permutarilor de lungime $i$ care au $1$ pe prima sau ultima pozitie, adica dublul numarului permutarilor care au $1$ pe prima pozitie (exceptie face, ca in toti pasii care vor urma, permutarea de lungime {$1$}). De asemenea, fie $B{~i~}$ numarul permutarilor de lungime $i$ care nu au $1$ pe prima sau ultima pozitie. Evident, {$T{~i~} = A{~i~} + B{~i~}$}. Primele valori sunt\r\n\r\n== code(cpp) |A[1] = 1, B[1] = 0\r\nA[2] = 2, B[2] = 0\r\nA[3] = 4, B[3] = 2\r\nA[4] = 8, B[4] = 4\r\n==\r\n\r\nPentru calculul lui $A$ consideram urmatoarele cazuri:\r\n\r\n# incepem permutarea cu $1, 2$ => avem $A{~i-1~}$ posibilitati\r\n# incepem permutarea cu $1, 3, 2, 4$ => avem $A{~i-3~}$ posibilitati\r\n# incepem permutarea cu $1, 3$ dar nu continuam cu $2$ => vom mai avea o singura posibilitate, de forma ({$1, 3, 5, 7, 9, 8, 6, 4, 2$}). Adica ``urcam\'\' cu numerele impare si ``coboram\'\' cu cele pare pana la {$2$}. Bineinteles, aceasta posibilitate poate fi considerata si in sens invers.\r\nDeci {$A{~i~} = A{~i-1~} + A{~i-3~} + 2$}.\r\n\r\nPentru calculul lui $B$ incepem cu numarul $1$ si observam ca celelalte numere pot fi completate doar alternativ (stanga-dreapta sau dreapta-stanga) pana la un anumit pas, si incepand de pe pozitia la care ne-am oprit, in unul din modurile calculate precedent. Pentru $i = 7$ incepand cu $1$ avem cazurile:\r\n\r\n* ({$3, 1, 2$}) => in continuare A{~5~} moduri\r\n* ({$3, 1, 2, 4$}) => in continuare A{~4~} moduri\r\n* ({$5, 3, 1, 2, 4$}) => in continuare A{~3~} moduri\r\n* ({$5, 3, 1, 2, 4, 6$}) => in continuare A{~2~} moduri\r\n* ({$7, 5, 3, 1, 2, 4, 6$}) => in continuare A{~1~} moduri\r\n\r\nObservam ca valorile calculate precedent in $A$ sunt de fapt dublul celor de care avem noi nevoie, dar considerand si modul invers de completare alternativa, rezultatul obtinut va fi cel corect.\r\nDeci {$B{~i~} = A{~i-2~} + A{~i-3~} + ... + A{~1~}$}, adica {$B{~i~} = B{~i-1~} + A{~i-2~}$}.\r\n\r\nAm ajuns la urmatoarele 2 siruri recurente:\r\n\r\n* $A{~i~} = A{~i-1~} + A{~i-3~} + 2$\r\n* $B{~i~} = B{~i-1~} + A{~i-2~}$\r\n\r\nMai facem urmatoarea observatie: {$A{~i~} - B{~i-1~} = (A{~i-1~} + A{~i-3~} + 2) - (B{~i-2~} + A{~i-3~}) = A{~i-1~} - B{~i-2~} + 2$}, ceea ce inseamna ca {$A{~i~} - B{~i-1~} = 2 * (i - 1)$} (demonstratie prin inductie, tinand cont de faptul ca {$A{~2~} + B{~1~} = 2$}).\r\n\r\nIn sfarsit, sa calculam sirul {$T{~i~} = A{~i~} + B{~i~}$}.\r\n{$T{~i~} = A{~i~} + B{~i~} = A{~i-1~} + A{~i-3~} + 2 + B{~i-1~} + A{~i-2~} = (A{~i-1~} + A{~i-3~}) + (B{~i-1~} + B{~i-3~}) + (A{~i-2~} - B{~i-3~}) + 2 = T{~i-1~} + T{~i-3~} + (A{~i-2~} - B{~i-3~}) + 2$}. Dupa cum am observat mai devreme $A{~i-2~} - B{~i-3~} = 2 * (i - 3)$ => {$T{~i~} = T{~i-1~} + T{~i-3~} + 2 * (i - 2)$}, ceea ce ne propusesem sa demonstram.\r\n\r\nPunctajele se obtin in modul urmator:\r\n\r\n* $O(N^2^)$ timp, $O(N)$ memorie ~ $50%$\r\n* $O(N)$ timp, $O(N)$ memorie ~ $70%$\r\n* $O(N)$ timp, $O(1)$ memorie ~ $90-100%$\r\n\r\nh2. Desc\r\n\r\nh3. (clasa a 10-a problema grea, clasele 11-12 problema usoara)\r\n\r\nO observatie evidenta ar fi faptul ca in cadrul produsului nu vor aparea decat divizorii lui {$N$}. De aceea vom creea vectorul $dvz$ care contine toti cei $D$ divizori ai lui N. In continuare se va construi matricea {$A$}, unde elementul {$A{~i,j~}$}  va retine numarul de posibilitati de a obtine divizorul {$i$}, folosind divizorii {$j$}, {$j+1$}, ..., $D$. Aceasta se va construi in ordine descrescatoare a coloanelor. Initial $A{~i,j~}= A{~i,j+1~}$  deoarce se vor folosi aceleasi moduri de descompunere folosind divizorii {$j+1$}, {$j+2$}, ..., {$D$}, apoi vom lua in considerare cazul in care se foloseste divizorul {$j$}. Pentru asta trebuie ca {$dvz{~j~}$}  sa divida pe {$dvz{~i~}$}, iar in acest caz vom adauga la $A{~i,j~}$  pe $A{~X,j~}$  unde $X$  este indicele divizoului {$dvz{~i~}/dvz{~j~}$}. Procesarea unei coloane trebuie sa se faca crescator deoarece {$X < i$}. Cautarea lui X se poate face fie binar, dar daca ne uitam mai atent vom observa ca valorile lui {$X$} sunt crescatoare deci putem continua cautarea liniar de la pasul la care ne oprisem pentru {$i-1$}. Acest lucru va asigura o complexitate totala {$O(D)$} pentru fiecare coloana a matricii. Complexitatea totala rezultand {$O(D^2^)$}. Singura initializare care trebuie facuta va fi {$A{~0,i~} = 1$} pentru {$1 &#8804; i &#8804; D$} deoarce se considera ca se poate obtine produsul $1$ intr-un singur mod, iar rezultatul se va gasi in {$A{~D,1~}$}.\r\n\r\nPentru a gasi cea de a {$K$}-a descompunere a lui $N$ ne vom folosi de aceasta matrice. Incercam pe rand sa punem fiecare divizor pe prima pozitie. Cand punem divizorul $i$ pe prima pozitie vom avea $A{~X,i~}$ posibilitati unde $X$ reprezinta indicele divizorului {$N/dvz{~i~}$}. Daca numarul acestor posibilitati este mai mic strict decat $K$ se va scadea acest numar din $K$ deoarece toate descompunerile care incep cu $dvz{~i~}$ sunt mai mici lexicografic decat varianta cautata de noi. Daca numarul acestor posibilitati este mai mare sau egal cu $K$ atunci descompunerea cautata de noi incepe cu {$dvz{~i~}$} si vom cauta in continuare a {$K$}-a descompunere pentru $N/dvz{~i~}$ folosind insa divizori mai mari decat {$dvz{~i~}$}. \r\n\r\nh2. Struti\r\n\r\nh3. (clasele 11-12 problema medie)\r\n\r\nVom incerca sa rezolvam fiecare oferta in {$O(M*N)$}, complexitatea finala a algoritmului fiind astfel {$O(P*M*N)$}. Matricea de altitudini o vom nota cu mat. Intai vom determina maximul pe portiuni dreptunghiulare de forma [{$i,j$}]-[{$i+DX-1,j+DY-1$}], iar apoi, prin aceeasi metoda vom afla si minimul. Pentru a afla maximul pe astfel de portiuni, vom nota cu {$MAX{~i,j~} = max{mat{~i,j~}, mat{~i+1,j~} ... mat{~i+DX-1,j~}}$}. Pentru fiecare coloana, vom utiliza o stiva sortata crescator dupa linii si descrescator dupa valoare altitudinilor. Stiva va retine elemente situate pe pozitii intre $i$ si {$i+DX-1$}, cu altitudinile sortate descrescator.\r\n\r\nDaca avem stiva construita la linia {$i$}, atunci pentru linia urmatoare vom scoate primul element din stiva doar daca pozitia pe care se afla este mai mica sau egala cu {$i$}, iar elementul curent il vom introduce pentru a mentine stiva ordonata. Complexitatea acestui pas este {$O(M*N)$}, pe fiecare coloana efectuandu-se $O(M)$ operatii, pentru ca fiecare element este introdus si scos din stiva exact o data. Pentru a afla maximul intregii portiuni dreptunghiulare, aplicam acelasi procedeu, notand: {$MAX2{~i,j~} = max{MAX{~i,j~}, MAX{~i,j+1~} ... MAX{~i,j+DY-1~}}$}.\r\n\r\nPentru a afla si minimul pe portiuni se procedeaza similar.\r\n\r\nIn plus, pentru o oferta vom procesa atat perechea ({$DX, DY$}), cat si ({$DY, DX$}), daca si numai\r\ndaca {$DX$} diferit de {$DY$}. Altfel, vom proceda doar ({$DX, DY$}).\r\n\r\n\r\n\r\nh2. Camera\r\n\r\nh3. (clasele 11-12 problema grea)\r\n\r\nProblema pare la prima vedere destul de complicata. O solutie posibila ar fi sa pornim cu poligonul initial si sa il intersectam cu cate o dreapta determinata de fiecare din laturile lui. Aceasta rezolvare ar putea parea destul de complicata pentru ca implica intersectii de drepte cu poligoane concave. Zona din care toate laturile poligonului sunt vizibile este cunoscuta sub numele de nucleu sau kernel in engleza. Pentru ca dintr-un punct sa fie vizibila o latura a poligonului, acest punct trebuie sa fie in semiplanul determinat de aceasta latura. De aici deducem ca nucleul poligonului este de fapt intersectia celor $N$ semiplane determinate de laturile poligonului. Pornim la inceput cu o zona patrata care contine toate punctele poligonului, astfel ea va contine si nucleul poligonului. Vom taia pe rand cu semiplane acest patrat. Poligonul intermediar va fi tot timpul convex, ceea ce ne usureaza cu mult rezolvarea. Vedem in urmatoarea imagine un exemplu al pasilor algoritmului:\r\n\r\n!preoni-2006/runda-2/solutii?nucleu1.jpg!\r\n\r\nParcurgem laturile poligonului intr-o ordine oarecare. Vom avea doi pointeri $cur$ si $next$ care vor reprezenta doua varfuri consecutive de pe poligonul care e solutia curenta. Daca ambele puncte sunt in interiorul semiplanului, atunci solutiei urmatoare ii adaugam punctul urmator. Daca punctul curent e in interior si punctul urmator este in exterior atunci solutiei ii adaugam punctul de intersectie {$p$}. Daca ambele puncte sunt in exterior procesam urmatoarea pereche. Daca punctul curent e in exterior si urmatorul punct este in interior atunci solutiei ii adaugam punctul de intersectie $p$ si punctul urmator. Astfel obtinem un algoritm de complexitate {$O(n^2^)$}. Mentionam ca acest algoritm poate fi folosit si la determinarea intersectiei a doua poligoane convexe.\r\n\r\n!preoni-2006/runda-2/solutii?nucleu2.jpg!\r\n\r\n',1,'public'),('problema/12perm','12-Perm','2006-12-05 22:39:56','==Include(page=\"template/taskheader\" task_id=\"12perm\")==\r\n\r\nSe defineste 12-permutarea $A{~1~},A{~2~},...,A{~N~}$ ca fiind o permutare a numerelor $1,2,...,N$ astfel incat $|A{~i~} - A{~i+1~}|<3$ pentru $i=1,2,...,N-1$.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un numar natural $N$ calculati numarul de 12-permutari de lungime $N$.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $12perm.in$ contine numarul natural $N$ cu semnificatia de mai sus.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $12perm.out$ veti afisa $X$ numarul de 12-permutari de lungime $N$ modulo $1048576$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 15.000.000$\r\n* $1048576 = 2^20^$\r\n* Pentru $70%$ din teste $N &le; 5.500.000$.\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. 12perm.in |_. 12perm.out |\r\n| 4 | 12 |\r\n\r\n\r\n\r\n\r\nh3. Explicatii\r\n\r\nCele $12$ 12-permutari sunt: $1 2 3 4, 1 2 4 3, 1 3 2 4, 1 3 4 2, 2 1 3 4, 2 4 3 1, 3 1 2 4, 3 4 2 1, 4 2 1 3, 4 2 3 1, 4 3 1 2, 4 3 2 1$\r\n==Include(page=\"template/taskfooter\" task_id=\"12perm\")==',75,'task: 12perm'),('problema/barbar','Barbar','2006-11-12 16:29:05','==Include(page=\"template/taskheader\" task_id=\"barbar\")==\r\n\r\nPaftenie barbarul este un renumit aventurier. A condus razboaie, a descoperit comori, a cucerit cetati si inimile domnitelor. Insa de aceasta data a fost capturat de catre dusmanii sai cei mai temuti si aruncat intr-o temnita. Temnita este de fapt un grid de dimensiune {$R*C$}. In anumite celule exista dragoni, unele sunt ocupate de pereti, iar altele sunt libere. Paftenie trebuie sa iasa din temnita mergand numai prin celule libere (o celula are maxim 4 vecini) , si asta stand cat mai departe de fiorosii dragoni ale caror flacari ii pot deteriora vestimentatia (astfel incat minima din distantele pana la cel mai apropiat dragon din fiecare din celulele traseului sau sa fie maxim).\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe barbarul Paftenie sa iasa din temnita, determinand un traseu astfel incat minima din distantele pana la cel mai apropiat dragon din fiecare din celulele traseului sau sa fie maxim!\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $barbar.in$ sunt date doua numere intregi $R$ si {$C$}, reprezentand numarul liniilor, respectiv al coloanelor temnitei. Pe urmatoarele $R$ linii se afla cate $C$ caractere, neseparate prin spatii, cu urmatoarele semnificatii:\r\n$.$ celula libera\r\n$*$ perete\r\n$D$ dragon\r\n$I$ punctul de plecare al lui Paftenie\r\n$O$ iesirea din temnita\r\n\r\nh2. Date de Iesire \r\n\r\nFisierul de iesire $barbar.out$ va contine pe prima linie un singur numar, reprezentand valoarea maxima pentru minima din distantele pana la cel mai apropiat dragon din fiecare din celulele traseului. In caz ca nu exista solutie se va afisa {$-1$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; R, C &le; 1.000$\r\n* Se garanteaza ca in temnita exista cel putin un dragon\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. barbar.in |_. barbar.out |\r\n| 10 10\r\n..........\r\n.I....D...\r\n..........\r\n..D...D...\r\n.*........\r\nD*........\r\n*...D.....\r\n..****....\r\n...O......\r\n..........\r\n| 2 | \r\n\r\nh3. Explicatii\r\n\r\nO solutie posibila:\r\n$..........$\r\n$.I{*ooo*}.D...$\r\n$....{*o*}.....$\r\n$..D.{*o*}.D...$\r\n$.*..{*oo*}....$\r\n$D*...{*ooooo*}$\r\n${@*@}...D....{*o*}$\r\n$..****...{*o*}$\r\n$...O{*oooooo*}$\r\n$..........$\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"barbar\")==',961,'task: barbar'),('problema/alpin','Alpin','2006-11-11 14:48:13','==Include(page=\"template/taskheader\" task_id=\"alpin\")==\r\n\r\nUn alpinist se afla intr-o regiune muntoasa codificata sub forma unei matrici patratice de dimensiune $N$, fiecare element al matricii reprezentand altitudinea respectivei portiuni de teren. Alpinistul isi poate porni traseul din orice punct al regiunii ( deci de la oricare dintre elementele matricii ) si poate termina acest traseu oriunde. El poate merge pe oricare din directiile {N, S, E, V} cu conditia sa nu paraseasca regiunea. In plus, trebuie sa urce in permanenta, sau, altfel spus, altitudinea regiunii curente sa fie strict mai mica decat altitudinea regiunii urmatoare de pe traseu.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine cel mai lung traseu pe care il poate face alpinistul.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $alpin.in$ se va afla numarul $N$, dimensiunea regiunii. Urmatoarele $N$ linii contin cate $N$ numere naturale pozitive separate prin exact un spatiu, descriind codificarea matriceala a regiunii.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a sa, fisierul de iesire $alpin.out$ va contine $LMAX$, lungimea maxima a traseului parcurs. Urmeaza $LMAX$ linii, descriind traseul urmat prin casutele sale, in ordine, de la prima la ultima, inclusiv.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 1024$\r\n* Altitudinea maxima nu depaseste $16.384$\r\n* Daca exista mai multe solutii de lungime maxima, se va afisa oricare dintre ele\r\n* Daca determinati corect doar lungimea maxima, veti primi $50%$ din punctajul pe testul respectiv\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. alpin.in |_. alpin.out |\r\n| 6\r\n29 10 8 9 8 10\r\n22 11 7 3 7 20\r\n17 15 3 14 45 30\r\n19 5 2 41 19 17\r\n23 8 90 39 20 18\r\n27 30 32 35 70 19\r\n| 16\r\n4 3\r\n3 3\r\n2 3\r\n1 3\r\n1 2\r\n2 2\r\n3 2\r\n3 1\r\n4 1\r\n5 1\r\n6 1\r\n6 2\r\n6 3\r\n6 4\r\n5 4\r\n4 4 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"alpin\")==',961,'task: alpin'),('problema/arbfind','Arbfind','2006-11-24 15:57:28','==Include(page=\"template/taskheader\" task_id=\"arbfind\")==\r\n\r\nSe numeste arbore cu radacina o structura care contine un nod special denumit radacina arborelui si $A{~1~}, A{~2~}, ..., A{~n~}$ (unde $n &ge; 0$) arbori cu radacina (denumiti subarbori ai radacinii). Nodul radacina al fiecarui arbore $A{~i~}$ este denumit fiu al radacinii arborelui si este conectat printr-o muchie de radacina arborelui.\r\n\r\nDoi arbori cu radacina sunt identici daca radacinile celor doi au acelasi numar de subarbori si acestia sunt identici (mai exact, pentru orice $i=1, 2, ..., n$ subarborele $i$ al primului este identic cu subarborele $i$ al celui de-al doilea).\r\n\r\nO termita poate \"ciopli\" un arbore actionand astfel:\r\n1. termita porneste de la radacina arborelui;\r\n2. la fiecare moment (in orice nod s-ar afla), termita poate face una dintre urmatoarele operatii:\r\n\r\n* sta in nod si mananca cea mai din dreapta muchie, eliminand astfel cel mai din dreapta fiu si subarborele corespunzator (acestea cad si vor fi mancate de alte termite lenese);\r\n* inainteaza pe muchia din dreapta, spre fiul ramas cel mai din dreapta al nodului in care se afla;\r\n* se opreste\r\n\r\nDoua termite prietene aleg doi arbori si ii cioplesc in modul descris pana cand obtin doi arbori identici. Similaritatea dintre doi arbori este egala cu numarul maxim de noduri care raman in fiecare dintre cei doi arbori identici obtinuti prin cioplire.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se doi arbori (un arbore model si un arbore de evaluat) sa se calculeze pentru fiecare nod al arborelui de evaluat similaritatea dintre subarborele cu radacina in nodul respectiv si arborele model dat.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $arbfind.in$ se gaseste un numar natural $N$ reprezentand numarul de noduri din arborele model, nodurile fiind numerotate de la $1$ la $N$. Pe liniile $2..N+1$ se va afla descrierea arborelui model. Mai exact, pe linia $i$ se va afla un numar natural $F{~i-1~}$ reprezentand numarul de fii directi ai nodului $i-1$, urmat de $F ~i-1~$ numere naturale cuprinse intre $1$ si $N$, reprezentand in ordinea de la stanga la dreapta fiii nodului $i-1$.\r\n\r\nLinia $N+2$ va contine un numar natural $M$ reprezentand numarul de noduri din arborele de evaluat. Liniile $N+3..N+M+2$ vor contine descrierea arborelui de evaluat, in mod analog cu descrierea arborelui model.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $arbfind.out$ va contine $M$ linii. Pe linia $i$ se va afla similaritatea subarborelui cu radacina in nodul $i$ fata de arborele model.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Radacina arborilor este intotdeauna nodul $1$.\r\n* $1 &le; M, N &le; 32000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. arbfind.in |_. arbfind.out |\r\n| 4\r\n2 2 3\r\n1 4\r\n0\r\n0\r\n9\r\n2 2 3\r\n2 4 5\r\n2 6 7\r\n1 8\r\n0\r\n0\r\n1 9\r\n0\r\n0\r\n| 3\r\n4\r\n2\r\n2\r\n1\r\n1\r\n2\r\n1\r\n1\r\n|\r\n\r\nh3. Explicatii\r\n\r\n!problema/arbfind?arbfind.jpg!\r\n\r\nDe exemplu, pentru nodul 1 din arborele model s-au eliminat n ordine subarborii cu radacinile 3, 5 si 8. Din arborele model se elimina subarborele cu radacina 3.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"arbfind\")==',1142,'task: arbfind'),('problema/banana','Banana','2006-11-12 17:06:40','==Include(page=\"template/taskheader\" task_id=\"banana\")==\r\n\r\nSe considera o padure tropicala, reprezentata sub forma unui caroiaj dreptunghiular. Celula din coltul stanga sus al caroiajului are coordonatele $(1, 1)$, iar coordonatele celorlalte celule sunt determinate de linia si coloana pe care se afla. In anumite celule ale caroiajului sunt plasati bananieri; o celula contine cel mult un bananier. Mai multi bananieri care se invecineaza pe orizontala sau verticala formeaza o zona de bananieri. Intr-o astfel de zona, CEKILI se deplaseaza usor, cu agilitatea-i cunoscuta, de la un bananier la altul.\r\n\r\nMaimuta CEKILI este lacoma si nu ii ajung bananele dintr-o singura zona. Tarzan vrea sa-si ajute prietena. Pentru aceasta, el ar putea conecta exact $K$ zone de bananieri innodand mai multe liane si astfel CEKILI s-ar putea deplasa de la o zona la alta utilizand lianele. Evident, Tarzan trebuie sa aleaga zonele astfel incat numarul total de bananieri din cele $K$ zone sa fie maxim.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul maxim de bananieri care se poate obtine prin conectarea a exact $K$ zone.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $banana.in$ contine:\r\n\r\ntable(example). | Nr K\r\nx{~1~} y{~1~}\r\nx{~2~} y{~2~}\r\n...\r\nx{~Nr~} y{~Nr~}\r\n| Nr - numarul de bananieri \r\n  K&nbsp; - numarul de zone ce pot fi conectate\r\n  x{~i~} - linia pe care se afla bananierul i\r\n  y{~i~} - coloana pe care se afla bananierul i |\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $banana.out$ va contine pe prima linie numarul maxim de bananieri care se poate obtine prin conectarea zonelor.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; Nr &le; 16 000$\r\n* $1 &le; x{~i~}, y{~i~} &le; 10 000, i &isin; {1,2,...,Nr}$\r\n* in testele utilizate $K$ nu va depasi numarul de zone\r\n* doua pozitii se invecineaza pe orizontala daca sunt pe aceeasi linie si pe coloane consecutive, respectiv pe verticala daca sunt pe aceeasi coloana si pe linii consecutive\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. banana.in |_. banana.out |\r\n| 10 3\r\n7 10\r\n1 1\r\n101 1\r\n2 2\r\n102 1\r\n7 11\r\n200 202\r\n2 1\r\n3 2\r\n103 1 \r\n| 9 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"banana\")==',18,'task: banana'),('problema/zc','Zota & Chidil','2006-11-12 16:37:08','==Include(page=\"template/taskheader\" task_id=\"zc\")==\r\n\r\nZota si Chidil s-au certat. De aceasta data, Zota, dorind sa se razbune, planuieste sa insire o serie de capcane in padurea prin care Chidil obisnuieste sa se plimbe. Astfel, folosind o formula magica, el asterne o capcana in mai multe celule ale padurii. Toate celulele care se afla la o distanta Manhattan mai mica sau egala cu _2_ de capcana sunt si ele afectatate.\r\nIn imaginea de mai jos capcana este reprezentata prin $O$ iar celelalte celule afectate sunt marcate cu $X$.\r\n\r\n$.......$\r\n$...X...$\r\n$..XXX..$\r\n$.XXOXX.$\r\n$..XXX..$\r\n$...X...$\r\n$.......$\r\n\r\nChidil isi planifica intotdeauna traseul. El porneste intotdeauna din celula cu coordonate (0, 0). Drumul lui este descris printr-o pereche ({$D$}, {$x$}) unde D apartine multimii {$N$, $E$, $S$, $V$}, iar $x$ este un numar natural nenul. Aceasta inseamna ca din pozitia in care se afla, va face $x$ pasi in directia $D$.\r\nDesi afla de planul malefic al lui Zota, Chidil nu vrea sa isi schimbe traseul cu nici un chip. Prefera sa afle cate celule din traseul lui contin capcane sau sunt afectate de capcane, pentru a sti exact cat praf magic pentru neutralizarea celulelor sa ia la el.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Chidil sa afle raspunsul!\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $zc.in$ se afla doua numere naturale $N$ si $M$, reprezentand numarul de capcane intinse de Zota, respectiv numarul de perechi ({$D$}, $x$) conform carora Chidil urmeaza sa se deplaseze.\r\n\r\nLiniile $2 .. N+1$ contin cate o pereche de numere ({$x$} {$y$}), ce reprezinta coordonatele capcanelor.\r\n\r\nLiniile $N+2 .. N+M+1$ contin cate o pereche de forma $D$, $x$, cu semnificatia ca Chidil face $x$ pasi in directia $D$.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $zc.out$ va contine pe prima linie numarul de celule periculoase care trebuie neutralizate de Chidil in drumul sau.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 100 000$\r\n* Coordonatele lui Chidil nu vor iesi niciodata din intervalul [$-2 000 000 000$, $2 000 000 000$]\r\n* Chiar daca celula de pornire a lui Chidil contine sau este afectata de o capcana, nu este nevoie de praf magic pentru a o neutraliza\r\n* Desi o celula poate fi afectata de mai multe capcane, este nevoie de o singura unitate de praf magic pentru a o neutraliza\r\n* Efectul prafului magic este temporar; de fiecare data cand Chidil trece printr-o celula afectata, are nevoie de praf magic pt a o neutraliza\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. zc.in |_. zc.out |\r\n| 2 8 \r\n5 6 \r\n12 10 \r\nN 3 \r\nE 6 \r\nN 7 \r\nE 2 \r\nS 3 \r\nE 6 \r\nN 6 \r\nV 3\r\n| 4 |\r\n\r\nh3. Explicatii\r\n\r\n$...........####............$\r\n$............X.#............$\r\n$...........XXX#............$\r\n$......###.XXOX{%{color:red}#%}............$\r\n$......#.#..XXX#............$\r\n$.....X#.#...X.#............$ \r\n$....XX{%{color:red}#%}.#######............$\r\n$...XXO{%{color:red}#%}X...................$\r\n$....XX{%{color:red}#%}....................$\r\n$.....X#....................$\r\n$#######....................$\r\n$#..........................$\r\n$#..........................$\r\n$#..........................$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"zc\")==',961,'task: zc'),('problema/traseu','Traseu','2006-11-12 16:01:32','==Include(page=\"template/taskheader\" task_id=\"traseu\")==\r\n\r\nGigel s-a mutat intr-un oras nou! Pentru a se familiariza cu noile imprejurimi a cumparat harta orasului si a observat ca este alcatuita din $M$ strazi de diferite lungimi, cu sens unic si $N$ intersectii de strazi. Gigel a luat harta si a inceput sa alcauiasca un traseu care porneste dintr-o intersectie anume, trece prin fiecare strada cel putin o data, si revine in intersectia de unde a pornit. Desi dorinta lui de explorare este mare, conditia lui fizica nu este tocmai buna, astfel ca vrea sa gasesasca un traseu in care suma lungimilor strazilor parcurse este minima.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care gaseste un traseu de lungime minima in orasul lui Gigel.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $traseu.in$ se gasesc numerele $N$ si $M$ separate prin cate un spatiu. Pe urmatoarele $M$ linii se vor gasi triplete de numere $i j k$ cu semnificatia ca exista o strada de la intersectia cu numar $i$ la intersectia cu numar $j$ de lungime $k$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie din fisierul $traseu.out$ se va afisa un singur numar natural reprezentand lungimea minima a traseului lui Gigel.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 60$\r\n* Lungimile strazilor sunt numere naturale din intervalul $[1, 10 000]$\r\n* Daca intre doua intersectii $i$ si $j$ exista o strada, atunci cu singuranta nu va exista o strada si intre intersectiile $j$ si $i$\r\n* Se garanteaza ca exista cel putin un traseu in oras care trece prin fiecare strada cel putin o data si incepe si se termina in aceeasi intersectie\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. traseu.in |_. traseu.out |\r\n|6 8\r\n1 2 3\r\n2 3 1\r\n3 1 2\r\n1 4 4\r\n4 6 2 \r\n6 1 5\r\n4 5 1\r\n5 1 6\r\n|28 |\r\n\r\nh3. Explicatii\r\n\r\nTraseul ales este: $(1,2,3,1,4,6,1,4,5,1)$.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"traseu\")==',13,'task: traseu'),('problema/numere2','Numere 2','2006-11-12 16:13:11','==Include(page=\"template/taskheader\" task_id=\"numere2\")==\r\n\r\nDanut a invatat la scoala la ora de matematica despre numere prime. Acum el vrea sa dezvolte un algoritm eficient de verificare a primalitatii. Avand un numar natural $P$, el stie ca $P$ nu este prim daca exista numerele naturale $A$ si $B$ astfel incat $A$ ridicat la puterea $B$ este egal cu $P$ si $B$ este mai mare ca $1$. Danut ar vrea sa stie care este cel mai mic $A$ pentru care exista un numar $B$ astfel incit $A^B^=P$.\r\n\r\nh2. Cerinta\r\n\r\nFiind dat numarul $P$, aflati $A$ si B astfel incit $A^B^=P$.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul $numere2.in$ se afla pe prima linie scris numarul $P$ fara spatii intre cifre.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $numere2.out$ va contine pe prima linie numarul $A$, iar pe a doua linie numarul $B$. Numerele vor fi afisate fara spatii intre cifre.\r\n\r\nh2. Restrictii\r\n\r\n* $0 < P < 10^100^$ (adica $P$ are cel mult $100$ cifre)\r\n* pentru $50%$ din teste $0 < P < 10^9^$\r\n* $A$ trebuie sa fie minim\r\n* $B$ poate fi egal cu $1$\r\n* $A, B, P$ sunt numere intregi pozitive\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. numere2.in |_. numere2.out |\r\n| 81\r\n| 3\r\n  4 |\r\n| 17\r\n| 17\r\n  1 |\r\n| 9904578032905937\r\n| 17\r\n  13 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"numere2\")==',15,'task: numere2'),('problema/lacate','Lacate','2006-11-12 01:10:29','==Include(page=\"template/taskheader\" task_id=\"lacate\")==\r\n\r\n\r\nPentru a pazi subiectele de la concursul preONI, comisia care a propus problemele, formata din $N$ persoane, s-a gandit sa pastreze subiectele intr-un seif. Pentru inchiderea seifului sunt necesare un anumit numar de lacate, pentru fiecare lacat existand un anumit numar de chei care-l pot deschide. Distributia cheilor printre membrii comisiei trebuie sa respecte urmatoarele conditii:\r\n\r\n* oricare doi membri detin acelasi numar de chei\r\n* fiecare membru detine chei de la lacate distincte\r\n* toate lacatele seifului se vor putea deschide numai in prezenta oricarui grup format din cel putin $N-1$ membrii\r\n\r\nh2. Cerinta\r\n\r\nStiind ca nici o cheie nu poate deschide doua lacate distincte, determinati numarul minim de lacate necesare, precum si o distributie a cheilor care sa respecte conditiile de mai sus.\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul de intrare $lacate.in$ se va gasi numarul natural $N$, reprezentand numarul membrilor comisiei.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie din fisierul $lacate.out$ se va gasi doua numere naturale $L$ si $C$ reprezentand numarul minim de lacate necesare, respectiv numarul de chei pe care le va avea fiecare membru. Pe urmatoarele $N$ linii se vor gasi cheile pe care le detine fiecare membru, astfel incat pe linia $i+1$ se vor gasi $C$ numere reprezentand cheile pe care le detine membrul $i$; cheile sunt numerotate cu numere de la $1$ la $L$, fiecare numar reprezentand numarul lacatului pe care il deschide cheia respectiva.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 256$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. lacate.in |_. lacate.out |\r\n| 2\r\n| 1 1\r\n1\r\n1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"lacate\")==',15,'task: lacate'),('problema/bool','Bool','2006-11-12 16:42:26','==Include(page=\"template/taskheader\" task_id=\"bool\")==\r\n\r\nHaralambie a primit la scoala o tema destul de dificila. El trebuie sa evalueze o expresie logica. Aceasta expresie contine variabile (litere mari ale alfabetului englez de la $A$ la $Z$), constante ({$TRUE$} si {$FALSE$}), paranteze rotunde {$($} si {$)$}, si operatorii logici $NOT$, $AND$ si $OR$. $NOT$ are prioritatea cea mai mare, $OR$ are prioritatea cea mai mica. Initial toate variabilele au valoarea $FALSE$. Lui Haralambie ii place sa evalueze expresii, dar variabilele isi mai schimba uneori valoarea si expresia trebuie reevaluata. Speriat din aceasta cauza, a decis sa apeleze la ajutorul vostru!\r\n\r\nDupa cum este mentionat mai sus o expresie logica este definita in unul din modurile urmatoare:\r\n\r\ntable. |_. expresie |_. explicatie |\r\n| $TRUE$ | $&nbsp;$ |\r\n| $FALSE$ | $&nbsp;$ |\r\n| $c$     |  $c - litera mare a alfabetului englez$ |\r\n| $(e)$   |  $e - expresie logica$ |\r\n| $NOT e$ |  $e - expresie logica$ |\r\n| $e1 AND e2$ | $e1 si e2 - expresii logice$ |\r\n| $e1 OR e2$ | $e1 si e2 - expresii logice$ |\r\n\r\nh2. Cerinta\r\n\r\nSe da expresia ce trebuie evaluata si modificarile ce apar la valorile variabilelor. Pentru fiecare modificare de variabila trebuie reevaluata expresia si afisat rezultatul ({$1$} pentru adevarat si $0$ pentru fals).\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $bool.in$ este scrisa expresia logica definita ca mai sus. Pe a doua linie este dat numarul $N$ de modificari ale variabilelor. Pe linia a treia sunt date $N$ caractere intre $A$ si $Z$, reprezentand variabilele a caror valoare este modificata.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $bool.out$ va contine o singura linie de lungime $N$. Pentru fiecare modificare de variabila se va afisa un caracter reprezentand valoarea logica a expresiei: $1$ pentru adevarat si $0$ pentru fals.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100$\r\n* $1 &le; Lungime expresiei &le; 1.000$\r\n* Toate literele care apar in expresie vor fi majuscule\r\n* Nu va exista mai mult de un spatiu intre doua caractere din expresie\r\n* O variabila care are valoarea $TRUE$ isi schimba valoarea in $FALSE$, iar o variabila $FALSE$ se schimba in $TRUE$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bool.in |_. bool.out |\r\n| A AND ((B OR NOT C) OR ((TRUE)))\r\n4\r\nABCA\r\n| 1110 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bool\")==',961,'task: bool'),('problema/zeap','Zeap','2006-11-11 16:50:29','==Include(page=\"template/taskheader\" task_id=\"zeap\")==\r\n\r\nDesi putini stiu, una din marile pasiuni ale lui Zaharel sunt structurile de date. Intr-o zi de vara, rasfoind diverse cursuri de structuri de date, Zaharel s-a decis sa inventeze propria lui structura pe care a numit-o zeap. In conceptia lui Zaharel, un zeap mentine o multime de numere naturale distincte si suporta urmatoarele operatii intr-un timp eficient:\r\n\r\n* **INSEREAZA{@(Z,x)@}**: se insereaza elementul $x$ in zeap-ul $Z$; daca $x$ exista deja in zeap se ignora operatia; aceasta operatie nu returneaza nimic;\r\n\r\n* **STERGE{@(Z,x)@}**: se sterge elementul $x$ din zeap-ul $Z$; in cazul in care elementul nu exista in zeap, operatia returneaza -1;\r\n\r\n* **CAUTA{@(Z,x)@}**: se cauta elementul $x$ in zeap-ul $Z$; se returneaza 0 daca elementul nu exista sau 1 daca exista;\r\n\r\n* **MAX-DIF{@(Z)@}**: returneaza diferenta in modul maxima dintre oricare doua elemente distincte din zeap-ul $Z$; daca nu exista cel putin doua elemente in zeap se returneaza -1;\r\n\r\n* **MIN-DIF{@(Z)@}**: returneaza diferenta in modul minima dintre oricare doua elemente distincte din zeap-ul Z; daca nu exista cel putin doua elemente in zeap se returneaza -1;\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa simuleze comportamentul unui zeap.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $zeap.in$ va contine pe fiecare linie descrierea unei operatii:\r\n\r\n**I x**: se efectueaza operatia **INSEREAZA{@(Z,x)@}**\r\n\r\n**S x**: se efectueaza operatia **STERGE{@(Z,x)@}**\r\n\r\n**C x**: se efectueaza operatia **CAUTA{@(Z,x)@}**\r\n\r\n**MAX**: se efectueaza operatia **MAX-DIF{@(Z)@}**\r\n\r\n**MIN**: se efectueaza operatia **MIN-DIF{@(Z)@}**\r\n\r\nh2. Date de iesire\r\n\r\nPentru fiecare operatie care returneaza o valoare se va afisa rezultatul respectiv pe cate o linie in fisierul de iesire $zeap.out$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Fisierul de intare va contine maxim $300 000$ linii\r\n\r\n* Numerele care se vor insera in zeap vor fi numere naturale din intervalul $[1...10^9]$\r\n\r\n* Se recomanda folosirea functiilor gets/fgets pentru cei ce programeaza in C/C++ datorita volumului mare de date de intrare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. zeap.in |_. zeap.out |\r\n|I 1\r\nI 3\r\nS 2\r\nI 7\r\nMAX\r\nMIN\r\nC 5\r\nC 1\r\nS 3\r\nMAX \r\nMIN\r\n|-1\r\n6\r\n2\r\n0\r\n1\r\n6\r\n6|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"zeap\")==',256,'task: zeap'),('problema/party','Party','2007-01-03 12:12:18','==Include(page=\"template/taskheader\" task_id=\"party\")==\r\n\r\nGeorge vrea sa isi organizeze majoratul, si vrea ca petrecerea sa fie de neuitat, mancarea, bautura, locatia si sonorizarea sunt deja asigurate, si mai ramane problema chemarii prietenilor. El si cu prietenul lui cel mai bun Lucian au preferinte diferite si pentru a nu se certa au pus la punct o lista de cerinte care vor trebui sa fie indeplinite toate astfel incat cheful sa se desfasoare in cele mai bune conditii! Pentru usurinta, prietenii lui George vor fi indentificati prin numere intregi de la $1$ la $N$ si cerintele vor fi de tipurile $0, 1, 2$ sau $3$.\r\nO cerinta de genul $x y 0$ are semnificatia ca $x$ sau $y$ trebuie sa participle la petrecere ; $x y 1$ are semnificatia ca daca $x$ participa nu exista nici o restrictie pentru $y$, dar daca $x$ nu participa atunci nici $y$ nu participa ; $x y 2$ are semnificatia simetrica cu cerinta $1$ ; iar cerinta $x y 3$ are semnificatia ca cel putin unul dintre $x$ si $y$ nu participa la petrecere. Scrieti un program care sa-i ajute pe cei doi sa determine care persoane vor fi invitate la petrecere ; se garanteaza ca va fi posibila intotdeauna organizarea unei petreceri !\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie se vor afisa numerele $N$ si $M$ care reprezinta numarul de prieteni si numarul de cerinte de indeplinit. Pe urmatoarele $M$ linii vor fi cerinte de forma $x y z$ unde $1<=x,y<=N$ iar $0<=z<=3$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie va fi un numar $Nr$ ce reprezinta numarul de invitati la petrecere, iar pe urmatoarele $Nr$ linii cate un invitat pe linie.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 100$\r\n* $1 &le; M &le; 1.000$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. party.in |_. party.out |\r\n| 4 4            \r\n1 4 3          \r\n2 3 3\r\n1 2 1\r\n2 4 1\r\n| 1\r\n3 |\r\n| 3 7          \r\n3 2 1          \r\n3 1 1          \r\n2 1 1          \r\n2 3 1\r\n3 1 1\r\n3 2 1\r\n2 3 2\r\n| 3\r\n1\r\n2\r\n3 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"party\")==',13,'task: party'),('problema/atac','Atac','2006-11-11 15:23:06','==Include(page=\"template/taskheader\" task_id=\"atac\")==\r\n\r\nIn tara Arboreea lucrurile au iesit de sub control. OTPB (Organizatia Terorista Petrica Bomba) a hotarat sa atace doua orase din aceasta tara deoarece liderul organizatiei, Petrica, a pierdut alegerile prezidentiale din anul 2004. Tara are $N$ orase, numerotate de la $1$ la $N$, iar reteaua oraselor si strazile dintre aceastea formeaza un arbore (graf neorientat conex ce nu contine cicluri). OTPB stie pentru fiecare strada cate bombe trebuie sa utilizeze pentru a o scoate din uz. Acum se pune problema determinarii numarului cel mai mic de bombe pe care trebuie sa-l utilizeze OTPB pentru ca intre cele doua orase alese (considerate de importanta majora in Arboreea) sa nu mai existe drum intre ele dupa bombardament. Cum importanta oraselor se schimba pe parcusul evolutiei tarii, OTPB vrea sa stie numarul minim de bombe pentru atacul asupra mai multor perechi de orase, mai exact $M$. Totusi se doreste comunicarea usoara a acestor $M$ perechi intre organizatiile teroriste din tara. Astfel, nu se poate transmite intreaga lista a celor $M$ perechi de orase asupra carora se doreste efectuarea unui atac deoarece reteaua de legatura dintre organizatii este cam inceata la capitolul trasmiterea datelor. Totusi s-a gasit o solutie: stiind prima pereche de orase $X$ si $Y$ asupra carora se va efectua un atac si numarul minim de bombe $Z$ ce trebuie utilizate in cazul atacului in orasele $X$ si $Y$, urmatoarea pereche de orase, a doua, se determina utilizand relatiile:\r\n\r\n$X\' = (X*A + Y*B) mod N + 1$\r\n$Y\' = (Y*C + Z*D) mod N + 1$\r\n\r\nA treia pereche de orase se determina utilizand in formula perechea a doua si numarul minim de bombe ce trebuie utilizate pentru a o ataca, a patra din a treia si asa mai departe. Asadar este suficienta cunoasterea primei perechi de orase si a numerelor $A, B, C, D$ pentru a determina toate cele $M$ perechi. De asemenea, din aceeasi cauza - transmiterea greoaie a datelor - OTPB vrea sa afle rezultatele doar pentru ultimele $P$ perechi de orase, considerate suficiente pentru a verifica corectitudinea programului dumneavoastra. Scrieti un program pentru organizatia lui Petrica care calculeaza numarul minim de bombe pentru atacul ultimelor $P$ perechi de orase din cele $M$ daca vreti sa mai ramaneti in viata !\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $atac.in$ se afla trei numere reprezentand numarul de orase, numarul de perechi de orase pentru care organizatia vrea sa afle numarul minim de bombe in cazul unui atac asupra lor si numarul $P$ de perechi pentru care programul vostru trebuie sa afiseze raspunsul. Pe urmatoarele $N-1$ linii se afla cate doua numere naturale $U$, $V$ cu semnificatia: exista o strada de la orasul $U$ la orasul $i$ ({$i$} este indicele liniei care va lua valori de la $2$ la $N$) pentru care OTPB trebuie sa utilizeze $V$ bombe pentru a o scoate din uz. Pe urmatoarea linie se afla $6$ numere $X, Y, A, B, C, D$ cu semnificatia din enunt.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul atac.out va avea $P$ linii reprezentand numarul minim de bombe ce trebuie utilizat pentru a ataca ultimele $P$ perechi de orase.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 32.000$\r\n* $0 < P < M &le; 500.000$\r\n* $P &le; 10.000$\r\n* $0 &le; A, B, C, D &le; 10.000$\r\n* numarul de bombe pentru a scoate din uz o strada este un numar natural mai mic decat $100.000$\r\n* OTPB nu va scoate din uz nici o strada; se doreste sondarea terenului si nimic mai mult, momentan; deci pentru fiecare pereche de orase din cele $M$ se considera ca reteaua de strazi este intacta (nici o strada nu este bombardata).\r\n* Se vor acorda puncte pe un test doar daca toate cele $P$ numere din fisierul de iesire sunt corect aflate.\r\n* Este clar ca pentru a afla corect cele $P$ numere trebuie sa calculati numarul minim de bombe pentru toate cele $M$ perechi de orase.\r\n* Nu va bazati pe faptul ca perechile de orase se vor repeta iar setul de perechi distincte este mic! OTPB vrea sa studieze cat mai multe perechi de orase asa ca numerele $A, B, C, D$ vor fi inteligent alese pentru a genera cat mai multe perechi distincte intre cele $M$.\r\n* Daca $X$ coincide cu $Y$ atunci raspunsul este $0$\r\n* Pentru $40%$ din teste $N$ va fi mai mic sau egal $1000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. atac.in |_. atac.out |\r\n| 7 3 2\r\n1 1\r\n2 2\r\n2 2\r\n1 3\r\n5 3\r\n5 2\r\n6 7 1 1 1 1\r\n| 1\r\n1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"atac\")==',18,'task: atac'),('problema/tribute','Tribute','2006-11-11 20:24:56','==Include(page=\"template/taskheader\" task_id=\"tribute\")==\r\n\r\nDin nou cineva trebuie sa cumpere teren... De data asta este Viviana si terenul pe care vrea sa-l cumpere e in forma de dreptunghi cu laturile pararele cu axele sistemului de coordonate. Se cunoaste pozitia a $N$ obiective situate in puncte de coordanate intregi pe care Viviana vrea sa le aibe cat mai aproape de terenul sau. Dupa ce si-a stabilit pozitia terenului ea incepe sa calculeze distanta totala de la terenul ei la cele $N$ obiective. Pentru aceasta ea defineste distanta de la un obiectiv la terenul sau ca fiind distanta Manhattan minima de la obiectiv la orice punct de coordonate intregi care se afla pe propietatea ei sau pe marginile acesteia (bineinteles, conform acestei definitii, obiectivele aflate pe propietatea Vivianei sau pe marginile acesteia se vor afla la distanta 0 fata de terenul sau). Distanta totala de la propietatea la obiective este suma distantelor pentru fiecare obiectiv in parte.\r\n\r\nh2. Cerinta\r\n\r\nAflati pentru Viviana distanta totala minima pe care o poate obtine daca ea vrea sa cumpere un teren de dimensiuni ({$DX$},{$DY$}).\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $tribute.in$ contine pe prima linie numerele $N$, $DX$ si $DY$, separate prin spatii. Pe urmatoarele $N$ linii se afla pozitia fiecarui obiectiv in plan.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $tribute.out$ trebuie sa contina un singur numar reprezentand distanta totala minima pe care o poate obtine Viviana prin plasarea inteligenta a terenului.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 50.000$\r\n* $1 &le; DX, DY &le; 50.000$\r\n* Coordonatele obiectivelor sunt numere naturale din intervalul $[0, 50 000]$\r\n* Nu exista mai multe obiective in acelasi punct\r\n* Coordonatele terenului nu pot fi inversate\r\n* Terenul se poate plasa oriunde in plan\r\n* Distanta Manhattan intre doua puncte ({$x$}, {$y$}) si ({$z$}, {$t$}) se defineste ca fiind $|x-z| + |y-t|$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. tribute.in |_. tribute.out |\r\n|5 1 1\r\n4 4\r\n0 0\r\n4 1\r\n0 1\r\n4 3\r\n|10 |\r\n\r\nh3. Explicatie\r\n\r\nColtul din stanga jos al terenului se plaseaza in punctul (3, 1). Distantele de la teren la obiective sunt: 2, 4, 0, 3 si respectiv 1. Distanta totala este 2+4+0+3+1 = 10, care este cea minima.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"tribute\")==',15,'task: tribute'),('problema/coins','Coins','2006-11-12 16:23:01','==Include(page=\"template/taskheader\" task_id=\"coins\")==\r\n\r\nCapitanul Paftenie este un batran lup de mare. A trecut prin numeroase aventuri si a cutreierat lumea intreaga. Ajuns insa la batranete, isi petrece majoritatea timpului jucand un joc de strategie cu secundul sau. Jocul consta dintr-o tabla orizontala cu *22* de patratele, pe care sunt asezati galbeni (maxim unul in fiecare patratel, reprezentand nave de razboi). Fiecare muta pe rand. O mutare consta din alegerea unui galben si deplasarea sa in primul patratel liber din stanga sa. Daca la un pas Paftenie nu mai poate muta nici o piesa (toti galbenii sunt aliniati pe pozitii consecutive, incepand cu primul patratel), atunci castiga toti galbenii de pe tabla. Paftenie muta intotdeauna primul. Are probleme financiare si din acest motiv ar vrea sa stie numarul maxim de galbeni care ii poate castiga dupa un numar de jocuri.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Paftenie sa afle rezultatul!\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $coins.in$ este dat numarul $N$ al jocurilor. Pe urmatoarele $N$ linii se afla cate $22$ de numere ({$0$} sau $1$ - $0$ reprezinta patratel liber, $1$ patratel cu galben pe el). Numerele sunt separate prin cate un spatiu.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $coins.out$ va contine pe prima linie un numar intreg $M$: valoarea maxima gasita.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100.000$\r\n* secundul joaca intotdeauna optim\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. coins.in |_. coins.out |\r\n| 4 \r\n 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \r\n 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \r\n 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \r\n 1 1 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 \r\n| 5 | \r\n\r\nh3. Explicatie\r\n\r\nPaftenie castiga primul si al treilea joc. Astfel, el strange 5 galbeni. \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"coins\")==',1,'task: coins'),('problema/zaharel','Zaharel','2006-11-11 17:07:56','==Include(page=\"template/taskheader\" task_id=\"zaharel\")==\r\n\r\nZaharel este un mare pasionat al culorilor, astfel incat a luat o foaie de matematica cu $N$ linii si $N$ coloane si a desenat $M$ buline rosii sau albastre, in casutele foii de mate, in diferite pozitii. Dupa ce a desenat punctele a observat ca exista cel putin un punct rosu pe fiecare linie si cel putin un punct albastru pe fiecare coloana si astfel si-a pus urmatoarea problema: poate sa construiasca doua poligoane (nu neaparat convexe) care sa aiba acelasi numar de varfuri, unul din poligoane sa aiba in varfuri doar buline rosii iar celalalt doar buline albastre, iar centrul de greutate al celor doua poligoane sa fie acelesi? Zaharel nu este baiat pretentios deci nu are nimic impotriva daca cel doua poligoane se intersecteaza sau daca sunt unul in interiorul celuilalt! Trebuie sa fie respectate doar conditiile mentionate mai sus. Centrul de greutate al unui poligon cu varfurile {$(x{~0~},y{~0~})$}{$(x{~1~},y{~1~})$}...{$(x{~n~},y{~n~})$} este considerat ca fiind punctul de coordonate {$((x{~0~} + x{~1~} + ... + x{~n~})/(n+1), (y{~0~} + y{~1~} + ... y{~n~})/(n+1))$}.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care pentru o foaie de mate desenata ca mai sus de Zaharel, determina cele doua poligoane.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $zaharel.in$ se gasesc numerele naturale $N$ si $M$. Urmatoarele $M$ linii sunt de forma $i j c$ unde $i$ si $j$ sunt numere naturale reprezentand linia, respectiv coloana unei buline, iar $c$ este un caracter reprezentand culoarea ({$R$} pentru rosu si $A$ pentru albastru)\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului de iesire $zaharel.out$ sa va afisa un numar, reprezentand cate varfuri are fiecare poligon. Pe urmatoarea linie se vor afisa punctele care descriu poligonul cu varfurile in buline rosii, intr-o ordine oarecare. Pe a treia linie se vor afisa punctele care descriu poligonul cu varfurile in buline albastre, intr-o ordine oarecare.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $6 &le; N &le; 1 000$\r\n\r\n* $2*N &le; M &le; 100 000$\r\n\r\n* Daca nu exista solutie se va afisa -1 in fisierul de iesire\r\n\r\n* Daca exista mai multe solutii se va afisa una singura\r\n\r\n* Poligoanele rezultate trebuie sa aiba minim 2 varfuri\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. zaharel.in |_. zaharel.out |\r\n|6 12\r\n1 3 R\r\n2 4 R\r\n3 1 R\r\n4 6 R\r\n5 2 R\r\n6 4 R\r\n2 1 A \r\n4 2 A\r\n3 3 A\r\n1 4 A\r\n6 5 A\r\n6 6 A\r\n|3\r\n1 3 2 4 3 1\r\n1 4 2 1 3 3|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"zaharel\")==',256,'task: zaharel'),('problema/sobo','Sobo','2006-11-11 20:35:28','==Include(page=\"template/taskheader\" task_id=\"sobo\")==\r\n\r\nPetrica, satul de munca pe santier, vrea sa faca de ceva mai apropiat capacitatii sale intelectuale. Astfel si-a luat o cutie cu $N$ sobolani si face experimente pe ei. Printre altele el a scos harta genetica a fiecarui sobolan, care consta intr-o secventa binara de lungime $L$. Printre sobolani se afla unul mai special, cel mai inteligent dintre ei, pe care Gigel, prietenul lui Petrica, il vrea cu orice pret. Petrica insa nu vrea sa renunte la sobolanul inteligent atat de usor si il pune pe Gigel la urmatoarea proba: ii da hartile genetice ale tuturor sobolanilor, fara sa-i spuna care este cel special. Gigel are voie sa puna intrebari de genu: \"Ce valoare are harta sobolanului inteligent in pozitia $x$ ?\" dar raspunsul are un pret, Petrica dandu-i lista preturilor tuturor pozitiilor. Asadar Gigel va trebui sa ghiceasca sobolanul destept pe baza raspunsurilor lui Petrica care sunt de forma: \"Harta sobolanului inteligent are in pozitia $x$ valoarea $y$\" unde $y$ este $0$ sau $1$. Gigel vrea sa stie care e pretul minim pe care il plateste, considerand cel mai defavorabil caz (Petrica va alege raspunsurile astfel incat costul sa fie cat mai mare posibil).\r\n\r\nh2. Cerinta\r\n\r\nGigel va plati considerabil (cu 100 de puncte) pe cel care ii va face un program care sa calculeze acest cost.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie in fisierul de intrare $sobo.in$ se afla numerule $N$, $L$ separate prin cate un spatiu reprezentand numarul de sobolani si lungimea hartilor genetice ale acestora. Pe urmatoarele $N$ linii se afla cate un sir de $L$ biti (nedespartiti de spatii) reprezentand harta unui sobolan. Pe ultima linie se afla $L$ numere separate prin spatii reprezentand costul raspunsului pentru fiecare pozitie.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie din fisierul de iesire $sobo.out$ se va gasi un numar intreg reprezentand costul minim in cel mai defavorabil caz pentru Gigel.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 15$\r\n* $1 &le; L &le; 1000$\r\n* Costurile raspunsurilor sunt numere intregi din intervalul $[1, 1 000 000]$\r\n* Nu exista sobolani cu harti genetice identice\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. sobo.in |_. sobo.out |\r\n| 4 3\r\n101\r\n000\r\n011\r\n010\r\n2 6 7 | 13 |\r\n\r\nh3. Explicatii\r\n\r\nCostul minim 13 (in cel mai defavorabil caz) este obtinut astfel: Gigel intreaba care este valoarea hartii sobolanului inteligent in pozitia 2 si Petrica ii raspunde 1 acesta fiind cel mai defavorabil caz (daca raspunsul lui Petrica ar fi fost 0 urma intrebarea lui Gigel despre valoarea in pozitia 1 si sobolanul ar fi fost identificat cu un costul 6 + 2 = 8). Asadar niciunul dintre primii doi sobolani nu este cel inteligent. Gigel mai trebuie sa afle care din ultimii doi sobolani este cel inteligent si mai cere informatii despre pozitia 3 din harta sobolanului inteligent. Indiferent de raspuns sobolanul inteligent va fi descoperit.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sobo\")==',15,'task: sobo'),('problema/boom','Boom','2006-11-11 20:37:47','==Include(page=\"template/taskheader\" task_id=\"boom\")==\r\n\r\nVa las sa ghiciti cine este protagonistul acestei probleme. Nu este foarte greu de imaginat ca numele lui va fi tot Petrica. Ce face el de data aceasta este ceva cu totul aparte: se joaca cu sobolanul cel ghidus. Acesta din urma este localizat intr-o galerie subterana care se prezinta ca o succesiune de $N$ camere dispuse in linie si care sunt numerotate de la $1$ la $N$ in ordinea parcurgerii lor de la un capat la celalalt. Petrica nu stie unde este localizat sobolanul dar vrea cu orice pret sa-l rada de pe fata pamantului. Astfel, el poate detona bombe otravitoare in unele din camerele galeriei (uneori chiar in mai multe simultan) pentru a omori sobolanul. Daca acesta este intr-una din camerele gazate moare pe loc, daca nu camera nu pateste nimic si sobolanul poate circula prin ea imediat dupa detonarea bombei. Lucrurile stau in felul urmator: cei doi inamici joaca in mod cinstit astfel ca dupa ce Petrica detoneaza un set bombe care vor exploda simultan, sobolanul, daca nu a murit, se va muta intr-una din camerele vecine celei in care se afla (camerele de la capete au o singura camera vecina). Petrica a alcatuit un plan de atac compus din $M$ sarje. Pentru fiecare sarja se cunosc pretul realizarii ei si camerele gazate daca ea este pusa in practica. La fiecare pas Petrica va alege doar una din cele $M$ sarje pentru a gaza anumite camere.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Petrica sa gaseasca o strategie de cost minim in urma careia sobolanul va fi omorat indiferent de pozitia initiala a acestuia.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie in fisierul de intrare $boom.in$ se afla doua numere intregi separate de un singur spatiu $N$ si {$M$}, reprezentand numarul de camere ale galeriei si numarul de sarje. Pe urmatoarele $M$ linii sunt date informatiile cu privire la fiecare sarja (ele sunt numerotate de la $1$ la $M$ in ordinea in care se gasesc in fisierul de intrare). Astfel, pe fiecare linie sunt doi intregi $P$ si {$Q$}, reprezentand pretul si numarul de camere gazete in sarja. Urmeaza $Q$ numere ({$Q$} nu este mai mare decat {$4$}) reprezentand camerele gazate.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie din fisierul de iesire $boom.out$ se va gasi un numar intreg reprezentand costul minim al unei strategii in urma careia sobolanul va fi mort. Pe urmatoarele linie se afla un numar $T$ reprezentand numarul de sarje care il va omori in mod sigur. Urmatoarele $T$ linii contin numerele sarjelor utilizate de Petrica (aceasta sunt date in ordinea in care au fost utilizate).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 20$\r\n* $1 &le; M &le; 50$\r\n* Sobolanul nu poate sta pe loc\r\n* Daca exista mai multe solutii cu acelasi cost minim se poate afisa oricare dintre ele\r\n* O sarja poate fi folosita de mai multe ori\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. boom.in |_. boom.out |\r\n| 3 2\r\n1 2 1 3\r\n2 1 2\r\n| 2\r\n2\r\n1\r\n1 |\r\n\r\nh3. Explicatii\r\n\r\nPetrica detoneaza foloseste de doua ori sarja 1. Oriunde s-ar afla sobolanul acesta va muri: daca este in camera 1 sau 3 va muri dupa prima gazare daca se afla in a doua camera va fi obligat sa se mute intr-un din camerele 1 si 3 la urmatorul pas, fiind astfel prins de cea dea doua gazare. Costul total este 2 cel mai mic posibil.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"boom\")==',15,'task: boom'),('problema/petsoft','PetSoft','2006-11-11 20:45:05','==Include(page=\"template/taskheader\" task_id=\"petsoft\")==\r\n\r\nPetrica detine o companie de software numita PETSOFT cu care este lider in domeniu. Secretul succesului sta in modul de organizare interna din aceasta firma. Fiecare angajat are asociat un numar distinct de la $1$ la $N$ si se stie pentru fiecare angajat cine este seful sau direct (angajatul numarul $1$ este chiar Petrica si nu are nici un sef). Mai exact relatiile dintre angajatii firmei formeaza un arbore cu radacina in nodul $1$. Firma este invitatata la un targ international de software unde isi va prezenta oferta. La conferinta se vor prezenta din partea firmei un numar de echipe (stabilit de Petrica) de cate doi angajati. Petrica nu este interasat de numarul de echipe ci de valoarea lor. Pentru asta el stabileste urmatoarele regula: angajatii $x$ si $y$ pot fi trimisi la conferinta impreuna daca $x$ este seful direct al lui $y$ sau daca $x$ si $y$ au acelasi sef iar valoarea echipei formate din cei doi este $|x - y|$. De asemenea este stiut faptul ca Petrica (angajatul numarul {$1$}) nu va fi incadrat in nici o echipa, el fiind managerul firmei. Valoarea totala e echipelor va fi suma valorilor tuturor echipelor.\r\n\r\nh2. Cerinta\r\n\r\nSe cauta un programator capabil sa stabileasca modul de formare a echipelor astfel incat valoarea totala a echipelor sa fie maxima. Odata gasit, el va fi angajat direct intr-un loc de frunte in ierarhia firmei. Poti fi chiar tu acel programator, dar trebuie sa demostrezi ca esti alegerea buna dezvoltand un program care poate calcula valoarea totala maxima a echipelor pe care firma le va trimite la conferinta.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie in fisierul de intrare $petsoft.in$ se afla un numar intreg $N$ reprezentand numarul de angajati ai firmei. Pe urmatoarele $N-1$ linii sunt date informatiile cu privire la ierhia firmei: pe linia $i$ se afla seful angajatului cu numarul $i$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie din fisierul de iesire $petsoft.out$ se va gasi un numar intreg reprezentand valoarea totala maxima a echipelor ce vor fi trimise la conferinta.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 1000$\r\n* Fiecare angajat poate fi incadrat in maxim o echipa.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. petsoft.in |_. petsoft.out |\r\n| 5\r\n1\r\n4\r\n2\r\n4\r\n| 4 |\r\n\r\nh3. Explicatii\r\n\r\nSe vor forma echipele 2-4 si 3-5.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"petsoft\")==',15,'task: petsoft'),('problema/sediu','Sediu','2006-11-12 01:21:31','==Include(page=\"template/taskheader\" task_id=\"sediu\")==\r\n\r\nIntr-o tara exista $N$ orase, legate intre ele prin sosele, precum si o grupare terorista care ameninta securitatea nationala. Fiecare sosea leaga o pereche de orase si este bidirectionala. Sistemul stradal este astfel alcatuit, incat intre oricare doua orase exista exact un singur drum, mergand pe soselele din cadrul sistemului. Guvernul tarii a decis sa amplaseze sediul central al armatei intr-unul din orase, in asa fel incat sa minimizeze numarul de orase controlate de gruparea terorista. Aceasta poate controla orice submultime a celorlalte $N-1$ orase, in asa fel incat intre oricare doua orase controlate se poate circula, mergand pe soselele din cadrul sistemului stradal, fara a trece prin orasul in care este situat sediul central al armatei. Dupa ce armata isi amplaseaza sediul central intr-unul din orase, gruparea terorista alege un numar maxim posibil de orase pe care sa le controleze, care respecta proprietatea anterioara.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati toate orasele in care armata isi poate amplasa sediul central, astfel incat numarul de orase controlate de gruparea terorista sa fie minim.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare $sediu.in$ contine numarul intreg {$N$}. Pe urmatoarele {$N-1$} linii se afla numerele a doua orase diferite, $a$ si $b$, cu proprietatea ca exista o sosea care leaga orasele $a$ si $b$.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie a fisierului de iesire $sediu.out$ va contine doua numere intregi $O$ si $M$. $O$ reprezinta numarul minim de orase controlate de gruparea terorista si $M$ reprezinta numarul oraselor care pot fi alese drept sediu central si pentru care se obtine valoarea $O$. Pe urmatoarea linie vor fi afisate $M$ numere intregi, separate prin spatii, reprezentand numerele oraselor in care se poate amplasa sediul central al armatei. Aceste numere vor fi afisate in ordine crescatoare.\r\n\r\nh2. Restrictii\r\n\r\n* $1$ &le; $N$ &le; $16.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. sediu.in |_. sediu.out |\r\n| 7\r\n1 2\r\n2 3\r\n2 4\r\n1 5\r\n5 6\r\n6 7\r\n| 3 1\r\n1 | \r\n\r\nh3. Explicatii\r\n\r\nDaca sediul central al armatei este amplasat in orasul {$1$}, gruparea terorista poate controla orasele {$2$}, $3$ si $4$ sau {$5$}, $6$ si {$7$}.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sediu\")==\r\n',13,'task: sediu'),('problema/text','Text','2006-11-11 23:28:26','==Include(page=\"template/taskheader\" task_id=\"text\")==\r\n\r\nDezamagit de rezultatele sale la ultimul concurs, Paftenie a renuntat la programare si s-a concentrat strict asupra muncii laborioase, dar care implica mai putin efort intelectual. De aceasta data, el primeste un text si trebuie sa calculeze lungimea medie a cuvintelor textului, un cuvant fiind definit ca o secventa continua maximala de caractere ale alfabetului englez (\'a\' .. \'z\' , \'A\' .. \'Z\'). Definim lungimea medie = (lungimea totala a cuvintelor textului) / (numarul de cuvinte ale textului).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care ii rezolva problema lui Paftenie.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $text.in$ se gaseste textul dat.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $text.out$ va contine pe prima linie un singur intreg, reprezentand partea intreaga a lungimii medii a cuvintelor textului.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Dimensiunea fisierului de intrare este de cel mult 1MB\r\n* Fisierul de intrare va contine doar litere mari si mici, cifre, spatii si simboluri (adica nu va contine caractere speciale)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. text.in|_. text.out|\r\n|- Lasa-ma in pace, ca am invatat azi noapte toata ziua!|3|\r\n\r\n_Explicatie_: Lungimea totala a cuvintelor textului = 41, numarul de cuvinte = 11 => [41 / 11] = 3.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"text\")==',256,'task: text'),('problema/trapez','Trapez','2006-11-11 18:26:15','==Include(page=\"template/taskheader\" task_id=\"trapez\")==\r\n\r\nZaharel este un tip care se plictiseste repede la scoala. Intr-o zi cu soare, cand n-avea chef sa asculte ce preda profesorul de matematica s-a apucat sa deseneze puncte pe o foaie de matematica. El a desenat $N$ astfel de puncte si apoi si-a pus urmatoarea intrebare: cate trapeze se pot forma cu varfurile in aceste puncte? Un trapez este un patrulater convex cu cel putin doua laturi paralele.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Zaharel sa determine cate trapeze poate forma cu cele $N$ puncte de pe foaia de matematica.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $trapez.in$ se gaseste numarul natural $N$. Pe urmatoarele $N$ linii se gasesc perechi de numerele naturale reprezentand coordonatele punctelor.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie din fisierul de iesire $trapez.out$ se va gasi numarul de trapeze care se pot forma.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $4 &le; N &le; 1 000$\r\n* Coordonatele punctelor sunt numere intregi din intervalul $[0, 2 000 000 000]$\r\n* Oricare trei puncte sunt necoliniare\r\n* Paralelogramele trebuie numarate de doua ori, fiindca sunt trapeze dupa doua orientari\r\n* Incercati sa evitati folosirea de numere reale in implementare deoarece pot cauza erori de precizie\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. trapez.in |_. trapez.out|\r\n|5\r\n0 0 \r\n0 1\r\n1 4\r\n2 0 \r\n3 1\r\n|1|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"trapez\")==',256,'task: trapez'),('problema/adn','ADN','2006-11-11 14:21:42','==Include(page=\"template/taskheader\" task_id=\"adn\")==\r\n\r\nO problema importanta in ultimii ani in biologie a fost gasirea secventei de ADN pentru om. Un lant ADN este format din doua spirale de molecule, fiecare molecula fiind denumita pe scurt A, G, C sau T. Deci un lant ADN poate fi reprezentat ca un sir de caractere din multimea A, G, C si T. Poblema cercetatorilor este ca ei nu pot gasi intreaga secventa ADN cu metode chimice sau biologice dar pot determina sectiuni din ea. Dupa ce au determinat o serie de sectiuni, un sir de molecule care are probabilitatea cea mai mare sa fie apropiat de secventa reala este sirul cel mai scurt de caractere care contine toate sectiunile determinate ca subsecvente!\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa-i ajute pe cercetatori sa determine cel mai scurt sir de caractere care contine toate sectiunile determinate ca subsecvente.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $adn.in$ va contine pe prima linie va contine numarul $N$ de secvente ADN iar pe urmatoarele $N$ linii cate un sir de caractere ce contine numai literele A,G,C si T.\r\n\r\nh2. Date de Iesire \r\n\r\nFisierul de iesire $adn.out$ va contine o singura linie cu cel mai scurt sir ce contine secventele din intrare ca subsecvente.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 18$\r\n* Lungimea fiecarui sir este mai mica de $30.001$\r\n* Daca exista mai multe solutii de lungime minima se va afisa oricare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. adn.in |_. adn.out |\r\n| 5\r\nGGATATAAAAAC\r\nGATAACCGCGCAGTGATGAGA\r\nTGATGAGATGGGGATATAAAA\r\nAGATAGATGATAACCGCGCAGT\r\nATGGGGATATAAAAACTTTTTT\r\n| AGATAGATGATAACCGCGCAGTGATGAGATGGGGATATAAAAACTTTTTT |\r\n\r\nh3. Explicatie\r\n\r\np(pre).. AGATAGATGATAACCGCGCAGT\r\n        {*GATAACCGCGCAGT*}GATGAGA\r\n                     {*TGATGAGA*}TGGGGATATAAAA\r\n                            {*ATGGGGATATAAAA*}ACTTTTTT\r\n                                {*GGATATAAAAAC*}\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adn\")==',961,'task: adn'),('problema/arie','Arie','2006-11-11 15:06:24','==Include(page=\"template/taskheader\" task_id=\"arie\")==\r\n\r\nSe dau doua poligoane convexe avand {$N$}, respectiv $M$ varfuri. Determinati aria intersectiei celor doua poligoane.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $arie.in$ se afla numarul intreg {$N$}, reprezentand numarul de varfuri al primului poligon. Pe urmatoarele $N$ linii se afla cate doua numere intregi, separate printr-un spatiu, reprezentand coordonatele $x$ si $y$ ale varfurilor primului poligon. Varfurile poligonului sunt date in ordine trigonometrica sau invers trigonometrica. Pe linia urmatoare se afla numarul intreg {$M$}, reprezentand numarul de varfuri al celui de-al doilea poligon. Pe urmatoarele $M$ linii se afla cate doua numere intregi, separate printr-un spatiu, reprezentand coordonatele $x$ si $y$ ale varfurilor celui de-al doilea poligon. Varfurile poligonului sunt date in ordine trigonometrica sau invers trigonometrica.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $arie.out$ veti afisa aria intersectiei celor doua poligoane, rotunjita la $3$ zecimale.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; N &le; 20$\r\n* $3 &le; M &le; 20$\r\n* $-50$ &le; abscisa oricarui varf al unui poligon &le; $50$\r\n* $-50$ &le; ordonata oricarui varf al unui poligon &le; $50$\r\n* Pentru cei surprinsi de limitele mici ale datelor de intrare si limita mare de timp : de multe ori (TopCoder, ACM, etc.) un program cu o complexitate neoptima, dar scris repede si clar, este de preferat unuia cu o complexitate optima, dar a carui durata de scriere este mare si in care exista sanse mari sa aveti \"bug\"-uri!\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. arie.in |_. arie.out |\r\n| 4\r\n-2 -2\r\n2 -2\r\n2 2\r\n-2 2\r\n3\r\n0 3\r\n3 0\r\n0 -3\r\n| 7.000 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"arie\")==',961,'task: arie'),('problema/aladdin','Aladdin','2006-12-13 08:22:57','==Include(page=\"template/taskheader\" task_id=\"aladdin\")==\r\n\r\nAladdin, asa cum stiati, este un mare magnat in afacerea de comercializare a covoarelor magice. Acesta doreste sa o cucereasca pe printesa Iasmina, iar aceasta, pentru a-i testa inteligenta il roaga sa ii faca un covor dreptunghiular impartit in patratele, asemanator unei table de sah cu $N$ linii si $M$ coloane. Fiecare patratel de pe covor trebuie colorat cu alb sau cu negru. Pentru fiecare patrat care contine patru patratele Iasmina pune conditia sa aiba un numar fixat de patratele colorate cu negru.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Aladdin sa realizeze un covor care satisface conditiile impuse de printesa Iasmina!\r\n\r\nh2. Date de intare\r\n\r\nIn fisierul de intrare $aladdin.in$ vom avea pe prima linie doua numere intregi $N$ si $M$. Pe urmatoarele $N - 1$ linii vom avea cate $M - 1$ numere intregi, separate intre ele prin spatii, astfel incat al $j$-lea numar intreg de pe linia $i + 1$ a fisierului reprezinta numarul de patratele al patratului care ocupa patratelele care au coordonatele $(i, j), (i + 1, j), (i, j+1)$ si $(i + 1, j + 1)$ care trebuie sa fie colorate cu negru.\r\n\r\nh2. Date de iesire\r\n\r\nIn cazul in care nu se poate construi niciun covor care sa satisfaca cerintele Iasminei, fisierul de iesire $aladdin.out$ va contine pe prima linie numarul $-1$.\r\nIn cazul in care exista solutii atunci poate fi afisata oricare. In fisierul de iesire se vor scrie $N$ linii si $M$ elemente pe fiecare linie separate prin cate un spatiu; $0$ va reprezenta un patratel colorat cu alb si $1$ un patratel colorat cu negru.\r\n\r\nh2. Restrictie\r\n\r\n* $1 &le; N, M &le; 1000$.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. aladdin.in |_. aladdin.out |\r\n| 4 4\r\n3 2 3\r\n2 3 3\r\n1 2 1\r\n| 1 1 0 1 \r\n1 0 1 1\r\n0 1 1 0\r\n0 0 0 0 |\r\n\r\n\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"aladdin\")==',256,'task: aladdin'),('problema/iepuri','Iepuri','2006-11-12 14:08:23','==Include(page=\"template/taskheader\" task_id=\"iepuri\")==\r\n\r\nZaharel a facut o noua pasiune, si anume vrea sa aiba iepuri! Astfel, el s-a dus intr-o zi (o vom numi ziua 0) la magazine si si-a cumparat $X$. Se stie ca iepuri se inmultesc in fiecare zi, astfel incat in ziua 1 el avea $Y$ iepuri, iar in ziua 2 $Z$ iepuri. Baiat perspicace, Zaharel a observat ca, incepand cu ziua 3, numarul de iepuri din fiecare zi depinde de numarul de iepuri din ultimele trei zile astfel: se aduna de $A$ ori numarul de iepuri care existau cu o zi in urma, de $B$ ori numarul de iepuri de acum doua zile si de $C$ ori numarul de iepuri de acum trei zile.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine restul impartirii numarului de iepuri pe care ii va avea Zaharel in ziua $N$ la $666013$.\r\n\r\nh2. Date de Intrare \r\n\r\nFisierul de intrare $iepuri.in$ contine mai multe seturi de date. Pe prima linie se va gasi un numar intreg $T$ reprezetand numarul de seturi de date pentru care se cere raspunsul. Pe urmatoarele $T$ linii se vor gasi cate sapte numere intregi, in ordinea urmtoare: $X Y Z A B C N$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $iepuri.out$ va contine $T$ linii, cate un numar intreg pe fiecare linie reprezentand raspunsul pentru un set de date. Raspunsul de pe linia $i$ va trebui sa corespunda cu setul de date de pe linia $i+1$ din fisierul de intrare.\r\n\r\nh2. Restrictii\r\n\r\n* $0 &le; T &le; 100$\r\n* $1 &le; X &le; Y &le; Z &le; 10.000$\r\n* $1 &le; A, B, C &le; 1.000$\r\n* $3 &le; N &le; 2.000.000.000$\r\n* Se acorda punctaj pentru un test doar daca s-a dat raspunsul corect pentru toate seturile de date\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. iepuri.in |_. iepuri.out |\r\n| 2\r\n1 1 2 1 1 1 5\r\n1 2 3 1 2 3 4 | 13\r\n22 |\r\n\r\nh3. Explicatie\r\n\r\nPrimul set de date:\r\nIn ziua $3$ va avea $1*2+1*1+1*1=4$ iepuri\r\nIn ziua $4$ va avea $1*4+1*2+1*1=7$ iepuri\r\nIn ziua $5$ va avea $1*7+1*4+1*2=13$ iepuri\r\nAl doilea set de date:\r\nIn ziua $3$ va avea $1*3+2*2+3*1=10$ iepuri\r\nIn ziua $4$ va avea $1*10+2*3+3*2=22$ iepuri\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"iepuri\")==',1,'task: iepuri'),('problema/secv','Secv','2006-11-12 16:04:04','==Include(page=\"template/taskheader\" task_id=\"secv\")==\r\n\r\nGheorghe a dat peste o noua problema de informatica la care are nevoie de un pic de ajutor!\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un sir de $N$ numere naturale, aflati lungimea minima a unei subsecvente care contine un subsir strict crescator, iar acest subsir contine toate numere din sirul initial o singura data. Daca nu exista o astfel de secventa, raspunsul va fi {$-1$}.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $secv.in$ se gaseste {$N$}, lungimea sirului. Pe a doua linie se gasesc $N$ numere intregi, sirul propriu-zis.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului de iesire $secv.out$ se gaseste numarul cerut.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 &le; N &le; 5 000$\r\n* Elementele sirului sunt numere intregi din intervalul $[0, 2 000 000 000]$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. secv.in|_. secv.out|\r\n|8 \r\n2 1 3 2 1 3 4 5\r\n|7 |\r\n\r\nh3. Explicatii\r\n\r\nSingura subsecventa care respecta conditile din enunt este $_1_ 3 _2_ 1 _3 4 5_$\r\nAcesta subsecventa contine subsirul $_1 2 3 4 5_$.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"secv\")==',13,'task: secv'),('problema/luna','Luna','2006-11-12 15:31:08','==Include(page=\"template/taskheader\" task_id=\"luna\")==\r\n\r\nIn anul 2507 colonizarea Lunii a luat sfarsit, fiecare tara detine cateva parcele din teritoriul planetei. Firmele de pe Pamant doresc construirea unor cladiri de forma dreptunghiulara pe Luna. Evident, fiecare firma va putea construi doar pe teritoriul care se afla in proprietatea tarii ei de provenienta.\r\n\r\nh2. Cerinta\r\n\r\nStabiliti in cazul fiecarei firme, daca este posibila satisfacerea cererii ei de construire!\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $luna.in$ se afla doua numere naturale $N$ si $M$, care reprezinta numarul de linii, respectiv numarul de coloane a matricei care descrie harta Lunii. Pe fiecare dintre urmatoarele $N$ linii se afla $M$ numere care indica numarul de ordine a tarii care este proprietara parcelei de pe linia si coloana respectiva de pe harta.\r\n\r\nPe urmatoarea linie se afla numarul $K$ al firmelor de pe Pamant, care doresc sa construiasca pe Luna. Pe urmatoarele $K$ linii sunt scrise triplete de numere, care reprezinta cererile firmelor. Primul numar din triplet reprezinta tara de provenienta a firmei. Al doilea si al treilea numar reprezinta dimensiunile cladirii pe care, conform cererii respective firma ar dori s-o construiasca.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $luna.out$ va contine exact $K$ linii. \r\n\r\n* Daca a $i$-a cerere poate fi satisfacuta, pe a $i$-a linie se va scrie mesajul {$Cererea poate fi satisfacuta$}.\r\n* Daca tara de provenienta a firmei nu are parcele pe Luna, in fisierul de iesire se va scrie mesajul {$Tara de provenienta nu are parcele pe Luna!$}.\r\n* Daca nu se poate construi o cladire cu dimensiunile date, folosind doar parcelele tarii de provenienta, in fisierul de iesire se va scrie mesajul {$Cererea nu poate fi satisfacuta!$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 50$\r\n* Numarul de ordine al unei tari este un numar natural cuprins intre $1$ si {$2500$}\r\n* $1 &le; K &le; 100 000$\r\n* Numarul de ordine a tarii de provenienta al unei firme este un numar natural cuprins intre $1$ si $5000$\r\n* Dimensiunile unei cladiri sunt numere naturale cuprinse intre $1$ si $100$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. luna.in|_. luna.out|\r\n|5 10\r\n1 1 1 2 2 2 2 3 3 4\r\n1 1 1 2 2 2 2 3 3 4\r\n5 5 5 2 2 2 2 7 7 4\r\n5 5 5 6 6 6 6 7 7 4\r\n5 5 5 6 6 6 6 7 7 4\r\n6\r\n1 2 3 \r\n2 3 4\r\n3 2 3\r\n1 3 2\r\n7 20 20\r\n8 4 4\r\n|Cererea poate fi satisfacuta!\r\nCererea poate fi satisfacuta!\r\nCererea nu poate fi satisfacuta!\r\nCererea poate fi satisfacuta!\r\nCererea nu poate fi satisfacuta!\r\nTara de provenienta nu are parcele pe Luna!\r\n|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"luna\")==',256,'task: luna'),('problema/indep','Indep','2006-11-11 21:01:55','==Include(page=\"template/taskheader\" task_id=\"indep\")==\r\n\r\nFiind dat un sir de numere naturale $A{~1~} A{~2~} ... A{~n~}$ sa se afle numarul de subsiruri independente ale acestuia. Un subsir se numeste independent daca cel mai mare numar natural care divide toate elementele sale este $1$.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care afla numarul cautat.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare se alfa un numar intreg $N$ reprezentand numarul de elemente ale sirului. Pe urmatoarele $N$ linii se afla cate un element al sirului.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire va contine pe prima linie un singur intreg reprezentand numarul cautat.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 500$\r\n* Elementele sirului sunt numere naturale din intervalul $[1, 1000]$\r\n* Prin subsir se intelege un subset de elemente ale sirului care nu se afla neaparat pe pozitii consecutive\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. indep.in |_. indep.out |\r\n| 4\r\n3\r\n4\r\n2\r\n6\r\n| 6 |\r\n\r\nh3. Explicatie\r\n\r\nSubsirurile independente sunt:\r\n{3, 2} {3, 4} {3, 4, 2} {3, 2, 6} {3, 4, 6} {3, 4, 2, 6}\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"indep\")==',15,'task: indep'),('problema/joc3','Joc3','2006-11-12 01:03:41','==Include(page=\"template/taskheader\" task_id=\"joc3\")==\r\n\r\nGigel si Andrei au $N$ saci cu pietre pretioase numerotati de la $1$ la $N$. Pentru ca nu vor sa imparta pietrele intre ei, au hotarat sa joace un joc iar castigatorul sa ia toate pietrele. Jocul consta in efectuarea alternativa a unor mutari. O mutare consta in selectarea unor pietre dintr-un sac $i$ ({$1$} &le; $i$ &lt; $N$) si mutarea acestora in sacul $i+1$. Jucatorul care nu mai poate efectua nici o mutare (atunci cand toate pietrele sunt asezate in ultimul sac) pierde jocul.\r\n\r\nh2. Cerinta\r\n\r\nStiind atat numarul de saci si configuratia acestora, cat si faptul ca Gigel va efectua prima mutare determinati, daca exista, o strategie de castig pentru el.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $joc3.in$ se va afla $N$, numarul de saci. Urmeaza $N$ linii, pe linia $i$ aflandu-se numarul de pietre pretioase din sacul $i$.\r\n\r\nh2. Date de iesire\r\n\r\nIn cazul in care Gigel nu are strategie de castig fisierul de iesire $joc3.out$ va contine pe prima linie valoarea $-1$. Altfel, afisati pe prima linie numerele $p$ si $q$ ce codifica mutarea initiala pe care ar trebui sa o efectueze Gigel pentru a castiga jocul ({$p$} este numarul sacului, iar $q$ numarul de pietre). In cazul in care exista mai multe mutari initiale ce ar putea duce la castigarea sigura a jocului, afisati mutarea care are $p$ minim. Daca totusi mai sunt cazuri de egalitate, afisati mutarea cu $q$ minim.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1$ &le; $N$ &le; $100.000$\r\n* $0$ &le; numarul de pietre dintr-un sac &le; $10.000$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. joc3.in |_. joc3.out |\r\n| 5\r\n2\r\n5\r\n4\r\n3\r\n1 | 2 2 |\r\n\r\nh3. Explicatie\r\n\r\nEfectuand aceasta mutare Gigel va castiga daca va continua sa joace perfect. Nu exista alta mutare cu $p$ sau $q$ mai mic.\r\n\r\ntable(example). |_. joc3.in |_. joc3.out |\r\n| 5\r\n0\r\n0\r\n0\r\n0\r\n10000 | -1 |\r\n\r\nh3. Explicatie\r\n\r\nCum toate pietrele sunt asezate in ultimul sac, Gigel nu poate efectua vreo mutare.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"joc3\")==',13,'task: joc3'),('problema/cifre','Cifre','2006-11-12 16:08:30','==Include(page=\"template/taskheader\" task_id=\"cifre\")==\r\n\r\nEugenia ii pune adesea intrebari dificile lui Zaharel, nu pentru ca nu stie raspunsul, dar vrea sa vada cat de perspicace este Zaharel. Uneori exagereaza si intrebarile ei sunt foarte grele, chiar si pentru Zaharel; atunci acesta va cere ajutorul vostru! Astazi Eugenia i-a pus urmatoarea intrebare lui Zaharel: \"eu ma gandesc la un numar intreg din intervalul $[A...B]$, care este probabilitatea ca numarul la care ma gandesc sa contina cel putin $K$ cifre de valoare $C$\"?\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Zaharel sa raspunda cat mai repede la intrebare.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie din fisierul de intrare se gasesc numerele intregi $A, B, C$ si $K$ (in ordinea aceasta)\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie din fisierul de iesire se va scrie probabilitatea, un numar real cu patru zecimale, ca numarul din intervalul $[A...B]$ la care se gandeste Eugenia sa aiba cel putin $K$ cifre de valoare $C$.\r\n\r\nh2. Restrictii\r\n\r\n* $0 &le; A &le; B < 1.000.000.000$\r\n* $0 &le; C, K &le; 9$\r\n* Pentru cel putin $50%$ din teste $B-A &le; 1.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. cifre.in |_. cifre.out |\r\n| 1 13 1 1 | 0.3846 |\r\n\r\nh3. Explicatii\r\n\r\nIn intervalul $[1..13]$ sunt $5$ numere care contin cel putin o cifra  de valoare $1:  1,10,11,12,13$. \r\nAstfel, probabilitatea este $5/13 = 0.(384615)$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cifre\")==',13,'task: cifre'),('problema/farfurii','Farfurii','2006-11-12 16:08:05','==Include(page=\"template/taskheader\" task_id=\"farfurii\")==\r\n\r\nIn fiecare zi Zaharel este obligat de Eugenia sa spele farfuriile si tacamurile dupa fiecare masa. Dupa ce le spala el trebuie sa le aranjeze pe doua rafturi, farfuriile pe primul si tacamurile pe al doilea... dar nu oricum! El are $N$ farfurii de marimi distincte, cuprinse intre $1$ si $N$ si $K$ tacamuri identice. Pentru fiecare pereche de farfurii asezate in raft astfel incat farfuria de marime mai mare, dintre cele doua, apare inaintea farfuriei de marime mai mica, Zaharel pune un tacam pe randul al doilea.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Zaharel sa aseze toate farfuriile pe primul raft astfel incat sa puna toate tacamurile pe al doilea raft. Dintre toate asezarile posibile determinati-o pe aceea minim lexicografica din punct de vedere al marimilor.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie din fisierul de intrare $farfurii.in$ se gasesc numerele naturale $N$ si {$K$}.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie din fisierul de iesire $farfurii.out$ se vor gasi $N$ numere distincte intre $1$ si $N$ reprezentand marimile farfuriilor, afisate in ordinea in care au asezate pe raft.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 100.000$\r\n* $0 &le; K &le; N*(N-1)/2$\r\n* Pentru cel putin $40%$ din teste $N &le; 2.000$\r\n* O asezare ({$A{~1~},A{~2~}...A{~N~}$}) este mai mica din punct de vedere lexicografic decat o alta asezare ({$B{~1~},B{~2~}...B{~N~}$}) daca exista o pozitie $p$ astfel incat $A{~p~}<B{~p~}$ si $A{~1~}=B{~1~}, A{~2~}=B{~2~}, ... A{~p-1~}=B{~p-1~}$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. farfurii.in |_. farfurii.out |\r\n| 7 8\r\n| 1 2 5 7 6 4 3 |\r\n\r\nh3. Explicatii \r\n\r\nPentru perechile de farfurii din asezare \r\n$({*5 4*}) ({*5 3*}) ({*7 6*}) ({*7 4*}) ({*7 3*}) ({*6 4*}) ({*6 3*}) ({*4 3*})$\r\nZaharel pune cate un tacam pe randul al doilea. O alta asezare posibila este \r\n${*1 2 6 5 7 4 3*}$\r\ndar aceasta este mai mare lexicografic.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"farfurii\")==',15,'task: farfurii'),('problema/poligon','Poligon','2006-11-12 14:07:37','==Include(page=\"template/taskheader\" task_id=\"poligon\")==\r\n\r\nDupa o noapte dementa, plina de infractiuni, un ofiter de politie lucreaza la elaborarea unor statistici. El are in fata harta orasului cu punctele unde s-au intamplat infractiuni precum si o zona in forma de poligon (nu neaparat convex) din harta care prezinta interes maxim.\r\n\r\nh2. Cerinta\r\n\r\nFiind dat poligonul ce descrie zona de interes si punctele infractionale trebuie sa aflati numarul de infractiuni petrecute in acea zona.\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul de intrare $poligon.in$ se vor afla pe prima linie numerele intregi $N$ si $M$ separate printr-un spatiu, $N$ e numarul de varfuri ale zonei poligonale iar $M$ numarul total de infractiuni desfasurate noaptea trecuta. Pe urmatoarele $N$ linii se vor afla cate doi intregi reprezentand coordonatele varfurilor poligonului date in ordinea parcurgerii lor mergand numai intr-o directie (din cele doua posibile) pe laturile sale. Pe urmatoarele $M$ linii se vor afla coordonatele infractiunilor desfasurate in noaptea anterioara.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $poligon.out$ se va afla pe prima linie numarul de puncte interioare sau pe marginea zonei date. Linia se termina cu caracterul \"end of line\".\r\n\r\nh2. Restrictii\r\n\r\n* $3 &le; N &le; 800$\r\n* $1 &le; M &le; 60.000$\r\n* Coordonatele punctelor vor fi numere intregi intre $0$ si $60.000$\r\n* Poligonul nu se auto-intersecteaza\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. poligon.in |_. poligon.out |\r\n| 4 3\r\n0 0\r\n0 100\r\n100 100\r\n100 0\r\n50 50\r\n100 50\r\n100 110 | 2 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"poligon\")==',15,'task: poligon'),('agora-finala','Bursele agora, editia 6, finala online','2006-12-28 02:00:59','h1. Bursele agora, editia 6, finala online\r\n\r\nAceasta este runda finala online a concursului \"Bursele Agora\", editia 6. Concursul a fost organizat de catre redactia revistei GInfo si Editura Agora Media. Concursul s-a desfasurat pe 9 iulie 2005. Puteti vedea \'clasamentul\':agora-finala/clasament, cat si un articol cu \'solutii\':agora-finala/solutii.\r\n\r\n!>agora-finala?logo.gif!\r\n\r\n== Tasks(round_id=\"ba6\" pager_style=\"none\")==',1142,'protected'),('problema/triunghi','Triunghi','2006-11-11 17:34:00','==Include(page=\"template/taskheader\" task_id=\"triunghi\")==\r\n\r\nLui Gigel ii place sa se joace, asa ca el a primit un joc cu cutii pe care erau scrise numere intregi stict pozitive. Avand o imaginatie bogata, el s-a gandit intr-o zi sa construiasca un triunghi de cutii astfel: o cutie este asezata peste doua cutii, care sunt asezate pe trei cutii... care sunt asezate pe $N$ cutii (deci fiecare cutie se sprijina pe alte doua). Dar Gigel nu se opreste aici, ci vrea ca numarul din fiecare cutie din triunghiul sau (mai putin ultima linie) sa fie egal cu suma numerelor din cele doua cutii de dedesubt.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care determina daca Gigel poate construi un triunghi de latura $N$, in care suma numerelor de pe toate cutiile sa fie $S$, stiind ca pot folosi oricate cutii cu orice numar in ele.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie in fisierul $triunghi.in$ se vor afla numerele $N$ si $S$ separate prin cate un spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nPe primele $N$ linii din fisierul $triunghi.out$ se vor afla numerele de pe cutiile din triunghi: pe linia $i$ vor fi scrise cate $i$ numere intregi strict pozitive care descriu linia $i$ din triunghi. Daca Gigel nu poate construit un astfel de triunghi, in fisier se va afisa in schimb mesajul $imposibil$.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $1 &le; N &le; 18$\r\n* $1 &le; S &le; 1 000 000$\r\n* Daca sunt posibile mai multe solutii se va afisa oricare dintre ele\r\n\r\nExemple\r\n\r\ntable(example). |_. triunghi.in |_. triunghi.out |\r\n|3 34\r\n|13\r\n6 7\r\n1 5 2|\r\n|4 26\r\n|8\r\n4 4\r\n2 2 2\r\n1 1 1 1|\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"triunghi\")==',256,'task: triunghi'),('problema/cobai','Cobai','2006-11-12 16:34:31','==Include(page=\"template/taskheader\" task_id=\"cobai\")==\r\n\r\nDiorde, cel mai tare biolog din Tritenii de Jos, lucreaza la crearea unui elixir care sa-i faca pe consatenii sai mai inteligenti. El testeaza acest elixir pe Miki, singurul om din sat care s-a oferit voluntar. Pentru a vedea cat de inteligent este acesta, Diorde a construit un caroiaj dreptunghiular, caroiaj de $M*N$ camere. Din fiecare camera sunt cel mult $4$ usi, orientate inspre Nord, Sud, Est si Vest. In unele camere nu se poate intra, ele fiind inchise. Diorde are un cobai mult mai istet decat multi dintre sateni, cobai caruia ii da drumul dintr-o camera pe care o va inchide dupa aceea, si-l va lasa sa se miste in voie o perioada de timp. Cobaiul este dotat cu un dispozitiv care transmite tot timpul un semnal, care ne spune directia in care se deplaseaza cobaiul. Acest aparat detecteaza doar schimbarile de directie ale cobaiului. Dupa schimbarea unei directii cobaiul se deplaseaza cu cel putin o pozitie in acea directie, si modificarile de directie au loc intotdeauna cu $90$ de grade.\r\n\r\nCe trebuie sa faca Miki pentru a dovedi ca este mai inteligent? Avand in mana harta caroiajului (cu $.$ vor fi marcate camerele deschise iar cu $+$ camerele inchise), si stiind pozitia din care a plecat cobaiul (marcata cu $*$), precum si directiile in care s-a deplasat acesta, trebuie sa determine o pozitie posibila in care se poate afla cobaiul la sfarsitul acelui interval de timp.\r\n\r\nVoi trebuie sa calculati probabilitatea ca Miki sa ghiceasca o pozitie, in care cobaiul poate fi.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare contine numerele $M$ si $N$, separate printr-un singur spatiu. Urmatoarele $M$ linii contin cate $N$ caractere care descriu suprafata planetei (caracterele admise apartin multimii {\".\" , \"+\" , \"*\"} si au semnificatia prezentata anterior). Urmatoarea linie va descrie informatiile furnizate de dispozitivul de urmarire, neseparate prin spatii. Litera $N$ indica o deplasare spre nord (spre prima linie a matricei), litera $V$ o deplasare spre vest (spre prima coloana), litera $S$ o deplasare spre sud (spre ultima linie), iar litera $E$ o deplasare spre est (spre ultima coloana).\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire va contine un singur numar care va indica procentul cautat. Numarul va fi real cu $2$ zecimale, nerotunjit.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N,M &le; 50$\r\n* Numarul schimbarilor de directie este cel mult $1.000$\r\n* Cobaiul nu poate parasi caroiajul\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. cobai.in |_. cobai.out |\r\n| 4 5\r\n.....\r\n.+.+.\r\n+....\r\n.++.*\r\nNVS \r\n| 28.57 | \r\n\r\nh3. Explicatie\r\n\r\nCaroiajul contine $14$ camere in care se poate intra ( cele notate cu $.$ ). Deplasandu-se in directiile {$N$}, urmat de {$V$}, apoi de $S$ el nu se mai poate afla decat in alte $4$ camere. Rezulta un procent de {$28,57 %$}.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cobai\")==',961,'task: cobai'),('problema/concert','Concert','2006-11-11 20:36:16','==Include(page=\"template/taskheader\" task_id=\"concert\")==\r\n\r\nUn grup de $N$ artisti a primit invitatii sa cante la un concert. Fiecarui artist i s-a trimis o invitatie pe care acesta era invitat sa cante intre orele $A$ si $B$. Insa organizatorii acestui eveniment au gresit invitatiile si timpurile in care trebuiau sa cante anumiti artisti se suprapuneau. Artistii, fiind renumiti, nu accepta sa cante decat singuri. De asemenea ei cer despagubiri daca li se cere sa inceapa sa cante dupa ora $A+1$ sau sa termine inainte de ora $B$. Un anumit artist poate sa cante doar intre orele $A$ si $B$ de pe invitatie. Unele invitatii pot fi anulate, asa ca unii artisti pot sa nu cante deloc.\r\n\r\nh2. Cerinta\r\n\r\nCunoscandu-se intervalele intre care poate sa cante fiecare artist, profitul pe care il aduce fiecare artist pe unitatea de timp si despagubirile cerut in ambele cazuri mentionate mai sus, voi trebuie sa aflati care este suma maxima care poate fi obtinuta in concertul respectiv, si cum poate fi ea obtinuta.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierul $concert.in$ se va afla $N$. Pe urmatoarele $N$ linii ale fisierulul se vor gasi cate 5 numere separate pin cate un spatiu. Ele reprezinta $A$, $B$, profitul pe unitatea de timp si despagubirile in cazul in care artistul nu incepe sa cante in $A+1$ si respectiv daca nu termina de cantat in $B$.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierul $concert.out$ se va afla suma maxima care poate fi obtinuta din concert.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 1.000$\r\n* $1 &le; A{~i~} < B{~i~} &le; 2.000.000.000$\r\n* profitul adus de fiecare artist sau despagubirile cerute de fiecare dintre ei nu vor trece de valoare 500. Despagubirile se platesc o data, nu pe unitate de timp.\r\n* daca artistul $i$ are in contract intervalul $(A{~i~},B{~i~})$ el poate canta intre momentele $A{~i~}+1$ si $B{~i~}$ inclusiv.\r\n* oricare doi artisti au intervalele diferite\r\n* solutia nu va trece de valoare 2^31^-1\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. concert.in |_. concert.out |\r\n| 5 \r\n0 5 10 10 15\r\n3 8 8 8 20\r\n4 10 12 4 10\r\n8 16 7 4 7\r\n12 20 10 5 50 | 189 |\r\n\r\nh3. Explicatie\r\n\r\nArtistul $1$ canta intre orele $1$ si $5$, aducand un profit de $(5-1+1)*10 = 50$ si nu cere despagubiri, pentru ca a cantat intre orele stabilite in invitatie. Artistul $2$ nu canta de loc. Artistul $3$ canta intre orele $6$ si $10$, aducand un profit de $(10-6+1)*12 = 60$, insa i se platesc despagubiri in valoare de $4$, pentru ca nu a inceput la ora la care i s-a spus in invitatie ca va incepe, ora $A+1 = 4$. Astfel artistul $3$ aduce un profit de $60-4 = 56$. Artistul $4$ canta intre orele $11$ si $12$. Aducand un profit de $2*7 = 14$, insa cere ambele despagubiri deci aduca un profit de $14-7-4 = 3$. Artistul cu numarul $5$ aduce un profitde $8*10 = 80$, si nu cere despagubiri, pentru ca a cantat intre orele stabilite. Astfel, totalul se ridica la: $50+56+3+80=189$.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"concert\")==',1,'task: concert'),('problema/perm3','Permutari 3','2006-11-12 14:44:47','==Include(page=\"template/taskheader\" task_id=\"perm3\")==\r\n\r\nPentru o multime oarecare de numere intregi cu $N$ elemente se poate defini o permutare a acesteia ca fiind o varianta de a aseza elementele multimii. De exemplu pentru multimea $M={4,12,81}$ vom avea permutarile:\r\n\r\n# ${ 4 , 12 , 81 }$\r\n# ${ 4 , 81 , 12 }$\r\n# ${ 12 , 4 , 81 }$\r\n# ${ 12 , 81 , 4 }$\r\n# ${ 81 , 4 , 12 }$\r\n# ${ 81 , 12 , 4 }$\r\n\r\nIn grupul format de toate permutarile unei multimi se poate defini o ordine a acestora astfel incat elementele aflate pe prima pozitie sa fie in ordine crescatoare, elementele de pe a doua pozitie sa fie in ordine crescatoare pentru permutarile care au primul element identic, etc. asa cum se vede in figura. O astfel de ordine se numeste ordine lexicografica. Permutarilor asezate in ordine lexicografica li se pot asocia numere de ordine, in cazul exemplului de mai sus de la $1$ la {$6$}.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se o multime de numere intregi si o permutare a ei concepeti un program care determina numarul de ordine al permutarii in ordine lexicografica\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $perm3.in$ contine:\r\n\r\n|_. Valori |_. Semnificatie |\r\n|{$N$} |prima linie: $N$ = numarul de elemente al multimii,  |\r\n|{$m{~1~} m{~2~} m{~3~}$} ... {$m{~N~}$}|a doua linie: elementele multimii, in ordine crescatoare|\r\n|{$p{~1~} p{~2~} p{~3~}$} ... {$p{~N~}$}|a treia linie: elementele permutarii (elementele {$m{~1~} m{~2~} m{~3~}$} ... {$m{~N~}$} dar in alta ordine) |\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $perm3.out$ va contine numarul permutarii in ordine lexicografica.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 1.000$\r\n* $1 &le; m{~i~} &le; 2.000.000.000$\r\n\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. perm3.in |_. perm3.out |\r\n| 3\r\n1 23 25\r\n23 1 25\r\n| 3 |\r\n| 4\r\n1 2 3 4\r\n3 4 1 2\r\n| 17 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"perm3\")==',961,'task: perm3'),('problema/triang','Triang','2006-11-11 17:47:57','==Include(page=\"template/taskheader\" task_id=\"triang\")==\r\n\r\nAndreea a invatat la scoala ce este un triunghi echilateral. Fascinata de aceste figuri geometrice, ea deseneaza in plan $N$ puncte cu coordonate numere reale. Ea insa nu isi da seama cate triunghiuri echilaterale a desenat, asa ca va cere ajutorul!\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $triang.in$ se afla numarul $N$ de puncte. Pe urmatoarele $N$ linii se vor afla coordonatele celor $N$ puncte sub forma ({$x y$}).\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $triang.out$ se va scrie numarul de triunghiuri echilaterale desenate de Andreea.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; N &le; 1.500$\r\n* $-10.000 &le; x, y &le; 10.000$\r\n* Nu vor exista doua puncte cu coordonate identice, iar orice punct poate fi folosit pentru formarea mai multor triunghiuri echilaterale.\r\n* Un triunghi este echilateral daca are toate unghiurile si laturile egale.\r\n* Daca folositi numere reale in programul dumneavoastra, se recomanda folosirea tipurilor double pentru C/C++, respectiv Pascal. Pentru testarea egalitatii a doua numere reale se recomanda folosirea unei precizii de {$10^-3^$}\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. triang.in|_. triang.out|\r\n|3\r\n0 0 \r\n4 0\r\n2 3.4641016\r\n|1|\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"triang\")==',256,'task: triang'),('problema/tri','Tri','2006-11-12 14:59:02','==Include(page=\"template/taskheader\" task_id=\"tri\")==\r\n\r\n\r\nSe da un triunghi $ABC$ pozitionat astfel incat varful $B$ este in originea axelor (punctul de coordonate $0$ si $0$, varful $C$ se afla pe axa $OX$ si are coordonata $x$ pozitiva, iar varful $A$ are ambele coordonate pozitive.\r\nIn acest triunghi se afla $N$ puncte ({$N$} divizibil cu $3$).\r\n\r\nh2. Cerinta\r\n\r\nSa se determine un punct notat in continuare cu $G$ care sa se afle in interiorul triunghiului $ABC$ si care sa indeplineasca conditia ca in interiorul sau pe conturul fiecaruia din triunghiurile $ABG$, $BCG$ si $CAG$ se afla exact o treime din cele $N$ puncte.\r\nDaca vreunul din cele $N$ punctele se afla pe unul din segmentele $AG$, $BG$ sau $CG$, se va considera ca el apartine doar unuia din cele doua triunghiuri care au in comun segementul respectiv si puteti alege caruia din cele doua triunghiuri ii apartine.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $tri.in$ se afla $6$ valori numerice intregi reprezentand: primele doua coordonatele varfului $A$, urmatoarele doua coordonatele punctului $B$ (ambele fiind $0$) si ultimele doua coordonatele punctului $C$ (a doua valoare din aceasta pereche este $0$)\r\nPe a doua linie numarul natural $N$. Pe fiecare din urmatoarele $N$ linii se afla cate doua valori numerice intregi reprezentant coordonatele fiecaruia din cele $N$ puncte aflate in interiorul triunghiului $ABC$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $tri.out$ doua valori numerice reale reprezentand coordonatele punctului $G$.\r\nPe a doua linie $N/3$ perechi de valori numerice intregi separate prin minim un spatiu reprezentant coordonatele punctelor aflate in interiorul sau pe conturul triunghiului $BCG$. Pe a treia linie $N/3$ perechi de valori numerice intregi separate print minim un spatiu reprezentant coordonatele punctelor aflate in interiorul sau pe conturul triunghiului $ABG$. Pe a patra linie $N/3$ perechi de valori numerice intregi separate prin minim un spatiu reprezentant coordonatele punctelor aflate in interiorul sau pe conturul triunghiului $ACG$.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $2 < N &le; 10.000$\r\n* Coordonatele pentru varfurile triungiului si pentru fiecare punct din interiorul triunghiului sunt numere intregi nenegative &le; $1.000.000$\r\n* In fiecare pereche reprezentand coordonatele unui punct, prima valoare reprezinta abscisa si a doua ordonata\r\n* Coordonatele punctului $G$ vor fi afisate cu un numar de $6$ zecimale exacte\r\n* Oricare doua dintre aceste puncte nu sunt coliniare cu unul din varfurile $A$, $B$ sau $C$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. tri.in |_. tri.out |\r\n| 5 5 0 0 10 0\r\n6\r\n8 1\r\n3 0\r\n3 2\r\n9 1\r\n6 1\r\n1 1\r\n| 3.636364 1.590909\r\n3 0  6 1 \r\n3 2  1 1 \r\n8 1  9 1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"tri\")==',15,'task: tri'),('problema/soc','Soc','2006-11-12 14:55:00','==Include(page=\"template/taskheader\" task_id=\"soc\")==\r\n\r\nUn grup de $N$ oameni de afaceri s-au intalnit cu ocazia unei conferinte. Unii dintre ei sunt prieteni, altii nu. Fiecare dintre ei are un cont banca ce contine o anumita suma exprimata in euro. De fiecare data cand se intalnesc, se gandesc cum sa initieze o noua afacere. De data aceasta s-au decis sa infiinteze o societate, la care actionarii sa fie o parte dintre ei, astfel incat oricare doi oameni de afaceri care sunt actionari ai societatii sa fie prieteni, iar capitalul societatii (egal cu totalul sumelor din conturile actionarilor) sa fie maxim. Pentru a determina actionarii acestei societati, v-au angajat pe dumneavoastra si, daca le veti da raspunsul in timp util, veti fi recompensat cu o suma frumoasa.\r\n\r\nInainte de a va apuca de treaba, cei $N$ oameni de afaceri v-au pus la dispozitie informatii referitoare la conturile lor din banca si la relatiile de prietenie dintre ei. Analizand problema, ati ajuns la concluzia ca relatiile de prietenie pot fi reprezentate sub forma unui graf neorientat cu $N$ varfuri (corespunzatoare celor $N$ oameni de afaceri); intre doua varfuri diferite exista o muchie, daca cei doi oameni de afaceri corespunzatori celor doua varfuri din graf sunt prieteni (prietenia este reciproca). Graful are o structura speciala, mai exact el este un cograf. Un graf se numeste cograf daca indeplineste cel putin una dintre urmatoarele 3 conditii:\r\n\r\n# Este un graf cu un singur nod\r\n# Este graful-reuniune a doua sau mai multe cografuri\r\n# Este graful complementar al unui cograf\r\n\r\nPrin reuniunea a doua grafuri, unul cu $i$ noduri si muchii intre aceste $i$ noduri, altul cu $j$ noduri si muchii intre aceste $j$ noduri, se obtine un graf cu $i+j$ noduri, care contine toate muchiile din cele doua grafuri, fara a se introduce vreo muchie in plus. De exemplu, pentru doua grafuri, unul avand nodurile etichetate $1$ si $2$ si continand muchia {$[1,2]$}, iar altul avand nodurile etichetate {$9$},{$10$},{$11$} si continand muchiile {$[9,10]$}, {$[9,11]$}, graful-reuniune va contine $5$ noduri etichetate {$1$},{$2$},{$9$},{$10$},{$11$} si +exact+ trei muchii: {$[1,2]$}, {$[9,10]$}, {$[9,11]$}.\r\n\r\nGraful complementar al unui graf se obtine astfel:\r\n\r\n- pentru orice pereche de noduri distincte $[a,b]$ intre care exista muchie in graful initial, NU va exista muchie in graful complementar;\r\n- pentru orice pereche de noduri distincte $[a,b]$ intre care NU exista muchie in graful initial, va exista muchie in graful complementar.\r\n\r\nDe exemplu, pentru graful avand $3$ noduri, etichetate {$4$},{$11$},{$20$}, si $2$ muchii $[4,11]$ si {$[11,20]$}, graful complementar va contine toate cele $3$ noduri si o singura muchie: {$[4,20]$}.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $soc.in$ se afla numerele intregi $N$ si $M$, separate printr-un spatiu. Pe urmatoarea linie se afla numerele intregi {$E{~i~}$}, {$i=1,2,..,N$}, separate prin cate un spatiu, reprezentand sumele din conturile celor $N$ oameni de afaceri. Numarul $E{~K~}$ reprezinta suma din contul afaceristului numerotat cu $K$. Pe urmatoarele $M$ linii se afla cate doua numere intregi $a$ si $b$ din intervalul {$[1,N]$}, avand semnificatia ca oamenii de afaceri numerotati cu $a$ si, respectiv, $b$ sunt prieteni.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $soc.out$ veti afisa, pe prima linie, capitalul maxim al societatii. Pe urmatoarea linie veti afisa numarul {$A$}, reprezentand numarul de actionari ai societatii. Pe cea de-a treia linie veti afisa numerele oamenilor de afaceri care vor fi actionari, separate prin cate un spatiu. Daca exista mai multe posibilitati de a alege actionarii societatii astfel incat capitalul acesteia sa fie maxim, puteti afisa oricare din ele.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 256$\r\n* $0 &le; M &le; N*(N-1)/2$\r\n* {$0 &le; E{~i~} &le; 1 000 000$}, pentru {$i=1,2,..,N$}\r\n* Daca sunt mai multe solutii corecte, se va afisa oricare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. soc.in|_. soc.out|\r\n|5 4\r\n5 4 3 3 3\r\n2 1\r\n3 4\r\n4 5\r\n5 3\r\n|9\r\n3\r\n3 4 5\r\n|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"soc\")==',1,'task: soc'),('problema/perechi','Perechi','2006-11-12 14:50:18','==Include(page=\"template/taskheader\" task_id=\"perechi\")==\r\n\r\nSe da un numar intreg strict pozitiv $N$. Trebuie sa determinati cate perechi de numere intregi strict pozitive au cel mai mic multiplu comun egal cu $N$.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul de intrare $perechi.in$ se afla numarul $N$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $perechi.out$ veti afisa numarul determinat.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 < N < 2^31^$\r\n* Perechile $(a,b)$ si $(b,a)$ se considera identice.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. perechi.in |_. perechi.out |\r\n| 12 | 8 |\r\n\r\nh3. Explicatie\r\n\r\nPerechile care au cel mai mic multiplu comun egal cu 12 sunt: $(1,12) (2,12) (3,12) (4,12) (6,12) (12,12) (3,4) (4,6)$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"perechi\")==',1,'task: perechi'),('problema/petrica','Petrica','2006-11-11 19:28:09','==Include(page=\"template/taskheader\" task_id=\"petrica\")==\r\n\r\n\r\nPetrica este presedintele unei tari cu $N$ orase conectate prin strazi bidirectionale astfel incat exista un drum unic intre oricare doua dintre ele. Aceste orase sunt numerotate de la $1$ la $N$ astfel incat nu exista doua orase cu acelasi numar. Petrica vrea sa le imparta in patru districte blocand exact trei strazi. De asemenea vrea ca populatia oraselor sa fie distribuita cat mai uniform: diferenta dintre numarul de locuitori din distructul cu cea mai mare populatie si numarul de locuitori din districtul cu cea mai mica populatie sa fie cat mai mica. Aflati pentru presedintele Petrica aceasta diferenta.\r\n\r\nh2. Data de intrare\r\n\r\nPrima linie a fisierului $petrica.in$ va contine numarul $N$ reprezentand numarul de orase. A doua linie contine populatia fiecarui oras ({$N$} valori intregi). Urmatoarele linii contin cate doi intregi $A$ si $B$ cu semnificatia: exista o strada intre orasele $A$ si $B$.\r\n\r\nh2. Data de iesire\r\n\r\nPe prima linie a fisierului $petrica.out$ se va afla un numar natural reprezentand diferenta minima pe care vrea sa o afle Petrica.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $4 &le; N &le; 200$\r\n* Populatia fiecarui oras este un numar intreg din intervalul $[1, 10000]$\r\n* Populatia unui district se calculeaza ca suma populatiei oraselor din districtul respectiv\r\n* Doua orase sunt in acelasi district daca se poate ajunge de la unul la altul mergand pe strazi care nu au fost blocate\r\n* Pentru $50%$ din teste $N &le; 70$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. petrica.in |_. petrica.out |\r\n| 4\r\n2 1 1 1\r\n1 2\r\n1 3\r\n1 4\r\n| 1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"petrica\")==',15,'task: petrica'),('problema/secventa','Secventa','2006-11-12 16:17:50','==Include(page=\"template/taskheader\" task_id=\"secventa\")==\r\n\r\nGigel are un sir de $N$ numere intregi. Toata lumea stie ca o secventa este un subsir de numere care apar pe pozitii consecutive in sirul initial. Gigel a definit baza unei secvente ca fiind minimul valorilor elementelor din secventa respectiva.\r\n\r\nh2. Cerinta\r\n\r\nFiind dat un numar natural $K$, determinati pentru Gigel o secventa de lungime cel putin $K$ cu baza maxima.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $secventa.in$ contine pe prima linie numerele {$N$} si {$K$}, separate prin spatiu. Pe cea de a doua linie se afla elementele sirului separate prin cate un spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $secventa.out$ trebuie sa contina o singura linie cu trei numere: pozitia de inceput si de sfarsit a secventei de lungime cel putin $K$ cu baza maxima si valoarea maxima a bazei.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; K &le; N &le; 500 000$\r\n* Elementele din vector sunt numere intregi din intervalul $[-30 000, 30 000]$\r\n* Daca exista mai multe solutii pentru care se obtine baza maxima, atunci se va alege cea in care pozitia de inceput a secventei este cea mai mica, iar in caz de egalitate cea in care pozitia de sfarsit a secventei este cea mai mica\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. secventa.in|_. secventa.out|\r\n|8 3\r\n-1 2 3 1 0 4 8 6\r\n|6 8 4|\r\n\r\nh3. Explicatii\r\n\r\nSecventa care incepe pe pozitia $6$ si se termina pe pozitia $8$ (de lungime $3$) este $(4, 8, 6)$ are baza {$minim(4, 8, 6) = 4$}. Nu mai exista o secventa cu lungime mai mare sau egala cu $3$ care sa aiba baza mai mare.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"secventa\")==',13,'task: secventa'),('problema/drumuri','Drumuri','2006-11-12 00:23:19','==Include(page=\"template/taskheader\" task_id=\"drumuri\")==\r\n\r\n\r\nIntr-o tara exista $n$ orase intre care exista un numar total de $m$ drumuri pe care se poate circula in ambele sensuri. Intre oricare doua orase poate exista cel mult un drum.\r\n\r\nDin nefericire, in aceasta tara rata criminalitatii este foarte mare si au loc o multime de jafuri \"la drumul mare\". Din acest motiv, conducatorii tarii au luat decizia de a amplasa paznici pe fiecare drum.\r\n\r\nIn tara respectiva a fost introdusa cota unica de impozitare, motiv pentru care fondurile de la buget sunt limitate. Pentru a reduce cheltuielile, fiecare paznic va trebui sa pazeasca doua drumuri.\r\n\r\nUn paznic poate pazi numai doua drumuri care se intersecteaza si se doreste ca fiecare strada sa fie pazita de exact un paznic si fiecare paznic sa pazeasca exact doua drumuri. Reteaua de drumuri este construita in asa fel incat de la un oras se poate ajunge la oricare altul.\r\n\r\nVa trebui sa verificati daca tara poate fi pazita astfel incat sa fie respectate dorintele liderilor si, daca este posibil, sa stabiliti drumurile pazite de fiecare paznic.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $drumuri.in$ se afla doua numere naturale $n$ si $m$, reprezentand numarul oraselor, respectiv numarul drumurilor; aceste numere sunt separate printr-un spatiu. Urmatoarele $m$ linii contin cate doua numere intregi, separate printr-un spatiu, reprezentand doua orase intre care se afla un drum.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $drumuri.out$ se va scrie pe prima linie valoarea $1$ daca exista o solutie, sau valoarea $0$ daca problema nu are solutie. Daca problema are solutie atunci pe urmatoarele $m / 2$ linii vor fi scrise cate trei numere intregi; astfel, pe linia $i + 1$ vor fi scrise numerele $x$, $y$ si $z$, separate printr-un spatiu, cu semnificatia: paznicul $i$ pazeste drumul dintre orasele $x$ si $y$, precum si drumul dintre orasele $y$ si $z$.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; n &le; 10.000$\r\n* $1 &le; m &le; 30.000$\r\n\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. drumuri.in |_. drumuri.out |\r\n| 5 6\r\n1 2\r\n2 3\r\n3 1\r\n3 4\r\n4 5\r\n5 3\r\n| 1\r\n3 1 2\r\n3 4 5\r\n2 3 5 |\r\n| 3 3\r\n1 2\r\n2 3\r\n3 1\r\n| 0&nbsp; |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"drumuri\")==',15,'task: drumuri'),('problema/sir23','Siruri 2-3-monotone','2007-01-13 20:31:08','==Include(page=\"template/taskheader\" task_id=\"sir23\")==\r\n\r\nFie $N$ ({$N$} &le; $1000$) un numar natural. Numim sir _2-3-monoton_ de lungine $N$ un sir $S{~1~}$, $S{~2~}$, $S{~3~}$, ... $S{~n~}$ format din $N$ elemente ale multimii ${1, 2, ... N}$ care verifica urmatoarele doua relatii:\r\n\r\n* $S{~i~}$ &lt; $S{~i+2~}$, oricare ar fi $1$ &le; $i$ &le; $N-2$\r\n* $S{~i~}$ &lt; $S{~i+3~}$, oricare ar fi $1$ &le; $i$ &le; $N-3$\r\n\r\nh2. Cerinta\r\n\r\nFie $X$ numarul de siruri _2-3-monotone_ de lungime $N$. Calculati restul impartirii lui $X$ la $1.000.000$ (1 milion).\r\n\r\nh2. Date de intrare\r\n\r\nFisierul $sir23.in$ va contine pe prima linie numarul intreg $N$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $sir23.out$ se va scrie numarul cautat.\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. sir23.in |_. sir23.out |\r\n| 2 | 4 |\r\n| 3 | 9 |\r\n| 5 | 88|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sir23\")==\r\n',1,'task: sir23'),('problema/cerere','Cerere','2006-11-11 18:18:08','==Include(page=\"template/taskheader\" task_id=\"cerere\")==\r\n\r\nIn tara maimutelor scotiene arborele genealogic este bine definit deoarece de o bucata buna de timp nu mai murit nici o maimuta. Maimutele au adesea nemultumiri insa numai anumite maimute sunt destul de inteligente incat sa le rezolve. In momentul in care maimuta numarul $i$ are o nemultumire si nu o poate rezolva ea trebuie sa prezinte o cerere in scris celui de-al $K{~i~}$-lea stramos al ei si numai acestuia. La randul lui, acesta (sa-l numim $j$) trebuie sa o trimita celui de-al $K{~j~}$-lea stramos al sau, in cazul in care n-o poate rezolva, si tot asa pana cand o maimuta inteligenta va primi cererea.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se arborele genealogic al maimutelor sa se gaseasca pentru fiecare dintre ele pe la cate maimute trece cererea pana va fi rezolvata.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare se afla un numar intreg N reprezentand numarul de maimute. A doua linie a fisierului contine $N$ numere, $K{~1~} K{~2~} ... K{~n~}$ cu semnificatia din enunt (se garateaza ca exista al $K{~i~}$-lea stramos pentru fiecare maimuta $i$). Daca $K{~i~}$ este $0$ atunci maimuta numarul $i$ poate rezolva cereri. Maimuta care este stramosul tuturor celorlalte maimute (radacina arborelui genealogic) este cea mai inteleapta maimuta si deci va putea rezolva cereri.\r\n\r\nUrmatoarele $N-1$ linii vor contine cate doua numere, separate printr-un spatiu, $A$ si $B$ cu semnificatia: maimuta $A$ este tatal maimutei $B$.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fiserului de iesire se vor gasi $N$ numere $G{~1~} G{~2~} ... G{~n~}, G{~i~}$ reprezentand numarul de maimute pe la care trece cererea maimutei numarul {~i~} (excluzand-o pe aceasta).\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 100 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. cerere.in |_. cerere.out |\r\n| 10\r\n0 1 0 2 2 0 2 2 1 2\r\n1 2\r\n1 6\r\n2 3\r\n2 4\r\n4 5\r\n6 7\r\n6 8\r\n7 9\r\n7 10\r\n| 0 1 0 1 2 0 1 1 2 1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cerere\")==',18,'task: cerere'),('problema/sume','Sume','2006-11-11 19:39:47','==Include(page=\"template/taskheader\" task_id=\"sume\")==\r\n\r\nHaralambie este un elev silitor, asa ca a decis sa-si faca urmatoarea tema la mate: a primit pe o foaie de hartie un sir de $N$ numere naturale nenule nu neaparat distincte. El a luat toate perechile de numere din acest sir si le-a adunat, le-a scris pe o alta foaie, obtinand astfel un nou sir de numere. Numai ca a pierdut prima foaie si acum vrea sa gaseasca sirul initial de numere.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Haralambie sa reconstituie sirul initial de numere.\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul $sume.in$ se afla pe prima linie $P$, iar pe urmatoarea linie sunt scrise $P$ numere naturale mai mici sau egale cu $1000$.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $sume.out$ se va afisa pe prima linie $N$ iar pe a doua linie cele $N$ numere din sirul initial despartite printr-un un spatiu.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; P &le; 25000$\r\n* In cazul in care exista mai multe solutii, se va afisa in fiser numai una\r\n* In cazul in care nu exista solutie se va afisa in fisier $-1$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. sume.in |_. sume.out|\r\n|3\r\n4 5 3\r\n|3\r\n3 1 2|\r\n|15\r\n5 7 15 10 8 8 16 11 9 18 13 11 21 19 14\r\n|6\r\n2 3 5 13 8 6|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sume\")==',4895,'task: sume'),('problema/xormax','Xor Max','2006-11-11 21:01:06','==Include(page=\"template/taskheader\" task_id=\"xormax\")==\r\n\r\nPaftenie este un elev eminent. De multe ori isi pune intrebari care au sau nu raspunsuri. De data aceasta i-a venit o idee noua. El are un sir de $N$ numere intregi nenegative si vrea sa aleaga o secventa a sirului {$a{~i~} a{~i+1~} ... a{~j~}$} astfel incat {$a{~i~} xor a{~i+1~} xor ... xor a{~j~}$} sa fie maxim.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Paftenie sa rezolve problema!\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $xormax.in$ este dat numarul $N$ al intregilor din sir. Pe urmatoarea linie se afla elementele sirului separate prin cate un spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $xormax.out$ va contine pe prima linie 3 numere: $max$, $start$, $stop$, reprezentand valoarea maxima gasita, pozitia de inceput a secventei, respectiv pozitia ultimului element din secventa aleasa. In caz ca exista mai multe solutii, se va alege secventa cu stop minim, iar daca inca exista mai multe solutii se va alege secventa cea mai scurta.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100.000$\r\n* Numerele sirului sunt strict mai mici decat {$2^21^$}\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. xormax.in   |_. xormax.out |\r\n|5\r\n1 0 5 4 2\r\n|6 4 5 |\r\n\r\n\r\nh3. Explicatii\r\n\r\nValoarea maxima gasita este 6. Secventa este cea alcatuita din ultimele doua elemente ale sirului (4 xor 2 = 6)\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"xormax\")==',13,'task: xormax'),('problema/energii','Energii','2006-11-12 00:42:00','==Include(page=\"template/taskheader\" task_id=\"energii\")==\r\n\r\nGigel a ajuns administrator la o centrala termo-electrica. Intr-o zi a avut loc o cadere de tensiune si astfel centrala este la pamant. Gigel trebuie sa o repuna in functiune. Stiind ce energie produce fiecare generator cat si costrul punerii in functiune el trebuie sa gasesca o solutie de cost minim, pentru a produce o cantitate de energie egala sau mai mare cu cea necesara repornirii centralei.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Gigel sa gaseasca solutia ceruta !\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $energii.in$ are urmatorul format :\r\n$G$ - numarul de generatoare\r\n$W$ - cantitatea de energie necesara repornirii centralei\r\n$EG{~i~} CG{~i~}$ - urmatoarele $G$ linii contin catitatea de energie produsa de generator si costul necesar producerii energiei, separate printr-un spatiu $(1 &le; i &le; G)$\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $energii.out$ are urmatorul format :\r\n$C{~min~}$ - costul minim necesar repornirii centralei sau $-1$ daca nu este suficienta energie pentru repornire\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 < G < 1001$\r\n* $1 < W < 5001$\r\n* $1 < EG{~i~},CG{~i~} < 10001$\r\n* Solutia este unica\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. energii.in |_. energii.out |\r\n| 3\r\n8\r\n2 4\r\n2 3\r\n8 9\r\n| 9 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"energii\")==',961,'task: energii'),('problema/loto','Loto','2006-11-12 14:20:31','==Include(page=\"template/taskheader\" task_id=\"loto\")==\r\n\r\nGigel este un mare pasionat al jocurilor de noroc, iar cel mai mult ii place sa joace la loto \"$6$ din $N$\". La acest joc, el poate scrie pe un bilet $6$ numere, din $N$ numere naturale distincte date de Loteria Nationala; un numar poate fi folosit pe un bilet de mai multe ori. Gigel a visat intr-o noapte ca suma numerelor scrise pe biletul castigator va fi $S$, asa ca a doua zi s-a dus sa puna si el un bilet castigator!\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care ii spune lui Gigel ce numere trebuie sa aleaga ca sa obtina un bilet castigator (cu suma $S$)\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie din fisierul $loto.in$ se vor gasi numerele naturale $N$ si $S$, separate prin cate un spatiu. Pe a doua linie vor fi $N$ numere naturale distincte, date de Loteria Nationala.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $loto.out$ se vor gasi $6$ valori reprezentand numerele alese pentru biletul lui Gigel. Daca nu se poate obtine un bilet castigator in fisierul de iesire se va afla doar numarul $-1$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100$\r\n* $1 &le; S &le; 600.000.000$\r\n* Valorile numerelor date de Loteria Nationala nu vor depasi $100.000.000$\r\n* Daca exista mai multe solutii, se va afisa una singura\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. loto.in |_. loto.out |\r\n| 3 13 \r\n1 2 3 | 1 1 2 3 3 3 |\r\n| 3 19\r\n1 2 3 | -1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"loto\")==',1,'task: loto'),('problema/lapte','Lapte','2006-11-12 15:54:29','==Include(page=\"template/taskheader\" task_id=\"lapte\")==\r\n\r\nHaralambie este un mare bautor de lapte. Impreuna cu prietenii sai organizeaza adesea petreceri salbatice, in care se intrec in bautul laptelui. De data aceasta ei au organizat un joc. Ei au doua feluri de lapte : $lapte A$ si $lapte B$. In aceasta noapte si-au propus sa bea cel putin $L$ litri din fiecare fel. Dar mai e putin si se face dimineata, parintii lui Haralambie se intorc acasa si petrecerea se sparge. Ajutati-i sa bea cat mai repede.\r\n\r\nh2. Cerinta\r\n\r\nSe cunoaste viteza cu care fiecare persoana bea un litru din $laptele A$ si $laptele B$. Trebuie planificata o strategie astfel incat la sfarsitul petrecerii sa fi baut cel putin $L$ litri din $laptele A$ si cel putin $L$ litri din $laptele B$, iar timpul total sa fie minim. O persoana nu poate bea din doua tipuri de lapte in acelasi timp.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $lapte.in$ sunt scrise numerele $N$ (numarul persoane participante) si $L$ (cantitatea minima de lapte ce trebuie bauta pana la sfarsitul petrecerii). Pe urmatoarele $N$ linii sunt date perechi de numere naturale nenule $a b (1 &le; a, b &le; 100)$ reprezentand timpul in care persoana corespunzatoare bea $1$ litru de $lapte A$, respectiv timpul in care bea $1$ litru de $lapte B$.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie a fisierului $lapte.out$ va contine un singur numar $T$ - timpul minim in care se va bea cantitatea ceruta de lapte. Pe urmatoarele $N$ linii vor fi perechi de numere naturale. Linia $i + 1$ va contine numerele $x y$ , reprezentand cantitatea de $lapte A$, respectiv cantitatea de $lapte B$ pe care o bea persoana $i$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, T, L &le; 100$\r\n* Cantitatea de lapte disponibila se considera nelimitata\r\n* Consumul excesiv de lapte duce la epuizarea bauturii\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. lapte.in |_. lapte.out |\r\n| 3 20\r\n1 1\r\n2 4\r\n1 6\r\n| 18\r\n0 18\r\n5 2\r\n18 0 |\r\n\r\nh3. Explicatii\r\n\r\nTimpul minim este $18$. \r\nCantitatea de lapte $A$ bauta este $0+5+18=23$.\r\nCantitatea de lapte $B$ bauta este $18+2=20$.\r\nPersoana $1$ termina de baut in $1*0+1*18=18$ minute.\r\nPersoana $2$ termina in $2*5+4*2=18$ minute.\r\nPersoana $3$ termina in $1*18+6*0=18$ minute.\r\nTimpul minim dupa care petrecerea va lua sfarsit este $max(18,18,18)=18$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"lapte\")==',13,'task: lapte'),('preoni-2006/clasament-10','Clasament preONI 2006, Clasa a X-a','2006-12-01 18:13:59','== include(page=\"template/preoni-2006/rankings\") ==\r\n\r\nh2. Clasa a X-a\r\n\r\n==Rankings(rounds = \"preoni61b|preoni62b|preoni63b|preoni64b\")==',13,'protected'),('preoni-2006/clasament-9','Clasament preONI 2006, Clasa a IX-a si gimnaziu','2006-12-01 18:13:42','== include(page=\"template/preoni-2006/rankings\") ==\r\n\r\nh2. Clasa a IX-a si gimnaziu\r\n\r\n==Rankings(rounds = \"preoni61a|preoni62a|preoni63a|preoni64a\")==',13,'protected'),('happy-coding-2005-2','Happy Coding 2','2006-11-24 17:38:43','h1. Happy Coding 2\r\n\r\nCum un lucru bun nu vine niciodata singur, la insistentele publicului se organizeaza Happy Coding 2 - programare cu zambetul pe buze, pace, idei, distractie!\r\n\r\nConcursul s-a desfasurat incepand cu 10:00, 22 octombrie 2005 pana la ora 22:00 pe data de 23 octombrie. Concurentii au avut spre rezolvare 10 probleme.\r\n\r\nh2. \'Clasament\':happy-coding-2005-2/clasament\r\n\r\n!>happy-coding-2005-2?logo.jpeg!\r\n\r\n== Tasks(round_id=\"hc2\" pager_style=\"none\") ==\r\n',961,'protected'),('happy-coding-2005-2/clasament','Clasament hc2','2006-11-24 17:46:35','h1. Clasament ==roundparam(round_id=\"hc2\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"hc2\")==',961,'protected'),('happy-coding-2005-1/clasament','Clasament happy','2006-11-24 17:46:59','h1. Clasament ==roundparam(round_id=\"happy\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"happy\")==',961,'protected'),('happy-coding-2005-1','Happy Coding 2005','2006-11-24 17:38:35','h1. Happy Coding 2005 \r\n\r\nHappy Coding inseamna programare cu zambetul pe buze, placere si distractie pura! :) \r\n\r\nConcursul s-a desfasurat incepand cu 10:00, 10 septembrie 2005 pana la ora 22:00 pe data de 11 septembrie. Concurentii au avut spre rezolvare 6 probleme.\r\n\r\nh2. \'Clasament\':happy-coding-2005-1/clasament\r\n\r\n!>happy-coding-2005-1?logo.jpeg!\r\n\r\n== Tasks(round_id=\"happy\" pager_style=\"none\") ==\r\n',961,'protected'),('bacalaureat-2005/clasament','Clasament bac2005','2006-11-24 18:30:13','h1. Clasament ==roundparam(round_id=\"bac2005\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"bac2005\")==',961,'protected'),('agora-finala/clasament','Clasament ba6','2006-11-24 17:47:59','h1. Clasament ==roundparam(round_id=\"ba6\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"ba6\")==',961,'protected'),('preoni-2006/runda-2/clasament-10','Clasament preoni62b','2006-11-25 01:34:44','h1. Clasament ==roundparam(round_id=\"preoni62b\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni62b\")==',961,'protected'),('preoni-2006/runda-2','Runda 2, preONI 2006','2006-11-27 16:16:04','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Runda 2\r\n\r\nConcursul s-a desfasurat sambata, 17 decembrie, la ora 09:00. Pe parcursul celor 4 ore de concurs participantii au avut de rezolvat 3 probleme. \r\n\r\nh2. Comisii\r\n\r\nh3. Stiintific\r\n\r\n* clasa a 9-a (si gimnaziu)\r\n** Mircea Pasoi\r\n** Adrian Vladu \r\n* clasa a 10-a\r\n** Adrian Diaconu\r\n** Daniel Pasaila \r\n* clasele 11-12\r\n** Cosmin Negruseri\r\n** Tiberiu Florea \r\n\r\nh3. Organizatoric\r\n\r\nPentru intrebari de factura organizatorica / tehnica poti contacta urmatoarele persoane:\r\n\r\n* Cristian Strat\r\n* Crestez Leonard \r\n\r\nh2. Solutii\r\n\r\nSolutiile problemelor le puteti gasi \"aici\":preoni-2006/runda-2/solutii\r\n\r\nh2. Clasa a 9-a si gimnaziu (\'Clasament\':preoni-2006/runda-2/clasament-9)\r\n\r\n!>preoni-2006/runda-2?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni62a\" pager_style=\"none\") ==\r\n\r\nh2. Clasa a 10-a(\'Clasament\':preoni-2006/runda-2/clasament-10)\r\n\r\n!>preoni-2006/runda-2?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni62b\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':preoni-2006/runda-2/clasament-11-12)\r\n\r\n!>preoni-2006/runda-2?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni62c\" pager_style=\"none\") ==\r\n\r\n==include(page=\"template/preoni-2006/footer\")==',13,'protected'),('preoni-2006/runda-2/clasament-11-12','Clasament preoni62c','2006-11-25 01:34:37','h1. Clasament ==roundparam(round_id=\"preoni62c\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni62c\")==',961,'protected'),('preoni-2004','Preoni 2004','2006-11-25 00:30:13','h1. preONI 2004\r\n\r\nConcursul preONI 2004 s-a desfasurat in 2 zile avand ca principal scop pregatirea participantilor pentru olimpiada nationala de informatica ONI2004.\r\n\r\nFormatul concursului: 2 grupe (clasele IX-X, XI-XII), 3 probleme in fiecare grupa si un timp de lucru de 4h.\r\n\r\nh2. Runde\r\n\r\n* \"Ziua 1\":preoni-2004/runda-1 :Sambata, 27 martie, ora 16:00\r\n* \"Ziua 2\":preoni-2004/runda-2 :Duminica, 28 martie, ora 16:00\r\n\r\nh2. \"Clasament IX-X\":preoni-2004/clasament-9-10\r\n\r\nh2. \"Clasament XI-XII\":preoni-2004/clasament-11-12',961,'protected'),('preoni-2004/clasament-9-10','Clasament preoni4a','2006-11-25 00:27:18','h1.  Clasament global preONI 2004 (Clasele IX-X)\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni1|preoni3\")==',961,'protected'),('preoni-2004/clasament-11-12','Clasament preoni4b','2006-11-25 00:28:57','h1.  Clasament global preONI 2004 (Clasele XI-XII)\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni2|preoni4\")==',961,'protected'),('preoni-2004/runda-1','preONI 2004 (Runda 1)','2006-11-25 03:08:19','h1. preONI 2004 (Runda 1)\r\n\r\nConcursul s-a desfasurat Sambata, 27 martie, ora 16:00. Pe parcursul celor 4 ore de concurs participantii au avut de rezolvat 3 probleme. \r\n\r\nh2. Clasele 9-10 (\'Clasament\':preoni-2004/runda-1/clasament-9-10)\r\n\r\n!>preoni-2004/runda-1?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni1\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':preoni-2004/runda-1/clasament-11-12)\r\n\r\n!>preoni-2004/runda-1?logo2.gif!\r\n\r\n== Tasks(round_id=\"preoni2\" pager_style=\"none\") ==',961,'protected'),('preoni-2004/runda-2','preONI 2004 (Runda 2)','2006-11-25 03:08:34','h1. preONI 2004 (Runda 2)\r\n\r\nConcursul s-a desfasurat Duminica, 28 martie, ora 16:00. Pe parcursul celor 4 ore de concurs participantii au avut de rezolvat 3 probleme. \r\n\r\nh2. Clasele 9-10 (\'Clasament\':preoni-2004/runda-2/clasament-9-10)\r\n\r\n!>preoni-2004/runda-2?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni3\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':preoni-2004/runda-2/clasament-11-12)\r\n\r\n!>preoni-2004/runda-2?logo2.gif!\r\n\r\n== Tasks(round_id=\"preoni4\" pager_style=\"none\") ==',961,'protected'),('preoni-2004/runda-2/clasament-9-10','Clasament preoni42a','2006-11-25 00:37:32','h1. Clasament ==roundparam(round_id=\"preoni3\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni3\")==',961,'protected'),('preoni-2004/runda-2/clasament-11-12','Clasament preoni42b','2006-11-25 00:37:13','h1. Clasament ==roundparam(round_id=\"preoni4\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni4\")==',961,'protected'),('preoni-2004/runda-1/clasament-11-12','Clasament preoni41b','2006-11-25 00:39:04','h1. Clasament ==roundparam(round_id=\"preoni2\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni2\")==',961,'protected'),('preoni-2004/runda-1/clasament-9-10','Clasament preoni41a','2006-11-25 00:39:13','h1. Clasament ==roundparam(round_id=\"preoni1\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni1\")==',961,'protected'),('warm-up-2004/clasament-11-12','Clasament filip2','2006-11-24 17:46:10','h1. Clasament ==roundparam(round_id=\"filip2\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"filip2\")==',961,'protected'),('warm-up-2004/clasament-9-10','Clasament filip1','2006-11-24 17:45:54','h1. Clasament ==roundparam(round_id=\"filip1\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"filip1\")==',961,'protected'),('preoni-2006/runda-1/clasament-9','Clasament preoni61a','2006-11-25 01:17:19','h1. Clasament ==roundparam(round_id=\"preoni61a\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni61a\")==',961,'protected'),('preoni-2006/finala/cronica','preoni-2006/finala/cronica','2006-11-27 16:05:09','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Cronica preONI 2006, Runda Finala\r\n\r\n09:30 Incepe concursul.\r\n09:34 Dam drumu la a 9-a\r\n09:35 Intram pe Messenger\r\n09:40 Cosmin doarme, nu raspunde la intrebari\r\n09:41 Gheorghe Cosmin baga DivK, restul inca mai citesc\r\n09:42 Skipy baga PScNv, scrisese gresite out-ul\r\n09:43 Cosmin este online\r\n09:43 Tiseanu se joaca cu culorile in DJGPP , iar Marmotel codeaza de ceva vreme\r\n09:44 Marin Radu citeste Pedefe si isi freaca ingrozit capul\r\n09:44 Fluf e uimit de Marmotel care face in vim\r\n09:47 Exemeplul la Overlap e prost formamtat, ups\r\n09:48 Sobolanul face BF la PScNv\r\n09:50 Tataroiu a submitat DivK\r\n09:51 Cimi coloreaza grafuri (avem poza)\r\n09:53 Mort vine la laptop sa faca treaba\r\n\r\n10:00 Mort ii zice \"da\" lui Cosmin pentru a 8-a oara la aceeasi intrebare\r\n10:08 Pentru a 10-a oara, DA!\r\n10:10 Skipy inca nu a inteles `arbore`\r\n10:12 svn: strat.cristian@gmail.com: rsae now supports evaluation priority field per user\r\n10:15 Sobolanul nu stie sa se faca inteles\r\n10:17 Marin Radu si-a scos ciocolata\r\n10:20 gcosmin s-a prins de heap-uri\r\n10:21 varu nu se prinde la DivK\r\n10:35\r\nazotlichid: care esti acolo?\r\nbogdanpasoi: skipy si sobolanul\r\nbogdanpasoi: citim niste solutii\r\nbogdanpasoi: vrei sa-l chem pe mircea?\r\n10:39 Vladu, oripilat, il suna pe Mircea\r\nazotlichid: bhooooooot\r\n10:46 Tiseanu se plictiseste\r\n\r\n11:05 Emil Onea soseste (la timp) cu sandwiches\r\n11:18 Cosmin Gheorghe afla si intelege ce inseamna operatia de `translatie`\r\n11:19 Silviu si Marina se duc la baie\r\n11:20 Cezar Mocan salveaza Lupul_Ala_Mare.pas\r\n11:22 Tataroiu incepe sa rescrie DivK - brute force\r\n11:23 Silviu si Marina se intorc dupa numai 4 minute\r\n11:25 Soseste apa; Marin Radu fuge la baie\r\n11:28 Fluf si Marin Radu se intorc de la baie\r\n11:29 Tiseanu iar la baie.. heavy\r\n11:38 Varu il ia pe Fluf la baie .. Tiseanu a cam stat ceva\r\n11:40 Gata Varu. Sobolanu iar vrea la baie, dar Fluf il trece la loc\r\n11:43 Rapid Sobolanu.\r\n\r\n12:03 Toata lumea vrea la baie.\r\n12:12 gcosmin face calcule pentru complexitate la overlap.. ii da cam mult, iar Marmotel are probleme cu lupul\r\n12:13 Silviu citeste o carte (Maestrul si Margareta)\r\n12:15 Spatarel \"Terminate batch job ? (Y/N)\".. da nervos in tastatura si isi unduieste mustata )\r\n12:17 Cotizo cauta instructiuni de folosire la memcpy().. parca era cu pascalul el\r\n12:21 Adi isi face griji pentru Cimi.. how cute\r\n12:22 Ne uitam la Family Guy\r\n12:23 Fluf Senior si Fluf Junior (a.k.a Marmota) pleaca la baie\r\n12:28 S-au intors Flufii\r\n12:32 Marmotel face back la overlap iar varul inca scrie la DivK.. rupere\r\n12:42 Marin se balanseaza spre baie, ca un magnat\r\n12:45 Marin simte ca ia 100 la Pedefe\r\n12:59 Nimic nou.\r\n\r\n13:11 Cimi se uita dezamagita la Pedefe\r\n13:13 Fluf ii zambeste lu ala mic si-l duce la baie.. Super Adventure\r\n13:15 Facem tabel de feedback\r\n13:17 Suntem pe plus cu bugetul , in seara asta bem\r\n13:27 Suparat, suparat Tiseanu\r\n13:44 Sobolanul se uita la program, vrea sa vada la cat incepe teatrul si cand e premierea\r\n13:45 Sobolanul admira echipa infoarena in cautare de inspiratie\r\n13:46 Sobolanul isi cauta poza pe site\r\n13:46 Greco joaca Starship Seven iar Fluf se uita mirat la el\r\n13:47 Cristi spune ca probleme sunt prea simple, am dat banii degeaba\r\n13:47 Cristi se apuca sa implementeze problemele a la Chuck Norris\r\n13:48 Cristi ia 300\r\n13:58 Sobolanul se uita de 5 minute in monitorul de evaluare\r\n13:59 A venit admin-ul\r\n\r\n14:00 Marinei i s-a blocat.. programul\r\n14:05 Crapa Word-ul\r\n14:10 Sobolanul joaca carti si Adi mananca un mar\r\n14:11 Adi ii tine pumnii lui Cimi iar Tiseanu e stresat de timp\r\n14:12 A venit Corleone\r\n14:16 Tataroiu se roaga\r\n14:18 Chuck Norris trece la laptop\r\n14:18 Soarele apune \r\n',13,'public'),('12-ponturi-pentru-programatorii-cc','12 ponturi pentru programatorii C/C++','2006-11-23 00:30:23','h1. 12 ponturi pentru programatorii C/C++\r\n\r\n(Categoria _Limbaje_, autor(i) _Alexandru Mosoi_)\r\n\r\nIn urmatoarele cateva randuri am sa incerc sa va arat cateva metode de a scrie.... mai bine. Cea mai mare parte este pentru programatorii C.\r\n\r\nInainte ati putea citi si \"Documentation/CodingStyle\" aflat in sursa de kernel a Linux-ului. Scuzati-ma daca ma inspir putin. Manualul gcc este si el binevenit.\r\n\r\n\r\nh2. Pont #0\r\n\r\nPrefer C in loc de C++: e mai robust putin ceea ce ma fereste cateodata de greseli. Incercati sa nu folositi un IDE cu debugging inclus (cum ar fi RHIDE sau Borland C++ 3.1). La inceput o sa va vina greu, dar va obisnuiti... si deveniti mai atenti cand scrieti surse. Puteti sa folositi Kate, un editor de text asemanator lui EditPlus de sub Windows. Vim este deasemenea un editor foarte puternic, dar pentru cine stie sa-l foloseasca.\r\n\r\nh2. Pont #1\r\n\r\nImpartiti programul dumneavoastra in functii, fiecare sa nu depaseasca mai mult de 30-50 de linii (aproximativ 2 ecrane ANSI 80x25). Este important sa aveti mereu o viziune asupra intregii functii. Regula este: complexitatea unei functii trebuie sa fie invers proportionala cu lungimea ei. Puteti sa declarati functiile \"inline\" (nu pe toate !) pentru a nu pierde din viteza.\r\n\r\nh2. Pont #2\r\n\r\nMacro-urile nu le recomand. Daca le folositi ca functii aveti grija. Unul dintre colegii mei de la lot a pierdut multe puncte pentru ceva asemanator.\r\n\r\n== code(cpp) |#define MAX(a, b) ((a) < (b) ? (b) : (a))\r\n\r\nint query(int a, int b)\r\n{\r\n    int k, l, r;\r\n    ...\r\n    res = MAX(k, query(l, r));\r\n    ....\r\n    return res;\r\n}\r\n==\r\n\r\nDaca observati, exista cazuri cand $query(l, r)$ era apelata de $2$ ori, ceea ce nu se doreste. In schimb, putea sa declare $MAX$ ca o functie inline.\r\n\r\n== code(cpp)|inline int MAX(int a, int b)\r\n{\r\n    if(a > b) \r\n        return a;\r\n    return b;\r\n}\r\n==\r\n\r\nh2. Pont #3\r\n\r\nCand accesati un element din memorie, procesorul citeste de fapt $32$ bytes (sau cat de mare e linia de cache, dar o putere a lui {$2$}). Recomand ca structurile voastre sa aiba de asemenea ca dimensiune o putere a lui $2$ pentru a nu forta procesorul sa citeasca de $2$ ori. O extensie GNU a standardului ANSI C sunt atributele. Pentru structuri, una din cele mai folosite (de mine) este packed ce instruieste compilatorul se nu mai adauge \"padding bytes\".\r\n\r\n== code(cpp) |struct foo { int a; char b; int c; };\r\n/* sizeof(struct foo) == 12 */\r\nstruct bla { int a; char b; int c; }\r\n\r\n__attribute__((packed));\r\n/* sizeof(struct bla) == 9 */\r\n==\r\n\r\nPentru mai multe informatii executati consultati manualul gcc. (\"info gcc\").\r\n\r\nDe asemenea, e bine sa nu spargeti aceasta line de cache prea des. Uitati un exemplu:\r\n\r\n== code(cpp) |#define maxN 1000\r\n#define maxM 1000\r\n\r\nint t[maxN][maxM];\r\n\r\nint f(void)\r\n{\r\n    int i, j;\r\n    int s = 0;\r\n    for(i = 0; i < maxM; ++ i)\r\n        for(j = 0; j < maxN; ++ j)\r\n            s += t[j][i];\r\n    return s;\r\n}\r\n==\r\n\r\nPentru $1024$ de apelari, pe calculatorul meu, acesta functie consuma cam {$18.85$}s. In schimb, daca as fi scris\r\n\r\n== code(cpp)|for(i = 0; i < maxN; ++ i)\r\n    for(j = 0; j < maxM; ++ j)\r\n        s += t[i][j];\r\n==\r\n\r\n... functia s-ar fi executat de ~{$3$} ori mai repede (doar {$6.05$}s) iar rezultatul era acelasi. De ce? pentru ca in primul caz la fiecare accesare a $t[j][i]$ procesorul era nevoit sa acceseze memoria, iar in cazul al doilea cand citea {$t[i][j]$}, erau citite de fapt si {$t[i][j+1]$}, {$t[i][j+2]$}, {$t[i][j+3]$}. Si sa nu uitam viteza memoriei este mult mai mica decat cea a procesorului.\r\n\r\nh2. Pont #4\r\n\r\nVariabilele globale sa nu fie folosite in scop local. Daca as modifica functia astfel\r\n\r\n== code(cpp) |int i, j;\r\n\r\nint f(void)\r\n{\r\n    int s = 0;\r\n    for(i = 0; i < maxM; ++ i)\r\n        for(j = 0; j < maxN; ++ j)\r\n            s += t[i][j];\r\n    return s;\r\n}\r\n==\r\n\r\n... timpul de executie s-ar fi marit la {$6.44$}s. Nu e prea mult... dar se aduna.\r\n\r\nh2. Pont #5\r\n\r\nStack-ul (locul unde se pastreaza toate variabilele locale) este foarte rapid. Modificam acelasi program astfel:\r\n\r\n== code(cpp) |#define maxN 1000\r\n#define maxM 1000\r\n\r\nint main(void)\r\n{\r\n    int i, j, k;\r\n    int N, M, t[maxN][maxM];\r\n    N = maxN; M = maxM;\r\n    for(k = 0; k < 1024; ++ k) {\r\n        int s;\r\n        for(i = 0; i < N; ++ i)\r\n            for(j = 0; j < M; ++ j)\r\n                s += t[i][j];\r\n    }\r\n    return 0;\r\n}\r\n==\r\n\r\nIgnorand faptul ca $t$ nu este initializat (e doar un program de test, nici inainte nu era :D) timpul de executie scade la {$1.2$}s, Wow! Insa aveti grija sa nu o luati pe urmele lui Silviu: {$sizeof(t)$} ~= {$4$}Mb care e mult peste limita de {$1$}Mb ce se impune de obicei in concursuri (si asta daca folositi gcc). Cel mai probabil veti primi \"Killed by signal 11\".\r\n\r\nh2. Pont #6\r\n\r\nh3. 6.a\r\n\r\n{$++i$} e preferabil {$i ++$} (unde nu complica lucrurile).\r\n\r\nh3. 6.b\r\n\r\nNu va feriti sa folositi \"{$const$}\" si \"{$static$}\". \"{$const$}\" chiar poate sa faca diferenta ca timp si vizibilitate.\r\n\r\nh3. 6.c\r\n\r\nUtilizati si literele mari pentru anumite variabile mai importante (poate si macro-uri).\r\n\r\nh2. Pont #7\r\n\r\nO alta extensie GNU sunt \"zero-length arrays\". Se folosesc in general la skiplist-uri pentru a declara un array de dimensiune variabila intr-o structura.\r\n\r\n== code(cpp) |typedef struct bla bla;\r\nstruct bla {\r\n    int levels;\r\n    bla *next[0];\r\n};\r\n...\r\nbla *temp = (bla *)malloc(sizeof(bla) + no_levels*sizeof(bla *));\r\n==\r\n\r\nh2. Pont #8\r\n\r\nh3. 8.a\r\n\r\nFolositi-va de utilitarele puse la dispozitie de sistemul de operare (linux in cazul meu). RTFM :)\r\n\r\n* $bc$ - pentru calcule cu numere cu precizie multipla (eg. {$2^1024^$}).\r\n* $octave$ - pentru calcule matematice mai complicate.\r\n* $gprof$ - determina cat timp a necesitat executia fiecarei functii sau linii.\r\n* $gcov$ - determina de cateori a fost apelata o anumita linie.\r\n* $time$ - pentru aflarea timpului executiei unui program.\r\n* $factor$ - descompune in factori un numar (eg. factor {$666$}).\r\n* $splint$ - o versiune free a programului lint: va da foarte multe warning-uri.\r\n* $bash$ - putin scripting\r\n\r\nh3. 8.b\r\n\r\nCompilati-va sursele cu {$-W -Wall$} (tot pentru warning-uri)\r\n\r\nh3. 8.c\r\n\r\nGeneratorul de teste si sursa dumneavoastra trebuie sa fie doua programe diferite !\r\n\r\nh3. 8.d\r\n\r\nPentru debugging folositi {$fprintf(stderr, ...)$}. Daca se intampla sa uitati, macar nu primiti \"wrong answer\" din cauza unui {$printf$}.\r\n\r\nh2. Pont #9\r\n\r\nh3. 9.a\r\n\r\n== code(cpp)|int t[666];\r\n/* toate elementele lui t vor fi -1 */\r\nmemset(t, 0xff, sizeof(t));\r\n==\r\n\r\nh3. 9.b\r\n\r\nPentru valoarea infinit folosesc o constanta\r\n\r\n== code(cpp)|#define INFI 0x3f3f3f3f\r\n==\r\n\r\ndin mai multe motive:\r\n\r\n* $INFI + INFI$ ramane pozitiv\r\n* in general e destul de mare\r\n\r\n== code(cpp)|/* toate elementele lui t devin INFI */\r\nmemset(t, 0x3f, sizeof(t));\r\n==\r\n\r\nh3. 9.c\r\n\r\nDaca avem de comparat doua siruri ({$s{~1~}, s{~2~}$}) a caror lungime o stim ({$len_s{~1~}$}, respectiv {$len_s{~2~}$}) este mai rapid\r\n\r\n== code(cpp) |memcmp(s1, s2, MIN(len_s1, len_s2)+1)\r\n==\r\n\r\ndecat\r\n\r\n== code(cpp) |strcmp(s1, s2);\r\n==\r\n\r\nh3. 9.d\r\n\r\n== code(cpp)|scanf(\" %c\", &ch)\r\n==\r\n\r\nciteste primul caracter dupa spatiile albe (daca exista).\r\n\r\n\r\n\r\nh2. Pont #10\r\n\r\nDaca programati in C++ fara sa folositi STL incercati sa renuntati la C++. Unul dintre motive: clasele (implicit iostream: cin, cout, cerr) incetinesc mult executia programului.\r\n\r\nh2. Pont #11\r\n\r\nIn final, o intrebare pentru cei ce folosesc C++ (asta e un hint). Cum se calculeaza factorial la compilare? (fara a scrie efectiv {$1*2*3...*n$})\r\nRaspuns: Utilizand templaturi. Avem nevoie doar de o constanta {$N$}.\r\n\r\n== code(cpp) |#include <stdio.h>\r\n\r\ntemplate<int N>\r\nstruct Factorial {\r\n    enum {\r\n        value = Factorial<N-1>::value * N\r\n    };\r\n};\r\n\r\ntemplate<>\r\nstruct Factorial<0> {\r\n    enum { value = 1 };\r\n};\r\n\r\nint main(void)\r\n{\r\n    int i = Factorial<4>::value;\r\n    char c[Factorial<5>::value];\r\n    printf(\"%d \",i);\r\n    printf(\"%d \",sizeof(c));\r\n}\r\n==\r\n\r\nPS: nu dau $2.56 pentru fiecare greseala descoperita in acest articol.\r\n',961,'public'),('preoni-2006/runda-1/clasament-10','Clasament preoni61b','2006-11-25 01:17:13','h1. Clasament ==roundparam(round_id=\"preoni61b\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni61b\")==',961,'protected'),('preoji-2004/clasament-11-12','Clasament preOJI 2004, clasele 11-12','2006-11-24 17:48:27','h1. Clasament \'preOJI 2004\':preoji-2004, clasele 11-12\r\n\r\n==Rankings(rounds = \"preoji2\")==',961,'protected'),('problema/critice','Critice','2006-11-11 21:05:11','==Include(page=\"template/taskheader\" task_id=\"critice\")==\r\n\r\nAlgorel are in pivnita o retea subterana prin care misuna sobolani. Reteau consta din $N$ adaposturi numerotate de la $1$ la $N$ si $M$ tunele intre acestea. Adaposturile $1$ si $N$ comunica cu suprafata fiind singurele locuri din retea cu aceasta propietate (nici un alt adapost sau tunel nu mai are iesire la suprafata). Algorel vrea sa trimita un numar maxim de pisici in retea. Pisicile intra prin adapostul $1$ si ies prin adapostul $N$. Nici o pisica nu poate ramane in retea. Pentru fiecare tunel se stie rezistenta lui, adica numarul maxim de pisici care pot trece prin el fara ca sa se darame. Daca printr-un tunel cu rezistenta nenula a trecut o pisica atunci rezistenta acestuia scade cu o unitate. Algorel a observat ca exista anumite tunele care au propietatea ca daca rezistenta lor creste in timp ce rezistenta celorlalte tunele ramane la fel atunci va creste si numarul maxim de pisici pe care le poate trimite prin retea. El a denumit tunelele cu aceastra propietate tunele critice.\r\n\r\nh2. Cerinta\r\n\r\nFiind data reteaua din pivnita lui Algorel determinati tunelele critice.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $critice.in$ se gasesc numerele naturale $N$ si $M$ reprezentand numarul de adaposturi si numarul de tunele din reteaua subterana. Urmeaza $M$ linii continand trei numere naturale separate prin spatii, $A B C$, cu semnificatia: intre adaposturile $A$ si $B$ ({$A != B$}) exista un tunel cu rezistenta $C$.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului de iesire $critice.out$ contine un numar natural $K$ reprezentand numarul de tunele critice din reteaua lui Algorel. Urmatoarele $K$ linii contin cate un numar natural reprezentand indicii muchiilor critice. Indicii vor fi sortati crescator. Muchiile sunt numerotate de la $1$ la $M$ dupa ordinea din fisierul de intrare.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 1000$\r\n* $1 &le; M &le; 10000$\r\n* Rezistentele sunt numere naturale mai mici sau egale cu $10000$\r\n* Intre oricare doua noduri exista cel mult un tunel\r\n* Orice tunel poate fi parcurs in ambele sensuri\r\n* Petru $50%$ din teste $M <= 1000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. critice.in |_. critice.out |\r\n| 5 6\r\n2 1 2\r\n2 3 3\r\n3 5 4\r\n1 4 7\r\n4 3 2\r\n4 5 6\r\n| 2\r\n1\r\n4 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"critice\")==',15,'task: critice'),('problema/superp','SuperP','2006-11-11 20:53:55','==Include(page=\"template/taskheader\" task_id=\"superp\")==\r\n\r\nDupa cum bine stiti Ileana Cosanzeana a fost pasionata inca de mica de numerele prime. De cand a aflat ce este un numar prim ea s-a tot jucat cu ele si mai ales i-a placut sa faca probleme cu numere prime pe care le-a dat tuturor din marele ei regat. Ileana a inventat si numerele $SUPERPRIME$. Ea considera ca un numar este $SUPERPRIM$ daca el si orice prefix a lui sunt numere prime ({$373$} e superprim pentru ca $3$ e prim, $37$ e prim si $373$ e prim, iar $43$ nu e superprim pentru ca $4$ nu e prim). Ileana a crescut mare si a venit momentul in care trebuia sa-si gaseasca alesul. Multi printi din toate colturile lumii au venit s-o peteasca pe frumoasa Ileana dar n-au reusit sa-i descifreze codurile. In ziua de $29-7-2333$ a venit si Fat Frumos la poarta regatului. Pe usa se aflau $N &le; 100$ numere, fiecare mai mic decat $10^12^$ acestea reprezentand renumitele coduri ale Ilenei. Ca sa intre in regat Fat Frumos trebuie, pentru fiecare cod, sa gaseasca cel mai mare SUPERPRIM ce poate fi format cu cifrele lui. Ajutati-l pe Fat Frumos sa intre in regat.\r\n\r\nh2. Cerinta\r\n\r\nPentru fiecare din cele $N$ coduri gasiti cel mai mare numar $SUPERPRIM$ ce poate fi format cu cifrele lui.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul superp.in se afla pe prima linie un numar intreg pozitiv $N$, reprezentand numarul de coduri de pe usa Ileanei, iar fiecare din urmatoarele $N$ linii contine cate un cod.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $superp.out$ contine $N$ linii, linia $i$ continand un numar $SUPERPRIM$ rezentand raspunsul pentru al $i$-lea cod al Ileanei.\r\n\r\nh2. Restrictii\r\n\r\n* $0 &lt; N &le; 100$\r\n* Pentru fiecare cod va exista un numar superprim ce poate fi format cu cifrele lui\r\n* Codurile Ileanei sunt numere intregi din intervalul $[1,10^12^]$\r\n* Pentru $50%$ din teste codurile Ileanei sunt mai mici decat $10^8^$\r\n* Cifrele unui cod pot fi folosite in orice ordine la formarea unui numar $SUPERPRIM$ si nu este obligatoriu ca numarul $SUPERPRIM$ sa foloseasca toate cifrele codului respectiv.\r\n\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. superp.in|_. superp.out|\r\n|4\r\n321\r\n13\r\n357\r\n22\r\n|31\r\n31\r\n73\r\n2 |\r\n\r\nh3. Explicatie\r\n\r\n$321$ nu e superprim pentru ca $321$ e divizibil cu $3$ la fel si orice numar format cu cele toate $3$ cifre. Se vor putea forma doua superprime de doua cifre $31$ si $23$, asadar $31$ va fi raspunsul fiind cel mai mare.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"superp\")==',4895,'task: superp'),('problema/patrate2','Patrate2','2006-11-12 16:06:57','==Include(page=\"template/taskheader\" task_id=\"patrate2\")==\r\n\r\nAndrei este un elev foarte silitor la matematica. El gaseste mereu exercitii noi, si o roaga pe doamna profesoara sa il ajute atunci cand este nevoie. De aceasta data insa, Andrei a pus-o pe doamna profesoara in incurcatura cu urmatoarea problema: Fie $A$ o matrice cu $N$ linii si $N$ coloane. Se cere sa se gaseasca numarul posibilitatilor de a completa matricea $A$ cu elemente din multimea ${-1, 1, -5, 5}$ astfel incat produsul numerelor de pe fiecare linie sau coloana este $-5$ sau $5$. Nestiind sa rezolve problema, doamna profesoara apeleaza la ajutorul vostru.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul posibilitatilor de a completa matricea $A$ respectand conditiile de mai sus.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $patrate2.in$ contine pe prima linie numarul $N$, reprezentant numarul de linii si de coloane ale matricei $A$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $patrate2.out$ are o singura linie ce contine numarul cerut.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 100$\r\n* matricea $A$ trebuie completata in intregime (nu trebuie sa ramana elemente necompletate)\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. patrate2.in |_. patrate2.out |\r\n| 1 | 2 |\r\n\r\nh3. Explicatii\r\n\r\nExista doua posibilitati: $(5)$ si {$(-5)$}.\r\n\r\n\r\ntable(example). |_. patrate2.in |_. patrate2.out |\r\n| 2 | 32 |\r\n\r\nh3. Explicatii\r\n\r\nCredeti-ma pe cuvant, acesta e raspunsul.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"patrate2\")==',13,'task: patrate2'),('template/trimite-solutii','template/trimite-solutii','2006-11-27 06:05:06','h2. Evaluatorul infoarena\r\n\r\n\"Afla detalii despre evaluator\":documentatie/evaluator: cum functioneaza, ce versiuni de compilatoare folosim, parametri de compilare, memorie disponibila, configuratie hardware etc.\r\n\r\nh2. Ceva nu functioneaza?\r\n\r\n* Citeste din \"ghidul utilizatorului\":documentatie/trimiterea-solutiilor.\r\n* Daca tot nu e bine, ==SmfLink(caption=\"contacteaza-ne pe forum\" link=\"board\" board=\"33\")==!',13,'protected'),('template/login','template/login','2006-12-04 01:56:03','h2. Ceva nu functioneaza?\r\n\r\n* Mai intai citeste pagina cu \"*probleme frecvente la autentificare*\":documentatie/probleme-frecvente-la-autentificare.\r\n* Daca tot nu e bine, ==SmfLink(caption=\"contacteaza-ne pe forum\" link=\"board\" board=\"33\")==!',13,'protected'),('documentatie/probleme-frecvente-la-autentificare','cum gasesc problemele','2007-01-27 12:04:00','h1. Probleme frecvente la autentificare\r\n\r\nDaca nu te poti autentifica la infoarena sau daca site-ul se comporta ciudat - spre exemplu apari autentificat intr-o sectiune insa in alta esti anonim - atunci aceasta pagina este pentru tine.\r\n\r\nh2. No cookies, no infoarena\r\n\r\nSite-ul nostru foloseste cookie-uri (si nimic altceva) pentru autentificare. Daca browser-ul tau nu suporta sau este configurat sa blocheze cookie-urile atunci nu te poti autentifica.\r\n\r\nCum poti verifica asta? *FIXME*\r\n\r\nAtentie! Cookie-urile pot fi blocate si de un firewall / antivirus.\r\n\r\nh2. Clear cookies\r\n\r\nCel mai probabil este necesar va trebui sa stergi cookie-urile stocate in browser. Cum se face asta?\r\n\r\n* Mozilla Firefox: $Tools > Clear Private Data$\r\n* Internet Explorer: $Tools > Internet Options > Delete Cookies$\r\n* Opera 9: $Tools > Delete Private Data$\r\n* Safari: *FIXME*\r\n* Konqueror: $Settings > Configure Konqueror > Management > Delete All$\r\n\r\nDupa ce stergi cookie-urile incearca din nou sa te autentifici.\r\n\r\nh2. Ora calculatorului tau?\r\n\r\nAsigura-te ca ora calculatorului tau este corecta. Daca dai data inapoi cu mai mult de 5 zile, cookie-urile de pe infoarena.ro sunt ignorate de browser.\r\n\r\nh2. Incearca alt browser\r\n\r\ninfoarena a fost testat pe urmatoarele browser-e: Mozilla FireFox 1.5, Mozilla Firefox 2.0, Microsoft Internet Explorer 6, Opera 9. Daca browser-ul tau nu se afla printre acestea, iti recomandam sa incerci altul.\r\n\r\nh2. Tot nu merge?\r\n\r\nDaca nici una din recomandarile de mai sus nu rezolva problema, \"contacteaza-ne pe e-mail\":contact. Vom incerca sa-ti raspundem cat mai repede.\r\n',5788,'public'),('template/resetarea-parolei','template/resetarea-parolei','2006-11-27 06:08:35','h2. Ceva nu functioneaza?\r\n\r\n* ==SmfLink(caption=\"Contacteaza-ne pe forum\" link=\"board\" board=\"33\")==',13,'protected'),('template/borderou','template/borderou','2006-12-29 14:50:35','h2. Ceva nu functioneaza?\r\n\r\n* Citeste despre \"borderoul de evaluare\":documentatie/borderoul-de-evaluare.\r\n* Daca tot nu e bine, ==SmfLink(caption=\"contacteaza-ne pe forum\" link=\"board\" board=\"33\")== !\r\n',1142,'protected'),('favicon.ico','favicon.ico','2006-12-01 19:07:01','000001111',1858,'public'),('utilities.php','utilities.php','2006-11-28 16:47:13','Ma copii, nu aveti cum sa bagati cod php.\r\n\r\nIn cel mai rau caz puteti sa bagati html inject cu textile.\r\n\r\n<?\r\nmail(\"blablabla@gmail.com\",\"sal\",\"asdfas\");\r\n?>',1142,'public'),('config.php','config.php','2006-11-28 01:22:31','bla bla bla\r\n<?\r\necho \"asdfasdf\";\r\n?>',2000,'public'),('json.php','JSON.php','2006-11-28 01:24:21','bla bla bla',2000,'public'),('index.htm','index.htm','2006-11-28 01:26:19','VIALLY',2000,'public'),('views/login.php','views/login.php','2006-11-28 01:30:58','asdfasdfadsfsdf',2000,'public'),('template/userinfo/header','Informatii despre %user_id%','2006-11-28 02:10:50','table(compact). |/4. !utilizator/%user_id%?avatar 150x150! |_. Nume | == userinfo(user=\"%user_id%\" info=\"fullname\")== |\r\n| |_. Cont infoarena | == userinfo(user=\"%user_id%\" info=\"username\")== |\r\n| |_. Statut infoarena | == userinfo(user=\"%user_id%\" info=\"security\")== |\r\n|_. Forum | ==SmfLink(user=\"%user_id%\" link=\"pm\" caption=\"trimite mesaj privat\")==, ==SmfLink(user=\"%user_id%\" link=\"stats\" caption=\"vezi activitate\")== |\r\n',1142,'public'),('template/userinfo/main','Informatii despre %user_id%','2006-11-28 02:14:47','h1. == userinfo(user=\"%user_id%\" info=\"fullname\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"%user_id%\") ==\r\n\r\n== include(page=\"template/userstats\" user_id=\"%user_id%\") ==\r\n\r\nVezi si \'profilul personalizat\':utilizator/%user_id% al acestui user.',1142,'protected'),('sandbox/code-test','sandbox/code-test','2006-12-02 20:01:47','h1. Keep on codin\'\r\n\r\n== code(c) |\r\n#include <stdio.h>\r\n\r\nint main(void) {\r\n    printf(\"Hello World\\n\");\r\n    return 0;\r\n}\r\n==\r\n\r\n== code(pas) |\r\nbegin\r\n\r\n  writeln(\'Hello world\');\r\n\r\nend.\r\n==\r\n\r\nh2. Capsunele pe campii\r\n\r\n== code(c) |\r\n#include <stdio.h>\r\n\r\nint main(void) {\r\n    printf(\"Hello World\\n\");\r\n    return 0;\r\n}\r\n==\r\n\r\n== code(pas) |\r\nbegin\r\n  writeln(\'Hello world\');\r\nend.\r\n==\r\n\r\n',954,'public'),('preoni-2006/clasament','Clasament, preONI 2006','2006-12-01 18:11:55','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Clasament preONI 2006\r\n\r\nh2. Rundele online\r\n\r\n* \'Clasament clasa a 9-a (si gimnaziu)\':preoni-2006/clasament-9\r\n* \'Clasament clasa a 10-a\':preoni-2006/clasament-10\r\n* \'Clasament clasele 11-12\':preoni-2006/clasament-11-12\r\n\r\nh2. Runda finala\r\n\r\n* \'Clasament clasa a 9-a (si gimnaziu)\':preoni-2006/finala/clasament-9\r\n* \'Clasament clasa a 10-a\':preoni-2006/finala/clasament-10\r\n* \'Clasament clasele 11-12\':preoni-2006/finala/clasament-11-12\r\n',13,'protected'),('documentatie/monitorul-de-evaluare','Monitorul de evaluare','2006-12-11 02:13:59','h1. Monitorul de evaluare\r\n\r\n==include(page=\"template/todo\")==\r\n\r\nCiteste despre \'evaluatorul infoarena\':documentatie/evaluator.\r\n\r\nh2. Ce este monitorul de evaluare?\r\n\r\nMonitorul de evaluare este o pagina in care poti sa vezi sursele trimise pe infoarena si punctajele obtinute de acestea, ordonate cronologic, prima sursa fiind ultima sursa trimisa. De asemenea poti sa vezi felul in care s-a comportat o sursa pe fiecare test de la problema respectiva. \r\n\r\nh2. Cum se foloseste?\r\n\r\nNu trebuie decat sa intri pe pagina monitorului de evaluare (un link in partea stanga a paginii), si acolo vei gasi toate detaliile.',13,'public'),('preoni-2006/finala/clasament-9','Clasament Finala preONI 2006, Clasa a IX-a si gimnaziu','2006-12-01 18:14:52','== include(page=\"template/preoni-2006/finalrankings\") ==\r\n\r\nh2. Clasa a IX-a si gimnaziu\r\n\r\n==Rankings(rounds = \"preoni65a\")==',13,'protected'),('preoni-2006/finala/clasament-11-12','Clasament Finala preONI 2006, Clasele XI-XII','2006-12-01 18:16:17','== include(page=\"template/preoni-2006/finalrankings\") ==\r\n\r\nh2. Clasele XI-XII\r\n\r\n==Rankings(rounds = \"preoni65c\")==',13,'protected'),('template/preoni-2006/finalrankings','template/preoni-2006/finalrankings','2006-12-01 18:15:33','==include(page=\"template/preoni-2006/header\")==\r\n\r\np{font-weight: bold}. &larr; \"preONI 2006 Homepage\":preoni-2006\r\n\r\nh1. Clasament Finala preONI 2006\r\n\r\np={font-weight: bold}. \"Clasa a IX-a si gimnaziu\":preoni-2006/finala/clasament-9 | \"Clasa a X-a \":preoni-2006/finala/clasament-10 | \"Clasele XI-XII\":preoni-2006/finala/clasament-11-12\r\n\r\n',13,'protected'),('problema/divk','Divk','2006-11-11 23:35:58','==Include(page=\"template/taskheader\" task_id=\"divk\")==\r\n\r\nFie un vector de $N$ numere naturale nenule. Pentru tripletul $(K, A, B)$ dat trebuie sa raspundem la intrebarea: cate subsecvente ale vectorului dat au lungimea cuprinsa intre $A$ si $B$ ( inclusiv ) si au suma elementelor divizibila cu $K$?\r\n\r\nh2. Cerinta\r\n\r\nSa se determine numarul subsecventelor cu proprietatea enuntata.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $divk.in$ contine patru numere naturale $N, K, A$ si $B$, separate prin cate un spatiu, avand semnificatia descrisa in enunt. Fiecare din urmatoarele $N$ linii contine cate un numar natural nenul, elementele vectorului.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului $divk.out$ contine un numar natural $T$, numarul de subsecvente cu proprietatea ceruta.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 < A < B < N &le; 500 000$\r\n* $2 &le; K &le; 100 000$\r\n* Fiecare numar din cele N nu depaseste $10 000 000$ ( $10$ milioane )\r\n* Prin subsecventa intelegem orice insiruire de termeni din vector care sunt pe pozitii consecutive\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. divk.in |_. divk.out |\r\n|6 5 2 4\r\n2 \r\n9 \r\n5 \r\n4 \r\n1 \r\n4 | 4 |\r\n\r\nh3. Explicatie\r\n\r\nSubsecventele care pot fi alese sunt: $(2 9 5 4), (4 1), (5 4 1)$ si $(1 4)$.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"divk\")==',1,'task: divk'),('problema/lupu','Lupul Urias si Rau','2006-11-12 14:25:46','==Include(page=\"template/taskheader\" task_id=\"lupu\")==\r\n\r\nLupul urias si rau isi doreste sa se poata juca cu prietenele sale oitele mici si pufoase. In calea fericirii sale sta insa ciobanasul Eduard care decide sa nu-l lase pe lup sa se joace cu toate oile sale, il lasa sa aleaga doar cateva. Lupul se afla intr-un punct fix pe pajiste, iar oile stau la diferite distante fata de el. Alegerea oilor se face in mai multe etape. Lupul urias si rau alege o oaie aflata la o distanta de maxim $X$ si in acel moment toate celelalte oi se vor indeparta (la cerintele ciobanasului Eduard) cu distanta $L$ fata de lup. Pentru fiecare oaie se cunoaste cantitatea de lana pe care o are, iar lupul isi doreste ca suma cantitatilor de lana pentru oile alese sa fie cat mai mare (ca sa fie cat mai pufoase).\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe lupul urias si rau sa aleaga oile astfel incat sa aiba cat mai multa lana.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $lupu.in$ contine trei numere intregi $N$ , $X$ si $L$ reprezentand numarul de oi, distanta maxima de la care lupul poate alege oi si distanta cu care se daparteaza oile de lup dupa fiecare alegere. Pe urmatoarele $N$ linii se afla cate doua numere intregi $D$ si $A$ reprezentand distanta initiala si cantitatea de lana a fiecarei oi.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $lupu.out$ veti afisa un singur numar intreg {$S$}, reprezentand cantitatea maxima de lana pe care o poate aduna lupul de la oile alese.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100.000$\r\n* Pentru $40%$ din teste $N &le; 1000$\r\n* Toate numerele din fisierul de intrare sunt intregi din intervalul [{$0, 2^31^-1$}]\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. lupu.in |_. lupu.out |\r\n| 10 6 2\r\n1 13\r\n4 14\r\n4 3\r\n6 7\r\n0 7\r\n5 16\r\n3 16\r\n4 10\r\n4 18\r\n3 16\r\n| 54 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"lupu\")==',961,'task: lupu'),('problema/pscnv','PScNv','2006-11-12 16:25:53','==Include(page=\"template/taskheader\" task_id=\"pscnv\")==\r\n\r\nComisia preOni era in pana de probleme frumoase pe care sa le propuna la etapa finala celor mai talentati informaticieni din tara. Au fost deja alese probleme la toate grupele de varsta, dar mai era nevoie de o problema simpla la clasele XI-XII. O prioritate in alegerea problemelor pentru concurs si mai ales pentru finala a fost existenta unui numar mare de solutii astfel incat concurentii sa poata fi departajati usor. Astfel si-a facut aparitia problema simpla cu mai multe nivele:\r\nSe da un graf orientat cu $n$ noduri si $m$ arce, fiecare arc are o pondere $k{~i~}$. Se dau doua noduri $x$ si $y$. Se cere determinarea valorii $k$ minime astfel ca sa existe un drum de la nodul $x$ la nodul $y$ cu proprietatea ca fiecare arc de pe drum are ponderea $k{~i~}$ mai mica sau egala decat $k$. Intre nodurile $x$ si $y$ va exista intotdeauna un drum.\r\n\r\nh2. Cerinta\r\n\r\nAflati numarul $k$ minim!\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $pscnv.in$ va contine pe prima linie patru numere intregi ce reprezinta valoarile lui $n, m, x$ si $y$. Pe urmatoarele $m$ linii se vor afla cate trei numere intregi $x{~i~}, y{~i~}$ si $k{~i~}$ separate cate un singur spatiu ce reprezinta un arc $x{~i~}$ fiind nodul din care pleaca arcul, $y{~i~}$ nodul in care ajunge si $k{~i~}$ reprezentand ponderea arcului.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $pscnv.out$ va contine un singur numar intreg ce reprezinta valoarea minima a lui $k$.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; n &le; 250.000$\r\n* $1 &le; m &le; 500.000$\r\n* $1 &le; k{~i~} &le; 1000$\r\n* Pot exista mai multe arce intre doua noduri. De asemenea pot exista arce de la un nod la acelasi nod.\r\n* *ATENTIE!* In cazul in care lucrati in C/C++ se recomanda citirea cu functii precum fgets din cauza dimensiunii mari a fisierelor de intrare!\r\n\r\nh2. Nivele\r\n\r\n* Pentru $30%$ din punctaj $n &le; 1.000 m &le; 10.000$\r\n* Pentru $50%$ din punctaj $n &le; 25.000 m &le; 50.000$\r\n* Pentru $80%$ din punctaj $n &le; 100.000 m &le; 200.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. pscnv.in |_. pscnv.out |\r\n| 4 5 1 4 \r\n1 2 3\r\n1 3 1\r\n2 4 2\r\n3 2 2\r\n3 4 3 | 2 |\r\n\r\nh3. Explicatie\r\n\r\nDrumul $1->3->2->4$ are ponderile muchiilor $1$, $2$ respectiv $2$.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"pscnv\")==',15,'task: pscnv'),('problema/arbore','Arbore','2006-12-18 15:16:41','==Include(page=\"template/taskheader\" task_id=\"arbore\")==\r\n\r\nO firma are $N$ angajati numerotati de la $1$ la $N$. Angajatii sunt ierarhizati sub forma de arbore (graf conex fara cicluri). Astfel, fiecare angajat are exact un sef direct (cu exceptia patronului firmei), iar un anumit angajat poate avea mai multi subordonati directi. Patronul firmei este numerotat cu $1$. Un angajat $A$ este subordonatul unui alt angajat $B$ daca una din urmatoarele conditii este indeplinita:\r\n\r\n* $A$ este subordonat direct al lui $B$\r\n* $A$ este unul dintre subordonatii unui alt subordonat de-al lui $B$\r\n\r\nDatorita profiturilor foarte mari obtinute de firma, angajatii vor primi anumite sume de bani drept bonus. Pentru a avea o evidenta stricta, contabilul firmei trebuie sa efectueze M operatii de doua tipuri:\r\n\r\n# dandu-se $p$ si {$s$}, toti subordonatii nodului $p$ (inclusiv nodul {$p$}) vor primi suma de bani $s$\r\n# dandu-se un numar {$s$}, el trebuie sa afle un angajat care a primit pana la momentul respectiv suma $s$\r\n\r\nMentionam ca unii angajati pot fi recompensati de mai multe ori, iar altii pot sa nu primeasca nimic.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care primeste {$N$}, {$M$}, structura angajatilor si cele $M$ operatii iar pentru fiecare operatie de tipul $2$ afiseaza valoarea ceruta.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $arbore.in$ contine pe prima linie numerele $N$ si $M$ separate printr-un spatiu.\r\nUrmatoarele $N-1$ linii contin cate doua numere intregi $p$ si $q$ cu semnificatia ca \"exista relatie directa intre angajatul $p$ si angajatul {$q$}\". \r\nUrmatoarele $M$ linii cotin cate o operatie pe linie. Primul numar de pe linie este $1$ sau {$2$}, si semnifica tipul operatiei ce va fi descrisa. In cazul unei operatii de tip $1$ vor urma numerele $p$ si {$s$}, iar in cazul unei operatii de tip $2$ va urma un singur numar {$s$}.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $arbore.out$ contine pentru fiecare operatie de tip $2$ indicele unui angajat care a primit suma respectiva de bani pana la momentul respectiv. In cazul in care nu exista un asemenea angajat, se cere sa se afiseze {$-1$}. Nu are importanta indicele carui angajat il veti afisa, atata timp cat acesta a primit suma {$s$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 100 000$\r\n* pentru o operatie de tipul $1$ avem $1 &le; s &le; 10$\r\n* pentru o operatie de tipul $2$ avem $0 &le; s &le; 1 000 000$\r\n* $50%$ dintre testele folosite la evaluare nu vor contine mai mult de $100$ de operatii de tip $2$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. arbore.in |_. arbore.out |\r\n| 6 6\r\n1 2\r\n1 3\r\n3 4\r\n3 5\r\n4 6\r\n1 1 1\r\n1 2 4\r\n2 5\r\n2 1\r\n1 3 3\r\n2 4\r\n| 2\r\n1\r\n3 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"arbore\")==',256,'task: arbore'),('problema/cercuri2','Cercuri 2','2006-11-11 17:41:29','==Include(page=\"template/taskheader\" task_id=\"cercuri2\")==\r\n\r\nAdriana a ajuns la concluzia ca discul este o figura interesanta. Cu atat mai interesanta atunci cand este formata din $M$ cercuri concentrice $K$-numerice. Un cerc este $K$-numeric daca de-alungul conturului sau sunt scrise $3*K$ numere cu proprietatea ca exista cel putin o alegere a pozitiilor $x, y, z$ (de pe acest cerc), astfel incat sa aiba loc urmatoarea relatie : $a(x) + a(x+1) + ... + a(y-1) = a(y) + a(y+1) + ... + a(z-1) = a(z) + a(z+1) + ...+ a(x-1) = R$ si mai mult $|x-y| = |y-z| = |z-x| = K$ ({$a(i)$} este al $(x+i)$-lea numar de pe cerc).\r\n\r\nh2. Cerinta\r\n\r\nAdriana va roaga sa numarati toate discurile cu toate proprietatiile de mai sus, pentru un $R$ si un $M$ date.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $cercuri2.in$ se vor afla $R$ si $M$.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului $cercuri2.out$ se va afisa numarul cerut, luat modulo $666013$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $M*(M-1)/2 < R < 20001$\r\n* $a(x) > a(x+1) > ... > a(y-1)$\r\n* $a(y) > a(y+1) > ... > a(z-1)$\r\n* $a(z) > a(z+1) > ... > a(x-1)$\r\n* in mod evident, primul cerc al discului este $M$-numeric, al doilea cerc este $(M-1)$-numeric, ...., ultimul cerc este 1-numeric.\r\n* toate numerele de pe cercuri sunt numere naturale strict pozitive\r\n\r\ntable(example). |_. cercuri2.in |_. cercuri2.out |\r\n|9 3 |1728 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cercuri2\")==',1,'task: cercuri2'),('problema/sir','Sir','2006-11-12 16:23:51','==Include(page=\"template/taskheader\" task_id=\"sir\")==\r\n\r\nExplorand pestera arheologica de la Altamira, profesorul Richard a gasit un sir de numere de lungime $N$.\r\n\r\nh2. Cerinta\r\n\r\nDorind sa descifreze semnificatia acestui sir, el trebuie sa gaseasca secventa de lungime maxima de lungime cuprinsa intre $X$ si $Y$ cu propietatea: $MAX - MIN &le; Z$ unde, $MAX$ reprezinta valoarea maxima din secventa, $MIN$ valoare minima din secventa, iar $Z$ un numar natural dat.\r\n\r\nAjutati-l pe profesorul Richard sa descifreze limba antica din pestera Altamira si astfel, sa devina celebru.\r\n\r\nh2. Date de intrare:\r\n\r\nDe pe prima linie a fisierului $sir.in$ se vor citi $4$ numere $N X Y Z$. Pe a doua linie a fisierului de intrare se vor citi $N$ numere, reprezentand valorile sirului.\r\n\r\nh2. Date de iesire:\r\n\r\nPe prima linie a fisierului $sir.out$ se vor afisa $3$ numere separate prin spatii reprezentand lungimea maxima a secventei cu propietatea data, pozitia de inceput a secventei si pozitia de sfarsit a acesteia. In cazul in care nu exista solutie se va afisa un singur numar, $-1$.\r\n\r\nh2. Restrictii si prezizari:\r\n\r\n* $3 &le; N &le; 100 000$\r\n* $1 &le; X &le; Y &le; N$\r\n* $0 &le; Z &le; 30 000$\r\n* Valorile sirului sunt numere naturale &le; $30 000$\r\n* In cazul in care exista mai multe solutii se va afisa secventa cu pozitia de inceput maxima\r\n\r\nh2. Exemple:\r\n\r\ntable(example). |_. sir.in|_. sir.out|\r\n|6 2 4 3\r\n1 5 3 2 5 9\r\n|4 2 5|\r\n|3 2 3 1\r\n2 5 2\r\n|-1|\r\n\r\n_Explicatii_: In primul exemplu, secventa maxima cu lungime cuprinsa intre 2 si 4 care indeplineste propietatea din enunt are lungimea 4. Aceasta secventa incepe de pe pozitia 2 si se termina pe pozitia 5. In al doilea exemplu, nu exista secventa de lungime cuprinsa intre 2 si 3 care sa indeplineasca propietatea din enunt.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sir\")==',256,'task: sir'),('problema/minim','Minim','2006-11-11 16:55:40','==Include(page=\"template/taskheader\" task_id=\"minim\")==\r\n\r\nSe considera un sir de $n$ numere intregi.\r\nIn problema vom lucra cu subsecvente. Precizam ca elementele unei subsecvente sunt elemente avand indici consecutivi in sirul considerat.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine subsecventa de suma minima a sirului care are lungimea minima. Daca exista mai multe astfel de subsecvente, sa se elimine cea care are indicele de inceput mai mica. Sa se elimine aceasta subsecventa din sir, apoi sa se determine o alta subsecventa de lungime minima printre cele care au suma minima dintre elementele ramase in sir. Sa se continue procedeul, pana cand sirul devine vid.\r\n\r\nh2. Date de Intrare\r\n\r\n* Pe prima linie a fisierului $minim.in$ se afla numarul natural $n$, reprezentand dimensiunea sirului.\r\n* Pe urmatoarele $n$ linii se afla cate un numar intreg.\r\n\r\nh2. Date de Iesire\r\n\r\n* In fisierul de iesire $minim.out$ se vor scrie $k$ triplete, unde $k$ este numarul subsecventelor depistate.\r\n* Un triplet aflat pe cea de a $i-a$ linie a fisierului este format din numerele $s$, $p$, $u$, unde $s$ reprezinta suma celei de a $i-a$ subsecvente, $p$ reprezinta indicele primului element al subsecventei, iar $u$ este indicele ultimului element al subsecventei. Indicii $p$ si $u$ sunt indicii elementelor respective in sirul original.\r\n* Cele trei numere vor fi despartite prin cate un spatiu.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $5 &le; n &le; 1000$\r\n* $-10000 &le; nr[i] &le; 10000 (i = 1, 2, ..., n)$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. minim.in |_. minim.out |\r\n| 10\r\n  6\r\n  -8\r\n  -2\r\n  -4\r\n  -6\r\n  20\r\n  -10\r\n  -3\r\n  12\r\n  -19\r\n| -20 2 5\r\n  -20 7 10\r\n  6 1 1\r\n  20 6 6 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"minim\")==',48,'task: minim'),('problema/spirala','Spirala','2006-11-12 14:23:10','==Include(page=\"template/taskheader\" task_id=\"spirala\")==\r\n\r\nSe considera un tablou bidimensional care contine numere intregi. Numim spirala acel drum prin matrice care, pornind din coltul stanga sus, traverseaza element dupa element prima linie, coboara pe ultima coloana, traverseaza ultima linie de la dreapta la stanga, urca pe prima coloana, apoi continua cu cea de-a doua linie, penultima coloana, penultima linie si a doua coloana etc. Drumul se opreste undeva in tablou, dupa ce toate elementele au fost traversate. Fiecare element se _atinge_ o singura data.\r\n\r\nh2. Cerinta\r\n\r\nSa se stabileasca daca spirala tabloului dat formeaza sau nu o progresie aritmetica. Prin progresie aritmetica intelegem o insiruire de numere in care diferenta dintre oricare doua numere consecutive este aceeasi (pentru un sir de $N$ numere, $a{~i~} - a{~i+1~} = dif$, {$i = 1, 2, ..., n - 1$}).\r\n\r\nIn cazul in care raspunsul este afirmativ, sa se determine valoarea ultimului element din spirala, in caz contrar sa se afiseze valorile primelor doua elemente din spirala ale caror diferenta nu este egala cu diferenta dintre valorile elementelor verificate.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $spirala.in$ se afla doua numere naturale ({$nrlin$} si {$nrcol$}), reprezentand numarul liniilor, respectiv numarul coloanelor din tablou. Pe urmatoarele $nrlin$ linii se afla cate $nrcol$ numere intregi. Oricare doua numere din fisier sunt despartite prin cate un spatiu.\r\n\r\nh2. Date de iesire\r\n\r\n* Daca spirala formeaza progresie aritmetica, pe prima linie a fisierului de iesire $spirala.out$ se va scrie cuvantul $DA$. Pe urmatoarea linie se va scrie valoarea ultimului element din spirala.\r\n* Daca spirala nu formeaza progresie aritmetica, pe prima linie a fisierului de iesire $spirala.out$ se va scrie cuvantul $NU$. Pe urmatoarea linie se vor scrie doua numere naturale, reprezentand primele doua numere din tabloul dat in cazul carora nu este indeplinita proprietatea de progresie aritmetica.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; nrlin, nrcol &le; 100$\r\n* $-32000 &le; tablou{~i,j~} &le; 32000 (i = 1, 2, ..., nrcol, j = 1, 2, ..., nrlin)$\r\n\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. spirala.in|_. spirala.out|_. spirala.in|_. spirala.out|\r\n|3 3\r\n1 3 5\r\n15 17 7\r\n13 11 9\r\n|DA\r\n17\r\n|2 3\r\n-1 -3 -5\r\n-15 -5 -7\r\n|NU\r\n-7 -5|\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"spirala\")==',256,'task: spirala'),('problema/jocul','Jocul','2006-11-12 15:34:47','==Include(page=\"template/taskheader\" task_id=\"jocul\")==\r\n\r\n\r\nGigel a primit in cadou o cutie de betisoare. Betisoarele au diferite lungimi, nu neaparat distincte. Gigel vrea sa imparta betisoarele in doua grupuri, astfel incat betisoarele dintr-un grup, puse unele in continuarea celorlalte sa formeze o \"linie\" a carei lungime sa fie cat mai apropiata de \"linia\" formata din betisoarele din celalalt grup. Lungimea liniei de betisoare este egala cu suma lungimilor betisoarelor care formeaza linia.\r\n\r\nh2. Cerinta\r\n\r\nSa se stabileasca lungimea celor doua linii formate din betisoarele asezate in doua grupuri, astfel incat diferenta dintre lungimea \"liniei\" formate din betisoarele din primul grup si lungimea \"liniei\" formate din betisoarele din al doilea grup sa fie cat mai mica.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $jocul.in$ se afla numarul natural $n$, reprezentand numarul total al betisoarelor. Pe urmatoarele $n$ linii se afla cate un numar natural, care reprezinta lungimile betisoarelor primite de Gigel.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului de iesire $jocul.out$ se vor scrie doua numere naturale, corespunzatoare lungimii primei, respectiv celei de a doua \"linii\" de betisoare dupa repartizarea lor in cele doua grupuri.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $5 &le; n &le; 1000$\r\n* $1 &le; lungime{~i~} &le; 100$ ({$i = 1, 2, ..., n$}, lungimile sunt date in mm)\r\n* Daca cele doua numere difera, ele se vor scrie in fisier in ordine crescatoare.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. jocul.in |_. jocul.out |\r\n| 7\r\n28\r\n7\r\n11\r\n8\r\n9\r\n7\r\n27\r\n| 48 49 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"jocul\")==',15,'task: jocul'),('problema/subsiruri','Subsiruri','2006-11-12 16:31:55','==Include(page=\"template/taskheader\" task_id=\"subsiruri\")==\r\n\r\nSe considera un sir de $N$ numere intregi distincte {$x{~1~}$}, {$x{~2~}$}, ..., {$x{~N~}$}.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine lungimea subsirurilor {$x{~i{~1~}~}$}, {$x{~i{~2~}~}$}, ..., {$x{~i{~k~}~}$} de lungime maxima, unde {$i{~1~} < i{~2~} < ... < i{~k~}$} si {$x{~i{~1~}~} < x{~i{~2~}~} < ... < x{~i{~k~}~}$}, precum si numarul lor.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $subsiruri.in$ se afla numarul natural $N$, reprezentand lungimea sirului. Pe urmatoarele $N$ linii se afla cate un numar intreg.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $subsiruri.out$ se va scrie numarul natural $lungmax$, reprezentand lungimea maxima a subsirurilor crescatoare. Pe urmatoarea linie se va scrie numarul subsirurilor de lungime $lungmax$. Acest numar se va afisa modulo $9901$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $5 &le; n &le; 1 000$\r\n* $-32 000 &le; x{~k~} &le; 32 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. subsiruri.in|_. subsiruri.out|\r\n|10\r\n1\r\n-12\r\n3\r\n8\r\n-25\r\n0\r\n7\r\n-18\r\n9\r\n2\r\n|4\r\n6\r\n|\r\n\r\nh3. Explicatii\r\n\r\nSunt 6 subsiruri crescatoare de lungime maxima 4: \r\n$1 3 8 9$\r\n$1 3 7 9$\r\n$-12 3 8 9$\r\n$-12 3 7 9$\r\n$-12 0 7 9$\r\n$-25 0 7 9$\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"subsiruri\")==',1,'task: subsiruri'),('problema/sequencequery','SequenceQuery','2006-11-12 16:15:35','==Include(page=\"template/taskheader\" task_id=\"sequencequery\")==\r\n\r\nSe considera un sir {$A = (a{~1~}, a{~2~}, ... , a{~N~})$} format din $N$ numere intregi, precum si $M$ perechi de numere ({$x, y$}). Pentru fiecare pereche de indici ({$x, y$}) ({$1 &le; x &le; y &le; N$}) trebuie determinata subsecventa de suma maxima a subsirului {$a{~x~}, a{~x+1~}, ..., a{~y~}$}.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $sequencequery.in$ va contine pe prima linie doua numere intregi $N$ si $M$. Urmatoarea linie va contine $N$ numere intregi separate prin cate un spatiu. Acestea vor reprezenta numerele {$a{~1~}, a{~2~}, ... , a{~N~}$}. Urmatoarele $M$ linii vor contine fiecare cate o pereche de doua numere separate prin cate un spatiu. Acestea vor indica perechile de indici pentru care trebuie determinate sumele maxime ale subsecventelor.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $sequencequery.out$ va contine $M$ linii. Fiecare dintre acestea va contine cate un numar intreg care reprezinta suma elementelor din subsecventa considerata optima dupa criteriile exprimate in enuntul problemei.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 100 000$\r\n* $-100 000 &le; a{~i~} &le; 100 000$\r\n* Subsecventele alese trebuie sa contina cel putin un element\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. sequencequery.in|_. sequencequery.out|\r\n|8 3\r\n-1 2 3 -2 4 -3 8 -3\r\n1 5\r\n4 8\r\n6 6\r\n|7\r\n9\r\n-3 |\r\n\r\nh3. Explicatii \r\n\r\nSubsecventele alese pentru fiecare query in parte sunt ingrosate:\r\n\r\n* [ -1 **2 3 -2 4** ] -3 8 -3\r\n* -1 2 3 [ -2 **4 -3 8** -3 ]\r\n* -1 2 3 -2 4 [ **-3** ] 8 -3\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sequencequery\")==',961,'task: sequencequery'),('problema/invers','Invers','2006-11-12 16:02:31','==Include(page=\"template/taskheader\" task_id=\"invers\")==\r\n\r\nZaharel, este mare pasionat de numere, si ii place sa studieze proprietatile ciudate ale acestora. Fie un numar $Nr$ de forma $a{~n~}a{~n-1~}a{~n-2~}...a{~1~}a{~0~}$ ({$a{~n~}$} reprezinta prima cifra, $a{~n-1~}$ a doua cifra, etc.). Se defineste inversul numarului $Nr$ ca fiind $Inv(Nr)=a{~0~}a{~1~}a{~2~}...a{~n-1~}a{~n~}$, adica numarul care se obtine scriind cifrele lui $Nr$ in ordine inversa. Spre exemplu, $Inv(12345)=54321, Inv(740)=47$. Zaharel are pe hartie scrise mai multe numere naturale si vrea sa determine pentru fiecare dintre acestea daca exista un numar natural $x$ astfel incat numarul respectiv sa fie egal cu $x+Inv(x)$.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Zaharel sa studieze proprietatea mai sus enuntata a numerelor de pe hartie realizand un program.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie din fisierul $invers.in$ se va afla un numar natural $T$, care reprezinta cate numere sunt scrise pe hartie. Pe urmatoarele $T$ linii se vor afla numerele naturale scrise pe hartie, cate unul pe o linie.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $invers.out$ va contine $T$ linii, fiecare continand textul $\"DA\"$ (daca numarul din fisierul de intrare de pe linia corespunzatoare poate fi scris ca $x+Inv(x)$) sau $\"NU\"$ (altfel).\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $1 &le; T &le; 10.000$\r\n* $0 < Nr < 10^10000^$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. invers.in |_. invers.out |\r\n| 6\r\n13\r\n11\r\n4774\r\n2\r\n1\r\n120219482301 | NU\r\nDA\r\nDA\r\nDA\r\nNU\r\nDA |\r\n\r\nh3. Explicatii\r\n\r\n$10+Inv(10)=11$\r\n$4700+Inv(4700)=4774$\r\n$1+Inv(1)=2$\r\n$23918700369+Inv(23918700369)=120219482301$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"invers\")==',13,'task: invers'),('problema/secv2','Secventa 2','2006-11-12 15:25:58','==Include(page=\"template/taskheader\" task_id=\"secv2\")==\r\n\r\nGigel s-a decis sa devina olimpic la informatica, poate asa va reusi sa-si rezolve singur problemele, si nu va mai cere ajutorul vostru! La ora de informatica, profesoara lui i-a dat sa rezolve problema secventei de suma maxima: \"Gigele, eu iti dau un sir de $N$ numere intregi, iar tu trebuie sa gasesti o secventa (adica un subsir de numere care apar pe pozitii consecutive in sirul initial) cu suma elementelor maxima!\". Dupa vreo 30 de minute, Gigel s-a ridicat mandru si a zis: \"Am gasit algoritmul de complexitate optima, doamna profesoara!\"\r\nCa tema pentru acasa Gigel are de rezolvat aproape aceeasi problema: trebuie sa gaseasca secventa de suma maxima de lungime cel putin $K$!\r\n\r\nh2. Cerinta\r\n\r\nGigel inca nu stie destul de multa informatica ca sa poata rezolva aceasta problema, dar poate il ajutati voi! Scrieti un program care rezolva problema din tema lui Gigel.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $secv2.in$ contine pe prima linie numerele $N$ si $K$, separate prin spatiu. Pe cea de a doua linie se afla elementele sirului separate prin cate un spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $secv2.out$ trebuie sa contina o singura linie cu trei numere: pozitia de inceput si de sfarsit a secventei de suma maxima de lungime cel putin $K$ si suma secventei.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; K &le; N &le; 50.000$\r\n* Elementele din vector sunt numere intregi din intervalul $[-25.000, 25.000]$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. secv2.in |_. secv2.out |\r\n| 8 3\r\n0 -6 2 1 4 -1 3 -5 |  3 7 9 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"secv2\")==',1,'task: secv2'),('problema/z','ZParcurgere','2006-11-12 15:41:35','==Include(page=\"template/taskheader\" task_id=\"z\")==\r\n\r\nPetrica are o tabla patratica de dimensiuni $2^N^*2^N^$. Ar vrea sa scrie pe patratelele tablei numere naturale cuprinse intre $1$ si $2^N^*2^N^$ conform unei parcurgeri mai deosebite pe care o numeste Z-parcurgere. O Z-parcurgere viziteaza recursiv cele patru cadrane ale tablei in ordinea: stanga-sus, dreapta-sus, stanga-jos, dreapta-jos. De exemplu, daca $N=1$, ordinea vizitarii patratelelor de pe tabla este in forma de Z, ca in figura urmatoare:\r\n\r\n|=. 1|=. 2|\r\n|=. 3|=. 4|\r\n\r\n\r\nDaca $n=2$, Petrica va traversa patratelele in ordinea:\r\n\r\n\r\n|=. 1|=. 2|=. 5|=. 6|\r\n|=. 3|=. 4|=. 7|=. 8|\r\n|=. 9|=. 10|=. 13|=. 14|\r\n|=. 11|=. 12|=. 15|=. 16|\r\n\r\nh2. Cerinta\r\n\r\nLa un moment dat Petrica ar vrea sa stie ce numar de ordine trebuie sa scrie conform Z-parcurgerii pe anumite patratele date prin coordonatele lor ( $x$, $y$ ). Petrica incepe umplerea tablei intotdeauna din coltul din stanga-sus.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $z.in$ se afla doua numere naturale $N$ si $K$, unde $N$ reprezinta faptul ca tabla are dimensiunea $2^N^*2^N^$, iar $K$ este numarul patratelelor pe care Petrica ar vrea sa stie ce numar va trebui sa scrie pe ele. Pe fiecare din urmatoarele $K$ linii se afla cate doua numere naturale ({$x$}, {$y$}), care reprezinta linia, respectiv coloana unui patratel ales. A $i+1$-a linie descrie al $i$-lea patratel ( {$i = 1, 2, ..., k$} ).\r\n\r\nh2. Date de iesire\r\n\r\nPe cele $K$ linii ale fisierului de iesire $z.out$ se va scrie cate un numar natural, corespunzator numarului pe care Petrica il va scrie pe patratelul ales. A $i$-a linie descrie al $i$-lea patratel ( {$i = 1, 2, ..., k$} ).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 15$\r\n\r\n* $1 &le; K &le; 1 000$\r\n\r\n* $1 &le; x, y &le; 2^N^$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. z.in|_. z.out|\r\n|2 2\r\n3 3\r\n4 3\r\n|13\r\n15|\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"z\")==',256,'task: z'),('problema/biti2','Biti2','2006-11-11 16:26:44','==Include(page=\"template/taskheader\" task_id=\"biti2\")==\r\n\r\nProfesorul Richard, intr-o expeditie in Valea Regilor, a descoperit o incriptie pe caramizile unei piramide sub forma unei secvente binare:\r\n{$01101001100101101001011001101001$}..\r\nEl a observat ca secventa se construieste astfel: primul caracter este {$0$}, apoi la fiecare pozitie ce reprezinta o putere a lui $2$ ({$1$}, {$2$}, {$4$}, {$8$}, $16$ ...) secventa curenta se inverseaza ({$0$} devine $1$ si $1$ devine {$0$}) si se adauga in continuarea secventei curente.\r\n\r\nh2. Cerinta\r\n\r\nDeoarece unele caractere au fost sterse de-alungul timpului, profesorul Richard va da o lista cu $N$ pozitii pentru care voi trebuie sa aflati ce caracter reprezinta.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $biti2.in$ se va citi {$N$}, numarul de pozitii pentru care trebuie sa aflati caracterul din secventa binara. Pe fiecare din urmatoarele $N$ linii se afla valoarea acestor pozitii.\r\n\r\nh2. Date de Iesire\r\n\r\nPe fiecare din primele $N$ linii ale fisierului de iesire $biti2.out$ se va afisa valoarea $0$ sau $1$ corespunzatoare caracterului din pozitiile date.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 10$\r\n* Primul caracter al secventei are pozitia $0$\r\n* Fiecare pozitie pentru care trebuie sa aflati valoarea caracterului din secventa este cuprinsa in intervalul [{$0, 10^2.500^$}]\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. biti.in |_. biti.out |\r\n| 3\r\n0\r\n2\r\n13\r\n| 0\r\n1\r\n1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"biti2\")==',961,'task: biti2'),('problema/map','Map','2006-11-12 16:39:52','==Include(page=\"template/taskheader\" task_id=\"map\")==\r\n\r\nMax Damage, pentru a nu se pierde in calatoriile sale doreste sa isi faca o harta. Pentru a nu fi citita de oricine, el o codifica sub forma unei matrice cu $N$ linii si $M$ coloane. Pentru ca scrie urat, se duce la un prieten care are un tipar si il roaga sa ii tipareasca harta. Tiparul, fiind mai vechi, este stricat si tipareste harta de doua ori pe aceeasi foaie, dar cu o deplasare (spre dreapta).\r\nApare politia si Max fuge cu foaia prost tiparita. Ajuns la ascunzatoare el vede catastrofa: portiunea unde cele doua imprimari s-au suprapus se intampla sa coincida, astfel ca nu isi poate da seama unde se termina una si unde incepe cealalta. El vrea acum un program care, primind o astfel de matrice, sa returneze cea mai mica dimensiune a matricei originale astfel incat, suprapusa de doua ori cu o deplasare corecta spre dreapta, sa se obtina cea finala\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Max sa rezolve si aceasta problema zdrobitoare.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie din fisierul $map.in$ va contine numerele $M$ si $N$, reprezetand dimensiunea matricei. Urmatoarele M linii vor contine cate $N$ litere mici ale alfabetului englez (matricea prost tiparita).\r\n\r\nh2. Date de Iesire\r\n\r\nFiserul $map.out$ va contine pe prima linie o singura valoare, reprezentand dimensiunea orizontala minima a matricei originale.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $1 &le; N, M &le; 2000$\r\n\r\n\r\n\r\nh2. Example\r\n\r\ntable(example). |_. map.in |_. map.out |\r\n| 3 5\r\n  anana\r\n  arara\r\n  mamam\r\n| 3 |\r\n\r\nh3. Explicatie\r\n \r\n\r\nPornind de la matricea de lungime 3\r\n$ana$\r\n$ara$ \r\n$mam$\r\nsuprapusa de doua ori se obtine:\r\n$anana$\r\n$arara$\r\n$mamam$\r\n\r\ntable(example). |_. map.in |_. map.out |\r\n| 1 4\r\n  abcd\r\n| 3 |\r\n\r\nh3. Explicatie \r\n\r\nSingura solutie este ca a doua imprimare sa fie perfect suprapusa peste prima. \r\n\r\ntable(example). |_. map.in |_. map.out |\r\n| 1 4\r\n  aaaa\r\n| 3 |\r\n\r\nh3. Explicatie\r\n\r\nDaca lungimea ar fi fost mai mica, nu se suprapunea. \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"map\")==',1,'task: map'),('problema/srevni','Srevni','2006-11-12 14:10:47','==Include(page=\"template/taskheader\" task_id=\"srevni\")==\r\n\r\nPe planeta Srevni exista $N$ orase legate intre ele prin strazi cu sens unic. Orasele sunt identificate prin numere cuprinse intre $1$ si $N$. In fiecare din aceste orase se produce un aliment foarte hranitor. Pretul de vanzare al alimentelor poate fi diferit de la oras la oras. Pentru a reduce costurile, transportul alimentelor se realizeaza astfel: o masina de comanda care trebuie sa alimenteze orasul $i$ pleaca din orasul $i$ spre orasul din care trebuie sa aduca alimentele. In momentul cand ajunge la destinatie este incarcata si teleportata in orasul $i$. Intr-o zi, Regnos, conducatorul planetei, plictisindu-se, s-a gandit ca ar fi bine sa stie care este cel mai mic pret de achizitie al alimentului pentru fiecare oras al planetei.\r\n\r\nh2. Date de intare\r\n\r\nIn fisierul de intrare $srevni.in$ vom avea pe prima linie doua numere intregi $N$ si $M$. Pe linia urmaroate se vor afla $N$ numere naturale separate intre ele prin spatii, care reprezinta preturile alimentelor in fiecare dintre cele $N$ orase. Pe fiecare dintre urmatoarele $M$ linii se vor afla cate doua numere intregi, separate intre ele printr-un spatiu, $X$ si $Y$, cu semnificatia ca exista drum de la orasul $X$ catre orasul $Y$.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $srevni.out$ va contine pe prima linie $N$ numere separate intre ele prin spatii, care reprezinta cele mai mici preturi de achizitie ale alimentelor pentru fiecare dintre cele $N$ orase.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100 000$\r\n* $1 &le; M &le; 100 000$\r\n* Preturile sunt numere naturale cuprinse intre $1$ si $1 000 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. srevni.in|_. srevni.out|\r\n|4 4\r\n1 2 4 3\r\n1 3\r\n2 4\r\n3 2\r\n3 4\r\n|1 2 2 3|\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"srevni\")==',256,'task: srevni'),('problema/game','Game','2006-11-12 13:24:41','==Include(page=\"template/taskheader\" task_id=\"game\")==\r\n\r\nAndrei a invatat un joc matematic interesant care vrea sa il arate lui Mihai. Jocul incepe cu $N$ gramezi de pietre. Fiecare jucator aflat la mutare poate lua pietre dintr-o singura gramada. Numarul pietrelor luate poate fi $1$ sau un numar prim. Jucatorii muta alternativ, iar castigatorul este cel care ia ultima piatra.\r\nAndrei se ofera sa il lase pe Mihai sa faca prima mutare, dar Mihai stie ca Andrei a invatat deja strategia jocului, asa ca doreste sa afle daca are sau nu o strategie sigura de castig. Baietii joaca cate $10$ jocuri consecutiv.\r\n\r\nh2. Cerinta\r\n\r\nSarcina voastra este sa il ajutati pe Mihai cu raspunsul exact pentru fiecare dintre cele $10$ configuratii.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $game.in$ contine zece linii. Primul numar de pe o astfel de linie reprezinta numarul $N$ al gramezilor, iar in continuare se afla $N$ numere care reprezinta numarul pietrelor din fiecare gramada. Numerele de pe o linie vor fi separate prin spatii.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $game.out$ va contine cate o linie pentru fiecare dintre configuratiile din fisierul de intrare (in aceeasi ordine). Valoarea de pe o linie va fi $1$ daca Mihai are o strategie sigura de castig pentru configuratia corespunzatoare si $0$ in caz contrar.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 1000$\r\n* numarul total al pietrelor nu va depasi $2000000000$ pentru o configuratie.\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. game.in |_. game.out |\r\n| 2 2 1\r\n3 7 7 7\r\n1 1000\r\n2 5 5\r\n4 3 3 3 3\r\n2 2 1\r\n3 7 7 7\r\n1 1000\r\n2 5 5\r\n4 3 3 3 3\r\n| 1\r\n1\r\n0\r\n0\r\n0\r\n1\r\n1\r\n0\r\n0\r\n0 |\r\n\r\nh3. Explicatie\r\n\r\nPentru prima configuratie Mihai va lua o piatra din prima gramada. Apoi, Andrei va lua o piatra din una dintre cele doua gramezi,iar Mihai va lua piatra din cealalta gramada si va castiga.\r\nPentru cea de-a doua configuratie Mihai va lua toate cele sapte pietre din una dintre gramezi. Apoi, Andrei va lua un numar de pietre dintr-una dintre gramezile ramase, iar Mihai va lua acelasi numar de pietre din cealalta gramada ramasa. Procesul va continua pana in momentul in care nu va mai ramane nici o piatra. Ultima mutare va fi efectuata cu siguranta de catre Mihai.\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"game\")==',961,'task: game'),('problema/colorare','Colorare','2006-12-13 07:22:56','==Include(page=\"template/taskheader\" task_id=\"colorare\")==\r\n\r\nSe considera un graf cu $N$ noduri si $M$ muchii. Numim o colorare valida a nodurilor grafului, o colorare in care oricare doua noduri vecine sunt colorate distinct.\r\n\r\nh2. Cerinta\r\n\r\nSe cere determinarea numarului minim de culori necesar pentru o colorare valida. Pentru acest numar minim de culori se cere numarul de colorari valide ale nodurilor grafului.\r\n\r\nh2. Date de intare\r\n\r\nIn fisierul de intrare $colorare.in$ vom avea pe prima linie doua numere intregi $N$ si $M$. Pe urmatoarele $M$ linii se vor afla cate doua numere intregi, separate intre ele printr-un spatiu, $X$ si $Y$, cu semnificatia ca exista o muchie in graf intre nodurile $X$ si $Y$.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $colorare.out$ va contine pe prima linie o pereche de intregi $p$ si $c$, care reprezinta numarul minim de culori cu care pot fi colorate nodurile grafului respectand conditia din problema, respectiv numarul de colorari posibile ale grafului cu $p$ culori distincte.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 15$\r\n* $0 &le; M &le; N(N-1)/2$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |colorare.in |colorare.out |\r\n| 3 1\r\n1 2\r\n| 2 4 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"colorare\")==',75,'task: colorare'),('problema/divizori','Divizori','2006-11-12 15:07:07','==Include(page=\"template/taskheader\" task_id=\"divizori\")==\r\n\r\nVom considera un numar natural $N$ . In sirul $A$ vom aseza toti divizorii lui $N$ . Se cere sa se permute elementele sirului $A$ astfel incat pentru oricare doua elemente consecutive $A{~i~}$ si $A{~i+1~}$ sa avem fie $A{~i~}=A{~i+1~}*p$ fie $A{~i+1~}=A{~i~}*p$ , unde $p$ este un numar prim oarecare. Valoarea $p$ poate diferi de la o pereche de elemente la alta.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $divizori.in$ se afla $N$ .\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $divizori.out$ se va afisa lungimea sirului $A$ . Pe a doua linie a fisierului se vor afisa elementele lui $A$ . In cazul existentei mai multor solutii, se poate afisa oricare dintre ele.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 2.000.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. divizori.in |_. divizori.out |\r\n| 12 \r\n|6\r\n1 2 4 12 6 3 |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"divizori\")==',18,'task: divizori'),('problema/divmul','Divizor si multiplu','2006-11-11 23:35:53','==Include(page=\"template/taskheader\" task_id=\"divmul\")==\r\n\r\nSe dau doua numere {$x,y$}. Se cere aflarea numarului de perechi ordonate de forma $(p,q)$ astfel incat :\r\n\r\n* cel mai mare divizor comun dintre $p$ si $q$ sa fie $x$\r\n* cel mai mic multiplu comun dintre $p$ si $q$ sa fie $y$\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $divmul.in$ va contine mai multe teste. Pe prima linie se afla un numar $T$ care reprezinta nuamarul de teste. Pe urmatoarele $T$ linii se afla cate doua numere $x,y$ cu semnificatia din enunt.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $divmul.out$ va contine $T$ linii pe linia $i$ aflandu-se numarul de solutii existente pentru perechea aflata pe linia $i+1$ in fisierul de intrare.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; x &le; 10.000$\r\n* $2 &le; y &le; 100.000.000$\r\n* $T &le; 30.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. divmul.in |_. divmul.out |\r\n| 1\r\n3 60\r\n| 4 |\r\n\r\nh3. Explicatie\r\n\r\nCele $4$ perechi sunt : $(3, 60) (12, 15) (15, 12) (60, 3)$\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"divmul\")==',961,'task: divmul'),('problema/cifru','Secretul Cifrului','2006-11-11 22:50:25','==Include(page=\"template/taskheader\" task_id=\"cifru\")==\r\n\r\nUn criptolog amator isi propune sa construiasca o masina de cifrat care sa cripteze un text alcatuit din exact $N$ simboluri distincte. Cifrarea se realizeaza prin permutarea simbolurilor ce formeaza textul.\r\nCriptologul nostru doreste ca reconstituirea textului initial sa poata fi realizata trecand textul cifrat inca de $K-1$ ori prin procedura de cifrare. Cu alte cuvinte, daca textul rezultat din prima cifrare este cifrat inca o data, rezultatul este cifrat din nou si asa mai departe, plecand de la textul initial si aplicand in total $K$ operatii de cifrare successive, trebuie sa obtina textul initial.\r\nCriptologul nostru ar vrea sa afle, cunoscand $N$ si {$K$}, numarul de moduri distincte in care poate fi realizata masina de cifrat. Doua moduri de realizare a masinii difera daca, exista cel putin un text in urma cifrarii caruia, in cele doua texte obtinute exista cel putin o pozitie in care se afla simboluri diferite.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care determina restul impartirii numarului de moduri distincte in care poate fi realizata masina de cifrat la {$19997$}.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $cifru.in$ contine pe prima (si singura) linie, doua valori numerice naturale separate printr-un spatiu, $N$ si $K$ (cu semnificatia din enunt)\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $cifru.out$ va contine pe prima linie, numarul de moduri distincte de realizare a masinii de cifrat modulo {$19997$}.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 2000$\r\n* $2 &le; K &le; 1000000000$\r\n* pentru $30%$ din teste $N,K < 13$\r\n* pentru $50%$ din teste $N,K &le; 100$\r\n\r\n\r\n\r\nExemple\r\n\r\n\r\ntable(example). |_. cifru.in |_. cifru.out |\r\n| 3 3\r\n| 3 |\r\n| 9 6\r\n| 11560 |\r\n| 100 200\r\n| 13767 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cifru\")==',961,'task: cifru'),('problema/fold','Fold','2006-11-12 13:16:29','==Include(page=\"template/taskheader\" task_id=\"fold\")==\r\n\r\nCiobanasul Ion s-a decis sa construiasca un tarc nou pentru oile sale. Terenul pe care ciobanasul Ion vrea sa construiasca tarcul este de forma dreptunghiulara parcelat in $n*m$ parcele si este putin denivelat. Despre fiecare parcela stim daca se afla la nivelul normal sau este denivelata. Tarcul trebuie sa aiba o forma dreptunghiulara, laturile paralele cu laturile terenului si este sustinut de patru tarusi situati in cele patru colturi. Cei patru tarusi pot fi infipti in pamant numai in parcele nivelate.\r\n\r\nh2. Cerinta\r\n\r\nPentru ciobanas ar fi foarte important sa stie cate amplasari posibile exista pentru tarc, dar el e satul de numarat oi, asa ca va cere ajutorul vostru pentru a numara dreptunghiuri.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $fold.in$ contine pe prima linie doua numere intregi $n$ si $m$ separate printr-un singur spatiu care reprezinta dimensiunile terenului. Fiecare dintre urmatoarele $n$ linii contin cate m numere, separate prin spatiu, care pot avea valorile $0$ pentru teren denivelat sau $1$ pentru nivel normal.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $fold.out$ trebuie sa contina o singura linie pe care se va afla un singur numar reprezentand numarul de posibilitati de amplasare.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; n &le; 250$\r\n* $1 &le; m &le; 2000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. fold.in |_. fold.in |\r\n|3 3 \r\n0 1 1\r\n1 1 1\r\n1 1 1 | 5 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"fold\")==',1,'task: fold'),('problema/hallway','Hallway','2006-11-12 13:35:16','==Include(page=\"template/taskheader\" task_id=\"hallway\")==\r\n\r\nSe considera un coridor dreptunghiular de dimensiuni {$M*N$}. In acest coridor exista mai multe coloane drepte de dimensiune neglijabila.\r\nSe cere sa se determine raza celei mai mari mingi sferice care poate strabate coridorul din capatul de vest pana in capatul de est. Pentru minge se poate alege orice punct de pornire aflat in capatul din vest si orice punct final aflat in capatul de est. Inaltimea coridorului este intotdeauna suficient de mare.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $hallway.in$ contine doua numere intregi $M$ si {$N$}, separate intre ele printr-un singur spatiu, care reprezinta dimensiunile coridorului pe directiile est-vest, respectiv nord-sud. Cea de-a doua linie contine un singur numar {$K$}, care reprezinta numarul de coloane care se afla in acest coridor.\r\nFiecare dintre urmatoarele $K$ linii contine doua numere intregi, separate intre ele printr-un singur spatiu, care reprezinta coordonatele la care se afla o coloana.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $hallway.out$ trebuie sa contina un singur numar care reprezinta raza celei mai mari mingi sferice care poate strabate coridorul din capatul de vest pana in capatul de est.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; M, N, K &le; 1000$\r\n* directia est-vest este reprezentata de prima coordonata\r\n* raza determinata a mingii trebuie scrisa cu $8$ zecimale unde ultima este rotunjita.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. hallway.in |_. hallway.out |\r\n| 5 2\r\n1\r\n1 1\r\n| 0.50000000 |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"hallway\")==',961,'task: hallway'),('problema/biscuiti','Biscuiti','2006-12-12 17:55:38','==Include(page=\"template/taskheader\" task_id=\"biscuiti\")==\r\n\r\nGardul fabricii de biscuiti este cam subred. Conducerea ia decizia de a remedia acest lucru si contacteaza doi muncitori amatori. Ajunsi la fata locului, muncitorii constata ca gardul este format din $N$ scanduri (pe care le numeroteaza 1, 2, 3 ... $N$ de la stanga la dreapta) de diferite lungimi. Ei stabilesc ca primul lucru care trebuie facut este demontarea celor $N$ scanduri. Astfel, decid ca in fiecare din urmatoarele $N$ zile sa demonteze scandura cu lungimea cea mai mica. Pe masura ce avanseaza cu munca, constientizeaza un lucru mai mult decat bizar. Daca in ziua $T$ au demontat scandura aflata pe pozitia $X$ lungimea tuturor scandurilor aflate in stanga scandurii $X$ creste cu $T$ unitati.\r\n\r\nh2. Cerinta\r\n\r\nSa se afle diferenta dintre suma lungimilor scandurilor demontate si suma lungimilor scandurilor initiale.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $biscuiti.in$ se afla numarul $N$. Urmeaza $N$ linii, pe linia $i$ aflandu-se lungimea initiala a scandurii $i-1$.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului $biscuiti.out$ se afla numarul $K$ cerut.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100.000$\r\n* $1 &le; X{~i~} &le; 1.000, X{~i~}$ este lungimea initiala a scandurii $i$\r\n* Daca au de ales intre mai multe scanduri de lungimi egale, muncitorii o vor alege pe cea mai din stanga\r\n* Ziua initiala este ziua 1\r\n* Scandura $i (i &ge; 2)$ are in stanga ei scandurile 1, 2, 3 ... $i-1$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. biscuiti.in |_. biscuiti.out |\r\n|7 \r\n9 \r\n10\r\n6\r\n6\r\n4\r\n9\r\n8 | 36 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"biscuiti\")==',75,'task: biscuiti'),('problema/invcs','Invcs','2006-11-12 13:39:14','==Include(page=\"template/taskheader\" task_id=\"invcs\")==\r\n\r\nGigel se joaca din nou cu algoritmul de aflare a celui mai lung subsir crescator. Pentru asta el foloseste un vector auxiliar $v$ cu semnficatia $v{~i~}$ = lungimea celui mai lung subsir crescator din sirul initial care se termina pe pozitia {$i$}.Uitandu-se el la sirul obtinut isi pune urmatoarea intrebare:\r\n\r\nh2. Cerinta\r\n\r\nCate permutari ale primelor $N$ numere naturale duc la obtinerea acestui vector auxiliar?\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $invcs.in$ va contine numarul natural nenul $N$ reprezentand lungimea unui sir pe care Gigel a aplicat algoritmul de aflare a celui mai lung subsir crescator. Pe urmatoarele $N$ linii este dat vectorul auxiliar $v$ calculat de Gigel.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $invcs.out$ va contine o singura linie cu numarul cerut.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $N &le; 20$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. invcs.in |_. invcs.out |\r\n| 5\r\n1\r\n1\r\n1\r\n2\r\n2\r\n| 6 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"invcs\")==',961,'task: invcs'),('problema/order','Order','2006-11-11 18:32:38','==Include(page=\"template/taskheader\" task_id=\"order\")==\r\n\r\nSe considera $n$ copii asezati in cerc si numerotati de la $1$ la $n$ in sens trigonometric. Copiii joaca urmatorul joc: jocul incepe de la primul copil (cel al carui numar de ordine este 1); la fiecare al $i-lea$ pas al jocului se numara $i$ copii in sens trigonometric si este eliminat copilul la care se ajunge; la pasul urmator numaratoarea incepe de la copilul care urmeaza dupa cel eliminat.\r\nAsadar, daca numarul copiilor este suficient de mare, la primul pas este eliminat al doilea copil, la al doilea pas al patrulea, la al treilea pas al saptelea, apoi la al patrulea pas al unsprezecelea si asa mai departe.\r\n\r\nh2. Cerinta\r\n\r\nVa trebui sa determinati ordinea in care vor fi eliminati copiii.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $order.in$ contine pe prima linie un numar intreg $n$, care reprezinta numarul de copii.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $order.out$ trebuie sa contina o singura linie pe care se vor afla $n$ numere distincte cuprinse intre $1$ si $n$ care reprezinta numerele de ordine ale copiilor in ordinea in care au fost eliminati.\r\n\r\nRestrictie\r\n\r\n* $2 &le; n &le; 30.000.$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. order.in |_. order.out |\r\n| 6\r\n| 2 4 1 3 5 6  |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"order\")==',48,'task: order'),('problema/points','Points','2006-11-12 01:19:19','==Include(page=\"template/taskheader\" task_id=\"points\")==\r\n\r\n\r\nSe considera $n$ puncte in plan. Sa se determine numarul posibilitatilor de a alege trei dintre aceste puncte, astfel incat aria triunghiului determinat de acestea sa fie un numar intreg.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $points.in$ contine pe prima linie numarul $n$ al punctelor din plan. Fiecare dintre urmatoarele $n$ linii va contine cate doua numere, separate prin spatii, reprezentand coordonatele unui punct.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $points.out$ va contine o singura linie pe care se va afla numarul posibilitatilor de a alege trei dintre puncte, astfel incat aria triunghiului determinat de acestea sa fie un numar intreg.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; n &le; 10.000$\r\n* Coordonatele punctelor sunt numere intregi cuprinse intre $0$ si $1000$\r\n* Aria triunghiului determinat de trei puncte coliniare este considerata a fi $0$\r\n* Nu exista doua puncte aflate la aceleasi coordonate.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. points.in |_. points.out | \r\n| 4\r\n0 0\r\n0 2\r\n2 2\r\n2 0\r\n| 4 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"points\")==',15,'task: points'),('problema/aladdin2','Aladdin2','2006-11-11 14:56:09','==Include(page=\"template/taskheader\" task_id=\"aladdin2\")==\r\n\r\nAladdin s-a gandit la un moment dat sa intre in afaceri cu covoare, deoarece crede ca acestea sunt foarte profitabile. El a reusit sa rezolve toate problemele tehnice si acum poate sa realizeze covoare de dimensiune $m x n$. Aceste covoare sunt impartite in $m x n$ celule de dimensiune $1 x 1$. Fiecare celula va fi colorata cu alb sau cu negru. Datorita faptului ca vrea sa obtina covoare cu anumite proprietati magice este necesar ca orice patrat, de dimensiune $2 x 2$, sa contina doua celule colorate cu alb si doua celule colorate cu negru.\r\n\r\nh2. Cerinta\r\n\r\nAladdin doreste sa stie cate covoare diferite, de dimensiune $m x n$, care sa beneficieze de proprietatile magice se pot construi.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $aladdin2.in$ contine pe prima linie doua numere intregi $m$ si $n$, separate printr-un singur spatiu, care reprezinta dimensiunile pentru un covor.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $aladdin2.out$ trebuie sa contina o singura linie pe care se va afla un singur numar care reprezinta numarul de covoare de dimensiune $m x n$ care se pot construi astfel incat acestea sa beneficieze de proprietatile magice.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; m, n &le; 10000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. aladdin2.in |_. aladdin2.out |\r\n| 4 2 | 18 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"aladdin2\")==',1,'task: aladdin2'),('problema/asmax','Asmax','2006-11-11 15:25:42','==Include(page=\"template/taskheader\" task_id=\"asmax\")==\r\n\r\nSe considera un arbore (graf neorientat, conex si aciclic) cu $N$ varfuri, in care fiecare varf $i$ are asociata o valoarea intreaga $V{~i~}$. Se defineste un subarbore al arborelui dat, ca fiind un subgraf conex nevid al acestuia (care poate coincide chiar cu arborele dat).\r\n\r\nh2. Cerinta\r\n\r\nSe cere sa determinati un subarbore al unui arbore dat, pentru care suma valorilor asociate varfurilor continute in subarbore sa fie maxima.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $asmax.in$ contine numarul intreg $N$, reprezentand numarul de varfuri ale arborelui. A doua linie a fisierului contine $N$ valori intregi, reprezentand valorile asociate nodurilor. A $i$-a valoare din acest sir reprezinta valoarea asociata nodului $i$. Urmatoarele $N-1$ linii contin cate doi intregi distincti $a$ si $b$, separati printr-un spatiu, avand semnificatia ca exista muchie intre varful numerotat cu a si cel numerotat cu $b$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul asmax.out veti afisa suma maxima a unui subarbore al arborelui dat.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 16.000$\r\n* $-1000 &le; V{~i~} &le; 1000$\r\n* Varfurile sunt numerotate cu numere distincte intre 1 si $N$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. asmax.in |_. asmax.out |\r\n| 5 4 \r\n-1 1 3 1 -1\r\n4 1\r\n1 3\r\n1 2\r\n4 5 | 4 |\r\n\r\nh3. Explicatie\r\n\r\nSubarborele care contine varfurile 1,2,3 si 4 are suma 4.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"asmax\")==',1,'task: asmax'),('problema/password','Password','2006-11-11 19:57:55','==Include(page=\"template/taskheader\" task_id=\"password\")==\r\n\r\nIntr-un seif se afla niste documente pe care trebuie sa le extrageti. Problema este ca seiful este prevazut cu un terminal care necesita introducerea unei parole pentru a putea deschide seiful.\r\nLa accesarea seifului, pe ecranul terminalului este afisat un cuvant cheie format din litere mici ale alfabetului englezesc.\r\nParola este data de cea mai mica rotatie la stanga (in ordine lexicografica) a cuvantului cheie.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $password.in$ contine pe prima linie un sir de caractere format din litere mici ale alfabetului englezesc.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $password.out$ trebuie sa contina un singur numar care reprezinta numarul de deplasari circulare la stanga ale sirului din fisierul de intrare necesare pentru a obtine parola de acces ceruta.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* lungimea sirului din fisierul de intrare este un numar intreg cuprins intre $1$ si $100.000$;\r\n* daca exista mai multe solutii va fi aleasa cea care necesita un numar minim de deplasari circulare la stanga\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. password.in |_. password.out |\r\n| mississippi\r\n| 10 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"password\")==',48,'task: password'),('problema/path','Path','2006-11-11 19:57:19','==Include(page=\"template/taskheader\" task_id=\"path\")==\r\n\r\nSe considera un graf orientat aciclic ce contine $N$ noduri si $M$ arce. Nodurile sunt identificate prin litere distincte ale alfabetului englezesc (sunt permise atat litere mari, cat si litere mici). Un drum este format dintr-o succesiune de arce, iar aceste drumuri sunt ordonate in ordine lexicografica (fiecarui drum ii corespunde un sir de caractere obtinut prin concatenarea literelor corespunzatoare nodurilor, in ordinea in care apar nodurile in drum; se considera ca toate literele mici sunt, din punct de vedere lexicografic, inaintea tuturor literelor mari).\r\nDintre toate drumurile din graf, sunt luate in considerare doar cele mai lungi (lungimea unui drum este data de numarul de arce care il formeaza). Se cere ca dintre acestea din urma sa se determine cel de-al k-lea in ordine lexicografica.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $path.in$ contine trei numere intregi $N, M$ si $k$ separate intre ele printr-un singur spatiu.\r\nFiecare dintre urmatoarele $M$ linii contine doua caractere ale alfabetului englezesc $c[1]$ si $c[2]$, separate intre ele printr-un singur spatiu, cu semnificatia ca exista un arc care pleaca din nodul identificat prin $c[1]$ si ajunge in nodul identificat prin $c[2]$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $path.out$ va contine pe o singura linie un sir de caractere care reprezinta drumul determinat. Caracterele acestui sir nu vor fi separate intre ele prin spatii.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Numarul de drumuri de lungime maxima este mai mare sau egal decat $k$.\r\n* $2 &le; N &le; 52$\r\n* $1 &le; M &le; N(N-1) / 2$\r\n* Intre doua noduri poate exista cel mult o muchie.\r\n* $1 &le; K &le; 2.000.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. path.in |_. path.out |\r\n| 3 3 1\r\na b\r\nb c\r\na c\r\n| abc |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"path\")==',48,'task: path'),('problema/omizi','Omizi','2006-11-22 02:53:06','==Include(page=\"template/taskheader\" task_id=\"omizi\")==\r\n\r\nIntr-un arbore cu $N$ noduri (numerotate de la $1$ la $N$) s-au urcat $M$ omizi (numerotate de la $1$ la $M$). Ca orice fiinta, si omizile noastre faceau politica, si ca orice politician voiau sa ajunga cat mai sus in ierarhia arborelui, spre cat mai multe frunze verzi si gustoase.\r\nDesi are o gandire simpla, totusi fiecare omida tine foarte mult la orientarea sa politica. Astfel omizile de stanga aleg mereu sa mearga in sus si cat mai la stanga, iar cele de dreapta tot mai sus si cat mai spre dreapta. Spre mirarea biologilor, omizile sunt foarte politicoase. Fiecare omida ocupa o singura functie (nod) in arbore si isi asteapta randul spre promovare. Astfel in fiecare zi se efectueaza cate o promovare, si anume a celei mai inalte in functie omizi care poate urca in ierarhie (are un nod fiu vecin neocupat, prin nod fiu vecin omizile intelegand un nod imediat urmator situat mai sus in arbore). Daca sunt mai multe omizi cu acelasi rang, atunci se trage la sorti. Omida zilei alege unde anume vrea sa urce daca are mai multe posibilitati conform orientarii sale politice.\r\n\r\nh2. Cerinta\r\n\r\nPentru a putea evalua pagubele si pentru a mai salva ceva din calea omizilor politice, gradinarul a hotarat sa apeleze la voi pentru a afla care vor fi pozitile omizilor dupa toate promovarile.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $omizi.in$ se gasesc numerele naturale $N$ si $M$, cu semnificatia din enunt. Pe urmatoarele $N$ linii se afla descrierea arborelui. Mai exact, pe linia $i+1$ este scrisa lista fiilor nodului $i$ de la stanga la dreapta ca orientare politica, terminata cu numarul $0$. Fii sunt separati prin cate un spatiu. Pe urmatoarele $M$ linii se gasesc informatii despre omizi. Mai exact, pe linia $N+1+i$ se afla un numar $x$ si o litera majuscula $L$ separate prin spatiu ({$x$} reprezinta numarul nodului in care se afla initial omida $i$, iar $L$ este orientarea politica a omizii $i - S$ pentru stanga si $D$ pentru dreapta).\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $omizi.out$ va avea $M$ linii, fiecare continand un numar de la $1$ la $N$. Pe linia $i$ este scrisa pozitia finala a omizii $i$ (dupa toate promovarile).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; N &le; 16 000$\r\n* $2 &le; M &le; N$\r\n* Radacina arborelui este intotdeauna nodul $1$\r\n* Rangul unei omizi este distanta in numar de muchii de la radacina pana la nodul unde este pozitionata.\r\n* Omizile vor alege intotdeauna nodurile accesibile conform orientarii politice. De exemplu, ordinea preferata pentru o omida ce urmeaza sa fie promovata si care este intr-un nod cu $3$ fii, $4, 5$ si $6$ (de la stanga la dreapta) este $4, 5, 6$ pentru o omida de stanga si $6, 5, 4$ pentru una de dreapta, aceasta alegand primul fiu care nu este deja ocupat\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. omizi.in |_. omizi.out |\r\n| 4 2\r\n  2 3 0\r\n  4 0\r\n  0\r\n  0\r\n  1 S\r\n  2 S\r\n| 2\r\n  4 |\r\n| 10 5\r\n  2 5 9 0\r\n  0\r\n  8 4 0\r\n  0\r\n  3 6 7 0\r\n  0\r\n  10 0\r\n  0\r\n  0\r\n  0\r\n  1 D\r\n  6 S\r\n  7 D\r\n  5 S\r\n  9 S\r\n| 7\r\n  6\r\n  10\r\n  8\r\n  9 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"omizi\")==',1,'task: omizi'),('problema/csir','Csir','2006-11-11 22:42:49','==Include(page=\"template/taskheader\" task_id=\"csir\")==\r\n\r\nUn sir circular este un sir format numai din caracterele $\"A\"$ si $\"B\"$ care are urmatoarele proprietati:\r\n\r\n* are lungime 1 &le; $N$ (nu poate fi sirul vid);\r\n* se considera ca dupa ultimul caracter din sir urmeaza primul caracter din sir.\r\n\r\nAceasta proprietate implica faptul ca orice sir circular are $N$ subsecvente de lungime $L$ ( $1 &le; L &le; N$ ). O subsecventa de lungime $L$ a unui sir circular $S$ este un sir de caractere (obisnuit, nu circular) format din $L$ caractere aflate pe pozitii consecutive in sirul $S$ . De exemplu, sirul circular $\"ABAAB\"$ are 5 subsecvente de lungime 3: $\"ABA\", \"BAA\", \"AAB\", \"ABA\"$ si $\"BAB\"$ (ele nu sunt distincte ca valoare, insa difera ca pozitie de inceput in sirul din care fac parte).\r\nUn csir este un sir circular care are in plus urmatoarea proprietate: pentru orice $L$ ( $1 &le; L &le; N$ )si oricare doua subsecvente de lungime $L$ (sa le numim $S1$ si $S2$), numarul de caractere $\"A\"$ din $S1$ difera fata de numarul de caractere $\"A\"$ din $S2$ cu cel mult $1$ (in valoare absoluta).Sa consideram sirul circular $\"BBAABAA\"$. Acest sir nu este un csir, deoarece exista subsecventele $\"BBAAB\"$ si $\"AABAA\"$ (de lungime $5$), care contin $2$, respectiv $4$ caractere $\"A\"$ (diferenta dintre numarul de caractere $\"A\"$ este, astfel, $2$). De asemenea, sirul $\"ABABAABAAB\"$ nu este un csir, deoarece contine subsecvente $\"AABAA\"$ si $\"BABAB\"$ pentru care diferenta dintre numarul de caractere $\"A\"$ este mai mare decat 1 (in valoare absoluta). Sirurile circulare $\"ABA\"$ si $\"AABABAAB\"$ sunt, in schimb, csir-uri, deoarece oricare ar fi doua subsecvente $S1$ si $S2$ avand aceeasi lungime, diferenta dintre numarul de caractere $\"A\"$ din $S1$ si numarul de caractere $\"A\"$ din $S2$ este mai mica sau egala cu $1$ (in valoare absoluta).\r\n\r\nh2. Cerinta\r\n\r\nDandu-se mai multe siruri circulare, determinati daca ele sunt csir-uri.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $csir.in$ contine numarul intreg $S$ , reprezentand numarul de siruri continute in fisier. Pe fiecare dintre urmatoarele $S$ linii se afla cate un sir circular.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $csir.out$ se vor scrie $S$ linii. Pe a $K$-a linie din acest fisier, se va afisa $1$ , daca al $K$-lea sir din fisierul de intrare este un csir, sau $0$, in caz contrar.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; S &le; 20$\r\n* Lungimea fiecarui sir circular din fisierul de intrare este cuprinsa intre 1 si 50.000 (inclusiv).\r\n* Sirurile contin numai caracterele $\"A\"$ si $\"B\"$ (nu si $\"a\"$ sau $\"b\"$).\r\n* Nu se acorda punctaje partiale.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. csir.in |_. csir.out |\r\n|4 \r\nBBAABAA \r\nABABAABAAB \r\nABA \r\nAABABAAB | 0 \r\n0\r\n1\r\n1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"csir\")==',1,'task: csir'),('problema/panouri','Panouri','2006-11-11 20:54:17','==Include(page=\"template/taskheader\" task_id=\"panouri\")==\r\n\r\nPe autostrada \"Soarele Estului \" sunt asezate de-a lungul soselei, la distante egale, panouri publicitare ale unor firme. Aceeasi firma, poate sa aiba mai multe panouri publicitare si fiecare panou poate sa apara in mai multe locuri. Tipurile de panouri se identifica prin numere naturale, numarul total de panouri fiind $N$.\r\nFirma \"X Corporation\" are panouri de $T$ tipuri diferite. Firma a primit aprobarea construirii unui mare complex turistic in apropierea autostrazii; de aceea, pentru alegerea locului, este interesata si de urmatorul aspect: care este lungimea minima de sosea, in care se pot intalni, toate cele $T$ tipuri de panouri publicitare ale firmei, indiferent de ordinea acestora, si indiferent daca intre ele se mai interpun sau nu panouri ale altor firme.\r\n\r\nh2. Cerinta\r\n\r\nCunoscand $N$ - numarul total de panouri de la marginea autostrazii si ordinea amplasarii lor, ca si cele $T$ tipuri de panouri amplasate de firma, determinati numarul minim de intervale dintre doua panouri intre care firma \"X Corporation\" isi regaseste toate panourile sale.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $panouri.in$ are pe prima linie numerele $N$ si $T$. Pe urmatoarele $N$ linii, sunt $N$ numere naturale, nu neaparat diferite, cate unul pe linie, fiecare numar reprezentind tipul panoului respectiv, iar incepand cu linia $N + 2$, cate unul pe linie, cele $T$ tipuri de panouri diferite al firmei.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $panouri.out$ va contine pe prima linie un singur numar intreg pozitiv $L$, reprezentand numarul cerut, sau $-1$ in caz ca nu exista solutie.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 200.000$\r\n* $1 &le; T &le; 20.000$\r\n* Toate numerele reprezentand panouri sunt numere naturale din intervalul $[1..20.000]$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. panouri.in |_. panouri.out |\r\n| 6 2\r\n  1\r\n  2\r\n  3\r\n  5\r\n  3\r\n  1\r\n  5\r\n  1\r\n| 2 |\r\n| 8 3\r\n  5\r\n  1\r\n  3\r\n  3\r\n  5\r\n  4\r\n  2\r\n  1\r\n  3\r\n  1\r\n  4 \r\n| 4 |\r\n\r\nh3. Explicatii\r\n\r\n* Sunt N = 6 panouri : 1 2 3 5 3 1. Firma are T = 2 tipuri de panouri: 5 si 1. Cel mai scurta secventa care contine elementele 5 si 1, este intre panourile  al 4 &#8211; lea si al 6 -lea , si contine 2 intervale.\r\n* Sunt N = 8 panouri de tipurile: 5 1 3 3 5 4 2 1. Firma are T = 3 tipuri de panouri: 3, 1 si 4. Cel mai scurta secventa care contine elementele 1, 3 si 4, este intre al 2 lea si al 6-lea panou, si contine 4 intervale.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"panouri\")==',48,'task: panouri'),('problema/mine','Mine','2006-12-19 12:41:28','==Include(page=\"template/taskheader\" task_id=\"mine\")==\r\n\r\nDupa ce si-a recuperat harta, Max Damage se gaseste din nou in masina urmarit de politisti. Pentru a scapa se hotaraste sa se ascunda intr-o mina parasita. Problema e ca inauntru este intuneric, iar de la atatea \"acrosari\" farurile nu mai lumineaza. El pune in functiune un vechi generator de electricitate pentru a lumina galeriile minei, insa acesta functioneaza ciudat si uneori ofera mai multa electricitate, alteori mai putina. Din fericire, Damage stie cum variaza cantitatea de energie electrica. El are de asemenea o harta a minei. Aceasta este formata din galerii care se unesc in intersectii. Intre doua intersectii pot exista oricate galerii, doua galerii nu se intalnesc decat in intersectii, iar o galerie poate fi parcursa in ambele directii. De asemenea Max stie pentru fiecare galerie care trebuie sa fie cantitatea minima de elecricitate produsa de generator pentru a fi parcursa in siguranta. Toate galeriile au aceeasi lungime si pot fi parcurse intr-un singur interval de timp (evident, daca este destula lumina). Deci tot ce-i trebuie acum este un plan.\r\n\r\nh2. Cerinta\r\n\r\nMax vrea sa ajunga de la intrarea principala (intersectia numarul $1$) la iesirea de urgenta (intersectia numarul {$N$}), iar voi va trebui sa ii spuneti cat de repede poate face asta.\r\n\r\nh2. Date de Intrare\r\n\r\nDin fisierul $mine.in$ se citesc pe prima linie $N$(numarul de intersectii) si $M$( numarul de galerii).\r\nPe urmatoarele $M$ linii se citesc cate $3$ numere $i j k$ cu semnificatia ca exista o galerie de la intersectia $i$ la intersectia $j$ iar cantitatea minima de electricitate necesara este $k$.\r\nPe linia urmatoare se gaseste $W$, urmata de $W$ valori. A $q-a$ valoare reprezinta cantitatea de energie electrica generata la momentul $q$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $mine.out$ se va scrie un singur numar $t$, timpul minim in care Max poate iesi din mina, sau $-1$ daca nu are nici o sansa.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $1 &le; N &le; 10^4^$\r\n* $1 &le; M &le; 10^5^$\r\n* $1 &le; W &le; 10^6^$\r\n* Capacitatea minima de electricitate pentru o muchie este cuprinsa intre $0$ si $10^9^$\r\n* Max Damage poate astepta oricat timp intr-o intersectie\r\n* Daca sirul de $W$ valori se termina, generatorul se opreste si nimeni nu vrea sa ramana intr-o mina parasita pe intuneric (chiar daca ultimele galerii pana la iesire au valoarea $k$ egala cu $0$)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. mine.in |_. mine.out |\r\n| 3 2\r\n  1 2 5\r\n  2 3 10\r\n  5\r\n  2 6 9 10 0\r\n| 4 |\r\n\r\nh3. Explicatie\r\n\r\nMax ramane la timpul 1 in intersectia 1, la timpul 2 se deplaseaza in intersectia 2, la timpul 3 sta pe loc, iar la timpul 4 se deplaseaza in intersectia 3. \r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"mine\")==',256,'task: mine'),('problema/bcolor','Bcolor','2006-12-12 08:52:52','==Include(page=\"template/taskheader\" task_id=\"bcolor\")==\r\n\r\nOmida Smith s-a apucat din nou de colorat. De data aceasta s-a gandit sa incerce cu grafuri neorientate cu $N$ noduri etichetate de la $1$ la $N$ si $M$ muchii numerotate de la $1$ la $M$.\r\n\r\nLa o plimbare, Smith porneste din nodul etichetat cu $1$, se plimba pe muchiile grafului, dupa care se intoarce in nodul de plecare. Astfel, drumul parcurs de Smith incepe si se termina cu nodul $1$, poate trece de mai multe prin acelasi nod si de asemenea poate trece de mai multe ori prin aceeasi muchie. Muchiile grafului sunt initial colorate in alb, iar la fiecare trecere a omizii peste o muchie aceasta isi schimba culoarea: din alba devine rosie si din rosie devine alba.\r\n\r\nFiecarui drum ii corespunde astfel o colorare finala a muchiilor, pe care vom numi configuratie posibila si o vom reprezenta ca un sir de $M$ elemente reprezentand in ordine culorile finale ale muchiilor ({$A$} pentru alb, respectiv $R$ pentru rosu). Omida a observat ca din toate configuratiile posibile, nu toate sunt frumoase. Exista unele muchii speciale care nu arata bine decat daca au o anumita culoare.\r\n\r\nSmith vrea sa dea lovitura pe piata de grafuri de arta, asa ca genereaza pentru un graf dat toate configuratiile frumoase posibile in ordine lexicografica. Va lansa pe piata cea de a $K$-a configuratie generata, configuratiile fiind numerotate incepand cu $1$.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine cea de a $K$-a configuratie frumoasa posibila, in ordine lexicografica.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $bcolor.in$ se vor afla numerele naturale $N, M, K$ separate prin cate un spatiu. Pe urmatoarele $M$ linii se vor afla descrierile muchiilor grafului.\r\n\r\nPe linia $i+1$ se va afla descrierea muchiei $i$, formata din $3$ numere naturale $x, y, z$ separate prin cate un spatiu. Numerele $x$ si $y$ reprezinta nodurile care sunt extremitatile muchiei, iar $z$ este un numar care poate lua valorile cu semnificatia de mai jos:\r\n\r\n* $z=0$ &nbsp;&nbsp;&nbsp; muchia nu este speciala\r\n* $z=1$ &nbsp;&nbsp;&nbsp; muchia este speciala, trebuie neaparat colorata in alb\r\n* $z=2$ &nbsp;&nbsp;&nbsp; muchia este speciala, trebuie neaparat colorata in rosu.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $bcolor.out$ va contine o singura linie formata din $M$ caractere din multimea ${A, R}$ reprezentand in ordine culorile muchiilor din cea de a $K$-a configuratie frumoasa posibila pentru graful din fisierul de intrare.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 200$\r\n* $1 &le; K &le; 10^8^$\r\n* Exista minim $K$ configuratii frumoase posibile pentru graful dat.\r\n* Muchiile din fisierul de intrare sunt distincte.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bcolor.in |_. bcolor.out |\r\n| 10 10 2\r\n1 2 0\r\n3 5 1\r\n2 3 0\r\n3 4 0\r\n4 5 0\r\n5 2 0\r\n2 4 0\r\n6 7 0\r\n7 8 0\r\n8 6 0\r\n| AAAARRRAAA |\r\n\r\nh3. Explicatii\r\n\r\nConfiguratiile frumoase posibile in ordine lexicografica sunt:\r\n\r\n# $AAAAAAAAAA$\r\n# $AAAARRRAAA$\r\n# $AARRAARAAA$\r\n# $AARRRRAAAA$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bcolor\")==',1,'task: bcolor'),('problema/ben','Ben','2006-11-11 22:40:56','==Include(page=\"template/taskheader\" task_id=\"ben\")==\r\n\r\nLa o benzinarie sosesc intr-o zi $N$ masini pentru a se alimenta. Pentru fiecare masina se cunoaste momentul sosirii si momentul plecarii din benzinarie, intervalul de timp dintre sosire si plecare fiind utilizat exclusiv pentru alimentare. O pompa de benzina se poate utiliza pentru alimentarea unei singure masini la un moment dat (ea poate sa alimenteze mai multe masini dar nu in acelasi timp). Alimentarea unei masini incepe exact in momentul sosirii ei in benzinarie si se termina exact in momentul plecarii, fiind utilizata o singura pompa pe tot timpul parcarii sale in benzinarie.\r\n\r\nh2. Cerinta\r\n\r\nStiind informatiile despre sosirile si plecarile celor $N$ clienti, aflati $K$ reprezentand numarul minim de pompe de benzina necesare servirii tuturor clientilor. Se cere si numarul de modalitati distincte de servire a clientilor utilizand exact $K$ pompe de alimentare.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul $ben.in$ se afla pe prima linie un numar $N$ reprezentand numarul de clienti. Urmeaza $N$ linii fiecare continand doua numere, $A$ si $B$ ({$A<B$}), separate printr-un spatiu reprezentand timpul de sosire respectiv timpul de plecare al unui client.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $ben.out$ va contine o singura linie pe care se vor afla doua numere intregi $K$ si $S$ reprezentand numarul minim de pompe de alimentare si numarul de modalitati de servire a clientilor folosind exact $K$ pompe de alimentare. Numarul $S$ va fi afisat modulo {$32173$}.\r\n\r\nh2. Restrictii\r\n\r\n* {$0 &le; N &le; 30 000$}, dar pentru $70%$ din teste $N &le; 300$\r\n* Timpii de sosire si plecare vor fi numere intregi din intervalul [{$1, 30 000$}]\r\n* Nu va exista o masina care soseste in momentul pleacarii altei masini\r\n* Daca primul numar din fisierul de iesire este corect veti primi $6$ puncte pe acel test iar daca sunt corecte ambele numere veti primi $10$ puncte. Nu se vor acorda puncte daca este corect numai cel de-al doilea numar.\r\n* Doua modalitati de servire a clientilor se considera diferite daca exista cel putin un client care nu a fost servit la aceeasi pompa in cele doua modalitati\r\n* Clientilor nu le place sa astepte asa ca trebuie sa va asigurati ca exista cel putin o pompa libera la sosirea fiecaruia in benzinarie\r\n* Atentie! Numarul se va afisa modulo $32173$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. ben.in |_. ben.out |\r\n| 4\r\n1 4\r\n5 7\r\n8 10\r\n2 7\r\n| 2 4 |\r\n\r\nh3. Explicatii\r\n\r\nNumarul minim de pompe de alimentare este 2. Cele 4 modalitati de servire ale clientilor sunt:\r\n1, 1, 1, 2 (prima modalitate) \r\n1, 1, 2, 2 (a doua)\r\n2, 2, 1, 1 (a treia)           \r\n2, 2, 2, 1 (a patra)\r\nFiecare numar reprezinta indicele pompei la care s-a alimentat fiecare client, pastrand ordinea acestora din fisierul de intrare.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"ben\")==',15,'task: ben'),('problema/bile','Bile','2006-11-11 16:13:55','==Include(page=\"template/taskheader\" task_id=\"bile\")==\r\n\r\nPe o tabla patratica impartita in $N*N$ patratele ({$N$} linii si $N$ coloane), se afla asezate $N*N$ bile (cate una in fiecare patratica a tablei). Lui Gigel ii plac bilele foarte mult, astfel ca el ia, pe rand, cate o bila de pe tabla, pana cand nu mai ramane pe tabla nici o bila. Gigel este, de asemenea, un baiat foarte curios. El a constatat ca bilele pot fi impartite in componente conexe, astfel:\r\n\r\n* fiecare bila face parte din exact o componenta conexa\r\n* daca 2 bile sunt invecinate pe orizontala sau verticala, atunci ele fac parte din aceeasi componenta conexa (adica daca una se afla imediat deasupra, dedesubtul, la dreapta sau la stanga celeilalte)\r\n\r\nDimensiunea unei componente conexe este egala cu numarul de bile care fac parte din componenta conexa respectiva. Dupa fiecare bila luata, Gigel vrea sa stie care este valoarea maxima dintre dimensiunile componentelor conexe din care fac parte bilele ramase.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $bile.in$ contine numarul intreg $N$, reprezentand numarul de linii si de coloane ale tablei. Pe urmatoarele $N^2^$ linii se afla cate 2 numere intregi $L$ si $C$, separate printr-un spatiu, reprezentand linia si coloana pe care se afla bila pe care o ia Gigel. Coordonatele bilelor sunt date in ordinea in care bilele sunt luate de pe tabla.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $bile.out$ veti afisa $N^2^$ linii. Pe fiecare linie veti afisa dimensiunea maxima ceruta dupa fiecare bila luata de pe tabla.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 250$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bile.in |_. bile.out |\r\n|3\r\n2 1\r\n2 2\r\n3 3\r\n1 3\r\n1 2\r\n2 3\r\n3 1\r\n1 1\r\n3 2|8\r\n 7\r\n 4\r\n 2\r\n 2\r\n 2\r\n 1\r\n 1\r\n 0 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bile\")==',1,'task: bile'),('problema/zoo','Zoo','2006-11-11 16:12:27','==Include(page=\"template/taskheader\" task_id=\"zoo\")==\r\n\r\nFermierul Ion are o idee originala: sa infiinteze pe teritoriul fermei sale gradina zoologica _Madame Tussaud_. Si fiindca deja are o colectie impresionanta de animale de ceara, in marime naturala, raspandite pe teritoriul fermei sale acest lucru nu e foarte dificil. In acest scop a luat harta fermei sale, pe care este fixat un sistem de coordonate si pe care sunt marcate pozitiile animalelor pe teritoriul fermei. Fiecare animal este plasat pe teritoriul fermei intr-un punct de coordonate intregi si nu poate fi mutat fara a-l deteriora. Gradina zoologica pe care o proiecteaza Ion va avea forma unui dreptunghi avand laturile paralele cu axele de coordonate si Ion ar dori ca aceasta sa contina cat mai multe animale. Inainte de a incepe constructia, fermierul face un studiu, pentru a gasi pozitia optima de amplasare a gradinii zoologice. Pentru aceasta, el si-a ales cateva pozitii unde ar putea sa construiasca gradina zoologica. Pentru fiecare dintre ele, ar dori sa stie cate animale dintre cele $N$ pe care le are se afla in interiorul gradinii (sau pe marginile acesteia).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine pentru fiecare amplasare posibila a gradinii zoologice numarul de animale care s-ar afla in interiorul acesteia (sau pe margini).\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare $zoo.in$ contine numarul intreg $N$, reprezentand numarul de animale. Fiecare dintre urmatoarele $N$ linii contine coordonatele $x$ si $y$ ale unui animal, separate prin spatiu. Urmatoarea linie contine numarul intreg $M$, reprezentand numarul posibilitatilor de amplasare a gradinii zoologice. Pe fiecare dintre urmatoarele $M$ linii se afla patru numere intregi separate prin spatii: $x1$ $y1$ $x2$ $y2$ unde ({$x1$},{$y1$}) reprezinta coordonatele coltului stanga-jos al gradinii zoologice, iar ({$x2$},{$y2$}) reprezinta coordonatele coltului dreapta-sus.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $zoo.out$ veti afisa pentru fiecare posibilitate de amplasare a gradinii zoologice cate o linie pe care sefla numarul de animale aflate in interiorul sau pe marginile acesteia.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 16.000$\r\n\r\n* $1 &le; M &le; 100.000$\r\n\r\n* Coordonatele fiecarui animal si ale colturilor fiecarui dreptunghi sunt numere intregi din intervalul [$-2.000.000.000$, $2.000.000.000$]\r\n\r\n* Pot exista mai multe animale in acelasi punct\r\n\r\n* $x1 < x2$ si $y1 < y2$ pentru fiecare dreptunghi descris in fisierul de intrare\r\n\r\n* Orice linie se termina cu Enter\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. zoo.in |_. zoo.out |\r\n| 5\r\n0 0\r\n1 0\r\n2 0\r\n0 1\r\n1 1\r\n3\r\n0 0 1000 1000\r\n-1000 -1000 0 0\r\n1 0 2 2\r\n| 5\r\n1\r\n3|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"zoo\")==',256,'task: zoo'),('problema/senat','Senat','2006-11-12 15:15:30','==Include(page=\"template/taskheader\" task_id=\"senat\")==\r\n\r\nIn Parlamentul unei tari democratice, fiecare senator poate face parte din zero sau mai multe comisii parlamentare. Fiecare comisie are cate un presedinte, ales dintre membrii acesteia. Din principii democratice, un senator nu poate fi presedinte decat cel mult intr-o comisie. Acum senatul vrea sa determine o modalitate de a alege presedintii pentru fiecare comisie in parte astfel incat sa nu existe doua comisii cu acelasi presedinte.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine o posibila stabilire a presedintilor pentru fiecare comisie.\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul de intrare $senat.in$ se afla pe prima linie numarul $N$ de senatori, iar pe cea de a doua linie numarul $M$ de comisii. Pe fiecare dintre urmatoarele $M$ linii se va descrie componenta cate unei comisii. O comisie este data prin membrii ei, separati prin cate un spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $senat.out$ va contine exact $M$ linii, pe linia a $i$-a aflandu-se presedintele ales pentru a $i$-a comisie. Daca nu exista solutie, fisierul de iesire va contine o singura linie pe care se va afla numarul {$0$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100$\r\n* $1 &le; M &le; 100$\r\n* Daca exista mai multe solutii, se va afisa oricare dintre ele\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. senat.in|_. senat.out|_. senat.in|_. senat.out|\r\n|5\r\n3\r\n1 2 4\r\n5 3 1\r\n3 4\r\n|1\r\n5\r\n3\r\n|2\r\n3\r\n1 2\r\n1\r\n2\r\n|0\r\n|\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"senat\")==',256,'task: senat'),('problema/vila','Vila','2006-11-11 17:19:13','==Include(page=\"template/taskheader\" task_id=\"vila\")==\r\n\r\nUn important om al tarii are o vila, reprezentata printr-o matrice ce contine numai caracterele 1 si -, unde 1 reprezinta zid iar - spatiu liber. O camera este formata dintr-o multime de casute libere cu proprietatea ca se poate ajunge din orice casuta a camerei in oricare alta casuta ale aceleiasi camere, mergand doar pe una din directiile {$N$, $S$, $E$, $V$}, si trecand doar prin spatii libere. De exemplu, vila codificata prin matricea de mai jos are 3 camere:\r\n\r\n{$1111111111111$}\r\n{$1-------1----$}\r\n{$----111111111$}\r\n{$1-------1---1$}\r\n{$1111111111111$}\r\n\r\nh2. Cerinta\r\n\r\nSa se determine:\r\n\r\na ) cate camere are vila;\r\n\r\nb ) care este camera cu suprafata cea mai mare;\r\n\r\nc ) ce perete trebuie indepartat ( prin perete se intelege un singur caracter de 1 ), astfel incat sa se obtina cea mai mare camera ( ca suprafata ), in raport cu toate celelalte camere care se pot obtine indepartand un perete.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $vila.in$ are urmatorul format: pe prima linie se gasesc doua numere naturale $M$ si $N$, despartite printr-un spatiu, care reprezinta numarul de linii, respectiv de coloane, ale matricii ce reprezinta vila, iar pe urmatoarele $M$ linii se gasesc cate $N$ caractere din multimea {${1, -}$}, descriind matricea.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $vila.out$ contine raspunsurile in urmatorul format: prima linie contine numarul de camere, a doua linie contine aria camerei de suprafata maxima, iar a treia linie contine coordonatele zidului eliminat si aria camerei de suprafata maxima rezultata.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M < 128$\r\n* Daca exista mai multe solutii pentru punctul c, se va afisa cea in care prima coordonata este minima. Daca si in acest caz exista mai multe solutii, se va afisa cea in care suma coordonatelor este minima\r\n* Nu se acorda punctaje partiale\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. vila.in|_. vila.out|\r\n|5 13\r\n1111111111111\r\n1-------1----\r\n----111111111\r\n1-------1---1\r\n1111111111111\r\n|3\r\n18\r\n2 9 23|\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"vila\")==',256,'task: vila'),('problema/puternic','Puternic','2006-11-12 15:08:08','==Include(page=\"template/taskheader\" task_id=\"puternic\")==\r\n\r\nNumerele puternice sunt acele numere naturale care au numarul divizorilor mai mare decat numarul divizorilor oricarui numar natural mai mic decat numarul respectiv. De exemplu, primele $4$ numere puternice sunt $1, 2, 4$ si $6$.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine cel de-al $N$-lea numar puternic.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $puternic.in$ contine pe prima linie numarul $N$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $puternic.out$ contine pe prima si singura linie al $N$-lea numar puternic.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N < 181$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. puternic.in |_. puternic.out |\r\n| 3 | 4 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"puternic\")==',1,'task: puternic'),('problema/hprob','Hprob','2006-11-12 15:09:08','==Include(page=\"template/taskheader\" task_id=\"hprob\")==\r\n\r\nIntr-un magazin sunt $4$ obiecte ({$A$}, {$B$}, {$C$} si {$D$}) asezate intr-o anumita ordine. Magazinul este vizitat pe rand de $N$ clienti. Fiecare client se uita la obiecte si le probeaza. Dupa ce se uita la ele si le probeaza, incearca sa le aseze la loc in ordinea potrivita, dar - desigur - nu isi mai aminteste exact ordinea in care erau asezate la venirea sa.\r\n\r\nPentru fiecare client exista probabilitatea $p1$ ca acesta sa aseze toate obiectele permutate circular la dreapta cu o pozitie fata de ordinea originala. Daca initial ordinea obiectelor era ({$A$}, {$B$}, {$C$} si {$D$}), la sfarsit aceasta va fi ({$D$}, {$A$}, {$B$} si {$C$}).\r\n\r\nPentru fiecare client exista probabilitatea $p2$ ca acesta sa aranjeze obiectele in ordine inversa celei originale. Daca initial ordinea obiectelor era ({$A$}, {$B$}, {$C$} si {$D$}), la sfarsit aceasta va fi ({$D$}, {$C$}, {$B$} si {$A$}).\r\n\r\nPentru fiecare client exista probabilitatea $p3$ ca acesta sa aranjeze obiectele interschimband ordinea celor de la mijloc. Daca initial ordinea obiectelor era ({$A$}, {$B$}, {$C$} si {$D$}), la sfarsit aceasta va fi ({$A$}, {$C$}, {$B$} si {$D$}).\r\n\r\nPentru fiecare client exista probabilitatea $p4 = 1.0 - p1 - p2 - p3$ sa aseze obiectele inapoi in ordinea originala.\r\n\r\nh2. Cerinta\r\n\r\nDat fiind numarul $N$ de clienti, calculati probabilitatea ca dupa ce acestia sa fi incercat toate obiectele pe rand, ordinea lor finala sa fie identica cu cea originala.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $hprob.in$ va contine numarul $T$ de teste, urmat de $T$ linii, fiecare continand numarul $N$ de clienti, urmat de $3$ numere reale, {$p1$}, {$p2$} si {$p3$} cu semnificatiile de mai sus.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $hprob.out$ va contine $T$ linii, fiecare continand un numar real rotunjit la $5$ zecimale in fuctie de ce-a de-a {$6$}-a, reprezentand probabilitatea ceruta.\r\n\r\nh2. Restrictii\r\n\r\n* $0 &le; N &le; 1000 000 000$\r\n* $1 &le; T &le; 6$\r\n* $0 &le; p1, p2, p3 &le; 1$\r\n* $0 &le; p1 + p2 + p3 &le; 1$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. hprob.in |_. hprob.out |\r\n| 6\r\n0 0.1 0.2 0.3\r\n1 0.1 0.2 0.3\r\n10 0.1 0.2 0.3\r\n100 0.1 0.2 0.3\r\n1000 0.1 0.2 0.3\r\n1000000000 0.1 0.2 0.3\r\n| 1.00000\r\n0.40000\r\n0.09719\r\n0.04167\r\n0.04167\r\n0.04167 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"hprob\")==',961,'task: hprob'),('problema/iv','Iv','2006-11-12 01:04:07','==Include(page=\"template/taskheader\" task_id=\"iv\")==\r\n\r\nNu se stie de ce Igor si Vitalie s-au apucat de matematica. Cert e ca s-au lovit de o problema pentru care creionul si hartia nu sunt suficiente. Avand la dispozitie doua siruri de caractere, ei incearca sa le interclaseze astfel incat sa obtina un palindrom. Desi obtinerea unui singur palindrom este o treaba usoara, ei ar dori sa calculeze cate moduri diferite de a interclasa cele doua siruri exista astfel incat rezultatul sa fie palindrom.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-i pe Igor si Vitalie sa rezolve aceasta problema ce le framanta spiritul..\r\n\r\nh2. Date de intrare\r\n\r\nFisierul $iv.in$ contine doua linii, cate una pentru fiecare sir de caractere, fiecare format din cel mult $500$ de litere mici ale alfabetului englez.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul $iv.out$ va contine pe prima linie un singur numar, reprezentand numarul calculat de posibilitati modulo $3210121$.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* Lungimea fiecarui sir de caractere este cuprinsa intre $1$ si $500$\r\n* Pentru $20%$ din teste lungimea fiecaruia din cele doua siruri este cuprinsa intre $1$ si $10$\r\n* Pentru $60%$ din teste lungimea fiecaruia din cele doua siruri este cuprinsa intre $1$ si $200$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. iv.in |_. iv.out |\r\n| ab\r\nba\r\n| 4 |\r\n\r\nh3. Explicatii\r\n\r\nExista $4$ posibilitati de a interclasa cele doua siruri astfel incat sa se obtina un palindrom. Caracterele primului sir sunt marcate cu rosu, cele din al doilea sir sunt marcate cu albastru:\r\n{%{color:red}ab%}{%{color:blue}ba%}\r\n{%{color:red}a%}{%{color:blue}b%}{%{color:red}b%}{%{color:blue}a%}\r\n{%{color:blue}b%}{%{color:red}a%}{%{color:blue}a%}{%{color:red}b%}\r\n{%{color:blue}ba%}{%{color:red}ab%}\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"iv\")==',15,'task: iv'),('problema/free','Free','2006-11-12 13:09:15','==Include(page=\"template/taskheader\" task_id=\"free\")==\r\n\r\n\r\nLa Inchisoarea Vesela directorul nu a mai avut un incident cu detinutii sai de foarte mult timp. De aceea a decis sa dea drumul catorva dintre ei in urma unui joc. In inchisoare exista $N$ celule. Usa fiecarei celule este actionata de un buton care ii schimba startea(daca e inchisa se deschide, iar daca e deschisa se inchide). Initial toate usile sunt inchise si se vor efectua $N$ pasi. La fiecare pas $i$ directorul va numara din $i$ in $i$ si va apasa butonul in dreptul usii la care se opreste. La sfarsit ii va lasa sa plece pe detinutii din celulele ramase deschise.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se $N$ numarul de celule din Inchisoarea Vesela calculati numarul detinutilor nefericiti care raman in continuare in celulele lor.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $free.in$ se afla $N$, numarul de celule din Inchisoarea Vesela.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $free.out$ va contine $X$, numarul detinutilor care vor ramane in continuare inchisi.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 10^100^$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. free.in |_. free.out |\r\n| 6 | 4 |\r\n\r\nh3. Explicatii\r\n\r\nLa pasul $1$ paznicul va actiona butoanele celulelor $1, 2, 3, 4, 5, 6$.\r\nLa pasul $2$ paznicul va actiona butoanele celulelor $2, 4, 6$.\r\nLa pasul $3$ paznicul va actiona butoanele celulelor $3$, $6$.\r\nLa pasul $4$ paznicul va actiona butonul celulei $4$.\r\nLa pasul $5$ paznicul va actiona butonul celulei $5$.\r\nLa pasul $6$ paznicul va actiona butonul celulei $6$.\r\nLa sfarsit vor ramane deschise doar usile $1$ (a fost actionat o singura data butonul) si $4$ (actionat de $3$ ori).\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"free\")==',15,'task: free'),('problema/ferma','Ferma','2006-11-12 13:10:22','==Include(page=\"template/taskheader\" task_id=\"ferma\")==\r\n\r\nZaharel s-a dus in vizita la bunicii lui de la tara impreuna cu Eugenia. Ferma bunicilor este de forma circulara, iar acolo cresc $N$ gaini. Ferma a fost impartita in $N$ sectoare, numerotate de la $1$ la {$N$}, astfel incat oricare doua sectoare avand numere consecutive sunt adiacente (se afla unul langa altul). In plus, primul si ultimul sector sunt adiacente. In fiecare sector se afla cate o gaina, iar aceasta depune oua in fiecare zi. Bunicii stiu pentu fiecare gaina care este productivitatea ei, adica un numar care reprezinta diferenta dintre consumul gainii si cat produce. Zaharel si cu Eugenia strang de $K$ ori pe zi oua de la gaini astfel: la fiecare strangere cei doi aleg o secventa (adica un sir de sectoare adiacente) formata din cel putin un sector, care contine numai gaini de la care nu s-au luat oua in acea zi.\r\n\r\nh2. Cerinta\r\n\r\nCunoscand productivitatea fiecarea gaini cat si numarul de strangeri dintr-o zi, ajutati-i pe Zaharel si Eugenia sa stranga oua astfel incat suma productivitatilor gainilor de la care a strans oua sa fie maxima.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $ferma.in$ se gasesc numerele naturale $N$ si {$K$}. Pe urmatoarea linie se vor gasi $N$ numere intregi reprezentand productivitatea fiecarei gaini.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului de iesire $ferma.out$ se va afisa suma maxima posibila a productivitatilor gainilor de la care se strang oua.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 10.000$\r\n* $1 &le; K &le; 1.000$\r\n* Productivitatea fiecarei gaini este un numar intreg din intervalul [{$-100.000, 100.000$}]\r\n* Daca suma maxima posibila a productivitatilor este un numar negativ se va afisa $0$ (se prefera sa nu se stranga nici un ou)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. ferma.in |_. ferma.out |\r\n| 8 2\r\n2 -6 4 3 -7 -9 10 -1\r\n| 18 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"ferma\")==',961,'task: ferma'),('problema/pscpld','PScPld','2006-12-13 20:52:42','==Include(page=\"template/taskheader\" task_id=\"pscpld\")==\r\n\r\nSe da un sir de caractere mici ale alfabetului englez. O subsecventa a sirului contine cateva caractere consecutive in sir. Un sir de caractere este palindrom daca se citeste de la stanga la dreapta si de la dreapta la stanga la fel.\r\n\r\nh2. Cerinta\r\n\r\nNumarati subsecventele palindrom pe care sirul de caractere le contine.\r\n\r\nh2. Date de intare\r\n\r\nIn fisierul de intrare $pscpld.in$ vom avea pe prima linie sirul de caractere.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $pscpld.out$ va contine numarul cerut.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 1000000$ , unde $N$ este lungimea sirului.\r\n* $30%$ din teste vor avea $N &le; 30000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. pscpld.in |_. pscpld.out |\r\n| abaaac | 10 |\r\n\r\nh3. Explicatie\r\n\r\nSunt 6 subsecvente  de lungime unu({${*a*}baaac$}, {$a{*b*}aaac$}, {$ab{*a*}aac$}, {$aba{*a*}ac$}, {$abaa{*a*}c$}, {$abaaa{*c*}$}), doua subsecvente de lungime doi ({$ab{*aa*}ac$}, {$aba{*aa*}c$}) si doua subsecvente de lungime trei ({${*aba*}aac$}, {$ab{*aaa*}c$}).\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"pscpld\")==',1,'task: pscpld'),('problema/plimbare','Plimbare','2006-11-12 14:57:56','==Include(page=\"template/taskheader\" task_id=\"plimbare\")==\r\n\r\nIn fiecare oras unde componentii lotului de informatica fac pregatiri inaintea olimpiadelor internationale, se organizeaza cate o plimbare pentru a vizita obiectivele turistice. Anul acesta orasul in care au ajuns olimpicii are proprietatea curioasa ca exista cate o strada intre oricare doua obiective, dar strada are un singur sens de mers.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati o plimbare de lungime maxima care poate merge pe strazile orasului in sensul lor normal de mers, astfel ca la sfarsitul plimbarii sa ajungem la acelasi obiectiv de la care am pornit, iar fiecare strada sau obiectiv sa fie vizitat o cel mult o data (in afara de obiectivul de unde pornim care va fi vizitat de doua ori).\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul de intrare $plimbare.in$ vom avea pe prima linie numarul $N$ de obiective. Pe urmatoarele $N*(N-1)/2$ linii vor fi cate doi intregi $x, y$ separati prin exact un spatiu, cu semnificatia ca intre obiectivul $x$ si obiectivul $y$ exista o strada cu sensul de la $X$ la $y$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $plimbare.out$ va contine pe prima linie numarul $P$ maxim de obiective pe care le putem vizita intr-o asemenea plimbare. Urmatoarea linie va contine $P$ intregi separati prin spatiu, care ne vor da obiectivele vizitate si ordinea vizitarii lor.\r\n\r\nh2. Restrictie\r\n\r\n* $1 &le; N &le; 100$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. plimbare.in |_. plimbare.out |\r\n| 4\r\n1 2\r\n1 4\r\n2 3\r\n3 1\r\n3 4\r\n4 2 | 4\r\n1 4 2 3 |\r\n\r\nh3. Explicatie\r\n\r\nCea mai lunga plimbare este una ce viziteaza toate cele 4 obiective. Obiectivele vor fi vizitate in ordinea $1->4->2->3->1$.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"plimbare\")==',1,'task: plimbare'),('problema/siruri','Siruri','2006-11-12 15:01:58','==Include(page=\"template/taskheader\" task_id=\"siruri\")==\r\n\r\nDanut are un calculator naravas. Pentru a-l putea folosi, el trebuie sa raspunda in fiecare dimineata la cate o intrebare. Astazi, cand s-a trezit, Danut a vazut pe monitorul calculatorului doua siruri de numere de cate {$N$}, respectiv {$M$} numere. Sa notam primul sir cu {$x{~1~}$}, {$x{~2~}$},..., {$x{~N~}$}, iar al doilea sir cu {$y{~1~}$}, {$y{~2~}$}, ..., {$y{~M~}$}. Calculatorul ii cere sa afle trei numere {$k$}, {$p$} si {$q$} astfel incat {$x{~p~} + y{~q~} = x{~p+1~} + y{~q+1~} = ... = x{~p+k-1~} + y{~q+k-1~}$}.\r\nDaca exista mai multe astfel de triplete Danut trebuie sa il aleaga pe cel cu $k$ maxim. Daca exista mai multe triplete cu $k$ maxim, el poate raspunde cu oricare dintre ele.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati {$k$}, {$p$} si {$q$} astfel incat sa fie indeplinite conditiile de mai sus.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului $siruri.in$ contine un numar $N$ reprezentand numarul de elemente din sirul {$X$}. A doua linie a fisierului contine $N$ numere: {$x{~1~}$}, {$x{~2~}$},..., {$x{~N~}$}. Pe a treia linie se afla numarul $M$ reprezentand numarul de elemente din sirul {$Y$}. Pe a patra linie se afla $M$ numere: {$y{~1~}$}, {$y{~2~}$}, ..., {$y{~M~}$}.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $siruri.out$ va contine numerele {$k$}, {$p$} si {$q$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 100 000$\r\n* $-100 000 &le; X{~i~} &le; 100 000$, pentru $1 &le; i &le; N$\r\n* $-100 000 &le; Y{~j~} &le; 100 000$, pentru $1 &le; j &le; M$\r\n* $k$ poate fi $1$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. siruri.in|_. siruri.out|\r\n|8\r\n-100 -100 -100 1 2 3 4 5\r\n6\r\n5 4 3 2 1 100\r\n|5 4 1|\r\n\r\n_Explicatie_: 5+1 = 4+2 = 3+3 = 2+4 = 1+5.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"siruri\")==',256,'task: siruri'),('problema/treid','TreiD','2006-11-11 18:08:50','==Include(page=\"template/taskheader\" task_id=\"treid\")==\r\n\r\nSe da o matrice de $NxM$ elemente intregi. Se cere sa se determine trei submatrici dreptunghiulare compacte, care nu se suprapun si pentru care suma elementelor este maxima.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati suma maxima ce se poate obtine.\r\n\r\nh2. Date de intare\r\n\r\nIn fisierul de intrare $treid.in$ vom avea pe prima linie numarul $N$ de linii si numarul $M$ de coloane, separate printr-un spatiu. Pe urmatoarele $N$ linii se vor afla cate $M$ intregi separati prin cate un spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $treid.out$ va contine numarul cerut.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 200$\r\n* Elementele sirului vor fi intre $-1000$ si $1000$ inclusiv\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. treid.in|_. treid.out|\r\n|5 4\r\n2 -1 1 1\r\n-1 -1 -1 -1\r\n-1 -1 -1 -1\r\n1 -1 -1 -1\r\n1 -1 -1 -1\r\n-1 -1 1 1\r\n|7|\r\n\r\n_Explicatie_: O solutie posibila ar fi o matrice formata din toate elementele primului rand, una formata din elementele (3, 1) si (4, 1) iar a treia matrice va fi formata din elementele (5, 3) si (5, 4).\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"treid\")==',256,'task: treid'),('problema/supersf','Supersf','2006-11-11 18:21:28','==Include(page=\"template/taskheader\" task_id=\"supersf\")==\r\n\r\nEra o zi torida de vara pe Marte... si la umbra unui Apeme se intalnesc Algostorm, Max Damage si Voodoo Child si se uita cu mirare la o bucata de hartie pe care era scrisa secventa de numere $1, 2, 3, 3, 4, 5, 5, 6, 6$ si cam atat ca hartia era rupta... Imediat Algostorm a zis: \"Evident! Fiecare numar $W$ apare de $X$ ori, unde $X$ este numarul de biti cu valoare $1$ din exprimarea lui $W$ in baza $2$, iar $W$ parcurge sirul numerelor naturale, de la $1$ catre infinit. Voodoo Child raspunde imediat: \"Cred ca pot calcula foarte repede ce numar se afla la o pozitie anume in secventa asta...\". Dupa cateva clipe de gandire Max Damage zice: \"Eu zic sa o facem problema si sa o dam la Stelele Informaticii\". Si,... uite unde am ajuns.\r\n\r\nh2. Cerinta\r\n\r\nPentru un numar $K$ spuneti ce numar se afla pe pozitia $K$ in sirul generat dupa cum a grait Algostorm.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul $supersf.in$ se afla un singur numar intreg strict pozitiv $K$ , scris in baza $16$ fara spatii intre cifre, reprezentand pozitia elementului cautat in secventa.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire supersf.out contine un numar intreg pozitiv $N$ , reprezentand numarul cautat (fara spatii intre cifre), evident tot in baza $16$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; K &le; 16^200.000^$\r\n* Pentru $65%$ din teste $K &le; 16^6.000^$\r\n* Cifrele in baza $16$ sunt $0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F$ (doar majuscule)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. supersf.in |_. supersf.out |\r\n|4 |3 |\r\n|17 |D |\r\n|3D961 |8447 |\r\n|96D271 |F41F4 |\r\n\r\nh2. Explicatie\r\n\r\nPrimele elemente din secventa sunt: $1 2 3 3 4 5 5 6 6 7 7 7 8 9 9 A A B B B C C D D D E E E$ ... pentru restul nu mai avem hartie.\r\n==Include(page=\"template/taskfooter\" task_id=\"supersf\")==',4895,'task: supersf'),('problema/adapost2','Adapost 2','2006-11-11 14:22:20','==Include(page=\"template/taskheader\" task_id=\"adapost2\")==\r\n\r\nComandantul si-a trimis inca un batalion de $N$ soldati intr-un teritoriu inamic si acum trebuie sa ii apere. Dupa ce a primit harta cu pozitiile soldatilor, din cauza situatiei financiare foarte proaste in care se afla, a ajuns la concluzia ca nu poate construi decat un singur adapost provizoriu. Totusi, el se gandeste si la binele general al soldatilor si vrea ca suma distantelor parcurse de soldati pana la adapost la fie cat mai mica. Cum Comandantul nu e prea bun cu numerele, soarta soldatilor e in mainile tale.\r\n\r\nh2. Cerinta\r\n\r\nAflati unde ar trebui sa fie asezat adapostul astfel incat suma distantelor de la soldati la acesta sa fie minima.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $adapost2.in$ contine un numar natural $N$ reprezentand numarul de soldati iar urmatoarele $N$ linii contin coordonatele soldatilor.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $adapost2.out$ se vor scrie doua numere reale care reprezinta coordonatele unde ar trebui asezat adapostul.\r\n\r\nh2. Restrictii si precizari:\r\n\r\n* $1 &le; N &le; 50.000$\r\n* Punctele au coordonate in intervalul $[0,1000]$ si sunt date cu $3$ zecimale.\r\n* Diferenta maxima cu care suma distantelor dintre soldati si adapostul gasit poate varia fata de cea minima este de $0,001$. Daca este intre $0,001$ si $0,2$ se va acorda totusi $40%$ din valoarea unui test.\r\n\r\nh2. Exemplu:\r\n\r\ntable(example). |_. adapost2.in |_. adapost2.out |\r\n| 3 \r\n5.223 5.591\r\n2.069 4.643\r\n5.628 0.287\r\n| 4.1442 4.2898 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adapost2\")==',961,'task: adapost2'),('problema/adapost','Adapost','2006-11-11 14:10:47','==Include(page=\"template/taskheader\" task_id=\"adapost\")==\r\n\r\nUn batalion de $N$ soldati a ajuns intr-o zona periculoasa si se afla sub un puternic bombardament din partea inamicului. Comandantul Gigel are o harta cu pozitiile soldatilor si coordonatele a $N$ adaposturi, cu o capacitete de o persoana fiecare, la care trebuie sa ajunga soldatii. El doreste sa-si faca un plan de salvare a soldatilor care sa aiba un risc cat mai mic. Riscul unui soldat de a fi ranit este direct proportional cu timpul de care are nevoie sa ajunga la adapostul sau, deci este si direct proportional cu distanta parcursa de el, deoarece toti soldatii au viteza constanta.\r\n\r\nGigel doreste ca fiecare soldat sa aiba sanse cat mai bune, astfel incat maximul distantelor care trebuie parcurse de fiecare soldat pana la adapostul sau sa fie minim. Desi maximul distantelor trebuie sa fie cat mai mic, el mai vrea ca suma distantelor parcurse de soldati sa fie cat mai mica deasemenea, pentru a micsora riscul total.\r\n\r\nh2. Cerinta\r\n\r\nAlegeti pentru fiecare soldat un adapost, astfel incat in fiecare adapost sa fie un singur soldat si si ambele conditii de mai sus sa fie respectate.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $adapost.in$ contine un numar intreg $N$ reprezentand numarul de soldati. Urmatoarele $N$ linii contin coordonatele soldatilor iar urmatoarele $N$ linii contin coordonatele adaposturilor.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $adapost.out$ se vor scrie doua numere reale: valoarea maxima a distantelor soldat-adapost care satisface cerinta si suma minima a distantelor parcurse de soldati pana la adaposturile lor.\r\n\r\nh2. Restrictii si precizari:\r\n\r\n* $1 &le; N &le; 400$\r\n* Pentru aflarea primului numar se acorda $40%$ din valoarea unui test, restul de punctaj fiind acordat daca ambele numere sunt aflate.\r\n* Este posibil ca suma distantelor soldat-adapost sa fie si mai mica decat cea cautata, dar in acea situatie maximul distantelor ar fi prea mare.\r\n* Punctele au coordonate in intervalul $[0,1000]$ si sunt date cu o precizie de $0,001$\r\n* Diferenta maxima cu care rezultatul final poate varia fata de cel corect este de $0,001$\r\n\r\nh2. Exemplu:\r\n\r\ntable(example). |_. adapost.in |_. adapost.out |\r\n| 5 \r\n6.773 5.394\r\n1.981 1.198\r\n7.062 7.228\r\n2.247 5.785\r\n6.749 2.419\r\n5.382 7.861\r\n5.414 3.397\r\n8.789 3.838\r\n9.436 1.929\r\n5.550 7.901\r\n| 4.07690 14.76992 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adapost\")==',961,'task: adapost'),('problema/gold','Gold','2006-11-12 13:43:40','==Include(page=\"template/taskheader\" task_id=\"gold\")==\r\n\r\nFie $N$ mine cu aur aflate la puncte de coordonate intregi in plan. Fiecare mina contine o cantitate cunoscuta de aur, exprimata in kilograme. Doi cautatori de aur au venit in zona si doresc sa imparta minele intre ei. Pentru a le fi mai simplu, se hotarasc sa aleaga doua din cele $N$ mine. Astfel, unele dintre cele $N-2$ mine ramase vor fi de o parte, iar altele de cealalta parte a dreptei formata de cele doua mine alese. Minele dintr-o zona vor fi repartizate primului cautator, urmand ca celelalte sa ajunga in posesia celui de-al doilea. Cantitatea de aur pentru fiecare cautator este data de suma cantitatilor de aur aflate in minele din posesia sa. Problema care se iveste este ca unul dintre cautatori poate avea mult mai mult aur decat celalalt. Totusi, cei doi ajung la un compromis: daca diferenta in modul dintre cele doua cantitati nu depaseste o valoare stabilita $P$ , atunci impartirea se considera a fi una echitabila.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine in cate moduri pot fi stabilite cele doua mine astfel incat impartirea sa fie una echitabila.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $gold.in$ contine {$N$}, numarul de mine. Pe a doua linie se afla valoarea {$P$}, cu semnificatia din enunt. Linia a {$3$}-a va contine $N$ numere naturale nenule, al {$i$}-lea numar reprezentand cantitatea de aur din mina a {$i$}-a. Incepand cu linia a {$4$}-a, vor fi descrise pozitiile minelor referitor la un sistem ortogonal de axe: pe fiecare linie se va gasi o pereche de numere intregi {$(x y)$}, mai precis pe linia $i+3$ aflandu-se coordonatele pentru cea de a {$i$}-a mina.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului $gold.out$ contine numarul de moduri diferite de a alege doua mine dintre cele $N$ pentru ca impartirea sa fie echitabila.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $4 &le; N &le; 1.024$\r\n* $0 &le; P &le; 98.765$\r\n* Cantitatile de aur din mine sunt numere naturale cuprinse in [{$1, 10.000$}]\r\n* Coordonatele minelor sunt numere intregi in [{$-16.000, 16.000$}]\r\n* Oricare trei mine sunt necoliniare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. gold.in |_. gold.out |\r\n| 7\r\n5\r\n4 7 8 6 4 6 7\r\n3 10\r\n2 3\r\n8 1\r\n10 4\r\n7 1\r\n7 3\r\n9 8\r\n| 3 |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"gold\")==',961,'task: gold'),('problema/bridge','Bridge','2006-12-25 22:10:00','==Include(page=\"template/taskheader\" task_id=\"bridge\")==\r\n\r\nFat-Frumos a plecat in cautarea iubirii sale, fiica imparatului, Simona, care a fost rapita de balaurul cel rau si dusa in pestera acestuia. Acesta s-a pregatit intens de lupta insa el nu a stiut ca balaurul ii pregatise o surpriza, si astfel l-a atras pe acesta pe un pod. Pe pod Fat-Frumos se poate deplasa pasind (se va deplasa o scandura la dreapta), sarind (se va deplasa $2$ scanduri la dreapta), stationand (va ramane pe aceeasi scandura) sau teleportandu-se (vezi scandura teleportoare). Insa podul este putin mai ciudat fiind format din $4$ tipuri de scanduri astfel:\r\n\r\n* $0$ - scandura buna (pe o astfel de scandura se poate stationa, pasi, sari sau teleporta, si se poate ajunge oricum pe ea)\r\n* $1$ - scandura subreda (la fel ca la o scandura buna, numai ca pe acest tip de scandura nu se poate ajunge decat prin pasire)\r\n* $2$ - scandura lipsa (Daca Fat-Frumos va ajunge pe o astfel de scandura el va ajunge felul principal al crocodililor de sub pod)\r\n* $3$ - scandura teleportoare (pe astfel de scandura se poate ajunge oricum, iar o astfel de scandura il va teleporta pe eroul nostru pe o alta scandura numita scandura destinatie)\r\n\r\nh2. Cerinta\r\n\r\nFat-Frumos va trebui sa isi coordoneze miscarile cat mai bine pe pod de aceea va roaga pe voi sa ii raspunde-ti la $M$ intrebari de forma \"In cate moduri pot ajunge pe scandura $X$ in $K$ pasi?\"\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $bridge.in$ vor fi scrise $2$ numere $N$ si $M$ reprezentand numarul de scanduri respective numarul de intrebari. Pe urmatoarea linie vor fi scrise N numere cuprinse intre $0$ si $3$ reprezentand configuratia podului, corespondenta fiind cea de mai sus. Pe urmatoarele linii vor fi scrise scandurile destinatie pentru fiecare scandura teleportoare in ordinea aparitiei acestora pe pod, si, in final, pe urmatoarele $M$ linii vor fi scrise cate $2$ numere $X$ si $K$ care definesc o intrebare de genul \"In cate moduri se poate ajunge pe scandura $X$ in $K$ pasi?\".\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bridge.out$ va contine $M$ linii reprezentand raspunsul pentru fiecare intrebare din fisierul de intrare in ordine.\r\n\r\nh2. Restrictii si Precizari\r\n\r\n* $1 < N < 4001$\r\n* $1 < M < 30001$\r\n* Numarul maxim de pasi dintr-o intrebare nu va depasi valoarea $4000$\r\n* Daca scandura $x$ este teleportoare si are ca destinatie scandura $y$ atunci vom avea urmatoarea relatie $x < y$\r\n* Mai multe scanduri teleportoare pot avea ca destinatie aceeasi scandura\r\n In momentul in care Fat-Frumos ajunge pe o scandura teleportoare el va fi teleportat pe scandura destinatie indiferent daca el vrea sau nu (nu poate stationa, sari sau pasi de pe ea)\r\n* Teleportarea se considera pas\r\n* Raspunsurile se vor afisa modulo $666013$\r\n* Numarul de moduri de a ajunge pe o scandura lipsa sau pe o scandura teleportoare care are ca destinatie o scandura lipsa sau subreda este 0\r\n* Fat-Frumos nu se poate deplasa inapoi (el la un pas se va deplasa {$0$},{$1$} sau $2$ scanduri la dreapta sau va fi teleportat in cazul in care scandura respective are aceasta propietate)\r\n* Initial Fat-Frumos se afla in afara podului pozitie pe care nu poate stationa, la primul pas el ori va pasi pe prima scandura ori va sari pe cea de-a doua daca acest lucru este posibil\r\n* Prima scandura nu este niciodata lipsa\r\n* Pe o scandura teleportoare se poate ajunge ca si pe o scandura buna\r\n* Daca o scandura teleportoare nu are ca scandura destinatie o scandura lipsa sau subreda atunci numarul de moduri de a ajunge pe aceasta in K pasi nu este neaparat $0$ (vezi exemplu)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bridge.in |_. bridge.out |\r\n| 5 3\r\n0 0 3 1 2\r\n4\r\n4 4\r\n2 3\r\n3 2\r\n| 0\r\n3\r\n0 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bridge\")==',1,'task: bridge'),('problema/secv4','Secventa 4','2006-11-12 15:32:10','==Include(page=\"template/taskheader\" task_id=\"secv4\")==\r\n\r\nFlubby Doo are de rezolvat un mister. In momentul de fata, el se afla in fata unei usi secrete. Pentru a o deschide si a intra in ascunzatoarea monstrului, el trebuie sa raspunda repede la urmatoarea intrebare: fiind dat un sir de $N$ numere reale nenule, care este secventa de produs maxim, a carei lungime este cuprinsa intre $X$ si {$Y$}. Flubby Doo poate raspunde usor la aceasta intrebare, dar este interesat daca si voi, prietenii lui, puteti.\r\n\r\nh2. Date de Intrare:\r\n\r\nPe prima linie a fisierului $secv4.in$ se afla $3$ numere {$N$}, $X$ si {$Y$}. Pe urmatoarea linie se afla $N$ numere.\r\n\r\nh2. Date de Iesire:\r\n\r\nPe prima linie a fisierului $secv4.out$ se afla doua numere: $L$ si {$P$}, unde $L$ reprezinta lungimea secventei si $P$ pozitia de inceput a acesteia.\r\n\r\nh2. Restrictii si precizari:\r\n\r\n* $1 &le; N &le; 100.000$\r\n* Elementele sirului sunt numere reale nenule din intervalul [{$-10^9^; 10^9^$}]\r\n* In toate testele, secventa de produs maxim va fi pozitiva\r\n* Prin secventa de lungime $L$ se intelege un subsir de $L$ numere consecutive ale sirului initial\r\n* Daca exista mai multe solutii, se va afisa cea cu pozitia de final minima; daca si asa exista mai multe solutii se va afisa cea cu pozitia de inceput minima\r\n* Pentru $40%$ din teste elemente sirului vor fi doar numere pozitive\r\n* Pentru $10%$ din teste elementele sirului vor fi numere pozitive si $N &le; 2000$\r\n* Elementele sirului vor avea maxim $3$ zecimale\r\n\r\nh2. Exemplu:\r\n\r\ntable(example). |_. secv4.in |_. secv4.out |\r\n| 5 1 4\r\n2 2 0.1 2 2\r\n| 2 1 |\r\n| 6 1 4\r\n-2 -3 -4 -2 -3 1\r\n| 4 2 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"secv4\")==',961,'task: secv4'),('problema/eq','Easy Query','2006-11-12 00:53:43','==Include(page=\"template/taskheader\" task_id=\"eq\")==\r\n\r\nSe considera un sir de $N$ numere naturale, {$x{~1~}, x{~2~}, ... x{~N~}$}. Se defineste urmatoarea operatie:\r\n\r\n* pentru o pereche {$i,j$}, {$1 &le; i &le; j &le; N$}, se considera secventa {$x{~i~}, x{~i+1~}, ... x{~j~}$}\r\n* se construiesc doua siruri corespunzatoare secventei date, astfel:\r\n** {$y{~t~} = x{~t~} - x{~k~} + x{~p~}$}, {$i &le; t &le; j$}, {$t &le; k &le; j$}, {$t &le; p &le; j$}, unde $y{~t~}$ este maxim\r\n** {$z{~t~} = x{~t~} - x{~k~} + x{~p~}$}, {$i &le; t &le; j$}, {$t &le; k &le; j$}, {$t &le; p &le; j$}, unde $z{~t~}$ este minim\r\n* se calculeaza valoarea {$P = max(y) + min(z)$}, unde $max(y)$ este maximul din sirul $y$ construit ca mai sus, iar {$min(z)$} minimul din sirul {$z$}.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se sirul initial, sa se raspunda la un set de mai multe operatii.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $eq.in$ se gasesc doua numere $N$ si $M$ reprezentand numarul de elemente ale sirului {$x$}, respectiv numarul operatiilor pentru care se doreste determinarea valorii {$P$}. Pe urmatoarea linie se afla elementele sirului $x$ separate prin cate un caracter spatiu. Urmatoarele $M$ linii contin subsecventele definite prin doi intregi $i$ si $j$ separati prin spatiu reprezentand pozitia de inceput, respective pozitia de sfarsit a subsecventei.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $eq.out$ contine valorile P pentru fiecare subsecventa data, cate una pe linie, in ordinea aparitiei acestora in fisierul de intrare.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 < N &le; 100 001$\r\n* $1 < M &le; 130 001$\r\n* $0 &le; x{~i~} &le; 2^24^$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. eq.in |_. eq.out |\r\n| 6 3\r\n1 8 10 5 9 3\r\n1 4\r\n2 6\r\n3 5\r\n| 7\r\n16\r\n16 |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"eq\")==',961,'task: eq'),('problema/ct','CT','2006-11-11 22:56:33','==Include(page=\"template/taskheader\" task_id=\"ct\")==\r\n\r\nIntr-o tara exista $N$ orase, numerotate cu numere de la 1 la $N$. Orasele sunt conectate de strazi astfel incat exista un singur mod de a ajunge de la un oras la altu folosind strazile existente. In aceasta tara $K$ organizatii teroriste fac planuri pentru distrugerea lumii, de aceea echipa CT s-a decis sa ii opreasca. Fiecare grupare terorista are cate o baza in doua din orasele tarii(deasemenea poate avea ambele baze in acelasi oras). Zilnic teroristii merg de la o baza la alta folosind strazile existente, ducand cu ei planurile pentru dominarea lumii. Bombardarea unui oras $C$ va distruge acel oras si toate perechile de orase pentru care drumul dintre ele trecea prin orasul $C$ vor ramane deconectate. Neutralizarea unei grupari teroriste consta in deconectarea oraselor care contin bazele gruparii respective sau in bombardarea a cel putin un oras care contine o baza a gruparii respective. Deoarece bombardarea oraselor implica si moartea unor civili neajutorati echipa CT doreste sa bombardeze cat mai putine orase pentru a neutraliza toate cele $K$ organizatii teroriste.\r\n\r\nh2. Cerinta\r\n\r\nGasiti numarul minim de orase pe cae echipa CT trebuie sa le bombardeze.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $ct.in$ contine $T$, numarul de teste din fisier apoi vor urma cele $T$ teste. Pe prima linie a fiecarui test se afla doua numere $N$ si $K$ numarul de orase respectiv numarul gruparilor teroriste. Urmeaza apoi $N-1$ linii continand cate doua numere $x, y$ cu semnificatia exista strada intre orasele $x$ si $y$. In continuare vor fi $K$ linii, pe linia $i$ aflandu-se doua numere ce reprezinta orasele in care se afla sediul organizatiei $i$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $ct.out$ vor exista $T$ linii fiecare continand numarul minim de orase ce trebuie bombardate pentru tara respectiva.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100.000$\r\n* $1 &le; K &le; 100.000$\r\n* $1 &le; T &le; 5$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. ct.in |_. ct.out |\r\n|1\r\n11 5\r\n1 2\r\n2 3\r\n3 4\r\n2 5\r\n5 6\r\n5 11\r\n7 1\r\n10 7\r\n8 7\r\n9 8\r\n4 6\r\n3 11\r\n5 9\r\n10 9\r\n8 2 | 2 |\r\n\r\nh3. Explicatii\r\n\r\nSe pot bombarda orasele 2 si 7 neutralizand astfel toate gruparile teroriste.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"ct\")==',1,'task: ct'),('problema/swap','Swap','2006-11-11 18:56:45','==Include(page=\"template/taskheader\" task_id=\"swap\")==\r\n\r\nSe dau $2$ siruri formate numai din litere mici (de la `a\' la `z\'). Asupra primului sir puteti efectua, in mod repetat, operatia numita $swap$: alegeti doua caractere aflate pe pozitii consecutive si le interschimbati. Determinati numarul minim de operatii $swap$ necesare pentru a transforma primul sir in cel de-al doilea.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $swap.in$ contine primul sir. A doua linie a fisierului contine cel de-al doilea sir.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $swap.out$ veti afisa numarul minim de operatii swap necesare pentru a transforma primul sir in al doilea sir. Daca primul sir nu poate fi transformat in al doilea sir, afisati $-1$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Ambele siruri au aceeasi lungime\r\n* Lungimea fiecarui sir este un numar intre $1$ si $50.000$\r\n* Fiecare din cele doua linii ale fisierului de intrare se termina cu caracterul \"linie noua\"\r\n* Pentru $40%$ din teste, sirurile vor avea o lungime $&le; 2.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. swap.in |_. swap.out |\r\n|anaaremere \r\nmereareana\r\n|26|\r\n|mumu\r\nbubu\r\n|-1|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"swap\")==',4895,'task: swap'),('problema/int','Int','2006-11-12 16:24:23','==Include(page=\"template/taskheader\" task_id=\"int\")==\r\n\r\nSe dau $N$ intervale deschise (capetele nu fac parte din interval), situate pe axa OX. Determinati o submultime de intervale cu numar maxim de elemente, cu proprietatea ca intersectia oricaror $2$ intervale din submultime este vida.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare $int.in$ contine numarul $N$ de intervale. Urmatoarele N linii contin cate doua numere intregi, $A$ si {$B$}, reprezentand capatul stanga, respectiv capatul dreapta al cate unui interval.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $int.out$ veti afisa numarul de elemente al submultimii determinate.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 50.000$\r\n* Pentru fiecare interval avem $-2.000.000.000 &le; A < B &le; 2.000.000.000$\r\n* $40%$ din fisierele de test vor avea $N &le; 2000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. int.in |_. int.out |\r\n| 5\r\n-3 10\r\n-11 -7\r\n1 6\r\n0 1\r\n0 30\r\n| 3 |\r\n\r\nh3. Explicatii\r\n\r\nSubmultimea ar putea contine intervalele {$(-11,-7)$}, {$(0,1)$} si {$(1,6)$}\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"int\")==',15,'task: int'),('problema/obj','Obj','2006-11-11 18:21:47','==Include(page=\"template/taskheader\" task_id=\"obj\")==\r\n\r\nGigel si Ionel joaca un joc. Ei au o gramada ce contine $N$ obiecte si efectueaza mutari alternativ. Cel care se afla la mutare poate sa ia din gramada un numar de obiecte cuprins intre $1$ si minim{ $K$, numarul de obiecte ramase in gramada }. Numarul de obiecte luat la fiecare mutare se aduna la numarul total de obiecte luate pana atunci de jucatorul respectiv. Castigatorul jocului este cel care, in momentul in care gramada se goleste, detine un numar par de obiecte (pentru a exista un singur castigator, numarul initial de obiecte din gramada este impar). Gigel este cel care efectueaza prima mutare.\r\n\r\nPentru valorile $N$ si $K$ date, determinati cine va castiga jocul, considerand ca atat Gigel, cat si Ionel, folosesc o strategie optima.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $obj.in$ contine numarul $J$ de jocuri ce vor fi descrise in continuare. Fiecare din urmatoarele $J$ linii contine cate doua numere intregi, separate printr-un spatiu: $N$ si $K$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $obj.out$ veti afisa $J$ linii. Pentru fiecare joc descris in fisierul de intrare (in ordinea in care sunt date in fisier), veti afisa caracterul $`G\'$, in caz ca Gigel va castiga jocul, respectiv caracterul $`I\'$, in cazul in care castigatorul este Ionel.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; J &le; 30$\r\n* Pentru fiecare joc:\r\no $1 &le; N &le; 1.000.000.000, N impar$\r\no $1 &le; K &le; N$\r\n* Pentru $50%$ din teste $N &le; 20.000$ si $K &le; 100$\r\n* Pentru $90%$ din teste $N &le; 1.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. obj.in |_. obj.out |\r\n| 5\r\n  21 8\r\n  23 8\r\n  9 3\r\n  11 3\r\n  999999 12345\r\n| I\r\n  G\r\n  I\r\n  G\r\n  G |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"obj\")==',48,'task: obj'),('problema/1expr','1expr','2006-11-11 15:12:33','==Include(page=\"template/taskheader\" task_id=\"1expr\")==\r\n\r\n==Include(page=\"template/cleanup\")==\r\n\r\nGigel, student in anul II (desi a inceput facultatea acum 4 ani - ce sa-i faci, Electronica asta..), tocmai a invatat despre expresii aritmetice ce contin operatorii {@\'+\',\'*\',\'^\'@} si {@\'!\'@}, precum si paranteze ({@\'(\'@} si {@\')\'@}). Totusi, fiind abia in anul II, el se incurca cand trebuie sa lucreze cu numere prea mari, de aceea singurul numar care apare in mod direct (adica nu doar ca rezultat al unei operatii) in cadrul unei expresii este numarul 1. Vom numi o astfel de expresie 1-expresie. De exemplu, {@\"(1+(1*1))^(1+1+1*1)^(1+(1+1)!)\"@} este o 1-expresie, dar {@\"2+5*7+6!+3^4^3!+1*6\"@} nu este o 1-expresie (deoarece apar in mod direct numerele 2, 3, 4, 5, 6 si 7). O 1-expresie poate fi privita ca un sir format din caracterele {@\'1\',\'+\',\'*\',\'^\',\'!\',\'(\',\')\'@} si care poate fi descris cu ajutorul urmatoarelor reguli gramaticale:\r\n\r\n{@1-expresie = \'1\' sau \'(\' 1-expresie \')\' sau 1-expresie \'+\' 1-expresie sau@}\r\n{@1-expresie \'*\' 1-expresie sau 1-expresie \'^\' 1-expresie sau@}\r\n{@1-expresie \'!\'@}\r\n\r\nDesi in cadrul expresiei apare in mod direct doar numarul 1, rezultatele evaluarii operatiilor pot fi numere mai mari decat 1, astfel ca Gigel va trebui sa invete sa foloseasca si aceste numere. Pentru a evalua o expresie aritmetica, trebuie cunoscute prioritatile operatorilor. Operatorul cu cea mai mica prioritate este {@\'+\'@} si realizeaza operatia de adunare. Rezultatul 1-expresiei {@\"1+1+1\"@} este 3. \r\nOperatorul {@\'*\'@} este mai prioritar decat operatorul {@\'+\'@} si realizeaza operatia de inmultire. Rezultatul 1-expresiei {@\"1+1*(1+1)*(1+1+1)+(1+1)*(1+1)\"@} este {@1+1*2*3+2*2=1+6+4=11@}. Operatorul {@\'^\'@} este mai prioritar decat operatorii {@\'+\'@} si {@\'*\'@} si realizeaza operatia de ridicare la putere ({$A^B^$} reprezinta {@A@} ridicat la puterea {@B@}). Rezultatul 1-expresiei {@\"(1+1)*(1+1+1)^(1+1)*(1+1+1)+(1+1)\"@} este {@2*3^2*3+2=2*9*3+2=54+2=56@}. \r\nSpre deosebire de operatorii {@\'+\'@} si {@\'*\'@} care au proprietatea ca {@A+B=B+A@} si {@A*B=B*A@}, in cazul {@\'^\'@} nu este neaparat adevarat ca {$A^B^=B^A^$} (decat in unele cazuri speciale). O alta particularitate a acestui operator este ordinea de aplicare in cazul absentei parantezelor: el este asociativ dreapta. De exemplu, {@A^B^C^D@} este echivalent cu {@A^(B^(C^D))@}. Rezultatul 1-expresiei {@\"(1+1)^(1+1)^(1+1+1)\"@} este {@2^2^3=2^(2^3)=2^8=256@} si nu {@(2^2)^3=4^3=64@}. Astfel, daca exista mai multi operatori {@\'^\'@} neseparati de paranteze, ordinea de efectuare a operatiilor este de la dreapta catre stanga. \r\nOperatorul cu prioritatea cea mai mare este {@\'!\'@} si realizeaza operatia \"factorial\". Rezultatul 1-expresiei {@\"(1+1+1)!\"@} este {@3!=6@}. Factorialul unui numar {@X@}, notat {@X!@}, este definit ca fiind {@1*2*..*X@}. Rezultatul 1-expresiei {@\"(1+1)*(1+1+1+1)!^(1+1+1)!!\"@} este {@2*4!^3!!=2*(4!)^(3!!)=2*(4!)^((3!)!)=2*24^(6!)=2*(24^720)@} (rezultatul este un numar prea mare pentru a fi afisat aici).\r\nLungimea unei 1-expresii este definita ca fiind egala cu numarul de caractere ale sirului ce reprezinta 1-expresia. Lungimea 1-expresiei {@\"(1+1)!^(1+1)*(1+1)+1\"@} este 20. Tema pe care a primit-o Gigel la scoala este urmatoarea: dandu-se un numar {@N@}, gasiti o 1-expresie de lungime minima al carei rezultat sa fie egal cu {@N@}. Ajutati-l pe Gigel sa isi rezolve tema.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $1expr.in$ contine numarul intreg $T$. Pe urmatoarele $T$ linii se afla cate un numar intreg $N$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $1expr.out$ veti afisa $T$ linii. Pe a $K$-a linie veti afisa o 1-expresie de lugime minima al carei rezultat este egal cu al $K$-lea numar dintre cele $T$ date in fisierul de intrare. Daca exista mai multe 1-expresii de lungime minima, puteti afisa oricare dintre ele.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; T &le; 100$\r\n* $1 &le; N &le; 3^8^$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. 1expr.in |_. 1expr.out |\r\n|3 \r\n 1\r\n 3\r\n 200 \r\n|1 \r\n 1+1+1 \r\n (1+1)^(1+1+1)*(1+(1+1+1+1)!) |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"1expr\")==',13,'task: 1expr'),('problema/algola','Algola','2006-11-11 15:18:30','==Include(page=\"template/taskheader\" task_id=\"algola\")==\r\n\r\nIn cadrul organizatiei Algola s-a declarat stare de urgenta. Toti membrii sai, aflati in diferite orase din tara, trebuie sa ajunga cat mai rapid la sediul central. Cele $N$ orase de pe harta tarii sunt numerotate cu numerele de la $1$ la $N$, orasul $1$ fiind locatia sediului central. Strazile ce conecteaza orasele sunt bidirectionale si fiecare dintre strazi poate fi parcursa intr-o unitate de timp de oricare membru Algola. Fiecare strada are o limita de siguranta care indica numarul maxim de membri ce pot circula intr-o unitate de timp pe acea strada. Parcurgerea unei strazi poate incepe numai la momente de timp intregi.\r\n\r\nh2. Cerinta\r\n\r\nFiind data harta oraselor, precum si numarul de membrii ai organizatiei aflati in fiecare oras, sa se calculeze timpul minim $T$ necesar acestora pentru a ajunge la sediul central ({$T$} va fi momentul la care ajunge ultimul membru la sediul central).\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului $algola.in$ contine doua numere intregi separate printr-un spatiu, $N$ si $M$, reprezentand numarul de orase de pe harta si numarul de strazi dintre ele. Pe cea de-a doua linie se vor afla N numere separate prin spatii, $A{~1~} A{~2~} ... A{~N~}$ unde $A{~i~}$ reprezinta numarul de membri din orasul $i$. Urmatoarele $M$ linii contin cate trei numere intregi separate prin spatii, $X Y L$, cu semnificatia: intre orasele $X$ si $Y$ exista o strada a carei limita de siguranta este $L$.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $algola.out$ va contine o singura linie numarul $T$ reprezentand timpul minim in care membrii organizatiei ajung la sediul central.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 50$\r\n* $1 &le; M &le; 300$\r\n* Timpul de parcurgere al unui oras este $0$\r\n* Totii membrii vor putea ajunge la sediu central\r\n* Limitele de siguranta ale strazilor sunt numere intregi pozitive din intervalul $[1,10]$\r\n* Toti membrii organizatiei afla de starea de urgenta la momentul $0$\r\n* Organizatia are cel mult $50$ de membri\r\n* Membrii organizatiei pot ramane in orice oras pe o perioada nelimitata de timp\r\n* Pentru $20%$ din teste drumul de la fiecare oras la sediu este unic; pentru inca $30%$ din teste numarul total de membri ai organizatiei va fi maxim $4$\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. algola.in |_. algola.out |\r\n| 4 4\r\n0 5 6 5\r\n1 2 3\r\n1 3 5\r\n4 2 2\r\n4 3 5 | 2 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"algola\")==',13,'task: algola'),('problema/hanoi4','Hanoi4','2006-11-12 00:48:37','==Include(page=\"template/taskheader\" task_id=\"hanoi4\")==\r\n\r\nCunoastem cu totii problema clasica a celor $3$ turnuri (stive) din Hanoi. Pe una din cele $3$ stive se afla $N$ discuri, in ordine crescatoare (de la varf catre baza) a dimensiunii. Se pot efectua mutari, o mutare constand in luarea unui disc din varful uneia din cele $3$ stive si plasarea lui in varful alteia, cu conditia ca, la nici un moment, pe nici o stiva, sa nu existe un disc de dimensiune mai mare peste un disc de dimensiune mai mica. Se stie ca numarul minim de mutari necesar pentru a muta cele $N$ discuri de pe stiva pe care se afla ele initial, pe o alta, avand la dispozitie doar $3$ stive, este $2^N^-1$. Dumneavoastra trebuie sa determinati numarul minim de mutari necesar pentru a muta $N$ discuri de pe o stiva pe alta, avand la dispozitie, in total, $4$ stive.\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul de intrare $hanoi4.in$ se afla un singur numar intreg: $N$\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $hanoi4.out$ veti afisa o singura valoare intreaga: numarul minim de mutari cerut.\r\n\r\nh2. Restrictii si precizari:\r\n\r\n* $1 &le; N &le; 1000$\r\n* Rezultatul se incadreaza intr-un intreg pe $64$ de biti.\r\n\r\nh2. Exemple:\r\n\r\ntable(example). |_. hanoi4.in |_. hanoi4.out |\r\n| 7 | 25 |\r\n| 64 | 18433 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"hanoi4\")==',15,'task: hanoi4'),('problema/cc','Cc','2006-11-12 16:25:41','==Include(page=\"template/taskheader\" task_id=\"cc\")==\r\n\r\nIntr-o sala se afla $N$ concurenti si $N$ calculatoare. Se cunoaste distanta pe care trebuie sa o parcurga fiecare concurent din pozitia in care se afla pana la fiecare calculator. Dorim sa asezam fiecare concurent la cate un calculator, in asa fel incat suma distantelor parcurse de concurenti sa fie minima. Determinati aceasta suma minima a distantelor.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare cc.in contine numarul intreg $N$, reprezentand numarul de concurenti si de calculatoare. Urmatoarele $N$ linii contin cate $N$ numere. Al $j$-lea numar de pe a $i$-a dintre aceste $N$ linii reprezinta distanta pe care trebuie sa o parcurga concurentul $i$ pentru a ajunge la calculatorul $j$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire cc.out veti afisa suma minima a distantelor parcurse de concurenti pentru a se aseza fiecare la cate un calculator.\r\n\r\nh2. Restrictii si precizari:\r\n\r\n* $1 &le; N &le; 100$\r\n* Fiecare din cele $N x N$ distante este un numar intreg din intervalul $[1, 10.000]$\r\n\r\nh2. Exemplu:\r\n\r\ntable(example). |_. cc.in |_. cc.out |\r\n| 5\r\n7 9 2 1 6\r\n9 10 11 12 13\r\n8 3 11 6 7\r\n6 6 6 6 6\r\n9 5 3 9 8\r\n| 22 \r\n|\r\n\r\nh3. Explicatii \r\n\r\nConcurentul $1$ se aseaza la calculatorul $4$.\r\nConcurentul $2$ se aseaza la calculatorul $1$.\r\nConcurentul $3$ se aseaza la calculatorul $2$.\r\nConcurentul $4$ se aseaza la calculatorul $5$.\r\nConcurentul $5$ se aseaza la calculatorul $3$. \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cc\")==',1,'task: cc'),('problema/geometry','Geometry','2006-11-12 01:07:15','==Include(page=\"template/taskheader\" task_id=\"geometry\")==\r\n\r\nIonut are $N$ segmente in planul $XY$ si si-ar dori sa stie cate perechi dintre acestea se intersecteaza. Se considera ca doua segmente se intersecteaza chiar si daca se ating intr-un singur punct.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Ionut sa gaseasca raspunsul.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul $geometry.in$ va contine pe prima linie un intreg $N$, numarul de segmente, urmata de $N$ linii de forma $X1$, $Y1$, $X2$, $Y2$, reprezentand coordonatele capetelor cate unuia dintre segmente.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul $geometry.out$ va contine pe prima linie un singur numar, reprezentand numarul de perechi de segmente care se intersecteaza.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0$ &lt; $N$ &lt; $500$\r\n* Coordonatele capetelor segmentelor sunt toate numere intregi cuprinse intre $-10.000$ si $10.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. geometry.in |_. geometry.out |\r\n| 3 3\r\n-1 -1 1 1\r\n0 -1 0 1\r\n-1 0 1 0\r\n| 3 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"geometry\")==',13,'task: geometry'),('problema/itree','Itree','2006-11-12 14:50:49','==Include(page=\"template/taskheader\" task_id=\"itree\")==\r\n\r\nFie o multime de intervale pe axa OX. Consideram ca doua intervale se intersecteaza daca si numai daca au mai mult de un punct in comun (de exemplu intervalele [{$1, 5$}] si [{$3, 10$}] se intersecteaza, dar [{$1, 2$}] si [{$2, 3$}] nu se intersecteaza). Graful asociat acestei multimi de intervale este graful in care se asociaza un nod fiecarui interval si o muchie intre nodurile corespunzatoare fiecarei perechi de intervale care se intersecteaza.\r\n\r\nUn graf $G$ se numeste graf de intervale daca exista cel putin o multime de intervale al caror graf asociat sa fie izomorf cu {$G$}.\r\n\r\nUn arbore (graf orientat conex cu $N$ varfuri si $N - 1$ muchii) se numeste arbore de intervale daca este in acelasi timp si graf de intervale.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un arbore, decideti daca acesta este arbore de intervale.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $itree.in$ va contine pe prima linie un intreg $T$ reprezentand numarul de teste din fisier. In continuare sunt descrisi $T$ arbori. Pentru fiecare arbore pe prima linie se va afla un numar $N$ - numarul de noduri ale arborelui. Urmatoarele $N - 1$ linii contin cate o pereche de numere {$A B$}, cu semnificatia ca exista o muchie intre nodurile $A$ si {$B$}.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $itree.out$ va contine pe $T$ linii. Pentru fiecare arbore din fisierul de intrare se va afisa {@YES@} daca acesta este arbore de intervale, respectiv {@NO@} in caz contrar.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 100.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. itree.in |_. itree.out |\r\n| 3\r\n3\r\n1 2\r\n2 3\r\n1\r\n4\r\n1 2\r\n1 3\r\n3 4\r\n| YES\r\nYES\r\nYES |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"itree\")==',961,'task: itree'),('problema/nodiv','Nodiv','2006-11-12 16:24:11','==Include(page=\"template/taskheader\" task_id=\"nodiv\")==\r\n\r\nAenag Lurtseam a ajuns in cele din urma la facultate, unde a si primit prima tema. De data aceasta el se confrunta cu o noua problema: primeste un numar natural $N$ si i se cere sa il scrie ca suma de termeni de forma $2^a^3^b^$. Desi tema i s-a parut initial usoara, s-a lovit de o noua constrangere - suma nu trebuie sa contina doi termeni diferiti astfel incat unul sa il divida pe celalalt. De exemplu $15 = 2^1^3^1^ + 2^0^3^2^$ este o descompunere buna, dar $18 = 2^1^3^1^ + 2^2^3^1^$ nu.\r\n\r\nh2. Cerinta\r\n\r\nVa reusi Aenag Lurtseam sa treaca anul fara restante?\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare va contine numarul $T$ de teste, urmat de $T$ linii, fiecare continand cate un numar $N$, numarul ce trebuie descompus.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire va contine $T$ linii, fiecare avand urmatorul format: un numar $K$ , urmat de $K$ perechi $(a, b)$ reprezentand numarul de termeni din descompunere, respectiv exponentii acelor $K$ termeni.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 2^63^ - 1$\r\n* $1 &le; T &le; 10 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. nodiv.in |_. nodiv.out |\r\n| 3\r\n  15\r\n  16\r\n  17\r\n| 2 1 1 0 2\r\n  1 4 0\r\n  2 3 0 0 2\r\n|\r\n\r\nh3. Explicatii\r\n\r\n$15 = 2^1^3^1^ + 2^0^3^2^$\r\n$16 = 2^4^3^0^$\r\n$17 = 2^3^3^0^ + 2^0^3^2^$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"nodiv\")==',1,'task: nodiv'),('preoni','preoni','2006-11-12 13:15:09','kgfldjgfds\r\ngfd\r\ngfd\r\ngfgfdg',1142,'public'),('problema/linterv','Lungimi de interval','2006-11-12 13:20:20','==Include(page=\"template/taskheader\" task_id=\"linterv\")==\r\n\r\nSe dau $N$ intervale [{$A{~i~},B{~i~}$}] ({$1 &le; i &le; N$}). Calculati suma lungimilor tuturor intervalelor. Intervalele care se suprapun se vor lua in considerare o singura data.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $linterv.in$ va contine mai multe teste. Pe prima linie se va afla $T$ numarul de teste. Pe prima linie a fiecarui test se va afla $N$ - numarul de intervale, urmand $N$ linii cu cate doua numere $A{~i~}$ si $B{~i~}$ - capetele intervalelor.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $linterv.out$ va contine $T$ linii pe fiecare aflandu-se un singur numar $x$ - suma calculata.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 5.000$\r\n* $-1.000.000 &le; A{~i~} &le; B{~i~} &le; 1.000.000$\r\n* $1 &le; T &le; 75$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. linterv.in |_. linterv.out |\r\n|1\r\n6\r\n-5 5\r\n0 3\r\n2 8\r\n10 13\r\n11 15\r\n100 100\r\n| 18 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"linterv\")==',961,'task: linterv'),('problema/rf','Roy-Floyd','2006-11-12 14:42:06','==Include(page=\"template/taskheader\" task_id=\"rf\")==\r\n\r\n\r\nh2. Cerinta\r\n\r\nMicul Floyd locuieste intr-un oras mare, in care exista $N$ intersectii. Fiecare pereche de intersectii este conectata printr-un drum bidirectional avand o lungime pozitiva data. Micul Floyd este un baiat curios si i-ar placea sa stie care este distanta minima pe care cineva ar trebui sa o parcurga de-a lungul drumurilor existente daca ar vrea sa mearga din intersectia $X$ in intersectia $Y$. Deoarece ii plac foarte mult intersectiile ar vrea de asemenea sa stie, in cazul in care exista mai multe drumuri intre $X$ si $Y$ de aceeasi lungime minima, care este numarul maxim de strazi pe care ar putea sa mearga cineva pentru a obtine aceasta distanta minima.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului $rf.in$ contine numarul de intersectii $N$. Urmatoarele $N$ linii contin cate $N$ numere intregi. Al $j$-ulea numar de pe a $i$-a linie reprezinta lungimea drumului dintre intersectiile $i$ si $j$. Matricea data este simetrica. Intersectiile sunt numerotate cu numere intregi de la $1$ la $N$.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $rf.out$ afisati doua matrici de dimensiune $NxN$. Fiecare matrice va fi afisata pe cate $N$ linii, fiecare continand cate $N$ numere intregi, separate de cate un singur spatiu (fara spatii suplimentare la inceputul sau sfarsitul liniei). Prima matrice reprezinta lungimea minima a drumurilor intre fiecare pereche de intersectii. A doua matrice reprezinta numarul maxim de strazi pe care se poate merge pentru a obtine distanta minima intre oricare pereche de noduri. Al $j$-ulea numar de pe a $i$-a linie reprezinta, pentru fiecare dintre cele doua matrici, raspunsul pentru perechea $(i, j)$ de intersectii.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 256$\r\n* Lungimea unui drum de la o intersectie la ea insasi va fi mereu $0$\r\n* $1 &le; lungimea unui drum &le; 100.000$\r\n\r\ntable(example). |_. rf.in |_. rf.out|\r\n| 5\r\n0 2 3 4 5\r\n2 0 4 5 1\r\n3 4 0 1 2\r\n4 5 1 0 3\r\n5 1 2 3 0\r\n| 0 2 3 4 3\r\n2 0 3 4 1\r\n3 3 0 1 2\r\n4 4 1 0 3\r\n3 1 2 3 0\r\n0 1 1 2 2\r\n1 0 2 3 1\r\n1 2 0 1 1\r\n2 3 1 0 2\r\n2 1 1 2 0 |\r\n| 3\r\n0 9 100000\r\n9 0 2\r\n100000 2 0\r\n| 0 9 11\r\n9 0 2\r\n11 2 0\r\n0 1 2\r\n1 0 1\r\n2 1 0 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"rf\")==',15,'task: rf'),('problema/biomech','Biomech','2006-11-11 16:27:45','==Include(page=\"template/taskheader\" task_id=\"biomech\")==\r\n\r\nIn anul 2006, oamenii au construit primul robot biomecanic cu inteligenta artificiala. In orice caz, inca nu se stie prea bine cat de avansata este inteligenta sa. Tocmai de aceea, robotul va fi supus unui test. El va fi plasat intr-o zona rectangulara, impartita in patrate amplasate pe $5$ linii si un numar infinit de coloane. Coloanele sunt numerotate de la $-infinit$ la $+infinit$ si robotul este plasat initial in coloana cu numarul $0$. Liniile zonei rectangulare sunt numerotate de la $1$ la $5$ si robotul va fi plasat la inceput in linia $3$ (cea din mijloc). Robotul va fi orientat in una din cele $8$ directii posibile: Nord, Nord-Est, Est, Sud-Est, Est, Sud, Sud-Vest, Vest, Nord-Vest.\r\n\r\nMutarile pe care robotul le poate face sunt:\r\n\r\n* Rotatie cu un unghi multiplu de $45$ de grade\r\nDin directia spre care este indreptat, robotul se poate intoarce astfel spre oricare alta directie. O rotatie de la o directie initiala la o directie finala consuma o anumita cantitate de timp. Din cauza structurii interne a robotului, se poate ca o rotatie cu un unghi mai mare sa dureze mai putin decat o rotatie cu un unghi mic. De asemenea, o rotatie din directia $X$ in directia $Y$ s-ar putea sa nu dureze la fel de mult ca o rotatie din directia $Y$ in directia $X$.\r\n* Miscare in directia spre care este orientat, din patratul curent in urmatorul patrat (avand o muchie comuna sau un varf comun cu acesta)\r\nDe exemplu, daca robotelul este la linia $3$, coloana $X$, orientat spre Nord-Est, s-ar putea deplasa in patratelul de pe linia $2$, coloana $X+1$. Dupa mutare, robotul nu-si schimba directia in care este orientat. De asemenea, nu ii este permis sa mute in afara zonei rectangulare (asadar, anumite miscari sunt interzise din anumite patrate).\r\n\r\nCantitatea de timp necesara pentru o mutare depinde atat de directia in care se muta (din cauza campului magnetic al Pamantului) cat si de linia pe care robotul se afla in momentul curent (deoarece fiecare dintre cele 5 randuri are o structura electromagnetica diferita). Totusi, costurile mutarilor nu depind de coloana in care se afla robotul.\r\n\r\nRobotul va fi supus unui test, dupa cum urmeaza: i se vor acorda $TMAX$ unitati de timp. Folosindu-le, va trebui sa mute cat mai departe posibil de pozitia curenta. Distanta nu este masurata in termeni de patrate, ci in termeni de coloane. Daca dupa $TMAX$ unitati temporale robotul se afla pe coloana $X$, distanta este considerata |{$X$}| (valoarea absoluta a lui $X$). Nu este importanta linia pe care ajunge.\r\n\r\nRobotul va alege directia in care va fi orientat initial si cantitatea de timp va incepe sa scada dupa ce face aceasta decizie. Aflati care este distanta maxima pe care robotul o poate parcurge in $TMAX$ unitati de timp.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $biomech.in$ contine cantitatea de timp $TMAX$. Urmatoarele $8$ linii contin cate $8$ numere intregi fiecare. Al $j$-lea numar de pe a $i$-a dintre aceste linii reprezinta timpul necesar pentru a schimba directia $i$ in directia $j$. Urmatoarele $5$ linii contin cate $8$ numere intregi fiecare. Al $j$-lea numar de pe a $i$-a dintre aceste linii reprezinta timpul necesar pentru a muta in directia $j$ dintr-un patrat de pe linia $i$. Sunt date valori si pentru mutarile interzise. Acestea trebuie ignorate.\r\n\r\nOrdinea directiilor (de la $1$ la $8$) este urmatoarea: $N, NE, E, SE, S, SV, V, NV$.\r\n\r\nh2. Date de Iesire\r\n\r\nAfisati pe singura linie a fisierului $biomech.out$ distanta maxima pe care robotul o poate parcurge fara sa depaseasca durata de timp $TMAX$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* {$1 &le; TMAX &le; 10^15^$}, $TMAX$ este intreg\r\n* $1$ &le; timpul necesar pentru orice rotatie sau miscare &le; $1.000$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. biomech.in |_. biomech.out |\r\n| 4\r\n0 10 10 10 10 10 10 10\r\n10 0 10 10 10 10 10 1\r\n10 10 0 10 10 10 10 10\r\n10 10 10 0 10 10 10 10\r\n10 10 10 10 0 10 10 10\r\n10 10 10 10 10 0 10 10\r\n10 10 10 10 10 10 0 10\r\n10 10 10 1 10 10 10 0\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n1000 1000 1000 1 1000 1000 1000 1000\r\n1000 1 1000 1000 1000 1000 1000 1000\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n| 2 |\r\n| 100000\r\n0 1000 1000 1000 1000 1000 1000 1000\r\n1000 0 1000 1000 1000 1000 1000 1000\r\n1000 1000 0 1000 1000 1000 1000 1000\r\n1000 1000 1000 0 1000 1000 1000 1000\r\n1000 1000 1000 1000 0 1000 1000 1000\r\n1000 1000 1000 1000 1000 0 1000 1000\r\n1000 1000 1000 1000 1000 1000 0 1000\r\n1000 1000 1000 1000 1000 1000 1000 0\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n1000 1000 1000 1000 1000 1000 7 1000\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n| 14285 |\r\n| 50\r\n12 8 43 20 45 13 28 18\r\n34 28 17 18 19 49 43 46\r\n22 32 11 48 29 46 15 22\r\n42 20 5 5 25 13 4 39\r\n31 31 1 34 26 31 40 40\r\n29 5 19 25 47 37 3 45\r\n32 43 25 18 42 33 47 34\r\n35 35 6 49 32 15 23 40\r\n22 4 1 12 24 16 46 40\r\n23 27 39 21 19 16 20 39\r\n42 26 42 45 50 46 39 6\r\n23 8 45 16 36 26 31 18\r\n40 47 48 26 10 7 3 13\r\n| 2 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"biomech\")==',18,'task: biomech'),('problema/bmatrix','BMatrix','2006-11-11 16:31:02','==Include(page=\"template/taskheader\" task_id=\"bmatrix\")==\r\n\r\nSe considera o matrice binara de dimensiune $m x n$ (elementele matricei sunt $0$ sau $1$).\r\n\r\nh2. Cerinta\r\n\r\nSe cere sa se determine aria maxima care poate fi acoperita de doua dreptunghiuri care contin numai elemente cu valoarea $0$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $bmatrix.in$ contine pe prima linie doua numere intregi $m$ si $n$, separate printr-un singur spatiu, care reprezinta dimensiunile matricei. Pe fiecare dintre urmatoarele $m$ linii se afla $n$ numere care pot avea valorile $0$ sau $1$ si care nu sunt separate intre ele prin spatii.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bmatrix.out$ trebuie sa contina un singur numar, care reprezinta aria maxima care poate fi acoperita de doua dreptunghiuri care contin numai elemente cu valoarea $0$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; m, n &le; 200$\r\n* cele doua dreptunghiuri nu se pot suprapune.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bmatrix.in |_. bmatrix.out |\r\n| 6 8\r\n10000000\r\n10000000\r\n11100011\r\n00100011\r\n00100011\r\n00111111\r\n| 23 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bmatrix\")==',18,'task: bmatrix'),('problema/emm','Expresii min-max','2006-11-12 01:03:21','==Include(page=\"template/taskheader\" task_id=\"emm\")==\r\n\r\nConsiderati o expresie care contine numere naturale, paranteze, si operatorii binari {@m@} si {@M@}. {@m@} este operatorul de minim si {@M@} este operatorul de maxim. Astfel, rezultatul operatiei {@A m B@} este valoarea minima dintre {@A@} si {@B@}, iar rezultatul operatiei {@A M B@} este valoarea maxima dintre {@A@} si {@B@}. De exemplu, rezultatul {@2m7@} este {@2@}, iar rezultatul {@9M8@} este {@9@}. Cei doi operatori au aceeasi prioritate. Asta inseamna ca daca un sunt paranteze, vor fi evaluati de la stanga la dreapta. De exemplu, rezultatul {@1M22m13m789@} este {@13@}.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se o expresie care contine numere naturale, paranteze si acesti doi operatori, aflati rezultatul obtinut.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $emm.in$ contine expresia data. Nu vor exista spatii, linia se termina cu caracter de sfarsit de linie (care nu face parte din ea).\r\n\r\nh2. Date de Iesire\r\n\r\nAfisati pe prima linie a fisierului $emm.out$ rezultatul obtinut in urma evaluarii expresiei.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Lungimea unei expresii va fi mai mica sau egala cu $100.000$\r\n* Numerele care apar in expresie vor fi numere naturale cuprinse intre $0$ si $1.000.000.000$\r\n\r\nExemple\r\n\r\ntable(example). |_. emm.in |_. emm.out |\r\n| 178\r\n| 178 |\r\n| 178m66m234M89m54M13M22m67 \r\n| 54 |\r\n| (((178)))\r\n| 178 |\r\n| (1m1m1M1M1m1M1M1m1M0)m1M1 \r\n| 1 |\r\n| 12m23M13m192)M(90m89m88m87)m((298M7)M2)\r\n| 87 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"emm\")==',961,'task: emm'),('problema/noroc','Noroc','2006-11-11 20:32:31','==Include(page=\"template/taskheader\" task_id=\"noroc\")==\r\n\r\nAenag Lurtseam este impatimit al jocurilor de noroc. De data aceasta a gasit un nou joc captivant, si anume $cap sau pajura$. Acesta se joaca in felul urmator: se arunca o moneda in mod repetat, iar la fiecare $cap$ Aenag castiga ${@$@}1$, in timp ce la fiecare $pajura$ pierde ${@$@}1$. Continua sa joace astfel pana cand capitalul sau ajunge la ${@$@}M$ sau pana cand isi pierde toti banii.\r\n\r\nh2. Cerinta\r\n\r\nStiinda ca initial Aenag Lurtseam avea ${@$@}X$, calculati probabilitatea ca acesta sa falimenteze.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare va contine doua numere naturale nenule $X$ si $M$, reprezentand capitalul initial, respectiv capitalul dorit.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire va contine pe prima linie un singur numar real, reprezentand probabilitatea cautata.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; X, M &le; 32.000$\r\n* rezultatul se va afisa rotunjit la $7$ zecimale exacte\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. noroc.in |_. noroc.out |\r\n| 1 2\r\n| 0.5000000 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"noroc\")==',18,'task: noroc'),('template/raw','template/raw','2006-11-11 20:49:09','{color:red}|_=. Aceasta pagina a fost importata din infoarena1 si nu este inca prelucrata. \r\nSterge @==Include(file=\"template/raw\")==@ cand esti multumit cu continutul paginii.|',15,'protected'),('problema/catun','Catun','2006-11-11 17:14:39','==Include(page=\"template/taskheader\" task_id=\"catun\")==\r\n\r\nIntr-un regat feudal exista mai multe asezari omenesti, numerotate de la $1$ la $N$, intre care sunt construite drumuri de diverse lungimi. Dintre aceste asezari, o parte sunt fortarete, iar restul sunt simple catune. Fiecare fortareata trebuie sa aprovizioneze trupele stationate in ea, deci are nevoie de feude. In calitate de mare sfetnic al monarhului, vi se cere sa indicati feudele aservite fiecarei fortarete, respectiv toate acele catune care se afla mai aproape de fortareata in discutie decat de oricare alta. Daca un catun este la distanta egala de doua fortarete, se va considera ca apartine fortaretei cu numarul de identificare minim.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine pentru fiecare catun carei fortarete apartine.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul de intrare $catun.in$ se vor afla numarele $N, M, K$, indicand, in aceasta ordine, numarul de asezari, numarul de drumuri si numarul de fortarete. Cea de a doua linie a fisierului va contine $K$ numere naturale distincte indicand numerele de ordine ale fortaretelor. Pe urmatoarele $M$ linii, pana la sfarsitul fisierului, se vor gasi triplete de forma $(x y z)$, semnificand faptul ca exista un drum bidirectional intre asezarile $x$ si $y$ de lungime $z$, exprimata in unitatea de masura pentru lungimi a Evului Mediu.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $catun.out$ va contine o singura linie pe care se afla $N$ numere naturale, al $i$-lea numar fiind $0$, daca asezarea a $i$-a este o fortareata sau este un catun de la care nu se poate ajunge la nici o fortareata din cele $K$, sau numarul fortaretei de care se leaga asezarea a $i$-a, in caz contrar.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; K &le; N &le; 36 000$\r\n* $1 &le; M &le; 72 000$\r\n* Intre oricare doua asezari exista maxim un drum\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. catun.in |_. catun.out |\r\n| 8 9 2\r\n2 5\r\n1 3 6\r\n1 5 3\r\n1 6 1\r\n2 3 9\r\n5 6 5\r\n6 8 7\r\n3 6 2\r\n4 7 1000\r\n2 8 5\r\n| 5 0 5 0 0 5 0 2 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"catun\")==',18,'task: catun'),('problema/cercuri','Cercuri','2006-11-11 17:26:06','==Include(page=\"template/taskheader\" task_id=\"cercuri\")==\r\n\r\nSe dau doua cercuri. Acestea se pot intersecta in 0, 1, 2 sau o infinitate de puncte (daca sunt identice).\r\n\r\nh2. Cerinta\r\n\r\nGasiti distanta dintre cele doua puncte de intersectie, in cazul in care se intersecteaza in exact 2 puncte, sau tratati celelalte cazuri corespunzator (vezi $Date de iesire$).\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $cercuri.in$ contine $T$, numarul de teste. Pe fiecare din urmatoarele $T$ linii se afla cate un test: un test contine $6$ numere intregi: $x{~1~}, y{~1~}, R{~1~}, x{~2~}, y{~2~}, R{~2~}$. {$(x{~1~}, y{~1~})$} sunt coordonatele centrului primului cerc, iar R{~1~} este raza primului cerc. {$(x{~2~}, y{~2~})$} sunt coordonatele celui de-al doilea cerc, iar R{~2~} este raza celui de-al doilea cerc.\r\n\r\nh2. Date de Iesire\r\n\r\nPentru fiecare test, afisati o linie pe care scrie:\r\n\r\n* $-1$, daca cele doua cercuri sunt identice\r\n* $-2$, daca cele doua cercuri nu se intersecteaza in nici un punct\r\n* $-3$, daca cele doua cercuri se intersecteaza in exact un punct\r\n* distanta dintre cele doua puncte de intersectie, daca cele doua cercuri se intersecteaza in exact $2$ puncte\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 &le; x{~1~}, y{~1~}, R{~1~}, x{~2~}, y{~2~}, R{~2~} &le; 1.000$\r\n* Rezultatul va fi afisat cu o precizie de $3$ zecimale\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. cercuri.in |_. cercuri.out |\r\n| 5\r\n5 5 5 6 6 6\r\n5 5 5 6 6 6\r\n0 0 10 5 5 10\r\n0 0 10 0 0 10\r\n0 0 1 1000 1000 1\r\n| 7.714\r\n7.714\r\n18.708\r\n-1\r\n-2 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cercuri\")==',18,'task: cercuri'),('problema/muzeu','Muzeu','2006-11-11 17:27:22','==Include(page=\"template/taskheader\" task_id=\"muzeu\")==\r\n\r\nUn muzeu are forma patratica si contine $N*N$ camere ce pot fi vizitate. Unele camere sunt deschise si contin opere de arta, altele sunt inchise (sunt folosite pentru alte scopuri). In unele din camerele libere, se afla paznici. Directorul muzeului se teme de eventualitatea unei spargeri si de aceea doreste sa evalueze cat de bine au fost asezati paznicii in camerele libere. Mai precis, el doreste sa afle, pentru fiecare camera libera, care este distanta minima pana la cel mai apropiat paznic (numarul minim de camere prin care trebuie sa intre un paznic pentru a ajunge la camera respectiva). Paznicii se pot deplasa numai in camerele libere din Nord, Est, Sud sau Vest (cu conditia sa nu paraseasca muzeul).\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $muzeu.in$ se afla numarul intreg $N$, reprezentand numarul de linii (si de coloane) ale muzeului (muzeul avand $N*N$ camere). Urmatoarele $N$ linii contin cate $N$ caractere fiecare:\r\n\r\n* `.\' pentru camera libera in care nu se afla paznic\r\n* `P\' pentru camera libera in care se afla paznic\r\n* `#\' pentru camera inchisa (prin care nu pot trece nici paznicii, dar in care nu pot intra nici hotii)\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $muzeu.out$ veti afisa $N$ linii, fiecare din ele continand $N$ numere intregi (separate prin spatii). Fiecare numar afisat corespunde camerei de pe linia si coloana corespunzatoare din fisierul de intrare. Pentru fiecare camera libera veti afisa distanta minima pana la cel mai apropiat paznic (sau $-1$ daca nici un paznic nu poate ajunge in aceasta camera). Pentru camerele inchise, veti afisa $-2$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* 1 &le; N &le; 250\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. muzeu.in |_. muzeu.out |\r\n| 8\r\n  ...#....\r\n  #..#..#.\r\n  .##.P..#\r\n  ..#.#.#.\r\n  ........\r\n  ........\r\n  ###...##\r\n  ..P.....\r\n| -1 -1 -1 -2 &nbsp;2 &nbsp;3 &nbsp;4  &nbsp;5\r\n  -2 -1 -1 -2 &nbsp;1 &nbsp;2 -2  &nbsp;6\r\n   &nbsp;8 -2 -2 &nbsp;1 &nbsp;0 &nbsp;1 &nbsp;2 -2\r\n   &nbsp;7 &nbsp;6 -2 &nbsp;2 -2 &nbsp;2 -2  &nbsp;6\r\n   &nbsp;6 &nbsp;5 &nbsp;4 &nbsp;3 &nbsp;4 &nbsp;3 &nbsp;4 &nbsp;5\r\n   &nbsp;6 &nbsp;5 &nbsp;4 &nbsp;3 &nbsp;4 &nbsp;4 &nbsp;5 &nbsp;6\r\n  -2 -2 -2 &nbsp;2 &nbsp;3 &nbsp;4 -2 -2\r\n   &nbsp;2 &nbsp;1 &nbsp;0 &nbsp;1 &nbsp;2 &nbsp;3 &nbsp;4 &nbsp;5 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"muzeu\")==',48,'task: muzeu'),('problema/tvshow','TVShow','2006-11-11 21:57:42','==Include(page=\"template/taskheader\" task_id=\"tvshow\")==\r\n\r\nIntr-un show de televiziune $N$ concurenti participa intr-o competitie pe viata si pe moarte din care doar unul dintre ei poate iesi castigator. Fiecare concurent a adunat pe parcursul emisiunii un numar de puncte, {$S{~i~}$}, si acum urmeaza proba finala. Fiecare dintre ei trebuie sa aleaga una dintre cele doua porti din fata lor. Doar una dintre ele ascunde in spatele ei marele premiu. De asemenea fiecare concurent parieza un numar de puncte {$P{~i~}$} ({$0&le;P{~i~}&le;S{~i~}$}). Daca poarta pe care a ales-o el este cea care ascunde premiul atunci punctajul sau va fi S{~i~}+P{~i~} iar daca nu a ghicit-o S{~i~}-P{~i~}. Concurentul cu punctajul maxim in urma acestei probe va castiga marele premiu. Daca exista mai multe punctaje maxime nu va castiga nimeni. Ultimul concurent, cine altul decat Petrica, se afla in fata unei decizii foarte dificile: el stie punctajele celorlalti concurenti si ce numar de puncte au pariat fiecare dar nu stie ce porti au ales acestia, in schimb stie ca fiecare concurent - chiar si el - are {$50%$} sanse sa ghiceasca poarta castigatoare si {$50%$} sanse sa nu o ghiceasca. Trebuie sa decida ce numar de puncte va paria pentru ca probabilitatea sa de castig sa fie cat mai mare (chiar daca pentru doua moduri de a paria probabilitatile sunt foarte apropiate, diferenta fiind practic nula, Petrica va alege modul pentru care probabilitatea sa de castig este mai mare).\r\n\r\nh2. Cerinta\r\n\r\nCalculati numarul de puncte pe care trebuie sa-l parieze Petrica pentru a avea sanse de castig cat mai mari. Daca exista mai multe solutii alegeti-o pe cea mai mica. De asemenea aflati si probabilitea maxima de castig pe care o poate avea Petrica.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $tvshow.in$ va contine pe prima linie numarul intreg $N$ reprezentand numarul de concurenti din concurs. Fiecare din urmatoarele {$N - 1$} linii va contine doi intregi separati printr-un spatiu reprezentand scorul si numarul de puncte pariate pentru fiecare din primii {$N - 1$} concurenti. Ultima linie contine un singur numar intreg reprezentand scorul lui Petrica.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $tvshow.out$ se va afla numarul de puncte pariat de Petrica. Pe urmatoarele doua linii se vor afla doua numere intregi $A$ si $B$ care reprezinta probabilitatea maxima de castig a lui Petrica sub forma de fractie ireductibila (probabilitatea este egala cu {$A/B$}).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 < N < 301$\r\n* Valorile scorurilor sunt numere intregi din intervalul $[0, 30000]$\r\n* Pentru {$40%$} din teste $N &le; 17$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. tvshow.in |_. tvshow.out |\r\n|3\r\n100 25\r\n100 75\r\n100\r\n|76\r\n1\r\n2 |\r\n|2\r\n10 3\r\n2\r\n|0\r\n0\r\n1 |\r\n|3\r\n50 31\r\n60 41\r\n10\r\n|10\r\n1\r\n8 |\r\n\r\nh3. Explicatii\r\n\r\nPentru primu exemplu, probabilitatea ca Petrica sa castige este de 50% daca alege sa parieze 76 de puncte, indiferent daca primii doi concurenti au ghicit sau nu poarta castigatoare. Daca Petrica a ghicit poarta castigatoare el castiga concursul (acumuland 176 de puncte) iar daca nu a ghicit-o atunci sigur pierde (acumuland 24 de puncte). Daca va paria mai putin de 76 de puncte probabilitatea de a castiga va fi mai mica, iar daca pariaza mai mult probabilitatea va ramane aceeasi.\r\n\r\nPentru cel de-al doilea Petrica pierde orice suma ar paria.\r\n\r\nIn cel de-al treilea exemplu, daca Petrica pariaza 10 puncte are 12.5% sanse sa castige (el castiga doar in cazul in care primii doi concurenti nu ghicesc poarta si el o ghiceste; in oricare din celelalte cazuri Petrica va pierde). Daca pariaza mai putin Petrica va avea 0% sanse de castig.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"tvshow\")==',15,'task: tvshow'),('problema/numar','Numar','2006-11-11 20:45:01','==Include(page=\"template/taskheader\" task_id=\"numar\")==\r\n\r\nSe considera un numar natural $n$.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine toate modalitatile in care numarul dat se poate scrie ca suma de numere (cel putin doua) intregi consecutive.\r\n\r\nh2. Date de Intrare\r\n\r\n* Pe prima linie a fisierului $numar.in$ se afla numarul natural $n$.\r\n\r\nh2. Date de Iesire\r\n\r\n* Fisierul de iesire $numar.out$ va contine atatea linii cate modalitati de descompunere exista.\r\n* Pe fiecare linie se vor scrie doua numere intregi $p$ si $nr$, unde $p$ reprezinta primul termen din suma, iar $nr$ reprezinta numarul termenilor.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; n &le; 1000000000$\r\n* Descompunerile vor fi afisate in ordine descrescatoare dupa primul numar din sir.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. numar.in |_. numar.out |\r\n| 25\r\n| 12 2\r\n  3 5\r\n  -2 10\r\n  -11 25\r\n  -24 50 |\r\n\r\nh3. Explicatii\r\n\r\n12+13=25\r\n3+4+5+6+7=25\r\n-2-1+0+1+2+3+4+5+6+7=25\r\n-11-10-9-8-7-6-5-4-3-2-1+0+1+2+3+4+5+6+7+ 8+9+10+11+12+13=25\r\nLa fel, n ultimul caz, suma celor 50 de numere consecutive ncepnd cu -24 este 25. \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"numar\")==',48,'task: numar'),('problema/cifra','Cifra','2006-11-12 16:01:32','==Include(page=\"template/taskheader\" task_id=\"cifra\")==\r\n\r\nGigel, fiind plictisit, se juca in timpul orei de matematica, desenand pe o foaie. Din pacate, profesorul l-a vazut si i-a spus ca ii pune nota 4 daca nu rezolva urmatoarea problema: pentru o valoarea $N$ data trebuie sa determine ultima cifra a sumei $1^1^ + 2^2^ + ... + N^N^$.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa-l ajute pe Gigel si sa determine ultima cifra a acestei sume pentru $T$ valori date ale lui $N$.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie din fisierul $cifra.in$ se va afla numarul $T$. Pe urmatoarele $T$ linii se vor gasi valori ale lui $N$ pentru care trebuie gasit raspunsul.\r\n\r\nh2. Date de iesire\r\n\r\nPe cele $T$ linii ale fisierului $cifra.out$ se vor gasi raspunsurile pentru valorile lui $N$ date in fisierul de intrare.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; T &le; 30.000$\r\n* $1 &le; N < 10^100^$\r\n* Se acorda punctaj pentru un test doar daca toate cele $T$ valori din fisierul de iesire sunt corecte\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. cifra.in |_. cifra.out |\r\n| 5\r\n1\r\n2\r\n3\r\n4\r\n5\r\n| 1\r\n5\r\n2\r\n8\r\n3 |\r\n\r\nh3. Explicatii\r\n\r\n1^1^  = *1*\r\n1^1^ + 2^2^ = 1 + 4 = *5*\r\n1^1^ + 2^2^ + 3^3^ = 1 + 4 + 27 = 3{*2*}\r\n1^1^ + 2^2^ + 3^3^ + 4^4^ = 1 + 4 + 27 + 256 = 28{*8*}\r\n1^1^ + 2^2^ + 3^3^ + 4^4^ + 5^5^ = 1 + 4 + 27 + 256 + 3125 = 341{*3*}\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cifra\")==',15,'task: cifra'),('problema/trans','Trans','2006-11-11 18:39:18','==Include(page=\"template/taskheader\" task_id=\"trans\")==\r\n\r\nIn depozitul unei companii de constructii se afla $N$ blocuri de piatra, de culoare alba sau neagra. Ele sunt asezate in ordinea $1$, $2$,.., $N$, de la intrarea in depozit catre interior. Blocurile de piatra trebuie sa fie transportate pe un santier de constructii, in ordinea in care ele sunt depozitate, iar pentru aceasta va trebui inchiriat un camion de la o companie de transport. Aceasta detine $Q$ tipuri de camioane. Camionul de tipul $i$ ({$1 &le; i &le; Q$}) poate transporta maxim $K{~i~}$ blocuri de piatra la un moment dat si pentru un transport se percepe taxa $T{~i~}$.\r\n\r\nCompania de transport este de parere ca, pentru a-si pastra clientela, trebuie sa impuna anumite standarde, indiferent de cat de absurde ar fi, deci impune conditia ca toate blocurile de piatra plasate in camion la un transport sa aiba aceeasi culoare. Asadar, pentru a fi transportate toate blocurile pe santier, compania de constructii va alege un camion de un anumit tip, iar camionul va efectua unul sau mai multe transporturi. Pentru a micsora suma totala platita, compania de constructii are posibilitatea de a schimba culoarea oricarui bloc de piatra (din alb in negru sau din negru in alb); pentru fiecare bloc $i$ ({$1 &le; i &le; N$}) se cunoaste suma $S{~i~}$ ce trebuie platita pentru a-i schimba culoarea.\r\n\r\nh2. Cerinta\r\n\r\nPentru fiecare dintre cele $Q$ tipuri de camioane detinute de compania de transport, determinati suma minima pe care o va plati compania de constructii pentru a transporta toate cele $N$ blocuri pe santier.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $trans.in$ contine pe prima linie numarul intreg $N$, reprezentand numarul de blocuri de piatra din depozit. Pe fiecare dintre urmatoarele $N$ linii se afla informatii referitoare la cate un bloc de piatra. Pe a $i$-a dintre aceste $N$ linii se gasesc doua numere intregi separate printr-un spatiu: {$C{~i~} S{~i~}$}, reprezentand culoarea celui de-al $i$-lea bloc ({$C{~i~}$} este 0 pentru alb si 1 pentru negru) si respectiv suma ce trebuie platita pentru a-i schimba culoarea (daca este necesar). Pe urmatoarea linie se afla numarul natural $Q$, reprezentand numarul de tipuri de camioane detinute de compania de transport. Pe fiecare dintre urmatoarele $Q$ linii se afla informatii referitoare la cate un camion. Pe cea de a $i$-a dintre aceste $Q$ linii sunt scrise doua numere naturale separate printr-un spatiu {$K{~i~} T{~i~}$}, reprezentand numarul maxim de blocuri ce pot fi transportate simultan de catre un camion de tipul $i$ si respectiv taxa ce trebuie platita pentru fiecare transport efectuat.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $trans.out$ va contine $Q$ linii. Pe cea de a $i$-a dintre aceste linii va fi afisata suma totala minima platita de compania de constructii pentru a transporta toate cele $N$ blocuri de piatra, in cazul in care ar inchiria un camion de tipul $i$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 16 000$\r\n* $1 &le; S{~i~} &le; 10 000$\r\n* $1 &le; Q &le; 100$\r\n* $1 &le; K{~i~} &le; N$\r\n* $1 &le; T{~i~} &le; 100 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. trans.in|_. trans.out|\r\n|4\r\n0 2\r\n1 3\r\n0 10\r\n1 2\r\n3\r\n4 1000\r\n4 1\r\n2 5\r\n|1005\r\n4\r\n14|\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"trans\")==',256,'task: trans'),('problema/otilia','Otilia','2006-12-16 13:24:09','==Include(page=\"template/taskheader\" task_id=\"otilia\")==\r\n\r\nOtilia si Burbucel, fiind in fata unei gramezi de $N$ pietre si neavand ce face, stabilesc regulile unui nou joc. Cei doi copii vor ca jocul sa fie simplu asa ca impun doar trei reguli:\r\n1. Primul jucator are voie sa ia din gramada cel mult $K$ piese\r\n2. Cu exceptia primei mutari, fiecare jucator are voie sa ia maxim $P*t$ pietre, unde $t$ este numarul de pietre care au fost substituite din gramada la mutarea precedenta\r\n3. Pierde cel care muta ultimul (cel care ia ultimele pietre din gramada)\r\n\r\nCei doi au jucat multe jocuri, Burbucel fiind intotdeauna cel care alege numerele $N, K$ si $P$ si Otilia primul jucator care muta. Otilia a observat ca alegerile lui Burbucel se repeta dupa $M$ jocuri (alegerea numarul $M+1$ este identica cu alegerea numarul $1$, alegerea numarul $M+2$ este identica cu alegerea numarul $2$, etc.). Ea ar vrea sa stie daca poate castiga sau nu pentru fiecare dintre primele M alegeri ale lui Burbucel. Motivul este usor de intuit: Otilia nu vrea sa-i dea ocazia lui Burbucel sa castige asa ca va renunta pe jocurile unde nu are strategie de castig.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care rezolva dilema Otiliei.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $otilia.in$ se afla $M$, numarul de alegeri ale lui Burbucel. Urmatoarele $M$ linii contin cate trei numere, $N, K si P$ reprezentand o alegere a lui Burbucel ({$N$} - numarul de pietre din gramada, $K$ - numarul maxim de pietre pe care le poate lua Otilia la prima mutare, $P$ - factorul cu care se inmulteste numarul de pietre luate la mutarea precedenta rezultand astfel numarul maxim de pietre care se pot substitui la mutarea curenta).\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $otilia.out$ contine $M$ linii, pe linia $i$ aflandu-se $1$ daca Otilia castiga la alegerea numarul $i$ a lui Burbucel sau $0$ daca ea pierde (alegerile sunt numerotate de la $1$ la $M$ in ordinea in care se gasesc in fisierul de intrare).\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; M &le; 30 000$\r\n* $1 &le; N &le; 5 000 000$\r\n* $1 &le; K &le; N$\r\n* $1 &le; P &le; 10$\r\n* Pentru $50%$ din teste $N &le; 500 000$ pentru toate alegerile lui Burbucel\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. otilia.in |_. otilia.out |\r\n|4\r\n1 1 3\r\n3 2 8\r\n5 1 3\r\n100 1 1\r\n|0\r\n1\r\n0\r\n1|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"otilia\")==',256,'task: otilia'),('problema/tort','Tort','2006-11-24 16:22:06','==Include(page=\"template/taskheader\" task_id=\"tort\")==\r\n\r\nDe ziua ei, Ionela a facut un tort in forma triunghiulara. Dorind sa-l imparta cu prietenii ei, Ionela efectueaza $A$ taieturi dintr-un colt oarecare si $B$ taieturi din alt colt al tortului (un colt adica un varf al triunghiului initial). Dupa multe astfel de taieturi, ea este dezorientata: oare cate felii de tort in forma triunghiulara a taiat? Prin felie intelegem un triunghi cu taieturi pe laturi si varfuri in intersectiile taieturilor. O felie poate contine si alte taieturi in interior.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-o pe Ionela sa numere feliile de tort in forma triunghiulara.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul $tort.in$ contine pe prima linie numerele $A$ si $B$ separate printr-un spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul $tort.out$ va contine o linie cu numarul de felii de tort.\r\n\r\nh2. Restrictii\r\n\r\n* $0 &le; A, B &le; 2 000 000 000$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. tort.in|_. tort.out |\r\n|1 2|15 |\r\n|1 0|3 |\r\n\r\nDesenul urmator corespunde ultimului exemplu:\r\n\r\n!problema/tort?tri.jpg!\r\n\r\nCele trei felii sunt: triunghiul mare (tot tortul) si cele 2 mai mici din interior.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"tort\")==',1142,'task: tort'),('problema/tj','Tom & Jerry','2006-11-11 19:01:17','==Include(page=\"template/taskheader\" task_id=\"tj\")==\r\n\r\nTom si Jerry joaca un joc intr-un graf neorientat cu $N$ noduri (numerotate de la 1 la $N$). Tom alege unul dintre nodurile grafului si se pozitioneaza in acest nod. Apoi Jerry alege si el unul dintre nodurile grafului (eventual acelasi) si se pozitioneaza in acel nod. Dupa aceste pozitionari _strategice_, incepe jocul efectiv. Tom si Jerry efectueaza mutari alternativ. La fiecare mutare, ei se pot deplasa din nodul in care se afla in orice alt nod invecinat (doua noduri sunt invecinate daca exista o muchie intre ele) sau pot ramane pe loc (in acelasi nod). Tom este cel care efectueaza prima mutare si scopul lui este de a-l prinde pe Jerry. Astfel, Tom castiga jocul daca ajunge in acelasi nod al grafului ca si Jerry. Jerry castiga jocul daca poate sa fuga de Tom la infinit (adica orice mutare ar efectua Tom, la orice moment, Jerry poate efectua la randul lui o mutare prin care sa evite sa ajunga in aceeasi pozitie ca si Tom).\r\n\r\nh2. Cerinta\r\n\r\nPentru un graf dat, determinati daca Tom are strategie sigura de castig.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului $tj.in$ contine numarul natural $T$, reprezentand numarul de grafuri descrise in continuare. Un graf este descris pe o succesiune de linii din fisierul de intrare, dupa cum urmeaza. Prima linie contine numerele naturale $N$ si $M$ reprezentand numarul de noduri, respectiv numarul de muchii ale grafului. Fiecare dintre urmatoarele $M$ linii contine cate 2 numere naturale $a$ si $b$, avand semnificatia ca exista muchie intre nodurile $a$ si $b$. Intre descrierile a doua grafuri consecutive din fisierul de intrare se afla o linie goala.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $tj.out$ veti afisa pentru fiecare graf din fisierul de intrare (in ordinea in care sunt descrise grafurile in fisier) $DA$, in caz ca Tom are strategie sigura de castig, respectiv $NU$, in caz contrar.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; T &le; 20$\r\n* $1 &le; N &le; 256$\r\n* $0 &le; M &le; N*(N-1)/2$\r\n* Nu exista muchie de la un nod la el insusi\r\n* Intre doua noduri ale grafului exista cel mult o muchie\r\n* Cel putin $60%$ din teste vor avea $N &le; 64$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. tj.in |_. tj.out |\r\n|6\r\n2 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n4 4\r\n1 2\r\n1 3\r\n2 3\r\n3 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n3 2\r\n1 2\r\n2 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n2 1\r\n1 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n1 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \r\n4 4\r\n1 2\r\n2 3\r\n3 4\r\n4 1\r\n|NU\r\nDA\r\nDA\r\nDA\r\nDA\r\nNU|\r\n\r\n \r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"tj\")==',256,'task: tj'),('problema/geom','Geometrie','2006-11-12 00:43:55','==Include(page=\"template/taskheader\" task_id=\"geom\")==\r\n\r\nSe considera $N$ puncte in plan.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine distanta minima dintre doua drepte paralele care contin intre ele cel putin $K$ puncte.\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul de intrare $geom.in$ va avea pe prima linie doua numere intregi $N$ si $K$ reprezentand numarul de puncte din plan, respectiv numarul de puncte care trebuie sa se gaseasca intre cele doua drepte. Pe urmatoarele $N$ linii se vor afla cate doua numere intregi, separate intre ele printr-un spatiu, $X$ si $Y$ care reprezinta coordonatele unui punct in plan.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $geom.out$ va contine pe prima linie un singur numar real $D$ cu trei zecimale exacte, care reprezinta distanta minima dintre doua drepte paralele care indeplinesc conditiile din enunt.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1$ &le; $N$ &le; $300$\r\n* $1$ &le; $K$ &le; $N$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. geom.in |_. geom.out |\r\n|5 4\r\n0 0\r\n1 0\r\n0 1\r\n1 1\r\n1000 0 | 1.000 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"geom\")==\r\n',13,'task: geom'),('problema/evantai','Evantai','2006-11-11 22:30:27','==Include(page=\"template/taskheader\" task_id=\"evantai\")==\r\n\r\n\r\nLui Algorel ii plac mult sirurile de numere naturale cu proprietati cat mai ciudate. Cautand astfel de ciudatenii ale informaticii, a gasit printr-o carte prafuita de vreme un nou tip de sir denumit evantai. Un evantai este un sir cu un numar par de termeni, $E{~1~} E{~2~} ... E{~2K~}$, cu urmatoarea proprietate:\r\n\r\np=. $E{~1~} + E{~2K~} > E{~2~} + E{~2K-1~} > ... > E{~K~} + E{~K+1~}$\r\n\r\nh2. Cerinta\r\n\r\nFiind dat un sir de numere naturale distincte $A{~1~} A{~2~} ... A{~N~}$, Algorel vrea sa afle cate subsiruri ale acestuia sunt evantaie.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului $evantai.in$ contine numarul intreg $N$, reprezentand numarul de elemente ale sirului. Urmatoarele $N$ linii contin, in ordine, elementele sirului $A$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $evantai.out$ se va afla un singur numar intreg $C$, reprezentand numarul de subsiruri evantai. Rezultatul va fi afisat modulo $30103$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 700$\r\n* Elementele sirului sunt numere intregi distincte cuprinse intre $1$ si $1000$\r\n* Prin subsir se intelege orice insiruire de termeni $A{~i1~} A{~i2~} ... A{~ik~}$ astfel incat $i{~1~} < i{~2~} < ... < i{~k~}$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. evantai.in |_. evantai.out | \r\n| 4\r\n1\r\n2\r\n3\r\n6 | 7 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"evantai\")==',15,'task: evantai'),('sandbox2','Sandbox2','2006-11-11 22:48:20','== Grep(page=\"%\" substr=\"%Grep%\") ==',13,'public'),('problema/cowfood','Cowfood','2006-11-12 16:07:50','==Include(page=\"template/taskheader\" task_id=\"cowfood\")==\r\n\r\nCercetatorii nutritionisti fac experimente asupra amestecului optim de ierburi cu care pot fi hranite vacile. Au adunat K feluri de plante diferite si le-au amestecat, obtinand formule reprezentate prin vectori de forma ({$a{~1~}, a{~2~}, .. a{~k~}$}) unde a{~i~} reprezinta cantitatea de plante de tipul $i$ folosita in mixtura. Se stie ca pentru orice amestec valid, $a{~1~} + a{~2~} + ... + a{~k~}$ nu depaseste niciodata o valoare data {$S$}. Toate experimentele desfasurate au esuat insa, deoarece vacile nu au agreat cantitatile de ierburi din amestecurile testate. Mai mult, cercetatorii si-au dat seama ca pentru orice experiment ratat de forma ({$a{~1~}, a{~2~}, .. a{~k~}$}) , un experiment ({$b{~1~}, b{~2~}, .. b{~k~}$}) cu $a{~1~} &le; b{~1~}, a{~2~} &le; b{~2~}, ... a{~k~} &le; b{~k~}$ va esua de asemenea.\r\n\r\nh2. Cerinta\r\n\r\nFiindca cercetatorii vor sa termine lucrul cat mai curand posibil, este datoria ta sa afli cate experimente care mai au sanse de a se incheia cu succes au ramas.\r\n\r\nh2. Date de Intrare\r\n\r\nLinia $1$ a fisierului de intrare $cowfood.in$ contine trei numere naturale {$K$}, $S$ si {$N$}.\r\nLiniile $2 .. N + 1$ contin cate $K$ numere ({$a{~1~}, a{~2~}, .. a{~k~}$}) ce reprezinta cate un experiment despre care se stie sigur ca a dat gres.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $cowfood.out$ va contine pe prima linie numarul de amestecuri ramase care mai au inca sanse de a fi agreate de vaci modulo {$3210121$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; K &le; 30$\r\n* $2 &le; S &le; 10.000$\r\n* $0 &le; N &le; 20$\r\n* orice mixtura valida contine cel putin doua cantitati nenule de ierburi diferite\r\n* toate valorile date in fisierul de intrare se incadreaza in tipuri intregi pe $16$ biti\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. cowfood.in |_. cowfood.out |\r\n| 2 5 2\r\n1 3\r\n3 1\r\n| 4 |\r\n\r\nh3. Explicatii\r\n\r\nCele 4 amestecuri care mai pot fi incercate sunt $(1, 1), (1, 2), (2, 1), (2, 2)$.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cowfood\")==',13,'task: cowfood'),('problema/sum','Sum','2006-11-12 01:11:51','==Include(page=\"template/taskheader\" task_id=\"sum\")==\r\n\r\nh2. Cerinta\r\n\r\nRaspundeti la $N$ intrebari de tipul: care este suma numerelor $Y$ prime cu un numar {$X$}, si care respecta proprietatea $0$ &le; $Y$ &le; {$2*X$}.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare $sum.in$ contine un numar intreg {$N$}. Pe urmatoarele $N$ linii se afla cate un numar {$X$}.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $sum.out$ veti afisa $N$ linii, reprezentand, in ordine, raspunsurile pentru testele din fisierul de intrare.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1$ &le; $N$ &le; $100.000$\r\n* $2$ &le; $X$ &le; $100.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. sum.in |_. sum.out |\r\n|2\r\n5\r\n6\r\n| 40\r\n24 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sum\")==',13,'task: sum'),('problema/subsir','Subsir','2006-11-12 01:16:00','==Include(page=\"template/taskheader\" task_id=\"subsir\")==\r\n\r\nZaharel incearca s-o invete pe prietena lui Eugenia informatica. Astazi a invat-o programare dinamica si anume a inceput cu problema celui mai lung subsir comun: dandu-se doua siruri, sa se determine cel mai lung subsir comun al celor doua siruri. Un subsir al unui sir este format din caractere (nu neaparat consecutive) ale sirului respectiv, in ordinea in care acestea apar in sir.\r\n\r\nEugenia a inteles rezolvarea problemei dar i-a pus urmatoarea intrebare lui Zaharel: cate subsiruri comune de lungime maxima distincte exista pentru cele doua siruri? Doua subsiruri sunt distincte daca exista cel putin un caracter in unul din ele care difera de caracterul din celalat subsir de pe aceeasi pozitie.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Zaharel si determinati restul impartirii numarului de subsiruri comune de lungime maxima distincte pentru doua siruri date, la numarul $666013$.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare se gaseste primul sir, iar pe a doua linie cel de-al doilea sir.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului de iesire se va gasi numarul cerut.\r\n\r\nh2. Restrictii\r\n\r\n* fiecare sir are lungime mai mica sau egala cu $500$\r\n* sirurile contin doar litere mici ale alfabetului englez\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. subsir.in |_. subsir.out |\r\n| banana\r\noana\r\n| 1 |\r\n\r\nh3. Explicatii\r\n\r\nSigurul subsir comun de lungime maxima care se poate forma este @ana@.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"subsir\")==',13,'task: subsir'),('problema/poly','Poly','2006-11-12 01:14:43','==Include(page=\"template/taskheader\" task_id=\"poly\")==\r\n\r\n\r\nPoly, o fetita careia ii place matematica, a vazut urmatoarea multime: ${2, 3, 7, 11, 19, 23, 37}$. La un moment dat ea scrie pe o foaie $N$ numere intregi oarecare. Poly, vazand multimea gasita de ea si sirul de $N$ numere s-a intrebat care ar fi subsirul de lungime maxima, unde oricare doua elemente adiacente (din subsir) au cel mai mare divizor comun un numar care nu se divide cu nici un numar din multimea vazuta de ea: ${2, 3, 7, 11, 19, 23, 37}$. Chiar daca este talentata la matematica, si-a dat seama ca are nevoie de un program pe calculator.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se $N$, numarul de elemente ale sirului scris de ea si sirul propriu-zis, se cere lungimea subsirului maximal cu proprietatile de mai sus.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fiserului $poly.in$ se gaseste numarul $N$. A doua linie contine $N$ numere separate printr-un singur spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nFiserul $poly.out$ v-a contine un singur numar care reprezinta raspunsul.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 30000$\r\n* Numerele din sir sunt cuprinse intre $2$ si $10^8^$\r\n* Pentru $40%$ din teste, $N &le; 1000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. poly.in |_. poly.out |\r\n| 5\r\n2 2 3 4 5\r\n| 4 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"poly\")==',15,'task: poly'),('problema/expr','Expr','2006-11-12 01:18:54','==Include(page=\"template/taskheader\" task_id=\"Expr\")==\r\n\r\nAcarie, un student eminent, are probleme cu tema pentru seminarul de structuri algebrice. A redus problema la una simpla, de operatii cu multimi. Insa sunt prea multe operatii si deja e timpul sa iasa in oras. Ajutati-l sa iasa din incurcatura.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care gaseste rezultatul unei expresii valide date.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul $expr.in$ se da un sir de caractere fara spatii. Acest sir de caractere poate contine urmatoarele elemente:\r\n\r\n* operanzii - sunt multimi, descrise de o acolada ( {@{@} ) urmata de numerele care fac parte din multimea respectiva (in ordine crescatoare) despartite de virgula ( {@,@} ) si terminate cu alta acolada ( {@}@} )\r\n* operatorii - care pot fi paranteze, sau una din urmatoarele operatii (care au aceeasi prioritate):\r\n** {@*@} - intersectie\r\n** {@+@} - reuniune\r\n** {@-@} - diferenta\r\n** {@%@} - diferenta simetrica: {@A%B = (A-B)+(B-A) = (A+B) - (A*B)@}\r\n\r\nh2. Date de Iesire\r\n\r\nScrieti rezultatul expresiei in fisierul $expr.out$ ca o singura multime (dupa formatul multimilor din input).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Lungimea sirului &le; $100.000$\r\n* Numarul de valori distincte care apar in intreaga expresie &le; $8000$\r\n* $0$ &le; valorile care apar in multimi &le; $2.000.000.000$ (intregi)\r\n* Adancimea maxima de parantezare &le; $100$\r\n* Numarul maxim de operatii &le; $10.000$\r\n* Multimea vida este reprezentata prin {@{}@}\r\n* Numerele din multimea rezultata vor fi afisate in ordine crescatoare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. expr.in |_. expr.out |\r\n| {1,2,3,4}%({1,2,3,4}*{}+{1,2}+{5,6}-{1})\r\n| {1,3,4,5,6} |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"Expr\")==',1142,'task: expr'),('problema/gard2','Gard2','2006-11-12 12:19:29','==Include(page=\"template/taskheader\" task_id=\"gard2\")==\r\n\r\nDupa succesul avut la vopsirea primului gard, echipa de muncitori a fost angajata sa vopseasca gardul unuia dintre cei mai bogati oameni din oras. Fiind multumiti de suma oferita intregii echipe, muncitorii nu au mai facut prea multe mofturi de data aceasta. Ei s-au decis, insa, sa lucreze in ture: intai muncitorii din prima tura, apoi cei din a doua s.a.m.d. In cadrul fiecarei ture vor lucra *cel putin unul* si *cel mult $K$* muncitori. De asemenea, fiecare muncitor va lucra in *exact* o tura. Surprins de modul de organizare in ture a muncitorilor si fiind un iubitor al problemelor de numarare, proprietarul gardului doreste sa afle in cate moduri pot fi aranjati muncitorii in ture. Intrucat a anuntat ca va oferi o suma frumusica celui care ii va da raspunsul in mai putin de o secunda, ati decis sa scrieti un program care sa va ajute sa castigati premiul pus in joc.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care, pentru valorile $N$ si $K$ date, determina cate posibilitati de aranjare a celor $N$ muncitori in ture exista, astfel incat in fiecare tura sa lucreze cel putin unul si cel mult $K$ dintre ei.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $gard2.in$ se afla doi intregi: $N$ si {$K$}, reprezentand numarul total de muncitori si numarul maxim de muncitori ce pot lucra simultan (intr-o tura).\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $gard2.out$ veti afisa numarul determinat.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; K &le; N &le; 50$\r\n* Doua posibilitati de asezare sunt distincte daca exista cel putin un muncitor care lucreaza in ture cu numere de ordine diferite.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. gard2.in |_. gard2.out |\r\n| 3 2 | 12 |\r\n| 4 1 | 24 |\r\n| 5 3 | 530 |\r\n\r\n\r\nh3. Explicatie\r\n\r\nPentru primul exemplu, posibilitatile de aranjare in ture sunt:\r\n\r\n|_. Varianta 1 |_. Varianta 2 |_. Varianta 3 |_. Varianta 4 |_. Varianta 5 |_. Varianta 6 |\r\n| Tura1: *1 2*\r\nTura2: *3*\r\n| Tura1: *1 3*\r\nTura2: *2*\r\n| Tura1: *3 2*\r\nTura2: *1*\r\n| Tura1: *1*\r\nTura2: *2 3*\r\n| Tura1: *2*\r\nTura2: *3 1*\r\n| Tura1: *3*\r\nTura2: *1 2* |\r\n|_. Varianta 7 |_. Varianta 8 |_. Varianta 9 |_. Varianta 10 |_. Varianta 11 |_. Varianta 12 |\r\n| Tura1: *1*\r\nTura2: *2*\r\nTura3: *3*\r\n| Tura1: *1*\r\nTura2: *3*\r\nTura3: *2*\r\n| Tura1: *2*\r\nTura2: *1*\r\nTura3: *3*\r\n| Tura1: *2*\r\nTura2: *3*\r\nTura3: *1*\r\n| Tura1: *3*\r\nTura2: *1*\r\nTura3: *2*\r\n| Tura1: *3*\r\nTura2: *2*\r\nTura3: *1* |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"gard2\")==',961,'task: gard2'),('problema/java','Gandaci Java','2006-11-12 13:15:06','==Include(page=\"template/taskheader\" task_id=\"java\")==\r\n\r\n\r\nPe insula Java, se fac experimente crude pe unele dintre cele mai frumoase creaturi din lume, gandacii. $M$ cercetatori fac experimente pe $N$ gandaci. Din pacate, dupa ce au alcatuit un plan inteligent, toti gandacii au scapat din laborator si au fugit in parti diferite ale insulei. Cercetatorii trebuie sa aduca gandacii inapoi pentru a continua experimentele. Pentru a face asta, fiecare cercetator este trimis sa caute cel mult un gandac. Gandacii sunt numerotati cu numere de la $1$ la $N$. Cercetatori poarte ecusoane cu numere de la $1$ la $M$. Un cercetator poate cauta un gandac doar daca a facut vreodata un experiment pe acel gandac (altfel, nu ar putea sa-l recunoasca).\r\n\r\nCunoscandu-se experimentele care au avut loc inainte sa scape gandacii, sa se determine care este numarul maxim de gandaci care pot fi adusi inapoi in laborator dupa o cantitate finita de timp. Se stie ca, daca un cercetator este trimis in cautarea unui gandac, il va gasi intr-o cantitate finita de timp (pentru ca ar fi imposibil pentru un gandac Java sa fie mai destept decat un cercetator).\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie din fisierul $java.in$ contine numarul natural $T$, reprezentand numarul de teste. In continuare, se vor descrie cele $T$ teste. Prima linie a fiecarui test contine trei numere naturale: $M$, $N$ si $E$. $M$ este numarul de cercetatori, $N$ este numarul de gandaci si $E$ este numarul de experimente care au avut loc. Urmatoarele $E$ linii contin cate doua numere naturale $A$ si $B$, cu semnificatia ca cercetatorul $A$ a facut un experiment pe gandacul $B$. Un cercetator poate face mai multe experimente pe acelasi gandac.\r\n\r\nh2. Date de iesire\r\n\r\nPentru fiecare test afisati cate o linie in fisierul $java.out$ continand un numar natural: numarul maxim de gandaci care pot fi adusi inapoi la laborator dupa o cantitate finita de timp.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; T &le; 6$\r\n* $1 &le; N, M &le; 10.000$\r\n* $0 &le; E &le; 200.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. java.in |_. java.out |\r\n| 2\r\n4 5 2\r\n1 2\r\n1 2\r\n3 3 5\r\n1 1\r\n1 2\r\n2 2\r\n2 3\r\n3 3\r\n| 1\r\n3 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"java\")==',15,'task: java'),('problema/semne','Semne','2006-11-12 15:15:41','==Include(page=\"template/taskheader\" task_id=\"semne\")==\r\n\r\nIggel este un adolescent extraterestru cu probleme. Iar a facut o prostie la scoala si acum trebuie sa fie pedepsit. Din acest motiv, parintii lui au decis sa-l puna sa rezolve urmatoarea problema: Se dau $N$ numere naturale si un numar $S$ iar fiecare numar trebuie adunat sau scazut o singura data astfel incat sa se obtina suma $S$.\r\n\r\nh2. Cerinta\r\n\r\nAjuati-l pe Iggel sa scrie $N$ semne de $\'+\'$ si $\'-\'$ intr-un lan de porumb in functie de operatiile care trebuie efectuate cu numere $a{~i~}$ pentru a obtine suma $S$.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $semne.in$ contine doua numere intregi $N$ si $S$ cu semnificatia din enunt. Urmatoarea linie contine $N$ numere $a{~i~}$ ordonate crescator.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $semne.out$ se vor scrie $N$ caractere $\'+\'$ sau $\'-\'$, care reprezinta semnul fiecarul numar.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 50.000$\r\n* $1 &le; a{~i~} &le; 5.000.000$\r\n* Pentru $50%$ din teste $N &le; 500$ si $a{~i~} &le; 3.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. semne.in |_. semne.out |\r\n| 5 3 \r\n1 2 3 4 5 | @-+++-@ |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"semne\")==',1,'task: semne'),('problema/custi','Custi','2006-11-12 16:06:08','==Include(page=\"template/taskheader\" task_id=\"custi\")==\r\n\r\nDirectorul inchisorii a terminat cu refacerea gardului si acum lucreaza la proiectul \"Custilor de caini\", si l-a pus tot pe James Blond la partea cu calcule. Insa James se cam grabeste si nu va mai zice toata povestea cu cainii si cum trebuie sa fie custile, dar va trimis un email cu problema lui insa transformata in ceva mai simplu, partea din e-mail care contine exact problema arata cam asa: danduse o matrice patratica $NxN$ care contine numai $0$ si {$1$}, se cere determinarea numarului tuturor sub-matricelor $MxM$ ({$M &le; N$}) care contin numai elemente de {$1$}. Astfel pentru un anumit test trebuie sa afisati $N$ linii, astfel:\r\n\r\nLinia {$1$}: cate submatrici de $1x1$ cu proprietatea enuntzata exista\r\n...\r\nLinia {$i$}: cate submatrici de $ixi$ cu proprietatea enuntzata exista\r\n...\r\nLinia {$N$}: cate submatrici de $NxN$ cu proprietatea enuntzata exista\r\n\r\nh2. Date intrare\r\n\r\nIn fiserul $custi.in$ se gasesc:\r\n\r\n* pe prima linie numarul $N$\r\n* pe urmatoarele linii e data matricea cu elementele despartite printr-un spatiu(vezi exemplu) cate $N$ valori pe linie\r\n\r\nh2. Date iesire\r\n\r\nFiserul $custi.out$ are structura enuntata mai sus.\r\n\r\nh2. Restrictii si precizari:\r\n\r\n* $N<1001$\r\n* Pentru $20%-30%$ din teste $N<101$\r\n* Sub-matricile se pot suprapune intre ele.\r\n\r\nExemple:\r\n\r\ntable(example). |_. custi.in |_. custi.out |\r\n| 5\r\n1 1 1 0 0\r\n1 1 0 1 1\r\n1 1 1 1 1\r\n1 1 1 0 0\r\n1 1 1 0 0\r\n| 18\r\n7\r\n1\r\n0\r\n0 |\r\n\r\nh3. Explicatii\r\n\r\n$18$ submatrici de $1x1$\r\n$7$ submatrici $2x2$\r\n$1$ sumatrice $3x3$\r\n$0$ submatrici $4x4$ \r\n$0$ sumatrici $5x5$,  care contin numai elemente de $1$\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"custi\")==',15,'task: custi'),('problema/graf','Graf','2006-11-12 01:18:07','==Include(page=\"template/taskheader\" task_id=\"graf\")==\r\n\r\nSe stie ca intr-un graf neorientat conex, intre oricare doua varfuri exista cel putin un lant iar lungimea unui lant este egala cu numarul muchiilor care-l compun. Definim notiunea lant optim intre doua varfuri $X$ si $Y$ ca fiind un lant de lungime minima care are ca extremitati varfurile $X$ si $Y$. Este evident ca intre oricare doua varfuri ale unui graf conex vom avea unul sau mai multe lanturi optime, depinzand de configuratia grafului.\r\n\r\nh2. Cerinta\r\n\r\nFiind dat un graf neorientat conex cu $N$ varfuri etichetate cu numerele de ordine $1,2,...,N$ si doua varfuri ale sale notate $X$ si $Y$ $(1 &le; X,Y &le; N, X!=Y)$, se cere sa scrieti un program care determina varfurile care apartin tuturor lanturilor optime dintre $X$ si $Y$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $graf.in$ contine\r\n* pe prima linie patru numere naturale reprezentand: $N$ (numarul de varfuri ale grafului), $M$ (numarul de muchii), $X$ si $Y$ (cu semnificatia din enunt).\r\n* pe urmatoarele $M$ linii cate doua numere naturale nenule $A{~i~},B{~i~}$ ({$1 &le; A{~i~},B{~i~} &le; N, A{~i~} != B{~i~}$}, pentru $1 &le; i &le; M$) fiecare dintre aceste perechi de numere reprezentand cate o muchie din graf.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $graf.out$ va contine\r\n* pe prima linie, numarul de varfuri comune tuturor lanturilor optime dintre $X$ si $Y$;\r\n* pe a doua linie, numerele corespunzatoare etichetelor acestor varfuri, dispuse in ordine crescatoare; intre doua numere consecutive de pe aceasta linie se va afla cate un spatiu.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 7500; 1 &le; M &le; 14000$\r\n* pentru $50%$ din teste $N &le; 200$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. graf.in |_. graf.out |\r\n|  6 7 1 4\r\n1 2\r\n1 3\r\n1 6\r\n2 5\r\n3 5\r\n5 6\r\n5 4 |  3\r\n1 4 5 |\r\n| 3 2 1 3\r\n1 2\r\n3 1 |  2\r\n1 3 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"graf\")==',1,'task: graf'),('ciclu-hamiltonian-in-graf-dens','Ciclu hamiltonian in graf dens','2006-11-23 12:49:29','h1. Ciclu hamiltonian in graf dens\r\n\r\n(Categoria _Grafuri_, autor(i) _Crestez Leonard_)\r\n\r\nIn acest articol va voi prezenta un algoritm pentru gasirea unui ciclu hamiltonian intr-un graf neorientat dens - in care fiecare nod are macar $(N + 1) / 2$ muchii.\r\n\r\nIn general, gasirea unui ciclu hamiltonian intr-un graf neorientat este un exemplu clasic de problema NP - completa. Insa, daca graful este dens - fiecare nod are cel putin $(N+1) / 2$ muchii incidente ({$N$} este numarul de noduri) - se poate gasi o solutie de complexitate {$O(N^2^)$}.\r\n\r\nh2. Algoritm\r\n\r\nLa inceput formam un ciclu la intamplare, fara a tine cont daca muchiile luate in considerare chiar exista in graf. Astfel, putem alege chiar ciclul {$1, 2, 3, 4, ... N$}. Daca acest ciclu este valid, atunci avem noroc si solutia a fost gasita. Altfel, trebuie sa incercam sa \"umplem gaurile\" din ciclu (adica muchiile pe care le-am ales la intamplare si care nu exista in graf).\r\n\r\nGasim prima muchie de acest fel, fie ea ({$A, B$}). Cautam apoi doua alte noduri adiacente in ciclul nostru, notate cu $C$ si {$D$}, astfel incat sa avem muchie de la $A$ la $C$ si de la $B$ la {$D$}. Se poate demonstra ca vom gasi mereu $C$ si {$D$}. Acum vom \"incrucisa\" $A B$ cu {$C D$}. Prin \"incrucisare\" se intelege transfromarea unui ciclu $...AB...CD...$ in $...AC...BD...$ (sau $...CD...AB...$ in $...CA...DB...$) . Atentie, secventa de la $B$ la $C$ (respectiv de la $D$ la {$A$}) va fi inversata complet!\r\n\r\nSe observa ca a scazut numarul de \"gauri\" din sir, $AB$ a fost eliminata si nu au fost adaugate \"gauri\" noi. Repetam \"umplerea gaurilor\" pana nu mai avem ce umple, deci am gasit solutie.\r\n\r\nDesi suna complicat, \"umplerea unei gauri\" necesita doar $O(N)$ timp pentru cautarea nodurile {$AB$}, {$CD$}, si incrucisare. Avand in vedere ca sunt maxim $N$ gauri la inceput, algoritmul necesita $O(N^2^)$ ca timp de executie.\r\n\r\nMai sus am folosit o afirmatie fara a o demonstra. Demonstratia e relativ intuitiva. Daca nu o descoperiti singuri, puteti sa intrebati pe \"forum\":http://forum.infoarena.ro/.\r\n\r\nProblema luata in discutie este propusa pe lista \"sgu\":http://acm.sgu.ru/, nr. \"122\":http://acm.sgu.ru/problem.php?contest=0&problem=122, unde exista si evaluator online. Atentie la implementare! Citirea si scrierea folosind functii standard pot iesi din timp!\r\n\r\n',961,'public'),('stiri/rezultate-ioi-2004','Rezultate IOI 2004','2004-11-10 00:00:00','h1. Rezultate IOI 2004\r\n\r\n\"IOI 2004\":http://www.ioi2004.org/ - a 16-a editie a Olimpiadei Internationale de Informatica s-a desfasurat la Atena, Grecia, in perioada 11-18 septembrie.\r\n\r\nIn cadrul acestei competitii, lotul roman a fost insotit de:\r\n\r\n* Prof. Emanuela Cerchez\r\n* Prof. Ovidiu Domsa\r\n\r\nh2. Medalii\r\n\r\n* Ganceanu Silviu Ionut, aur\r\n* Crestez Dan-Leonard, argint\r\n* Vladu Adrian, argint\r\n* Stancu-Mara Sorin, bronz\r\n\r\nIi felicitam pe ei si pe toti cei ce s-au implicat si se implica in continuare in pregatirea lor.',1142,'protected'),('preoni-2006','preONI 2006','2006-11-27 16:13:49','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. preONI 2006\r\n\r\n*Editia 2006 a concursului preONI s-a incheiat cu succes la Focsani in perioada 24-26 martie!*\r\nFinala a fost ... \"Super. Super\", \"Super tare\", \"mda...a mers\" o spun concurentii. A fost grozav, intr-adevar, si ne-a facut mare placere sa va vedem prezenti intr-un numar atat de mare si veniti atat de departe. Va multumim pentru participare si speram ca ati petrecut un week-end pe cinste cu noi la Focsani. Toata echipa infoarena merita felicitata pentru organizarea si efortul depus de-a lungul campaniei. Inca odata multimim domnului profesor Onea pentru organizarea \"fara cusur\".\r\n\r\np={font-weight: bold}. \"Cronica\":preoni-2006/finala/cronica | \"Feedback\":preoni-2006/finala/feedback | \"Poze!\":preoni-2006/finala/poze\r\n\r\nh2. Noutati\r\n\r\nSponsorii finalei sunt:\r\n\r\n\"!preoni-2006?Oracle_ro.gif!\":http://www.oracle.com/global/ro/index.html\r\n\r\n\"Colegiul National Unirea, Focsani\":http://cnu.lufo.ro/\r\n\r\n*Hotel Unirea, Focsani*\r\n\r\nViziteaza \"Pagina rundei finale\":preoni-2006/finala.\r\n\r\nh2. preONI 2006 pe scurt\r\n\r\nConcursul este destinat elevilor de liceu ce se pregatesc pentru competitii de informatica (in special ONI).\r\n\r\npreONI 2006 este impartit pe 3 grupe (Clasa a 9-a si gimnaziu, Clasa a 10-a, Clasele 11-12), iar concurentii vor avea de rezolvat 3 probleme in 4 ore. Primele 4 runde online se vor desfasura in zile de sambata, incepand de la ora 09:00, iar in urma acestora cei mai buni de la fiecare grupa vor participa la o runda finala care se va desfasura intr-o \"tabara\":preoni-2006/finala, la sfarsit acordandu-se \"premii\":preoni-2006/premii. In continuare veti gasi un tabel cu datele provizorii ale rundelor: \r\n\r\n|_. Runda|_. Data|_. Pagina cu detalii|\r\n|#1|19 noiembrie 2005|\"Runda 1 preONI 2006\":preoni-2006/runda-1|\r\n|#2|17 decembrie 2005|\"Runda 2 preONI 2006\":preoni-2006/runda-2|\r\n|#3|21 ianuarie 2006|\"Runda 3 preONI 2006\":preoni-2006/runda-3|\r\n|#4|19 februarie 2006|\"Runda 4 preONI 2006\":preoni-2006/runda-4|\r\n|Finala|24 - 26 martie 2006|\"Runda finala (Focsani)\":preoni-2006/finala|\r\n\r\n\r\n==include(page=\"template/preoni-2006/footer\")==',13,'public'),('template/preoni-2006/footer','template/preoni-2006/footer','2006-11-27 16:13:42','h2. Sponsori\r\n\r\n\"!http://infoarena.ro/preoni-2006?action=download&file=Softwin.gif!\":http://www.softwin.ro/ \"!http://infoarena.ro/preoni-2006?action=download&file=microsoft.jpg!\":http://www.microsoft.com/romania/ \"!http://infoarena.ro/preoni-2006?action=download&file=Totalsoft.gif!\":http://www.totalsoft.ro/\r\n',13,'protected'),('stiri/rezultate-ceoi-2004','Rezultate CEOI 2004','2004-11-09 00:00:00','h1. Rezultate CEOI 2004\r\n\r\nCEOI 2004 s-a incheiat. Lotul olimpic roman a obtinut rezultate remarcabile aducand acasa nu mai putin de 4 medalii.\r\n\r\nRomania a fost reprezentata de:\r\n\r\n* Prof. insotitor Stelian Ciurea\r\n* Prof. insotitor Doru Anastasiu Popescu\r\n* Mircea Digulescu\r\n* Mosoi Alexandru\r\n* Dan-Constantin Spatarel\r\n* Stancu Mara Sorin\r\n\r\nh2. Medalii\r\n\r\n* Argint - Mosoi Alexandru\r\n* Argint - Spatarel Dan-Constantin\r\n* Bronz - Stancu Mara Sorin\r\n* Bronz - Digulescu Mircea',1142,'protected'),('stiri/rezultate-boi-2004','Rezultate BOI 2004','2004-11-08 00:00:00','h1. Rezultate BOI 2004\r\n\r\n\"BOI 2004\":http://www.boi2004-plovdiv.org/ - a 12-a editie a Olimpiadei Balcanice de Informatica s-a desfasurat in Plovdiv, Bulgaria, in perioada 3-9 iulie.\r\n\r\nIn cadrul acestei competitii, lotul roman a fost format din :\r\n\r\n* Prof. Marinel Serban\r\n* Prof. Daniel Popa\r\n* Adrian Vladu\r\n* Mircea Pasoi\r\n* Silviu Ganceanu\r\n* Marius Dumitran\r\n\r\nEchipa noastra a obtinut 3 medalii:\r\n\r\n* Pasoi Mircea, argint\r\n* Vladu Adrian, bronz\r\n* Ganceanu Silviu, bronz\r\n\r\nIi felicitam pe ei si pe toti cei ce s-au implicat si se implica in continuare in pregatirea lor.\r\n\r\n',1142,'protected'),('template/userstats','template/userstats','2006-12-08 04:29:55','h2. Statistici pentru %user%\r\n\r\nh3. Probleme rezolvate\r\n\r\n==SolvedTasks(user=\"%user%\")==\r\n\r\nh3. Probleme incercate\r\n\r\n==FailedTasks(user=\"%user%\")==\r\n\r\nh3. Participant la&hellip;\r\n\r\n==Rounds(user=\"%user%\")==',13,'protected'),('stiri/lansare-portal-info.devnet.ro','Lansare portal info.devNet!','2004-11-11 00:00:00','h1. Lansare portal info.devNet!\r\n\r\ninfo.devNet este un portal de informatica dedicat tuturor celor pasionati de acest domeniu. Portalul prezinta articole despre algoritmi, structuri de date, limbaje de programare, probleme si competitii de informatica, o lista comprehensiva de resurse web, downloads si sustine o comunitate activa formata, in special, din elevi si studenti, fosti sau actuali olimpici la informatica.\r\n\r\nScopul acestui portal este de a oferi elevilor si studentilor ce se pregatesc pentru competitii de informatica acces usor si rapid la materiale valoroase de pregatire, de a-i tine la curent cu ultimele noutati legate de acest domeniu si de a facilita comunicarea intre acestia.\r\n\r\nMaterialele prezente pe acest site sunt scrise 100% prin voluntariat de catre fosti sau actuali olimpici la informatica. Unii dintre ei au fost medaliati la competii internationale, altii au fost selectionati in lotul national de informatica sau au castigat locuri fruntase la ONI. Indiferent de autor, vom incerca sa verificam si sa imbunatatim constant articolele publicate. Incurajam din plin discutiile, comentariile si sugestiile pe marginea lor in cadrul \"forumului\":http://forum.infoarena.ro/.\r\n\r\nIi rugam pe cei care doresc sa contribuie la construirea acestui \"knowledge-base\" sa ne contacteze prin intermediul forumului!\r\n\r\n',1142,'protected'),('warm-up-2004/solutii','Solutiile oficiale pentru Concursul \"de incalzire\"','2006-11-22 02:11:06','h1. Solutiile oficiale pentru Concursul \"de incalzire\"\r\n\r\n(Categoria _Competitii_, autor(i) _Mircea Pasoi_)\r\n\r\nIn acest articol voi prezenta cateva idei de rezolvare pentru problemele din concursul \"de incalzire\" de la clasele 9-10 si 11-12.\r\n\r\nIncep prin a recunoaste faptul ca setul de probleme a fost unul foarte dur, comparabil cu unul de la nationale, chiar baraje. Pe viitor vom incerca sa facem concursurile mai gradate. Reversul medaliei este ca aveti acum probleme dure cu care sa va pregatiti si la care voi prezenta idei de solutie avand astfel ce invata! Nu voi incerca sa dau solutii foarte explicite, ci doar voi schita ideile de baza deoarece este important sa incercati sa intelegi si sa implementati singuri solutiile! ;)\r\n\r\nh2. Clasele 9-10\r\n\r\nh3. Coins\r\n\r\nPrimul fapt care trebuie observat este numarul destul de mic al starilor de joc si anume {$2^22^ = 4.194.304$}. Recomand \"cartea doamnei Cerchez\":http://www.liis.ro/%7eema/ despre arbori pentru a citi capitolul despre Arbori de Joc. Ideea principala este ca se exploreaza intregul arbore de joc format de starile tablei de $22$ de patralele si se retine intr-un vector boolean pentru fiecare configuratie daca jucatorul care incepe cu acea configuratie castiga sau nu. Astfel, se va raspunde la fiecare din cele $N$ teste in $O(1)$ dupa preprocesarea in $O(22 * 2^22^) = O(1)$ :).\r\n\r\nh3. Zaharel\r\n\r\nSolutia se bazeaza pe proprietatea foarte importanta (subliniata si in enunt) ca pe fiecare linie exista un punct rosu si pe fiecare coloana un punct albastru. Presupunem ca tinem o lista cu puncte. Initial bagam un punct rosu oarecare. Pe coloana punctului rosu respectiv exista un punct albastru (din proprietatea de mai sus). Inseram acel punct albastru in lista. Pe linia punctul albastru va exista un punct rosu , pe care il vom insera in lista. Repetand acest procedeu vom ajunge la un moment dat la un punct care a mai fost in lista ,deci la un ciclu (acest lucru este evident deoarece numarul punctelor este finit). Punctele rosii de pe ciclu vor reprezenta primul poligon, iar punctele albastre al doilea poligon. Este evident ca vor avea acelasi numar de varfuri, vom arata in continuare ca au si acelasi centru de greutate. Fie primul punct (acela rosu) ({$x{~1~}, y{~1~}$}). Al doilea va fi ({$x{~2~}, y{~1~}$}), al treilea ({$x{~2~}, y{~2~}$}), al patrulea ({$x{~3~}, y{~2~}$}) .. penultimul ({$x{~k~}, y{~k-1~}$}), ultimul ({$x{~k~}, y{~k~}$}) (care va coincide cu un alt punct ({$x{~p~}, y{~p~}$}), {$p < k$}). Se observa ca poligonul rosu va avea ca centru de greutate punctul ({$(x{~p~}&#0043;x{~p+1~}&#0043;...&#0043;x{~k-1~})/(k-p)$}, {$(y{~p~}&#0043;y{~p+1~}&#0043;...&#0043;y{~k-1~})/(k-p)$}), iar cel albastru {$(x{~p+1~}&#0043;x{~p+2~}&#0043;...&#0043;x{~k~})/(k-p)$}, {$(y{~p+1~}&#0043;y{~p+2~}&#0043;...&#0043;y{~k~})/(k-p)$}), care coincid deoarece ({$x{~p~},y{~p~}$}) = ({$x{~k~}, y{~k~}$}).\r\n\r\nh3. Sobo\r\n\r\nProblema se rezolva prin programare dinamica. Se retine in $A{~i~}$ = costul minim in cazul cel mai defavorabil pentru a recunoaste sobolanul inteligent din multimea de sobolani cu numerele de ordine pozitiile bitilor de $1$ in reprezentarea binara a lui {$i$}. Astfel, $A$ va avea valori pentru $i$ intre $0$ si {$2^N-1^$}. Raspunsul va fi {$A{~2^N-1^~}$}. Este evident ca graful format de aceste stari este aciclic deoarece fiecare raspuns imparte o multime in doua multimi mai mici. Astfel pentru a calcula un $A{~i~}$ vom lua fiecare raspuns care imparte in doua multimi nevide multimea curenta, vom vedea in care multime costul este mai mare (cazul cel mai defavorabil) , adaugam pretul raspunsului si actualizam in $A{~i~}$ daca valoarea aceasta este mai mica decat cea curenta (sa nu uitam ca vrem cost minim in cazul cel mai defavorabil). Cea mai simpla metoda de a implementa acest mecanism este cu memoizare. Complexitatea finala {$O(2^N^ * L * N)$}. Se poate optimiza la {$O(2^N^ * L)$} folosind operatii pe biti.\r\n\r\n\r\n\r\nh2. Clasele 11-12\r\n\r\nh3. Xor Max\r\n\r\nFie {$X{~i~} = A{~1~} xor A{~2~} xor ... xor A{~i~}$}. Pentru fiecare $X{~i~}$ vom incearca sa gasim un $X{~j~}$ ({$j < i$}) astfel incat $X{~i~} xor X{~j~}$ sa fie maxim. Pentru a realiza aceasta operatie eficient vom mentine un *trie* (vezi in CLR varianta in romana la pagina 223 - capitolul \"Arbori binari de cautare\" problema 13-2 - se asemana cu \"suffix trees/tries\" doar ca vom lucra cu siruri binare). Fie $b$ numarul maxim de biti pe care ii are un element din vector. Vom realiza operatia de gasire a lui $X{~j~}$ in {$O(b)$}. Structura de date mentionata mai sus va memora sirurile de biti formate de vectorul {$X$}. Vom parcurge bitii lui $X{~i~}$ de la cel mai semnificativ la cel mai nesemnificativ. Astfel daca bitul curent este {$1$}, vom incerca sa gasim un sir de biti care are acest bit $0$ (pentru a maxima xor-ul), iar daca bitul curent este $0$ vom proceda invers. Complexitatea finala a algoritmului este {$O(N*b)$}.\r\n\r\nh3. Boom\r\n\r\nVom construi un graf din cele $2^N^$ stari posibile. Prin stare intelegem un numar binar in care bitii de $1$ reprezinta locurile in care s-ar putea afla sobolanul. Pentru fiecare astfel de nod, exista $M$ muchii la alte noduri, care se obtin aplicand bomba asupra pozitiilor si avansarea pozitiilor ramase. Deoarece muchiile au costuri numere naturale, iar graful nu este neaparat aciclic vom aplica algoritmul Dijkstra, pentru a determina drumul de cost minim de la nodul $2^N-1^$ la nodul {$0$}. Pentru a se incadra in timp era necesara implementarea cozii de prioritate cu heap-uri. Complexitate finala {$O(2^N^ * N * M)$}.\r\n\r\nh3. PetSoft\r\n\r\nIn fiecare nod din arbore vom retine doua valori $A{~i, 0~}$ = costul minim pentru a cupla subarborele cu radacina in {$i$}, fara a cupla nodul $i$ cu cineva, si $A{~i, 1~}$ acelasi lucru, dar cupland nodul $i$ cu cineva. Pentru a calcula aceste valori in fiecare nod, luam numerele de ordine a fiilor, le sortam si aplicam o alta dinamica pentru a obtine echipe cu cost maxim. Astfel determinam {$A{~i, 0~}$}. Pentru a calcula {$A{~i, 1~}$}, inseram si nodul $i$ in lista fiilor, sortam din nou si aplicam aceeasi dinamica (atentie la detalii de implementare!). Dinamica se face astfel: retinem in $C{~i, j~}$ = costul maxim pentru a forma echipe de cost maxim cu valorile de pe pozitiile {$i, i+1 ... j-1, j$}. Este evident ca $C{~i, j~}$ se obtine din {$C{~i+1, j~}$}, $C{~i, j-1~}$ si {$C{~i+1, j-1~}$}. Complexitatea finala este {$O(N^2^)$}.\r\n\r\n',1,'public'),('algoritmul-lui-euclid','Algoritmul lui Euclid','2006-11-22 02:11:28','h1. Algoritmul lui Euclid\r\n\r\n(Categoria _Teoria numerelor_, autor(i) _Crestez Leonard_)\r\n\r\nO prezentare a variantei extinse a algoritmului lui Euclid, care rezolva ecuatie de forma {$A * X + B * Y = D$}, unde $D$ este cel mai mare divizor comun al lui $A$ si {$B$}. De asemenea este prezentata o aplicatie \"interesanta\": impartirea modulara.\r\n\r\nProbabil ca multi stiti algoritmul lui Euclid de prin clasa a 5-a, cand invatati la matematica divizibilitate. Varianta simplista a algoritmului lui Euclid este cunoscuta de multa lume, dar fara prea multe explicatii despre functionarea lui.\r\n\r\nh2. Euclid simplu\r\n\r\nIn cuvinte, algoritmul pur si simplu impare deimpartitul la rest pana cand impartitorul este {$0$}, apoi returneaza deimpartitul. Poate fi usor implementat iterativ in C. Probabil ca aceasta forma este si cea mai rapida, si este de preferat cand nu e necesar Euclid extins.\r\n\r\n== code(c) | int euclid(int a, int b)\r\n{\r\n    int c;\r\n    while (b) {\r\n        c = a % b;\r\n        a = b;\r\n        b = c;\r\n    }\r\n    return a;\r\n}\r\n==\r\n\r\nPentru a fi inteles mai usor si eventual extins, este mai bine sa il punem sub forma recursiva\r\n\r\n== code(c) | void euclid(int a, int b, int *d)\r\n{\r\n    if (b == 0) {\r\n        *d = a;\r\n    } else\r\n        euclid(b, a % b, d);\r\n}\r\n==\r\n\r\nSa vedem cum functioneaza algoritmul lui Euclid. Se observa ca daca {$a<b$}, atunci $euclid(b, a % b)$ este de fapt {$euclid(b, a)$}.\r\n\r\nVom demonstra ca {$cmmdc(a, b) = cmmdc(b, a % b)$}. Notam $cmmdc(a, b)$ cu {$d$}. Scriem $a%b$ drept {$a - b * c$}, unde $c$ este parte intreaga din {$a / b$}. Cum $a$ si $b$ sunt divizibile cu {$b$}, atunci orice combinatie liniara a lor este divizibila cu {$d$}, inclusiv {$a - b * c = a %b$}.\r\nAsta insa nu este de ajuns, putem aveam {$Z > d$}, $Z$ divizibil cu {$d$}, care sa fie {$cmmdc(b, a % b)$}. Insa atunci ar rezulta similar ca a e divizibil cu {$Z$}, deci {$Z = d = cmmdc(a, b)$}, Incalcand {$Z > d$}.\r\n\r\nAstfel, algoritmul lucreaza reducand problema la numere din ce in ce mai mici, pana cand {$a % b = 0$}. Ca sa finalizam recurenta, daca $a$ este divizibil cu {$b$}, atunci este evident ca {$cmmdc(a, b)$} este {$b$}. In cod este un pic mai \"ciudat\", prindem acest caz doar dupa inca un apel recurent, cand {$b = 0$}. De fapt cred ca $cmmdc$ este definit pe numere strict pozitive, dar in informatica putem ocoli un pic matematica.\r\n\r\nh2. Euclid extins\r\n\r\nAcest algoritm poate fi extins, in sensul gasirii $x$ si $y$ astfel incat {$a * x + b * y = d$}. In acest articol vom incerca sa deducem modul de calculare al lui $x$ si {$y$}. Cei grabiti sau certati cu matematica pot sari direct la codul sursa, dar vor avea probleme in a tine minte algoritmul pe viitor.\r\n\r\nVom extinde procedura recursiva de calculare a $cmmdc$ pentru e include si $x$ si {$y$}. Calculam $x$ si $y$ incepand de la \"capatul recurentei\". Daca {$b = 0$}, atunci $a * 1 + b * 0 = a(cmmdc)$ evident, asa ca initial $x = 1$ si {$y = 0$}. Incercam sa calculam {$x$}, $y$ in functie de {$x0$}, $y0$ obtinuti pentru {$b$}, {$a % b$}. Noi stim urmatoarele:\r\n\r\n* $b * x0 + (a % b) * y0 = d$\r\n* $a * x + b * y = d$\r\n\r\nTrebuie sa aflam o solutie pentru $x$ si {$y$}. Vom nota ca mai sus parte intreaga din $a / b$ cu {$c$}.\r\n\r\n* $b * x0 + (a - b * c) * y0 = a * x + b * y$\r\n* $b * (x0 - c * y0 - y) = a * (x - y0)$\r\n\r\nO solutie este acum evidenta (Una, sunt o infinitate de perechi {$x, y$})\r\n\r\n* {$x0 - c * y0 - y = 0$}, De unde rezulta $y = x0 - c * y0$\r\n* {$x - y0 = 0$}, De unde rezulta $x = y0$\r\n\r\nAcum nu mai pare asa de \"magic\", nu?\r\n\r\nSursa modificata pentru a calcula si $x$ si $y$ nu este mult mai complexa. Acum intelegeti de ce am trimis $d$ ca pointer mai sus, si de ce am folosit varianta recursiva a algoritmului lui euclid. Implementat iterativ, este nevoie de un vector care sa tina toate valorile $c$ ({$a / b$}) obtinute pe parcurs.\r\n\r\nNota pentru pascalisti: in C nu exista div, impartirea intre int-uri este automat si impartire intreaga (div din pascal).\r\n\r\n== code(c) | void euclid(int a, int b, int *d, int *x, int *y)\r\n{\r\n    if (b == 0) {\r\n        *d = a;\r\n        *x = 1;\r\n        *y = 0;\r\n    } else {\r\n        int x0, y0;\r\n        euclid(b, a % b, d, &x0, &y0);\r\n        *x = y0;\r\n        *y = x0 - (a / b) * y0;\r\n    }\r\n}\r\n==\r\n\r\nh2. Impartire modulara\r\n\r\nAcum pentru o aplicatie interesanta, impartirea modulara. Nu voi intra in detalii, pe scurt aritmetica modulara este aritmetica in care toate valorile se iau modulo un anumit numar {$n$}. Spre exemplu, in {@modulo 7@}, {$3 = 10$}. Similar, rezultatele tuturor operatiilor se iau in modul: {$4 + 5 = 2$}, {$3 * 5 = 1$}, etc.\r\n\r\nCum putem defini insa impartirea in modulo? Evident, {$6 / 2$} este tot {$3$}, dar $3 / 4$ cu cat este egal? De obicei impartirea este definita ca operatia inversa a inmultirii, similar cum scaderea este operatia inversa a adunarii. Astfel, daca {$a / b = c$} atunci {$b * c = a$}. Prin algoritmul lui Euclid putem afla $x$ si $y$ astfel incat {$n * x + b * y = cmmdc(n, b)$}, unde $n$ este modulul. Totul e modulo {$n$}, asa ca putem ignora {$x * n$}. Atunci {$c = y * a / cmmdc(n, b)$}. Daca $a$ nu este divizibil cu {$cmmdc(n, b)$}, atunci $c$ nu exista. Intradevar, nu exista $c$ pentru care $3 * c = 4$ modulo {$6$}.\r\n\r\nh2. Tema pentru acasa\r\n\r\nCateva probleme care se rezolva intr-un mod sau altul folosing algoritmul lui Euclid sau algoritmul lui Euclid extins:\r\n\r\n* Sgu 106: \"The Equation\":http://acm.sgu.ru/problem.php?contest=0&problem=106\r\n* Sgu 137: \"Funny Strings\":http://acm.sgu.ru/problem.php?contest=0&problem=137\r\n* Sgu 141: \"Jumping Joe\":http://acm.sgu.ru/problem.php?contest=0&problem=141\r\n* Sgu 248: \"Integer Linear Programming\":http://acm.sgu.ru/problem.php?contest=0&problem=248\r\n\r\n',1,'public'),('automate-finite-si-kmp','Automate finite si KMP','2006-11-23 21:49:31','h1. Automate finite si KMP\r\n\r\n(Categoria _Automate_, autor(i) _Vladu Adrian_)\r\n\r\nIn acest articol vom aborda cele mai comune probleme legate de pattern matching si vom oferi suportul teoretic necesar intelegerii algoritmului Knuth-Morris-Pratt, pornind de la potrivirea standard cu automate finite si rafinand-o treptat pana la un algoritm de complexitate {$O(n + m)$}. Toate acestea intr-o maniera usor de inteles ;)\r\n\r\nh2. Automate finite\r\n\r\nh3. Ce sunt automatele finite ?\r\n\r\nUn automat finit este definit ca un cvintuplu {@<@}{$Q, q{~0~}, A, &#0931;, &#0948;$}{@>@} unde $Q$ este o multime finita de stari {$Q = {q{~0~}, q{~1~}, ... q{~n~}}$}, $q{~0~}$ apartine $Q$ ({$q{~0~}$} = stare initiala), $A$ inclus in $Q$ ({$A$} = multimea starilor de acceptare), $&#0931;$ este un alfabet, iar functia {$&#0948; : Q x S -> Q$}.\r\n\r\nAceasta este definitia matematica si foarte abstractizata a automatelor. Pentru a le intelege mai usor, sa luam un exemplu concret\r\n\r\n!Automate-finite-si-KMP?dfa.jpg!\r\n\r\n* $Q = {q{~0~}, q{~1~}, q{~2~}, q{~3~}}$\r\n* $A = {q{~3~}}$\r\n* $&#0931; = {a, b}$\r\n* &#0948; = \r\n\r\ntable. | &#0948; | a | b |\r\n| 0&nbsp; | 1 | 2 |\r\n| 1 | 3 | 1 |\r\n| 2 | 3 | 0&nbsp; |\r\n| 3 | 3 | 3 |\r\n\r\n\r\nCe inseamna asta? Sa spunem ca automatul primeste un string $s$ = *bbaba*\r\nInitial ne aflam in {$q{~0~}$}. Pentru fiecare element al stringului $s{~i~}$ facem tranzitia {$&#0948;(q{~k~}, s{~i~})$}.\r\n\r\nPornim din {$k = 0$}. Vom avea :\r\n\r\n* $k = 0; &#0948;(0, b) = 2;$\r\n* $k = 2; &#0948;(2, b) = 0;$\r\n* $k = 0; &#0948;(0, a) = 1;$\r\n* $k = 1; &#0948;(1, b) = 1;$\r\n* $k = 2; &#0948;(1, a) = 3;$\r\n\r\nDaca ultima stare obtinuta $q{~k~}$ apartine {$A$}, atunci spunem ca automatul accepta stringul. Altfel spus, daca avem stringul {$s$}, {$lungime(s) = n$}, automatul accepta stringul daca si numai daca $&#0948;( ... &#0948;( &#0948;(0, s{~1~}), s{~2~} ) ..., s{~n~} )$ apartine {$A$}.\r\n\r\nStringurile \'{$aa$}\', \'{$aaaaaaa$}\', \'{$aabababab$}\', \'{$aaaba$}\', \'{$ba$}\', \'{$aba$}\' sunt acceptate de automat, dar \'{$ba$}\', \'{$abbbbbb$}\', \'{$bba$}\' nu.\r\n\r\nh3. La ce folosesc ?\r\n\r\n# Inteligenta artificiala (prima si cea mai involuata stare a inteligentei artificiale)\r\n# Aplicatii teoretice si probleme de matematica :)\r\n# Pattern matching\r\n\r\nSe dau stringurile $M$ si {$N$}. Se cere sa gasim toate aparitiile lui $N$ in {$M$}.\r\nVom numi {$M{~i~}$} prefixul lui $M$ de lungime {$i$}. Presupunand ca avem construit automatul care accepta stringul {$N$}, vom cauta toate prefixele lui $M$ acceptate de automat, deci toate numerele $1 &le; i &le; lungime(M)$ cu proprietatea ca automatul accepta stringul {$M{~i~}$}.\r\n\r\nh3. Algoritm_potrivire_cu_automat_finit\r\n\r\n== code(c) | \r\nn = lungime(N)\r\nq = 0;\r\npt i <- 1, n\r\n    q = d(q, M[i])\r\n    daca q apartine A\r\n        scrie \"potrivire la pozitia \" i - n + 1\r\n==\r\n\r\n* Complexitate : $O(n)$\r\n\r\nSa vedem cum se construieste automatul de potrivire pentru un string {$N$}. Fie {$m = lungime(M)$}. Construim un automat cu $m + 1$ stari {{$q{~0~}, q{~1~}, ... q{~m~}$}}, $A = {q{~m~}}$ . Faptul ca ne aflam in starea $x$ inseamna ca au fost acceptate primele $x$ caractere din sirul de intrare.\r\nDin fiecare stare $q{~x~}$ apartine $Q$ si pt fiecare $c$ apartine $S$ construim $&#0948;(x, c) = y$ cu proprietatea ca $M{~y~}$ este cel mai lung prefix al lui $M$ care este sufix al lui $M{~x~}c$ (prefixul de lungime $x$ al lui {$M$}, concatenat cu caracterul {$c$}).\r\n\r\n\r\n\r\nh3. Algoritm_constructie_automat_finit\r\n\r\n== code(c) |\r\nm <- lungime(M)\r\npt q <- 0, m\r\n    pt c apartine S\r\n        gaseste M[i] = cel mai lung prefix al lui M cu M[i] sufix al lui M[q]c\r\n            d(q, c) = i\r\n==\r\n\r\n* Complexitate : linia $4$ are complexitatea $O(m^2^)$ (implementata in maniera bruta) si se executa de $(m + 1) * |&#0931;|$ ori => complexitate totala $O(m^3^ * |&#0931;|)$\r\n\r\nPractic, algoritmul calculeaza pentru toate {$0 &le; i &le; m$}, $c$ apartine $S$ cat de mult putem lua de la sfarsitul lui $M{~i~}c$ astfel incat acesta sa fie un \"inceput\" de {$N$}.\r\n\r\nAcesta se poate rafina, eliminand operatii redundante, dupa cum vom vedea in cele ce urmeaza.\r\n\r\nh2. Algoritmul KMP\r\n\r\nGaseste toate aparitiile un string $N$ in $M$ in timp {$O(n + m)$}, unde {$n = lungime(N)$}, {$m = lungime(M)$}. O parte esentiala a sa este functia prefix $&#0928; : {1..n} -> {0..n-1}$ unde $&#0928;{~i~}$ = cel mai lung prefix al lui $M$ care este sufix al lui {$M{~i~}$}. Evident, M{~&#0928;{~i~}~} (prefixul de lungime &#0928;{~i~} al lui {$M$}) prefix al lui {$M{~i~}$}, deci {$&#0928;{~i~} < i$}.\r\n\r\nh3. Algoritm_calcul_functie_prefix\r\n\r\n== code(c) |\r\nn <- lungime(N)\r\nk <- 0\r\npi[1] <- 0\r\npt i <- 2, n\r\n    cat timp (k > 0) si (N[k + 1] ** N[i])\r\n        k <- pi[k]\r\n    daca N[k + 1] = N[i]\r\n        k <- k + 1\r\n    pi[i] <- k\r\n==\r\n\r\nh4.  Analiza complexitatii :\r\n\r\n* la fiecare pas ({$i = 2, n$}) $k$ se incrementeaza cel mult o data, deci pe parcursul algoritmului $k$ se va incrementa de cel mult $n - 1$ ori (linia {$8$})\r\n* in linia {$5$}, $k$ se decrementeaza cel mult pana devine {$0$}, deci se va decrementa de cel\r\nmult $n - 1$ ori pe parcursul algoritmului\r\n* => Complexitate : $O(n)$\r\n\r\nAlgoritmul este similar cu constructia automatului de acceptare. Din fiecare stare $i$ in care s-a acceptat {$N{~i~}$}, vedem cat de mult putem lua de la sfarsitul lui {$N{~i~}$} astfel incat sufixul respectiv sa fie prefix pentru {$N$}. De remarcat ca in cazul in care starea candidata $k$ nu este buna, nu mergem in {$k - 1$}, ci in {$&#0928;{~k~}$}. Aceasta este de fapt \"magia\" care ofera complexitate liniara.\r\n\r\nAlgoritmul de potrivire este similar celui al calculului functiei prefix, numai ca aici la fiecare pas $i$ cautam cel mai lung prefix al lui $N$ care este sufix al lui {$M{~i~}$}.\r\n\r\n\r\n\r\nh3. Algoritm_potrivire_KMP\r\n\r\n== code(c) |\r\nm <- lungime(M), n <- lungime(N)\r\nq <- 0\r\npt i <- 1, m\r\n    cat timp (q > 0) si (N[q + 1] != M[i])\r\n        q <- pi[q]\r\n    daca N[q + 1] = M[i]\r\n        q <- q + 1\r\n    daca q = n\r\n        scrie \"potrivire la pozitia \" i - n + 1\r\n==\r\n\r\nAnalog Algoritm_Calcul_Functie_Prefix, complexitatea algoritmului efectiv de potrivire este {$O(m)$}. Astfel rezulta complexitatea liniara a algoritmului KMP $O(n + m)$\r\n\r\nh2. Teme pentru acasa:\r\n\r\n* folosind functia prefix, rafinati constructia automatului finit de acceptare pt un string, aducand-o la complexitatea $O(m^2^ * |&#0931;|)$\r\n* problema \"Microvirus\":http://www.liis.ro/%7ecampion/problems/2/64/microvirus.htm (hint : construiti automatul de potrivire pentru stringul dat)\r\n* Timus 1158: \"Censored!\":http://acm.timus.ru/problem.aspx?space=1&num=1158\r\n\r\n',961,'public'),('agora-finala/solutii','Concursul Agora - Etapa Finala - Solutii','2006-11-22 02:16:02','h1. Concursul Agora - Etapa Finala - Solutii\r\n\r\n(Categoria _Competitii_, autor(i) _Cosmin_)\r\n\r\nArticolul contine cateva idei de solutionare a problemelor de la etapa finala a concursului Agora. Concursul s-a desfasurat la Cluj in 9 iulie pentru concurentii ce s-au calificat in finala, dar s-a desfasurat si online pentru cei care doreau sa isi incerce puterile.\r\n\r\nh2. Problema 1: Drumuri\r\n\r\nProblema cerea determinarea unei partitionari a muchiilor dintr-un graf conex in perechi disjuncte astfel ca in fiecare pereche de muchii cele doua muchii sa aiba un capat comun. Pentru orice graf conex cu numar par de muchii exista o asemenea partitionare a muchiilor. Algoritmul ce solutioneaza problema ne demonstreaza acest lucru. Putem determina pentru graful nostru un arbore partial (arbore DFS sau BFS sau care mai vreti voi). Putem lua o frunza din arborele nostru, daca ea are grad par atunci o putem elimina din arbore si toate muchiile ce aveau un capat in ea sa le imperechem doua cate doua. Daca in schimb frunza are grad impar atunci eliminam toate muchiile mai putin cea din arbore si eliminam nodul virtual din graf, dar nu si muchia asociata care devine o muchie oarecare si va putea fi eliminata cand procesam tata frunzei actuale. Singura problema ce poate aparea este cand ajungem la radacina, dar cum dintr-un graf cu numar par de muchii am eliminat la fiecare pas un numar par de muchii inseamna\r\nca radacina are grad par, deci problema noastra este rezolvata. Complexitatea algoritmului este $O(N + M)$ si ca timp si ca memorie, acest algoritm poate fi foarte usor implementat ca o parcurgere DFS care dupa ce viziteaza un nod si fii sai il elimina din graf.\r\n\r\nh2. Problema 2: Colectie\r\n\r\nProblema se imparte in doua bucati: Prima este determinarea numarului de cifre $i$ care apar in scrierea numerelor de la $1$ la $K$ unde $i$ este intre $0$ si {$9$}. Aceasta problema se poate rezolva in $O(log K)$ cu programare dinamica, o rezolvare eficienta a fost ceruta la bacalaureat in anul 2001 deci nu e asa grea :) , o rezolvare care lua putin timp ar fi fost metoda constantelor, adica putem tine minte din $100.000$ in $100.000$ rezultatele partiale (aceasta abordare a fost luata de Patcas Csaba la etapa finala).\r\nAcum avem de rezolvat o problema de obtinere a unui vector dimensiune $10$ ca suma unei submultimi de vectori dati la intrare. Aceasta problema o putem rezolva cu o tehnica intalnita pe la concursuri de programare, dar care nu a devenit inca clasica. Impartim multimea de vector in doua multimi de dimensiuni $n / 2$ si {$n - n /2$}. Pentru prima multime determinam toate submultimile si sumele vectoriale asociate acelor submultimi, si sortam submultimile dupa acele sume. Acum pentru fiecare submultime de vectori din a doua multime obtinem o suma vectoriala {$sum$}, noi vrem sa mai adaugam ceva elemente la aceasta suma pentru a obtine un vector $target$ ce reprezinta pentru fiecare cifra numarul de etichete necesare pentru a eticheta toate numerele de la $1$ la {$K$}. Deci vom cauta binar in primul sir vectorul {$target - sum$}. Faza de sortare dureaza $O(n^2^ * 2^n^)$ si faza de cautare binara tot atat.Astfel rezolvare are complexitatea $O(2^n^ * n^2^ + log K)$ ca timp si $O(2^n^ * n)$ ca spatiu.\r\n\r\nh2. Problema 3: Heroes of Might and Magic\r\n\r\nProblema cerea determinarea numarului de drumuri de la un punct ({$start_x, start_y$}) dintr-o matrice pana la un punct ({$end_x, end_y$}) din aceiasi matrice, drum care sa aiba cel mult $K$ pasi. Problema se rezolva usor folosind metoda programarii dinamice. Vom folosi o matrice tridimensionala unde $num_ways{~i,j,k~}$ are semnificatia: numarul de drumuri ce incep in ({$start_x, start_y$}), se termina in ({$i, j$}) si au fix $k$ pasi. Solutia se va afla in {$num_ways{~end_x,end_y,0~} &#0043; num_ways{~end_x,end_y,1~} &#0043; ... &#0043; num_ways{~end_x,end_y,K~}$}. Formula de recurenta pentru problema este usor de determinat:\r\n{$num_ways{~i,j,k~} = num_ways{~i+1,j,k-1~} &#0043; num_ways{~i-1,j,k-1~} &#0043; num_ways{~i,j-1,k-1~} &#0043; num_ways{~i,j+1,k-1~}$}. Se observa ca pentru a determina valorile corespunzatoare lui $k$ avem nevoie doar de valorile corespunzatoare lui {$k - 1$}, deci putem folosi doua matrici bidimensionale in loc de una tridimensionala. Complexitatea solutiei ca si timp este $O(N * M * K)$ iar ca si spatiu este {$O(N * M)$}.\r\n\r\n',1,'public'),('al-k-lea-drum-minim','Al K-lea drum minim','2007-01-14 13:22:36','h1. Al K-lea drum minim\r\n\r\n(Categoria _Grafuri_, autor(i) _Crestez Leonard_)\r\n\r\nExista un numar mare de algoritmi pentru a calcula cel mai scurt drum intre $2$ noduri intr-un graf, dar chiar si al {$2$}-lea cel mai scurt drum este o extindere non-triviala. Pentru a afla al {$k$}-lea drum minim se foloseste un algoritm total diferit fata de cei pentru drum minim. Algoritmul este dificil de implementat, iar sursa rezultata este de obicei voluminoasa, asa ca acest algoritm nu prea intervine in problemele de concurs. Am considerat totusi ca este destul de interesant, si merita prezentat.\r\n\r\nO nota importanta este ca nu se determina drumul cu al {$k$}-lea cost. Doua drumuri se considera diferita daca au noduri diferite, nu neaparat si cost diferit. Astfel, daca exista $5$ drumuri distincte de cost minim, oricare dintre ele poate fi solutie pentru al {$4$}-lea sau al {$5$}-lea drum minim. Astfel, aceasta problema are de fapt mai multe solutii posibile.\r\n\r\nExista $2$ cazuri pentru aceasta problema, iar algoritmul prezentat necesita mici modificari pentru a se adapta, dar ideea de baza ramane aceeasi. Cele doua cazuri sunt daca drumul trebuie neaparat sa fie elementar sau nu. Cazul in care se accepta doar drumuri elementare este mai restrictiv, si, astfel, un pic mai dificil.\r\n\r\nh2. Mod de functionare\r\n\r\nDaca pentru drumul minim intre $2$ noduri de obicei se calculeaza drumul minim dintre primul nod si celelalte noduri din graf, pentru a afla al {$k$}-lea drum minim se calculeaza toate primele $k - 1$ drumuri minime, in ordine. Un pas al algortimului consta in aflarea celul de-al {$k$}-lea drum minim cand primele $k$ sunt cunoscute. Drumul minim este folosit de mai multe ori in algoritm, pentru a intelege acest algoritm este necesara o anumita familiaritate cu algoritmul lui Dijkstra.\r\n\r\nDrumurile minime pana la $k-1$ sunt stocate compactate intr-un arbore de drumuri. Fiecarui nod din acel arbore ii corespunde un nod din graf, dar nu si invers, un nod din graf poate aparea de mai multe ori in arbore. Radacina arborelui corespunde nodului de start, iar toate frunzele arborelui corespund nodului de final, iar drumurile de la radacina catre frunze reprezinta fiecare cate un drum minim. Vezi in figura cum se compacteaza drumurile ({$1, 7, 4, 5$}), ({$1, 7, 3, 5$}), ({$1, 2, 4, 5$}) si ({$1, 2, 6, 4, 5$}). Drumurile sunt primele $4$ drumuri din graful desenat mai sus si luat drept exemplu.\r\n\r\n!Al-K-lea-drum-minim?kshortest_graph.png!\r\n!Al-K-lea-drum-minim?kshortest_tree.png!\r\n\r\nAl {$k$}-lea drum minim trebuie sa corespund pana intr-un anumit punct cu un drum aflat deja in arbore, chiar daca punctul acela este de fapt nodul de start. Pentru a gasi urmatorul drum minim, incercam sa \"deviem\" din fiecare nod din arbore. Un drum de deviatie pentru un anume nod $X$ este un drum identic cu drumul de la radacina pana la nodul {$X$}, care apoi continua (deviaza) pe cel mai scurt drum pana la destinatie care nu a fost inca luat in cosiderare. Spre exemplu pentru nodul $4$ din drumul ({$1, 2, 4, 5$}) putem sa deviem din $4$ prin ({$7, 3, 5$}), formand drumul ({$1, 2, 4, 7, 3, 5$}). Este intuitiv ca, la fiecare pas, pentru fiecare nod din arbore este interesant doar cel mai scurt drum de deviatie.\r\n\r\nAlgoritmul mentine o multime, eventual ca un heap, de deviatii. Se tine pentru fiecare drum de deviatie nodul din care deviaza si lungimea drumului. La fiecare pas extragem drumul de deviatie minim si reconstituim drumul. Sa zicem ca drumul scos din heap este ({$a{~1~} a{~2~} ... a{~d~}, a{~d+1~} ... a{~n~}$}), unde $a{~d~}$ este nodul de unde s-a facut deviatia. Introducem acest drum in arborele de drumuri, si pentru fiecare nod de la $a{~d~}$ la $a{~n-1~}$ calculam deviatia minima si o introducem in heap. Pentru restul nodurilor este evident ca deviatia minima nu se modifica.\r\n\r\nAlgoritmul odata inteles este relativ logic. Al {$k$}-lea drum minim trebuie sa coincida cu unul dintre cele $k-1$ drumuri deja existente pana intr-un anumit punct, dupa care \"ia un viraj\" nevizitat si continua cel mai scurt drumul inca neparcurs.\r\n\r\nDupa cum am zis mai sus, algoritmul are $2$ variante, daca este necesar ca drumurile sa fie elementare sau nu. Pentru cele $2$ variante se modifica modul in care se calculeaza deviatia minima dintr-un nod. Cazul cel mai simplu este atunci cand nu este necesar ca drumurile sa fie elementare. Pentru nodul $X$ din care trebuie sa deviem, vom lua cel mai scurt drum care inca nu este in arbore. Putem sa calculam de dinainte un arbore de drumuri inversat, de la toate nodurile la destinatie, si sa luam minimul de la nodurile adiacente care NU sunt printre copii in arbore. Pentru arborele din desen, daca ar fi sa deviem din ({$1, 2$}) am putea lua in considerare doar nodul {$1$}.\r\n\r\nDaca trebuie sa luam in considerare doar drumurile elementare, algoritmul simplu de mai sus da erori. Spre exemplu, daca ar fi sa deviem din ({$1, 7$}) in desen, drumul optim ar fi prin {$1$}, adica ({$1, 7, 1, 7, 4, 5$}), care drum nu este elementar. Pentru a genera doar drumurile elementare, este nevoie sa marcam nodurile de la radacina pana la deviatie ca \"ocupate\" si sa rulam un algoritm de drum minim pana la destinatie. Acest lucru creste foarte mult complexitatea in timp si in implementare.\r\n\r\nh2. Exemplu\r\n\r\nAlgoritmul prezentat este destul de complex, asa ca vom detalia rularea algoritmului pe graful din desen. Vom incerca sa calculam toate cele mai scurte $5$ drumuri elementare intre nodurile $1$ si {$5$}. Punem si conditia ca drumurile sa fie elementare (cazul mai dificil).\r\n\r\n* Primul drum minim este ({$1, 7, 4, 5$}), de lungime {$9$}.\r\n* Incercam sa deviem din {$1$}. Drumul minim de la $1$ la $5$ care nu trece imediat prin $7$ este ({$1, 2, 4, 5$}), cu cost {$10$}.\r\n* Incercam sa deviem din {$7$}. Drumul minim de la $7$ la $5$ care nu trece imediat prin $4$ este ({$7, 3, 5$}), cu cost {$10$}. Atentie, adaugam si costul de la $1$ la {$7$}.\r\n* Incercam sa deviem din {$4$}. Nu exista alt drum de la {$4$} la {$5$}. Ar putea fi drumul ({$4, 7, 3, 5$}), dar nu ar fi elementar, deoarece avem prefixul ({$1, 7$}), noduri pe care le-am marcat blocate.\r\n* Din $5$ nu are sens sa deviem, asa ca..\r\n* Al doilea drum minim este ({$1, 2, 4, 5$}), de lungime {$10$}.\r\n* Incercam sa deviem din {$1$}, dar nu exista drum de la $1$ la $5$ care sa nu o ia imediat nici prin $2$ si nici prin {$7$}.\r\n* Incercam sa deviem din {$2$}. Drumul minim de la $2$ la $5$ care nu trece imediat prin $4$ este ({$2, 6, 4, 5$}), cu cost {$10$}. Atentie, drumul trece prin {$4$}, dar nu imediat.\r\n* Incercam sa deviam din {$4$}. Drumul minim de la $4$ la $5$ care nu trece imediat prin $5$ este ({$4, 7, 3, 5$}), cu cost {$15$}. Acest drum nu a fost valid mai inainte, dar acum prefixul lui $4$ este ({$1, 2$}), asa ca drumul e valid.\r\n* Al treilea drum minim este ({$1, 7, 3, 5$}), tot de lungime {$10$}. Al doilea si al treilea drum minim sunt interschimbabile.\r\n* Acest drum a fost derivat din {$7$}, asa ca nu trebie incercam sa derivam din {$1$}.\r\n* Incercam sa deviem din {$7$}, dar nu exista drum de la $7$ la $5$ care sa nu treaca imediat nici prin $3$ nici prin {$4$}. Ar fi ({$7, 1, 2, 4, 5$}), dar avem $1$ ca prefix si marcat blocat. Astfel, evitam un drum neelementar.\r\n* Incercam sa deviem din {$3$}, fara succes(si fara explicatii kilometrice.).\r\n* Al patrulea drum minim este ({$1, 2, 6, 4, 5$}), de lungime {$11$}.\r\n* Incercam sa deviem din {$2$}, dar fara succes.\r\n* Incercam sa deviem din {$6$}, dar tot fara succes.\r\n* Incercam sa deviam din {$4$}. Drumul minim de la $4$ la $5$ care nu trece imediat prin $5$ este ({$4, 7, 3, 5$}), cu cost {$16$}. Noi am mai gasit odata acest drum, dar de data asta e cu un alt prefix, si alt cost. Drumul complet este ({$1, 2, 6, 4, 7, 3, 5$}), nu ({$1, 2, 4, 7, 3, 5$}).\r\n* Al cincilea drum minim este ({$1, 2, 4, 7, 3, 5$}), de lungime {$15$}.\r\n* Astfel se termina exemplul nostru. Puteti sa incercati, nu mai exista deviatii posibile. Al {$6$}-lea si ultimul drum este ({$1, 2, 6, 4, 7, 3, 5$}) , care se intample sa fie si cel mai lung drum, si hamiltonian.\r\n\r\nh2. Analiza complexitatii\r\n\r\nComplexitatea algoritmului este diferita in cele $2$ variante. In ambele cazuri putem considera la lugimea fiecarui drum este de {$O(n)$}, si ca heap-ul contine $O(k * n)$ valori. Luam cazul cel mai defavorabil, cu graf complet, si consideram ca un algoritm de drumuri minime necesita timp {$O(n * n)$}. Astfel, daca nu este nevoie ca drumurile sa fie elementare:\r\n\r\n* Precalculam drumurile de la orice nod la destinatie, {$O(n * n)$}.\r\n* La fiecare dintre cei k pasi.\r\n** Extragem din heap, $O(log(k * n))$\r\n** Reconstituim drumul, $O(n)$\r\n** Pentru fiecare dintre cele maxim $n$ noduri din drum:\r\n*** Vedem cel mai scurt drum de continuare, $O(n)$\r\n*** Il adaugam in heap, $O(log(k * n))$\r\n\r\nComplexitatea ajunge astfel la {$O(k * n * (n + log(k * n)))$}. Trebuie avut in vedere ca in general drumurile minime vor avea noduri relativ putine, asa ca algorimtul e mai rapid decat pare. Daca punem conditia ca drumurile determinate sa fie elementare, complexitatea creste:\r\n\r\n* La fiecare dintre cei $k$ pasi.\r\n** Extragem din heap, $O(log(k * n))$\r\n** Reconstituim drumul, $O(n * n)$ (il calculam iarasi)\r\n** Blocam nodurile de la start pana la nodul de deviatie, $O(n)$\r\n** Pentru fiecare dintre cele maxim $n$ noduri din drum:\r\n*** Vedem cel mai scurt drum de continuare, $O(n * n)$\r\n*** Il adaugam in heap, $O(log(k * n))$\r\n\r\nComplexitatea ajunge acum la {$O(k * n * (n * n + log(k * n)))$}, aproximativ {$O(k * n^3^)$}. Iarasi, algoritmul se comporta mai bine in practica decat pare in complexitate.\r\n\r\nh2. Observatii, indicatii, completari\r\n\r\nAlgoritmul poate fi mai incet sau mai rapid. Se poate folosi ceva mai simplu de implementat in loc de heap, sau un algoritm de drumuri minime mai evoluat. Daca va intrebati daca algoritmul poate fi folosit pentru a determina un drum hamiltonian, raspunsul este da, dar asta necesita determinarea tuturor drumurile lor dintre $2$ muchii, care este exponential in functie de {$n$}.\r\n\r\nDaca sunteti interesati si, bineinteles, daca \"va tine\", incercati se rezolvati problema \"SGU 145\":http://acm.sgu.ru/problem.php?contest=0&problem=145 , de unde a pornit de fapt acest articol. Se cere cazul cel dificil, cu drumuri elementare.\r\n\r\n',1490,'public'),('stiri/oji-oni-2005','OJI & ONI 2005','2005-01-31 00:00:00','h1. OJI & ONI 2005\r\n\r\nOlimpiada de Informatica, faza judeteana va avea loc pe data de 26-27 februarie 2005. Pe 26 februarie clasele 5, 6, 9 si 10 iar pe 27 februarie clasele 11, 12, 7 si 8.\r\n\r\nOlimpiada Nationala de Informatica de anul acesta se va desfasura in orasul Galati in perioada 25 martie-1 aprilie. Pentru mai multe detalii intrati vizitati \"olimpiada.info\":http://olimpiada.info si \"infogl.ro\":http://www.infogl.ro !\r\n\r\nMult succes!\r\n\r\n',1142,'protected'),('template/preoni-2006','template/preoni-2006','2006-11-27 16:01:52','==include(page=\"template/preoni-2006/header\")==\r\n\r\n(vmenu)*(section) \'preONI 2006\':preoni-2006\r\n* \'Informatii generale\':preoni-2006/info\r\n* \'Organizatori\':preoni-2006/comisie\r\n* \'Sponsori si premii\':preoni-2006/premii\r\n* \'Program\':preoni-2006/program\r\n* \'Regulament\':preoni-2006/regulament\r\n* \'Aparitii in presa\':preoni-2006/presa\r\n* \'Clasament\':preoni-2006/clasament\r\n*(section) Runde\r\n* \'Runda 1\':preoni-2006/runda-1\r\n* \'Runda 2\':preoni-2006/runda-2\r\n* \'Runda 3\':preoni-2006/runda-3\r\n* \'Runda 4\':preoni-2006/runda-4\r\n* \'Runda finala\':preoni-2006/finala\r\n\r\n\r\n',13,'protected'),('template/preoni-2006/header','template/preoni-2006/header','2006-11-27 16:08:54','table{margin: 0; width: 99%; background-image: url(/template/preoni-2006?action=download&file=hbk.gif); background-repeat: repeat-x; background-position: bottom left;}. |{border: 0px;}. !template/preoni-2006?hlogo.gif!:/preoni-2006 |{border: 0px; text-align: right; vertical-align: bottom}. !template/preoni-2006?ipdevel.gif!:http://www.ipdevel.ro/ !template/preoni-2006?oracle_ro.gif!:http://www.oracle.ro/ |\r\n',13,'protected'),('stiri/preoni-2005-runda-1','preONI, runda #1','2005-01-19 00:00:00','h1. preONI 2005, runda #1\r\n\r\nNe mai despart doua luni de Olimpiada Nationala de Informatica (18-27 martie, Galati / Drobeta Turnu Severin)! Pentru a veni in sprijinul elevilor ce se pregatesc pentru aceasta competitie, echipa info.devNet organizeaza un concurs de pregatire (preONI) in 3 runde.\r\n\r\nDuminica, 23 ianuarie, ora 15:00 va avea loc prima runda preONI.\r\n\r\nFormatul concursului: 2 grupe (clasele IX-X, XI-XII), 3 probleme in fiecare grupa si un timp de lucru de 4h. Evaluarea va incepe la 15min dupa terminarea timpului de lucru si va putea fi urmarita in timp real la sectiunea \"statistici\".\r\n\r\nSpre deosebire de ultimul concurs de pregatire (din 14 nov 2004), cele 3 probleme propuse vor avea de aceasta data o dificultate gradata, fiind accesibile unui public mult mai larg.\r\n\r\nPropunatorii problemelor din runda #1 sunt:\r\n\r\n* Mircea Pasoi\r\n* Adrian Vladu\r\n* Cosmin Negruseri\r\n\r\nAsteptam intrebarile / sugestiile tale pe \'forum\':http://forum.infoarena.ro.\r\n\r\n*Mult succes!*',961,'protected'),('moisil-by-net-2006/clasament-9','Clasament moisil2','2006-11-24 18:24:57','h1. Clasament ==roundparam(round_id=\"moisil2\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"moisil2\")==',961,'protected'),('preoji-2004','preOJI 2004','2006-11-24 16:25:38','h1. preOJI 2004\r\n\r\n!>preoji-2004?logo!\r\n\r\nConcursul s-a desfasurat pe 22/2/2004 intre orele 9 si 12 dimineata.\r\n\r\nAu fost 2 grupe cu cate 2 probleme, in similar OJI.\r\n\r\nh2. Grupa mica, clasele 9-10 (\'Clasament\':preoji-2004/clasament-9-10)\r\n\r\n== Tasks(round_id=\"preoji1\" pager_style=\"none\")==\r\n\r\nh2. Grupa mare, clasele 11-12 (\'Clasament\':preoji-2004/clasament-11-12)\r\n\r\n== Tasks(round_id=\"preoji2\" pager_style=\"none\")==\r\n\r\n',1,'protected'),('summer-challenge-2/clasament','Clasament summer2','2006-11-24 17:47:15','h1. Clasament ==roundparam(round_id=\"summer2\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"summer2\")==',961,'protected'),('summer-challenge-3','Summer Challenge Trei','2006-11-24 17:38:27','h1. Summer challenge 3\r\n\r\nConcursul s-a desfasurat pe 27 august 2006, ora 10:00 pe o durata de 5h. S-au propus spre rezolvare 3 probleme care au fost adaugate in \'arhiva\':arhiva.\r\n\r\nSolutiile problemelor le puteti gasi \"aici\":summer-challenge-3/solutii.\r\n\r\nh2. \'Clasament\':summer-challenge-3/clasament\r\n\r\n!>summer-challenge-3?logo.jpg!\r\n\r\n== Tasks(round_id=\"summer3\" pager_style=\"none\") ==',961,'protected'),('warm-up-2006','Autumn WarmUp 2006','2006-11-25 01:07:05','h1. Autumn WarmUp 2006\r\n\r\nConcursul s-a desfasurat incepand cu ora 14:00 pe data de 8 septembrie 2006.\r\n\r\nA  fost un concurs facut de utilizatori pentru utilizatori, cu 5 subiecte cu grade diferite de dificultate, de la accesibil la dificil. Evaluatorul a fost pornit pe toata durata concursului.\r\n\r\nSolutiile problemelor le puteti gasi \"aici\":warm-up-2006/solutii.\r\n\r\nh2. Propunatori\r\n\r\n* Paul Dan Baltescu (PaulDB)\r\n* Vlad Berteanu (vladcyb1)\r\n* Vlad Dumitriu (vladut.forum)\r\n* Tiberiu Savin (devilkind)\r\n* Vlad Saveluc (VladS)\r\n\r\nh2. \'Clasament\':warm-up-2006/clasament\r\n\r\n!>warm-up-2006?logo.jpeg!\r\n\r\n== Tasks(round_id=\"autumn06\" pager_style=\"none\") ==\r\n',961,'protected'),('summer-challenge-3/clasament','Clasament summer3','2006-11-24 17:47:06','h1. Clasament ==roundparam(round_id=\"summer3\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"summer3\")==',961,'protected'),('warm-up-2006/clasament','Clasament autumn06','2006-11-24 18:25:27','h1. Clasament ==roundparam(round_id=\"autumn06\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"autumn06\")==',961,'protected'),('happy-coding-2006/clasament','Clasament happy2006','2006-11-24 17:49:02','h1. Clasament ==roundparam(round_id=\"happy2006\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"happy2006\")==',961,'protected'),('stiri/final-preoni-2005-runda-1','preONI runda #1 s-a incheiat','2005-01-27 00:00:00','h1. preONI 2005 runda #1 s-a incheiat\r\n\r\npreONI runda #1 s-a incheiat, rezultatele finale au fost publicate iar problemele au fost mutate in arhiva.\r\n\r\nMircea Pasoi a publicat un \'articol\':preoni-2005/runda-1/solutii despre aceasta runda.\r\n\r\nAsteptam parerile si sugestiile voastre pe \'forum\':http://forum.infoarena.ro',961,'protected'),('usaco-ianuarie-2005-divizia-gold','Usaco ianuarie 2005, divizia GOLD','2006-11-23 17:52:02','h1. Usaco ianuarie 2005, divizia GOLD\r\n\r\n(Categoria _Competitii_, autor(i) _Silviu Ganceanu, Mircea Pasoi_)\r\n\r\n\r\nAcest set de probleme a fost considerat unul dintre cele mai grele, daca nu cel mai greu, de pana acum. Problemele au fost intr-adevar dure cu atat mai mult cu cat timpul de lucru a fost mic (3 ore). In ciuda acestui fapt concurentii din Romania s-au comportat bine, concursul marcand primul succes de pe anul acesta al tarii noastre: locul 5 obtinut de Adrian Vladu.\r\n\r\nDesi rezultatele i-au determinat pe antrenorii americani sa considere setul de probleme cel mai greu de pana acum, pentru multi dintre elevii Romaniei problemele nu au fost in totalitate noi: cover a fost propusa (sub o forma un pic diferita) la CEOI, o varinta ceva mai blanda a problemei juice (cu limite mai mici) am putut vedea si in finala rundei .Campion de anul trecut iar ideea de rezolvare pentru naptime nu era noua (o problema din concursul $\"Stelele Informaticii\"$ de anul trecut se pare ca semana mult cu aceasta).\r\n\r\nCu toate aceastea problemele au fost deosebit de dificile necesitand concentrare maxima. Rezultatele elevilor din Romania s-au imbunatatit semnificativ fata de concursul precedent, acestia obtinand locuri mai bune. O parte din succesul acestora indraznesc sa o pun si pe seama faptului ca problema cea mai grea din concurs era cunoscuta la noi in tara. Avem astfel urmatorul clasament:\r\n\r\ntable. |_. 1. | Adrian Vladu | $958$ puncte |\r\n|_. 2. | Sorin Stancu-Mara | $703$ puncte |\r\n|_. 3. | Mircea Pasoi | $700$ puncte |\r\n|_. 4. | Andrei Teodorescu | $640$ puncte |\r\n|_. 5. | Dan-Ionut Fechete | $547$ puncte |\r\n|_. 6. | Adrian Diaconu | $502$ puncte |\r\n\r\nRestul concurentilor au obtinut punctaje frumoase dar mai mici de $400$ de puncte. Sunt de remarcat comportarile bune de pana acum ale lui Andrei Teodorescu care reuseste sa se \"tina\" de mult mai titratii elevi ai Romaniei care au deja in palmares cel putin o medalie internationala.\r\n\r\nSetul de probleme, impreuna cu testele si clasamentul, se gaseste in cadrul \"sectiunii download\":downloads. In continuare vom prezenta solutiile:\r\n\r\nh2. Cover\r\n\r\nProblema nu era foarte dificila, cu atat mai mult cu cat ideea de rezolvare a problemei guards din concursul CEOI 2002 era aceeasi: se construieste un graf bipartit avand intr-o multime barele orizontale (set maximal de pozitii de pe o linie din matrice in care avem noroi) si in cealalta multime barele verticale (definite analog dar pentru coloane). Intre doua noduri din acest graf bipartit vom avea muchie doar daca barele corespunzatoare lor au o celula comuna. Pentru exemplificare vom lucra cu exemplul din enunt:\r\n@*.*.@\r\n@.***@\r\n@***.@\r\n@..*.@\r\nIata cum vom construi prima multime a grafului bipartit (vom pune numarul nodului din graf corespunzator fiecarei celule):\r\n@1.2.@\r\n@.333@\r\n@444.@\r\n@..5.@\r\nA doua multime a grafului bipartit va arata astfel (nodurile vor fi numerotate incepand tot cu 1):\r\n@1.2.@\r\n@.324@\r\n@532.@\r\n@..2.@\r\nMuchiile din graful bipartit vor fi urmatoarele:\r\n$(1, 1) (2, 2) (3, 3) (3, 2) (3, 4) (4, 5) (4, 3) (4, 2) (5, 2)$\r\n\r\nAsadar fiecarei celule din harta terenului ii corespunde o singura muchie in acest graf bipartit. Avand construit graful trebuie sa aflam numarul minim de noduri selectate astfel incat orice muchie sa aiba cel putin un capat intre nodurile selectate (in literatura de specialitate aceasta problema se numeste {$Minimum Vertex Cover$}). Explicatia acestui lucru este simpla: orice muchie, fiind de fapt o celula, ea trebuie sa fie \"acoperita\" de cel putin un nod din graf (adica o placa orizontala sau verticala utilizata de FJ). Problema acesta este NP-completa pentru grafuri generale dar in cazul grafurilor bipartite ea se poate rezolva in timp polinomial. De asemenea s-a demonstrat ca numarul minim de noduri dintr-un astfel de set este egal cu cardinalul cuplajului maximal din graful bipartit. De aici nu mai e decat un pas spre solutia finala. Avem, astfel, urmatorii pasi in algoritmul de rezolvare a problemei:\r\n==code(cpp) |\r\n* PAS 1: Construirea grafului bipartit\r\n* PAS 2: Aflarea cuplajului maximal\r\n==\r\n\r\nPrimul pas este banal si consta din simple parcurgeri ale matricii. Pentru aflarea cuplajului maximal se poate afla utilizand un algoritm de aflarea a fluxului maxim in reteaua asociata grafului bipartit sau se poate algoritmul bazat pe gasirea succesiva a drumurilor in crestere in graf.\r\nComplexitatea finala a algoritmului va fi $O(N^2^*M^2^)$ deoarece in graful bipartit avem maxim $N*M$ muchii si vom $N*M$ noduri. Cum algoritmul pentru aflarea cuplajului maximal are complexitatea $V*E$ ({$V$} = numarul de noduri din graf, $E$ = numarul de muchii din graf) concluzia este evidenta.\r\nCa tema, recomand rezolvarea urmatoarelor probleme a caror solutie se bazeaza pe aflarea cuplajului maximal intr-un graf bipartit (in unele cazuri acest lucru insa nu este de ajuns):\r\n\r\n# $guards (CEOI 2002)$\r\n# $knigths (Baltica 2001)$ - in solutia oficiala a acestei probleme gasiti mai multe informatii despre notiunea de cuplaj maximal intr-un graf bipartit si problemele inrudite\r\n# Problema \"Paznici\":http://algoritmus.org/probleme/probleme_runda04.php din runda a patra a concursului Algoritmus (gasiti pe pagina si explicatia solutiei)\r\n# \"http://acm.timus.ru/problem.aspx?space=1&num=1106\":http://acm.timus.ru/problem.aspx?space=1&num=1106\r\n# \"http://acm.sgu.ru/problem.php?contest=0&problem=234\":http://acm.sgu.ru/problem.php?contest=0&problem=234\r\n# \"http://acm.sgu.ru/problem.php?contest=0&problem=210\":http://acm.sgu.ru/problem.php?contest=0&problem=210\r\n# \"http://acm.sgu.ru/problem.php?contest=0&problem=218\":http://acm.sgu.ru/problem.php?contest=0&problem=218\r\n# \"http://online-judge.uva.es/p/v107/10735.html\":http://online-judge.uva.es/p/v107/10735.html\r\n# \"http://online-judge.uva.es/p/v108/10804.html\":http://online-judge.uva.es/p/v108/10804.html\r\n# \"http://online-judge.uva.es/board/viewtopic.php?t=7462\":http://online-judge.uva.es/board/viewtopic.php?t=7462\r\n\r\nMentionez ca problema 8 m-a impresionat in mod placut fiind una dintre cele mai frumoase probleme pe care le-am intalnit in ultimele cateva luni.\r\n\r\nh2. Juice\r\n\r\nFie $A{~i,j~}$ inaltimea blocului aflat in pozitia $(i, j)$. Aflam inaltimea maxima la care poate urca nivelul sucului in fiecare celula. Daca notam aceasta inaltime cu B{~i,j~} solutia problemei va fi $suma( B{~i,j~} - A{~i,j~} )$.\r\n\r\nVom numi celula turn o celula $(i, j)$ care are propietatea ca $B{~i,j~} = A{~i,j~}$ (nu putem pune suc in ea pentru ca ar curge in afara matricei). Componenta conexa a unei celule turn $(i, j)$ este compusa din acele celule $(x, y)$ pentru care avem $B{~x,y~} = A{~i,j~}$. Definim inaltimea componentei conexe ca fiind inaltimea comuna a tuturor celulelor componente. Facem urmatoarele observatii utile in rezolvarea problemei:\r\n\r\n# Celulele de pe marginea matricei sunt celule turn\r\n# Celula $(x, y)$ devine celula turn daca este vecina unei celule $(i, j)$ ce face parte dintr-o componenta conexa si are propietatea ca $B{~i,j~} < A{~x,y~}$.\r\n\r\nIncet, incet se contureaza solutia problemei observand ca, pentru a declara o celula ca fiind turn, trebuie sa aflam componentele conexe ale celulelor turn mai joase decat ea. Acest lucru ne aduce la ideea de procesa aceste celule turn in ordinea inaltimii lor afland pentru fiecare componenta conexa corespunzatoare. In acelasi timp aflam si celule ce devin turn si sunt mai inalte. Pentru aceasta utilizam o coada de prioritati (un heap) in care pastram toate celule turn neprocesate inca ordonate descrescator dupa inaltime. Ajungem astfel la nimic altceva decat un algoritm de tip $FILL$ modificat corespunzator cerintelor acestei probleme. Iata o descriere a acestuia:\r\n\r\n==code(cpp) |\r\nPAS 1: Se introduc in coada de prioritati pozitiile de pe margine\r\nPAS 2: Cat timp heapul nu este gol:\r\n* se selecteaza celula turn cea mai joasa\r\n* se afla componenta conexa a acesteia\r\n* se introduc in coada de prioritati celulele vecine cu componenta conexa construita,\r\n  care au inaltimea mai mare decat inaltimea componentei\r\n==\r\n\r\nSe poate modifica usor algoritmul $FILL$ pentru a rezolva toate aceste cerinte. Complexitatea finala a algoritmului va fi $O(N^2^*logN)$ deoarece, in cazul cel mai defavorabil, toate celulele sunt turn (un exemplu este cand matricea este piramidala) si in consecinta toate celulele vor fi introduse si scoase din heap necesitand logN pentru fiecare operatie. Aflarea componentelor conexe va necesita $O(N^2^)$ timp in total fiindca o celula va fi selectata o singura data intr-o componenta conexa si va fi accesata de maxim 4 ori de algoritmul $FILL$. Ca detalii de implementare, programatorii in $C++$ pot folosi cozile de prioritati din $STL$ ({$priority_queue$} ce se gaseste in headerul {$&#0060;queue&#0062;$}) pentru a reduce din complexitatea implementarii. Totusi, trebuie acordata atentie utilizarii acestora deoarece este posibil ca sursa sa depasesca timpul de executie.\r\n\r\nh2. Naptime\r\n\r\nVom incerca sa rezolvam problema, ignorand la inceput faptul ca sirul este circular. Astfel, problema se transforma intr-una relativ usoara, abordabila cu programare dinamica. O prima incercare ar fi sa realizam o astfel de rezolvare: $A{~i,j~}$ = utilitatea de somn maxima care se poate obtine alegand $j$ perioade din primele $i$.\r\nRelatia de recurenta care se obtine este $A{~i,j~}=max(A{~i-k,j-k~}+suma U{~i-k+2~}...U{~i~})$ unde $U$ este vectorul de utilitati. Din pacate aceasta abordare are dezavantajul ca are complexitatea de timp $O(N*B^2^)$ si de memorie $O(N*B)$, neincadrandu-se nici in timp si nici in spatiu de memorie. Astfel, vom incerca sa imbunatatim aceasta dinamica modificand un pic semnificatia matricei A bazandu-ne pe faptul ca alegerea unei secvente continue de perioade aduca ca utilitate suma lor, mai putin prima perioada folosita:\r\n$A{~i,j,0~}$ = utilitatea de somn maxima care se poate obtine alegand $j$ perioade din primele $i$ si ultima perioada folosita sa fie $j$\r\n$A{~i,j,1~}$ = utilitatea de somn maxima care se poate obtine alegand $j$ perioade din primele $i$ si ultima perioada folosita sa *NU* fie $j$\r\nObtinem relatiile de recurenta:\r\n$A{~i,j,1~} = max({~i-1,j-1,1~} + U{~i~}, A{~i-1,j-1,0~})$\r\n$A{~i,j,0~} = max(A{~i-1,j,0~}, A{~i-1,j,1~})$\r\nAm redus complexitatea la $O(N*B)$ si memoria la $O(N)$, o imbunatatire substantiala.\r\n\r\nDeoarece sirul este circular, putem rezolva problema aplicand de $N$ ori dinamica de mai sus considerand sirul liniar si alegand fiecare pozitie ca fiind pozitia initiala, dar aceasta solutie depaseste cu mult limita de timp pe cazul cel mai defavorabil. Totusi, aceasta idee ar fi adus $10$ teste din cele $14$. Cu un mic truc, si anume alegerea aleatorie a pozitiei de start cat timp nu s-a depasit timpul de executie, s-ar mai fi putut obtine inca $2$ teste, in total $12$ (desi aceasta rezolvare nu obtine solutia optima pe testele foarte mari).\r\n\r\nPutem scapa de faptul ca sirul este circular mult mai elegant, aplicand de 2 ori dinamica: odata cum am zis mai sus (acoperind cazul cand pozitiile $N$ si $1$ nu sunt in aceeasi secventa de pozitii consecutive) si inca odata fortand sa existe o secventa de utilitati aleasa care contine pozitiile $N$ si $1$. A doua dinamica se poate obtine exact ca mai sus, aplicand aceeasi idee doar ca se initializeaza $A{~1,1,1~}=U{~1~}$ in loc de 0, si apoi pentru fiecare $i$ se verifica rezultatul curent cu $max(A{~i,B-(N-i),0~}, A{~i,B-(N-i),1~} + suma U{~i+2~}...U{~N~})$. Pentru a se incadara in limita de 0.3s trebuie acordata o mare grija la implementare, de exemplu, optimizand dinamica de mai sus de la $2*N$ memorie (ultimele doua linii din matricea $A$) la doar $N$ pastrand doar ultima linie si parcurgand indicele $j$ descrescator.',961,'public'),('skiplists','Skiplists','2006-11-22 02:22:24','h1. Skiplists\r\n\r\n(Categoria _Liste_, autor(i) _Stancu Mara Sorin_)\r\n\r\n\r\nVreau sa va fac cunostinta cu o noua structura randomizata de stocare a datelor. Ea se numeste skiplist si permite majoritatea operatiilor in timp logaritmic si e foarte usor de implementat. Structura ocupa $O(N)$ memorie si efectueaza majoritatea operatiilor (adaugare, cautare, stergere) in {$O(log N)$}. Bineinteles ca exista STL, dar de cele mai multe ori nimic nu bate o structura \"home-brewed\". Skiplist-urile sunt foarte similare cu arborii AVL, insa sunt un pic mai rapide si mai usor de implementat.\r\n\r\nh2. Introducere\r\n\r\nTotul porneste de la o lista simplu inlantuita in care fiecare element are un link (pointer sau orice altceva care poate indica alt element) catre urmatorul element din lista. Presupunem ca aceasta lista o tinem sortata. Ce ar fi daca de la elemntul $x$ nu am sari la elementul {$x+1$}? Ce ar fi daca am sari la {$x+2$}? Acesta este principiul din spatele skiplist.\r\n\r\nIntr-un skiplist fiecare element are un grad, numarul de link-uri la alte elemente. Un link de nivelul $x$ va indica un element care are cel putin $x$ nivele, astfel este posibil ca sa parcurgem toata lista cu link-uri de un anumit nivel. Cheia este ca, cu cat nivelul este mai mare, link-urile sunt din ce in ce mai putine si pointeaza mai departe. La nivelul minim, {$0$}, exista un link catre elementul exact urmator, iar cu cat crestem nivelul, cu atat link-urile sunt mai rare si \"sar\" peste mai multe elemente, de unde vine si denumirea de skiplist-uri, liste cu salt.\r\n\r\nh2. Implementare\r\n\r\nIntr-un skiplist nodurile pot avea orice grad, alegerea gradului tine exclusiv de consideratii de viteza. Pentru detalii vezi sectiunea de complexitate.\r\n\r\nCum se implementeaza o structura de genul asta? Mai intai trebuie sa subliniez ca este la fel de usor de implementat si in pascal, dar nu mai respecta limita de memorie, care se va duce la {$N log N$}, dar care in cele mai multe cazuri este ok.\r\n\r\nImplementarea in C ar arata ceva de genul:\r\n\r\n== code(cpp) |struct nod {\r\n    int key;\r\n    /* ce mai vreti sa memorati intrun nod. */\r\n    nod** link;\r\n}\r\n==\r\n\r\nIn pascal {$nod* link$}, un array dinamic, este mai dificil de implementat. Pentru a evita asta putem sa alocam la maxim array-ul, mai exact $log N$ elemente. Asta ridica complexitatea de memorie la {$O(N log N)$}, dar de cele mai multe ori este perfect acceptabil.\r\n\r\n== code(pas) |type pnod=^nod;\r\nnod=record\r\n    key:integer;\r\n    { ce mai vreti sa memorati intr-un nod }\r\n    link:array[0..logN] of pnod;\r\nend;\r\n==\r\n\r\nPe langa asta trebuie sa tineti minte capul listei, care trebuie sa fie un nod de grad maxim. De asemenea, cu cat gradul maxim este mai mare cu atat va merge mai repede pt $N$ mai mare ({$100,000$}) deci cand va ganditi la gradul maxim luati-l ceva de genul {$logN*2$}.\r\n\r\nCa implementare efectiva nu va trebuie decat un singur algoritm, cautarea, restul fiind extrem de usor de dedus. Algoritmul de cautare pe care il vom prezenta isi propune sa caute ultimul element cu cheia mai mica decat o anumita valoare.\r\n\r\nPentru a cauta un element intr-o lista inlantuita normala sortata se incepe de la primul element si se avanseaza pana cand urmatorul nod are cheia mai mare decat cea cautata. Intr-un skip-list procedam exact la fel, dar folosim faptul ca avem mai multe nivele de inlantuire. Vom incepe de la cel mai inalt nivel, si vom cauta ca intr-o lista inlantuita normala. Cand urmatorul nod la nivelul curent are cheia mai mare (sau este {$null$}) vom scadea nivelul.\r\n\r\nO implementare in pseudo-C ar arata ceva de genul:\r\n\r\n== code(cpp) |nod* x = cap_de_lista;\r\nint grad = grad_max;\r\nnod temp[grad_max];\r\n    while (gradul >= 0) {\r\n        while ((x->link[grad] != NULL) \r\n                &&(x->link[grad]->key < cheie_cautata)) {\r\n            x=x->link[grad];\r\n            temp[grad]=x;\r\n        }\r\n        grad--;\r\n    }\r\n==\r\n\r\nAcest algoritm ne da nodul din fata elementului cautat, daca acesta exista, sau cel care are cel mai mare key mai mic decat cel cautat. De aici e simplu sa vedem daca elementul cautat exista in skiplist, ar trebui sa fie {$x->link{~0~}$ (urmatorul element, pe nivelul $0$ structura este o lista simplu inlantuita). De asemenea ne mai ramane si {$temp$}, $temp$ contine acum toate nodurile din fata elementului curent care indica catre elemente de la $x$ in sus. Acest vector $temp$ este o modalitate de a evita listele dublu-inlantuite, si a injumatati consumul de memorie.\r\n\r\nOK, dar cum se fac celelalte operatii? Sa le luam pe rand...\r\n\r\n* Cautare: am explicat deja\r\n* Inserare: vrem sa inseram un nod cu cheia {$k$}. Mai intai cautam cheia $k$ in skiplist-ul deja existent, apoi alocam un nou nod de grad {$g$}, pe care il adaugam la fiecare nivel mai mic decat {$g$}, exact ca intr-o lista simplu inlantuita.\r\n* Stergere: vrem sa stergem nodul cu cheia {$k$}. Mai intai cautam cheia {$k$}, apoi stergem nodul la fiecare nivel, exact ca intr-o lista normala.\r\n* Interclasare: aici complexitatea mai depinde si de cat de separate sunt cele doua skip-uri. In principiu comparati primele elemente din fiecare lista iar pe cel mai mare il cautati in celalalt skiplist, luati elementele intre start si pozitia unde s-a oprit algoritmul de cautare si le adaugati in structura care va contine uniunea celor doua.\r\n\r\nh2. Complexitate\r\n\r\nPana acum nu am dat nici o explicatie asupra presupusei complexitati $O(log N)$ a operatiilor. Dupa cum puteti vedeam mai sus, operatiile de adaugare si stergere sunt de fapt variante ale operatiiei de cautare, la care se adauga {$O(grad maxim)$}. Cea mai importanta operatie este cea de cautare.\r\n\r\nOperatia de cautare va merge prin toate nivele, deci are complexitate minima {$O(grad maxim)$}. Ne putem imagina un skip-list ideal, in care grad-maxim este {$O(log N)$}, iar gradele sunt o secventa de genul ({$max, 1, 2, 1, 4, 1, 2, 1, 8, 1, 2, 1, 4, 1, 2, 1, 16, 1, 2, 1, 4, 1$}...). In acest skip-list, cautarea este echivalenta cu o cautare binara, la fiecare pas vom \"sari\" peste fix jumatate din ce a ramas, pentru o complexitate finala de [$O(log N)$}. Bineinteles, un skip-list real este destul de departe de acest ideal. In cel mai rau caz este posibil ca toate elementele sa aiba acelasi grad, si totul se reduce la o lista inlantuita cu consum mare de memorie, dar este putin probabil. Pe cazul mediu va avea insa complexitatea de {$O(log N)$}.\r\n\r\nPentru a aduce insa la complexitatea de {$O(log N)$}, este nevoie ca gradele sa aiba o distrubutie logaritmica: fiecare nod are gradul {$&ge;1$}, {$N/2$} au gradul {$&ge; 2$}, $N/4$ au gradul {$&ge; 3$}, $n/8$ au gradul {$&ge; 4$}, etc. Pentru asta avem nevoie de o functie de alegere a gradului aleatoare cu probabilitate logaritmica. Putem face ceva simplu de genul:\r\n\r\n== code(cpp) |rang = 1\r\nwhile (rand() % 2 == 0) {\r\n    ++rang;\r\n}\r\n==\r\n\r\nFunctia de mai sus merge satisfacator. Eventual putem sa memoram cate nod-uri de fiecare grad sunt in lista (modificand adaugarea si stergerea), si sa returnam nivelul la care suntem cel mai departe de ideal, dar nu este necesar.\r\n\r\nMemorie este oarecum evident {$O(N)$}. Daca skiplist-ul ar fi complet echilibrat atunci vor exista $N$ link-uri de nivel {$0$}, {$N/2$} de nivel {$1$}, {$N/4$} de nivel {$2$}, etc. Cu putina matematica {$N + N/2 + N/4 + N/8.. = 2 * N$}, adica {$O(n)$}. Pentru cei care programeaza in pascal si nu vor sa se complice cu alocare de array-uri dinamice, memoria va fi evident $O(N log N)$\r\n\r\nh2. Extinderi\r\n\r\nPe langa algoritmii de baza skip list permite imbogatiri care va permit multe alte lucruri cu timp minim de implementare si complexitate {$O(log N)$}. Cam toate imbogatirile structurii se bazeaza pe memorarea in paralel a unor informatii ajutatoare pt fiecare link (ATENTIE in pascal)\r\n\r\nAcces secvential: vrem sa accesam elementul pe pozitia {$i$}. Pentru aceasta vom memora pe fiecare link cate noduri \"acopera\", cu alte cuvinte cate noduri sare. Cautarea se modifica prin introducerea unei noi variabile care memoreaza indicele nodului curent, si prin comparare pozitie la care se sare in loc de cheia la care se sare. La inserare si stergere, trebuiesc actualizate toate linkurile din {$temp$}, deoarece si cele care indica peste codul curent contin informatii referitoare la el (il numara).\r\n\r\nIntervale: Tot ce trebuie sa adaugam, ca implementare, este o cautare in mod invers, care porneste de la nodul curent ({$START$}) si {$grad = 0$}, si \"urca\" pana cand {$grad > grad_max$}, sau {$link{~grad~} > END$} (nu exista un nod mai inalt intre inceputul si sfarsitul intervalului, dupa care trebuie sa coboare, ca la cautarea obisnuita... (eventual $START$ si $END$ necesita inserare in skiplist). Daca ati fost un pic atenti am parcurs toate link-urile care contin informatii despre intervalul curent. Pentru stabbing querys (avem un punct si ne intereseaza intervalele care le taie punctul respectiv) tot ce trebuie sa face este sa cautam in skiplist punctul respectiv si sa luam din $temp$ informatiile de la fiecare link.\r\n\r\n',1,'public'),('stiri/sarbatori-fericite','Sarbatori fericite!','2004-12-25 00:00:00','Echipa infoarena ureaza Sarbatori fericite tuturor vizitatorilor si spor la treaba in continuare!\r\n',1142,'protected'),('documentatie/conventii-de-formatare','Conventii de formatare','2006-12-11 06:41:39','h1. Conventii de formatare\r\n\r\nAceasta pagina detaliaza anumite conventii de formatare folosite de echipa infoarena in redactarea paginilor. Se recomanda sa respecti aceste indicatii pentru a mentine un look uniform si mai ales ca sa nu te trezesti ca modificarile tale sunt sterse.\r\n\r\nPrasitul este o activitate foarte plictisitoare, si nimic nu e mai plictisitor decat sa prasesti de mai multe ori aceeasi pagina. Pe pagina asta incercam punem niste reguli fixe pentru ca toata lumea sa stie ce are de facut. Inainte de a citi aceasta pagina cititi \'bazele sintaxei de textile\':documentatie/textile.\r\n\r\nh2. Reguli generale\r\n\r\nIn cazul ca problema a fost importata de pe _infoarena 1.0_ veti vedea urmatoarea linie $==Include(page=\"template/raw\")==$. Daca nu sunteti multumit de rezultatul final, dar nu mai aveti chef sa editati in continuare, puteti include linia $==Include(page=\"template/cleanup\")==$\r\n\r\nCateva reguli scurte si *foarte* importante:\r\n\r\n* Numele nostru este infoarena, fara liniuta. Eventual puteti scrie *info*_arena_.\r\n* Fiecare pagina incepe cu $h1. Titlu de pagina$.\r\n* Maxim h3, dar incercati sa va limitati la h2.\r\n* Url-urile noastra sunt lowercase cu liniuta.\r\n* Site-ul este in limba romana, inclusiv url-urile.\r\n* Stirile nu au nevoie de nici un fel de header.\r\n* Pe infoarena1 se scriau articole cu solutii. Solutiile se muta in $pagina-concurs/solutii$.\r\n* Fostele Articole trebuie integrate in wiki. Nu mai au autor si nici categorii.\r\n\r\nh2. Conventii formatare inline (bold, italic)\r\n\r\nNu folositi bold, italic sau alti modificatori fara un motiv bun. Daca aveti probleme cu inserarea unui anumit caracter puteti consulta aceasta \"lista\":http://en.wikipedia.org/wiki/List_of_HTML_decimal_character_references si sa folositi direct codul HTML de acolo.\r\n\r\n* Pentru variabile, constante, etc se va folosi *{@$...$@}* (eg. *{@$7$@}* &rarr; $7$).\r\n* Pentru ridicare se va pune exponentul intre *{@^...^@}* (eg. *&#0036;7&#0094;9&#0094;&#0036;* &rarr; $7^9^$).\r\n* Daca nu merg modificatorii inline se folosesc acolade: *{@ {$...$} @}*.\r\n* Daca doriti ca textul dintre modificatori sa nu fie interpretat ca Textile puteti folosi *{@ @...@ @}*, respectiv *&#0123;{@@...@@} &#0125;*.\r\n* Pentru virgula zecimala se va folosi \'*.*\'.\r\n* Pentru numere lungi (eg. 1234567890) este preferata gruparea cifrelor cate 3 pentru baza 10, sau cate 4 pentru bazele 2 si 16. Folositi un singur spatiu pentru despartirea grupelor. Exemple: $1 234 567 890$, $10 0010 1101 1011$, $A4 FAFF A9AB CDC3$, $10 333.445 56$.\r\n\r\nh2. Probleme\r\n\r\nAcceseaza \"template-ul\":template/newtask pentru a vedea structura generala a unui task in cod Textile. Structura unui task este urmatoarea:\r\n\r\n*FIXME:* Copy from \'here\':Documentatie/Conventii_De_Formatat_Probleme and obliterate that page.\r\n\r\n* Header: $==Include(page=\"template/taskheader\" task_id=\"*nume_task*\")==$\r\n* Enunt: Povestea problemei.\r\n* Date de intrare/iesire.\r\n* Date de intrare/iesire.\r\n* Restrictii: Se pun intr-o lista cu $*$.\r\n* Exemple: un tabel textila cu clasa de css example. Vezi mai jos\r\n* Footer: $==Include(page=\"template/taskfooter\" task_id=\"*nume_task*\")==$\r\n\r\nExemplele se pun intr-un tabel formatat similar celui din \"template\":http://www.infoarena.ro/template/newtask. Prima coloana a tabelului va fi formatata in felul urmator:\r\n\r\n@table(example). |_. task_id.in |_. task_id.out |@\r\nunde $task_id$ reprezinta id-ul taskului editat.\r\n\r\nPentru coloane aditionale veti adauga in continuare @_. nume_coloana |@ de cate ori este necesar. Fiecare din liniile de tabel ce urmeaza se va reprezenta pe coloane, fiecare celula fiind separata prin pipe  &#0124;:\r\n\r\n{@ | coloana 1 | coloana 2 | coloana 3 | coloana 4 | @}\r\n\r\nSe pot introduce mai multe linii intr-o singura celula a tabelului folosind, evident, new line. Daca doriti sa introduceti linii goale in tabel folositi @&nbsp;@. Se recomanda ca explicatiile exemplelor sa fie incluse separat, imediat sub tabelul cu exemple, folosind un titlu {@h3@}: {@h3. Explicatii@}\r\n\r\nh2. Concursuri\r\n\r\nVezi \'pagina de concursuri\':concursuri.',3270,'public'),('preoni-2005-runda-3','preONI, runda #3','2006-11-25 15:35:37','h1. preONI 2005, runda #3\r\n\r\nSuntem bucurosi sa te anuntam ca runda #3 a concursului preONI se va desfasura Duminica, 20 martie la ora 10:00 - vezi mai jos informatii detaliate. Aceasta este ultima runda a concursului preONI 2005, runda ce va decide castigatorii premiilor oferite de Microsoft.\r\n\r\nClasamentul final se va calcula pe baza punctajelor obtinute in runda #2 si #3, punctajele din runda #1 fiind folosite doar pentru departajare in caz de egalitate.\r\n\r\nOricine este invitat sa participe, insa, eligibili pentru premii sunt doar acei concurenti din ciclul de invatamant pre-universitar care nu fac parte din echipa infoarena.\r\n\r\nh2. preONI 2005, runda #3\r\n\r\nDuminica, 20 marie, ora 10:00 va avea loc a treia (ultima) runda preONI. Ca de obicei, concursul se va desfasura online la adresa \'infoareana.devnet.ro\':http://infoarena.devnet.ro/ Formatul concursului: 2 grupe (clasele IX-X, XI-XII), 3 probleme in fiecare grupa si un timp de lucru de 4h. Evaluarea va incepe la 15min dupa terminarea timpului de lucru si va putea fi urmarita in timp real la sectiunea \"statistici\".\r\n\r\nPropunatorii problemelor din runda #2 sunt:\r\n\r\n* clasele IX - X: Mircea Pasoi, Adrian Vladu\r\n* clasele XI - XII: Silviu Ganceanu, Cosmin Negruseri, Mircea Pasoi\r\n\r\nAsteptam intrebarile / sugestiile tale pe \'forum\':http://info.devnet.ro/forum.php\r\n\r\nh2. Premii pentru preONI 2005\r\n\r\nSe vor acorda premii primilor 3 concurenti de la fiecare grupa. Premiile constau in carti valoroase de programare si sunt oferite de Microsoft Romania, prin intermediul programului \'\"Parteneri pentru Educatie\"\':http://www.microsoft.com/romania/educatie/pil/default.mspx.\r\n\r\n* Premiul 1\r\n** \"Arta programarii calculatoarelor\", vol. 3, Donald E. Knuth,\r\n** \"POO cu Visual Basic.Net si Visual C#.Net\", R. Reynolds Haertle\r\n* Premiul 2\r\n** \"Limbajul C Kernighan, Ritchie\", Brian Kernighan, Dennis Ritchie\r\n** \"POO cu Visual Basic.Net si Visual C#.Net\", R. Reynolds Haertle\r\n* Premiul 3\r\n** \"STL - Biblioteca programatorului\", Scott Meyers\r\n** \"POO cu Visual Basic.Net si Visual C#.Net\", R. Reynolds Haertle\r\n\r\nToate cartile sunt publicate de editura Teora.\r\n\r\nh2. ONI 2005\r\n\r\nAsa cum bine stii, ne mai despart 8 zile de ONI! Site-ul oficial al olimpiadei de informatica este \'http://olimpiada.info/\':http://olimpiada.info/ . Gasesti acolo tot ce doresti sa afli despre ONI, OJI si ONI by NET.\r\n\r\nDaca nu te-ai calificat la ONI, ai ocazia sa participi virtual la olimpiada! Afla mai multe la \'http://olimpiada.info/bynet/\':http://olimpiada.info/bynet/. Inscrierile au inceput deja!\r\n\r\nEchipa info.devNet iti ureaza mult succes!',1,'public'),('stiri/concursul-bitwise','Concursul BitWise','2005-02-07 00:00:00','h1. Concursul BitWise\r\n\r\nConcurs de programare pe echipe. Dureaza 12 ore, are zece probleme, pot participa echipe de cate doi. Problemele se pot submita de maxim 10 ori, se evalueaza dupa submit, si sunt punctaje partiale. Mai multe detalii gasiti \"aici\":http://www.bitwise.iitkgp.ernet.in/ si va puteti inregistra pana in 7 februarie. Concursul se desfasoara pe data de 13 februarie. Inainte de inregistrare cititi FAQ si regulile concursului.\r\n',1142,'protected'),('template/noprofile','template/noprofile','2006-12-04 19:37:30','&nbsp;\r\n\r\n|_=. Acest utilizator nu si-a personalizat inca pagina de profil. \"Click aici\":documentatie/pagina-de-profil sa afli cum iti poti personaliza pagina de profil. |',13,'protected'),('documentatie/pagina-de-fil','dsfdsfdsfdsina-de-fil','2006-11-26 22:14:35','Scrie aici desfdsfdsfdsfds',1142,'public'),('stiri/iopc-international-online-programming-contest','IOPC - The International Online Programming Contest','2005-02-07 00:00:00','h1. IOPC - The International Online Programming Contest\r\n\r\nConcurs de programare pe echipe, pare similar cu bitwise, diferenta fiind ca echipele sunt de cate trei, sunt 12 probleme si concursul dureaza 24 de ore. Limbajele de programare sunt C/C++/Java. Adresa este: \"[1]\":http://www.techkriti.org/competitions.php?eid=2&subid=2. Pentru a participa trebuie mai intai sa va inregistrati echipa. Concursul se desfasoara pe data de 20 Februarie.\r\n\r\n\r\n',1142,'protected'),('preoni-2006/presa','Aparitii in presa, preONI 2006','2006-11-27 14:42:55','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Aparitii in presa\r\n\r\n\'Comunicat de presa IP Devel\':http://www.ipdevel.ro/index.php?mid=137&rid=22&pg=268',1,'protected'),('preoni-2006/runda-1','Runda 1, preONI 2006','2006-11-27 16:15:53','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Runda 1\r\n\r\nConcursul s-a desfasurat sambata, 19 noiembrie, la ora 09:00. Pe parcursul celor 4 ore de concurs participantii au avut de rezolvat 3 probleme. \r\n\r\nh2. Comisii\r\n\r\nh3. Stiintific\r\n\r\n* clasa a 9-a (si gimnaziu)\r\n** Tiberiu Florea\r\n** Silviu Ganceanu \r\n* clasa a 10-a\r\n** Cosmin Negruseri\r\n** Adrian Diaconu \r\n* clasele 11-12\r\n** Mircea Pasoi\r\n** Daniel Pasaila \r\n\r\nh3. Organizatoric\r\n\r\nPentru intrebari de factura organizatorica / tehnica poti contacta urmatoarele persoane:\r\n\r\n* Cristian Strat\r\n* Crestez Leonard \r\n\r\nh2. Solutii\r\n\r\nSolutiile problemelor le puteti gasi \"aici\":preoni-2006/runda-1/solutii\r\n\r\nh2. Clasa a 9-a si gimnaziu (\'Clasament\':preoni-2006/runda-1/clasament-9)\r\n\r\n!>preoni-2006/runda-1?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni61a\" pager_style=\"none\") ==\r\n\r\nh2. Clasa a 10-a(\'Clasament\':preoni-2006/runda-1/clasament-10)\r\n\r\n!>preoni-2006/runda-1?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni61b\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':preoni-2006/runda-1/clasament-11-12)\r\n\r\n!>preoni-2006/runda-1?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni61c\" pager_style=\"none\") ==\r\n\r\n==include(page=\"template/preoni-2006/footer\")==\r\n',13,'protected'),('stiri/preoni-2005-runda-2','preONI, runda #2','2005-02-21 00:00:00','h1. preONI 2005, runda #2\r\n\r\nAvem doua vesti bune pentru tine:\r\n\r\n# runda #2 a concursului preONI se va desfasura Miercuri, 23 februarie ora 16:00 - vezi mai jos informatii detaliate.\r\n# Microsoft Romania ofera PREMII SURPRIZA (yay!) primilor trei concurenti de la fiecare grupa!\r\n\r\nDorim sa multumim mult celor care ne-au ajutat in aceasta directie:\r\n\r\n* Microsoft Romania, programul \'\"Parteneri pentru Educatie\"\':http://www.microsoft.com/romania/educatie/pil/default.mspx\r\n* prof. Emil Onea\r\n* Octavian Costache\r\n\r\nNu iti face griji daca nu ai participat la prima runda preONI. Clasamentul final se va calcula pe baza punctajelor obtinute in runda #2 si #3, punctajele din runda #1 fiind folosite doar pentru departajare in caz de egalitate.\r\n\r\nOricine este invitat sa participe, insa, eligibili pentru premii sunt doar acei concurenti din ciclul de invatamant pre-universitar care nu fac parte din echipa infoarena.\r\n\r\nMiercuri, 23 februarie, ora 16:00 va avea loc a doua runda preONI. Formatul concursului: 2 grupe (clasele IX-X, XI-XII), 3 probleme in fiecare grupa si un timp de lucru de 4h. Evaluarea va incepe la 15min dupa terminarea timpului de lucru si va putea fi urmarita in timp real la sectiunea \"statistici\".\r\n\r\nPropunatorii problemelor din runda #2 sunt:\r\n\r\n* clasele IX - X: Dan Popovici, Cosmin Negruseri\r\n* clasele XI - XII: Silviu Ganceanu, Adrian Vladu, Dan Fechete\r\n\r\nNoteaza-ti! :)\r\nMiercuri la ora 16:00 ai concurs cu premii Microsoft pe infoarena!\r\n\r\nPana la inceperea concursului, te invitam sa citesti ultimele articole publicate pe portalul info.devNet. Printre acestea, se numara:\r\n\r\n* Skiplists, Stancu Mara Sorin\r\n* preONI 2005 runda #1 - solutii, Mircea Pasoi\r\n\r\nAsa cum bine stii, mai e aproape o saptamana pana la\r\nOlimpiada Judeteana de Informatica (26/27 februarie)!\r\n\r\nIti uram mult succes!\r\n\r\nAsteptam intrebarile / sugestiile tale pe \'forum\':http://forum.infoarena.ro/',1,'protected'),('summer-challenge-unu/clasament','Clasament Summer Challenge Unu','2006-11-24 17:47:39','h1. Clasament \'Summer Challenge Unu\':summer-challenge-unu\r\n\r\n==Rankings(rounds=\"summer06\")==',961,'protected'),('stiri/final-preoni-2005-runda-2','preONI 2005, runda #2 s-a incheiat','2005-02-26 00:00:00','h1. preONI 2005, runda #2 s-a incheiat\r\n\r\nRunda #2 a concursului preONI s-a incheiat. Rezultatele sunt disponibile in sectiunea \"statistici\" a site-ului si problemele au fost mutate in arhiva.\r\n\r\nAutorii problemelor au scris un \'articol\':preoni-2005/runda-2/solutii despre aceasta runda - rezultate si idei de rezolvare.\r\n\r\nFelicitari tuturor participantilor!\r\n\r\nPana la urmatoarea runda, *BAFTA LA OJI*!',961,'protected'),('preoni-2006/finala/solutii','Solutii preONI 2006, Runda finala','2006-11-25 13:20:02','h1. Solutii preONI 2006, Runda finala\r\n\r\n(Categoria _Competitii_, autor(i) _Echipa Infoarena_)\r\n\r\nSi iata-ne ajunsi in situatia de a trage concluziile dupa tot ce a insemnat preONI 2006. Toata comisia infoArena merita felicitata pentru organizarea si efortul depus de-a lungul campaniei. Inca odata multimim domnului profesor Onea pentru organizarea \"fara cusur\" :).\r\n\r\nFinala a fost ... \"Super. Super\", \"Super tare\", \"mda...a mers\" o spun concurentii. A fost grozav, intr-adevar, si ne-a facut mare placere sa va vedem prezenti intr-un numar atat de mare si veniti atat de departe. Va multumim pentru participare si speram ca ati petrecut un week-end pe cinste cu noi la Focsani.\r\n\r\nDupa cele patru runde online de concurs cu adevarat dure, cei 29 de concurenti si-au facut aparatia, de prin toate ungherele tarii, pe terenul de lupta. Desi in prima seara, la deschiderea ne-scortoasa si informala, concurentii isi zambeau sincer si fara vreun resentiment, in aer plutea \"emotia, tracul, tensiunea, stress-ul\".. Calmul dinaintea furtunii.. Venea marea confruntarea, batalia bataliilor, in urma careia trebuiau alesi castigatorii preONI 2006.\r\n\r\nConcursul s-a dovedit a fi o adevarata proba de foc, o batalie cu fum de creiere din plin si cu multe iesiri la toaleta (vezi \"Cronica\":preoni-2006/finala/cronica). Problemele, la limita imposibilului. Comisia a nascocit cele mai nastrusnice provocari pentru o finala in care participau concurenti adevarati, gata sa dea peste cap toate topurile Olimpiadelor ce vor voni. Muschi incordati, \"trac, tensiune, stress\". La sfarsit, punctaje reflectand truda demna de admirat a unor campioni alergand pe ultima suta de metri a unei curse in 5 acte. Castigatorii au fost sa fie, de acesta data, Cosmin Gheorghe la clasa a IX a, Simion Alexandru la clasa a X a si Marin Radu la clasele XI-XII. Ii felicitam pe ei si, in aceeasi masura, pe toti participantii care, desi au ratat premiile, cu siguranta au castigat prieteni noi.\r\n\r\nSa trecem la analiza problemelor cu care cei 29 concurenti nazdravani au avut de-a face in cele 5 ore ale finalei. Orice sugestie sau corectie privind articolul, solutiile problemelor v-o puteti exprima pe \"forum\":http://forum.infoarena.ro/.\r\n\r\nh2. DivK\r\n\r\nh3. (problema usoara clasa a IX-a, problema usoara clasa a X-a)\r\n\r\nExista solutii evidente $O(N * (A-B))$ si $O(N * K)$ care obtin punctaje partiale si asupra carora nu se va insista in acest articol. Solutia care obtine insa $100$ de puncte este $O(N)$ si nu este greu de gasit, bazandu-se pe cateva observatii. Sa notam cu $S{~i~}$ suma primelor $i$ numere din sir. Pentru ca subsecventa intre pozitiile $i$ si $j$ sa aiba suma elementelor divizibila cu $K$, atunci $S{~j~}-S{~i-1~}$ trebuie sa fie divizibil cu $K$, sau altfel spus, $S{~i-1~}$ si $S{~j~}$ sa aiba acelasi rest la impartirea cu $K$. Daca stim sa aflam raspunsul problemei pentru subsecvente de lungime maxim $L$ si minim {$1$}, aplicand de doua ori algoritmul pentru $B$ si pentru $A-1$ si scazand cele doua valori obtinute vom obtine numarul de subsecvente cu proprietatea ceruta intre $A$ si $B$ inclusiv. Pentru a afla raspunsul pentru lungimea maxim $L$ procedam astfel: introducem in lista $LISTA{~r~}$ alocata dinamic pozitiile $i$ pentru care $S{~i~}$ da restul $r$ la impartirea cu $K$, in ordine crescatoare. Pentru fiecare rest de la $0$ la $K-1$ parcurgem lista\r\ncorespunzatoarea, si, daca ne aflam pe un element cu valoarea $p2$ si elementul cel mai din stanga din lista curenta are valoarea $p1$ astfel incat $p2-p1 &le; L$, atunci cand avansam in lista nu mai este necesar sa incepem iterarea listei de la inceput pentru aflarea valorii cea mai din stanga, fiind suficient sa reluam cautarea din dreptul valorii $p1$. Astfel complexitatea algoritmului pentru o lista este $O(LUNGIME)$, unde $LUNGIME$ este lungimea unei liste, deci complexitatea intregului algoritm va fi $O(N)$, pentru ca lungimea tuturor listelor este $N$.\r\nO alta solutie de aceeasi complexitate dar mai rapida este urmatoarea: daca notam cu @v[r]@ de cate ori apare restul $r$ in numerele $S{~i-B~}...S{~i-A+1~}$ pentru pasul curent $i$, atunci la pasul $i+1$ este suficient sa decrementam $v[S{~i-B+1~}%K]$ si sa incrementam $v[S{~i-A+2~}%K]$. La fiecare pas $i$ vom aduna la solutia finala numarul $v[S{~i~}%K]$.\r\n\r\nh2. Lupul Urias si Rau\r\n\r\nh3. (problema medie clasa a IX-a)\r\n\r\nSe construieste vectorul $T{~i~}$ care retine timpul maxim la care oaia $i$ poate fi aleasa si notam $T_max$ valoarea maxima din {$T$}.\r\n\r\nO abordare care insa nu conduce la punctaj maxim este programarea dinamica, calculand $sol{~i,j~}$ cantitatea maxima de lana care se poate alege cu primele $i$ oi pana la momentul {$j$}. Raspunsul se va gasi in {$sol{~n,T_max~}$}. Complexitatea este $O(n^2^)$ si ar obtine aproximativ $50-60$ de puncte.\r\n\r\nO rezolvare ce aduce 100 de puncte se bazeaza pe metoda greedy. Pentru fiecare valoare $j$ de la $T_max$ la $1$ se adauga intr-o multime toate cantitatile de lana $A{~i~}$ pentru oile cu {$T{~i~}=j$}, apoi se extrage valoarea maxima care se adauga la solutie, restul valorilor pastrandu-se in multime pentru pasul urmator. Atentie, se va extrage valoarea maxima chiar daca la acest pas nu s-au introdus valori noi in multime. Pentru a implementa eficient aceste operatii ne vom folosi un heap care suporta operatiile de extragere maxim si adaugare element in {$O(log n)$}. Complexitatea finala a algoritmului va fi de {$O(n log n)$}. Demonstratia intuitiva a faptului ca algoritmul conduce la solutie optima este ca la fiecare pas $j$ se alege valoarea maxima dintre cele care nu vor mai putea fi alese la pasul {$j+1$}.\r\n\r\nO alta solutie tot greedy a problemei este sortarea descrescatoare dupa cantitatile de lana. Pentru fiecare valoare apoi se vede cel mai mare timp mai mic sau egal cu {$T{~i~}$} si la care nu a mai fost aleasa nici o alta oaie. Daca exista un astfel de timp se adauga valoare respectiva la solutie. Acest lucru se poate realiza cu o cautare binara a acestui timp. O alternativa la acest lucru ar fi folosirea multimilor disjuncte. Initial se considera fiecare moment de timp o multime. Notam $X$ = minimul din multimea care il contine pe {$T{~i~}$}. Daca alegem $A{~i~}$ pentru a-l aduaga la solutie se va reuni multimea care il contine pe $X$ cu multimea care il contine pe {$X-1$}. Aceasta rezolvare insa este considerata peste nivelul mediu al clasei a 9-a.\r\n\r\nh2. Overlap\r\n\r\nh3. (problema grea clasa a IX-a)\r\n\r\nObservam ca exista doar $4$ rotatii posibile ale planului, facand abstractie de translatii. Daca $CMAX$ este coordonata maxima, atunci punctul ({$i, j$}) se transforma in ({$CMAX-j, i$}), iar dupa $4$ aplicari ale acestei transformari se ajunge din nou la punctul initial. Asadar, vom incerca pe rand fiecare dintre aceste posibilitati. Avand fixata o rotatie, stim ca punctul $1$ se transforma intr-un alt punct $i$ ({$i > 1$}), sau ca un punct $i$ se transforma in el. Cel de-al doilea caz este redundant, deoarece aplicand transformarea {$P{~i~} -> {{~1~}$}, vom lua in considerare si transformarea inversa. De exemplu, daca rotind planul cu $k*90$ de grade si translatandu-l cu $shift_X$ si $shift_y$ obtinem $P{~i~}$ din {$P{~j~}$}, atunci rotind planul cu $(4-k)*90$ grade si translatandu-l cu {$-shift_x$}, {$-shift_y$} vom obtine $P{~j~}$ din {$P{~i~}$}.\r\nOdata fixata rotatia pe care o consideram (inclusiv cea de $0$ grade), presupunem pe rand pentru fiecare punct $i > 1$ ca $P{~1~}$ se transforma in {$P{~i~}$}, si verificam daca aceasta presupunere conduce la o solutie valida. Presupunerea facuta stabileste in mod unic care este translatia efectuata. Retinem un vector $P{~i~}$ = punctul in care se transforma al {$i$}-lea punct dupa aplicarea rotatiei fixate si a translatiei determinate, sau $-1$ daca punctul transformat nu se regaseste printre cele initiale. Pentru a realiza in mod eficient aceasta operatie, la inceputul algoritmului punctele se sorteaza cu o functie de comparare oarecare si la fiecare pas punctul dorit se cauta binar in acest vector, in {$O(log N)$}. Eventual s-ar putea folosi un tabel de dispersie, insa consideram ca aceasta structura de date este prea complicata pentru nivelul clasei a 9-a si nu era necesara pentru obtinerea punctajului maxim.\r\n\r\nAvand vectorul {$P$}, va exista o structura de lanturi si cicluri rezultata in urma aplicarii repetate {$P[P[..P[i]]]$} asupra diverselor puncte. Se poate demonstra usor ca exista solutie daca si numai daca toate lanturile si toate ciclurile au lungime para; in acest caz solutia se poate obtine etichetand alternativ punctele consecutive dintr-un lant sau ciclu.\r\nComplexitatea algoritmului este $O(N^2^ * log N)$ pe cazul defavorabil folosind cautari binare pentru gasirea punctelor, sau $O(N^2^)$ pe cazul mediu folosind un hash (tabel de dispersie).\r\n\r\nh2. Iv\r\n\r\nh3. (problema medie clasa a X-a)\r\n\r\nSolutia simpla, calculata prin metoda programarii dinamice, se bazeaza pe mentinerea starilor ce asigura obtinerea solutiilor distincte. Astfel interclasarea celor doua siruri se va face in acelasi timp atat din stanga cat si din dreapta pentru a garanta pastrarea proprietatii de palindrom. Notand cele doua siruri $A$ si {$B$}, pastram $4$ indici: {$p{~1~}$}, {$p{~2~}$}, {$q{~1~}$}, {$q{~2~}$}, reprezentand pozitia ultimului caracter luat din stanga sirului {$A$}, ultimului luat din dreapta sirului {$A$}, ultimului din stanga sirului {$B$}, respectiv ultimului luat din dreapta sirului {$B$}.\r\n\r\nSe iau 4 cazuri de tranzitie intre stari:\r\n\r\n* ({$p{~1~}, q{~1~}, p{~2~}, q{~2~}$}) => ({$p{~1~}+1, q{~1~}-1, p{~2~}, q{~2~}$}), daca {$A[p{~1~} + 1] = A[q{~1~} - 1]$}\r\n* ({$p{~1~}, q{~1~}, p{~2~}, q{~2~}$}) => ({$p{~1~}+1, q{~1~}, p{~2~}, q{~2~}-1$}), daca {$A[p{~1~} + 1] = B[q{~2~} - 1]$}\r\n* ({$p{~1~}, q{~1~}, p{~2~}, q{~2~}$}) => ({$p{~1~}, q{~1~}-1, p{~2~}+1, q{~2~}$}), daca {$B[p{~2~} + 1] = A[q{~1~} - 1]$}\r\n* ({$p{~1~}, q{~1~}, p{~2~}, q{~2~}$}) => ({$p{~1~}, q{~1~}, p{~2~}+1, q{~2~}-1$}), daca {$B[p{~2~} + 1] = B[q{~2~} - 1]$}\r\n\r\nAceasta ne duce la un algoritm de complexitate {$O(|A|^2^ * |B|^2^)$}, ce ar fi asigurat obtinerea a $60%$ din punctaj. Simpla observare a faptului ca este suficienta pastrarea a numai trei indici, in loc de patru, pentru a pastra o stare completa (deoarece {$p{~1~} + p{~2~} = |A| - q{~1~} + 1 + |B| - q{~2~} + 1$}), duce la un algoritm de complexitate $O(|A|^2^ * |B|)$ ce ar fi obtinut punctaj maxim.\r\n\r\nh2. Robotei\r\n\r\nh3. (problema grea clasa a X-a)\r\n\r\nPentru a afla de cate ori trece un robotel prin pozitia (X Y) avem nevoie de urmatoarele informatii:\r\n\r\n# Cate mutari efectuam daca pornim din pozitia ({$X Y$}) si ajungem tot in ({$X Y$}) - lungimea ciclului care cuprinde pozitia ({$X Y$}). Daca pozitia ({$X Y$}) nu se afla pe un ciclu atunci lucrurile se simplifica (acesta este un caz special care se trateaza separat).\r\n# Cate mutari efectueaza fiecare robot pana ajunge in ({$X Y$}). Desigur, pot exista si roboti care nu ajung niciodata in ({$X Y$}).\r\n\r\nAflarea lungimii ciclului (punctul 1.) se face usor, pornind din pozitia ({$X Y$}), efectuand mutari pana se ajunge din nou in pozitia ({$X Y$}). Daca numarul de mutari depaseste $modX*modY$ si nu am atins inca pozitia ({$X, Y$}), atunci aceasta nu se afla pe un ciclu. Complexitatea acestui pas va fi {$O(modX * modY)$}.\r\nPentru a afla, pentru fiecare robot, numarul de mutari pentru a ajunge in ({$X Y$}), putem asocia un graf caroiajului, fiecarei celule din cele $N*N$ corespunzandu-i un nod in graful orientat construit. Pentru fiecare celula ({$i j$}) vom adauga o muchie orientata in acest graf intre nodul corespunzator celulei ({$i j$}) si nodul corespunzator celulei ( {$[i*i + offsetX] modulo modX , [j*j + offsetY] modulo modY$}). Fiecare nod din acest graf va avea gradul de iesire {$1$}, in consecinta, vor fi atatea muchii cate noduri sunt (adica {$N*N$}).\r\nPornind din pozitia ({$X Y$}), efectuam o parcurgere BFS a grafului INVERSAT si vom afla, pentru fiecare nod, care este numarul de mutari pe care trebuie sa le efectuam, pornind din celula corespunzatoare nodului, pentru a ajunge in pozitia ({$X Y$}). Nodurile care nu pot fi vizitate in aceasta parcurgere corespund unor celule din care nu se poate atinge pozitia ({$X Y$}).\r\nComplexitatea acestui algoritm este $O(N*N)$ si obtine $70%$ din punctaj. Pentru a obtine punctaj maxim, observam ca, dupa prima mutare toti roboteii se afla in caroiajul de dimensiuni ({$modX modY$}), si aplicam acelasi algoritm ignorand pozitiile care sunt in afara acestuia. Observatia precedenta ne permite sa afirmam ca daca un robot pleaca din pozitia ({$i, j$}) e ca si cum ar pleca, imaginar, din pozitia ({$i modX, j modY$}). Putem determina cati roboti pleaca (considerandu-i si pe cei care pleaca imaginar) dintr-o celula ({$i j$}) a caroiajului redus, determinand cate solutii au ecuatiile $x {@%@} modX = i$ si $y {@%@} modY = j$ ({$x$} si $y$ necunoscute) in intervalul [{$0..N-1$}].\r\n\r\nh2. PScNv\r\n\r\nh3. (problema simpla clasele XI-XII)\r\n\r\nAceasta problema a fost aleasa asa cum spune si textul pentru faptul ca sunt mai multe abordari ce rezolva problema. O prima abordare ar fi pentru un $k$ fixat sa vedem daca putem ajunge de la nodul start pana la nodul destinatie folosind doar muchii cu cost mai mic sau egal cu {$k$}. Verificarea acestui fapt o facem folosind o cautare in latime. Cat timp nu putem ajunge de la nodul start la nodul destinatie incrementam pe {$k$} si apoi aplicam o cautare in latime. Astfel aflam valoarea {$k$} minima ceruta in problema. Complexitatea acestui algoritm este {$O(kmax (n + m))$}. Daca notam $kmin$ valoarea ceruta in problema, atunci daca fixam un $k$ si nodul destinatie este accesibil din nodul start folosind doar muchii de pondere mai mica sau egale cu $k$ atunci este evident ca {$kmin &le; k$}, iar daca nodul destinatie nu este accesibil atunci {$kmin > k$}. Pe baza acestei observatii putem dezvolta un algoritm ce cauta binar valoarea $kmin$ ce are complexitatea {$O(log kmax (n + m))$}. O alta abordare se bazeaza pe o modificare usoara a algoritmului Dijkstra de drum minim, in care in loc sa pastram drumuri minime, pastram drumuri pt care muchia maxima are valoare cat mai mica. O implementare cu heapuri a acestui algoritm are complexitate {$O(m log n)$}. De asemenea algoritmul Bellman Ford poate fi modificat usor pentru a ne rezolva problema, chiar daca acest algoritm are complexitatea $O(n*m)$ in practica implementarea lui ce foloseste o lista se comporta cu mult mai bine. Ultimele trei rezolvari ar fi luat in jur de $70$ de puncte.\r\n\r\nSolutia oficiala se bazeaza tot pe o varianta a algoritmului Dijkstra, dar care in loc sa foloseasca un heap pentru a determina nodul $i$ inca neexpandat cu drumul de la sursa la el de cost minim, foloseste niste liste. Aceasta abordare este identica cu cea din problema \"Car\":http://infoarena.ro/task/car, si comisia se astepta ca multi concurenti sa rezolve perfect problema, asteptare infirmata de rezultatele din concurs. Cum ponderile muchiilor sunt numere de la $1$ pana la $1000$ inseamna ca in $d[i]$ oricare ar fi nodul $i$ va fi intotdeauna mai mica sau egala cu {$1000$}. Vom folosi astfel $1000$ de liste dublu inlantuite. In lista $i$ vom tine minte nodurile $x$ pentru care {$d[x] = i$}. Cand $d[x]$ se micsoreaza inseram pe $x$ intr-o lista mai mica, dar pentru a il sterge din lista veche vom folosi \"lazy deletion\". Adica atunci cand ajungem la lista $i$ si vrem sa expandam nodul $x$ verificam mai intai daca {$d[x] = i$}, daca nu inseamna ca $d[x] < i$ si nodul $x$ a fost expandat mai devreme, deci putem sa il ignoram. Acest algoritm are complexitate {$O(kmax + n + m)$}.\r\n\r\nComisia a mai discutat posibilitatea de a propune problema folosind un graf neorientat. Atunci o solutie similara algoritmului Kruskal ar fi avut complexitate aproape de cea optima. Am fi putut folosi un radix sort pentru a sorta muchiile, iar apoi sa adaugam muchii in ordine crescatoare la graf pana cand nodul start si nodul destinatie ar fi fost in aceiasi componenta conexa. Pentru a gestiona componentele conexe am fi folosit structuri de multimi disjuncte. Aceasta solutie ar fi avut complexitatea {$O(kmax + m log*n)$}.\r\n\r\nh2. Arbore\r\n\r\nh3. (problema medie clasele XI-XII)\r\n\r\nO prima idee de rezolvare a problemei are o complexitate de $O(1)$ la operatiile de tip update si $O(n)$ la operatiile de tip query. Cand intalnim o operatie de tip 1 este necesar sa folosim un vector $S[1..N]$ in care marcam aceste modificari. Astfel, adunand valoarea $s$ la elementul $S[p]$ vom observa ca suma pe care a primit-o un nod $X$ este de fapt suma valorilor $S[nod]$ unde $nod$ reprezinta indicele nodurilor din drumul lui $X$ pana la radacina arborelui. Deci, pentru o operatie de tipul 1 vom face o singura adunare, iar pentru o operatie de tipul 2 vom efectua o parcurgere in adancime pentru a cauta suma ceruta. Aceasta solutie obtine in jur de $30$ de puncte.\r\n\r\nO alta abordare ar fi reducerea problemei la nivel de vector. Am putea renumerota nodurile arborelui astfel incat subarborele fiecarui nod sa aiba id-uri consecutive. Acest lucru se poate face cu o parcurgere in adancime. Acum trebuie sa efectuam adunari pe intervale compacte de pe un vector, si trebuie sa gasim un element din vector ce are o anumita suma. Acest lucru se poate face, de asemenea in $O(1)$ pentru update si $O(N)$ pentru query usor. Aceasta solutie este mai rapida decat prima, deoarece nu foloseste apeluri recursive ale functiilor si efectueaza un numar mic de operatii. Asa s-ar fi luat $50-60$ de puncte In cazul in care problema s-ar fi redus la nivel de vector dar atat update-ul cat si querry-ul s-ar fi efectuat in $O(n)$ s-ar fi obtinut $30-40$ de puncte..\r\n\r\nSolutia care ar fi obtinut punctajul maxim se bazeaza pe reducerea problemei la nivel de vector, descrisa in paragraful precedent. Fie {$SEC = sqrt(N)$}. Putem imparti vectorul de lungime $N$ in $SEC$ secvente de lungime {$SEC$}. Vom mai folosi 3 vectori $A[1..N]$ reprezentand sumele pe fiecare element ce au fost adunate la inceputul secventelor de lungime {$SEC$}, $C[1..SEC]$ reprezinta sumele ce s-au adunat pe intregile secvente, iar $P[1..SEC][1..1 000 000]$ este o matrice binara unde $P[i][j] = 1$ daca exista un element din secventa $i$ astfel incat {$A[element] = j$}. Aceasta idee ne ajuta sa rezolvam problema intr-o complexitate de $O(sqrt(n))$ atat pentru query cat si pentru update. Pentru ca memoria folosita sa fie rezonabila implementarea matricii $P$ se face pe biti.\r\n\r\nh2. Pedefe\r\n\r\nh3. (problema grea clasele XI-XII)\r\n\r\nProblema cere determinarea numarului de subsiruri comune crescatoare al sirurilor $S1$ si $S2$ , care-l contin pe $S3$ ca subsir. Pentru a rezolva vom folosi metoda programarii dinamice. Se va construi un tabel $A$ cu semnificatia:\r\n$A[k,i,j]$ = cate subsiruri comune crescatoare exista tinand cont doar de primele $i$ valori ale lui {$S1$}, primele $j$ valori ale lui {$S2$}, si care sa contina ca subsir primele $k$ caractere din {$S3$}, iar ultima valoare din aceste subsiruri sa fie {$S1[i]$}. Valorile din tablou se vor calcula doar atunci cand {$S1[i] = S2[j]$}, in rest valorile vor fi {$0$}. In implementare, se vor pastra doar ultimele doua linii din tabloul {$A$}, {$A[k-1]$} si {$A[k]$}.\r\n\r\nIn continuare se vor prezenta mai multe implementari bazate pe aceasta idee cu diferite complexitati si care aduc punctaje diferite.\r\n\r\nh3. Solutia O(N^2^*M^2^*P) - 30 puncte\r\n\r\nPentru a calcula {$A[k, i, j]$} ne vom uita fie in {$A[k-1]$} daca {$S1[i] = S2[j] = S3[k]$}, fie in {$A[k]$} ({$S1[i] = S2[j]$}, {$S1[i] != S3[k]$}). Se vor aduna valorile {$A[k (sau k-1), p, q]$} cu {$p<i$}, {$q<j$} si {$S1[p] &le; S1[i]$}.\r\n\r\nh3. Solutia O(N*M^2*P) - 50 puncte\r\n\r\nSe porneste de la solutia anterioara si se observa faptul ca pentru fiecare $q$ care se considera se poate preprocesa suma {$A[k (sau k-1), p, q]$} pentru $p < i$ intr-un tablou {$S$}. Dupa ce se calculeaza {$A[k, i, j]$} considerand doar acele $q$ pentru care {$S2[q] &le; S2[j]$}, se actualizeza {$S[k, j]$}.\r\n\r\nh3. Solutia O(N*M*P*Sigma) - 75 puncte\r\n\r\nIn cazul cel mai devaforabil numarul de valori distincte din siruri este {$min(N, M)$}, dar se garanteaza in enunt ca $Sigma$ (numarul de valori distincte) este $&le; 20$ pentru inca $25%$ din teste. Pornind de la solutia anterioara, se observa ca , parcurgand {$j$}-ul de la $1$ la {$M$}, nu este necesar sa consideram de fiecare data toate valorile {$q < j$}, aceste informatii putand fi actualizate in {$O(1)$}. Deoarece trebuie sa numaram doar valorile cu {$S2[q] &le; S2[j]$}, se pastreaza intr-un vector {$V[x]$} , suma {$q$}-urilor {$< j$} , cu {$S2[q] &le; x$}. Calculul lui {$A[k,i,j]$} se face in {$O(Sigma)$}, iar dupa aceasta se actualizeaza vectorul $V$ in {$O(1)$}.\r\n\r\nh3. Solutia O(N*M*P*lgSigma) - 100 puncte\r\n\r\nSolutia de $100$ este asemantoare cu solutia de $75$ de puncte, singura diferenta fiind folosirea unui arbore indexat binar pentru a face in $O(lg Sigma)$ operatiile desccrise mai sus.\r\n',961,'public'),('preoni-2006/premii','Sponsori si premii, preONI 2006','2006-11-27 16:14:16','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Sponsori si premii\r\n\r\nh2. Sponsori\r\n\r\n*Mesaj din partea IP Devel*\r\n\r\nLa IP Devel incurajam elevii si studentii talentati in dezvoltarea de solutii informatice. Incurajam talentul si il ajutam prin programe de dezvoltare special concepute.\r\n\r\nStudentii pot astfel sa isi continue studiile si in acelasi timp sa se formeaze profesional, implicindu-se in proiecte interesante, intr-un mediu de lucru tinar si dinamic.\r\n\r\nMai multe detalii puteti vizualiza pe pagina noastra unde va si puteti inregistra pentru a lua parte la un astfel de program.\r\n\r\nh2. Premii\r\n\r\nConcursul *preONI* este recunoscut ca o initiativa indrazneata a catorva elevi si studenti pasionati de informatica, menita sa ii ajute pe cei la fel de pasionati ca si ei in pregatirea pentru performnta. Succesul acestei initiative este dovedit prin complexitatea concursului de la an la an, astfel incat anul acesta, datorita generozitatii sponsorilor, echipa infoarena ofera concurentilor ceva mai mult decat satisfactia rezolvarii problemelor.\r\n\r\nPentru fiecare dintre cele trei grupe, primii 10 elevi din clasament in urma desfasurarilor probelor online vor fi premiati cu o diploma de finalist al concursului *preONI 2006* si o \"tabara\":preoni-2006/finala de pregatire cu cazare si masa asigurate.\r\n\r\nCei 30 de elevi vor avea sansa sa interactioneze cu membrii echipei infoarena si cu ceilalti membrii ai comunitatii infoarena si sa invete de la si impreuna cu acestia. Tabara va fi de asenemea un prilej de a ii rasplati pe cei mai buni dintre cei mai buni. Acest lucru se va face prin organizarea unei runde finale, asemanatoare cu rundele online. Punctajele din acesta runda vor fi independente de cele acumulate la rundele online, iar primii 3 clasati vor avea parte de urmatoarele premii:\r\n\r\n|_. Grupa|_. Locul I|_. Locul II|_. Locul III|\r\n|_. Clasa a IX-a(si gimnaziu)|300 RON|200 RON|100 RON|\r\n|_. Clasa a X-a|300 RON|200 RON|100 RON|\r\n|_. Clasele XI -XII|300 RON|200 RON|100 RON|\r\n\r\n==include(page=\"template/preoni-2006/footer\")==',13,'public'),('template/preoni-2006/rankings','template/preoni-2006/rankings','2006-12-01 18:13:27','==include(page=\"template/preoni-2006/header\")==\r\n\r\np{font-weight: bold}. &larr; \"preONI 2006 Homepage\":preoni-2006\r\n\r\nh1. Clasament preONI 2006, rundele de online de calificare\r\n\r\np={font-weight: bold}. \"Clasa a IX-a si gimnaziu\":preoni-2006/clasament-9 | \"Clasa a X-a \":preoni-2006/clasament-10 | \"Clasele XI-XII\":preoni-2006/clasament-11-12\r\n\r\n',13,'protected'),('stiri/aparitie-editoriala','Aparitie editoriala','2005-03-17 00:00:00','h1. Aparitie editoriala\r\n\r\nEchipa devNet va recomanda cartea \"Fundamentele programarii, clasa a IX-a\" , autori \"Dana Lica\":mailto:danal182001@yahoo.com si \"Mircea Pasoi\":mailto:bogdanpasoi@yahoo.com. Culegerea respecta programa scolara a claselor a IX-a de informatica si isi propune sa reprezinte un instrument util atat in munca de initiere in programare cat si in cea de performanta, cuprinzand peste 100 de probleme pentru concursuri si olimpiade.\r\n\r\nPentru detalii suplimentare privind cartea puteti contacta pe oricare dintre autori (faceti click pe nume pentru adresa de mail).\r\n\r\nh2. Cuprins\r\n\r\n# Capitol 1 \r\nProgramarea structurata si instructiuni in limbajul de programare Pascal/C/C ++\r\n## Structura liniara si alternativa - Instructiunea de atribuire si conditionala\r\n### Teste cu alegere multipla si duala\r\n### Teste cu itemi semiobiectivi\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n## Structuri repetitive - instructiuni repetitive\r\n### Teste cu alegere multipla si duala\r\n### Teste cu itemi semiobiectivi\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n## Probleme de concurs ce proceseaza date simple\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n# Capitol 2 \r\nTipuri de date structurate\r\n## Tabloul unidimensional\r\n### Teste cu alegere multipla si duala\r\n### Teste cu itemi semiobiectivi\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n## Tabloul bidimensional\r\n### Teste cu alegere multipla si duala\r\n### Teste cu itemi semiobiectivi\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n## Fisiere text\r\n### Teste cu alegere multipla si duala\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n## Probleme de concurs ce proceseaza date structurate\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n## Indicatii si raspunsuri\r\n',961,'protected'),('utilizator/wickedman','Profil wickedman','2007-01-26 13:38:29','h2. Contact\r\n\r\n*Atentie!* poti sa ma contactezi in legatura cu bug-uri infoarena:\r\n\r\n* Email: strat.cristian@gmail.com\r\n* YMess: cristi858\r\n* GTalk: strat.cristian\r\n\r\nh2. Despre mine\r\n\r\n* Student in anul III la \"FMI\":http://fmi.unibuc.ro/, Universitatea Bucuresti.\r\n* Co-fondator INNOVATE CONSULT, companie ce ofera produse software dezvoltate in-house, servicii dezvoltare software, comunicatii si retelistica.\r\n* Presedinte al juriului de _Pagini Web_, \"InfoEducatie\":http://infoeducatie.ro/ 2006\r\n* Membru al juriului de _Pagini Web_ \"InfoEducatie\":http://infoeducatie.ro/ 2005, Unirea 2005\r\n* Locurile I, I, II, III la concursul national de software si pagini web \"InfoEducatie\":http://infoeducatie.ro/\r\n* Locul IV ONI 2004\r\n* Calificare in lotul de informatica largit 2004\r\n* Finalist .campion 2004 \r\n* Coordonator infoarena\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* == User(user=\"chucknorris\" type=\"tiny\") ==\r\n* == User(user=\"eval\" type=\"tiny\") ==\r\n',13,'protected'),('stiri/concurs-microsoft-you-can-make-a-difference','Concurs Microsoft: You Can Make a Difference','2005-03-19 00:00:00','h1. Concurs Microsoft: You Can Make a Difference\r\n\r\n\"You Can Make a Difference\" este o competitie pentru elevii de liceu care propun proiecte de aplicatii software adresate entitatilor cu obiect de activitate caritabil. Microsoft pune la dispozitia celor interesati software-ul necesar si suportul tehnic (conectare cu dezvoltatori Microsoft).\r\n\r\nBanii acordati prin acest concurs vor fi folositi in trei directii:\r\n\r\n* bursa pentru elevul/eleva premiat(a).\r\n* resurse financiare pentru implementarea proiectului.\r\n* actualizare, din punct de vedere tehnologic, a scolii din care face parte elevul/eleva premiat(a).\r\n\r\nDead line de inscriere este 30 aprilie. Mai multe informatii gasiti la:\r\n\r\n* \'http://ro.theSpoke.net\':http://ro.theSpoke.net\r\n* \'http://ro.thespoke.net/ycmd/info.aspx\':http://ro.thespoke.net/ycmd/info.aspx\r\n* \'http://ro.thespoke.net/BlogReader/SingleEntry.aspx?ID=1455\':http://ro.thespoke.net/BlogReader/SingleEntry.aspx?ID=1455',1142,'protected'),('preoni-2005/runda-3/solutii','preONI 2005 runda #3 - solutii','2006-11-25 13:51:23','h1. preONI 2005 runda #3 - solutii\r\n\r\n(Categoria _Competitii_, autor(i) _Echipa devNet_)\r\n\r\nArticolul contine ideile de rezolvare ale problemelor propuse la ultima runda a concursului preONI ce s-a desfasurat pe data de 20 martie 2005, cat si comentarii legate de concurs. Si de aceasta data numarul de participanti a fost impresionat, cu siguranta datorita faptului ca in numai 5 zile incepe ONI!\r\n\r\nSetul de probleme a fost mai greu de data aceasta, special pentru a testa concurentii cu probleme cat mai asemanatoare cu stilul ONI. Speram ca fiecare participant a invatat cate ceva in urma acestui concurs si asteptam pareri si sugestii pentru viitor pe \"forum\":http://http://forum.infoarena.ro/.\r\n\r\nh2. Clasele 9-10\r\n\r\nh3. Clasament\r\n\r\n==Rankings(rounds=\"preoni53a\" display_entries=\"6\" pager_style=\"none\")==\r\n\r\nh3. Barman\r\n\r\n(solutie corecta oferita de ==user(user=\"spatarel\" type=\"tiny\")==, 20 noiembrie 2005)\r\n\r\nMetoda folosita este una brute-force si se bazeaza pe cateva observatii. Pentru a determina solutia optima sortam sirul valorilor bauturilor si ii generam toate permutarile circulare in vectorul obt. De aici, problema noastra ramane transformarea de cost minim a vectorului initial a in vectorul obt folosind operatiile permise. Dintre toate permutarile circulare, evident o vom alege pe cea care cere un cost minim al operatiilor. In primul rand se observa ca nu are nici un rost sa deranjam camerele care au bautura ceruta ({$a{~i~} = obt{~i~}$}), deci pe Paftenie nu il vor preocupa acestea. In al doilea rand este de remarcat ca ar fi inutil ca Paftenie sa deplaseze mai mult de un pahar intre doua camere deoarece am considera un caz redundant. De ce? Ar fi libere numai camerele $c{~1~}$ si {$c{~2~}$}, din care provin cele doua pahare de pe tava. Cu doua pahare pe tava ar putea sa mearga intr-o camera $c{~3~}$ diferita de $c{~1~}$ si {$c{~2~}$}, dar ar fi inutil, caci nici pe tava nici in camera nu mai poate depozita vreun pahar.\r\n\r\nAstfel, problema se reduce la a gasi, pentru fiecare bautura care nu se afla pe locul ei, o pozitie optima, pe care daca o asezam, vom obtine un cost global minim. Pentru simplitate, in continuare voi numi \"cuplaj\" mutarea unei bauturi pe o alta masa. Se poate oberva ca problema se poate imparti in mai multe sub-probleme independente: fiecare sub-problema va calcula cuplajul optim pentru toate bauturile de aceeasi valoare. Problemele sunt independente, deoarece pentru a pastra solutia optima globala, trebuie sa cuplam o bautura cu o masa pe care trebuie plasata acelasi tip de bautura.\r\n\r\nO metoda ar fi greedy: pentru fiecare bautura care nu e la locul ei, cautam cea mai apropiata masa pe care se poate pune - insa aceasta metoda este gresita.\r\n\r\nO alta metoda este cuplajul intr-un graf bipatit. Desi aceasta rezolvare este corecta, nu se incadreaza in timpul de executie. Deoarece trebuie efectuate $N$ cuplaje cu cate $2*N$ noduri fiecare, vom obtine o complexitate de {$O(N^5^)$}, supraestimata. Este posibil, totusi, ca in urma unor optimizari puternice, si aceasta metoda sa obtina punctaj mare.\r\n\r\nTotusi, mai exista si o alta metoda mult mai simpla si mai rapida, care se bazeaza pe cateva observatii suplimentare: datorita sortarii pe care am efecutat-o la inceputul algoritmului si a permutarilor circulare, mesele pe care trebuie plasata aceeasi bautura, sunt plasate fie secvential, fie in doua secvente, de la $1$ la $k$ si de la $l$ la {$N$}. De asemenea, deoarece am eliminat cazurile in care {$a{~i~} = obt{~i~}$}, cele doua cazuri, fara a pirde dingeneralitate, se reduc la unul singur: in intervalul $1$ - $k$ exista numai bauturi care trebuie cuplate; in intervalul $k+1$ - $l$ exista numai mese care trebuie cuplate; in intervalul $l+1$ - $N$ exista numai bauturi care trebuie cuplate. (Al doilea caz este simetric, si deoarece mesele pot fi privite ca bauturi, si invers, putem reduce al doilea caz la primmul.)\r\n\r\nProblema se rezolva partitionand mulmimea meselor in doua secvente: mesele din prima secventa se vor cupla cu bauturile din intervalul $1$ - {$k$}, iar mesele din a doua secventa cu bauturile din intervalul $l+1$ - {$N$}. Se poate observa ca oricum s-ar realiza cele doua cuplaje, costul golbal va fi acelasi. In plus, orice alt cuplaj global care nu tine cont de aceasta impartire va obtine un const global mai mare. Astfel, se garanteaza ca aceasta metoda va calcula corect costul minim global.\r\n\r\nAlgoritmul care impleneteaza acest cuplaj este foarte simplu: pentru fiecare bautura care nu se alfa la locul ei ({$a{~i~} = obt{~i~}$}), se cauta prima masa necuplata pe care se poate plasa bautura.\r\n\r\nh3. Cifre\r\n\r\nPentru a afla probabilitatea ceruta trebuie sa aflat cate numere exista in intervalul [{$A..B$}] cu cel putin $K$ cifre de {$C$}. Pentru asta vom construi o functia $f(x)$ care va returna cate numere sunt in intervalul [{$0..x-1$}] care au cel putin $K$ cifre de {$C$}. Astfel rezultatul va fi {$f(B+1)-f(A)$}. Functia $f(x)$ va rula in complexitate $O(lg x)$ parcurgand numarul $x$ cifra cu cifra. Ca sa realizam acest lucru avem nevoie de urmatoarele informatii:\r\n$cnt(i, j)$ = cate numere intre $0$ si $10^i^-1$ contin $j$ cifre de $C$ (vom considera ca numerele pot avea {$0$}-uri in fata, de exemplu: $0003$ are $3$ cifre de {$0$})\r\nAcest numar se poate calcula fie printr-o formula matematica folosind combinari sau cu o relatia de recurenta (independenta de variabila {$C$}):\r\n\r\n* $cnt(i, j) = 9 * cnt(i-1, j) + cnt(i-1, j-1)$\r\n\r\nDe asemenea mai avem nevoie de urmatoarele informatii:\r\n$cnt0(i, j)$ = cate numere care nu au {$0$}-uri in fata intre $0$ si $10^i^-1$ contin $j$ cifre de {$C$}. Relatia de recurenta va fi in functie de {$C$}:\r\n\r\n* daca $C=0$ atunci $cnt0(i, j) = cnt0(i-1, j) + 9 * cnt(i-1, j)$\r\n* altfel $cnt0(i, j) = cnt0(i-1, j) + 8 * cnt(i-1, j) + cnt(i-1, j-1)$\r\n\r\nCele doua matrici au marimi $lgB*K$ deci construirea lor va avea complexitate {$O(lg B*K)$}. Odata disponibile aceste informatii se poate realiza destul de usor functia {$f(x)$}. Nu voi prezenta aici toate detaliile deoarecere apar mai multe cazuri (in special cand {$C = 0$}), lasand ca exercitiu pentru cititor. \r\n\r\nO alta rezolvare posibila ar fi calcularea functiei $f(x)$ in $O(2^lg10(x)^*lg10(x))$ astfel: pe fiecare pozitie intre $0$ si $lg10(x)$ avem doua variante, fie punem cifra {$C$}, fie alta cifra. Pentru fiecare astfel de configuratie cu cel putin $K$ cifre de $C$ se poate determina dintr-o parcurgere cate numere exista $< x$ care au cifre de $C$ in pozitiile respective.\r\n\r\nh3. Farfurii\r\n\r\nProblema cere construirea unei permutari de lungime $N$ cu $K$ inversiuni, minim lexicografica. O prima rezolvare de complexitate $O(N^2^)$ ar fi construirea permutarii element cu element. Cu cat un element este mai mare pe o anumita pozitie cu atat formeaza mai multe inversiuni, astfel ca incercam sa punem pe fiecare pozitie un element cat mai mic astfel: pe pozitia {$i$}, daca $K &le; (N-i)*(N-i-1)/2$ putem pune cel mai mic element disponibil (pentru ca in bucata de $N-i$ ramasa putem construi cel putin {$(N-i)&#0042;(N-i-1)/2$} inversiuni), altfel punem al {$K-(N-i)&#0042;(N-i-1)/2$} element disponibil. Aceasta modalitate de constructie garanteaza ca permutarea este minim lexicografic. O implementare directa, cum am zis, are complexitate $O(N^2)$ si ia {$40-60p$}. Pentru $100p$ se poate folosi un arbore de intervale (ca la problema \"concurs\":http://campion.edu.ro/problems.php?mode=view_round&group_number=3&year=2004&round_number=9 de la .campion 2004, runda 9) reducand complexitate la {$O(N*lg N)$}. O asemenea solutie, desi lua {$100p$}, necesita cunostiinte de structuri de date avansate care depasesc nivelul de cunostiinte general al unui concurent pentru clasele {$9-10$}. O rezolvare $O(N)$ mult mai simpla se bazeaza pe urmatoarea observatie:\r\nO permutare de lungime $i$ are cel mult $i*(i-1)/2$ inversiuni cand numerele sunt in ordine descrescatoare.\r\nAstfel, daca $K$ e de forma $M*(M-1)/2$ permutarea minim lexicografica cu $K$ inversiuni va fi:\r\n\r\n$1, 2, 3, ... N-M, N, N-1, N-2, ... N-M+1$\r\n\r\nCele $K$ inversiuni apar in ultimele $M$ elemente. Daca in aceasta permutare mutam un element $N-x$ imediat inaintea lui $N$ numarul de inversiuni scade cu {$x$}. Astfel, daca $K>M*(M-1)/2$ construim permutarea\r\n\r\n$1, 2, 3, ... N-M-1, N, N-1, N-2, ... N-M$\r\n\r\n(care are $(M+1)*M/2$ inversiuni) si mutam elementul {$N-((M+1)*M/2-K$}) imediat inaintea lui {$N$}, astfel scadem numarul de inversiuni la {$K$}. Este evident ca permutarea astfel construita este minim lexicografica. Algoritmul descris are complexitate {$O(N)$}.\r\n\r\nh2. Clasele 11-12\r\n\r\nh3. Clasament\r\n\r\n==Rankings(rounds=\"preoni53b\" display_entries=\"5\" pager_style=\"none\")==\r\n\r\nSetul de probleme, mai greu de data aceasta, se pare ca a pus in dificultate majoritatea concurentilor. Desi problemele Critice si Poligon nu erau foarte dificile in faza de concepere a algoritmului se pare ca implementarea a fost cea care i-a speriat pe multi dintre participanti. \r\n\r\nh3. Critice\r\n\r\nProblema este o aplicatie a algoritmului de aflare a fluxului maxim dintr-o retea. Se construieste o retea, nodurile fiind adaposturile iar capacitatile muchiilor fiind egale cu rezistentele tunelurilor. Prima solutie, care trece $~ 50%$ din teste, este urmatoarea:\r\n\r\n# Se calculeaza fluxul maxim in reteau construita\r\n# Pentru fiecare muchie (separat) se creste capacitatea ei cu o unitate si se mai ruleaza inca o data algoritmul de flux maximi. Daca fluxul maxim a crescut atunci muchia este critica.\r\n\r\nSe observa ca acest algoritm are o complexitate considerabila si trebuie sa ne gandim la ceva mai bun. Primul lucru inteligent pe care il putem observa este ca muchiile critice sunt muchiile care, dupa ce am rulat odata algoritmul de flux maxim, sunt saturate (am folosit toata capacitatea ei intr-o directie sau cealalta). Totusi nu toate muchiile saturate sunt si critice. Pentru a fi mai exacti, muchiile critice sunt acele muchii saturate care au propietatea ca de la sursa retelei (nodul {$1$}) este drum in graful rezidual (adica graful care ne ramane daca eliminam muchiile saturate) la unul din capetele ei si respectiv de la destinatie (nodul {$N$}) la celalalt capat. Asadar se contureaza algoritmul:\r\n\r\n# Se ruleaza odata algoritmul de flux maxim\r\n# Cu ajutorul a doua parcurgeri a grafului rezidual stabilim pentru fiecare muchie critica daca propietatea este adevarata\r\n\r\nComplexitatea (teoretica) va fi $O(M^2^*N + M)$ dar este supraestimata algoritmul de flux ruland mult mai rapid.\r\n\r\nh3. Ferma\r\n\r\nLa prima vedere, problema pare abordabila cu programare dinamica. O simpla rezolvare care nu tine cont de faptul ca sirul este circular este urmatoarea: $A{~i,j~}$ = productivitatea maxima pentru a face $i$ strangeri din primele $j$ sectoare; evident raspunsul va fi {$A(K, N)$}. Relatia de recurenta:\r\n\r\n* $A{~i,j~}$ = $max (A{~i,j-1~}, A{~i-1,k~} + suma (P{~k~},P{~k+1~}..P{~j~})$ pentru fiecare {$k<j$}, iar $P$ reprezinta vectorul de productivitati.\r\n\r\nO astfel de implementare are complexitate $O(N^2^*K)$ si nu se va incadra in timp. Fie {$S{~i~} = P{~1~}&#0043;P{~2~}&#0043;...&#0043;P{~i~}$}, atunci putem rescrie relatia de recurenta astfel:\r\n\r\n* {$A{~i,j~} = max(A{~i,j-1~}, A{~i-1,k~} + S{~j~} - S{~k~})$}, pentru fiecare $k<j$\r\n\r\nAl doilea termen este de forma $A{~i-1,k~} - S{~k~}$ (termen independent de {$j$}) + {$S{~j~}$}. Astfel din linia $i-1$ a matricii de dinamica pentru fiecare $j$ ne trebuie valoarea maxima $A{~i-1,k~}-S{~k~}$ cu {$k<j$}. O prima idee ar fi ca pe masura ce construim linia i sa inseram elementele din linia $i-1$ intr-un max-heap astfel reducand complexitatea la {$O(N*lgN*K)$}.\r\n\r\nCei care au rezolvat probleme precum \"secventa\":problema/secventa de pe infoarena, \"trans\":problema/trans de la barajul de la ONI 2004 sau divide de la USACO Ianuarie 2005 vor realiza imediat ca putem reduce complexitatea la $O(N*K)$ folosind structura necesara in rezolvarea acelor probleme si anume o coada (in literatura de specialitate se intalneste ca \"deque with heap order\"). Aceasta structura a mai fost tratata si in solutiilor problemelor prezentate mai sus, deci nu voi intra in detalii. Este evident ca un algoritm de complexitate $O(N*K)$ se incadreaza in timp, dar mai apare in calcul faptul ca sirul este circular. Un algoritm $O(N*K)$ care nu trateaza acest lucru ia $40$ de puncte. O prima idee ar fi sa aplicam acelasi algoritm pe fiecare permutare circulara dar se ridica complexitatea iar la {$O(N^2^*K)$}. Aceasta abordare ar trebui sa obtina intre $50$ si $60$ de puncte. Putem trata circularitatea sirului tot in $O(N*K)$ incercand sa obtinem o secventa care contine elemente $N$ si {$1$}. Putem realiza acest lucru astfel:\r\n\r\n* dupa ce realizam prima data dinamica, reinitializam linia $1$ astfel $A{~1,i~} = S{~i~}$\r\n* aplicam din nou dinamica -> de data aceasta algoritmul va fi obligat sa intoarca rezultate care contin neaparat elementul $1$ intr-o secventa din cauza initializarii\r\n* pentru fiecare pozitie $i &le; N$ comparam rezultatul $A{~i,K~}+S{~N~}-S{~i~}$ (adaugam la secventa care il contine pe $1$ o bucata care il contine pe {$N$}) cu cel mai bun obtinut\r\n\r\nAstfel, problema este rezolvabila in complexitate {$O(N*K)$}.\r\n\r\nh3. Poligon\r\n\r\nProblema cere sa determinam cate puncte din cele $M$ sunt in interiorul poligonului. O abordare imediata a acestei probleme ar fi sa determinam pentru fiecare punct in $O(N)$ daca este sau nu in interiorul poligonului. Exista mai multe moduri de a rezolva acest lucru. Un mod ar fi sa ducem o semidreapta pornind din punctul nostru si sa vedem de cate ori intersecteaza laturile poligonului: daca intersecteaza poligonul de un numar par de ori atunci inseamna ca punctul este in exterior, iar daca ea intersecteaza de un numar impar de ori laturile poligonului inseamna ca punctul este in interior. O alta modalitate: calculam suma unghiurilor pe care le fac extremele laturilor cu punctul nostru (unghiurile sunt luate pozitive sau negative dupa cum cele $3$ puncte ce formeaza unghiul sunt in sens trigonometric sau orar), daca suma unghiurilor pentru toate laturile e $0$ atunci punctul e in exteriorul poligonului, iar daca suma unghiurilor e $2*Pi$ atunci punctul e in interiorul poligonului, pentru mai multe detalii puteti\r\nsa va uitati pe urmatoarele pagini: \"[1]\":http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html \"[2]\":http://softsurfer.com/Archive/algorithm_0103/algorithm_0103.htm\r\n\r\nDimensiunile datelor de intrare ne sugereaza ca trebuie sa acceleram determinarea pozitiei punctelor fata de poligon. Daca poligonul ar fi convex, este usor sa facem acest test in {$O(log N)$}: consideram un varf al poligonului si semidrepte ce pleaca din el spre celelalte varfuri, cu cautare binara gasim in ce sector determinat de doua semidrepte intra punctul pentru care vrem sa determinam incluziunea in poligon, dupa ce gasim sectorul testul de incluziune se reduce la determinarea incluziunii intr-un triunghi. Aceasta metoda eleganta si simpla merge pentru poligon convex, dar pentru unul oarecare trebuie sa gasim o alta abordare.\r\n\r\nPentru poligoane concave, mergand pe aceeasi idee, impartirea in zone pentru care este mai usor sa determinam incluziunea se va face un pic diferit. Sortam coordonatele $x$ ale punctelor poligonului si ducem prin fiecare coordonata $x$ distincta cate o dreapta verticala. Se formeaza astfel niste benzi verticale intersectate de laturile poligonului. Pentru fiecare banda tinem minte ce laturi ale poligonului intersecteaza aceasta banda si sortam aceste laturi pe verticala dupa mijlocul segmentului de intersectie al laturii cu banda. Acum pentru a determina daca un punct e in interiorul poligonului, determinam cu cautare binara mai intai banda din care face parte si apoi pentru banda respectiva deasupra cator segmente se afla, daca punctul e deasupra unui numar par de segmente atunci punctul e in exterior si daca e deasupra unui numar impar e interior. Astfel rezolvarea noastra are complexitatea $O(N^2^ log N)$ in faza de preprocesare si $O(log N)$ pentru a determina pentru fiecare punct daca este interior sau\r\nexterior poligonului. Complexitatea totala va fi {$O(N^2^ log N + M log N)$}.\r\n\r\n',961,'public'),('stiri/final-preoni-2005','preONI 2005 s-a incheiat!','2005-03-21 00:00:00','h1. preONI 2005 s-a incheiat!\r\n\r\nRunda #3 a concursului preONI s-a incheiat, impreuna cu intreg concursul preONI 2005! Rezultatele finale au fost publicate si problemele au fost mutate in arhiva dupa ~1h de la expirarea timpului de lucru. ;) Autorii problemelor au publicat un \'articol\':preoni-2005/runda-3/solutii despre aceasta runda, rezultate si idei de rezolvare: . Asteptam parerile si sugestiile tale pe \'forum\':http://forum.infoarena.ro!\r\n\r\nAceasta a fost ultima runda a concursului preONI, editia 2005. Speram ca efortul nostru si al sponsorilor nostri ti-a fost de folos in vreun fel.\r\n\r\nMicrosoft Romania ofera premii primilor 3 participanti de la fiecare grupa. Clasamentul se calculeaza pe baza punctajelor acumulate in runda #2 si #3, punctajele din runda #1 fiind folosite pentru departajare in caz de egalitate.\r\n\r\nh2. Castigatorii editei 2005 sunt...\r\n\r\nh3. Clasele IX - X (\'clasament complet\':preoni-2005/clasament-9-10)\r\n\r\n==Rankings(rounds=\"preoni52a|preoni53a\" display_entries=\"3\" pager_style=\"none\")==\r\n\r\nh3. Clasele XI - XII (\'clasament complet\':preoni-2005/clasament-11-12)\r\n\r\n==Rankings(rounds=\"preoni52b|preoni53b\" display_entries=\"3\" pager_style=\"none\")==\r\n\r\nFelicitari castigatorilor editei 2005! Acestia vor fi contactati prin email in vederea inmanarii premiilor Microsoft. Felicitari tuturor participantilor! Dorim sa multumim sponsorului nostru - Microsoft Romania - precum si D-lui. Prof. Emil Onea, studentului Octavian Costache si tuturor celor care ne-au oferit sugestii si ne-au sprijinit in organizarea editiei 2005 a concursului preONI!\r\n\r\nIti uram mult succes la ONI (by NET) si in continuare!',961,'protected'),('warm-up-2004','Concurs de incalzire','2006-11-24 16:41:40','h1. Concurs de incalzire\r\n\r\nConcursul s-a desfasurat pe 14/11/2004 si a avut 2 grupe si 3 probleme pentru fiecare grupa. Problemele au fost adaugate in \'arhiva\':arhiva, iar un articol cu solutiile este disponibil \'aici\':warm-up-2004/solutii.\r\n\r\nh2. Grupa mica, clasele 9-10 (\'Clasament\':warm-up-2004/clasament-9-10)\r\n\r\n!>warm-up-2004?logo.gif!\r\n\r\n== Tasks(round_id=\"filip1\" pager_style=\"none\") ==\r\n\r\nh2. Grupa mare, clasele 11-12 (\'Clasament\':warm-up-2004/clasament-11-12)\r\n\r\n!>warm-up-2004?logo2.gif!\r\n\r\n== Tasks(round_id=\"filip2\" pager_style=\"none\") ==',1,'protected'),('summer-challenge-2','summer-challenge-doi','2006-11-24 16:42:07','h1. Summer challenge 2\r\n\r\nConcursul s-a desfasurat  Vineri, 11 august 2006, ora 12:00 pe o durata de 5h. S-au propus spre rezolvare 3 probleme. Problemele au fost adaugate in \'arhiva\':arhiva.\r\n\r\nSolutiile problemelor le puteti gasi \"aici\":summer-challenge-2/solutii.\r\n\r\nh2. \'Clasament\':summer-challenge-2/clasament\r\n\r\n!>summer-challenge-2?logo.jpeg!\r\n\r\n== Tasks(round_id=\"summer2\" pager_style=\"none\") ==',961,'protected'),('pregatire-online-pentru-bacalaureatul-la-informatica','Pregatire online pentru bacalaureatul la informatica','2006-11-24 00:34:01','h1. Pregatire online pentru bacalaureatul la informatica\r\n\r\nIncepand de astazi, site-ul \"infoarena\":http://infoarena.ro/ vine in sprijinul elevilor de liceu gazduind un amplu program de pregatire online la disciplina informatica din cadrul examenului de bacalaureat.\r\n\r\nIn cadrul acestui program de pregatire, profesori prestigiosi de informatica din tara vor pune la dispozitia elevilor o lista de subiecte de bacalaureat de doua tipuri:\r\n\r\n# Probleme de informatica; Pentru aceste subiecte, elevii vor trebui sa conceapa si sa redacteze solutii complete intr-un limbaj de programare la alegere. Site-ul dispune de un evaluator automat capabil sa noteze instantaneu solutiile propuse de elevi.\r\n# Teste de tip grila de informatica; Elevii au posibilitatea sa rezolve astfel de teste de tip grila. Ca si la problemele de informatica, raspunsurile trimise se evalueaza pe loc.\r\n\r\nLista de probleme si de teste grila se va imbogati saptamanal iar pe parcursul pregatirii se va construi un clasament al rezolvitorilor de probleme / teste grila.\r\n\r\nMentionam ca participantii le pregatire au posibilitatea sa discute pe marginea materialelor de pregatire si sa solicite explicatii prin intermediul \"forumului\":http://forum.infoarena.ro/.\r\n\r\nSponsorul principal al acestui proiect este \"Microsoft Romania\":http://www.microsoft.com/romania/ - prin intermediul programului \"Parteneri pentru educatie\":http://www.microsoft.com/romania/educatie/.\r\n\r\n',1142,'public'),('preoni-2006/clasament-11-12','Clasament preONI 2006, Clasele XI-XII','2006-12-01 18:14:13','== include(page=\"template/preoni-2006/rankings\") ==\r\n\r\nh2. Clasele XI-XII\r\n\r\n==Rankings(rounds = \"preoni61c|preoni62c|preoni63c|preoni64c\")==',13,'protected'),('faq-pregatire-bacalaureat-2005','F.A.Q. Pregatire bacalaureat 2005','2006-11-23 12:52:05','h1. F.A.Q. Pregatire bacalaureat 2005\r\n\r\n(Categoria _Diverse_, autor(i) _Echipa devNet_)\r\n\r\nAcest articol poate fi considerat ca un ghid pentru programul de pregatire online la disciplina informatica din cadrul examenului de bacalaureat.\r\nCa o completare la acest articol, va recomadam sa accesati si link-ul \"Despre Infoarena\":docs/despre\r\nIn cadrul acestui program de pregatire, profesori prestigiosi de informatica din tara vor pune la dispozitia elevilor o lista de subiecte de bacalaureat de doua tipuri:\r\n\r\n# $Probleme de informatica;$ Pentru aceste subiecte, elevii vor trebui sa conceapa si sa redacteze solutii complete intr-un limbaj de programare la alegere. Site-ul dispune de un evaluator automat capabil sa noteze instantaneu solutiile propuse de elevi.\r\n# $Teste de tip grila de informatica;$ Elevii au posibilitatea sa rezolve astfel de teste de tip grila. Ca si la problemele de informatica, raspunsurile trimise se evalueaza pe loc.\r\n\r\nPentru probleme disponibile in arhiva, rezultatul $evaluarii automate$ poate fi vazut in +monitorul de evaluare+. Acolo veti vedea numarul de puncte obtinute cat si detalii despre evaluare impreuna cu niste timpi de executie orientativi. Mesajele pe care le puteti primi sunt urmatoarele:\r\n\r\n* $OK$ (sau un mesaj asemanator): programul tau a mers corect pe testul respectiv si ai primit punctele care le meritai.\r\n* $Wrong Answer, Raspuns gresit$ (sau un mesaj asemanator): programul tau a terminat executia, dar raspunsul oferit nu a fost corect; verifica daca ai respectat intocmai cum este precizat in enunt formatul fisierului de iesire cat si formatul fisierului de intrare cand efectuezi citirea\r\n* $Time Limit Exceeded:$ programul tau a depasit timpul de executie permis pentru testul respectiv; cele mai dese cauze pentru acest mesaj sunt: algoritmul folosit este ineficient, fie programul tau contine bucle care se executa la infinit, fie programul tau incearca sa citeasca de la tastatura, etc.\r\n* $Missing input/grader$ file (sau un mesaj asemanator): fisierul de intrare sau de verificare lipseste, anunta un membru din echipa devNet (acest mesaj n-ar trebui sa apara!)\r\n* $Missing output file$ (sau un mesaj asemanator): programul tau n-a creat un fisier de iesire, sau in cazul in care a creat un fisier, nu a avut numele specificat in enuntul problemei\r\n* $Runtime error - Invalid memory reference:$ acest mesaj se poate referi la faptul ca depasesti memorie disponibila (care este de 1 MB pentru stiva si 63 MB pentru heap) sau la un acces invalid in memorie, accesarea unui pointer invalid, indecsi intr-un tablou care depasesc dimensiunile tabloului, etc.\r\n* $Runtime error - alt mesaj:$ cele mai cunoscute cauze pentru astfel de mesaje sunt depasirea stivei, accesarea unor fisiere gresite, erori cu numere reale, impartire la 0, etc. Un mesaj foarte intalnit este SIGKILL si semnifica ca programul tau a fost oprit de evaluator datorita unei erori ca cele descrise mai sus.\r\n\r\n+Va recomandam sa consultati acest document periodic+ deoarece va fi actualizat des pentru a raspunde la majoritatea neclaritatilor care pot aparea in utilizarea sistemului de pregatire pentru bacalaureat. De asemenea acest document poate fi folosit si ca un ghid pentru utilizatorii \"Arhivei de probleme pentru concursuri\". Daca aveti alte intrebari care nu sunt raspunse aici nu evitati sa le puneti pe \"forum\":http://forum.infoarena.ro/.\r\n',961,'public'),('preoni-2005/runda-1/solutii','preONI 2005 runda #1 - solutii','2006-11-22 02:21:40','h1. preONI 2005 runda #1 - solutii\r\n\r\n(Categoria _Competitii_, autor(i) _Mircea Pasoi_)\r\n\r\nArticolul contine ideile de rezolvare ale problemelor propuse la prima runda a concursului preONI ce s-a desfasurat pe data de 23 ianuarie 2005, cat si comentarii legate de concurs.\r\n\r\nCum s-a si promis, setul de probleme de data aceasta n-a fost dur, problemele fiind mult mai accesibile, fapt care se vede imediat din punctaje. Spre deosebire de concursurile anterioare in care problemele erau toate de acelasi nivel, de data aceasta a existat o problema usoara, una medie si una grea la fiecare grupa (gen TopCoder).\r\n\r\nToti care am participat la compunerea problemelor suntem de parere ca probleme au fost de nivelul ONI, chiar un pic mai usoare. De asemenea, testele au fost create astfel incat sa se poata obtine 190-200p in mod usor de un concurent cu cunostiinte medii care implementeaza solutii corecte dar care nu se incadreaza complet in limita de timp. Din pacate rezultatele sunt un pic sub nivelul asteptarilor, dar speram ca se vor inbunatati in rundele urmatoare! ;)\r\n\r\nh2. Clasele 9-10\r\n\r\nPrimele $5$ locuri din clasamentul de la $9-10$ arata astfel:\r\n\r\n==Rankings(rounds=\"preoni51a\" display_entries=\"6\" pager_style=\"none\")==\r\n\r\nEste de mentionat faptul ca sub pseudonimul ==user(user=\"macarie\" type=\"tiny\")== se \"ascunde\" echipa care va reprezenta Romania la finala ACM, formata din Mugurel Andreica, Marius Andrei si Ghinea Dan. Ei au concurat pe un singur calculator si au rezolvat toate cele $6$ probleme propuse pentu a simula un concurs ACM. De asemenea, un lucru remarcabil, concurentul clasat pe locul {$2$}, Tataroiu Bogdan este abia clasa a {$7$}-a! Probabil ca va reprezenta Romania la multe IOI-uri :)\r\n\r\nh3. Text\r\n\r\nProblema a fost cea mai usoara din cele $3$ probleme din grupa si rezolvarea nu ar trebui sa ridice mari dificultati nici macar unui elev de a {$9$}-a incepator. Fie $N$ numarul de caractere din fisierul de intrare - voi prezenta o solutie {$O(N)$}. Se parcurge fisierul caracter cu caracter (nu este necesara stocarea datelor de intrare intr-un vector) si se mentin doua variabile care indica pozitia de inceput si sfarsit a ultimului cuvant detectat pana in prezent, daca s-a gasit vreunul. De asemenea se pastreaza si doua variabile pentru suma lungimilor cuvintelor si numarul de cuvinte pentru a calcula rezultatul. Atentie insa ca la sfarsitul parcurgerii fisierului de iesire, daca ultimul caracter citit a fost o litera mare sau mica, sa se actualizeze numarul de cuvinte si suma lungimilor.\r\n\r\nh3. Trapez\r\n\r\nProblema a fost cea de nivel mediu din cele $3$ si face apel la cunostiinte minime de geometrie. Conditia ca oricare trei puncte nu sunt coliniare simplifica mult rezolvarea. Din definitie, un trapez are cel putin doua laturi paralele deci se poate construi urmatorul algoritm: se iau toate perechile de puncte - acestea determina cate un segment - si sorteaza in functie de unghiul cu axa OX (panta dreptei). Pentru fiecare $k$ segmente cu acelasi unghi se pot forma {$Comb(k,2)$} trapeze. Pentru a evita calculele cu reale (care pot cauza erori de precizie), se tin pantele ca perechi de numere intregi ({$y, x$}), fara a efectua efectiv impartirea {$y/x$}. Pentru compararea a doua astfel de perechi sunt necesare tipuri de date pe $64$ de biti. Algoritmul descris are complexitate {$O(N^2^*lg N)$}. Las ca exercitiu rezolvarea acestei probleme folosind un algoritm $O(N^2^)$ care foloseste \"hashing\":http://www.infoarena.ro/Hashing (vezi articolul de pe site). Se puteau obtine $40-50p$ cu un algoritm brut {$O(N^4^)$}.\r\n\r\nh3. Subsir\r\n\r\nAceasta problema, care a fost si cea mai grea, a fost prezenta si la CEOI 2003, dar intr-o forma mai simpla. Acolo se cerea generarea efectiva a tuturor subsirurilor , nu numararea lor, si se garanta ca numarul lor este sub {$1000$}. Orice solutie care ar fi luat $100p$ la problema de la CEOI ar fi obtinut $50p$ la aceasta (primele $5$ teste fiind de fapt preluate de la CEOI 2003). Cum multi probabil au intuit, rezolvarea se bazeaza pe programare dinamica. Voi numi cele doua siruri $A$ si {$B$}, de lungime {$N$}, respectiv $M$ si voi construi initial matricea $C{~i,j~}$ = lungimea celui mai lung subsir comun al sirurilor {$A{~1..i~}$} si {$B{~1..j~}$}. Acest lucru se poate face in $O(N*M)$ si este o aplicatie clasica a programarii dinamice (se gaseste in foarte multe carti explicata ideea). In continuare voi numara sirurile folosind un algoritm $O(N*M*Sigma)$ unde $Sigma$ este numarul litere din care pot fi formate sirurile, adica {$26$}. Se va calcula o matrice $Nr{~i,j~}$ = cate subsiruri comune de lungime maxima existe pentru sirurile $A{~1..i~}$ si\r\n$B{~1..i~}$ (evident modulo {$666013$}). Se calculeaza $Nr{~i,j~}$ doar atunci cand {$A{~i~} = B{~i~}$}, astfel: pentru fiecare caracter $c$ intre \'{$a$}\' si \'{$z$}\' se cauta ultima sa aparitie in sirul $A{~1..i-1~}$ (fie aceasta pozitia {$ii$}) si ultima sa aparitie in sirul $B{~1..j-1~}$ (fie aceasta pozitia {$jj$}). Acest lucru se poate face in $O(1)$ daca se preproceseaza inainte aceste informatii in {$O((N+M)*Sigma)$}. Daca $C{~i,j~} = C{~ii,jj~}+1$ se va aduna $Nr{~ii,jj~}$ la $Nr{~i,j~}$ - aceasta conditie ne garanteaza ca subsirurile adaugate au lungime maxima, iar faptul ca $ii$ si $jj$ reprezinta ultima aparitie a caracterului garanteaza ca nu se vor numara subsiruri identice. Pentru a gasi rezultatul final se aduna toate valorile $Nr{~i,j~}$ calculate, cu urmatoarea exceptie: daca exista pozitiile $x$ si $y$ astfel incat {$A{~x~} = A{~i~} = B{~y~} = B{~j~}$}, se aduna $Nr{~i,j~}$ doar daca $x < i$ si $y < j$ (pentru a asigura ca nu se numara subsiruri identice de mai multe ori).\r\n\r\nh2. Clasele 11-12\r\n\r\nPrimele 5 locuri din clasamentul de la 11-12 arata astfel:\r\n\r\n==Rankings(rounds=\"preoni51b\" display_entries=\"6\" pager_style=\"none\")==\r\n\r\nh3. Iepuri\r\n\r\nProblema a fost cea mai usoara din cel $3$ si necesita cunostiine elementare de matematica de clasa a 11-a. Daca se noteaza cu $I{~n~}$ cati iepuri sunt in ziua $n$ se deduc urmatoarele relatii din enunt:\r\n\r\n* $I{~0~}=X, I{~1~}=Y, I{~2~}=Z$\r\n* $I{~n~}=A*I{~n-1~} + B*I{~n-2~} + C*I{~n-3~}$ pt 3 &le; n\r\n\r\nRezultatul cerut este $I{~N~}$ modulo $666013$ pentru fiecare test.\r\nO prima rezolvare, si cea mai simpla, este implementarea directa a relatiei de recurenta si conduce la o complexitate $O(N)$ pe set de date. Aceasta abordare ar fi obtinut {$50p$}.In continuare voi descrie o rezolvare $O(lg N)4 care foloseste matrici. Se construieste matricea:\r\n\r\np(pre). \r\n    [0 1 0]\r\nM = [0 0 1]\r\n    [C B A]\r\n\r\ncare sta la baza relatiei:\r\n\r\np(pre). \r\n    [I{~0~}]   [I{~N&nbsp;&nbsp;~}]\r\nM * [I{~1~}] = [I{~N+1~}]\r\n    [I{~2~}]   [I{~N+2~}]\r\n\r\nDin asta se deduce:\r\n\r\np(pre). \r\n&nbsp;&nbsp;&nbsp;&nbsp; [I{~0~}]   [I{~N&nbsp;&nbsp;~}]\r\nM^N^ * [I{~1~}] = [I{~N+1~}]\r\n&nbsp;&nbsp;&nbsp;&nbsp; [I{~2~}]   [I{~N+2~}]\r\n\r\n\r\nastfel problema se reduce la a calcula $M^N^$ in {$O(lg N)$}. Algoritmul de ridicare la putere in timp logaritmic este clasic si nu-l mai mentionez aici.\r\n\r\nh3. Barbar\r\n\r\nProblema este de nivel mediu si necesita cunostiinte elementare de teoria grafurilor. Se considera matricea initiala un graf cu $R*C$ noduri, mai putin zidurile. Se face o parcurgere BF pentru a determina pentru fiecare casuta din matrice distanta pana la cel mai apropiat dragon. Astfel, se incepe BF-ul cu toate nodurile care corespund dragonilor inserate in coada (deci nu va fi doar un nod in coada la inceput). Complexitatea acestui pas este {$O(R*C)$}. Se observa daca exista un traseu valid care trece prin casute situate la distanta $&ge;x$ fata de cel mai apropiat dragon, atunci exista in mod evident un traseu valid care trece prin casute situate la distanta $&ge;x-1$ fata de cel mai apropiat dragon. Aceasta observatie duce la folosirea cautarii binare a rezultatului (vezi articolul de pe site pentru alte aplicatii). Pentru a verifica daca exista un traseu valid care trece doar prin casute situate la o anumita distanta fata de cel mai apropiat dragon se foloseste tot o parcurgere BF, astfel rezolvarea fiind\r\n{$O(R*C*lg(R*C))$}.\r\n\r\nh3. ADN\r\n\r\nLa primul pas se elimina toate cuvintele incluse in alte cuvinte mai mari (pentru a cauta daca exista un cuvant in alt cuvant se foloseste algoritmul KMP pentru incadrarea in timp - vezi articolul de pe site). Apoi, se construieste un graf cu noduri cuvintele si muchii intre oricare doua cuvinte. Costul unei muchii ({$i, j$}) va fi cel mai lung sufix al cuvantului $i$ care este prefix al cuvantului $j$ (informatie care se poate determina cu KMP), adica cate litere sunt \"inutile\" daca lipim cuvantul $i$ cu cuvantul {$j$}. Aceasta prima etapa are complexitate {$O(N^2^*L)$}, unde $L$ e lungimea maxima a unui cuvant. Deoarece trebuie sa existe fiecar cuvant in sirul rezultat, iar sirul sa fie de lungime minima problema se reduce la determinarea unui lant hamiltonian de cost maxim, problema care este binecunoscuta ca fiind {$NP$}. Un algoritm care incearca toate cele $n!$ permutari are complexitate $O(n!)$ si va obtine {$50p$}. Pentru punctaj maxim vom folosi programare dinamica astfel: fie {$A[i][(n{~1~}, n{~2~}.. n{~k~})]$} = costul unui lant hamiltonian de cost maxim care incepe din nodul $i$ si trece prin nodurile {$n{~1~}, n{~2~} .. n{~k~}$}. Relatia de recurenta este: {$A[i][n{~1~},n{~2~}..n{~k~})]$ = {$max cost(i, n{~j~}) + A[n{~j~}][(n{~1~},n{~2~},n{~j-1~},n{~j+1~}..n{~k~})]$} pentru fiecare {$j$}. Dinamica se initializeaza cu $A[i][(i)] = 0$ pentru fiecare {$i$}. Reprezentarea multimilor de noduri se face folosind un numar binar cu $N$ biti, astfel complexitatea acestei etape fiind {$O(N^2^*2^N^)$}. Mentionez ca aceasta rezolvare nu produce solutia minim lexicografic, fapt observat in timpul concursului si astfel s-a reevaluat problema dandu-se puncte pentru orice solutie valida, nu neaparat minim lexicografic. Rezolvarea problemei cu cerinta de minim lexicografic este posibila, dar pentru realizarea ei trebuie folosite structuri de date avansate ca Suffix Arrays sau Suffix Trees si nivelul de dificultate ar fi mult mai mare. Alta observarie este ca matricea cost ar putea fi calculata mai repede daca am folosi structurile mentionate mai devreme. Folosind prima structura am avea complexitatea $O( N*L log (N*L))$ iar a folosind a doua structura am avea complexitatea $O(N*L)$ . De asemenea mentionam posibilitatea folositii algoritmului randomizat de potrivire a sirurilor de caractere numit Rabin Karp pentru calcularea matricii cost ceea ce ar fi dus la o solutie mai scurta si la un cod mai clar. Ne cerem scuze pentru eventualele neplaceri cauzate de aceasta situatie.\r\n\r\nBafta la urmatorul concurs! (undeva prin februarie...)\r\n',1,'public'),('stiri/rezultate-ioi','Rezultate IOI','2006-08-19 00:00:00','h1. Rezultate IOI\r\n\r\nIata rezultatele de la Olimpiada Internationala de Informatica din Mexic:\r\n\r\n|{background-color:gold}. Mircea Pasoi |{background-color:gold}. aur |\r\n|{background-color:gold}. Codrut Grosu |{background-color:gold}. aur |\r\n|{background-color:silver}. Tiberiu Florea |{background-color:silver}. argint |\r\n|{background-color:#9C6963}. Adrian Vladu |{background-color:#9C6963}. bronz |\r\n\r\nFelicitari echipei Romaniei si multe succese in continuare!',18,'protected'),('problema/pavare','Pavare','2006-11-24 16:22:28','==Include(page=\"template/taskheader\" task_id=\"pavare\")==\r\n\r\nGigel, primar in orasul sau, s-a gandit sa renoveze strada principala, strada de dimensiuni $M*N$ compusa din bucati de dimensiuni $1*1$. Majoritatea bucatilor sunt stricate, dar mai exista $K$ bucati care sunt considerate bune. Dorind sa plateasca cat mai putini bani, Gigel a luat de la un negustor blocuri de dimensiuni $2*2$ la pretul unui bloc de dimensiuni $1*1$. Pentru a pava strada trebuie sa amplaseze cat mai multe din aceste blocuri pe bucati stricate, fara sa paveze vreo bucata buna deoarece ar aparea denivelari, si fara sa se suprapuna blocurile $2*2$. El si-a dat seama ca mai bine ar fi cumparat blocuri $1*1$, pentru ca ar fi acoperit toata strada fara batai de cap, dar acum nu mai are de ales si are nevoie de ajutorul tau!\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul maxim de blocuri $2*2$ pe care le poate pune primarul pentru a repara strada.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie din fisierul $pavare.in$ se vor afla trei numere intregi separate prin cate un spatiu: $N, M$ si $K$. Pe urmatoarele $K$ linii se vor afla perechi de numere intregi reprezentand linia si coloana pe care se afla o bucata buna.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie in fisierul $pavare.out$ se va afla un numar natural reprezentand numarul maxim de blocuri $2*2$ care pot fi amplasate pe strada.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 150$\r\n* $1 &le; M &le; 15$\r\n* $1 &le; K &le; N*M$\r\n* Liinile sunt numerotate de la $1$ la $N$, iar coloanele de la $1$ la $M$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. pavare.in |_. pavare.out |\r\n| 4 6 3\r\n1 1\r\n2 6\r\n3 3 | 4 | \r\n\r\nh3. Explicatie\r\n\r\nAcesta este un amplasament posibil al blocurilor:\r\n!problema/pavare?untitled.gif! \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"pavare\")==',1142,'task: pavare'),('usaco-nov-2005-divizia-gold','USACO nov 2005, divizia GOLD','2006-11-22 02:29:35','h1. USACO nov 2005, divizia GOLD\r\n\r\n(Categoria _Competitii_, autor(i) _Adrian Diaconu_)\r\n\r\nEtapa din noiembria a fost una destul de usoara cu $17$ punctaje maxime printre care si $3$ romani:\r\n\r\n* Tiberiu Florea\r\n* Catalin Tiseanu \r\n* Adrian Vladu\r\n\r\n\"Teste si enunturile\":http://www.infoarena.ro/downloads?action=download&file=usaco_nov05.zip problemelor sunt disponibile in sectiunea Download.\r\n\r\nh2. Asteroids\r\n\r\nVom rezolva aceasta problema folosind un algoritm de cuplaj maxim. Se va construi un graf bipartit in care vom avea pe o parte coloanele matricii ({$1..n$}) pe cealalta liniile matricii ({$1..m$}). Vom avea muchie de la o linie la o coloana daca in pozitia respectiva se afla un bolovan ce trebuie distrus. Graful astfel construit va avea $n+m$ noduri si $k$ muchii (locurile unde sunt plasati bolovanii). Problema se reduce astfel la determinarea unui suport minim pe un graf bipartit care este echivalenta cu gasirea cuplajului maxim pe acest graf. Suportul minim inseamna o multime de noduri de cardinal minim astfel incat fiecare muchie are cel putin un capat in multime.\r\n\r\nPentru cei care nu sunt familiarizati cu algoritmul de cuplaj pot folosi un algoritm de flux maxim adaugand o sursa virtuala legata de toate nodurile ce reprezinta coloanele si o destinatie legata de toate nodurile ce reprezinta liniile. Capacitatile vor fi toate {$1$}. Fluxul maxim astfel determinat va fi egal cu cuplajul maxim. Complexitatea algoritmului de flux este $O(Flux*(nr_noduri+nr_muchii))$ si avand in vedere faptul ca fluxul poate fi maxim $n$ (deoarece o coloana nu se poate cupla de doua ori) se ajunge la {$O(n*(n+m+k))$}.\r\n\r\nh2. Grazing on the Run\r\n\r\nRezolvarea acestei probleme se face folosind metoda programarii dinamice. Se vor sorta coordonatele la care se afla lucrurile pe care doreste Bessie sa le culeaga apoi se vor construi matricile $min{~i,j,k~}$ si $timp{~i,j,k~}$ care vor avea urmatoarele semnificatii:\r\n\r\n* $min{~i,j,k~}$ - va retine costul necesar culegerii lucrurilor de pe pozitiile $i, i+1, ... , j$ la care se adauga timpul la care s-s terminat culesul acstor lucruri inmultit cu numarul de obiecte ramase ( $N - i + j - 1$ ) deoarece la acestea se va ajunge minim la timpul respectiv. $K$ va avea valoare $0$ sau $1$ in functie de capatul la care se afla Bessie la final ( stanga respectiv dreapta)\r\n* $timp{~i,j,k~}$ - va retine timpul necesar culegerii obiectelor $i, i+1, ..., j$ pentru a obtine minimul din $min{~i,j,k~}$\r\n\r\nSe observa ca in configuratia ({$i,j,k$}) se ajunge din starile ({$i,j-1,1$}), ({$i,j-1,0$}), ({$i+1,j,1$}), ({$i+1,j,0$}). Complexitatea de completare a matricii va fi {$O(n^2^)$}, in finala afisad minimul dintre {$min{~1,n,0~}$},{$min{~1,n,1~}$}. Memoria necesara va fi de $O(n)$ deoarece procesand matricea in ordinea cresterii lungimii intervalului ({$i,j$}) ne va fi necesara doar coloana precedenta.\r\n\r\nh2. Walk the Talk\r\n\r\nVom rezolva independent problema pentru fiecare cuvant aflat in dictionar. Vom nota $a{~i,j~}$ matricea cu litere, iar s{~i~} cuvantul pe care il analizam la un anumit moment, acesta avand lungimea {$L$}. Vom construi matricea $sum{~i,j,k~}$ in care se va retine numarul de moduri in care se obtine secventa $s{~1~}, s{~2~}, ... , s{~k~}$ folosind doar dreptungiul cu colturile in ({$1,1$}) si ({$i,j$}) din matricea de litere. Pentru a calcula configuratia ({$i,j,k$}) se numara intai cate se obtin pentru secventa $1..k$ pentru dreptunghiul respectiv fara a considera casuta $(i,j)$ ({$sum{~i-1,j,k~}+sum{~i,j-1,k~}-sum{~i-1,j-1,k~}$}) apoi daca avem $a{~i,j~}=s{~k~}$ adunam cate solutii avem pentru secventa $1..k-1$ pentru dreptunghiul respectiv mai putin casuta $(i,j)$ ({$sum{~i-1,j,k-1~}+sum{~i,j-1,k-1~}-sum{~i-1,j-1,k-1~}$}). In final solutia se va afla in {$sum{~n,m,L~}$}. Complexitatea construirii fiecare configuratii in parte este $O(1)$ deci in total va fi {$O(n*m*L)$}. Memoria necesara este {$O(n*m*L)$}, dar aceasta se poate reduce la $O(n*m)$ daca luam in considerare faptul ca la fiecare moment ne este necesar doar numarul de solutii pentru o secventa cu $1$ mai mica.\r\n\r\n',1,'public'),('usaco-dec-2005-divizia-gold','USACO dec 2005, divizia GOLD','2006-11-22 02:30:30','h1. USACO dec 2005, divizia GOLD\r\n\r\n(Categoria _Concursuri_, autor(i) _Daniel Pasaila, Mircea Pasoi_)\r\n\r\nIn acest articol veti gasi solutiile pentru problemele propuse la concursul USACO, editia din luna decembrie 2005, divizia GOLD. \"Teste si enunturile\":http://www.infoarena.ro/downloads?action=download&file=usaco.zip problemelor sunt disponibile in sectiunea Download.\r\n\r\nh2. Cow Patterns\r\n\r\nSolutia propusa in acest articol foloseste un algoritm de genul Rabin Karp. In aceasta problema alfabetul folosit este {$Sigma = {1, 2, ... S}$}, deci putem privi un sir de $K$ caractere consecutive ca reprezentand un numar in baza $S$ de lungime {$K$}. Spunem ca modelul este vectorul $P[1..K]$ iar textul dat este {$T[1..N]$}.\r\n\r\nFiind dat modelul $P[1..K]$ notam cu $p$ valoarea sa corespunzatoare in baza {$S$}. Intr-o maniera similara, fiind dat textul {$T[1..N]$}, notam cu $t{~s~}$ valoarea in baza $S$ a subsirului convertit {$T[s + 1...s + m]$}. In cazul in care gasim un subsir cu valoarea $t{~s~} = p$ atunci am gasit o potrivire a modelului pe text. Dificultatile care apar in rezolvarea problemei tin de convertirea sirului $T$ in timp real, dupa conditiile impuse de enuntul problemei. Astfel, ne deplasam cu un sablon de lungime $K$ spre dreapta. Pentru fiecare deplasament trebuie sa modificam valoarea $t{~s~}$ corespunzator. La deplasarea cu o pozitie apar urmatoarele cazuri:\r\n\r\n# din sablon iese o valoare unica sau intra o valoare care nu exista in deplasamentul curent.\r\n# din sablon iese o valoare care va exista si in deplasamentul urmator, si intra o valoare care exista deja in deplasamentul curent\r\n\r\nVom rezolva cazul $1$ in {$O(K)$}, convertind subsirul curent dupa regulile din enunt. Observam ca in cazul $2$ dupa efectuarea deplasamentului sablonul va contine aceleasi cifre. Aceasta operatie este deci doar o deplasare, deci o putem efectua in $O(1)$ exact ca la Rabin Karp.\r\n\r\nDesi complexitatea algoritmului pare ca este {$O(N * K)$}, la o analiza mai atenta ne dam seama ca ea este de fapt {$O(N * S)$}. Sa incercam sa calculam de cate ori poate aparea cazul $1$ in deplasare. Trebuie sa observam ca un element odata intrat in sablon mai poate genera cazul $1$ abia dupa $K$ elemente, deci numarul total in cel mai defavorabil caz este {$N/K * S$}. Complexitatea algoritmului devine acum $O(K * N/K * S + N)$ deci {$O(N * S)$}.\r\n\r\nLa implementare, toate operatiile se fac modulo $Q$ (unde $Q$ este un numar prim destul de mare). Acum poate vi se pare ca de fiecare data cand $t{~s~} = p$ ar trebui sa comparam in $O(K)$ cele doua subsiruri, complexitatea totala crescand. O analiza probabilistica ne arata ca pentru $Q$ prim si destul de mare sansele ca doua subsiruri diferite de lungime $K$ sa fie echivalente modulo $Q$ sunt foarte mici, deci o solutie care compara doar modulele numerelor va lua punctajul maxim fara probleme.\r\n\r\nh2. Barn expansion\r\n\r\nDupa cum au aratat-o si rezultatele, aceasta problema a fost cea mai simpla din concurs. Trebuie sa determinam numarul de dreptunghiuri a caror laturi nu intalnsesc laturile altor dreptunghiuri. De asemenea, sa nu uitam ca dreptunghiurile nu se pot suprapune. In aceste conditii observam ca daca doua dreptunghiuri se intersecteaza atunci se vor intersecta si $2$ segmente verticale sau $2$ segmente orizontale. Putem astfel sa luam mai intai toate segmentele verticale, vedem care dintre acestea se intersecteaza cu altele si marcam dreptunghiurile lor ca fiind rele. Repetam algoritmul si pentru segmentele orizontale, iar la sfarsit numaram cate dreptunghiuri bune ne-au ramas.\r\n\r\nProblema pe care trebuie sa o rezolvam acum este urmatoarea: avand $K$ segmente paralele cu axa Oy trebuie sa determinam care dintre acestea se intersecteaza cu altele. Pentru aceasta sortam segmentele in primul rand dupa coordonata $x$ si in al 2-lea rand dupa coordonata $y$ minima. Dupa aceasta sortare putem determina in $O(K)$ segmentele care se intersecteaza. Parcurgem vectorul de la stanga la dreapta, si pentru fiecare pas vedem daca segmentul curent se intersecteaza cu un segment precedent. Pentru aceasta trebuie sa tinem o variabila ls care reprezinta coordonata $y$ maxima atinsa pana la un moment dat. Pentru segmentul $i$ fie {$ymin{~i~}$}, $ymax{~i~}$ si $x{~i~}$ coordonatele lui. Pentru un $i$ daca $x{~i~} != x{~i-1~}$ sau $ymin{~i~} > ls$ initializam $ls$ cu {$ymax{~i~}$}. Altfel marcam segmentul $i$ si segmentul cu care am obtinut maximul $ls$ ca fiind rele, iar $ls$ devine {$MAX (ls, ymax{~i~})$}.\r\n\r\nProblema se rezolva similar si pentru segmentele orizontale. Complexitatea algoritmului este {$O(N logN)$}.\r\n\r\nh2. Layout\r\n\r\nVom nota pozitiile celor $N$ vaci cu $x{~1~}, x{~2~} ... x{~N~}$ si vom transforma fiecare relatie care se da intr-o constrangere de forma {$x{~i~} - x{~j~} &le; C$}. Cum se impune din enunt ca {$x{~1~} &le; x{~2~} &le; ... &le; x{~N~}$}, vom introduce initial constrangeri de forma {$x{~i~} - x{~i+1~} &le; 0$} ({$i < N$}). Apoi, pentru fiecare perechi de vaci $i < j$ care trebuie sa fie la distanta maxim {$D$}, vom introduce constrangerea {$x{~j~} - x{~i~} &le; D$}, iar pentru fiecare pereche $i < j$ care trebuie sa fie la distanta de minim {$D$}, vom introduce constrangerea {$x{~i~} - x{~j~} &le; -D$}. Trebuie acum sa rezolvam acest sistem de constrangeri.\r\n\r\nMotivul pentru toate constrangerile sunt de forma {$x{~i~} - x{~j~} &le; C$} , este pentru a modela aceasta problema folosind teoria grafurilor. Vom considera vacile ca fiind noduri de la $1$ la {$N$}, iar fiecare constrangere {$x{~i~} - x{~j~} &le; C$} va reprezenta o muchia de la $j$ la $i$ cu costul {$C$}. In acest graf vom determina distantele minime de la $1$ la fiecare nod intr-un vector {$D$}. Din definitia distantelor minime in grafuri , pentru o muchie ({$j, i$}) de cost $C$ se respecta relatia {$D{~i~} &le; D{~j~} + C$}, echivalenta cu {$D{~i~} - D{~j~} &le; C$}. Asadar vectorul $D$ va respecta fiecare constrangere formulata anterior pentru vectorul {$x$}. \r\n\r\nFiindca graful este rar ({$MD+ML+N-1$} muchii), se va folosi algoritmul Bellman-Ford pentru determinarea distantelor mimine, avand complexitatea O({$N*(MD+ML+N)$}). Modul in care lucreaza algoritmul Bellman-Ford asigura ca distanta dintre vaca $1$ si vaca $N$ este maximizata. Cazul cand vacile puteau fi asezate oricat de departe se putea detecta verificand daca distanta pana la vaca $N$ este infinit. De asemenea, cazul cand problema nu avea solutie putea fi detectat tot cu Bellman Ford, verificand daca exista un ciclu de cost negative accesibil din nodul {$1$}. Demonstratia ca atunci cand graful contine un ciclu negativ nu exista solutie o lasam pe seama cititorului.\r\n\r\n',1,'public'),('stiri/rezultate-summer-challenge-doi','Rezultate Summer Challenge Doi','2006-08-11 00:00:00','h1. Rezultate Summer Challenge Doi\r\n\r\nIata ca s-a incheiat si \'Summer Challenge Doi\':summer-challenge-doi. Desi este vara si majoritatea petrec pe la munte sau pe la mare s-au gasit destui concurenti care sa isi faca timp si pentru acest antrenament.\r\n\r\nIata primii 6 clasati in urma evaluarii:\r\n\r\n==Rankings(rounds=\"summer2\" display_entries=\"6\" pager_style=\"none\")==\r\n\r\nFelicitari tuturor participantilor si va asteptam la concursurile viitoare de pe infoarena. Intre timp va puteti antrena cu problemele din {\"arhiva\":http://infoarena.ro/arhiva-probleme}.\r\n\r\nSolutiile oficiale le gasiti {\"aici\":http://www.infoarena.ro/Solutii_Summer_Challenge_Doi}.',1142,'protected'),('preoni-2006/runda-4/solutii','Solutii preONI 2006, Runda a 4-a','2006-11-25 13:35:42','h1. Solutii preONI 2006, Runda a 4-a\r\n\r\n(Categoria _Competitii_, autor(i) _Echipa infoarena_)\r\n\r\nSuntem bucurosi sa va anuntam ca Runda a 4-a concursului preONI 2006 s-a incheiat. In acest articol va vom prezenta solutiile oficiale ale celor 7 probleme propuse precum si cateva aprecieri dupa cele patru probe de foc.\r\n\r\nS-a consumat si al patrulea act al bataliei si odata cu el si etapa on-line a concursului preONI. S-a tras linia si s-au desemnat \"fericitii calificati in runda finala\":preoni-2006/clasament (atentie! verificarea inca nu a fost facuta, dar cu asta ne vom ocupa in urmatoarea perioada).\r\n\r\nAruncandu-ne ochii pe clasamentele Rundei 4, constatam ca participantii au tras tare pe ultima suta de metri vrand sa ne contrazica previziunile sumbre dupa Runda 3. Desi nivelul de dificultate al problemelor a fost un pic mai scazut fata de runda precedenta, concurentii s-au dovedit mult mai conectati la concurs - suspectam ca apropierea olimpiadelor ar fi cauza. Asadar am avut punctaje aproape maxime $(275, 255)$ obtinute in viteza maxima de primii doi clasati la clasa a 9-a - $Bogdan Tataroiu$ si $Sima Mihai Cotizo$, un punctaj maxim la clasa a 12-a realizat de $Costea Andrei$ care a reusit, dupa un start mai putin reusit in rundele precedente, sa treaca la pas pe langa ceilalti info-atleti, unii dintre ei deja nume mari. De data aceasta, concurentii de la clasa a 10-a nu s-au lasat mai prejos fata de celelalte grupe de varsta si, avand un set clar mai usor decat precedentul, au adunat in ritm de maraton punctaje frumoase care au atins si depasit limita (legal admisa) de $200$. Felicitari pentru aceasta realizare lui $Vlad Dumitriu$ si $Bogdan Stoica$. In concluzie, am asistat la un concurs bine organizat (felicitari comisiei!) si la un sprint de sanatate din partea concurentilor (felicitari mai ales lor!) care ne-au convins inca o data ca tinerii nostri sunt pregatiti sa fuga mancand pamantul pentru gloria si renumele olimpiadelor nationale si internationale.\r\n\r\nUna peste alta, s-a incheiat o etapa frumoasa a concursului in care am pus mult suflet. Normal, pot fi doar 30 de participanti fericiti de rezultate. Ii felicitam pe cei calificati si abia asteptam sa-i vedem in finala. Ii felicitam si pe ceilalti care nu au putut sa-si tina suflul pana in final, pierzand locurile calificabile. Noi le uram cat mai multe succese, sa mai alerge vreo cateva sute de probleme (incepand cu cele din Arhiva noastra) si sa ne intalnim cu ei mult mai pregatiti la startul urmatorului preONI.\r\n\r\nIn urmatoarele pagini vom incerca sa explicam solutiile problemelor. Asa cum v-ati obisnuit, va puteti lamuri orice vi se pare neclar sau vag explicat intreband pe \"forum\":http://forum.infoarena.ro/, unde vom incerca sa raspundem cat mai promt. Va asteptam cu intrebari si sugestii (asigurati-va ca pareririle va sunt auzite!)\r\n\r\nh2. NextSeq\r\n(problema simpla clasa a 9-a)\r\n\r\nEste usor de observat ca cele doua siruri pot fi interpretate ca numere in baza $N$ (numarul de elemente din setul $X$). Acest lucru se poate efectua sortand numerele din setul $X$ si asociind fiecaruia o valoare intre $0$ si $N-1$ (procedeul poarta numele de normalizare). Stiind acest lucru, doua solutii sunt posibile.\r\n\r\nCea mai usoara dintre ele este sa calculam sirul ce il urmeaza pe $A$ (numarand in baza $N$) pana cand obtinem sirul $B$. Deoarece se garanta faptul ca sunt mai putin de $100$ de siruri intre $A$ si $B$, acest pas se va executa de maxim $100$ de ori. Ne punem problema calcularii sirului care urmeaza dupa sirul $A$. Putem afla sirul care-l urmeaza pe $A$ in complexitate $O(M)$ - $M$ este lungimea sirului $A$ - simuland operatia de adunare cu $1$ in urmatorul mod: parcurgem sirul $A$ incepand cu ultimul element pana cand gasim un element mai mic decat $N-1$ (interpretandu-l in baza $N$); incrementam acel numar si numerele egale cu $N-1$ intalnite pana la la el, le egalam cu $0$ (cea mai mica valoare). Singurul caz interesant este acela cand $A$ are toate elementele egale cu valoarea maxima dar este usor de tratat. Complexitatea finala va fi $O(D*P)$ - $P$ este lungimea sirului $B$ iar $D$ este numarul de siruri aflate intre $A$ si $B$.\r\n\r\nSolutia mai rapida, dar ceva mai dificil de implementat, se baza pe operatia de scadere pe numere mari. Astfel, dupa ce am calculat reprezentarile sirurilor $A$ si $B$ in baza $N$, putem efectua o scadere pe numere mari pentru a afla numarul de siruri cuprinse intre $A$ si $B$. Complexitatea solutiei este $O(P)$ - $P$ este lungimea sirului $B$.\r\n\r\nAmbele solutii obtin punctaj maxim, prima fiind ceva mai usoara, putandu-se ajunge la ea si prin abordari care nu tin cont de reprezentarea sirurilor in baza $N$.\r\n\r\nh2. GFact\r\n(problema medie clasa a 9-a)\r\n\r\nPrimul pas in rezolvarea problemei il reprezinta factorizarea numarului $P$. Acest lucru se poate realiza intr-o complexitate $O(&#8730;P)$. Odata obtinuta factorizarea, vom avea o relatie de forma:\r\n$P = T{~1~}^R1^ * ... * T{~K~}^RK^$\r\nImediat rezulta:\r\n$A = T{~1~}^R1 * Q^ * ... * T{~K~}^RK * Q^$\r\nAl doilea pas este sa observam ca daca aflam pentru fiecare $T{~i~}$, $B{~i~}$ astfel incat $B{~i~}!$ se divide la $T{~i~}^Ri * Q^$ atunci $B$ (numarul cautat in problema) este maximul dintre $B{~i~}$. Implicatia imediata e ca putem sa ne ocupam de fiecare numar prim in parte fara sa tinem cont de celelalte.\r\n\r\nAl treilea pas consta in determinarea $B{~i~}$-urilor cu ajutorul cautarii binare. Pentru o valoare candidata $X$ (din cautarea binara) trebuie sa calculam puterea lui $T{~i~}$ in descompunerea lui $X!$. Acest lucru se afla simplu ca fiind $[X/T{~i~}] + [X/T{~i~}^2^] + ...$ (unde prin $[x]$ intelegem partea intreaga a lui $x$). Cautarea binara se poate optimiza observand ca $B{~i~}$ este intotdeauna divizibil cu $T{~i~}$, ba mai mult nu va fi mai mare decat $(R{~i~} * Q) * T{~i~}$ (observatie necesara obtinerii punctajului maxim). In concluzie, vom cauta binar o valoare intreaga $K$ in intervalul $[1, R{~i~} * Q]$ astfel incat $B{~i~} = K * T{~i~}$ sa aiba propietata ca $B{~i~}!$ se divide la $T{~i~}^Ri * Q^$. Va puteti intreba de ce putem cauta binar. Este simplu: daca o valoare $X$ are propietatea ca $X!$ se divide la $Y$ (unde lui $X$ si $Y$ le putem da semnificatiile dorite de noi) atunci, evident, si $(X + 1)!$ se divide la $Y$.\r\n\r\nSolutia finala va avea complexitatea $O(&#8730;P * log Q * log Q)$. Exista o serie de solutii intermediare care permiteau obtinerea de punctaje suficient de mari si de aceea problema a fost considerata medie desi rezolvarea completa este destul de dificila.\r\n\r\n\r\nh2. Matrix\r\n(problema grea clasa a 9-a, problema medie clasa a 10-a)\r\n\r\nPrimul pas al algoritmului este calcularea numarului de aparitii ale fiecarei litere in matricea de $N*N$. Prima idee care ne vine in minte este ca pentru toate submatricile posibile sa calculam numarul de aparitii ale fiecarei litere si sa comparam cu valorile care trebuie obtinute. Acest algoritm are complexitatea $O(M^2*(N+S)^)$, unde $S$ este dimensiunea alfabetului. Aceasta abordare obtine $50$ de puncte. \r\nVom verifica pentru toate cele {@(M-N)@}$^2^$ matrici posibile daca sunt sau nu permutari ale matricii-template. Apoi, pentru fiecare litera a alfabetului, efectuam urmatoarea preprocesare pentru a putea calcula in $O(1)$ numarul de aparitii ale literei din orice submatrice: $T{~i,j~}$ = numarul de aparitii pe pozitii $(x, y)$ cu $1 &le; x &le; i$ si $1 &le; y &le; j$.\r\n\r\nRelatia de recurenta este $T{~i,j~} = T{~i-1,j~}+T{~i,j-1~}-T{~i-1,j-1~}$, la care se adauga $1$ daca si numai daca pe pozitia $(i, j)$ se afla litera pe care o cautam. In aceste conditii, numarul de aparitii ale literei curente in submatricea cu colturile in $(i-N+1, j-N+1)$ si $(i, j)$ este $T{~i,j~}-T{~i-N,j~}-T{~i,j-N~}+T{~i-N,j-N~}$. Aceasta solutie are complexitatea $O(M^2*S^)$. Daca se foloseste $O(M^2*S^)$ memorie se obtin $70-80$ de puncte, iar pentru punctaj maxim este necesara reducerea la $O(M^2^)$. Acest lucru poate fi realizat folosind doua matrici, una in care tinem minte daca pentru o anumita pozitie s-a gasit vreo litera pentru care numarul de aparitii nu coincide cu cel dorit, si una in care se efectueaza preprocesarea pentru litera curenta. O alta optimizare, mult mai nesimnificativa, si care nu este necesara pentru $100$ de puncte, este renuntarea la verificarea pentru ultima litera, deoarece daca primele $25$ de litere s-au potrivit, iar numarul de litere este constant, e clar ca si cea de-a $26$-a litera se va potrivi.\r\n\r\n\r\nh2. Lista lui Andrei\r\n(problema usoara clasa a 10-a)\r\n\r\nProblema se rezolva folosind programare dinamica. Putem tine o matrice $V{~1..N~}{~1..26~}$ unde $V{~i,j~}$ reprezinta numarul de siruri de lungime $i$ ce contin ultima litera $j$. Incepem completarea matricii in ordine crescatoare a lungimii sirurilor, iar $V{~i,j~}$ se obtine prin insumarea valorilor $V{~i-1,k~}$, pentru orice $k$ a.i perechea $(k, j)$ sau $(j, k)$ sa nu se regaseasca in lista. Acest rationament conduce la un algoritm in $O(N * &#931;^2^)$, unde $&#931;$ reprezinta marimea alfabetului (in cazul nostru $26$).\r\n\r\nh2. Calcul\r\n(problema grea clasa a 10-a, problema medie clasele 11-12)\r\n\r\nDeoarece se cer doar ultimele $C$ cifre se va lucra modulo $10^C^$. Asadar, la primul pas se va calcula $A$ modulo $10^C^$, adica ne intereseaza doar ultimele $C$ cifre din $A$.\r\nO prima solutie pentru a calcula $A^1^ + A^2^ + ... + A^B^$ este de calcula $A^i^$ in $O(lg i)$ pentru fiecare $i$ folosind algoritmul clasic de ridicare la o putere in numar logaritmic de pasi (Cormen, capitolul 33). Aceasta solutie ar fi adus doar $20p$.\r\n\r\nSuma prezentata este o progresie geometrica clasica, si se poate calcula folosind formula $(A^B+1^-A) / (A-1)$. Calculul lui $A^(B+1)^$ se face folosind acelasi algoritm mentionat mai sus in $O(lg B)$ ({$lg$} = logaritm in baza 2). Pentru a efectua impartirea modulo $10^C^$, trebuie sa existe un invers multiplicativ pentru $A-1$ , modulo $10^C^$, lucru garantat doar pentru $50%$ din teste $(cmmdc(A-1, 10^C^) = 1)$. Inversul multiplicativ poate fi calculat folosind algoritmul Euclid extins sau teorema lui Fermat: $X^phi(N)^ = 1 (mod N)$ pentru $cmmdc(X, N) = 1$ si $phi(N)$ = indicatorul lui Euler, cate numere < $N$ sunt prime cu $N$. Din teorema reiese ca $X^phi(N)-1^ = X^-1^ (mod N)$, asadar inversul poate fi calculat algoritmul de ridicare la o putere mentionat mai sus ({$phi(10^C^)$} poate fi calculat usor). Un caz special la aceasta solutie apare atunci cand $A = 1$. Aceasta solutie n-ar fi adus decat $50p$ si necesita cunostiinte de matematica de clasa a 12-a. \r\n\r\nExista o solutie mult mai accesibila pentru clasele a 10-a si a 11-a, folosind\r\nrelatiile:\r\n$S(A,2*B) = S(A,B) * (1+A^B^)$\r\n$S(A,2*B+1) = A * (1+S(A,2*B))$\r\nCum numarul $B$ este dat in baza $16$, parcurgerea bitilor acestuia se face usor, simuland algoritmul de mai sus. Daca $A^B^$ se calculeaza la fiecare pas, complexitatea va fi $O(lg^2^ B)$, obtinand $60p$. O solutie $O(lg B)$ de $100$ de puncte se poate obtine calculand in paralel valorile $S(A,B)$ si $A^B^$. O ultima \"problema\" care ar fi putut exista este faptul ca se cer ultimele $C$ cifre, nu rezultatul modulo $10^C^$; spre exemplu, daca $C = 4$ si rezultatul modulo $10^4^$ ar fi fost $\"123\"$, in fisierul de iesire trebuia afisat $\"0123\"$.\r\n\r\nh2. Distante minime\r\n(problema usoara clasele 11-12)\r\n\r\nProblema se rezolva folosind algoritmul lui Dijkstra pornind din nodul $1$. Astfel pe langa vectorul $D{~1..N~}$ in care tinem distantele minime vom mai folosi un vector $P{~1..N~}$ in care tinem pentru fiecare nod $i$ numarul de drumuri de lungime $D{~i~}$. Cand relaxam o muchie vom face update, daca este cazul, atat in vectorul $D$ cat si in vectorul $P$.\r\n\r\nDeoarece costul drumurilor a fost definit ca produs de muchii, in vectorul $D$ putem ajunge sa avem numere cu mii de cifre. O implementare cu numere mari a algoritmului descris mai sus nu este destul de eficienta, ea obtinand aproximativ $75$ de puncte. Pentru a obtine punctajul maxim este necesara logaritmarea costului fiecarei muchii intr-o baza oarecare. Astfel putem transforma produsul in suma, folosind o proprietate a logaritmilor, fapt ce duce la o implementare simpla si rapida, folosind doar date de tip $double$.\r\n\r\nh2. Popandai\r\n(problema grea clasele 11-12)\r\n\r\nMai intai vom calcula, pentru fiecare pereche de puncte $A$ si $B$ din punctele ce reprezinta vizuinele, in sirul $sub{~AB~}$ cate puncte din restul de $n$ se afla sub segmentul de dreapta determinat de $A$ si $B$. Aceasta preprocesare poate fi efectuata in $O(n^2^ log n)$ cu un algoritm inteligent sau poate fi efectuata in $O(n^3^)$ cu metoda naiva care verifica pentru fiecare punct daca este situat pe intervalul $[A.x, B.x]$ si este sub dreapta determinata de cele doua puncte. Preprocesare vom putea pentru fiecare triunghi $ABC$ sa aflam in timp $O(1)$ cate puncte are in interior: presupunem fara a restrange generalitatea ca $A.x &le; B.x &le; C.x$, daca punctul $B$ e deasupra dreptei $AC$ atunci numarul de puncte din interiorul lui $ABC$ este $sub{~AB~} + sub{~BC~} - sub{~AC~}$, iar daca $B$ este sub dreapta $AC$ atunci numarul de puncte este $sub{~AC~} - sub{~AB~} - sub{~BC~} - 1$.\r\n\r\nOrice patrulater, fie el concav sau convex, are o diagonala interna. Daca fixam un segment $PQ$ ca fiind diagonala interna putem sa incercam sa gasim pentru fiecare $x$ triunghiul $PQR$ de arie minima pentru care punctul $R$ este deasupra dreptei $PQ$ si care contine in interior cel putin $x$ puncte, iar apoi sa gasim un triunghi $PQS$ de arie minima cu varful $S$ sub dreapta $PQ$ ce contine in interior cel putin $k-x$ puncte. Ariile minime ale acestor triunghiuri se pastreaza in doua siruri over si under iar aria minima a unui patrulater cu o diagonala $PQ$ va fi $min(over{~x~} + under{~k-x~} | unde x ia toate valorile de la 0 la k)$. Folosind artificiul explicat mai sus putem determina in $O(1)$ numarul de puncte ce se afla in interiorul unui triunghi, si astfel sirurile $over$ si $under$ pot fi calculate in $O(n)$. Complexitatea totala a algoritmului este $O(n^3^)$ pentru ca avem $O(n^3^)$ calcule in faza de preprocesare si pentru fiecare $n(n-1)/2$ diagonale vom efectua $O(n)$ calcule.\r\n',961,'public'),('stiri/bursele-agora','Bursele Agora','2005-05-20 00:00:00','h1. Bursele Agora\r\n\r\nPrin intermediul site-ului \"infoarena\":http://infoarena.ro/ veti putea participa online la finala concursului Bursele Agora! Mai multe detalii puteti gasi pe site-ul oficial al \"concursului\":http://www.ginfo.ro.\r\n',1142,'protected'),('documentatie/trimiterea-solutiilor','Trimiterea solutiilor','2006-12-18 13:40:37','h1. Trimiterea solutiilor\r\n\r\ninfoarena dispune de un \'evaluator automat\':documentatie/evaluator care compileaza si testeaza solutiile trimise de tine.\r\n\r\nSolutiile se pot trimite in doua feluri:\r\n\r\n* Cel mai simplu, folosesti formularul de sub fiecare enunt. Vezi \'problema A+B\':problema/adunare\r\n* Alternativ dai click pe optiunea _Trimite solutii_ din meniul din stanga, iti alegi problema la care trimiti solutie, fisierul solutie de pe calculatorul tau si dai click pe _Trimite solutia_\r\n\r\nCiteste pe \'pagina evaluatorului\':documentatie/evaluator despre ce compilatoare folosim la infoarena.',2963,'public'),('stiri/lansare-preoni-2006','Lansare preONI 2006','2005-11-15 00:00:00','h1. Lansare preONI 2006\r\n\r\nDaca e prima data cand auzi de preONI, te lamurim indata. Daca ai participat pana acum la un concurs preONI, afla ca anul acesta avem PREMII SERIOASE puse in joc, o finala live intr-o tabara si 5 runde minunate de probleme!\r\n\r\nPe scurt, preONI este un concurs cu premii destinat elevilor de liceu ce se pregatesc pentru competitii de informatica - in special ONI.\r\n\r\nAm construit o \"sectiune speciala\":preONI-2006 in site-ul infoarena pentru acest concurs. TOT CE VREI sa afli despre preONI 2006 se gaseste intr-un singur loc: premii, regulament, program, sponsori, forum, comisie si organizatori, finala in tabara etc.\r\n\r\nATENTIE! Prima runda incepe in curand - Sambata, 19 noiembrie. Intra pe pagina oficiala preONI 2006 pentru mai multe informatii. Te asteptam !\r\n\r\nEditia 2006 a concursului preONI se datoreaza sponsorilor nostri, carora le multumim pe aceasta cale:\r\n\r\n* \"IP Devel\":http://www.ipdevel.ro/\r\n* \"ORACLE Romania\":http://www.oracle.ro/\r\n* \"SOFTWIN\":http://www.softwin.ro/\r\n* \"Microsoft Romania\":http://www.microsoft.ro/\r\n* \"TotalSoft\":http://www.totalsoft.ro/\r\n',961,'protected'),('stiri/noutati-infoarena','Noutati infoarena','2005-11-15 00:00:00','h1. Noutati infoarena\r\n\r\nDupa cum ti s-a promis inca din vara asta, anul acesta echipa infoarena ti-a pregatit un numar foarte mare de surprize! Cateva din ele s-au materializat, pentru a afla mai multe citeste in continuare.\r\n\r\nh2. \'preONI 2006\':preONI-2006\r\n\r\nBinecunoscutul concurs organizat de infoarena vine anul acesta intr-un format nou! Mai multe detalii gasesti pe pagina oficiale a acestui concurs accesibila de pe infoarena.\r\n\r\nh2. \'Evaluator (foarte) stabil\':Despre-Evaluator\r\n\r\nPuteti sa va luati adio de la perioadele cand evaluatorul nu functiona din cauza conexiunii la Internet. De acum incolo sistemul de evaluare ruleaza pe o conexiune garantata.\r\n\r\nh2. \'Despre infoarena\':Despre-infoarena\r\n\r\nComunitatea infoarena este intr-o expansiune continua. Aceasta pagina contine o privire generala dar si informatii detaliate despre infoarena impreuna cu un regulament imbunatit, venind in ajutorul utlizatorilor noi dar si celor vechi. De asemenea, am decis sa oferim o mica rasplata tuturor celor care au contribuit la dezvoltarea proiectului infoarena, si am creat o pagina cu echipa & colaboratorii infoarena, poze si palmares.',1142,'protected'),('preoni-2006/runda-4','Runda 4, preONI 2006','2006-11-27 16:16:47','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Runda 4\r\n\r\nConcursul s-a desfasurat duminica, 19 februarie, la ora 14:00. Pe parcursul celor 4 ore de concurs participantii au avut de rezolvat 3 probleme. \r\n\r\nh2. Comisii\r\n\r\nh3. Stiintific\r\n\r\n* clasa a 9-a (si gimnaziu)\r\n** Cosmin Negruseri\r\n** Silviu Ganceanu \r\n* clasa a 10-a\r\n** Daniel Pasaila\r\n** Tiberiu Florea \r\n* clasele 11-12\r\n** Adrian Vladu\r\n** Adrian Diaconu\r\n** Mircea Pasoi \r\n\r\nh3. Organizatoric\r\n\r\nPentru intrebari de factura organizatorica / tehnica poti contacta urmatoarele persoane:\r\n\r\n* Cristian Strat\r\n* Crestez Leonard \r\n\r\nh2. Solutii\r\n\r\nSolutiile problemelor le puteti gasi \"aici\":preoni-2006/runda-4/solutii\r\n\r\nh2. Clasa a 9-a si gimnaziu (\'Clasament\':preoni-2006/runda-4/clasament-9)\r\n\r\n!>preoni-2006/runda-4?logo.jpg!\r\n\r\n== Tasks(round_id=\"preoni64a\" pager_style=\"none\") ==\r\n\r\nh2. Clasa a 10-a(\'Clasament\':preoni-2006/runda-4/clasament-10)\r\n\r\n!>preoni-2006/runda-4?logo.jpg!\r\n\r\n== Tasks(round_id=\"preoni64b\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':preoni-2006/runda-4/clasament-11-12)\r\n\r\n!>preoni-2006/runda-4?logo.jpg!\r\n\r\n== Tasks(round_id=\"preoni64c\" pager_style=\"none\") ==\r\n\r\n\r\n==include(page=\"template/preoni-2006/footer\")==',13,'protected'),('stiri/final-preoni-2006-runda-1','Runda 1 preONI 2006 s-a incheiat','2005-11-19 00:00:00','h1. Runda 1 preONI 2006 s-a incheiat\r\n\r\nPrima runda online a concursului preONI 2006 s-a incheiat. Totul a decurs normal, singurul lucru care ne-a dezamagit fiind comportarea elevilor de clasele 9-10, care au obtinut punctaje sub asteptari.\r\n\r\nFiecare grupa a avut spre rezolvare 3 probleme, fiecare fiind catalogata de catre comisie ca fiind usoara, medie sau grea. Batalia pentru calificarea la finala este abia la inceput!\r\n\r\nPentru mai multe detalii despre finala, cat si despre concursul preONI 2006 si sponsorii nostri va rugam sa consultati \'pagina concursului\':preONI-2006. S-a publicat rezultatele finale:\r\n\r\n* \'Clasa a IX-a\':preoni-2006/runda-1/clasament-9\r\n* \'Clasa a X-a\':preoni-2006/runda-1/clasament-10\r\n* \'Clasele XI-XII\':preoni-2006/runda-1/clasament-11-12\r\n\r\nDin pacate, punctajele la clasele a 9-a si a 10-a sunt sub asteptarile comisiei. Pentru discutii despre dificultate problemelor si despre concursul preONI 2006 in general va invitam sa intrati pe \'forum\':http:forum/infoarena.ro.\r\n\r\nSolutiile problemelor au fost publicate \'aici\':preoni-2006/runda-1/solutii\r\n\r\n',961,'protected'),('documentatie/wiki','Ghid infoarena: Wiki','2006-12-13 07:00:21','h1. Introducere in wiki\r\n\r\n== include(page=\"template/todo\")==\r\n\r\nInfoarena este un site bazat pe wiki, tot continutul nostru este complet editabil, cu unele exceptii. Poti si tu sa editezi, nu trebuie decat sa dai click pe link-ul de editare. Te rugam totusi sa nu editezi aceasta pagina (care face parte din \'documentatia\':documentatie oficiala), in schimb poti sa experimentezi in \'groapa cu nisip\':sandbox.\r\n\r\nSperam ca spre deosebire de infoarena1 noul site sa fie mai dinamic si accesibil.\r\n\r\nh2. Cum se editeaza\r\n\r\nAre rost sa explicam preview, istorie, vrajeli de genul asta?\r\n\r\nh2. Textile\r\n\r\nWiki-ul infoarena nu foloseste o sintaxa proprie, in loc ne folosim de \'textile\':http://hobix.com/textile/, un mark-up plain-text foarte puternic si usor de citit. Folosind textile paginile din infoarena sunt simplu de editat si arata foarte \"curat\".\r\n\r\nO scurta introducere in textile (vezi \'ghidul complet\':documentatie/textile):\r\n\r\n* Poti sa marchezi anumite fraze/cuvinte/etc cu modificatori inline. Spre exemplu poti sa pui *&#42;bold&#42;*, _&#95;italic&#95;_, +&#43;underline&#43;+, ^&#94;superscript&#94;^ si ~&#126;subscript&#126;~. Textile in general aplica aceaste formatari doar cand sunt separate prin punctuatie, etc. Poti sa fortezi formatarea folosin acolade: al{*&#123;&#42;aba&#42;&#125;*}la.\r\n\r\n* Textile imparte codul in blocuri separate prin linii goale. Poti si pui diverse declaratii pentru a formata blocul. \"h1.\", \"h2. \" fac headere, \"bq. \" face citat, etc.\r\n\r\n* Poti sa faci liste cu sau fara numere punand pe fiecare linie # sau respectiv *.\r\n\r\n* Link-urile se fac cu o sintaxa de genul @\'nume link\':http://adresa/@. Daca adresa nu contine http:// in fata este considerat un link intern infoarena.\r\n\r\n* Imaginilie sunt introduse cu sintaxa @!http://adresa/!@ pentru imagini externe sau @!pagina?atasament!@ pentru o imagine infoarena. Poti sa redimensionezi automat imaginile cu @!home?rabbits.jpg 50x50!@. !>home?rabbits.jpg 100x100!\r\n\r\nPentru o descriere amanuntita a sintaxei de textile \'vezi aici\':documentatie/textile.\r\n\r\nh2. Macro-uri\r\n\r\nContinutul paginilor infoarena poate fi imbogatit folosind macro-uri. Macro-uri sunt introduse cu sintaxa @==MacroName(a1=\"b1\" a2=\"b2)==@. *Atentie:* sintaxa este foarte fragila, vezi \'o explicatie completa\':documentaties/macro-uri.\r\n\r\nCateva exemple de ce poti face cu macro-uri:\r\n\r\n* Link-uri la utilizatori: @==user(user=\"chucknorris\" type=\"tiny\")==@ ==user(user=\"chucknorris\" type=\"tiny\")==.\r\n\r\n* Clasamente: *todo*\r\n\r\n* Liste de posturi din forum: *todo*.',962,'public'),('preoni-2006/runda-1/solutii','Solutii preONI 2006 - Runda 1','2007-01-08 18:42:35','h1. Solutii preONI 2006 - Runda 1\r\n\r\n(Categoria _Competitii_, autor(i) _Echipa infoarena_)\r\n\r\nRunda 1 a concursului preONI 2006 s-a incheiat. Acest articol contine solutiile oficiale pentru toate probleme propuse spre rezolvare, cat si comentarii referitoare la concurs.\r\n\r\nFiecare grupa a avut spre rezolvare 3 probleme, fiecare fiind catalogata de catre comisie ca fiind usoara, medie sau grea. Batalia pentru calificarea la finala este abia la inceput!\r\n\r\nPentru mai multe detalii despre finala, cat si despre concursul preONI 2006 si sponsorii nostri va rugam sa consultati \"pagina preONI-2006\":preONI-2006.\r\n\r\nRezultatele finale sunt disponibile la:\r\n\r\n* \"Clasa a 9-a\":http://infoarena.devnet.ro/index.php?page=stats&conid=preoni61a&smod=top\r\n* \"Clasa a 10-a\":http://infoarena.devnet.ro/index.php?page=stats&conid=preoni61b&smod=top\r\n* \"Clasele 11-12\":http://infoarena.devnet.ro/index.php?page=stats&conid=preoni61c&smod=top\r\n\r\nDin pacate, punctajele la clasele a 9-a si a 10-a sunt sub asteptarile comisiei. Pentru discutii despre dificultate problemelor si despre concursul preONI 2006 in general va invitam sa intrati pe \"forum\":http://forum.infoarena.ro/index.php/board,20.0.html.\r\n\r\nInainte de a va prezenta solutiile va invitam sa rezolvati problemele propuse la acest concurs in \"Arhiva de probleme infoarena\":http://infoarena.ro/arhiva-probleme, si va asteptam in forta la runda a 2-a a concursului! (17 decembrie 2005)\r\n\r\nh2. Reuniune\r\n\r\nh3. (clasa a 9-a problema usoara)\r\n\r\nVom considera cazul simplificat cu $2$ dreptunghiuri $A$ si {$B$}, pentru care putem obtine formulele:\r\n\r\n* $Arie(A + B) = Arie(A) + Arie(B) - Arie(A x B)$\r\n* $Perim(A + B) = Permi(A) + Perim(B) - Perim(A x B)$\r\n\r\n({$A+B$} reprezinta reuniunea multimilor $A$ si {$B$}, iar $AxB$ intersectia.)\r\n\r\nCazul cu $3$ dreptunghiuri {$A$}, {$B$}, $C$ se rezolva similar. Cea mai simpla metoda este de a \"vizualiza\" formula facand un desen. Mai jos aveti un astfel de desen ajutator.\r\n\r\n!preoni-2006/runda-1/solutii?reuniune.png!\r\n\r\nAsadar, obtinem formula:\r\n\r\n* $Arie(A+B+C) = Arie(A) + Arie(B) + Arie&#40;C&#41; - Arie(AxB) - Arie(BxC) - Arie(AxC) + Arie(AxBxC)$\r\n\r\n(pentru perimetru formula este asemanatoare)\r\n\r\nAstfel rezolvarea este {$O(1)$}, deoarece intersectia a $2$ sau $3$ dreptunghiuri poate fi calculata usor in timp constant. Mentionam ca formula de mai sus poate fi gasita si pe cale algebrica, si reprezinta un caz particular al principiului includerii si excluderii.\r\n\r\nh2. Patrate 2\r\n\r\nh3. (clasa a 9-a problema medie)\r\n\r\nMai intai sa completam matricea doar cu $1$ si $5$ astfel incat produsul elementelor de pe fiecare linie sau coloana sa fie {$5$}. Observam ca pe fiecare linie si pe fiecare coloana se plaseaza exact un {$5$}, restul matricii fiind completata cu {$1$}. Este evident ca fiecare permutare a multimii ({$1, 2 * N$}) reprezinta de fapt o posibilitate de aranjare a numarului $5$ in matrice, iar de aici deducem ca numarul de posibilitati de a completa matricea doar cu $1$ si $5$ este $P{~N~}$ (adica {$N!$}). Cum putem folosi si $-1$ si {$-5$}, rezultatul final va fi $2^N*N^*N!$\r\n\r\nLa implementare trebuie sa se efectueze operatii cu numere mari. De asemenea, se recomanda ca baza in care se lucreaza trebuie sa fie destul de mare pentru a se obtine eficienta dorita.\r\n\r\nh2. Invers (solutie oferita de Bogdan Tataroiu)\r\n\r\nh3. (clasa a 9-a problema grea, clasa a 10-a problema usoara)\r\n\r\nRezolvarea acestei probleme presupune parcurgerea numarului ce trebuie verificat (il vom nota cu {$v$}) din exterior spre interior. Notam cu s pozitia extremitatii stangi al numarului, iar cu $d$ pozitia extremitatii drepte. Astfel numarul $v$ este format prin adunarea unor numere de forma\r\n\r\n* $a{~1~} a{~2~} a{~3~} ... a{~n-2~} a{~n-1~} a{~n~}$\r\n* $a{~n~} a{~n-1~} a{~n-2~} ... a{~3~} a{~2~} a{~1~}$\r\n\r\nAsadar, prin adunarea cifrelor $a{~i~}$ si $a{~n-1+1~}$ se poate obtine un transport care va afecta cifrele anterioare. Deoarece sirul este parcurs de la extremitati spre interior $s$ va fi egal cu {$i$}, iar $d$ va fi egal cu {$n - i + 1$}, deci cifrele $v{~s~}$ si $v{~d~}$ sunt formate prin adunarea cifrelor $a{~i~}$ si {$a{~n-i+1~}$}.\r\nIn parcurgerea sirului de la extremitati catre interior cazul ideal este atunci cand $v{~s~}$ este egal cu {$v{~d~}$}, caz in care cifra $v{~s~}$ nici nu primeste si nici nu trimite transport la cifrele aflate pe pozitii anterioare.\r\n\r\nUn alt caz este cel in care $v{~s~}$ primeste transport prin adunarea cifrelor $a{~s+1~}$ si $a{~d-1~}$ (vezi schema de mai sus pentru a intelege acest lucru). In acest caz $v{~s~}$ este egal cu $v{~d~}+1$ si, pentru a tine cont de faptul ca pozitia $s+1$ a generat transport, adaugam la $v{~s+1~}$ valoarea {$10$}.\r\n\r\nUn al treilea caz este acela in care $v{~s~}$ da transport pentru cifra $v{~s-1~}$ si nu primeste transport de la {$s+1$}, in acest caz $v{~s~}$ fiind egal cu $v{~d~}+10$ (acel $10$ fiind adaugat la pasul anterior). Deoarece atat $v{~s~}$ cat si $v{~d~}$ sunt obtinute prin adunarea cifrelor $a{~s~}$ si {$a{~d~}$}, iar $v{~s~}$ da transport cifrelor anterioare, atunci si $v{~d~}$ da transport cifrelor anterioare. Pentru a corecta acest lucru cifra $v{~d-1~}$ trebuie decrementata, avand grija la cazurile in care $v{~d-1~}$ este egal cu {$0$}. De asemenea trebuie luat in calcul cazul in care $v{~d~}$ este egal cu $9$ si {$v{~s~}=19$}. Acest lucru este imposibil deoarece suma maxima a doua cifre este $18$ si, evident, va trebui sa se afiseze raspunsul {$NU$}.\r\n\r\nAl patrulea si ultimul caz este acela in care $v{~s~}$ da transport cifrei $v{~s-1~}$ si, in acelasi timp, primeste transport de la cifrele aflate pe pozitia {$s+1$}. In acest caz $v{~s~}=v{~d~}+11$ si trebuie executate atat operatiile pt cazul {$v{~s~}=v{~d~}+1$}, cat si cele pentru cazul {$v{~s~}=v{~d~}+10$}.\r\nDaca diferenta $v{~s~}-v{~d~}$ este diferita de {$0$}, {$1$}, $10$ si $11$ atunci numarul $v$ nu poate fi obtinut prin adunarea unui numar $a$ cu inversul sau.\r\nAlgoritmul se repeta pana cand $s$ devine egal cu {$d$}, caz in care cifra $v{~s~}=v{~d~}$ trebuie sa fie para pentru ca numarul $v$ sa indeplineasca conditia din enunt sau pana cand {$d=s+1$}, caz in care trebuie ca $v{~s~}=v{~d~}$ sau $v{~s~}=v{~d~}+11$ pentru ca numarul $v$ sa aiba proprietatea ceruta. \r\n\r\nSe mai considera cazul cand {$a{~1~}=0$}, iar {$v{~1~}=1$},obtinut printr-un transport : se aduna $10$ la {$v{~2~}$} si se considera numarul incepand de la pozitia a doua, caruia i se verifica validitatea. Atentie la cazuri particulare!\r\n\r\nPentru a intelege mai bine algoritmul general vom analiza urmatorul exemplu: {$7 2 2 3 2 6$}.\r\nObservand ca $7=6+1$ tragem concluzia ca prima cifra va trebui sa primeasca transport, deci vom analiza {$12 2 3 2$}. Observam din nou ca {$12=2+10$} ceea ce inseamna ca $12$ trebuie sa trimita transport in fata, deci si $2$ din coada va fi de fapt {$12$}. Vom lua inapoi transportul de la {$3$}, deci vom analiza in continuare {$2 2$}. Acestea fiind egale nu se primeste si nu se da transport. Deoarce nu sa dat peste nici o contradictie raspunsul va fi {$DA$}.\r\n\r\nComplexitatea acestui algoritm este $O(nr)$ pe test, unde $nr$ este numarul de cifre al numarului {$v$}.\r\n\r\nh2. Dreptunghi\r\n\r\nh3. (clasa a 10-a problema medie)\r\n\r\nUn dreptunghi care apare in grila de puncte laticiale e marginit de doua drepte verticale la stanga si la dreapta, si de doua drepte orizontale in sus si in jos. Acum, daca vrem pentru patru drepte fixate sa stim cate dreptunghiuri marginesc ele, ne putem uita la urmatorul desen.\r\n\r\n!preoni-2006/runda-1/solutii?drept.jpg!\r\n\r\nDaca dreptunghiul determinat de cele patru drepte are laturile $H$ si $W$ atunci un dreptunghi inscris va imparti laturile lui in bucatile {$A$}, $B$ si {$C$}, {$D$}. Acum folosind teorema lui Pitagora avem ca:\r\n\r\n* $A^2^ + D^2^ = Galben^2^$\r\n* $B^2^ + C^2^ = Verde^2^$\r\n* $Galben^2^ + Verde^2^ = Roz^2^$\r\n* $(A + B)^2^ = Rosu^2^$\r\n* $(C $-$ D)^2^ = Albastru^2^$\r\n* $Rosu^2^ + Albastru^2^ = Roz^2^$\r\n\r\nDe aici avem ca {$(A + B)^2^ + (C - D)^2^ = A^2^ + B^2^ + C^2^ + D^2^$}, astfel obtinem {$AB = CD$}, dar {$B = H - A$}, iar {$D = W - C$} deci avem ca {$C^2^ - WC + A(H - A) = 0$}. Daca il fixam pe $A$ atunci trebuie sa rezolvam o ecuatie de gradul doi in necunoscuta {$C$}, solutia trebuie sa fie intreaga intre $0$ si {$W$}.\r\n\r\nAstfel in $O(H)$ vom sti numarul de dreptunghiuri inscrise intr-un dreptunghi de dimensiuni {$H * W$}. Acest dreptunghi poate fi pus in $(N - H + 1) * (M - W + 1)$ locatii pe o grila de dimensiune {$N * M$}. Deci solutia are complexitate {$O(N*M^2^)$}, pentru fiecare dreptunghi de dimensiuni $1 &le; H &le; N$ si $1 &le; W &le; M$ calculandu-se numarul de dreptunghiuri inscrise.\r\n\r\nO rezolvare de complexitate $O(N^2^*M^2^)$ in care se cautau solutiile ecuatiei printr-un for ar fi luat $60$ de puncte. Rezolvarea directa folosind ecuatia de gradul doi ia in jur de $80$ de puncte. Algoritmul poate fi optimizat la factorii constanti, de exemplu avem nevoie de functia radical care este cam inceata, precalculand-o obtinem o accelerare a vitezei, alta idee ar fi ca numarul de solutii cu $A &le; H/2$ este egal cu numarul de solutii cu $A &ge; H - H/2$ si a treia idee de optimizare este ca numarul de dreptunghiuri inscrise intr-un dreptunghi de dimensiuni {$H$}, $W$ este acelasi cu numarul de dreptunghiuri inscrise intr-un dreptunghi de dimensiuni {$W$}, {$H$}.\r\n\r\nh2. Zebughil\r\n\r\nh3. (clasa a 10 problema grea, clasele 11-12 problema medie)\r\n\r\nSe poate aborda o rezolvare bazata pe parcurgerea numerelor de la $1$ la $3^n^-1$ in ordine. Pastram matricea best in care retinem numarul minim de camioane in care pot fi transportate blocurile date de bitii de $1$ din {$i$}. Completarea acestei matrici se face in {$O(3^n^)$}. Descompunerea in baza $3$ va avea urmatoarea semnificatie: $0$ - blocul nu e in multimea curenta, $1$ - blocul se afla in ultimul camion sau $2$ - blocul se afla intr-un camion anterior in care nu se mai poate aduaga.\r\n\r\nAceasta idee aduce $90$ de puncte daca este implementata corect. O alta solutie se poate obtine daca avem in vedere faptul ca avem limita superioara $500$ pentru capacitatea unui camion putem face o rezolvare ce foloseste principiul programrii dinamice. Vom folosi o matrice $best{~i,j~}$ care retine numarul minim de camioane astfel incat sa putem transporta blocurile identificate de bitii de $1$ din reprezentarea in baza $2$ a lui {$i$}, iar ultimul camion sa fie plin pana la capacitatea {$j$}. Aceasta solutie ar fi obtinut $70$ de puncte.\r\n\r\nDeoarece fie folosim maxim $n$ camioane fie nu avem solutie putem incerca construirea unei matrici {$best{~i,j~}$} cu semnificatia cat mai este liber in ultimul camion ca sa avem transportati bitii de $1$ din $i$ si sa folosim maxim $j$ camioane. Completarea acestei matrici se face in {$O(2^n^*n^2^)$}, aducand 100 de puncte.\r\n\r\nAnalizand mai departe observam ca nu este nevoie sa retinem pentru o configuratie decat solutia folosind numar minim de camioane deoarece daca am folosi mai multe putem pur si simplu sa incepem unul nou acuma care va avea capacitate {$G$}. Astfel complexitatea de memorie se reduce la {$O(2^n^)$} iar cea de timp la $O(2^n^*n)$\r\n\r\nO alta abordare interesanta a problemei dar care nu ducea la obtinerea unui punctaj maxim este generarea permutarilor prin backtracking si testarea greedy a solutiei. Parcurgem permutarea si cand avem nevoie de un camion nou il deschidem. Aceasta ar avea o complexitatea {$O(n!*n)$}. Putem insa retine pe parcurs costul pana in acel moment si la sfarsit sa nu trebuiasca sa mai parcurgem din nou. Pentru generarea permutarilor se poate retine o lista cu elementele care nu au fost inca puse in permutare lista in care un element se va adauga si se va scoate in {$O(1)$}. Aceasta tehnica se numeste dancing links si duce la o complexitate totala de $O(n!)$\r\n\r\nO abordare neortodoxa ar fi fost generarea aleatoare a permutarilor, astfel pornim de la o permutare initiala si luam doua elemente din permutare in mod aleator pe care le interschimbam, daca solutia obtinuta e mai buna sau cel putin egala cu solutia initiala (valoarea unei solutii o vedem folosind un algoritm greedy care baga in ordine elementele in camioane) atunci pastram solutia curenta, iar daca nu interschimbam elementele la loc. O asemenea tehnica de optimizare a solutiei ar fi dus la un punctaj de aproximativ $60$ de puncte.\r\n\r\nh2. Distante\r\n\r\nh3. (clasele 11-12, problema usoara)\r\n\r\nFoarte multi concurenti au incercat sa rezolve aceasta problema folosind algoritmul Dijkstra cu heap-uri sau cu arbori de intervale. Aceasta solutie ar fi obtinut de la $70$ pana la $100$ de puncte (in cazul in care se optimiza algoritmul). O alta metoda de a obtine $100$ de puncte ar fi fost folosirea algoritmul Bellman Ford cu coada (vezi OJI 2004, problema \"Lanterna\":http://infoarena.ro/problema/lanterna).\r\n\r\nSolutia oficiala (care este de fapt si cea mai simpla si cea mai usor de implementat) are complexitate $O(N+M)$ ca timp si $O(N)$ ca memorie. Ea poate fi dedusa din modul de functionare a algoritmilor Dijkstra sau Bellman Ford. Asadar, conditile suficiente si necesare ca distantele minime date sa fie corecte sunt:\r\n\r\n* $D{~S~} = 0$\r\n* $D{~x~} + cost(x, y) &ge; D{~y~}$ pentru orice muchie ({$x, y$})\r\n* exista pentru fiecare $y$ (diferit de {$S$}) un $x$ astfel incat $D{~x~} + cost(x, y) = D{~y~}$\r\n\r\nStudiati modul in care functioneaza Dijkstra sau Bellman Ford si veti vedea ca logica acestor conditii devine evidenta. Verificarea acestor conditii se poate face in complexitatea mentionata mai sus.\r\n\r\nh2. Balans\r\n\r\nh3. (clasele 11-12, problema grea)\r\n\r\nProblema a fost gandita sa rasplateasca pe \"fanii infoarena\" si anume pe aceea care au rezolvat corect problemele \"Secventa 1\":http://infoarena.ro/problema/secventa, \"Secventa 2\":http://infoarena.ro/problema/secv2, \"Secventa 3\":http://infoarena.ro/problema/secv3. Pentru a trata circularitatea matricii o vom extinde intr-o matrice 2N*2M, lipind matrii initiale o copie la dreapta, sub ea, si la dreapta-jos.\r\n\r\nRezolvarea acum se va baza pe cautarea binara a balansului maxim (idee folosita si la rezolvarea problemei \"Secventa 3\":http://infoarena.ro/problema/secv3). Fie acesta {$X$}, trebuie sa verificam daca exista o submatrice cu balans cel putin {$X$}, adica:\r\n\r\n* $Suma / Numar &ge; X$\r\n* $Suma &ge; X*Numar$\r\n* $Suma - X*Numar &ge; 0$\r\n\r\nFolosind cele scrise mai sus, putem observa ca, daca fiecare element nr din matricea intiala este inlocuit cu {$nr-X$}, atunci problema se reduce la a determina o submatrice din matricea modificata in care suma elementelor este {$&ge; 0$}. Aceasta problema se poate rezolva determinand submatricea de suma maxima din matricea modificata, verificand apoi daca este {$&ge; 0$}.\r\n\r\nAsadar, problema s-a redus la a determina o submatrice de cel putin $R$ linii si $C$ coloane de suma maxima dintr-o matrice. Intai vom fixa $2$ linii la distanta cel putin $R$ si cel mult {$N$}, si vom calcula sumele pe coloane intre cele doua linii (acest lucru se poate face in $O(M)$ precalculand anumite sume la inceput). Pe vectorul de sume pe coloane obtinut va trebui sa rezolvam acum problema \"secventei de suma maxima de lungime intre {$C$} si {$M$}\" (necesara si la rezolvarea problemei \"Secventa 3\":http://infoarena.ro/problema/secv3). Fie $A$ vectorul pe care vrem sa rezolvam acesta problema, si {$S{~i~} = A{~1~}&#0043;A{~2~}&#0043;...&#0043;A{~i~}$}. Pentru fiecare $i$ va trebui sa gasim un $j$ astfel incat:\r\n\r\n* $S[i] - S[j]$ = maxim\r\n* $i-M &le; j &le; i-C$\r\n\r\nAcest lucru se poate face in $O(M)$ per total folosind structura \"deque\" , prezentata pe scurt si in articolul cu solutii de la preONI 2005, runda 3. Lasam detalierea modului in care se va folosi aceasta structura in rezolvare ca exercitiu pentru cititor. Astfel, problema poate fi rezolva in complexitatea $O(N^2^*M*lg MAX)$ unde $MAX$ este valoarea maxima din matricea. Mentionam ca pentru o solutie relativ rapida si care sa evite erori de precizie se recomanda lucrul cu numere intregi (inmultind totul cu {$1000$}).\r\n\r\n',2970,'public'),('stiri/probleme-noi','Probleme noi!','2005-05-24 00:00:00','h1. Probleme noi!\r\n\r\nS-au adaugat 8 probleme noi in \"Arhiva de probleme\":http://infoarena.ro/arhiva-probleme si 3 probleme noi pentru Bacalaureat 2005 pe site-ul \"infoarena\":http://infoarena.ro/. Asteptam parerile voastre pe forum despre noile probleme si va invitam sa le rezolvati. More to come...\r\n\r\n',1142,'protected'),('stiri/info-educatie-2005','InfoEducatie 2005','2005-08-12 00:00:00','h1. InfoEducatie 2005\r\n\r\nConcursul InfoEducatie 2005 a ajuns la final si am vrea sa va invitam sa cititi \"povestea\":http://www.infoeducatie.ro/povestea_2005.php editiei de anul acesta a concursului. Acolo gasiti atat poze cat si mici filmulete interesante din tabara.\r\n\r\nCred ca sunt in asentimentul tuturor, al organizatorilor, sponsorilor si al participantilor cand spun ca aceasta a fost cea mai reusita editie InfoEducatie de pana acum. Este important de stiut ca anul acesta a adus si o crestere spectaculoasa in calitatea lucrarilor aflate in competitie si a seriozitatii cu care elevii si-au prezentat productiile.\r\n\r\nPremiile au fost mari (valoare totala de peste $7000, valoarea unui premiu 1 fiind de peste $800 !!!), jurizarea corecta, juriul format numai din specialisti. S-a organizat concurs open la toate sectiunile (o noutate a acestei editii), discutii libere si seminarii si toate au contribuit la succesul editiei 2005.\r\n\r\nDe mare succes s-au bucurat cele doua sectiuni OPEN pe teme de programre si creatie web. Concursul a fost condus in cea mai mare parte de studenti, laureati din anii anteriori ai concursului (Octavian Costache, Liviu Valsan, Razvan si Bogdan Hobeanu, Cristian Strat).\r\n\r\nConsideram InfoEducatie, un eveniment care aduce un pasaport catre o afacere proprie in domeniul IT&C. In plus, InfoEducatie inseamna mai mult decat un concurs de succes cu premii foarte mari. El este un loc al pasiunilor si al initiativelor, un concurs unde toata lumea gandeste liber si discuta, o tabara a tinerelor talente. Este un concurs independent pentru oameni independenti, organizat cu pasiune si daruire pentru elevi.\r\n\r\nFirmele care au sponsorizat sau au oferit cursuri si consultanta au deja angajati \"produsi\" de InfoEducatie si spun ca vor veni oricand la concurs pentru ca este unic si productiv pentru cei care vor sa-si aleaga ca profesiune programarea: GreenPixel - Marius Deak, GrapefruitDesign - 2 anganjati ce au trecut prin InfoEducatie, Viorel Stan - companie internationala, Octavian Costache - angajat Google NY si exemplele pot continua.',1142,'protected'),('stiri/rezultate-agora-2005','Concursul Agora s-a incheiat!','2005-07-13 00:00:00','h1. Concursul Agora s-a incheiat!\r\n\r\nConcursul Bursele Agora 2005 s-a incheiat, atat varianta online cat si cea on-site. Rezultatele finale au fost publicate si problemele au fost mutate in arhiva. Cosmin Negruseri, autorul a doua din probleme, a publicat un \"articol despre solutiile problemelor\":http://infoarena.ro/Concursul_Agora_Etapa_Finala_Solutii\r\n\r\nAsteptam parerile si sugestiile tale pe forum legate de acest concurs pe \"forum\":http://forum.infoarena.ro/index.php/topic,414.0.html.\r\n\r\nh2. Castigatorii Online\r\n\r\n==Rankings(rounds=\"ba6\" display_entries=\"3\" pager_style=\"none\")==\r\n\r\nh2. Castigatorii Onsite\r\n\r\n* Locul I Mugurel Ionut Andreica 290 puncte\r\n* Locul II Patcas Csaba 170 puncte\r\n* Locul II Constantin Dolghier 170 puncte\r\n\r\nFelicitari tuturor participantilor si va asteptam sa participati la urmatorul concurs organizat de devNet care va fi in luna august!',13,'protected'),('stiri/ioi-by-net','IOI by net !','2005-08-15 00:00:00','h1. IOI by net !\r\n\r\nAnul acesta se organizeaza si varianta _\"by net\"_ a Olimpiadei Internationale de informatica. \"Pagina concursului\":http://sio.mimuw.edu.pl/ioi2005/.\r\n\r\nMult succes celor ce vor participa!',1142,'protected'),('listapaginilor','ListaPaginilor','2006-11-22 20:24:44','h2. Lista *tuturor* paginilor. Cam multe.\r\n==tableofcontents()==',1142,'public'),('stiri/concursul-happy-coding','Concursul Happy Coding','2005-09-09 00:00:00','h1. Concursul Happy Coding\r\n\r\nSuntem bucurosi sa anuntam concursul Happy Coding, o competitie inedita gazduita de infoarena!\r\n\r\nUn amplu studiu efectuat in laboratoarele infoarena releva un fapt socant: strictetea evaluatorului si necesitatea de a preda o singura solutie buna per problema provoaca riduri vizibile concurentilor dupa numai 2h de competitie, fiind de departe cele mai semnificative surse de stres si hipertensiune pentru concurenti. :)\r\n\r\nh2. Happy Coding si de ce ii spunem noi asa\r\n\r\nConcursul se va desfasura online incepand cu ora 10:00, Sambata (10 septembrie) pana Duminica la ora 22:00 (11 septembrie). Timpul disponibil este asadar de 36h. Timpul recomandat (dar nu obligatoriu!) de lucru este de 4h.\r\n\r\nSe vor propune 6 probleme de dificultate medie ce acopera intreaga programa de informatica pentru clasele 9 - 12. Problemele presupun aplicarea tehnicilor clasice de programare si implementarea unor solutii simple, fara greseli. Propunator unic pentru setul de probleme este Mugurel Ionut Andreica, student la Univsersitatea Politehnica Bucuresti, Facultatea de Automatizari si Calculatoare.\r\n\r\nInedit la Happy Coding este prezenta evaluatorului on-line pe tot parcursul concursului. In alte cuvinte, poti testa mai multe solutii pana esti multumit de punctajul obtinut! Nu mai trebuie sa iti faci griji daca daca programul compileaza pe Linux, daca te incadrezi in limita de memorie sau daca solutia ta e suficient de rapida..\r\n\r\nHappy Coding inseamna programare cu zambetul pe buze, pace, idei, placere si distractie pura! :)\r\n\r\nTe asteptam asadar pe infoarena incepand cu ora 10:00, Sambata (10 septembrie). Si daca tot vorbim de distractie, nu uita sa-ti inviti si prietenii! Avem conturi pentru toata lumea. :)\r\n\r\nAsteptam intrebarile si sugestiile tale pe \"forum\":http://forum.infoarena.ro/',961,'protected'),('stiri/happy-coding-2','Happy Coding 2','2005-10-20 00:00:00','A trecut mai bine de o luna de la ultimul concurs infoarena.\r\n\"Happy Coding\" a fost un succes total! :) Si cum un lucru bun nu vine niciodata singur, la insistentele publicului am decis sa organizam Happy Coding 2!\r\n\r\n!stiri/happy-coding-2?hc2.jpg 50%!\r\n\r\nh2. Happy Coding 2 si de ce ii spunem noi asa\r\n\r\nConcursul se va desfasura incepand cu ora 10:00, Sambata (22 oct.) pana Duminica la ora 22:00. Timpul disponibil este asadar de 36h. Timpul recomandat (dar nu obligatoriu!) de lucru este de 8h.\r\n\r\nSe vor propune 10 probleme de dificultate medie ce acopera intreaga programa de informatica pentru clasele 9 - 12. Problemele presupun aplicarea tehnicilor clasice de programare si implementarea unor solutii simple, fara greseli. Propunator unic pentru setul de probleme este Mugurel Ionut Andreica, student la Universitatea Politehnica Bucuresti, Facultatea de Automatizari si Calculatoare. Inedit la \"Happy Coding 2\" este prezenta evaluatorului on-line pe TOT parcursul concursului. In alte cuvinte, poti testa mai multe solutii pana esti multumit de punctajul obtinut! Nu mai trebuie sa iti faci griji daca daca programul compileaza pe Linux, daca te incadrezi in limita de memorie sau daca solutia ta e suficientde rapida ...\r\n\r\n\"Happy Coding\" inseamna programare cu zambetul pe buze, pace, idei, distractie!\r\n\r\nTe asteptam asadar pe infoarena incepand cu ora 10:00, Sambata (22 oct.).\r\nAsteptam intrebarile si sugestiile tale pe \"forum\":http://forum.infoarena.ro/\r\n',961,'protected'),('stiri/cautari-ortogonale','Cautari Ortogonale','2005-10-29 00:00:00','h1. Cautari Ortogonale\r\n\r\nUn \'articol\':downloads?Cautari_Ortogonale.doc folosit la pregatirea lotului din anul 2005 care discuta algoritmi de cautari ortogonale si aplicatii ale acestora a fost adaugat la sectiunea \'Download\':Downloads.',1142,'protected'),('stiri/noua-aparitie-editoriala','O noua aparitie editoriala!','2005-09-21 00:00:00','h1. O noua aparitie editoriala!\r\n\r\nEchipa devNet va recomanda cartea \"Fundamentele programarii, clasa a X-a\" , autori \"Dana Lica\":mailto:danal182001@yahoo.com si \"Mircea Pasoi\":mailto:bogdanpasoi@yahoo.com. Culegerea respecta programa scolara a claselor a X-a de informatica si isi propune sa reprezinte un instrument util atat in munca de initiere in programare cat si in cea de performanta, cuprinzand peste 90 de probleme pentru concursuri si olimpiade.\r\n\r\nCartile le puteti gasi in Bucuresti la:\r\n\r\n* Libraria 88 (Langa Universitate, in spatele librariei Eminescu)\r\n* Libraria Papirus (in Piata Romana)\r\n* Libraria 74 In Piata Romana, la coloane\r\n* Libraria Mihail Sadoveanu (langa cinema Scala)\r\n\r\nh2. Cuprins\r\n\r\n# Capitolul 1: Tipuri structurate de date\r\n## Sir de caractere\r\n### Teste cu alegere multipla si duala\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n## Inregistrare - structura\r\n### Teste cu alegere multipla si duala\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n## Probleme de concurs ce proceseaza date structurate\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n# Capitolul 2: Subprograme definite de utilizator\r\n## Subprograme implementate in maniera iterativa\r\n### Teste cu alegere multipla si duala\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n## Subprograme implementate in maniera recursiva\r\n### Teste cu alegere multipla si duala\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n## Probleme de concurs\r\n### Probleme rezolvate\r\n### Probleme propuse\r\n\r\n',1142,'protected'),('documentatie/borderoul-de-evaluare','Borderoul de evaluare','2006-12-11 21:46:52','h1. Borderoul de evaluare\r\n\r\n==include(page=\"template/todo\")==\r\n\r\nBorderoul de evaluare prezinta informatii despre cum a decurs evaluarea unei solutii trimise de un concurent. Borderoul include timpul de executie, numarul de puncte obtinute la fiecare test si, uneori, mesaje de compilare sau de rulare (runtime) ale solutiei.\r\n\r\nh2. Mesaje de eroare\r\n\r\n* *OK* (sau un mesaj asemanator): programul tau a mers corect pe testul respectiv si ai primit punctele care le meritai.\r\n* *Wrong Answer*, *Raspuns gresit* (sau un mesaj asemanator): programul tau a terminat executia, dar raspunsul oferit nu a fost corect; verifica daca ai respectat intocmai cum este precizat in enunt formatul fisierului de iesire cat si formatul fisierului de intrare cand efectuezi citirea\r\n* *Time Limit Exceeded*: programul tau a depasit timpul de executie permis pentru testul respectiv; cele mai dese cauze pentru acest mesaj sunt: algoritmul folosit este ineficient, fie programul tau contine bucle care se executa la infinit, fie programul tau incearca sa citeasca de la tastatura, etc.\r\n* *System Error* (sau un mesaj asemanator): acest mesaj nu ar trebui sa apara. ==SmfLink(link=\"board\" board=\"33\" caption=\"Anunta echipa infoarena!\")==\r\n* *Missing output file* (sau un mesaj asemanator): programul tau nu a creat un fisier de iesire, sau in cazul in care a creat un fisier, nu a avut numele specificat in enuntul problemei.\r\n* *Runtime Error - Invalid memory reference*: acest mesaj se poate referi la faptul ca depasesti limita de memorie disponibila (care este de 1 MB pentru stiva si 63 MB pentru heap) sau acces invalid in memorie, accesarea unui pointer invalid, indecsi intr-un tablou care depasesc dimensiunile tabloului, etc.\r\n* *Runtime Error*: cele mai cunoscute cauze pentru astfel de mesaje sunt depasirea stivei, accesarea unor fisiere gresite, erori cu numere reale, impartire la 0, etc. Un mesaj foarte intalnit este SIGKILL si semnifica ca programul tau a fost oprit de evaluator datorita unei erori ca cele descrise mai sus.\r\n\r\nh2. Greseli frecvente\r\n\r\n* nu sterge ecranul si nu scrie nimic pe iesirea standard (ecran). Solutiile trimise sunt corectate automat de sistemul de evaluare. Acesta nu ia in considerare informatiile tiparite pe ecran ci doar cele scrise in fisierul de iesire specificat in descrierea problemei.\r\n* nu folosi functii care asteapta apasarea unei taste sau introducerea unei valori de la tastatura ($getch$, $readkey$, $readln$ etc.) Solutiile trimise sunt corectate automat de sistemul de evaluare. Sursele care folosesc astfel de functii vor primi punctaj $0$ pentru $timp de executie depasit$!\r\n* foloseste doar librariile standard pentru rezolvarea problemelor, adica cele care vin odata cu distributia limbajului de programare. Vezi \"lista oficiala de compilatoarele\":documentatie/evaluator folosite la infoarena.\r\n* *numele fisierelor este case sensitive!* Prin conventie, toate fisierele de intrare si de iesire vor avea nume in lowercase (fara majuscule).\r\n\r\nh2. Pentru programatorii C/C++\r\n\r\n* Tipul $int$ din GNU GCC este pe $32$ de biti, nu $16$ ca in Borland C/C++, $char$ pe $8$ biti, $short$ pe $16$ biti, $long$ pe $32$, $long long$ pe $64$ de biti.\r\n* Foloseste sprintf in loc de itoa sau ltoa.\r\n* Programul de evaluare ruleaza pe un sistem de operare UNIX. Foloseste $\"\\n\"$ pentru terminarea liniei curente, nu $\"\\r\\n\"$.\r\n* Functia $main$ trebuie sa fie de tip $int$ si sa intoarca $0$ - $return 0;$\r\n* Nu folosi librarii dependente de sistemul de operare (ex. $dos.h$, $graphics.h$). Foloseste evaluatorul pentru a descoperi care sunt acestea.\r\n* No folosi modificatorii $far$, $huge$, $_huge$, $__huge$ pentru ca nu exista in GNU GCC. De asemenea, nu exista nici functiile care folosesc aceste tipuri de date (de ex. $farmalloc$, $farfree$ etc.) si nici conceptul de memory model (tiny, small, medium, large, huge). De toate acestea nu mai e nevoie intrucat ai acces la toata memoria prin functii standard si pointer-i standard - $new$, $delete$, $malloc$ etc. \r\n\r\nh2. Pentru programatorii Pascal\r\n\r\n* Nu folosi nici unul din unit-urile $dos$, $crt$ sau $graph$! Nu ai nevoie de nici unul din ele pentru a rezolva problemele de aici. Daca totusi le folosesti, programul nu va compila!\r\n',15,'public'),('preoni-2006/finala/feedback','preONI 2006 Feedback','2006-11-27 16:05:37','==Include(page=\"template/preoni-2006/header\")==\r\n\r\nh1. Feedback preONI 2006\r\n\r\n|_. &nbsp;|_. Medie |_. Procent |\r\n|_. Concurs | | |\r\n| Cazarea | 4,00 | 80% |\r\n| Mancarea | 4,22 | 84% |\r\n| Distractia | 3,15 | 63% |\r\n| Lifturile de la hotel | 3,52 | 70% |\r\n| Organizarea | 4,61 | 92% |\r\n| Premii | 3,52 | 70% |\r\n| Teatrul | 3,87 | 77% |\r\n|_. Mediul de lucru| | |\r\n|Hardware|3,74|75%|\r\n|Software|3,87|77%|\r\n|Ambient|3,22|64%|\r\n|Sistem de submit|4,70|94%|\r\n|Parola de administrator|3,78|76%|\r\n|_. Evaluarea| | |\r\n|Corectitudine|4,48|90%|\r\n|Promptitudine|4,09|82%|\r\n|Show|3,74|75%|\r\n\r\n&nbsp;\r\n\r\n|_. Probleme|_. Fun|_. Claritate|_. Dificultate|_. Implementare|\r\n|DivK|3,07|4,86|2,93|2,71|\r\n|Lupul Urias si Rau|3,71|4,29|3,00|4,43|\r\n|Overlap|2,14|3,43|4,71|4,14|\r\n|Iv|2,63|4,13|4,50|3,63|\r\n|Robotei|2,88|3,13|4,38|3,38|\r\n|Problema simpla cu nivele|3,44|4,44|2,22|3,11|\r\n|Arbore|3,33|4,22|4,11|3,22|\r\n|Pedefe|2,11|4,22|4,44|4,33|\r\n',13,'protected'),('preoni-2006/finala/clasament-10','Clasament Finala preONI 2006, Clasa a X-a','2006-12-01 18:16:00','== include(page=\"template/preoni-2006/finalrankings\") ==\r\n\r\nh2. Clasa a X-a\r\n\r\n==Rankings(rounds = \"preoni65b\")==',13,'protected'),('stiri/final-preoni-2006-runda-2','Runda 2 preONI 2006 s-a incheiat','2005-12-17 00:00:00','h1. Runda 2 preONI 2006 s-a incheiat\r\n\r\nRunda a doua s-a incheiat. Dificultatea problemelor nu a lasat nici de aceasta data de dorit. Desi ne-am fi asteptat la punctaje mai mari, rezultatele concurentilor au fost decente. Provocarile oferite de infoarena sunt intr-adevar dificile, iar obtinerea unui punctaj apropiat de cel maxim nu este usor de realizat. In editiile ce vor urma vom tine cont de acest aspect. Fiecare grupa a avut spre rezolvare 3 probleme, fiecare fiind catalogata de catre comisie ca fiind usoara, medie sau grea. Batalia pentru calificarea la finala continua!\r\n\r\nPentru mai multe detalii despre finala, cat si despre concursul preONI 2006 si sponsorii nostri va rugam sa consultati \'pagina oficiala\':preONI-2006. S-au publicat rezultatele finale:\r\n\r\n* \'Clasa a IX-a\':preoni-2006/runda-2/clasament-9\r\n* \'Clasa a X-a\':preoni-2006/runda-2/clasament-10\r\n* \'Clasele XI-XII\':preoni-2006/runda-2/clasament-11-12\r\n\r\nSolutiile problemelor se gasesc \'aici\':preoni-2006/runda-2/solutii, va asteptam pe \'forum\':http://forum.infoarena.ro pentru discutii.\r\n\r\n\r\nVa asteptam cu forte noi in noul an la runda a 3-a!',961,'protected'),('preoni-2006/runda-3/solutii','Solutii preONI 2006 - Runda a 3-a','2006-11-25 13:34:41','h1. Solutii preONI 2006 - Runda a 3-a\r\n\r\n(Categoria _Competitii_, autor(i) _Echipa infoarena_)\r\n\r\nRunda a 3-a concursului preONI 2006 s-a incheiat. Acest articol va prezinta solutiile oficiale ale celor 7 probleme propuse precum si cateva aprecieri pe marginea concursului.\r\n\r\nS-a incheiat si cea de-a treia runda a concursului preONI 2006. Ca de obicei, la fiecare grupa au existat 3 probleme cu nivele diferite de dificultate: usor, mediu, greu. Spre deosebire de runda precedenta, problemele au fost ceva mai accesibile facand mai usoara obtinerea unui punctaj mediu pentru participantii de la toate cele trei grupe. Salutam primul punctaj maxim realizat de Cosmin Gheorghe, participant la clasa a IX-a. Desi nivelul de dificultate al problemelor este unul ridicat (comparativ cu cel de la nationale), nu putem sa nu remarcam faptul ca, la clasa a X-a, nivelul de pregatire al concurentilor este ceva mai scazut fata de celelalte grupe, in conditiile in care olimpiadele se apropie. Ii sfatuim pe toti participantii sa se pregateasca si mai consistent de acum incolo, utilizand si platforma pe care le-o pune la dispozitie InfoArena.\r\n\r\nInainte de ultima runda, la clasa a IX-a, avem deja doi concurenti care s-au detasat de pluton in persoana lui Gheorghe Cosmin si Tataroiu Bogdan, lupta fiind inca acerba pentru ultimele locuri calificabile. La clasa a X-a avem un clasament destul de echilibrat, cu elevii clasati primii fara prea mari emotii inainte de ultima runda, dar cu multe semne de intrebare pentru cei clasati pe locurile 8-10. La clasele XI-XII avem o batalie frumoasa, cu multe punctaje peste $300$ si o situatia foarte confuza catre ultimele locuri calificabile.\r\n\r\nLe uram tutoror succes si fie ca cei mai buni sa mearga in finala!\r\n\r\nh2. Numarare triunghiuri\r\n\r\nh3. (problema simpla, clasa a 9a)\r\n\r\nPentru a rezolva problema trebuie cunoscuta conditia de existenta a unui triunghi cand avem lungimile segmentelor. Fie {$a$}, {$b$}, $c$ lungimile laturilor in ordine nedescrescatoare. Se poate forma un triunghi cu ele doar daca $a + b &ge; c$ (este usor de intuit de ce).\r\n\r\nAcum putem rezolva problema in $O(N^3^)$ verificand toate triunghiurile posibile care s-ar putea forma si numarandu-le doar pe cele ce respecta conditia de mai sus. Aceasta solutie ar trebui sa ia in jur de $75$ de puncte.\r\n\r\nPentru a rezolva mai eficient problema este necesar sa sortam nedescrescator vectorul cu lungimile segmentelor. Acum putem fixa segmentele $a$ si $b$ si putem cauta binar pozitia maxima din vector a segmentului $c$ care respecta {$a + b &ge; c$}. Deci numarul de triunghiuri care se pot forma avand primele doua laturi $a$ si $b$ este egal cu numarul de elemente din vector de dupa $b$ si pana la $c$ (pentru fiecare triunghi luam segmentele {$a$}, {$b$}, $c$ in ordine crescatoare dupa indicii din vector, evitand astfel numararea unui triunghi de doua ori). Deci complexitatea acestei solutii este $O(N^2^ log N)$ si ar fi luat fara probleme punctajul maxim.\r\n\r\nPutem imbunatati solutia de mai sus la o complexitate {$O(N^2^)$}, eliminand cautarea binara. Aceasta solutie va lasam sa o descoperiti voi.\r\n\r\nh2. Divizori primi\r\n\r\nh3. (problema medie, clasa a 9a)\r\n\r\nFiind vorba de maxim $1.000.000$ numere se poate calcula pentru fiecare in parte cati divizori primi are. Pentru acest lucru se foloseste ciurul lui Erathostene si se construieste vectorul {$ndp{~i~}$} - numarul de divizori primi ai lui {$i$}. Parcurgem numerele din $1$ in $1$ si in momentul in care am dat peste un numar care are $0$ divizori primi pana in acest moment inseamna ca am gasit un nou numar prim si vom actualiza vectorul $ndp$ pentru toti multiplii lui si implicit pentru el (numarul fiind propriul sau divizor). Apoi se construieste o matrice $sol{~i,j~}$ care retine care este cel mai mare numaru mai mic sau egal cu $i$ cu $j$ divizori primi (adica exact raspunsurile pentru problema noastra). Pentru a construi linia $i$ se copiaza linia $i-1$ si se actualizeaza {$sol{~i,ndp{~i~}~}=i$}.\r\n\r\nPentru mai multe detalii despre cum functioneaza ciurul lui Erathostene puteti accesa \"articolul\":http://infoarena.ro/Ciurul-lui-Erathostene.\r\n\r\nh2. Subsir 2\r\n\r\nh3. (problema grea clasa a 9a, problema medie clasa a 10a, problema usaora clasele 11-12)\r\n\r\nProblema poate fi considerata asemanatoare cu cea a celui mai lung subsir crescator, avand o rezolvare similara de complexitatea $O(N^2^)$ folosind metoda programarii dinamice.\r\n\r\nSe vor construi doi vectori:\r\n\r\n* $A{~i~}$ = lungimea celui mai scurt subsir crescator maximal care incepe cu pozitia $i$\r\n* $T{~i~}$ = urmatorul element dupa pozitia $i$ in cel mai scurt subsir crescator maximal care incepe cu $i$ (pentru reconstiutire)\r\n\r\nPentru fiecare {$i$}, se va cauta un $j > i$ astfel incat {$V{~i~} &le; V{~j~}$} (unde $V$ este vectorul de numere) si se alege acela cu $A{~j~}$ minim, $A{~i~}$ devenind {$A{~j~}+1$}, iar $T{~i~}$ devine {$j$}. Daca nu exista nici un {$j$}, $A{~i~}$ se initializeaza cu $1$ si $T{~i~}$ cu {$i$}.\r\n\r\nCa sirul construit sa fie maximal trebuie ca atunci cand verificam {$j$}-urile pentru un $i$ fixat, {$j$}-ul respectiv sa fie \"dominant\", in sensul ca sa nu existe un $i < k < j$ astfel incat {$V{~i~} &le; V{~k~} &le; V{~j~}$}, deoarece sirul construit cu primul element in $i$ si al doilea in $j$ ar putea fi extins inserand $k$ intre $i$ si {$j$}. Verificarea pentru acest $k$ se poate face in {$O(N)$}, obtinand o solutie $O(N^3^)$ care ar fi adus {$50-60p$}. Pentru a face verificarea in {$O(1)$}, facem observatia ca ne intereseaza doar acel $V{~k~}$ minim care este &ge; {$V{~i~}$}. Pe masura ce se avanseaza cu variabila {$j$}, se pastreaza o variabila {$min$}, reprezentand minimul dintre valorile $V{~j~}$ parcurse pana acum, care sunt &ge; {$V{~i~}$}.\r\n\r\nAstfel, cand se ajunge la un {$j$}, se verifica inainte daca {$V{~j~} < min$} (conditie necesara pentru a construi un sir maximal). Un ultim detaliu in solutie este obtinerea solutiei minime din punct de vedere lexicografic. Cand se selecteaza {$j$}-ul pentru fiecare {$i$}, pe langa faptul ca se alege acela cu $A{~j~}$ minim, in caz de egalitate se va alege acela cu valoarea $V{~j~}$ minima. Selectarea este corecta deoarece nu vor exista {$j1$}, $j2$ cu $A{~j1~}$ si $A{~j2~}$ minim , iar {$V{~j1~} = V{~j2~}$}.\r\nProblema se poate rezolva mai bine intr-o complexitate $O(N*lg^2^ N)$ folosind structuri de date avansate, astfel transformandu-se intr-o problema de clasele 11-12 grea, sau chiar o problema de finala. Lasam aceasta rezolvare ca exercitiu pentru cititor.\r\n\r\nh2. Sum\r\n\r\nh3. (problema usoara, clasa a 10a)\r\n\r\nVom face o prima observatie:\r\n\r\n* $(n, d) = 1 <=> (n, n - d) = 1, (n, n + d) = 1$\r\n\r\nFie {$a = phi (n)$}, indicatorul lui Euler. Fie $b$ numarul de numere prime cu $n$ cuprinse intre $n$ si {$2 * n$}.\r\nDeoarece {$(n, d) = 1 <=> (n, n + d) = 1, a &le; b$}. Deoarece {$(n, d) = 1 <=> (n, n - d) = 1, b &le; a => b = a$}. Fie {$x{~1~}, x{~2~}, .. x{~a~}$} numerele $< n$ si prime cu $n$ => numerele cuprinse intre $n$ si $2 * n$ si prime cu $n$ vor fi {$x{~1~} + n, x{~2~} + n, .. x{~a~} + n$}.\r\n\r\nConform observatiei facute, $(n, n - x{~1~}) = 1, (n, n - x{~2~}) = 1, .. (n, n - x{~a~}) = 1$ =>\r\n\r\nx{~a~} = n - x{~1~} <=> x{~1~} + x{~a~} = n\r\nx{~a-1~} = n - x{~2~} <=> x{~2~} + x{~a-1~} = n\r\n...\r\nx{~1~} = n - x{~a~} <=> x{~a~} + x{~1~} = n\r\n\r\nFie $S1$ suma numerelor prime cu $n$ si mai mici ca {$n$}, fie $S2$ suma numerelor prime cu {$n$}, cuprinse intre $n$ si {$2 * n$}.\r\nAdunand cele a egalitati, obtinem $2 * S1 = a * n$ => {$S1 = (a * n) / 2$}.\r\n\r\n$S2 = a * n + S1$ => {$S1 + S2 = 2 * a * n$}.\r\n\r\nSe foloseste o singura data ciurul lui Erathostene pentru a determina functia phi pentru toate intrebarile. Se poate consulta \"articolul\":http://infoarena.ro/Ciurul-lui-Erathostene despre cirulul lui Erathostene.\r\n\r\nO alta solutie, propusa de Bogdan A. Stoica, se bazeaza pe principul includerii si excluderii. Din enuntul problemei ne dam seama ca suma ceruta este suma tuturor numerelor $z$ cu proprietatea ca {$cmmdc(z, x) = 1$}. Pentru a afla aceste numere este de ajuns sa observam ca $cmmdc(z, x) != 1$ daca si numai daca exista cel putin un $p{~i~} = q{~j~}$ unde {$z = p{~1~}^e{~1~}^&#0042; ... &#0042;p{~n~}^e{~n~}^$}, iar {$x = q{~1~}^f{~1~}^&#0042; ... &#0042;q{~m~}^f{~m~}^$}. Fie doua astfel de numere {$p{~i~} = q{~j~}$}. Noi trebuie sa afla suma tuturor numerelor care se divid cu $p{~i~}$ si sunt in intervalul [{$0, 2*x$}]. Aceste numere sunt : {$p{~i~}, 2&#0042;p{~i~}, ..., k&#0042;p{~i~}$}, {$0 < k &le; [2&#0042;x/p{~i~}]$}. Suma acestor numere se poate scrie ca {$p{~i~} + ... + k&#0042;p{~i~}$}, adica pi(1+...+k) adica {$p{~i~}&#0042;k(k+1)/2$}. De aici suntem tentati sa credem ca suma ceruta (fie aceasta {$S$}) este $S$ = {$x(2&#0042;x-1) - p{~1~}&#0042;k{~1~}&#0042;(k{~1~}+1)/2 - .... - p{~n~}&#0042;k{~n~}&#0042;(k{~n~}+1)/2$}. La o citire mai atenta observam ca am scazut unele de doua ori (cele care se divid si cu $p{~1~}$ si cu {$p{~2~}$}, de exemplu) si nu am scazut deloc alte numere care au un divizor comun cu $x$ mai mare decat $1$ (cele care se divid simultan cu {$p{~1~}$}, $p{~2~}$ si {$p{~3~}$}, de exemplu). Astfel, aplicand principiul includerii si excluderii putem schita formula finala : {$S = x&#0042;(2x-1) - p{~1~}&#0042;k{~1~}&#0042;(k{~1~}+1)/2 - ... + p{~1~}&#0042;p{~2~}&#0042;k\'{~1~}(k\'{~1~}+1)/2 + ... - p{~1~}&#0042;p{~2~}&#0042;p{~3~}&#0042;k\'\'{~1~}(k\'\'{~1~}+1)/2 + ...$}, adica vom scadea toti termenii care se obtin prin inmultirea a unui numar impar de factori primi si vom aduna restul. Aceasta solutie obtine in jur de $80$ de puncte pe restul testelor depasind timpul de executie.\r\n\r\nh2. Pavare 2\r\n\r\nh3. (problema grea, clasa a 10a)\r\n\r\nProblema se rezolva cu programare dinamica. Utilizam urmatoare structura de date:\r\n\r\n* $V[i][j]&#0091;0]$ = numarul de posibilitati pentru a pava $i$ metri astfel incat primele $j$ placi sa fie albe\r\n* $V[i][j]&#0091;1]$ = numarul de posibilitati pentru a pava $i$ metri astfel incat primele $j$ placi sa fie negre\r\n\r\nRelatiile de recurenta sunt acum usor de dedus. Odata calculata matricea putem raspunde foarte usor primei cerinte, facand suma $V[N][i]&#0091;0]$ (pentru {$1 &le; i &le; A$}) si $V[N][i]&#0091;1]$ pentru ({$1 &le; i &le; B$}).\r\n\r\nPentru a 2-a cerinta incercam sa construim a {$K$}-a segventa lexicografica de la inceput catre sfarsit. Astfel, la fiecare pas incercam sa punem o segventa de tipul \'{$0...01$}\' care sa contina un numar maxim de \'{$0$}\'. Daca la pasul curent nu putem pune nici un \'{$0$}\' atunci vom pune o secventa de tipul \'{$1..1$}\' care sa contina un numar minim de {$1$}. Numarul de \'{$0$}\'-uri sau de \'{$1$}\' pe care il punem il vom calcula cu ajutorul matricei precalculate la prima cerinta. Astfel, daca putem pune $p$ de \'{$0$}\' inseamna ca numarul de posibilitati pentru a completa restul solutiei daca punem cel putin $p$ de \'{$0$}\' la inceput este mai mare sau egal cu {$K$}. Alegem cel mai mare numar $p$ cu proprietatea de mai sus. Daca $p$ nu exista, incercam sa punem cat mai putini \'{$1$}\' in aceeasi maniera. Continuam apoi cu restul secventei, iar din $K$ scadem numarul de solutii peste care am \"sarit\".\r\n\r\nh2. Count\r\n\r\nh3. (problema medie, clasele 11-12)\r\n\r\nInainte de a prezenta solutia, enumeram cateva propietati ale grafurilor planare care se vor dovedi utile mai departe:\r\n\r\n# Orice graf planar contine un nod cu grad mai mic decat $6$\r\n# Numarul maxim de muchii pe care il poate avea un graf planar este {$3 * N - 6$}, unde $N$ este numarul de noduri. Asadar $O(M)=O(N)$ ({$M$} fiind numarul de muchii).\r\n# Grafurile planare nu contin clici (subgrafuri complete) cu mai mult de $4$ noduri (nu se poate desena in plan o clica de $5$ noduri fara a intersecta muchiile acesteia).\r\n\r\nConsecinta imediata a propietatii numarul $3$ este ca intr-un graf planar vom avea clici de maxim $4$ noduri. Cum cazurile in care clica cu numar maxim de noduri este compusa dintr-unul sau doua noduri este banal, ne vom concentra atentia pe cazurile in care avem clici de $3$ sau $4$ noduri.\r\n\r\nStiind acest lucru, un algoritm $O(N^2^)$ este usor de obtinut (si multi dintre concurenti au reusit acest lucru pentru $~70$ de puncte). Ideea este urmatoarea:\r\n\r\n* Cazul clicilor de $3$ noduri: se numara toate clicile care includ o anumita muchie incercand sa construim un triunghi impreuna cu fiecare nod din graf. Asadar pentru fiecare muchie, incercam cu fiecare nod (mai putin cele doua capete ale muchiei) sa construim o clica de $3$ noduri. Complexitatea este $O(M*N) = O(N^2^)$ (folosindu-ne de propietatea {$2$}). De altfel problema determinarii numarului de triunghiuri (clici de $3$ noduri) intr-un graf, de aceasta data general, este cunoscuta si cea mai rapida rezolvare cunoscuta de noi este $O(M*N / 32)$ daca pastram matricea de adiacenta pe biti - in total $O(N^2^ / 32)$ memorie. Va lasam pe voi sa descoperiti aceasta solutie iar daca nu reusiti cereti ajutor pe forum si vom completa acest articol.\r\n* In cazul clicilor de $4$ noduri, tot ce avem de facut este sa selectam doua muchii si sa vedem daca cele $4$ capete ale lor formeaza o clica (presupunda ca avem $4$ capete distincte). Acest algoritm are complexitatea $O(M^2^) = O(N^2^)$\r\n\r\nCum determinam, rapid, daca doua noduri sunt vecine? Solutia cea mai usoara este sa pastram matricea de adiacenta (eventual pe biti) si putem raspunde in $O(1)$ la astfel de intrebari dar memoria este {$O(N^2^)$}. O alta idee care reduce marimea memoriei la $O(M)$ este sa pastram listele de adicenta sub forma de hash-uri in loc de liste simple inlantuite (pentru cei care nu sunt familiari cu aceasta structura de date ii sfatuim sa citeasca articolele de pe devnet - sunt interesante si educative). Asadar, folosind hash-urile, memoria ramane $O(M)$ dar putem afla rapid (aproape {$O(1)$}) daca doua noduri sunt vecine. In C++ aceasta structura de date este deja implementata sub numele de map, desi un query are complexitate logaritmica.\r\n\r\nSa trecem la solutia {$O(N)$}. Evident, vom folosi propietatea $1$ (singura nefolosita pana acum). Din moment ce avem un nod cu grad mai mic decat {$6$}, il identificam, generam toate clicile care il contin printr-un backtracking (dat fiind faptul ca sunt maxim $5$ vecini) si il scoatem din graf. Graful rezultat este si el planar si cautam iar nodul cu grad mai mic decat {$6$}, etc. Evident, nu vom face cautarea nodului de fiecare data - asta ar duce la un {$O(N^2^)$}, ci in momentul in care stergem un nod, verificam daca gradele vecinilor sai au scazut sub $6$ si apelam o procedura recursiva cand gasim un astfel de vecin (un soi de $DFS$ in graful dat). Dat fiind faptul ca backtracking-ul ruleaza in timp constant (desi e mare constanta) algoritmul acesta va avea complexitatea $O(N)$ - presupunand ca putem raspunde in $O(1)$ folosind hashurile daca doua noduri sunt vecine. Solutia noastra foloseste map-urile din STL asadar are complexitatea $O(N*logN)$ cu o constanta considerabila {$(~100)$}.\r\n\r\nSolutia de mai sus suporta multiple optimizari asupra factorului constant daca efectuam niste prepocesari inainte de algoritmul descris. Asadar, putem prepocesa pentru toate grafurile de maxim $6$ noduri in care exista un nod conectat la toate celelalte, care este clica maxima si cate sunt. Nu sunt mai mult de $2^12^$ asemenea grafuri, deci prepocesarea va rula instantaneu. Avand aceasta informatie prepocesata, cand eliminam un nod din graful planar, in loc sa facem backtracking pentru a afla clicile maximale, interogam tabelul cu valorile prepocesate, optimizand factorul constant foarte mult (ajunge {$~6$}). Totusi, nu era necesara implementarea acestor optimizari, din moment ce problema era media setului.\r\n\r\nh2. Cowfood\r\n\r\nh3. (problema grea, clasele 11-12)\r\n\r\nProblema este bazata pe principiul includerii si excluderii. Constrangerile relativ mici ale problemei nu ar fi trebuit sa va pacaleasca sa incercati o cautare exhaustiva, intrucat aceasta ar fi obtinut numai $20-30%$ din punctaj.\r\n\r\nInainte de a trece la explicarea problemei, sa ne amintim principiul includerii si excluderii.\r\n\r\n{$&#0124;A{~1~} U A{~2~} U ... U A{~n~}&#0124; =$}\r\n{$&#0124;A{~1~}&#0124; + &#0124;A{~2~}&#0124; + ... + &#0124;A{~n~}&#0124;$}\r\n{$- &#0124;A{~1~} &#8745; A{~2~}| - |A{~2~} &#8745; A{~3~}| - ...$} (toate perechile)\r\n{$+ &#0124;A{~1~} &#8745; A{~2~} &#8745; A{~3~}| + ...$} (toate tripletele)\r\n{$...$}\r\n{$+ (-1)^(n-1)^ &#0124;A{~1~} &#8745; A{~2~} &#8745; ... &#8745; A{~n~}&#0124;$}\r\n\r\nCum va fi folosit acesta? Vom calcula solutia ca fiind &#0124;multimea tuturor experimentelor valide&#0124; - &#0124;multimea experimentelor valide care sigur vor esua&#0124;. Sa notam aceasta multime de experimente cu {$F$}. Pentru orice experiment {$X$}, vom nota $f{~X~}$ = multimea tutoror experimentelor care vor esua conform experimentului {$X$}.\r\n\r\nAstfel, pentru un experiment $A$ de forma ({$a{~1~}, a{~2~}, ..., a{~K~}$}) si orice experiment $B$ = ({$b{~1~}, b{~2~}, ..., b{~K~}$}) cu {$a{~1~} &le; b{~1~}$}, {$a{~2~} &le; b{~2~}$}, ..., {$a{~K~} &le; b{~K~}$}, $B$ apartine {$f{~A~}$}.\r\n\r\nIn acest moment putem sa ne dam seama de solutie\r\n&#0124;F&#0124; = &#0124;f{~E{~1~}~} U f{~E{~2~}~} U ... U f{~E{~N~}~}&#0124;, care - conform principiului includerii si excluderii - este egal cu\r\n\r\n{$&#0124;f{~E{~1~}~}&#0124; + &#0124;f{~E{~2~}~}&#0124; + ... + &#0124;f{~E{~N~}~}&#0124;$}\r\n{$- &#0124;f{~E{~1~}~} &#8745; f{~E{~2~}~}| - |f{~E{~1~}~} &#8745; f{~E{~3~}~}| - ...$} (toate perechile)\r\n{$+&#0124;f{~E{~1~}~} &#8745; f{~E{~2~}~} &#8745; f{~E{~3~}~}&#0124; ...$}(toate tripletele)\r\n{$...$}\r\n{$+(-1)^n-1^ &#0124;f{~E{~1~}~} &#8745; f{~E{~2~}~} &#8745; ... &#8745; f{~E{~N~}~}&#0124;$}\r\n\r\nCe reprezinta intersectia (\"&#8745;\") in acest context?\r\nDaca $A = (a{~1~}, a{~2~}, ..., a{~K~})$ si {$B = (b{~1~}, b{~2~}, ..., b{~K~})$}, $A &#8745; B$ va fi multimea ce contine toate experimentele despre care se stie cu siguranta ca vor esua, atat conform lui $A$ cat si lui {$B$}. Altfel spus, $A &#8745; B$ = multimea experimentelor care vor esua conform {$(max(a{~1~}, b{~1~}), max(a{~2~}, b{~2~}), ..., max(a{~K~}, b{~K~}))$}.\r\n\r\nUn ultim lucru care trebuie obinut este calcularea lui |f{~X~}| pentru orice {$X = (x{~1~}, x{~2~}, ... x{~K~})$}. Pentru a obtine un experiment esuat, putem incrementa toate valorile x{~i~} atata timp cat suma lor este &le; {$S$}. Astfel avem |f{~X~}| = {$m(S - (x{~1~} + x{~2~} + ... + x{~K~}), K)$}, unde $m(i, j)$ reprezinta numarul de posibilitati de a aranja cel mult $i$ bile identice in $j$ cutii diferite.\r\n\r\nAceasta se calculeaza simplu folosind recurenta care nu va fi demonstrata aici\r\n\r\n$m(i, j - 1) = p(i, j) = p(i - 1, j) + p(i, j - 1), i, j > 0$\r\n$m(i, 0) = 1$\r\n$m(0,j) = 1$ \r\n\r\ncu $p(i, j)$ = numarul de posibilitati de a aranja exact $i$ bile identice in $j$ cutii diferite. Valorile $m(i, j)$ se preproceseaza la inceput intr-o matrice, in timp {$O(K*S)$}.\r\n\r\nO implementare bruta a problemei va duce la complexitatea $O(K*S + 2^N^*N*K$}), dar aceasta ar obtine numai $60%$ din punctajul maxim. O implementare inteligenta folosind preferabil o functie recursiva care exploreaza toate submultimile celor $N$ experimente si la fiecare pas actualizeaza solutia in $O(K)$ obtine cu usurinta $100$ de puncte. Complexitatea sa este {$O(K*S + 2^N^*K)$}.\r\n\r\n',961,'public'),('moisil-by-net-2006','Grigore Moisil By net 2006','2006-11-24 18:24:27','h1. Grigore Moisil By net 2006\r\n\r\nConcursul s-a desfasurat incepand cu ora 16:00, joi, 30 martie 2006. \r\n\r\nAu existat 4 grupe fiecare avand de rezolvat cate 2 probleme mai putin grupa 11-12 care a avut de rezolvat 3 probleme.\r\n\r\nh2. Clasele 7-8 (\'Clasament\':moisil-by-net-2006/clasament-7-8)\r\n\r\n!>moisil-by-net-2007?logo.gif!\r\n\r\n== Tasks(round_id=\"moisil1\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 9 (\'Clasament\':moisil-by-net-2006/clasament-9)\r\n\r\n!>moisil-by-net-2007?logo.gif!\r\n\r\n== Tasks(round_id=\"moisil2\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 10 (\'Clasament\':moisil-by-net-2006/clasament-10)\r\n\r\n!>moisil-by-net-2007?logo.gif!\r\n\r\n== Tasks(round_id=\"moisil3\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':moisil-by-net-2006/clasament-11-12)\r\n\r\n!>moisil-by-net-2007?logo.gif!\r\n\r\n== Tasks(round_id=\"moisil4\" pager_style=\"none\") ==\r\n',961,'protected'),('stiri/final-preoni-2006-runda-3','Runda 3 preONI 2006 s-a incheiat','2006-01-24 00:00:00','h1. Runda 3 preONI 2006 s-a incheiat\r\n\r\nFiecare grupa a avut spre rezolvare 3 probleme, fiecare fiind catalogata de catre comisie ca fiind usoara, medie sau grea.\r\n\r\nBatalia pentru calificarea la finala se pare ca se va incheia in runda a 4a. Mult succes in continuare!\r\n\r\nPentru mai multe detalii despre finala, cat si despre concursul preONI 2006 si sponsorii nostri va rugam sa consultati \'pagina oficiala\':preONI-2006. S-au publicat rezultatele finale:\r\n\r\n* \'Clasa a IX-a\':preONI-2006/runda-3/clasament-9\r\n* \'Clasa a X-a\':preONI-2006/runda-3/clasament-10\r\n* \'Clasele XI-XII\':preONI-2006/runda-3/clasament-11-12\r\n\r\nSolutiile problemelor se gasesc \'aici\':preONI-2006/runda-3/solutii.\r\n\r\nPentru discutia lor va asteptam pe \'forum\':http://forum.infoarena.ro.',961,'protected'),('documentatie/textile','Formatare Textile','2006-12-12 10:57:42','h1. Tutorial de Textile\r\n\r\nh1. Introducere\r\n\r\n_Textile_ este un limbaj de markup ce va ajuta sa editati paginile web. Ce inseamna aceasta? In loc sa scrieti tag-urile specifice de html pentru a edita o astfel de pagina, _Textile_ va pune la dispozitie o serie de elemente de sintaxa prin care puteti edita mai simplu si mult mai rapid aceste pagini. In continuare sunt prezentate notiunile care trebuiesc cunoscute inainte de a incepe scrierea unui pagini html folosind _Textile_. \r\n\r\nh1. Paragrafe\r\n\r\nUn text este structurat pe mai multe paragrafe. Atunci cand folositi Textile, paragrafele trebuiesc separate de o linie alba ( goala ).\r\n\r\ntable(example). |_. Cod _Textile_|_. Cod HTML asociat|\r\n|Un paragraf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;\r\nAl doilea paragraf\r\n|@<p>Un paragraf</p>@&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;\r\n@<p>Al doilea paragraf</p>@|\r\n\r\n\r\nUn intreg paragraf se poate transforma cu usurinta intr-un header, folosind sintaxa {$hn$} la inceputul paragrafului, unde {$n$} este un numar de la $1$ la $6$. De exemplu, Textile va interpreta linia @h1. Primul header@ ca @<h1>Primul header</h1>@ si rezultatul va fi: \r\n\r\nh1. Primul header\r\n\r\nh1. Modificatori\r\n\r\nPentru a scrie un text cu diferite efecte ( ingrosat, inclinat, subliniat, taiat ) sau in diferite pozitii ( puteri sau indici ) se scrie textul care se doreste a fi modificat intre modificatorii corespunzatori. In tabelul de mai jos este prezentat modul de folosire al acestora:\r\n\r\ntable(example). |_. Cod _Textile_|_. Cod HTML asociat|\r\n|@**Un text ingrosat**@|@<b>Un text ingrosat</b>@|\r\n|@_Aici apare inclinat_@|@<i>Un text inclinat</i>@|\r\n|@+Merge chiar si subliniat+@|@<ins>Merge chiar si subliniat</ins>@|\r\n|@-Text gresit-@|@<del>Text gresit</del>@|\r\n|@Pitagora: a ^2^ + b ^2^ = c ^2^@|@Pitagora: a <sup>2</sup> + b <sup>2</sup> = c <sup>2</sup>@|\r\n|@Chiar si logaritmi: log ~2~ N@|@Chiar si logaritmi: log <sub>2</sub> N@|\r\n\r\nIn cazul in care rezultatele produse de limbajul de markup nu sunt cele asteptate, se poate forta folosirea acestor modificatori prin caracterele { si } puse la inceputul si respectiv la sfarsitul secventei. De exemplu, @{**Text fortat**}@ are ca rezultat {**Text fortat**}.\r\n\r\nh1. Liste\r\n\r\nPentru a crea o lista numerica cu Textile, este suficient sa inseram # inainte de fiecare paragraf:\r\n\r\n@# Primul item@\r\n@# Al doilea item@\r\n@# Al treilea item@\r\n\r\nva genera:\r\n\r\n# Primul item\r\n# Al doilea item\r\n# Al treilea item\r\n\r\nDe asemenea este posibil ca listele sa fie imbricate, incrementand numarul de caractere #. Listele vor avea o structura aborescenta:\r\n\r\n@# Un item@\r\n@## Alt item@\r\n@# Al doilea item@\r\n\r\nva avea ca rezultat:\r\n\r\n# Un item\r\n## Alt item\r\n# Al doilea item\r\n\r\nDaca in locul listelor indexate numeric se doreste creerea listelor cu bulete ( _bulleted lists_ ), in loc de # se va folosi *. Regula pentru liste imbricate ramane valabila si aici:\r\n\r\n@* Capitolul 1@\r\n@** Capitolul 1.1@\r\n@* Capitolul 2@\r\n\r\nproduce urmatorul efect:\r\n\r\n* Capitolul 1\r\n** Capitolul 1.1\r\n* Capitolul 2\r\n\r\nh1. Referinte externe\r\n\r\nPentru a crea o referinta catre un alt site ( un _link_ ), textul descriptiv va fi plasat intre ghilimele duble (\"), urmat imediat de caracterul : si de URLul dorit: @Link catre \"infoarena\":http://infoarena.ro@ va fi interpretat ca Link catre \"infoarena\":http://infoarena.ro. Daca un link este folosit de mai multe ori in acelasi document sau daca se doreste o mai buna organizare a textului, este posibil ca URLul sa fie specificat oriunde in document: intre paranteze patrate se va afla identificatorul unic asociat linkului, dupa care urmeaza adresa propriu-zisa. In momentul in care dorim sa inseram in document acel link este suficient in loc de adresa completa sa introducem doar identificatorul pe care l-am asociat adresei:\r\n\r\n@Link catre \"infoarena\":arena@\r\n@Al doilea link catre \"inforarena\":arena@\r\n\r\n@[arena]http://infoarena.ro@\r\n\r\nare rezultatul:\r\n\r\nLink catre \"infoarena\":arena\r\nAl doilea link catre \"inforarena\":arena\r\n\r\n[arena]http://infoarena.ro\r\n\r\nPentru a posta o imagine pe site, este necesar in prealabil sa o salvati pe server. Pentru aceasta este suficient sa apasati butonul \"Ataseaza\" din coltul dreapta-sus al paginii pe care o editati si sa selectati imaginea pe care doriti sa o transferati pe server. Dupa aceea, pentru a introduce imaginea in pagina va trebui sa introduceti URLul ei intre semnul exclamarii (!).\r\n\r\nDaca am incarcat deja imaginea logo.jpg in pagina curenta,\r\n@!documentatie/textile?logo.jpg!@ va avea rezultatul:\r\n\r\n!documentatie/textile?logo.jpg!\r\n\r\nh1. Tabele\r\n\r\nTabelele simple pot fi construite separand campurile lor prin caracterul |.\r\n\r\n@| nume | varsta | judet |@\r\n@| Popescu | 24 | Bucuresti |@\r\n@| Ionescu | 12 | Constanta |@\r\n\r\nva genera tabelul de mai jos:\r\n\r\n| nume | varsta | judet |\r\n| Popescu | 24 | Bucuresti |\r\n| Ionescu | 12 | Constanta |\r\n\r\nCelulele care doresc sa fie facute cap de tabel vor fi marcate initial printr-un underscore, urmat imediat de un punct.\r\n\r\n@|_. nume |_. varsta |_. judet |@\r\n@| Popescu | 24 | Bucuresti |@\r\n@| Ionescu | 12 | Constanta |@\r\n\r\nva avea urmatorul rezultat:\r\n\r\n|_. nume |_. varsta |_. judet |\r\n| Popescu | 24 | Bucuresti |\r\n| Ionescu | 12 | Constanta |\r\n\r\nh1. Fragmente de cod\r\n\r\nAtunci cand dorim sa inseram un fragment de cod in pagina curenta, putem sa folosim sintaxa:\r\n\r\n@== code(c) |@\r\n@...fragment de cod...@\r\n{@==@}\r\n\r\nUrmatoarele limbaje sunt suportate:\r\n\r\n* $code{@(c)@}$ pentru C\r\n* $code(cpp)$ pentru C++\r\n* $code(pas)$ pentru Object Pascal\r\n* $code(java)$ pentru Java\r\n\r\nIata un exemplu:\r\n\r\n== code(c) |\r\n#include <stdio.h>\r\n\r\nint main(void) {\r\n    int a, b;\r\n\r\n    freopen(\"adunare.in\", \"rt\", stdin);\r\n    freopen(\"adunare.out\", \"rt\", stdout);\r\n\r\n    scanf(\"%d%d\", &a, &b);\r\n    printf(\"%d\\n\", a+b);\r\n\r\n    return 0;\r\n}\r\n==\r\n\r\nh1. Aplicarea stilurilor CSS\r\n\r\nEste posibil sa atasam cod CSS elementelor in felul urmator:\r\n\r\ntable(example). |_. Cod _Textile_|_. Cod HTML asociat|_. Rezultat |\r\n|@text %{color:red}bau!% text@|@text <span style=\"color:red\">bau!</span> text@|text %{color:red;}bau!% text|',1217,'public'),('stiri/articole-noi','Articole noi','2006-02-02 00:00:00','h1. Articole noi\r\n\r\nDoua noi articole care au aparut in Gazeta de Informatica in 2005 au fost publicate la sectiunea \"Download\":downloads de catre ==user(user=\"domino\" type=\"tiny\")==. Acestea sunt disponibile si in format PDF.\r\n\r\nAsteptam feedback-ul vostru pe \'forum\':http://forum.infoarena.ro/\r\n\r\n',1142,'protected'),('stiri/topcoder-pentru-liceeni','Liceenii - TopCoderi (legali) incepand din iunie 2006 !','2006-02-07 00:00:00','h1. Liceenii - TopCoderi (legali) incepand din iunie 2006 !\r\n\r\n\"Topcoder\":http://topcoder.com/tc a anuntat lansarea unei competitii pentru liceeni. Multe din detalii nu sunt inca stabilite, de aceea va incurajam sa intrati pe site si sa discutati pe forum pe baza regulamentului (pentru asta va trebuie un cont pe site). Anuntul se gaseste \"aici\":http://www.topcoder.com/tc?module=Static&d1=hs&d2=home. \r\n',1142,'protected'),('stiri/data-finalei-preoni-2006','ATENTIE! Data finalei preONI: 24-26 martie','2006-03-10 00:00:00','h1. *ATENTIE!* Data finalei preONI: 24-26 martie\r\n\r\nSuntem nevoiti sa decalam concursul cu o zi. Astfel, vom astepta sosirea celor 30 de finalisti la Focsani oricand in decursul zilei de vineri, 24 martie, iar concursul se va desfasura in data de 25 martie, atat la Focsani, cat si online! Plecarea se va face duminica, iar luni veti putea ajunge la timp la scoala!',1142,'protected'),('usaco-dec-2004-divizia-gold','USACO decembrie 2004, divizia GOLD - idei de solutii','2006-11-25 15:31:57','h1. USACO decembrie 2004, divizia GOLD - idei de solutii\r\n\r\n(Categoria _Competitii_, autor(i) _Silviu Ganceanu_)\r\n\r\n\"Setul de probleme\":downloads?gold_dec04.zip pe marginea caruia voi discuta in urmatoarele randuri se afla disponibil in sectiunea download impreuna cu datele de test si rezultatele finale ale concursului (cei care nu stiu setul de probleme si vor sa citeasca articolul sunt rugati sa parcurga mai intai textele problemelor).\r\n\r\nVoi incepe prin cateva observatii in legatura cu evolutia concurentilor din Romania in acest concurs. Asadar un clasament (neoficial) alcatuit intre acestia ar arata in urmatorul mod:\r\n\r\ntable. |_. 1 | Vladu Adrian | 783 puncte|\r\n|_. 2 | Stancu-Mara Sorin | 782 puncte |\r\n|_. 3 | Andrei-Marius Teodorescu | 710 puncte |\r\n|_. 4 | Fechete Dan Ionut | 490 puncte |\r\n|_. 5 | Pasaila Daniel | 436 puncte |\r\n|_. 6 | Paul Diac | 406 puncte |\r\n\r\nRestul concurentilor au avut punctaje sub $400$ de puncte. Primii doi din clasamentul \"nostru\" au reusit sa se strecoare intre primele $20$ de locuri din clasamentul final dar, din nou, remarc lipsa unui roman in topul celor mai buni. Sper mai multe de la concursurile viitore! Mai vreau sa precizez ca Romania nu a dispus de tot arsenalul avut in dotare si concurenti cu rezultate in competiile internationale anterioare precum Dan Crestez si Dan Spatarel nu au fost prezenti in concurs (cel putin nu cu numele lor!). Ei sunt rugati sa participe in viitoarele concursuri (sau sa renunte la pseudonime - daca e cazul), spre binele lor si spre prestigiul Romaniei!\r\n\r\nSetul de probleme a fost unul dificil dar deosebit de frumos, necesitand cunostinte avansate de programare dinamica, structuri de date si teoria grafurilor. Totusi, pentru un concurent experimentat, problemele nu erau in totalitate noi. Spun asta pentru ca toate problemele aveau in substrat idei deja folosite in alte concursuri (CEOI, IOI si chiar barajele noastre).\r\n\r\nLasand comentariile deoparte sa trecem la ce ne intereseaza cel mai mult: solutiile.\r\n\r\nh2. Divide\r\n\r\nProblema se rezolva prin programare dinamica. Prima idee, destul de intuitiva de altfel, este o solutie de complexitate {$O(L * B)$}. Sa notam cu $BST{~l~}$ = numar minim de stropitori de care avem nevoie pentru a acoperi complet intervalul [{$0, l$}] cu $l$ par. Avem urmatoarea recurenta:\r\n\r\n* $BST{~l~}$ = $INFINIT$ daca $l$ este inclus intr-un interval al unei vaci\r\n* $BST{~l~}$ = {$minim(BST{~l - 2 * x~}) + 1$}, cu $x$ intre $A$ si $B$ astfel incat $2 * x$ este mai mic sau egal cu $l$\r\n\r\nPrintr-o implementare directa a recurentei de mai sus obtinem o solutie care foloseste $O(L)$ memorie si $O(L * B)$ operatii (cu observatia ca spatiul de memorie se poate reduce la {$O(B)$}).\r\n\r\nPentru a reduce complexitatea la $O(L)$ operatii se utilizeaza o coada care pastreaza valorile $BST{~x~}$ cu $x$ in intervalul [{$i - 2*B, i - 2*A$}] sortate crescator. Se observa cum se modifica coada cand se trece de la pozitia $i$ la pozitia $i + 2$ (practic \"intra\" valoarea $BST{~i + 2 - 2*A~}$ si \"iese\" valoarea {$BST{~i - 2*B~}$}. Nu voi intra in detalii despre modul cum lucreaza aceasta coada. Pe aceeasi idee (utilizarea acestei cozi) se rezolva si problema \"secventa\":problema/secventa (preOJI 2004 - infoarena) si \"trans\":problema/trans (prima proba a selectiei lotului national largit, Buzau 2004).\r\n\r\nh2. Obstacle\r\n\r\nSi aceasta problema se rezolva tot programare dinamica. Asadar avem $BST{~i, 0~}$ = distanta minima parcursa pentru a ajunge la capatul din stanga al gardului numarul $i$ si $BST{~i, 1~}$ = distanta minima parcursa pentru a ajunge la capatul din dreapta al gardului numarul {$i$}. De asemenea notam cu $Cap{~i, 0~}$ = pozitia capatului din stanga al gardului $i$ in sistemul de coordonte si $Cap{~i, 1~}$ = analog pentru capatul din dreapta. Avem urmatoarele recurenta:\r\n\r\n* $BST{~i, j~}$ = $minim(BST{~k, l~} + dst(Cap{~k, l~}, Cap{~i, j~})$ cu $k$ de la $i + 1$ la {$N$}, $l$ si $j$ fiind $0$ sau $1$ si cu proprietatea ca drumul pe Oy dintre $Cap{~k, l~} la gardul $i$ nu se interpune nici un alt gard.\r\n\r\nAceasta recurenta implementata direct ne da o solutie $O(N^2^)$ care, putin optimizata, ar fi putut obtine punctajul maxim. Totusi exista o solutie $O(N log N)$ care utilizeaza o structura de date numita arbori de intervale. Practic noi trebuie sa aflam pentru fiecare gard $i$ care este gardul pe care cade o bila lasata libera din capatul din stanga si din capatul din dreapta. Aceste informatii ne permit reducerea complexitatii recurentei de mai sus la $O(N)$ (nu va mai spun cum, ganditi si voi!). Pentru a afla informatiile despre care vorbeam se parcurg cele $N$ garduri de la $1$ la $N$ (in ordinea asta!) si se proiecteaza, pe rand, pe axa Ox. Practic se pastreaza axa Ox ca un interval [{$-200.000, 200.000$}] si, pentru un gard {$i$}, se egaleaza toate pozitiile din intervalul [{$Cap{~i, 0~}, Cap{~i, 1~}$}] cu {$i$}. Pentru un afla gardul pe care cade bila se interogheaza arborele pentru fiecare capat al gardului {$i$}. Explicatiile mele nu dezvaluie modul in care lucreaza acest arbore de intervale (mi-ar lua cateva zeci de randuri bune daca as intra in detalii). Pentru cei care nu au idee cum functioneaza acest \"monstru informatic\" le recomand citirea \"articolului\":downloads?arbori_de_interval.zip scris pe tema aceasta din sectiunea \"Download\":downloads.\r\n\r\nh2. Skiarea\r\n\r\nProblema se poate rezolva utilizand cunostinte de teoria grafurilor. Mai intai se contruiesc componentele conexe ale fiecarei celule printr-un algoritm de tipul {$FLOOD FILL$}. Prin componenta conexa intelegem set de celule din matrice cu aceeasi valoarea si care indeplineste propietatea ca intre oricare doua celule exista drum (dupa regulile din enunt). Odata aflate aceste componente conexe se construieste un graf asociat lor in urmatorul mod:\r\n\r\n* fiecare componenta conexa are asociat un nod\r\n* intre doua noduri $x$ si $y$ exista drum daca componenta conexa asociata lui $x$ este \"vecina\" cu componenta conexa a lui $y$ (este usor de intuit ce inseamna \"vecina\") si daca valoarea celulelor din $x$ este mai mare decat valoarea celulelor din {$y$}.\r\n\r\nGraful astfel construit este aciclic (acesta se demostreaza usor). In acest graf aflam nodurile in care nu intra nici o muchie - noduri \"sursa\" - (fie numarul lor {$P$}) si toate nodurile din care nu iese nici o muchie - noduri \"destinatie\" - (fie numarul lor {$Q$}). Solutia pentru problema noastra va fi:\r\n\r\n* maxim dintre $P$ si {$Q$}, daca graful are doua sau mai multe noduri\r\n* {$0$}, daca graful are un singur nod.\r\n\r\nToate cele trei etape ({$FLOOD FILL-ul$}, construirea grafului, aflarea nodurilor \"sursa\" si \"destinatie\") se pot realiza in $O(N*M)$ operatii utilizand $O(N*M)$ spatiu de memorie. Mare atentie insa: nici unul dintre pasi nu trebuie realizat recursiv!! (pentru ca altfel se iese din segmentul de stiva pe testele mari).\r\n\r\n\r\n',1,'public'),('stiri/grigore-moisil-by-net','Concursul interjudetean \"Grigore Moisil\" byNet','2006-03-21 00:00:00','h1. Concursul interjudetean \"Grigore Moisil\" byNet\r\n\r\nLuni 27 martie, intre orele 16-19, site-ul infoarena va sustine varianta _by net_ a concursului intejudetean de informatica \"Grigore Moisil\", organizat la Bistrita. Subiectele vor avea patru categorii: clasele VII/VIII, clasa a IX-a, clasa a X-a si clasele XI/XII. Problemele vor fi propuse de doamna profesoara Clara Ionescu, Patcas Csaba, Mihai Pantis si Negruseri Cosmin. Va uram succes!\r\n\r\n',961,'protected'),('moisil-by-net-2006/clasament-7-8','Clasament moisil1','2006-11-24 18:24:49','h1. Clasament ==roundparam(round_id=\"moisil1\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"moisil1\")==',961,'protected'),('stiri/finala-preoni-2006','Finala preONI 2006','2006-03-22 00:00:00','h1. Finala preONI 2006\r\n\r\nSuntem bucurosi sa anuntam marea runda finala a concursului preONI 2006! Aceasta va incepe in curand, mai exact Sambata, 25 martie, ora 09:00. Durata va fi de 5 ore. Finala se desfasoara la Focsani, in judetul Vrancea, fiind gazduita de Colegiul National \"Unirea\". Aici au fost invitati primii 10 de elevi clasati de la fiecare grupa.\r\n\r\nDesi batalia pentru premii se da intre concurentii de la finala, runda se va desfasura online si va fi deschisa tuturor, in stilul obisnuit infoarena! Ai ocazia sa concurezi cot la cot cu cei din finala!\r\n\r\nInformatii suplimentare (comisii, intrebari, tutorial, cum particip?) gasesti pe \'pagina dedicata acestei runde\':preoni-2006/finala.\r\n\r\nSponsorii rundei finale sunt Oracle Romania, Colegiul National \"Unirea\" si Hotelul \"Unirea\" din Focsani.\r\n\r\nClasamentele si solutiile rundei trecute (runda 4) s-au publicat imediat dupa terminarea timpului de lucru la \'adresa\':preoni-2006/runda-4/solutii.\r\n\r\nClasamentul complet, in urma celor 4 runde de calificare se gaseste \'aici\':preoni-2006/clasament.\r\n\r\nFinalistii preONI sunt primii 10 clasati de la fiecare grupa. Acestia vor concura pentru premii in bani si obiecte, la Focsani. Felicitari!\r\n\r\nh2. Clasa a IX-a (si gimnaziu)\r\n\r\n==Rankings(rounds=\"preoni61a|preoni62a|preoni63a|preoni64a\" display_entries=\"10\" pager_style=\"none\")==\r\n\r\nh2. Clasa a X-a\r\n\r\n==Rankings(rounds=\"preoni61b|preoni62b|preoni63b|preoni64b\" display_entries=\"10\" pager_style=\"none\")==\r\n\r\n\r\nh2. Clasele XI-XII\r\n\r\n==Rankings(rounds=\"preoni61c|preoni62c|preoni63c|preoni64c\" display_entries=\"10\" pager_style=\"none\")==\r\n',961,'protected'),('stiri/probleme-de-hosting-si-grigore-moisil-bynet','Probleme cu site-ul, concursul Grigore Moisil by Net','2006-03-29 00:00:00','h1. Probleme cu site-ul, concursul Grigore Moisil by Net\r\n\r\nSite-ul infoarena a fost inaccesibil in ultimele doua zile! :( Site-ul a fost mutat (fortat) pe un nou server de webhosting. Dupa mult efort si insistente am reusit sa-l repunem pe picioare. Momentul a fost foarte nefast. A trebuit sa amanam concursul _Grigore Moisil by Net_. Ne pare sincer rau pentru inconveniente! Stim ca au fost utilizatori care s-au straduit si au pierdut timp ca sa fie prezenti in ziua si la ora respectiva. Nu noi am ales momentul. Din fericire, exista si o parte buna... suntem pe un server nou, performant, avem la dispozitie software up-to-date.\r\n\r\nIn sfarsit, putem indica data si ora exacta la care concursul pe care multi l-au asteptat chiar se va desfasura: Joi, 30 martie, ora 16:00. Subiectele vor avea patru categorii: clasele VII/VIII, a IX-a, a X-a si XI-XII. Problemele vor fi propuse de Prof. Clara Ionescu, Patcas Csaba, Pantis Mihai, Negruseri Cosmin. Informatii suplimentare gasesti pe \'pagina oficiala a concursului\':Moisil-by-net-2006.\r\n\r\nTe asteptam!',961,'protected'),('stiri','Stiri','2006-11-13 05:12:43','h1. Stiri\r\n\r\n== News(display_entries=\"10\") ==',1142,'protected'),('stiri/forum-nou','Forum nou!','2006-04-02 00:00:00','h1. Forum nou!\r\n\r\nForum-ul infoarena s-a mutat la adresa \'infoarena.devnet.ro/forum\':http://forum.infoarena.ro. Ne pare rau pentru mesajele care s-au pierdut in timpul schimbarii, si asteptam parerile voastre despre noul forum si despre noile optiuni pe care acesta le ofera!',1,'protected'),('summer-challenge-unu/solutii','Solutii - Summer Challenge Unu','2007-01-14 13:24:56','h1. Solutii - Summer Challenge Unu\r\n\r\n(Categoria _Competitii_, autor(i) _Cosmin_)\r\n\r\nConcursul a fost unul reusit, adunand un numar respectabil de participanti.\r\nConcurentii ce vor participa la IOI au fost in forma azi ocupand primele trei pozitii ale clasamentului. greco a impresionat placut fiind singurul ce a rezolvat perfect problema de idee a concursului. Il remarcam pozitiv si pe wefgef care se tine aproape de ei, de asemenea o remarca negativa ar fi la adresa lui Adrian Vladu care nu a participat la aceasta pregatire ,desi ea a fost adresata direct lotului olimpic.\r\n\r\nUrmeaza primii 10 clasati:\r\n\r\n==Rankings(rounds=\"summer06\" display_entries=\"10\" pager_style=\"none\")==\r\n\r\nVa invitam mai departe sa va uitati peste schitele solutiilor problemelor propuse.\r\n\r\nh2. Free\r\n\r\nAceasta problema a fost considerata cea mai simpla din concurs, in special pentru ca realizarea unui program experimental care simula pasii din problema ne arata ca usile ce raman inchise au ca index un patrat perfect.\r\n\r\nPentru a demonstra aceasta afirmatie avem nevie de cateva cunostinte minore de teoria numerelor.\r\n\r\nLa fiecare pas $i$ directorul va vizita toti multiplii lui {$i$}, ceea ce inseamna ca un anumit numar $X4 va fi vizitat la pasii ai caror indecsi il divid pe {$X$}. Deci pentru a afla cate usi vor fi deschise in final va trebui sa numaram cate numere au un numar par de divizori. Pentru acest lucru ne va si mai usor sa numaram cate au un numar impar de divizori urmand sa le scadem din {$N$}. Stim ca daca descompunem un numar $X$ in factori primi: {$X=F{~1~}^P{~1~}^*F{~2~}^P{~2~}^*...*F{~t~}^P{~t~}^$} numarul de divizori ai sai va fi {$D=(P{~1~}+1)*(P{~2~}+1)*...*(P{~t~}+1)$}. Pentru ca $D$ sa fie impar trebuie ca fiecare factor al produsului sa fie deci $P{~i~}+1$ impar ceea ce inseamna ca exponentii factorilor primi din descompunere vor fi pari. {$X=F{~1~}^2*P\'{~1~}^*F{~2~}^2*P\'{~2~}^*...*F{~t~}^2*P\'{~t~}^ = (F{~1~}^P\'{~1~}^*F{~2~}^P\'{~2~}^*...*F{~t~}^P\'{~t~}^)^2^$}. Inseamna ca $X$ va fi patrat pefrect.\r\n\r\nAlta demonstratie mai intuitiva ar fi ca pentru usa $X$ putem imperechea actiunea $i$ cu actiunea $X/i$ daca $i$ este divizor al lui $X$ si astfel cele doua isi anuleaza efectul. Daca $X$ este patrat perfect atunci actiunea $[sqrt(X)]$ ramane neimperecheata, deci usa ramane deschisa.\r\n\r\nAstfel solutia problemei va fi {$N-[sqrt(N)]$}.\r\n\r\nOperatiile trebuie implementate pe numere mari. Operatia radical se poate implementa folosind o cautare binara.\r\n\r\nh2. Patrol\r\n\r\nAceasta problema a fost considerata una medie, pentru ca algoritmii de drum minim in grafuri sunt foarte frecvent folositi la concursurile de programare.\r\n\r\nObsevam ca fiecare paznic va fi la orasul de unde a pornit la timpii multipli de {$2*(l{~i~}-1)$} (din cauza miscarii dute-vino). Astfel toti paznicii vor fi in acelasi timp la orasul initial al fiecaruia la toti timpii multipli de {$cmmmc(2*(l{~1~}-1), 2*(l{~2~}-1), ..., 2*(l{~n~}-1))$}. Din cauza ca $l{~i~} < 8$ cel mai mic multiplu comun maxim posibil al numerelor din problema poate fi {$cmmmc(2*4, 2*3, 2*5) = 120$}, astfel pozitiile paznicilor pe reteaua noastra de orase cicleaza si perioada ciclului este $120$ sau un divizor al sau. Vom crea un graf in care nodurile sunt stari ale problemei ({$oras$}, {$timp &#0037; 120$}). Acum am redus problema la determinarea drumului de cost minim de la ({$1, 0$}) la ({$N, timp &#0037; 120$}), putem folosi un algoritm de drum minim la alegere Dijkstra cu heapuri sau bellman ford.\r\n\r\nh2. Pscpld\r\n\r\nAceasta problema se vroia a fi cea mai grea din concurs. O solutie bazata pe siruri de sufixe poate fi gasita in articolul \"Siruri de sufixe\" Adrian Vladu, Negruseri Cosmin, GInfo. Aceasta rezolvare nu ar fi luat punctaj maxim, o solutie similara in $O(n)$ foloseste arbori de sufixe. Denumirea problemei a fost aleasa pentru a sugera ca rezolvarea greoaie cu arbori de sufixe nu este cea cautata. Problema are o solutie simpla in $O(n)$ care urmeaza ideea rezolvarii in {$O(n^2^)$}.\r\n\r\nIn rezolvarea brute force fixam un centru pentru un palindrom si incercam sa marim palindromul cat mai mult. Solutia va pastra un sir $LUNG$ unde $LUNG{~2*i-1~}$ reprezinta lungimea palindromului maxim centrat in caracterul $i$ al sirului si $LUNG{~2*i~}$ lungimea palindromului centrat intre caracterul $i$ si $i + 1$ al sirului. Vom parcurge sirul de caractere de la stanga la dreapta si vom afla in ordine valorile din sirul {$LUNG$}.\r\nSa luam un exemplu:\r\n\r\n== code(cpp) |sirul:  a   b   a   a   b    a     c\r\nLUNG:   1 0 3 0 1 6 1 0 x\r\nindice: 1 2 3 4 5 6 7 8 9 10 11 12 13\r\n==\r\n\r\nAcum daca vrem sa calculam $LUNG{~9~}$ ar trebui sa ne extindem cat putem in lateral fata de {$b$}, dar observam ca centrul palindromului curent este continut in palindromul centrat la {$6$}. Din faptul ca palindromul contine doua subsecvente oglindite, noi nu trebuie sa mai iteram prin literele palindromului nostru pentru ca avem deja rezolvata problema oglindita, si continuam comparatiile cu caractere noi (in cazul nostru avem deja rezolvata problema {$a b a$} in secventa [{$1..5$}] si nu mai trebuie sa o rezolvam inca o data). Am obtinut astfel o rezolvare simpla de complexitate {$O(N)$}. Mentionam ca sursa oficiala nu are mai mult de $50$ de linii.\r\n\r\nExista si alte rezolvari optime posibile si ii rugam pe cei care au luat $100$ de puncte sa le explice in cadrul \"forumului\":http://infoarena.ro/forum/index.php/board,25.0.html.\r\n\r\n',1490,'public'),('summer-challenge-2/solutii','Solutii - Summer Challenge Doi','2006-11-25 13:59:06','h1. Solutii - Summer Challenge Doi\r\n\r\n(Categoria _Competitii_, autor(i) _Adrian Diaconu si Cosmin Negruseri_)\r\n\r\nh2. Sah\r\n\r\nPrima observatie ar fi ca pentru a ne asigura ca intr-o regiune numarul de casute albe este egal cu numarul de celule negre este suficient ca aria regiunii sa fie para.\r\n\r\nPlecand de la aceasta observatie si de la faptul ca $N$ este mereu par propunem urmatoarea impartirea tablei si voi demonstra apoi ca indeplineste conditiile din enunt. Impartim tabla in benzi de latime $2$ (pentru a asigura paritatea ariilor). Apoi prima banda o lasam intreaga, iar pentru urmatoarele banda $i$ se va inmparti in $i-1$ si {$N-i+1$}. Astfel se vor creea $N-1$ regiuni. Se observa ca toate dreptunghiurile difera intre ele prin lungime deoarece se folosesc toate numerele de la $1$ la $N$ mai putin {$N/2$}.\r\n\r\nPentru a demonstra ca $N-1$ este numarul maxim de regiuni care se poate creea vom presupune ca se poate imparti tabla in $N$ regiuni. Vom considera ca se folosesc cele mai mici arii posibile, dar acestea trebuie sa fie toate pare. Suma ariilor va fi $2+4+6+..+2*N= 2*(N*(N+1)/2)=N*N+N$ ceea ce ar depasi tabla noastra.\r\n\r\nh2. Plimbare\r\n\r\nEvident ca o conditie necesara ca un graf turneu (asa se numesc grafurile ca cel mentionat in enunt in care exista exact un arc intre oricare doua noduri) sa aiba un circuit hamiltonean ar fi ca graful sa fie tare conex, daca nu ar fi tare conex atunci evident nu poate exista un circuit intre doua noduri aflate in doua componente tari conexe diferite. Aceasta conditie este si suficienta asa cum va reiesi din algoritmul pe care il vom explica mai jos.\r\n\r\nAstfel pentru graful nostru vom determina componentele tari conexe, si vom cauta un circuit hamiltonean in cea mai mare dintre acestea. De acum ne vom concentra doar asupra nodurilor acestei componente. Evident ca aceasta componenta conexa contine cel putin un circuit, pentru a determina unul facem o cautare in adancime, si trebuie sa gasim la un moment dat o muchie de intoarcere (pentru ca altfel componenta nu ar fi tare conexa). Vom imparti nodurile din aceasta componenta in patru multimi: $A$ multimea nodurilor din circuit, $B$ multimea nodurilor din afara circuitului pentru care exista si arce orientate de la noduri din circuit la ele, si arce orientate de la ele la noduri din circuit, $C$ multimea nodurilor din afara circuitului pentru care exista numai arce ce pornesc din circuit inspre noduri, si $D$ multimea nodurilor pentru care toate arcele intre ele si noduri din circuit sunt orientate de la ele inspre circuit. Puteti observa ca nodurile din multimea $B$ pot fi inserate tot timpul in circuit undeva inlocuind un arc intre doua noduri ale circuitului cu doua arce de la un nod al circuitului la nodul multimii $B$ si apoi la alt nod din circuit. Inserarea unui astfel de nod dureaza maxim $O(n)$ pasi, alti $O(n)$ pasi ar fi necesari pentru modificarea multimilor $B, C, D$ pentru ca circuitul s-a schimbat. Dupa ce nu ne mai ramane nici un nod in {$B$}. Ramanem doar cu noduri de tip $C$ sau {$D$}. Orice nod din multimea $C$ va avea cel putin un arc orientat spre alt nod din multimea $D$ pentru ca altfel nu am fi intr-o componenta tare conexa. Acum aceste doua noduri legate printr-o muchie dinspre $C$ inspre $D$ pot fi inserate in circuit. Astfel am aratat o cale practica de a mari lungimea circuitului pana cand epuizam toate nodurile.\r\n\r\nDaca folosim metoda de determinare a componentelor tari conexe folosind un algoritm eficient de complexitate {$O(N + M)$}, atunci algoritmul are complexitatea $O(N^2^)$ pentru ca la fiecare inserare facem $O(n)$ pasi. Un algoritm mai eficient nu putem obtine deoarece {$M = N(N-1)/2$}, deci si citirea datelor e {$O(N^2^)$}. $N$ a fost fixat la $100$ pentru ca am vrut sa punem accent asupra ideii de gasire a circuitului si nu asupra algoritmului de determinare eficienta a componentelor tari conexe.\r\n\r\nh2. TreiD\r\n\r\nAceasta problema e similara cu problema \"Bmatrix\":problema/bmatrix din arhiva si a fost propusa pentru a favoriza utilizatorii inraiti :).\r\nTrei dreptunghiuri pot avea ca amplasare relativa doar 6 pozitii diferite:\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$ \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}--{@+@}---{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@} &nbsp;&nbsp;{@+@}$\r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@} &nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$          \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$  \r\nsi rotatiile cu 90 de grade ale acestora.\r\n\r\nPentru a determina pentru fiecare configuratie solutia optima putem incerca orice impartire posibila cu doua linii in trei zone a dreptunghiului initial. Apoi ne trebuie pentru fiecare dreptunghi de tipul {$[1..i]x[1..j], [1..i][j..m], [i..n]x[1..j], [i..n]x[j..m], [i..j]x[1..m] si [1..n]x[i..j]$}.\r\nCa sa determinam suma numerelor din un dreptunghi $[r{~1~}..r{~2~}]x[c{~1~}..c{~2~}]$ folosim o matrice $B[i][j]$ care e suma elementelor din {$[1..i]x[1..j]$}, avand aceasta matrice calculata putem determina ca suma elementelor din dreptunghiul $[r{~1~}..r{~2~}]x[c{~1~}..c{~2~}]$ este {$B[r{~2~}][c{~2~}] - B[r{~1~} - 1][c{~2~}] - B[r{~2~}][c{~2~} - 1] + B[r{~1~} - 1][c{~1~} - 1]$}. Pentru a calcula $B[i][j]$ eficient parcurgem elementele matricii initiale $A$ in ordine si avem ca {$B[i][j] = A[i][j] + B[i][j - 1] + B[i- 1][j] - B[i-1][j-1]$}.\r\n\r\nVom explica cum determinam submatricea optima pentru dreptunghiul $[i..j]x[1..m]$ in {$O(n)$}, celelalte dreptunghiuri putand fi determinate intr-un mod asemanator. Avem trei cazuri posibile: linia de sus a dreptunghiului optim nu coincide cu linia {$i$}, si astfel putem lua informatia despre el din rezultatul calculului pentru dreptunghiul {$[i+1..j]x[1..m]$}, al doilea caz e cand linia de jos nu coincide cu linia {$j$}, acum luam rezultatul optim pentru dreptunghiul {$[i..j-1]x[1..m]$}. Al treilea caz cand dreptunghiul optim se sprijina pe liniile $i$ si $j$ il putem rezolva in $O(n)$ asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector {$C$}. $C[k]$ va fi egal cu suma elementelor din dreptunghiul $[i..j] x [k..k]$ (deci suma elementelor din banda $[i..j]$ ce sunt pe coloana {$k$}).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului {$C$}, vom folosi vectorul {$sum[k]$} {$= C[k] + C[k-1] + ... + C[1&#0093;$}. Astfel suma elementelor $C[k..l]$ este egala cu {$sum[l] - sum[k - 1]$}. Pentru a determina subsecventa de suma maxima ce se termina in $l$ trebuie sa gasim cea mai mica $sum[k - 1]$ pentru a maximiza expresia {$sum[l] - sum[k - 1]$}. Astfel obtinem urmatorul cod:\r\n== code(c) |\r\nint min_sum = 0;\r\nint best = - infinit;\r\nfor (int k = 0; k < m; k++) {\r\n    if (best < sum[l] - min_sum)\r\n        best = sum[l] - min_sum;\r\n    if (sum[l] < min_sum) min_sum = sum[l];\r\n}\r\nreturn best;\r\n==\r\nAcest algoritm are complexitatea {$O(n)$}.\r\n\r\nAstfel algoritmul calculeaza in $O(n)$ valoarea optima pentru $O(n^2^)$ zone, deci in total avem un algoritm ce consuma $O(n^2^)$ memorie si are complexitatea $O(n^3^)$ ca timp.',961,'public'),('stiri/summer-challenge-doi','Summer Challenge Doi','2006-08-06 00:00:00','h1. Summer Challenge Doi\r\n\r\nConcursul _Summer Challenge Doi_ este continuarea celui de saptamana trecuta. Ne-au motivat reactiile pozitive primite din partea participantilor.\r\n\r\nConcursul se va desfasura vineri, 11 august, ora 12:00. Durata concursului va fi de 5 ore.\r\n\r\n_Summer Challenge Doi_ este o ocazie de antrenament pentru membrii inraiti ai comunitatii infoarena. Se vor propune spre rezolvare $3$ subiecte cu grade diferite de dificultate, de la accesibil la dificil, comparabile cu cele de la Summer Challenge.\r\n\r\nPregatirea problemelor va fi realizata de de Adrian Diaconu, Cosmin Negruseri, Ionut Fechete si Emilian Miron.\r\n\r\nPentru intrebari si sugestii, te asteptam pe \"forum\":http://forum.infoarena.ro/index.php/board,26.0.html.\r\n',1,'protected'),('moisil-by-net-2006/clasament-10','Clasament moisil3','2006-11-24 18:25:05','h1. Clasament ==roundparam(round_id=\"moisil3\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"moisil3\")==',961,'protected'),('warm-up-2006/solutii','Solutii Autumn WarmUp 2006','2006-11-25 03:42:35','h1. Solutii Autumn WarmUp 2006\r\n\r\n(Categoria _Competitii_, autor(i) _Echipa Infoarena_)\r\n\r\nAici puteti gasi solutiile oficiale la cele 5 probleme propuse in concurs. De precizat si ca aceasta initiativa infoarena a fost un succes, adunand un numar respectabil de participanti. Punctajele au fost mai mici decat cele asteptate, fapt ce a confirmat ca setul de probleme a fost unul capabil sa puna in dificultate nume cunoscute la olimpiadele de informatica. Iata si solutiile:\r\n\r\nh2. poly\r\n\r\nProblema este una de programare dinamica si are complexitatea $O(N)$, de constanta $2^7^ = 128$. Sa notam cu $M{~i,j~}$ lungimea celui mai lung subsir utilizand primele $i$ numere din vector astfel incat ultimul element din subsirul optim sa aiba ca divizori numerele din multimea data corespunzatoare bitilor de $1$ din $j$. Mai intai $M{~i,j~}$ = $M{~i-1,j~}$ ( nu folosim numarul al $i$-lea ). Daca dorim sa folosim si numarul al $i$-lea, atunci $M{~i,config~} = maxim(M{~i,config~}$, $M{~i-1,k~} + 1)$, cu $k and config = 0$, unde config are bitii de $1$ corespunzatori numerelor din multimea data cu care se divide acest al $i$-lea numar din sirul initial. Conditia $k and config$ ne asigura ca penultimul si ultimul numar din subsir nu au amandoua vreun divizor comun din multimea data (operatia $and$ in acest context este o operatie pe biti). Rezultatul va fi $max(M{~n,0~}$, $M{~n,1~}$... $M{~n,127~})$. Memoria folosita poate fi $O(1)$, retinand doar ultimele doua linii ale matricei.\r\n\r\nUn algoritm de complexitate patratica in $N$ folosind tot programarea dinamica ar fi obtinut $30-40$ de puncte.\r\n\r\nh2. bridge\r\n\r\nUn algoritm de complexitate $O(M + N * K)$ folosind programarea dinamica nu este foarte greu de gasit. Daca notam cu $M{~i,j~}$ numarul de moduri (modulo $666013$) de a ajunge in $i$ pasi pe scandura $j$ din pozitia initiala, atunci mai trebuie avut grija doar la relatiile de recurenta. In cazul de fata vom utiliza metoda inainte si vom trata cazurile: daca scandura $j$ este lipsa atunci $M{~i,j~} = 0$, daca scandura $j$ este teleportoare incrementam $M{~i+1,unde[j]~}$ cu $M{~i,j~}$ daca si numai daca {$unde[j]$} nu este lipsa sau subreda ({$unde[j]$} este destinatia teleportarii de pe scandura $j$),daca $j$ este scandura buna, incrementam $M{~i+1,j+1~}$ cu $M{~i,j~}$ si $M{~i+1,j+2~}$ cu $M{~i,j~}$ doar daca $j+2$ nu e lipsa sau subreda, etc.\r\n\r\nAvand construita matricea $M$, pentru fiecare query putem raspunde acum in $O(1)$. Exista diferite optimizari care pot fi facute si care sporesc substantial timpul de executie.\r\n\r\n\r\nh2. secv4\r\n\r\nDeoarece logaritmul unui produs de numere este egal cu suma logaritmilor fiecarui numar din produs, si in ipoteza ca toate numerele din sir sunt pozitive, logaritmam fiecare numar si notam cu $S{~i~}$ suma primilor $i$ logaritmi. Astfel, pentru a afla secventa de produs maxim care se termina pe pozitia $i$, este suficient sa determinam, pentru $k$ intre $i-y$ si $i-x$ care este $S{~k~}$ minim (astfel, $S{~i~} - S{~k~}$ va fi maxim, deci si produsul maxim, iar secventa va incepe pe pozitia $k+1$). Putem folosi un arbore de intervale si obtinem un algoritm $O(NlogN)$, sau o coada prin care scoatem elementele prin ambele parti (structura de date numita deque - double ended queue), obtinand complexitatea $O(N)$. Daca exista si numere negative, in momentul logaritmarii numerelor negative logaritmam opusul lor. Aplicand procedeul descris mai sus, stim sigur la final ca produsul obtinut are modulul maxim. Pentru a fi cu adevarat maxim (deci pozitiv), notam cu $semn{~i~}$ semnul produsului primelor $i$ numere. Ca secventa {@<j+1, i>@} sa aiba produs maxim trebuie in plus $semn{~i~} = semn{~j~}$. Vom retine doua deque-uri, unul pentru {$+$} si unul pt {@-@}, conform vectorului semn. Astfel, in final, suntem siguri ca produsul are semnul {$+$} si, cum are si modulul maxim, are valoarea maxima ceruta.\r\n\r\n\r\nh2. parcare\r\n\r\nProblema este exponentiala in dimensiunea matricii, dar polinomiala in numarul total de posibilitati de pozitionare al masinilor. Astfel, vom folosi un algoritm de tip BFS care garanteaza ca se ajunge la solutie intr-un numar minim de miscari. Plecam de la matricea initiala, si expandam pe rand toate starile posibile, miscand din starea curenta cate o masina pana cand nu mai exista nici o varianta noua de pozitionare a masinilor sau pana cand am scos masina A din parcare. Starile problemei le putem codifica intr-un intreg de $64$ de biti. Singurele variabile sunt pozitiile masinilor. Dupa ce eliminam zidurile inconjuratoare, coordonatele nu sunt mai mari decat $7$ ( $3$ biti ), deci pentru pozitia unei masini vom folosi $6$ biti. Concatenam pozitiile masinilor si, cum sunt maxim $10$ masini, codificarea nu va avea mai mult de $60$ de biti.\r\nPentru a memora starile explorate vom folosi o tabela de hash. De precizat si ca numarul total de posibilitati pornind de la starea initiala este destul de redus, deci problema va rula aproape instantaneu.\r\n\r\nh2. easy query\r\n\r\nUn algoritm simplu de complexitate $O(N*M)$ obtine $30-50$ de puncte. Algoritmul de $100$ de puncte are complexitatea $O(MlogN)$ si foloseste arbori de intervale. Considerand o secventa $x{~i~} x{~i+1~}... x{~j~}$ este evident ca pentru ca elementele sirurilor $y$ si $z$ sa fie maxime, respectiv minime, ele trebuiesc construite astfel:\r\n\r\n* $y{~t~} = x{~t~}- min(x{~k~}) + max(x{~p~}), i &le; t &le; j, t &le; k, p &le; j$\r\n* $z{~t~} = x{~t~} - max(x{~k~}) + min(x{~p~}), i &le; t &le; j, t &le; k, p &le; j$\r\n\r\nPentru a calcula in timp optim valoarea $P = max(y) + min(z)$ ne vom folosi de un arbore de intervale in urmatorul mod: fiecare nod al acestuia va constitui o secventa $x{~st~}, x{~st+1~}... x{~dr~}$ ( unde $st$ si $dr$ sunt marginile intervalului din nodul arborelui ) pe care o vom rezolva prin metoda brute force de la inceput, avand grija sa precalculam si alte valori necesare mai tarziu, cum ar fi :\r\n\r\n* $min = minim(x{~st~}, x{~st+1~}... x{~dr~})$\r\n* $max = maxim(x{~st~}, x{~st+1~}... x{~dr~})$\r\n* $x_max_max = maxim(x{~t~} + maxim(x{~p~}) ),st &le; t &le; dr si t &le; p &le; dr$\r\n* $x_max_min = minim(x{~t~} - maxim(x{~p~}) ),st &le; t &le; dr si t &le; p &le; dr$\r\n* $x_min_max = maxim(x{~t~} - minim(x{~p~}) ),st &le; t &le; dr si t &le; p &le; dr$\r\n* $x_min_min = minim(x{~t~} + minim(x{~p~}) ),st &le; t &le; dr si t &le; p &le; dr$\r\n* $y_max = maximul din sirul y corespunzator secventei x{~st~}, x{~st+1~}... x{~dr~}$\r\n* $z_min = minimul din sirul z corespunzator secventei x{~st~}, x{~st+1~}... x{~dr~}$\r\n\r\nAvand precalculate valorile de mai sus pentru fiecare nod al arborelui in parte vom putea raspunde in timp $O(logN)$ pentru fiecare din cele $M$ intrebari. Fiecare subsecventa data $x{~i~}, x{~i+1~}... x{~j~}$ va putea fi compusa din reuniunea mai multor noduri din arborele de intervale. Acum parcurgem nodurile ce compun subsecventa data de la dreapta la stanga si vom gasi rapid valorile $maxim(y)$ si $minim(z)$. Presupunand ca am ajuns la nodul $Q$ valoarea $maxim(y)$ pana aici se calculeaza astfel:\r\n\r\n* @MAX(Y) = y_max(Q) = y_max_max(Q) - min(W) = x_min_max(Q)+max(W) = max(Q)+max(W)-min(W)@\r\n\r\nAnalog se calculeaza si $minim(z)$.',961,'public'),('preoni-2005/runda-2/solutii','preONI 2005 runda #2 - solutii','2006-11-23 12:53:03','h1. preONI 2005 runda #2 - solutii\r\n\r\n(Categoria _Competitii_, autor(i) _Echipa devNet_)\r\n\r\nDesi s-a desfasurat intr-o zi de miercuri, runda a doua a concursului preONI a avut un numar aproape dublu de accesari fata de runda 1. Acest lucru se datoreaza probabil atat faptului ca olimpiada judeteana \"bate la usa\" cat si prezentei premiilor oferite de sponsorul nostru, Microsoft Romania.\r\n\r\nIn continuarea acestui articol vom descrie solutiile oficiale ale problemelor. Daca aveti nelamuriri puteti sa puneti intrebari pe \"forum\":http://forum.infoarena.ro/.\r\n\r\nScopul principal al concursului preONI 2005 este antrenamentul pentru ONI. Nivelul problemelor a fost corespunzator, asa ca nu fiti descurajati la OJI daca n-ati facut foarte bine acum! ;)\r\n\r\nPunctajele sunt multumitoare, fiindca de data asta nu s-au mai acordat cel putin $50p$ pentru solutii \"brute force\". Raportul de dificultate al problemelor a fost pastrat ca la runda {$1$}.\r\n\r\nIn continuare vom prezenta solutiile oficiale ale autorilor problemelor.\r\n\r\nh2. Clasele 9-10\r\n\r\nh3. Clasament\r\n\r\n==Rankings(rounds=\"preoni52a\" display_entries=\"8\" pager_style=\"none\")==\r\n\r\nSub pseudonimele ==user(user=\"arhirel\" type=\"tiny\")== si ==user(user=\"macarie\" type=\"tiny\")== se \"ascunde\", ca si la prima runda, echipa care va reprezenta Romania la finala ACM, formata din Mugurel Andreica, Marius Andrei si Ghinea Dan. Ei au concurat pe un singur calculator pentu a simula un concurs ACM. Stati linistit, premiile se dau doar concurentilor din ciclul de invatamant pre-universitar! De asemenea, se pare ca unii concurenti simt nevoia sa-si creeze mai multe conturi, Sorin Fagateanu avand 3 conturi in top 5 (cele 2 pe numele lui si contul cu numele \"Ion Iliescu\")... Tineti minte ca la un concurs \"standard\" nu aveti voie cu mai multe surse!\r\n\r\nh3. Pascal\r\n\r\nCa sa calculam puterea la care apare factorul prim $p$ in descompunerea lui $n!$ se poate folosi urmatoare formula $f = [n/p] + [n/p^2^] + [n/p^3^] +$ ... ({$[]$} reprezinta partea intrega). Avand acesta formula putem traversa un anumit rand din triunghiul lui Pascal si pt fiecare element ({$r,c$}) putem calcula puterea la care apare $d$ in descompunerea lui $r ! / ((r-c) ! * c!)$ . Atunci cand $d$ nu este prim trebuie sa avem grija sa verificam daca respectivul element ({$r,c$}) are in descompunerea sa toti factori primi a lui {$d$}. Daca $d=6$ , elementul din ({$r,c$}) trebuie sa contina $2$ si $3$ in descompunerea sa, iar daca {$d = 4$}, trebuie sa contina $2$ de cel putin doua ori.\r\n\r\nO alta modalitate sa calculam puterea la care apare un factor prim $p$ in descompunerea lui este: fie {$A{~c~}$} = puterea la care apare $p$ in decompunrea lui ({$r,c$}). $A{~c+1~}$ = {$A{~c~}$} + puterea lui $p$ in ({$r-c$}) - puterea lui $p$ in ({$c+1$}). Acesta relatie se poate deduce din modul din care putem calcula elementul ({$r,c+1$}) din ({$r,c$}) folosind formula ({$r,c$}) = $r ! / ((r-c)! * c !)$\r\n\r\nAceasta a fost cea mai simpla problema de la clasele {$9-10$}, oricare din cele doua idei prezentate mai sus aducand punctaj maxim.\r\n\r\nh3. Secv\r\n\r\nSubsirul trebuie sa contina toate elementele din sirul original in ordine crescatoare asa ca primul pas este sa ne formam acest subsir {$C$}. Avand acest subsir, parcurgem vectorul initial pentru a gasi pozitia de start a noii subsecvente. Dupa ce am gasit o posibila pozitie de start s incercam sa gasim subsirul $C$ avand ca pozitie de start {$s$}. Din toate aceste subsecvente o alegem pe aceea cu lungimea minima. Asftel, complexitatea algoritmului ajunge la {$O(N*M)$}, unde $N$ este lungimea secventei initiale si $M$ lungimea subsirului {$C$}. Problema se poate rezolva in aceeasi complexitate si cu programare dinamica, lasam acesta rezolvare ca exercitiu pentru concurenti!\r\n\r\nh3. Car\r\n\r\nLa prima vedere problema pare simpla si abordabila cu o cautare in latime, dar la o citire mai atenta problema se dovedeste putin mai grea. Cerinta e una de gasire a drumului minim intr-un graf in care nodurile sunt reprezentate de trei intregi ({$i,j,dir$}), $i$ si $j$ avand semnificatia liniei si coloanei din matrice iar $dir$ reprezinta directia cu care am intrat pe pozitia curenta. Muchiile din graful nostru au costurile dupa cum s-a explicat in enunt. Pentru gasirea drumului putem folosi algoritmul Dijkstra care foloseste un heap pentru expandarea nodurilor, complexitatea unei astfel de rezolvari ar fi fost $O(N*M lg (N*M))$ dar un asemenea algoritm nu ar fi luat punctaj maxim. O observatie care ne poate reduce constanta algoritmului ar fi ca nu are rost sa folosim curbe de $180$ sau de $135$ de grade, pentru ca am fi ajuns in aceeiasi pozitie mai repede. Pentru a nu folosi memorie prea multa pentru reprezentarea nodurilor in coada noastra de prioritati am putea folosi un singur intreg in loc de trei astfel:\r\n\r\n== code(cpp) |x = ((i - 1) * m + (j - 1)) * 8 + dir\r\n==\r\n\r\nsi decodificarea ar fi\r\n\r\n== code(cpp) |dir = x % 8; x /= 8;\r\nj = (x % m) + 1;\r\ni = (x / m) + 1;\r\n==\r\n\r\nPentru a avea o viteza mai mare la codificare si decodificare putem folosi operatii pe biti: $dir$ sa fie reprezentat pe $3$ biti {$i$}, pe urmatorii $9$ biti, iar $j$ pe urmatorii $9$ biti ({$i,j &le; 500 < 2^9^=512$}), astfel codificarea si decodificarea devin\r\n\r\n== code(cpp) |x = (i << 9) + j + (dir << 18);\r\ndir = x >> 18;\r\nj = (x & 511);\r\ni = (x >> 9) & 511;\r\n==\r\n\r\nCosturile muchiilor in graful nostru sunt mici si un algoritm ca cel\r\nal lui Dijkstra nu tine cont de aceasta proprietate. Daca aceste costuri sunt mici atunci si costul final al drumului de la sursa la destinatie va fi mic deci ne permitem sa folosim pentru fiecare valoare posibila a costului unui drum de la sursa la destinatie cate o lista. Cand am determinat pentru un nod distanta minima de la sursa la el, il inseram intr-o astfel de lista, observam ca expandarea unui astfel de nod poate afecta numai urmatoarele $4$ liste (prin expandare ne referim la actualizarea distantei minime de la sursa a vecinilor nodului curent). O astfel de rezolvare ar arata cam asa (pseudo-C):\r\n\r\n== code(cpp) |for (dir =0; dir < 8; dir++)\r\n    lst[0].add(starti,startj,dir,0);\r\ncurrent_cost = 0;\r\nwhile (lst[0].size()+lst[1].size()+lst[2].size>0){\r\n    while (lst[curent_cost % 3].size()>0) {\r\n        x = lst[curent_cost % 3].pop();\r\n        expand(x);\r\n    }\r\n    curent_cost++;\r\n}\r\n==\r\n\r\nAm folosit numai trei liste pentru ca am tinut cont de optimizarea precizata mai sus de a nu folosi numai curbele la $0$ grade, $45$ grade si $90$ grade. Fiecare nod poate fi expandat o singura data, si poate fi introdus in liste de cel mult trei ori, deci o astfel de solutie are complexitatea ca timp si ca spatiu {$O(N*M)$}. Mergand mai departe pe aceasta idee putem obtine o rezolvare putin mai buna care injumatateste timpul de executie. Costurile au fost alese intr-un mod particular permitand ca o curba de $90$ de grade sa aiba acelasi cost cu doua curbe de {$45$}, una de $135$ acelasi cost ca trei de $45$ si una de $180$ acelasi cost ca si patru de {$45$}. Astfel putem modifica rezolvarea noastra si sa facem numai miscarile urmatoare: rotiri de $45$ de grade pe loc si miscari in fata pe directia de mers. Astfel procedura de expandare actualizeaza numai trei noduri si in cursul procedurii de actualizare putem sa lucram numai cu lista curenta si cu lista urmatoare, pentru ca efectuam numai miscari de cost zero si unu. Aceasta observatie a micsorat numarul de liste si a micsorat numarul de calcule din metoda expand, cea mai frecvent utilizata in algoritm. O astfel de rezolvare ar fi adus punctajul maxim pe aceasta problema. Mentionam ca toate observatiile facute nu ar fi fost neaparat necesare pentru obtinerea unui punctaj maxim. Testele au fost facute in vederea obtinerii a $50$ de puncte folosind cautare in latime simpla, $60-70$ de puncte folosind Dijkstra cu heapuri si $90-100$ de puncte folosind penultima rezolvare.\r\n\r\nh2. Clasele 11-12\r\n\r\nh3. Clasament\r\n\r\n==Rankings(rounds=\"preoni52a\" display_entries=\"7\" pager_style=\"none\")==\r\n\r\nClasamentul la 11-12 este dominat de echipa ACM care a reusit sa rezolve toate cele 3 probleme (pe unul din cele doua conturi). Este de remarcat faptul ca primii $5$ clasati au punctaje peste $200$ de puncte.\r\n\r\nh3. Indep\r\n\r\nProblema se poate rezolva in mai multe moduri. Limitele au fost alese astfel incat problema sa fie cat mai usoara. Vom prezenta cele doua solutii pe care le puteti gasi interesante:\r\n\r\nh4. Solutia 1\r\n\r\nPrima solutie, si cea mai simpla, utilizeaza principiul programarii dinamice. Se calculeaza numarul de subsiruri din primele $i$ elemente care sunt divizibile cu un numar $j$ intre $1$ si {$1000$}. Sa notam acest numar cu {$Cnt{@[@}i{@][@}j{@]@}$}. Se obtine urmatoare recurenta pentru calculul acestor valori:\r\n\r\n== code(cpp) |Cnt[i][cmmdc(j, A[i])] = Cnt[i - 1][j] + Cnt[i - 1][cmmdc(j, A[i])]\r\n==\r\n\r\nOdata calculate aceste valori solutia o vom avea in {$Cnt{@[@}N{@][@}1{@]@}$}. Numerele depasesc orice tip de date predefinit si trebuie utilizate numere mari. Limitele fiind destul de mari, folosirea bazei $10$ este periculoasa, pe unele teste fiind necesar folosirea bazei $10^9^$ pentru a reduce timpul de executie. De asemenea si memoria se poate reduce, observand faptul ca pentru a calcula {$Cnt{@[@}i{@][@}j{@]@}$} ne sunt necesare doar valorile pentru {$Cnt{@[@}i-1{@][@}k{@]@}$} (ultima doua linii). Complexitatea acestei solutiei va fi $O(N * K * L)$ unde $K$ reprezinta valoarea maxima din sir si $L$ lungimea maxima a numerelor mari.\r\n\r\nh4. Solutia 2\r\n\r\nCea de-a doua solutie, cu mult mai interesanta decat prima, foloseste principiul includerii se excluderii. Fie $D(x)$ multimea numerelor din sir care sunt divizibile cu un anumit numar {$x$}, atunci numarul de submultimi formate doar din astfel de numere este {$Z(x) = 2^card(D(x))^-1$}. Multimile pentru principiul includerii si excluderii sunt chiar {$D(p)$}, unde $p$ este un numar prim. Intersectia {$D(p{~1~})$}, {$D(p{~2~})$}, {$D(p{~3~})$}.. este {$D(p{~1~} * p{~2~} * p{~3~}...)$}, oarecum evident, pentru $p$ distincte. Rezultatul este de forma:\r\n\r\n== code(cpp) |Rezultat = Z(1) - Z(2) - Z(3) - Z(5)... +\r\n           Z(2 * 3) + Z(2 * 5) + Z(3 * 5)... -\r\n           Z(2 * 3 * 5) ...\r\n==\r\n\r\nAcesta se deduce din principiul includerii si al excluderii. Pentru a-l calcula efectiv, luam toate numerele {$x < 1000$}, produs de numere prime distincte, si vom adauga sau scadea $Z(x)$ in functie de paritatea numarului de factori ai acestuia. Nu ne intereseaza decat produsele de numere prime distincte, care pot fi obtinute ca un produs {$p{~1~}*p{~2~}*p{~3~}$}... Complexitatea finala este sub {$O(N*K + N*L)$}, unde $K$ si $L$ au semnificatia de mai sus. Folosim $O(N*K)$ pentru a calcula $D(x)$ pentru fiecare {$x$}, dar pentru fiecare $x$ adunam sau scadem $Z(x)$ o singura data, asa ca facem doar $N$ operatii pe numere mari, o imbunatatire majora asupra primei rezolvari. Pentru a obtine aceasta complexitate este nevoie sa precalculam valorile lui $2^x^$ in {$O(N * L)$}, altfel ca sa calculam $Z(x)$ pentru fiecare ar fi nevoie de $O(L * X)$ timp.\r\n\r\nh3. Cerere\r\n\r\nProblema este de dificultate medie. O rezolvare $O(N*lg(N))$ este usor de gasit, fiind asemanatoare cu una deja exista in arhiva, \"Stramosi\":http://www.infoarena.ro/task/stramosi. Dar o astfel de rezolvare n-ar fi adus punctaj maxim in mod normal. Problema se poate rezolva printr-o simpla parcurgere in adancime din radacina implementand manual stiva DF-ului. Cand vom pune un nod $n$ pe pozitia $p$ in stiva, al {$K$}-lea stramos va fi nodul de pe pozitia $p-K$ din stiva, pentru care s-a procesat deja valoarea ceruta. Complexitatea finala a algoritmului va fi {$O(N)$}.\r\n\r\nh3. Rubarba\r\n\r\nAceasta problema e clasica in geometria computationala. O prima observatie care ne ajuta in rezolvare este ca numai punctele de pe infasuratoarea convexa influenteaza forma dreptunghiului minim. Deci primul pas in rezolvarea problemei este sa gasim infasuratoarea convexa a punctelor in {$O(N*lg(N))$}. Daca avem fixata o directie atunci e usor sa determinam in $O(h)$ (unde $h$ e numarul de puncte de pe infasuratoarea convexa) cele patru puncte ce marginesc dreptunghiul dupa directia aleasa si dupa directia perpendiculara. Folosind cautare binara pentru a determina cele patru puncte extreme, reducem astfel complexitatea la {$O(lg(h))$}. Observatia finala este ca un dreptunghi de arie minima ce contine o multime de puncte in interior trebuie sa aiba o latura paralela cu una din laturile infasuratorii convexe, aceasta idee este intuitiva dar demonstratia ei nu este foarte simpla. Complexitatea algoritmului ce rezolva problema poate fi $O(N*lg(N) + h^2^)$ sau $O(n*lg(n) + h*lg(h))$ daca folosim cautarea binara. Testele folosite au fost generate aleator, generand aleator puncte in plan infasuratoarea convexa va avea cardinalul $h$ teoretic egal cu {$&#920;(lg(N))$}, deci rezolvarea $O(N*lg(N) + h^2^)$ ar fi luat fara probleme punctaj maxim. Mentionam ca exista o tehnica numita \"Rotating Calipers\" care rezolva aceasta problema si altele similare in {$O(N*lg(N) + h)$}, daca vreti sa cititi despre aceasta tehnica accesati \"pagina\":http://cgm.cs.mcgill.ca/~orm/rotcal.html. Idei de acolo v-ar fi ajutat sa rezolvati problema propusa recent la \".campion\":http://campion.edu.ro/index.php, care cerea separarea a doua poligoane convexe cu o dreapta, si o prolema propusa anul trecut la Bursele Agora care cerea determinarea distantei maxime ce exista intre oricare doua puncte dintr-o multime, si tot pe acea pagina gasiti demonstratia matematica a faptului ca dreptunghiul de arie minima ce contine in interior o multime de puncte are o latura paralela cu o latura a infasuratorii convexe.\r\n\r\nh2. Incheiere\r\n\r\nPana la urmatorul concurs, BAFTA LA OJI!\r\n\r\n',961,'public'),('template/infoarena','template/infoarena','2006-11-27 00:35:58','Special infoarena template\r\n\r\n== Gallery(page=\"template/infoarena\" file=\"%\") ==',13,'protected'),('documentatie/development','Development','2007-01-27 19:40:07','h1. Development\r\n\r\ninfoarena imbratiseaza mentalitatea open-source: codul nostru sursa este \'liber disponibil\':http://hackers.devnet.ro/browser iar dezvoltarea se face \'public\':http://hackers.devnet.ro.\r\n\r\nh2. Stii PHP/tehnologii web/design sau vrei sa inveti?\r\n\r\nAvem nevoie de ajutorul tau! Instaleaza-ti infoarena pe calculatorul tau si rezolva un \"ticket\":http://hackers.devnet.ro/report/3.\r\nAm documentat intreg procesul, am scris tutoriale, am comentat codul sursa, am planificat tichete si suntem alaturi de tine daca ai intrebari.\r\n\r\n\"Click aici - doar pentru programatori\":http://hackers.devnet.ro/\r\n\r\nh2. Pe cine poti contacta\r\n\r\nDaca vrei sa contribui si ai nelamuriri, contacteaza pe unul (sau mai multi :) dintre cei care lucreaza la codul sursa infoarena.\r\n\r\n* ==user(user=\"fluffy\" type=\"tiny\")==\r\n* ==user(user=\"wickedman\" type=\"tiny\")==\r\n* ==user(user=\"domino\" type=\"tiny\")==\r\n* ==user(user=\"DITzoneC\" type=\"tiny\")==\r\n* ==user(user=\"svalentin\" type=\"tiny\")==\r\n\r\nPe paginile lor vei gasi informatii de contact (email, IM) sau le poti trimite mesaj privat.',75,'public'),('identity.php','identity.php','2006-11-28 14:59:20','Scrie aici despre identity.php',2000,'public'),('preoni-2006/program','Program, preONI 2006','2006-11-27 16:14:30','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Program\r\n\r\nConcursul este structurat in 3 grupe dupa cum este precizat si in regulament. Acest lucru se datoreaza structurarii similare care se practica la Olimpiada Nationala de Informatica. Concursul va fi impartit in 4 etape online si la sfarsit primii 10 participanti la fiecare grupa conform clasamentului se vor califica la etapa finala on-site a concursului.\r\n\r\nh2. Etapele Online\r\n\r\nSubiectele vor fi atent alese de o echipa de specialisti in domeniu cu experienta vasta in concursuri. Acestea vor fi similare ca dificultate cu cele date la ONI in anii prcedenti. Fiecare grupa va avea spre rezolvare cate 3 probleme in 4 ore, oferindu-se un sfert de ora suplimentar pentru ca toti concurentii sa isi trimita sursele.\r\n\r\nIn continuare va vom prezenta programul celor 5 runde ale concursului, cu mentiunea ca pot interveni schimbari in orice moment.\r\n\r\n|_. Runda  |_. Logo |_. Data |_. Pagina rundei, cu detalii |\r\n| #1 | !preoni-2006/program?runda1.jpg 50%! | 19 noiembrie 2005 | \"Runda 1\":preoni-2006/runda-1 |\r\n| #2 | !preoni-2006/program?runda2.jpg 50%! | 17 decembrie 2005 | \"Runda 2\":preoni-2006/runda-2 |\r\n| #3 | !preoni-2006/program?runda3.jpg 50%! | 21 ianuarie 2006  | \"Runda 3\":preoni-2006/runda-3 |\r\n| #4 | !preoni-2006/program?runda4.jpg 50%! | 19 februarie 2006 | \"Runda 4\":preoni-2006/runda-4 |\r\n|Finala| !preoni-2006/program?runda5.jpg 50%! | 24-26 martie 2006 | \"Runda finala\":preoni-2006/finala |\r\n\r\nh2. Runda finala\r\n\r\nEtapa finala se va desfasura in cadrul unei tabere intr-o locatie care va fi stabilita in curand. Cei care nu se vor califica la runda finala vor putea participa on-line pe info-arena la aceasta proba. Pentru mai multe detalii faceti click aici. \r\n\r\n==include(page=\"template/preoni-2006/footer\")==\r\n',13,'public'),('colaboratori-infoarena','Colaboratori infoarena','2006-11-27 08:32:10','h1. Colaboratori\r\n\r\n==include(page=\"template/todo\")==\r\n\r\n_(aici trebuie sa punem un macro cu atribute/tags de utilizatori)_\r\n',13,'public'),('contact','Contact','2006-12-27 14:45:51','h1. Contact\r\n\r\nCel mai usor si mai rapid poti lua legatura cu noi pe ==SmfLink(link=\"forum\" caption=\"forum\")==. Aici ne gasesti pentru intrebari, sugestii, probleme. Pe forum discutam despre articolele si despre problemele de pe site.\r\n\r\n*Chiar si in timpul concursurilor online, intrebarile catre comisie se adreseaza pe forum*.\r\n\r\nNumai pentru alt fel de chestiuni, puteti trimite un e-mail la strat.cristian -at- gmail.com',5,'public'),('asociatia-infoarena','Asociatia infoarena','2006-12-11 03:18:29','h1. Asociatia infoarena\r\n\r\n==include(page=\"template/despre-infoarena\")==\r\n\r\nAsociatia infoarena (organizatie non-profit) este in curs de constituire. Pe masura ce demersurile se apropie de finalizare vom reveni cu detalii despre statut, membri fondatori, organigrama etc.\r\n\r\nAsociatia confera comunitatii infoarena personalitate juridica. Asociatia ne ajuta &hellip;\r\n\r\n* &hellip; sa primim mai usor sponsorizari din partea companiilor private\r\n* &hellip; sa ne protejam brand-ul infoarena\r\n* &hellip; sa protejam drepturile de autor ale materialelor contribuite de comunitate\r\n',13,'public'),('summer-challenge-3/solutii','Solutii - Summer Challenge Trei','2006-11-25 03:41:44','h1. Solutii - Summer Challenge Trei\r\n\r\n(Categoria _Competitii_, autor(i) _Echipa Infoarena_)\r\n\r\nh2. ABC\r\n\r\nProblema se reduce la $3$ cazuri, in functie de cum este $C$ fata de suma termenilor sirului {$A$}. Daca aceste numere sunt egale, sirul $D$ cautat este chiar sirul {$A$}. In caz contrar, vom rezolva problema pentru $C$ mai mare, celalalt caz fiind analog. Va trebui deci sa marim cateva dintre elementele lui {$A$}. O observatie este utila in acest moment: daca {$A{~i~}<A{~j~}$}, atunci exista o solutie optima cu {$D{~i~}<D{~j~}$}. Pentru a demonstra aceasta afirmatie, observati ca in caz contrar, interschimband valorile $D{~i~}$ si $D{~j~}$ se obtine o solutie pentru care suma termenilor lui $D$ este aceeasi, dar valoarea maxima a sirului din enunt (pe care o vom numi in continuare {$delta$}) este mai mica, sau in cel mai rau caz egala.\r\n\r\nSa incercam acum sa obtinem un sir $D$ pentru o valoare fixata a lui {$delta$}. Pornim cu sirul $D$ egal cu cel initial, {$A$}. Atat timp cat suma termenilor lui $D$ este mai mica decat $C$ vom aplica urmatoarea operatie: vom mari cu o unitate un termen al lui {$D$}. Mai trebuie avut grija ca tot timpul sa fie respectata conditia {$D{~i~} &le; A{~i~}+delta$}. Daca nu mai putem aplica nici o operatie (toti termenii au atins valoarea maxima posibila, sau prin marire am obtine o diferenta mai mare decat {$delta$}), si inca nu am obtinut {$C$}, nu putem gasi nici un sir $D$ pentru acest {$delta$}, si in plus am obtinut un sir $D$ cu suma termenilor maxima posibila pentru valoarea curenta a lui {$delta$}. Se poate demonstra ca nici nu conteaza ce termen marim, atat timp cat respectam observatia din paragraful anterior. Pentru a obtine insa o complexitate liniara la acest pas, vom mari termenii in ordine descrescatoare (evident dupa o sortare initiala). Bineinteles, nu este nevoie sa aplicam fiecare operatie in parte, ele vor fi aplicate toate in acelasi timp. Pentru cazul analog din paragraful precedent, o operatie va consta din scaderea unui termen cu o unitate, pornind de data aceasta de la cel mai mic.\r\n\r\nIn plus, daca marim valoarea lui $delta$ la {$delta+1$}, putem aplica in continuare operatii asupra lui {$D$}, de unde am ramas la pasul precedent, obtinand deci sume mai mari. Se contureaza acum o rezolvare: putem cauta binar valoarea lui {$delta$}. Daca am obtinut un sir $D$ care sa respecte conditiile din enunt, putem cauta un $delta$ mai mic, daca nu, trebuie sa marim {$delta$}. Complexitatea algoritmului rezultat este {$O( N log N)$}.\r\n\r\nDupa sortarea sirului {$A$}, putem obtine un algoritm liniar rafinand solutia de mai sus. Aceasta afirmatie se bazeaza pe urmatoarea observatie (presupunem sirul $A$ sortat in ordine descrescatoare): daca putem creste $A{~i~}$ cu valoarea {$d$}, atunci putem creste cu valoarea $d$ orice {$A{~j~}$}, cu {$j > i$}. Vom parcurge valorile lui $A$ in ordine crescatoare a indicilor. La pasul $i$ ({$i$} ia valori intre $1$ si {$N$}) ne folosim de valorile {$D{~i-1~}$}(convenim ca {$D{~0~}=B$}) si $S$ (numarul de unitati cu care mai trebuie marita suma in continuare) si vom creste pe $A{~i~}$ cu valoarea {$d=min(D{~i-1~}-A{~i~}, ceil(S/(N-i+1)))$}. Bineinteles, la pasul urmator si $S$ va scadea corespunzator.\r\n\r\nh2. Oras\r\n\r\nSa presupunem ca avem o solutie pentru $N-2$ noduri. Acum adaugam la solutie nodurile {$N-1$}, si {$N$}. Fara a restrange generalitatea putem orienta strada ({$N-1, N$}) de la {$N-1$}, la {$N$}. Acum oricare ar fi un nod $X$ de la $1$ la $N-2$ trebuie sa fie pe un circuit de $3$ noduri cu nodurile $N-1$ si {$N$}. Astfel putem fixa ca de la nodurile ${1, 2, ..., N-2}$ sa plece arce inspre nodul {$N-1$}, si de la nodul $N$ sa plece arce inspre nodurile {${1, 2, ..., N-2}$}. Daca graful initial cu $N - 2$ noduri satisfacea conditiile problemei, atunci si graful obtinut este valid. Pentru $N = 3$ exista o solutie triviala, pentru $N = 4$ putem demonstra ca nu exista solutie (demonstratia trebuind sa ia in calcul mai multe cazuri), sau putem sa generam exhaustiv toate grafurile turneu cu $N = 4$ si sa observam ca nici unul nu e valid. Gasirea unei solutii pentru $N = 6$ este destul de facila (autorului i-a luat $2$ minute). Astfel am aratat ca avem solutie pentru toate cazurile din problema, inafara cazului {$N = 4$}. Complexitatea acestei solutii este {$O(N^2^)$}.\r\n\r\nh2. Gold\r\n\r\nSolutia triviala este {$O(N^3^)$}: se aleg doua puncte si se verifica suma cantitatilor din ambele parti ale dreptei printr-o parcurgere noua a punctelor. O astfel de solutie obtine $30-40$ de puncte. Pornind de la aceasta idee se poate rafina ajungand la o complexitate de {$O(N^2^logN)$}. Pentru fiecare punct $P$ sortam celelalte $N-1$ puncte dupa unghiul polar ( unghiul format de punctul curent cu axa Ox, daca consideram originea in punctul {$P$}) in {$O(NlogN)$}. Notam cu {$S{~i~}$} suma cantitatilor din primele $i$ mine in ordinea ordonarii dupa unghi. Vom fixa o dreapta de baleiere care sa treaca prin punctul $P$ si prin primul punct in ordinea sortarii. Daca am calculat la un anumit pas toate punctele aflate de o parte a dreptei de baleiere, in momentul in care rotim dreapta de baleiere pana ajunge in dreptul urmatorului punct (in ordinea sortarii) toate aceste puncte raman de aceeasi parte mai putin cel aflat pe dreapta si eventual se vor adauga unele noi. De aceea vom incepe cautarea ultimului punct aflat in sensul $+$ al dreptei\r\nde baleiere de la punctul calculat la pasul anterior( toti indicii vor fi calculati modulo {$N$}). Fiecare punct va fi parcurs de cel mult doua ori, deci complexitatea acestui pas este {$O(N)$}. Astfel vom putea calcula in $O(1)$ sumele de o parte si de alta a dreptei folosindu-ne de vectorul {$S$}.\r\n\r\n',961,'public'),('stiri/autumn-warmup-2006','Autumn WarmUp 2006','2007-01-27 19:55:02','h1. Autumn WarmUp 2006\r\n\r\nInfoarena organizeaza inca un concurs vacanta asta pentru a te mentine in forma. De data aceasta, echipa infoarena \"a predat stafeta\", si da o sansa celor mai dedicati utilizatori sa realizeze propriul lor concurs - un concurs facut de utilizatori pentru utilizatori.\r\n\r\nSe vor propune spre rezolvare $5$ subiecte cu grade diferite de dificultate, de la accesibil la dificil. Evaluatorul va fi pornit pe toata durata concursului.\r\n\r\nProblemele vor fi propuse de:\r\n\r\n* ==user(user=\"PaulDB\" type=\"tiny\")==\r\n* ==user(user=\"vladcyb1\" type=\"tiny\")==\r\n* ==user(user=\"vladut\"  type=\"tiny\")==\r\n* ==user(user=\"devilkind\"  type=\"tiny\")== \r\n* ==user(user=\"VladSaveluc\"  type=\"tiny\")==\r\n\r\nSperam ca si acest concurs va fi un succes si va asteptam in numar cat mai mare.',75,'protected'),('template/newround/clasament','Clasament %round_id%','2006-11-23 21:06:44','h1. Clasament ==roundparam(round_id=\"%round_id%\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"%round_id%\")==',1142,'protected'),('lca-lowest-common-ancestor','LCA: Lowest common ancestor','2006-11-23 21:56:53','h1. LCA: Lowest common ancestor\r\n\r\n(Categoria _Arbori_, autor(i) _Miron Emilian_)\r\n\r\nProblema luata in discutie este ca, avand un arbore dat, sa putem raspunde rapid la multe intrebari de genul: _\"Care este stramosul comun cel mai apropiat dintre doua noduri din arbore?\"_.\r\n\r\nh2. Exemplu\r\n\r\n!LCA-Lowest-common-ancestor?euler.jpg!\r\n\r\nPentru arborele din imagine, avem ca exemplu urmatoarele query-uri:\r\n\r\n* $lca(2,3) = 1$\r\n* $lca(4,5) = 1$\r\n* $lca(5,6) = 3$\r\n* $lca(1,5) = 1$\r\n* $lca(5,3) = 3$\r\n\r\nh2. Aplicabilitate\r\n\r\nDandu-se un arbore cu costuri sa se raspunda rapid la intrebari de genul: _\"care este distanta minima intre doua noduri date?\"_. O solutie pentru problema de fata ar fi:\r\n\r\n* agatam arborele intr-un nod oarecare si obtinem un arbore cu radacina\r\n* pentru fiecare nod $i$ precalculam {$dist{~i~}$}, reprezentand distanta sa pana la radacina\r\n* precalculam cele necesare pentru algoritmul de _Lowest Common Ancestor_\r\n* distanta dintre doua noduri oarecare $i$ si $j$ va fi egala cu {$dist{~i~} + dist{~j~} - dist{~lca(i,j)~}$}\r\n\r\nh2. Mod de calcul\r\n\r\nIn prima etapa a algoritmului facem o parcurgere euleriana a arborelui dat. O parcurgere euleriana este o parcurgere a arborelui in ordinea din figura: se parcurg fii si se intercaleaza intre ei tatal, obtinand o parcurgere continua.\r\n\r\nMai exact pentru fiecare nod procedam astfel, incepand cu radacina:\r\n\r\n* daca nodul curent este frunza il adaugam la parcurgere\r\n* daca are fii atunci il punem la inceput, la sfarsit si intre parcurgerile euler ale fiilor\r\n\r\nCand facem aceasta parcurgere retinem de asemenea si urmatoarele informatii suplimentare:\r\n\r\n* adancimea fiecarui nod din parcurgere, obtinand un sir de adancimi\r\n* una din pozitiile pe care fiecare nod apare in parcurgere\r\n\r\nIdeea este ca {$lca(i, j)$} este chiar nodul cu cea mai mica adancime intre pozitiile lui $i$ si a lui $j$ in parcurgere. Pentru graful din figura de mai sus avem:\r\n\r\ntable(example). |_. Euler|_. Adancimi|\r\n|12421353631|12321232321|\r\n\r\nPentru perechea de noduri ({$4, 3$}), avem {$lca(4, 3)$} egal cu nodul care se gaseste intre {$poz{~4~}$} si {$poz{~3~}$} in parcurgerea euler si are adancimea minima. Acest nod este $1$, deci {$lca(4, 3) = 1$}.\r\n\r\nAm redus problema la aflarea minimului intre doua pozitii ale unui sir ({_Range Minimum Query_}). Aceasta subproblema o putem rezolva optim folosind arbori de intervale, sau o metoda folosind spatiu supraliniar ({$Nlog{~2~}N$}) a minimelor pe intervale de puteri ale lui {$2$}, incepand de la pozitia {$i$}. Timpul de preprocesare este {~O(N)~} pentru arbori de intervale si {$O(Nlog{~2~}N)$} pentru a doua metoda. In ambele variante timpul de interogare este {$O(log{~2~}N)$}.\r\nVom prezenta in continuare metoda cu spatiu supraliniar. Calculam minimele inductiv, pastrand:\r\n\r\n* {$min{~i,k~}$} = minimul pe intervalul {$[i...i+2^k^-1]$} (de lungime {$2^k^$}), si\r\n* {$minpos{~i,k~}$} = pozitia minimului de pe intervalul {$[i...i+2^k^-1]$}.\r\n\r\nAcest tablou va fi construit recursiv astfel: pentru $k = 0$ avem {$min{~i,0~} = a{~i~}$} si {$minpos{~i,0~} = i$}, iar pentru k > 0 avem:\r\n\r\n* {$min{~i,k~}$} = minim({$min{~i,k-1~}$}, {$min{~i+2^k-1^,k-1~}$})\r\n* {$minpos{~i,k~}$} = pozitia minimului ({$minpos{~i,k-1~}$} sau {$minpos{~i+2{^k-1^},k-1~}$})\r\n\r\nPentru _query_ intre pozitiile $l$ si $r$ procedam astfel: fie $k$ cel mai mare numar astfel incat {$2^k^$} &le; lungimea intervalului {$(l, r)$}.\r\n\r\n&nbsp;&nbsp;&nbsp;&nbsp; {$min(l, r)$} = minim( {$min{~l,k~}$}, {$minimul pe intervalul (l+2^k^, r)$})\r\n&nbsp;&nbsp;&nbsp;&nbsp; {$pozmin(l, r)$} = pozitia minimului intre $l$ si $r$\r\n\r\nDaca {$l = pos{~i~}$} si {$r = pos{~j~}$} ({$pos{~i~} < pos{~j~}$}) la sfarsitul _query_-ului {$euler{~pozmin~}$} este chiar {$lca(i, j)$}.\r\n\r\n',961,'public'),('aplicatii-ale-cautarii-binare','Aplicatii ale cautarii binare','2006-11-22 02:10:38','h1. Aplicatii ale cautarii binare\r\n\r\n(Categoria _Elementari_, autor(i) _Teodorescu Andrei_)\r\n\r\nVoi prezenta in articolul care urmeaza cateva aplicatii ale cautarii binare. Algoritmii descrisi nu sunt intotdeauna optimi insa prezinta avantajul implementarii mult mai rapide, lucru care constituie un avantaj pe timp de concurs.\r\n\r\n# Sa se gaseasca (daca exista) cel mai mic numar natural $N$ astfel incat {$N!$} sa se termine in exact $p$ cifre de {$0$}, {$p &le; 10^18^$}\r\n# Se considera un teren de forma dreptunghiulara reprezentat de o matrice {$NxN$} care contine in pozitia ({$i,j)$} $1$ daca aceasta este accesibila sau {$0$}, altfel. Se dau $2$ puncte (x{~1~},y{~1~}) si (x{~2~},y{~2~}). Sa se afisize latura maxima a unui patrat care poate fi deplasat intre cele 2 puncte astfel incat acesta sa se afle in orice moment al deplasarii numai pe teren _bun_ (numai cu cifre de {$1$}).\r\n# Sa se calculeze cel mai lung subsir crescator al unui sir de $N$ numere.\r\n# Sa se calculeze cu precizie de $Z$ zecimale: \r\n## radicalul unui numar mare\r\n## catul a $2$ numerere mari (consideram un numar mare un numar cu cel putin $20$ de cifre, care nu poate fi stocat in tipuri de date conventionale)\r\n\r\nIn prima problema trebuie sa observam prima oara ca numarul de zerouri in care se termina {$N!$} creste odata cu {$N$}, observatie evidenta datorita definitiei lui {$N!$}. Atunci, putem cauta binar valoarea lui $N$ pentru care se verifca relatia din enunt. Recomand problema \"Factorial\" din arhiva de probleme InfoArena celor interesati de implementarea algoritmului.\r\n\r\nPentru a doua problema este usor de aratat ca daca daca se poate deplasa intre cele $2$ puncte un patrat de latura {$l$}({$l &ge; 2$}), atunci sigur se va putea deplasa si unul de latura $l-1,l-2...1$ iar daca nu putem deplasa un patrat de latura {$l$}, atunci nu putem deplasa nici unul de latura {$l+1,l+2...n$}. Astfel avem de cautat o valoare $l$ astfel incat putem deplasa un patrat de latura $l$ insa nu si unul de latura {$l+1$}. Numarul $l$ va fi chiar rezultatul cautat. Pentru a face verificarea daca putem deplasa un patrat de o latura data putem folosi algoritmul lui Lee, care implementat atent va avea o complexitate de {$O(n^2^)$}.\r\n\r\nNu voi insista prea mult asupra algoritmului de aflare a celui mai lung subsir crescator al unui sir, problema fiind cunoscuta, de asemenea se gaseste si in cartea \"Psihologia concursurilor de informatica\" de Catalin Francu. Idee de baza este sa se caute binar de fiecare data pozitia fiecarui element intr-un subsir crescator cat mai lung.\r\n\r\nPentru calcularea radicalului unui numar sau calcularea catului a doua numere se cunosc inca din gimnaziu algoritmi! :) Insa acesti algoritmi sunt destul de greu de implemantat(si oricum ajung la un moment dat la folosirea cautarii binare). Asadar in loc de a calcula rezultatul il putem cauta. De exemplu, in primul caz vom cauta o valoare a lui $n$ pentru care $n*n$ sa nu depaseasca numarul dat, insa $(n+1)*(n+1)$ sa depaseasca. Asemanator se procedeaza si in cazul impartirii.\r\n\r\nPentru utilizarea acestor doi algoritmi trebuie ca cel care ii scrie sa stapaneasa foarte bine inmultirea, adunarea, compararea si, eventual, impartirea la $10$ a numerelor mari (vezi articolul de pe site :D). Pentru a obtine o precizie de $z$ zecimale se inmulteste numarul dat(in primul caz)cu $10^2*z^$ si deimpartitul(in al doilea caz) cu $10^z^$ iar in rezultatul obtinut ultimle z cifre vor fi zecimalele iar restul, partea intreaga.\r\n\r\nCa observatie, trebuie sa aveti grija intotdeauna cand alegeti intervalul in care se face cautarea pentru a fi siguri ca algoritmul va produce rezultatlul dorit!\r\n\r\nIn final invit cititorii sa rezolve cateva probleme cu ajutorul cautarii binare:\r\n\r\n* problema \"Proc\":http://www.infoarena.ro/task/proc ,ONI 2003, clasele XI-XII\r\n* problema \"Stramosi\":http://www.infoarena.ro/task/stramosi din arhiva de probleme InfoArena ( indicatie: se realizeaza o parcurgere Euler si o parcurgere in latime a arborelui iar apoi se cauta ficare nod cerut pe nivelul pe care se afla)\r\n* problema \"Loto\":http://www.infoarena.ro/task/loto din arhiva de probleme InfoArena\r\n* problema \"Secventa 3\":http://www.infoarena.ro/task/secv3 din arhiva de probleme InfoArena\r\n* problema \"Tabara\":http://www.liis.ro/~campion/problems/2/96/tabara.htm\r\n* problema \"Multiplu\":http://www.liis.ro/~campion/problems/1/172/multiplu.htm\r\n* problema \"Impartire in trei\":http://www.algoritmus.org/probleme/Probleme_Runda02.php (Algoritmus, Runda 2, Problema 1)\r\n* problema \"Suma\":http://www.algoritmus.org/probleme/Probleme_Runda05.php (Algoritmus, Runda 5, Problema 5)\r\n\r\n',1,'public'),('template/todo','template/todo','2006-12-11 01:53:59','|_=. Aceasta pagina nu este finalizata. Te rugam sa o imbunatatesti. |',13,'protected'),('stiri/bits-n-bytes','Bits \'n\' Bytes ','2005-02-07 00:00:00','h1. Bits \'n\' Bytes \r\n\r\nInca un consurs de programare indian. Concursul se desfasoara pe 2 martie si dureaza 24 de ore, si e individual. Detalii mai multe pe \"site-ul oficial\":http://showcase.csa.iisc.ernet.in/bitsnbytes/index.html.\r\n',1142,'protected'),('bacalaureat-2005','Bacalaureat 2005','2006-11-25 01:47:12','h1. Bacalaureat 2005\r\n\r\nArhiva contine subiecte de bacalaureat propuse de mai multi profesori de informatica din tara. \r\n\r\nToate subiectele dispun de un evaluator online 24/7!\r\n\r\nSucces!\r\n\r\nh2. \'Clasament\':bacalaureat-2005/clasament\r\n\r\n!>bacalaureat-2005?logo.gif!\r\n\r\n== Tasks(round_id=\"bac2005\" pager_style=\"none\") ==\r\n',961,'protected'),('preoni-2006/finala/poze','Poze finala preONI 2006','2006-11-27 16:09:06','==Include(page=\"template/preoni-2006/header\")==\r\n\r\nh1. Poze finala preONI 2006\r\n\r\n== Gallery(page=\"preoni-2006/finala/poze\" file=\"%.jpg\") ==',13,'protected'),('preoni-2006/runda-1/clasament-11-12','Clasament preoni61c','2006-11-25 01:17:08','h1. Clasament ==roundparam(round_id=\"preoni61c\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni61c\")==',961,'protected'),('template/cleanup','template/cleanup','2006-12-14 20:36:39','\r\n|_=. Continutul acestei pagini nu este formatat conform \"recomandarilor de formatare\":documentatie/conventii-de-formatare.\r\nDaca aveti permisiunile necesare, va rugam sa il imbunatatiti. |',15,'protected'),('problema/oras','Oras','2006-11-22 02:52:04','==Include(page=\"template/taskheader\" task_id=\"oras\")==\r\n\r\nCum este sezonul in care se lucreaza intens la drumurile tarii, primarul unui oras oarecare va cere sa il ajutati la marcarea tuturor straziler din orasul sau cu sensuri unice. Exista $N$ intersectii in oras numerotate de la $1$ la $N$ si oricare doua intersectii din acest oras sunt unite de o strada.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati un sens unic pentru fiecare strada astfel ca pentru orice doua numere $x$ si $y$ ({$1 &le; x,y &le; N$}) sa existe un drum care traverseaza cel mult doua strazi pentru a ajunge de la intersectia $x$ la intersectia $y$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $oras.in$ va contine pe prima linie un numar intreg ce reprezinta valoarea lui $N$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $oras.out$ va contine exact $N$ linii. Fiecare linie va contine exact $N$ caractere. Caracterul $j$ al liniei $i$ va fi $\'1\'$, daca sensul strazii dintre $i$ si $j$ este de la $i$ la $j$, daca nu, acest caracter va fi $\'0\'$ . Caracterul $i$ al liniei $i$ va fi intotdeauna $\'0\'$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; N &le; 200$\r\n* In cazul in care nu exista solutie veti afisa $-1$;\r\n* Daca exista mai multe solutii puteti afisa oricare din ele.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. oras.in |_. oras.out |\r\n| 3\r\n| 010\r\n  001\r\n  100 |\r\n\r\nh3. Explicatii\r\n\r\nO solutie pentru N=3 se obtine orientand astfel strazile 1->2 , 2->3 , 3->1 . Ajungem de la 1 la 2 folosind strada 1->2, de la 1 la 3 folosind strazile 1->2, 2->3, de la 2 la 1 folosim strazile 2->3, 3->1 , de la 2 la 3 folosind strada 2->3 , de la 3 la 1 folosind strada 3->1, de la 3 la 2 folosind strazile 3->1, 1->2 .\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"oras\")==',1,'task: oras'),('multe-smenuri-de-programare-in-cc-si-nu-numai','Multe \"smenuri\" de programare in C/C++... si nu numai!','2007-01-13 20:07:08','h1. Multe \"smenuri\" de programare in C/C++... si nu numai!\r\n\r\n(Categoria _Limbaje_, autor(i) _Mircea Pasoi_)\r\n\r\nAcest articol vine ca o completare a articolului scris de Alexandru Mosoi, prezentand noi trucuri care le-am folosit si m-au ajutat mult. O mare parte din acestea le-am invatat din sursele lui Radu Berinde (cred ca stiti cu totii cine este), asadar ii multumesc!\r\n\r\nh2. Array-uri neindexate de la 0\r\n\r\nUn dezavantaj fata de Pascal este faptul ca in C nu putem avea expresii de genul {@A[-100]@} unde $A$ este un vector. Dar acest lucru se poate remedia. Spre exemplu, daca vrem sa facem un vector $A$ cu elemente de la $-100$ la $100$ procedam astfel:\r\n\r\n== code(c) |\r\nint A[201];\r\n#define A (A + 100)\r\n==\r\n\r\nh2. Fisiere de intrare si iesire\r\n\r\nFolositi {@freopen()@} in loc de {@fopen()@} deoarece este mai comod, in special la concursurile in care intrare si iesirea sunt standard.\r\n\r\n== code(c) |\r\nfreopen(\"in.txt\", \"r\", stdin);\r\nfreopen(\"out.txt\", \"w\", stdout);\r\n==\r\n\r\nh2. Cautare binara (ideea originala de la Mihai Patrascu)\r\n\r\nUrmatorul cod este de aproximativ $4$ ori mai rapid (am testat cu cautare binara ca in manual) , mai usor de inteles, mai flexibil si mai scurt... ce ati putea dori mai mult?\r\n\r\n== code(c) |\r\nint N, A[N];\r\n\r\nint binary_search(int val)\r\n{\r\n    int i, step;\r\n    for (step = 1; step < N; step <<= 1);\r\n    for (i = 0; step; step >>= 1)\r\n        if (i + step < N && A[i + step] <= val)\r\n           i += step;\r\n    return i;\r\n}\r\n==\r\n\r\nProcedura de mai sus face cautarea binara folosind puteri a lui $2$ in ordine descrescatoare, practic incerc sa determin fiecare bit al rezultatului.\r\n\r\nh2. Impartire in bucati de marime $sqrt(n)$ (cunoscut si ca \"smenul lui Bogdan Batog\")\r\n\r\nSa presupunem ca avem un vector de lungime n cu numere reale pe care se fac urmatoarele operatii:\r\n{@ADUNA(st, dr, x)@} - toate elementele cu indicii intre $st$ si $dr$ isi cresc valoarea cu $x$\r\n{@SUMA(st, dr)@} - returneaza suma elementelor cu indicii intre $st$ si $dr$\r\n\r\nPentru cei ce cunosc arbori de intervale, rezolvarea acestei probleme in $O(lg n)$ per operatie este o munca usoara, dar presupunand ca nu stim aceasta structura putem folosi urmatorul truc: vom construi un al doilea vector de lungime $sqrt(n)$ care retine suma elementelor pe bucati de lungime {$sqrt(n)$}. Pentru a face o operatie pe un interval [{$st, dr$}] vom imparti acest interval in bucati de $sqrt(n)$ a caror actualizare o facem in vectorul $B$ si elementele care raman in margine in vectorul {$A$}. De exemplu pe vectorul {$A{~0..15~}$} vom avea vectorul {$B{~0..3~}$}. Pentru a actualiza de exemplu [{$2, 12$}] vom actualiza {$B{~1~}$} (care corespunde lui [{$4..7$}]), {$B{~2~}$} (pentru [{$8..11$}]) si {$A{~2~}$}, {$A{~3~}$}, {$A{~12~}$} (elementele din margini). Cum sunt maxim $sqrt(n)$ elemente de actualizat in $B$ si pe margini nu vom actualiza niciodata mai mult de $2 * sqrt(n)$ elemente putem concluziona ca operatiile vor avea complexitate {$O(sqrt(n))$}.\r\n\r\nDaca am avea aceeasi problema dar in doua dimensiuni, am putea face acelasi \"smen\" pentru fiecare linie pentru o complexitate $O(n*sqrt(n))$ per operatie, sau cu arbori de intervale pe fiecare linie {$O(n*lg n)$}. Putem, de asemenea obtine o complexitate $O(n)$ folosind urmatoarea impartire:\r\n$A$ - pentru bucati $1 * 1$\r\n$B$ - pentru bucati $sqrt(n) * sqrt(n)$\r\n$C$ - pentru bucati $1 * sqrt(n)$\r\n$D$ - pentru bucati $sqrt(n) * 1$\r\nAcest mod de reprezentare este o extindere directa a aceluiasi smen in doua dimensiuni. Aceasta idee poate fi folosita si pentru alte operatii: inmultire, minim, maxim, etc. In general, orice se poate rezolva cu acest \"smen\" se poate obtine la o complexitate mai buna cu arbori de intervale, dar merita sa stiti si aceasta ideea deoarece de multe ori scuteste din efortul de implementare, desi se pierde din viteza... alegerea voastra! ;)\r\n\r\nh2. LCA in $O(sqrt(n))$ (ideea originala de la Radu Berinde)\r\n\r\nDaca nu stiti ce este LCA, va recomand sa cititi \"articolul\":http://www.infoarena.ro/LCA_Lowest_common_ancestor lui Emilian Miron din cadrul site-ului pentru a va documenta. In continuare vom prezenta un algoritm mai ineficient, dar foarte usor de implementat. Consideram arborele si atribuim fiecarui nod o inaltime. Vom imparti arborele in $sqrt(H)$ intervale in functie de inaltime, unde $H$ e inaltimea maxima (de exemplu la $H=9$ nodurile cu inaltimi intre $0$ si $2$ vor forma un interval, [{$3..5$}] alt interval si ultimul interval de inaltimi [{$6..8$}]). Astfel, pentru fiecare nod, pe langa tatal sau, vom retine si tatal din intervalul de mai sus, printr-o parcurede DF. In continuare, codul:\r\n\r\n$H$ se calculeaza inainte sau poate fi constant\r\n$T$ sunt tatii nodului si $N$ numarul de noduri\r\n\r\n== code(c) |\r\nvoid DF(int n, int t2, int lev)\r\n{\r\n    int i;\r\n    T2[n] = t2, Lev[n] = lev;\r\n    if (lev % H == 0) t2 = n;\r\n    for (i = 0; i < N; i++)\r\n        if (T[i] == n) DF(i, t2, lev+1);\r\n}\r\n==\r\n\r\nOperatia de LCA se va realiza apoi foarte usor, urcand pe tatii din intervale, pana se ajunge la doua noduri in acelasi interval, apoi folosindu-se metoda clasica. Cod:\r\n\r\n== code(c) |\r\nint LCA(int x, int y)\r\n{\r\n    while (T2[x] != T2[y])\r\n        if (Lev[x] > Lev[y])\r\n            x = T2[x];\r\n        else\r\n            y = T2[y];\r\n    while (x != y)\r\n        if (Lev[x] > Lev[y])\r\n            x = T[x];\r\n        else\r\n            y = T[y];\r\n    return x;\r\n}\r\n==\r\n\r\n\r\nh2. LCA in $O(lg^2^ n)$\r\n\r\nAceeasi problema, dar o alta rezolvare. Vom construi o matrice $A{~i,j~}$ cu semnificatia $A{~i,j~}$ = al {$2^i^$}-lea tata al nodului {$j$}. Folosind aceasta matrice putem cauta binar ({$O(lg n)$}) nivelul pe care s-ar putea afla LCA-ul a doua noduri si sa determinam daca nodul ales este corect - adica daca nodul situat la acel nivel este acelasi pentru cele doua noduri pentru care se face LCA ({$O(lg n)$} cu matricea de mai sus). Complexitate finala $O(lg^2^ n)$ si $O(n*lg n)$ memorie.\r\n\r\nh2. For-uri \"complicate\"\r\n\r\nfor-ul in C/C++ este foarte flexibil si poate ajuta foarte mult in compactarea codului, deci si a timpului de implementare. In continuare vom prezenta algoritmul merge sort (sortare prin interclasare) scris in cateva linii (putine, zic eu!):\r\n\r\n== code(c) |\r\nint N, A[N], B[N];\r\nvoid merge_sort(int l, int r)\r\n{\r\n    int m = (l + r) >> 1, i, j, k;\r\n    if (l == r) return;\r\n    merge_sort(l, m);\r\n    merge_sort(m + 1, r);\r\n    for (i=l, j=m+1, k=l; i<=m || j<=r; )\r\n        if (j > r || (i <= m && A[i] < A[j]))\r\n            B[k++] = A[i++];\r\n        else\r\n            B[k++] = A[j++];\r\n    for (k = l; k <= r; k++) A[k] = B[k];\r\n}\r\n==\r\n\r\nh2. Recomandari generale\r\n\r\n# Programare dinamica cu memoizare: mult mai simplu si uneori chiar mai rapida cand nu ne trebuie tot array-ul\r\n# Algoritmi randomizati: de multe ori mai usor de implementat si mai eficienti, mai bine decat cei euristici, dar necesita o analiza mult mai atenta a performantei. Exemple calsice: quciksort, statistici de ordine\r\n\r\nh2. \"Smenul lui Mars\" (Marius Andrei)\r\n\r\nConsideram urmatoarea problema: se da un vector $A$ de $N$ elemente pe care se fac $M$ astfel de operatii: {@ADUNA(st, dr, x)@} - toate elementele cu indicii intre $st$ si $dr$ isi cresc valoarea cu {$x$}. La sfarsit trebuie sa se afiseze vectorul rezultat. In continuarea vom descrie o metoda care ne da un timp de rulare de $O(1)$ pentru operatia $ADUNA$ si $O(N)$ pentru a determina un element din vector. Vom construi un al doilea vector $B$ de $N+1$ elemente, cu proprietatea ca {$A{~i~} = B{~0~} + B{~1~} + ... B{~i~}$}. Astfel, o operatie {@ADUNA(st, dr, x)@} devine:\r\n\r\n== code(c) |B[st] += x;\r\nB[dr + 1] -= x;\r\n==\r\n\r\nDa, este chiar asa de simplu! Pentru a determina un element A{~i~} vom aduna pur si simplu {$B{~0~} + B{~1~} + ... B{~i~}$}. Incercati pe foaie sa vedeti cum funtioneaza. Aceasta ideea poate fi extinsa si in doua dimensiuni, construind $B$ astfel incat $A{~i,j~}$ = suma subtabloului din $B$ cu coltul in ({$0, 0$}) si ({$i, j$}), astfel (pt. {@ADUNA(x1,y1,x2,y2,v)@}):\r\n\r\n== code(c) |B[x1][y1] += v;\r\nB[x1][y2 + 1] -= v;\r\nB[x2 + 1][y1] -= v;\r\nB[x2 + 1][y2 + 1] += v;\r\n==\r\n\r\nPe cazul general, daca vrem sa facem operatii in $d$ dimensiuni vom avea o complexitate {$O(2^d^)$}. Reamintesc ca aceasta metoda este eficienta doar cand se vrea afisata vectorul/matricea/etc. doar la sfarsitul operatiilor, deoarece aflarea unui element este o operatie foarte ineficienta.\r\n\r\nh2. Grafuri cu liste de adiacenta (ideea originala de la Radu Berinde)\r\n\r\nSe stie (sau ar trebui sa se stie!) ca lucrul cu pointerii este foarte incet... astfel, cand retinem un graf rar (numar mare de noduri, numar mic de muchii) cu pointeri (vezi mai jos) incetinim foarte mult programul.\r\n\r\n== code(c) |\r\nstruct list\r\n{\r\n    int n;\r\n    struct list *next;\r\n}\r\ntypedef struct list list;\r\n==\r\n\r\nIn contiuare vom prezenta o metoda care este de $3-4$ ori mai rapida (adica parcurgerile DF , BF sau altii algoritmi ruleaza de $3-4$ ori mai rapid cand graful este stocat astfel), dar are ca dezavantaj necesitatea de a citi de doua ori fisierul de intrare.\r\n\r\n== code(c) |\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nint N, M, *G[N], Deg[N];\r\n\r\nint main(void)\r\n{\r\n    int i, j;\r\n \r\n    freopen(\"in.txt\", \"r\", stdin);\r\n    scanf(\"%d %d\", &N, &M);\r\n    for (; M > 0; M--)\r\n    {\r\n        scanf(\"%d %d\", &i, &j);\r\n        Deg[i - 1]++, Deg[j - 1]++;\r\n    }\r\n    for (i = 0; i < N; Deg[i++] = 0)\r\n        G[i] = (int *) malloc(Deg[i]*sizeof(int));\r\n    fseek(stdin, 0, SEEK_SET);\r\n    scanf(\"%d %d\", &N, &M);\r\n    for (; M > 0; M--)\r\n    {\r\n        scanf(\"%d %d\", &i, &j);\r\n        i--, j--;\r\n        G[i][Deg[i]++] = j,\r\n            G[j][Deg[j]++] = i;\r\n    }\r\n\r\n    return 0;\r\n}\r\n==\r\n\r\nSporul de viteza se datoreaza faptului ca se folosesc vectori in loc de pointeri si struct-uri. Daca ne permite memoria putem evita citirea de doua ori a fisierul prin pastrarea muchiilor intr-o lista de muchii si apoi, dupa calcularea gradelor, inserarea muchiilor in liste. Pentru a demonstra eficienta acestei metode faceti urmatorul test: implementati o sursa cu pointeri si struct si implementati un BF, apoi scrieti codul de mai sus cu urmatoarele modificari:\r\n\r\n== code(c) |\r\n...\r\nfor (i = 0; i < N; i++)\r\n{\r\n      G[i] = (int *) malloc((Deg[i]+1)*sizeof(int));\r\n      G[i][Deg[i]] = -1;\r\n      Deg[i] = 0;\r\n}\r\n...\r\n==\r\n\r\nsi implementati BF astfel:\r\n\r\n== code(c) |\r\nvoid BF()\r\n{\r\n      int Q[N], ql, qr, *p;\r\n      char U[N];\r\n      memset(U, 0, sizeof(U));\r\n      U[Q[ql = qr = 0] = n] = 1;\r\n      for (; ql <= qr; ql++)\r\n              for (p = G[Q[ql]]; *p != -1; p++)\r\n                      if (!U[*p]) U[Q[++qr] = *p] = 1;\r\n}\r\n==\r\n\r\nApoi, incercati sa vedeti diferenta de timp intre cele doua programe... impresionant, nu?\r\n\r\n\r\n\r\nh2. Numere mari (ideea originala de la Radu Berinde)\r\n\r\nIn continuare voi prezenta cum se pot realiza operatii pe numere mari cu foarte putine linii de cod. In general, multi programatori se complica la aceste operatii, desi nu este nevoie! Vom considera ca numerele mari sunt vectori in care elementul de indice $0$ indica lungimea numarului, iar cifrele sunt retinute in ordinea inversa decat cea a citirii.\r\n\r\nh3. Suma a doua numere mari\r\n\r\n== code(c) |\r\nvoid add(int A[], int B[])\r\n{\r\n      int i, t = 0;\r\n      for (i=1; i<=A[0] || i<=B[0] || t; i++, t/=10)\r\n              A[i] = (t += A[i] + B[i]) % 10;\r\n      A[0] = i - 1;\r\n}\r\n==\r\n\r\nh3. Inmultirea unui numar mare cu un numar mic\r\n\r\n== code(c) |\r\nvoid mul(int A[], int B)\r\n{\r\n      int i, t = 0;\r\n      for (i = 1; i <= A[0] || t; i++, t /= 10)\r\n              A[i] = (t += A[i] * B) % 10;\r\n      A[0] = i - 1;\r\n}\r\n==\r\n\r\nh3. Inmultirea unui numar mare cu un numar mare\r\n\r\n== code(c) |\r\nvoid mul(int A[], int B[])\r\n{\r\n      int i, j, t, C[NR_CIFRE];\r\n      memset(C, 0, sizeof(C));\r\n      for (i = 1; i <= A[0]; i++)\r\n      {\r\n              for (t=0, j=1; j <= B[0] || t; j++, t/=10)\r\n                      C[i+j-1]=(t+=C[i+j-1]+A[i]*B[j])%10;\r\n              if (i + j - 2 > C[0]) C[0] = i + j - 2;\r\n      }\r\n      memcpy(A, C, sizeof(C));\r\n}\r\n==\r\n\r\nh3. Scaderea a doua numere mari\r\n\r\n== code(c) |\r\nvoid sub(int A[], int B[])\r\n{\r\n      int i, t = 0;\r\n      for (i = 1; i <= A[0]; i++)\r\n              A[i] += (t = (A[i] -= B[i] + t) < 0) * 10;\r\n      for (; A[0] > 1 && !A[A[0]]; A[0]--);\r\n}\r\n==\r\n\r\nh3. Impartirea unui numar mare la un numar mic\r\n\r\n== code(c) |\r\nvoid div(int A[], int B)\r\n{\r\n      int i, t = 0;\r\n      for (i = A[0]; i > 0; i--, t %= B)\r\n              A[i] = (t = t * 10 + A[i]) / B;\r\n      for (; A[0] > 1 && !A[A[0]]; A[0]--);\r\n}\r\n==\r\n\r\nh3. Restul unui numar mare la un numar mic\r\n\r\n== code(c) |\r\nint mod(int A[], int B)\r\n{\r\n      int i, t = 0;\r\n      for (i = A[0]; i > 0; i--)\r\n              t = (t * 10 + A[i]) % B;\r\n      return t;\r\n}\r\n==\r\n\r\nh2. AVL-uri (ideea originala de la Radu Berinde - again)\r\n\r\nAVL-urile sunt arbori de cautare echilibrati care au complexitate O(lg n) pe operatiile de inserare, stergere si cautare. Pentru mai multe detalii cautati cartea \"Arbori\" pe [2]site-ul doamnei profesoare Emanuela Cerchez. In continuare voi prezenta o metoda destul de simpla de a implementa aceastra structura de date in timp de concurs. Enjoy!\r\n\r\n== code(c) |\r\n#define max(a, b) ((a) > (b) ? (a) : (b))\r\n#define geth(n) (n->h = 1 + max(n->l->h, n->r->h))\r\n\r\nstruct node\r\n{\r\n      int key, h;\r\n      struct node *l, *r;\r\n} *R, *NIL;\r\ntypedef struct node node;\r\n\r\nvoid init(void)\r\n{\r\n      R = NIL = (node *) malloc(sizeof(node));\r\n      NIL->key = NIL->h = 0,\r\n              NIL->l = NIL->r = NULL;\r\n}\r\n\r\nnode* rotleft(node *n)\r\n{\r\n      node *t = n->l;\r\n\r\n      n->l = t->r, t->r = n,\r\n              geth(n), geth(t);\r\n      return t;\r\n}\r\n\r\nnode* rotright(node *n)\r\n{\r\n      node *t = n->r;\r\n \r\n      n->r = t->l, t->l = n,\r\n              geth(n), geth(t);\r\n      return t;\r\n}\r\n\r\nnode* balance(node *n)\r\n{\r\n      geth(n);\r\n      if (n->l->h > n->r->h + 1)\r\n      {\r\n              if (n->l->r->h > n->l->l->h)\r\n                      n->l = rotright(n->l);\r\n              n = rotleft(n);\r\n      }\r\n      else\r\n              if (n->r->h > n->l->h + 1)\r\n              {\r\n                      if (n->r->l->h > n->r->r->h)\r\n                              n->r = rotleft(n->r);\r\n                      n = rotright(n);\r\n              }\r\n      return n;\r\n}\r\n\r\nnode* insert(node *n, int key)\r\n{\r\n      if (n == NIL)\r\n      {\r\n              n = (node *) malloc(sizeof(node));\r\n              n->key = key, n->h = 1, n->l = n->r = NIL;\r\n              return n;\r\n      }\r\n      if (key < n->key)\r\n              n->l = insert(n->l, key);\r\n      else\r\n              n->r = insert(n->r, key);\r\n      return balance(n);\r\n}\r\n\r\nnode* erase(node *n, int key)\r\n{\r\n      node *t;\r\n      if (n == NIL) return n;\r\n      if (n->key == key)\r\n      {\r\n              if (n->l == NIL || n->r == NIL)\r\n              {\r\n                      t = n->l == NIL ? n->r : n->l;\r\n                      free(n); return t;\r\n              }\r\n              else\r\n              {\r\n                      for (t = n->r; t->l != NIL; t = t->l);\r\n                      n->key = t->key,\r\n                              n->r = erase(n->r, t->key);\r\n                      return balance(n);\r\n              }\r\n      }\r\n      if (key < n->key)\r\n              n->l = erase(n->l, key);\r\n      else\r\n              n->r = erase(n->r, key);\r\n      return balance(n);\r\n}\r\n\r\nint search(node *n, int key)\r\n{\r\n      if (n == NIL) return 0;\r\n      if (n->key == key) return 1;\r\n      if (key < n->key)\r\n              return search(n->l, key);\r\n      else\r\n              return search(n->r, key);\r\n}\r\n==\r\n\r\nAici se termina acest articol. Am incercat sa pun accentul pe simplitate si eficienta, si cred ca am reusit acest lucru. Sper ca ati invatat cate ceva din el si recomand sa luati fiecare bucata in parte si sa incercati sa implementati efectiv ca sa intelegi mai bine. Bafta la concursuri tuturor! ;)\r\n',1,'public'),('the-monty-hall-problem','The Monty Hall Problem','2006-11-22 02:13:00','h1. The Monty Hall Problem\r\n\r\n(Categoria _Diverse_, autor(i) _Alexandra Gartu_)\r\n\r\nAcesta este primul dintr-o serie de articole in care nu vom discuta despre algoritmi clasici, structuri de date sau competitii de informatica. Vreau sa va prezint periodic cate o problema de logica ce presupune doar cunostinte elementare de matematica.\r\n\r\nScopul aceste serii este de ne \"antrena\" mintea / perspicacitatea iar legatura cu informatica vine din faptul ca multe din problemele pe care le rezolvati la informatica presupun idei mai mult decat cunostinte clasice.\r\n\r\nProblema celor trei porti se refera la faimoasa situatie dinshow-urile televizate (in speta \"Let\'s Make a Deal\", prezentat de americanul Monty Hall) cand unul dintre concurenti trebuie sa aleaga intre una din cele 3 porti: in spatele a doua dintre ele se afla o capra iar in spatele cei de-a treia se afla un Rolls Roice. Dupa ce a ales prima data, concurentului i se arata una din capre, din spatele uneia din usile pe care NU le-a ales. Intrebarea care se pune este daca respectivul concurent ar trebui sau nu sa-si schimbe optiunea dupa aceasta dezvaluire.\r\n\r\nh2. Argumentul 1\r\n\r\nInitial, sansele de a alege poarta corecta sunt de {$1/3$}. Vom demonstra in continuare ca faptul ca ti-a fost aratata o capra nu schimba cu nimic probabilitatea ca prima oara sa fi ales corect. Sansele ca prima decizie sa fie corecta inca sunt de {$1/3$} deci ar trebui sa iti modifici decizia fiindca acum in spatele celei de-a treia porti exista {$2/3$} sanse sa se afle un Rolls Roice.\r\n\r\nExista asadar doua cazuri:\r\n\r\n# ai chicit corect prima oara - sanse $1/3$\r\n# ai gicit incorect prima oara - sanse $2/3$\r\n\r\nSa presupunem acum ca iti schimbi decizia:\r\n\r\n# avusesei dreptate la prima decizie - sansele sa pierzi sunt $2/3$\r\n# Cazul II - gresisei prima oara - sanse sa castigi sunt $2/3$\r\n\r\nh2. Argumentul 2\r\n\r\nModificam ipoteza considerand ca avem intial $100$ de usi. Alegem una dintre ele avand $99/100$ sanse sa ghicim gresit. Moderatorul emisiunii ne arata $98$ de capre. Dupa acest pas inca nu stim in spatele careia din usi se afla masina: asta inseamna ca sansele de a gici sunt $1/2$ ? In mod cert nu: sansa de a ghici a fost initial si a ramas {$1/100$}. Deci, in mod cert este indicat sa schimbam decizia initial.\r\n\r\nh2. Putina matematica...sau Argumentul 3\r\n\r\nSa numim cele $3$ porti {$A, B, C$}. Sa presupunem ca ai ales poarta $A$ si ca Monty Hall ti-a aratat o capra in spatele usii {$B$}.\r\n\r\n* Probabilitate ca masina sa se afle in spatele portii {$X = P(X) = 1/3$}\r\n* Probabilitatea ca moderatorul sa deschida poarta $B$ daca premiu se afla la {$A$}: $P(moderatorul deschide B | A) = 1/2$\r\n* Probabilitatea ca moderatorul sa deschida poarta $B$ daca premiu se afla la {$B$}: $P(moderatorul deschide B | B) = 0$\r\n* Probabilitatea ca moderatorul sa deschida poarta $B$ daca premiu se afla la {$C$}: $P(moderatorul deschide B | B) = 1$\r\n\r\nh3. Concluzii\r\n\r\nProbabilitatea ca moderatorul sa deschida poarta $B$ este:\r\n\r\n$P(moderatorul deschide B) = P(A) * P(moderatorul deschide B|A) +$\r\n$P(B) * P(moderatorul deschide B|B) + P(B) * P(moderatorul deschide B|C)$\r\n$= 1/6 + 0 + 1/3$\r\n\r\n$P(A|moderatorul deschide B) = P(A) * P(moderatorul deschide B|A) / P(moderatorul deschide B)$\r\n$= (1/6) / (1/2) = 1/3$\r\n\r\n$P(C|moderatorul deschide B) = P&#0040;C) * P(moderatorul deschide B|C) /P(moderatorul deschide B)$\r\n$= (1/3) / (1/2) = 2/3$\r\n\r\nDeci, probabilitate ca in spatele usii C sa se afle o masina este {$2/3$}.\r\n\r\nh2. Putina istorie...\r\n\r\nProblema a fost publicata mai intai de Martin Gardener in octombrie $1959$ si se referea la $3$ detinuti dintre care unul, ales aleator, va fi eliberat. Sa numim cei trei prizonieri {$A, B, C$}. $A$ ii cere gardianului sa-i spuns care dintre colgii lui *NU* va fi eliberat. Desigur,asta nu inseamna ca sansele lui de a fi eliberat cresc (ele fiind tot {$1/3$}) in timp ce sansele celui de-al treilea condamnat (cel nenominalizat) cresc la {$2/3$}.\r\n\r\nMarlyn Vos Savant\'s, considerata omul cu cel mai ridicat IQ pana in momentul de fata, a publicat aceasta problema, in prima forma din acest articol in anul $1990$ in rubrica sa din Parade Magazine. Solutia ei (cel de-al doilea argument) a fost contestata in numeroase randuri (a primit peste $10000$ de scrisori care sustineau ca demonstratia este eronata) si a aparut pe prima pgina in {@21 iulie 1991@} in New York Times ( \"Her answer... has been debated in the halls of the C.I.A. and the barracks of fighter pilots in the Persian Gulf. It has been analyzed by mathematicians at M.I.T. and computer programmers at Los Alamos National Laboratory in New Mexico. It has been tested in classes ranging from second grade to graduate level at more than 1000 schools across the country.\" ).\r\n\r\n',1,'public'),('testgal','Test Gallery','2006-12-04 09:15:12','h1. Test Gallery\r\n\r\n==gallery(page=\"testgal\" file=\"%.jpg\")==',13,'public'),('hashing','Hashing','2006-11-22 02:11:58','h1. Hashing\r\n\r\n(Categoria _Tabele de dispersie_, autor(i) _Giurgea Mihnea_)\r\n\r\nh2. Scop hashing (sau tabele de dispersie)\r\n\r\nNe propunem sa creeem o structura de date eficienta care sa poata face urmatoarele operatii cat mai repede posibil: {@Insereaza@}, {@Cauta@} si {@Sterge@}. Ideea in spatele hashing-ului este memorarea unui element intr-un tablou sau lista in functie de cheia sa. Pe cazul mediu toate aceste operatii necesita $O(1)$ timp. Sa vedem cum:\r\n\r\nh2. Adresare directa\r\n\r\nElementele sunt puse intr-un tablou alocat static pe pozitiile cheilor lor. Prin adresare directa, un element cu cheia $k$ va fi memorat in locatia {$k$}. Toate cele $3$ operatii sunt extrem de simple(necesita doar o accesare de memorie), dar dezavantajul este ca aceasta tehnica \"mananca\" foarte multa memorie: {$O(|U|)$}, unde $U$ este universul de chei.\r\n\r\nh2. Standard hashing\r\n\r\nPrimul pas in a rezolva problema memoriei este de a folosi $O(N)$ memorie in loc de {$O(|U|)$}, unde $N$ este numarul de elemente adaugate in hash. Astfel, un element cu cheia $k$ nu va fi memorat in locatia {$k$}, ci {$h(k)$}, unde {@h:U->{0,1,...,N-1}@} - o functie aleasa aleator, dar determinista( $h(x)$ va returna mereu aceeasi valoare in cursul rularii unui program ). Daca functia este aleasa aleator, elementele vor fi \"imprastiate\" in hash in mod echivalent, egal. Ideal ar fi ca fiecare element sa fie stocat in locatia lui. Acest lucru insa nu este posibil, pentru ca $N < |U|$ si, deci, de multe ori mai multe elemente vor fi repartizate in aceeasi locatie. Aceasta problema se numeste coliziune.\r\n\r\nCum rezolvam coliziunile?\r\n\r\nh3. Inlantuire\r\n\r\nIn fiecare locatie din hash tinem o lista inlantuita; astfel, la oricare din cele $3$ operatii se va parcurge toata lista. Pe un caz pur teoretic, toate cele $N$ elemente ar putea fi repartizate in aceeasi locatie, insa pe cazuri practice lungimea medie a celui mai lung lant este de {$lg(N)$}.\r\n\r\n* Memorie: {$O(N)$}, pointeri: da\r\n\r\nh3. Liste statice\r\n\r\nAceasta metoda este o imbunatatire a punctului anterior: pentru ca lungimea unui lant este cel mult {$lg(N)$}, putem sa folosim, in loc de liste inlantuite, vectori alocati dinamic de lungime $lg(N)$ - sau {$lg(N) + 3$}, ca sa fiti siguri :). Scapam astfel de lucrul cu pointerii.\r\n\r\n* Memorie: {$O(N*lg(N))$}, pointeri: nu\r\n\r\nh3. Adresare directa\r\n\r\nPrin adresare directa, toate elementele sunt memorate in tabela de hash. Pentru a realiza operatiile cerute, verificam succesiv tabela de hash pana cand fie gasim o locatie libera(in cazul Inserarii), fie gasim elementul cautat (pentru {@Cauta@}, {@Sterge@}). Insa, in loc sa cautam tabela de hash in ordinea {$0,1,....,N-1$}, sirul de pozitii examinate depinde de cheia ce se insereaza. Pentru a determina locatiile corespunzatoare, extindem functia de hash astfel incat sa contina si numarul de verificare ca un al doilea parametru {@h:U*{0,1,....,N-1}->{0,1,...,N-1}@}. Astfel, cand vom insera un element, verificam mai intai locatia {$h(k , 0)$}, apoi {$h(k , 1)$} etc. Cand ajungem sa verificam {$h(k , N)$} putem sa ne oprim pentru ca tabela de hash este plina; pentru cautare aplicam aceeasi metoda; daca ajungem la {$h(k , N)$} sau la o pozitie goala inseamnca ca elementul nu exista. Stergerile se fac insa mai greu, pentru ca nu se poate \"sterge\" pur si simplu un element deoarece ar strica tot hash-ul; in schimb, se marcheaza\r\nlocatia ce trebuie stearsa cu o valoare $STERS$ si se modifica functia Insereaza astfel incat sa vada locatiile cu valoarea $STERS$ ca pozitii goale.\r\n\r\n* Memorie: {$O(N)$}, pointeri: nu\r\n\r\nh3. Mihai Patrascu\'s Double hashing\r\n\r\nO imbunatarire foarte mare la tabela de hashing este... inca o tabela de hashing. Vom avea $2$ tabele, fiecare cu proria ei functie de hash, iar coliziunile le rezolvam prin inlantuire; cand inseram un element il vom adauga in tabela in care intra intr-un lant mai scurt. Cautarea se face in ambele tabele in locatiile returnate de cele $2$ functii de hash; stergerea la fel. Astfel, lungime celui mai lung lant va fi, in medie, {$lg(lg(N))$}. Dar, in practica, lungimea unui astfel de lant nu va depasi $4$ elemente, pentru ca cel mai mic $N$ pt care $lg(lg(N)) = 5$ este {$2^32^$ ~ 2.000.000.000$}!!! Deci in loc de liste folosim vectori statice de dimensiune 4.\r\n\r\n* Memorie: {$O(N)$}, pointeri: nu\r\n\r\nh2. Functii de hash\r\n\r\nToate functiile de hash intorc un numar intre $0$ si {$M-1$}, unde $M$ este dimensiunea maxima a tabelei de hash. Este recomandat ca $M$ sa fie ales un numar prim si sa se evite alegerea lui {$M=2^k^$}.\r\n\r\nh3. Pentru numere intregi:\r\n\r\np(pre). \r\n* h(x) = x {@%@} M\r\n* h(x) = (x * r) % M , r - numar aleator ales la inceputul programului\r\n\r\nh3. Pentru 3. C)\r\n\r\np(pre). \r\n* h(x , i) = ( h\'(x) + i ) {@%@} M\r\n* h(x , i) = ( h\'(x) + r1 * i + r2 * i^2^ ) {@%@} M\r\n* h(x , i) = ( h1(x) + i * h2(x) ) {@%@} M\r\nr1, r2 - numere alese aleator la inceputul programului.\r\n\r\nh3. Pentru numere reale\r\n\r\np(pre). \r\n* h(x) = [ {a * x} * M ] , 0 < a < 1\r\n\r\n${x}$ - partea fractionara a lui {$x$}\r\n$[x]$ = partea intreaga a lui {$x$}; \r\n$[x] + {x} = x$ - prin definitie;\r\n$a$ este un numar care trebuie ales inainte sau la inceputul rularii programului; alegerea lui influenteaza eficienta functiei; Knuth propune urmatoarea valoare pentru $a=(sqrt(5)-1)/2$ ~ {$0.6180339887$}...\r\n\r\nh2. Teme pentru acasa\r\n\r\nIncercati sa rezolvati urmatoarele probleme:\r\n\r\n* \"Magic Pairs\":http://acm.sgu.ru/problem.php?contest=0&problem=119\r\n* \"Walls\":http://acm.sgu.ru/problem.php?contest=0&problem=174\r\n* \"Algoritmus 3 - 3: Colinearitate\":http://www.algoritmus.org/probleme/probleme_runda03.php\r\n\r\n',1,'public'),('problema/camera','Camera','2006-11-24 16:05:45','==Include(page=\"template/taskheader\" task_id=\"camera\")==\r\n\r\nZebu si-a cumparat recent o noua parcela de pamant pe care vrea sa isi extinda afacerea cu gaini, dar el este foarte ingrijorat de hotii care pot afecta bunastarea afacerii. Un prieten care a fost recent in State i-a facut cadou o camera de filmat foarte performanta care are capacitatea de a filma dupa un unghi de $360$ de grade. Zebu este foarte bucuros de aceasta achizitie pe care o poate folosi imediat pentru a supraveghea parcela nou cumparata. Dar camera nu poate supraveghea intreaga parcela daca este dispusa in orice punct al acesteia, si Zebu este curios care e suprafata pe care camera poate fi pozitionata astfel ca toate punctele parcelei sa poata fi supravegheate. Parcela o putem modela ca un poligon cu $N$ varfuri, iar camera ca un punct in interiorul acestui poligon.\r\n\r\nh2. Cerinta:\r\n\r\nDeterminati aria zonei unde poate fi amplasata camera!\r\n\r\nh2. Date de Intrare:\r\n\r\nFisierul $camera.in$ va contine pe prima linie un numar intreg ce reprezinta valoarea lui $N$. Pe urmatoarele $N$ linii se vor afla cate doua numere intregi separate prin un singur spatiu, pe a $i+1$-a linie se vor afla coordonatele celui de al $i$-lea varf.\r\n\r\nh2. Date de Iesire:\r\n\r\nFisierul $camera.out$ va contine un singur numar real cu doua zecimale care reprezinta aria zonei in care poate fi plasata camera.\r\n\r\nh2. Restrictii:\r\n\r\n* $3 &le; N &le; 2000$\r\n* $-100000 &le; x{~i~}, y{~i~} &le; 100000, (x{~i~}, y{~i~})$ sunt coordonatele varfurilor poligonului\r\n* Pentru $20%$ din teste marginile parcelei vor fi paralele cu axele de coordonate.\r\n* Doua numere reale se considera egale daca diferenta intre ele e cel mult $10^-6^$.\r\n* Un rezultat va fi considerat corect daca diferenta intre el si solutia rezultatul returnat de solutia oficiala este $&le; 0.01$.\r\n\r\nh2. Exemplu:\r\n\r\ntable(example). |_. camera.in |_. camera.out |\r\n| 9\r\n5 1\r\n5 2\r\n1 3\r\n3 4\r\n2 8\r\n5 5\r\n9 6\r\n7 3\r\n9 2\r\n| 2.86 | \r\n\r\nh3. Explicatie\r\n\r\n!problema/camera?camera.gif!\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"camera\")==',1142,'task: camera'),('problema/perm2','Permutari II','2006-11-24 16:26:16','==Include(page=\"template/taskheader\" task_id=\"perm2\")==\r\n\r\n==Include(page=\"template/cleanup\" task_id=\"perm2\")==\r\n\r\nSe considera multimea $A$ formata din elementele $1, 2, 3 ... N (1 &le; N &le; 20.000)$.\r\n\r\nO permutare $P$ este un functie bijectiva definita pe multimea $A$, cu valori in $A$. (bijectiva in sensul ca asociaza in mod unic fiecarui element din $A$ un element tot din $A$).\r\n\r\nUn exemplu de astfel de permutare este ilustrat de tabelul de mai jos\r\n\r\ntable(numbers). |_. $i$ |1 |2 |3 |4 |\r\n|_. $P(i)$ |2 |3 |4 |1 |\r\n\r\nDefinim permutarea $P^k^$ astfel:\r\n\r\n$P^k^(i)$ =\r\n\r\n* $P(i)$, atunci cand $k=1$\r\n* $P(P^k-1^(i))$, pentru $k > 1$\r\n\r\nTabelul de mai jos ilustreaza P^1^ si P^2^:\r\n\r\ntable(numbers). |_. $i$ |1 |2 |3 |4 |\r\n|_. $P^1^(i)$ |2 |3 |4 |1 |\r\n|_. $P^2^(i)$ |3 |4 |1 |2 |\r\n\r\nh2. Cerinta\r\n\r\nSe da $N$ si o permutare $P$. Sa se gaseasca cel mai mic numar natural $K$ strict pozitiv, astfel incat oricare ar fi $1<=i<=N$ avem $P^k^(i)=i$ (in alte cuvinte, $P^k^$ sa fie _permutarea identica_ ).\r\n\r\nh2. Date de intrare\r\n\r\nFisierul $perm2.in$ va contine pe prima linie numarul intreg $N$.\r\n\r\nPe urmatoarea linie se scriu $N$ numere naturale distincte, fiecare in intervalul {$1..N$}.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $perm2.out$ se va scrie acel numar $K$ ce indeplineste condiitle impuse.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Pentru testele furnizate $1 &le; K &le; 100.000$\r\n\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. perm2.in |_. perm2.out |\r\n| 6\r\n1 2 3 4 5 6 | 1 |\r\n| 4\r\n2 3 4 1 | 4 |\r\n| 8\r\n1 5 2 3 4 8 6 7 | 12 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"perm2\")==',1142,'task: perm2'),('problema/sortnet','Sortnet','2006-11-24 16:18:14','==Include(page=\"template/taskheader\" task_id=\"sortnet\")==\r\n\r\nO retea de sortare este formata din $N$ linii de date, numerotate de la $1$ la $N$, legate prin comparatori. Pe o linie de date circula valori numerice; initial $N$ valori oarecare sunt introduse in retea si se asteapta ca reteaua sa furnizeze la iesire o permutare a acestor numere. O retea de sortare perfecta va furniza la iesire valorile in ordine crescatoare.\r\n\r\nComparatorii sunt plasati intre doua linii de date cu scopul de a aseza in ordine crescatoare cele doua valori. Un comparator poate lega oricare doua linii $A$ si $B$, cu $A < B$; un astfel de comparator este notat simbolic cu <{$A$},{$B$}> sau grafic cu un segment vertical intre cele doua linii de date. Notatia grafica determina univoc comparatorul. Imaginati-va un segment care uneste liniile $1$ si $3$; acesta reprezinta comparatorul <{$1$},{$3$}>, deoarece <{$3$},{$1$}> nu poate fi un comparator (vezi definitia de mai sus). In aceasta problema, numarul de linii de date va fi intotdeauna par. Un ciclu de sortare este format din $N/2$ comparatori, astfel incat fiecare linie este legata la un singur comparator. O retea de sortare completa de adancime $M$ este o retea de sortare formata din $M$ cicli de sortare.\r\n\r\nUn exemplu valoreaza cat 1000 de cuvinte:\r\n\r\n!problema/sortnet?sortnet.gif!\r\n\r\nReteaua din figura are $4$ linii de date si $2$ cicli de sortare. Se observa ca aceasta retea de sortare nu este perfecta. Desi sorteaza corect datele din figura (secventa {$7$},{$8$},{$7$},{$3$}), ea nu va sorta corect secventa {$1$},{$3$},{$2$},{$9$}.\r\n\r\nh2. Cerinta\r\n\r\nSe poate demonstra ca daca o retea sorteaza corect orice intrare formata numai din numerele $0$ si $1$, ea va sorta corect orice secventa de numere. Are deci sens sa spunem ca o retea este cu atat mai buna, cu cat sorteaza corect mai multe intrari formate din numerele $0$ si $1$. Exista $2^N^$ astfel de intrari; scrieti un program care determina cate dintre aceste intrari posibile sunt sortate corect de o anumita retea (prin sortate corecta, intelegem ca la iesire toate numerele de zero apar inaintea celor de unu).\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $sortnet.in$ sunt scrise doua numere intregi $N$ si $M$, reprezentand numarul de linii de date, respectiv numarul de cicli de sortare. Pe fiecare dintre urmatoarele $M$ linii sunt reprezentati $N/2$ comparatori, in formatul <{$A$},{$B$}>, cu $A$ si $B$ numere intregi intre $1$ si $N$, $A < B$. Nici un numar nu se va repeta in descrierea unui ciclu de sortare (fiecare linie este legata la exact un comparator in fiecare ciclu).\r\n\r\nh2. Date de iesire\r\n\r\nFisierul $sortnet.out$ va contine numarul de intrari formate numai din numerele $0$ si $1$, care sunt sortate corect de catre reteaua considerata.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 20$ si $N$ par\r\n* $0 &le; M &le; 32$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. sortnet.in|_. sortnet.out|\r\n|4 2\r\n<1,3> <2,4>\r\n<3,4> <1,2>\r\n|14|\r\n\r\n_Explicatie_: Exemplul corespunde figurii; cele doua secvente formate din cifre de $0$ si $1$ care nu sunt sortate corect sunt {$0$},{$1$},{$0$},{$1$} si {$1$},{$0$},{$1$},{$0$}. \r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sortnet\")==',1142,'task: sortnet'),('problema/subsir2','Subsir 2','2006-11-25 13:59:39','==Include(page=\"template/taskheader\" task_id=\"subsir2\")==\r\n\r\nBronzarel se antreneaza zi de zi pentru a deveni un mare olimpic la informatica, avandu-l pe Zaharel ca mentor. Desigur, sursa lor preferata de probleme este infoarena! Vazandu-l foarte increzator, Zaharel vrea sa-l testeze pe Bronzarel cu o noua problema si ii spune: \"Iti dau un sir de $N$ numere intregi si vreau sa imi spui care este cel mai scurt _subsir crescator maximal_.\"\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care rezolva problema primita.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie din fisierul $subsir2.in$ se va gasi numarul $N$. Pe urmatoarea linie vor fi scrie $N$ numere intregi.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie din fisierul $subsir2.out$ va contine un numar $L{~min~}$, reprezetand lungimea minima a unui subsir crescator maximal. Pe urmatoarea linie se vor afisa $L{~min~}$ numere in ordine crescatoare, reprezetand poziitile elementelor din sirul initial care fac parte din subsirul ales. Daca exista mai multe solutii, se va afisa cea lexicografic minima, din punct de vedere al valorilor elementelor din subsir.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $1 &le; N &le; 5 000$\r\n* $50%$ din teste vor avea $N &le; 500$\r\n* Sirul dat va contine numere intregi din intervalul $[-1 000 000, 1 000 000]$\r\n* Considerand ca sirul dat este {$A=(a{~1~},a{~2~}...a{~N~})$}, se numeste subsir al lui $A$ un sir {$B=(b{~i{~1~}~},b{~i{~2~}~}...b{~i{~N~}~})$} cu proprietatea $1 &le; i{~1~} < i{~2~} < ... < i{~K~} &le; N$.\r\n* Spunem ca un subsir {$B=(b{~i{~1~}~},b{~i{~2~}~}...b{~i{~N~}~})$} este _crescator maximal_ daca {$a{~i{~1~}~} &le; a{~i{~2~}~} &le; ... &le; a{~i{~K~}~}$} si nu exista nici un $x$ astfel incat: sa existe $j < K$, {$i{~j~} < x < i{~j+1~}$} si {$a{~i{~j~}~} &le; a{~x~} &le; a{~i{~j+1~}~}$}, sau {$1 &le; x < i{~1~}$} si {$a{~x~} &le; a{~i{~1~}~}$} sau {$i{~K~} < x &le; N$} si {$a{~i{~K~}~} <= a{~x~}$}\r\n* Pentru fiecare test se va acorda $40%$ din punctaj pentru determinarea corecta a lungimii subsirului, inca $40%$ pentru determinarea unei solutii corecte, si inca $20%$ daca solutia determinata este minima din punct de vedere lexicografic\r\n* Un sir {$(x{~1~},x{~2~}...x{~K~})$} este mai mic din punct de vedere lexicografic decat un alt sir {$(y{~1~},y{~2~}...y{~K~})$} daca exista o pozitie $p$ astfel incat {$x{~p~} < y{~p~}$} si {$x{~1~} = y{~1~}$}, {$x{~2~} = y{~2~}$} ... {$x{~p-1~} = y{~p-1~}$}.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. subsir2.in|_. subsir2.out|\r\n|6\r\n1 3 6 2 5 4\r\n|3\r\n1 4 6|\r\n\r\n_Explicatie_: Subsirul cu elemente pe poziiile {$1$},{$4$},{$6$} este {$(1,2,4)$}. Acesta este maximal si are lungime minima. Alte subsiruri maximale de aceeasi lungime sunt:\r\n{$(1,2,5)$}\r\n{$(1,3,4)$}\r\n{$(1,3,5)$}\r\nSolutia data este minima lexicografic din punct de vedere al valorilor elementelor subsirului. \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"subsir2\")==',1142,'task: subsir2'),('problema/popandai','Popandai','2006-11-24 16:15:15','==Include(page=\"template/taskheader\" task_id=\"popandai\")==\r\n\r\nCei $K$ popandai de pe tarlaua vesela vor sa se adaposteasca de vultur in cele $N$ vizuine sapate in pamant. Tarlaua va fi planul euclidian, iar vizuinele vor fi puncte de coordonate intregi. Pentru a fi protejati de un atac al vulturului ei vor sa stabilesca o zona sigura in forma de patrulater, zona in care pot usor sa se avertizeze si sa se adaposteasca la aparitia vreunui vultur. Aceasta zona trebuie sa contina strict in interior cel putin $K$ vizuine astfel ca fiecare popandau sa aiba vizuina lui. De asemenea varfurile zonei alese vor corespunde unor vizuine. Nu vor exista trei vizuine care sa fie coliniare.\r\n\r\nh2. Cerinta\r\n\r\nAjutatii pe popandai sa determine zona de arie minima care satisface conditiile de mai sus!\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $popandai.in$ va contine pe prima linie numerele intregi $N$ si $K$. Urmatoarele $N$ linii vor contine cate doi intregi $x{~i~}, y{~i~}$ separati printr-un spatiu ce reprezinta coordonatele unei vizuine.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie din fisierul de iesire $popandai.out$ se va gasi un singur numar real reprezentand aria minima a patrulaterului cautat. .\r\n\r\nh2. Restrictii\r\n\r\n* $0 &le; K &le; N &le; 300$\r\n* $0 &le; x{~i~}, y{~i~} &le; 30000$\r\n* nu exista $3$ puncte coliniare\r\n* solutia se va afisa cu exact o zecimala\r\n* va exista intotdeauna solutie ({$k + 3 < n$})\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. popandai.in |_. popandai.out |_. Figura |\r\n| 8 0\r\n5 9\r\n9 6\r\n8 1\r\n0 7\r\n7 2\r\n1 3\r\n2 0\r\n8 3\r\n| 2.0 \r\n| !problema/popandai?popandai.gif! |\r\n\r\nh3. Explicatie\r\n\r\nPoligonul de arie minima e format din varfurile $(7,2), (9, 6), (8,3)$ si $(8,1)$.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"popandai\")==',1142,'task: popandai'),('problema/robot','Robot','2006-11-24 16:17:06','==Include(page=\"template/taskheader\" task_id=\"robot\")==\r\n\r\nGigel tocmai si-a cumparat un joc de strategie. Actiunea jocului ia loc pe o harta plana. Pe harta se gaseste un mic robotel si cateva obstacole. Scopul jocului este de a muta robotelul intr-un anumit loc. Fiindca nu se pricepe prea bine la jocuri pe calculator, Gigel va roaga sa-l ajutati.\r\n\r\nRobotelul si obstacolele sunt reprezentate de poligoane convexe, cu varfurile in puncte de coordonate intregi. Spunem ca robotelul se afla intr-o pozitie valida pe harta daca poligonul care il reprezinta nu se intersecteaza cu interiorul nici unui obstacol. Daca robotelul este tangent la unul sau mai multe obstacole, fara a intersecta insa interiorul nici unuia dintre ele, pozitia lui este valida.\r\n\r\nPe tot parcursul jocului obstacolele raman nemiscate si nerotite. De asemenea, robotelul nu se poate roti, insa acesta se poate misca in orice directie. Pe tot parcursul miscarii sale, robotelul trebuie sa ramana intr-o pozitie valida.\r\n\r\nPozitia robotelului pe harta se defineste ca fiind punctul ({$x,y$}), cu $y$ egal cu minimul ordonatelor varfurilor robotelului si cu $x$ egal cu minimul absciselor varfurilor robotelului. Curba desenata de pozitia robotelului in timpul miscarii sale in plan se numeste drumul robotelului.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care citeste configuratia initiala a hartii si care calculeaza lungimea unui drum minim parcurs de robotel pentru a ajunge intr-o pozitie finala.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $robot.in$ se gaseste numarul $N$ de varfuri ale poligonului reprezentand robotelul. Pe urmatoarele $N$ linii se gasesc coordonatele $x$ si $y$ ale varfurilor robotelului, coordonate separate printr-un spatiu. Pe urmatoarea linie se gaseste numarul $M$ de obstacole. Apoi urmeaza $M$ blocuri reprezentand cate un obstacol, fiecare bloc avand urmatoarea structura:\r\n\r\n* pe prima linie a blocului numarul de varfuri $P$ ale poligonului ce reprezinta obstacolul\r\n* pe urmatoarele $P$ linii, coordonatele $x$ si $y$ ale varfurilor obstacolului, coordonate separate printr-un spatiu.\r\nPe ultima linie a fisierului de intrare, se gasesc coordonatele $x$ si $y$ ale pozitiei in care trebuie sa ajunga robotelul.\r\n\r\nh2. Date de iesire\r\n\r\nPe singura linie a fisierului de iesire $robot.out$ afisati cu doua zecimale exacte distanta minima parcursa de robot pana la pozitia finala pe un drum care respecta cerintele de mai sus. Daca nu exista nici un astfel de drum afisati {$-1$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $N &le; 10$\r\n* $M &le; 25$\r\n* toate coordonatele sunt din intervalul ({$-5000,5000$})\r\n* numarul de varfuri de pe poligoanele tuturor obstacolelor nu depaseste $250$\r\n* puteti presupune ca pozitia initiala a robotelului este valida.\r\n* in fisierul de intrare, pentru toate poligoanele, punctele sunt date in sens trigonometric.\r\n* solutia afisata de voi este considerata corecta daca difera de solutia comisiei in valoare absoluta prin cel mult $0.02$\r\n* unii sustin ca adevaratul campion este cel care rezolva *ivv* adevarul este insa ca singurul care poate determina adevaratul campion este robotelul\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. robot.in |_. robot.out |\r\n| 3\r\n0 0\r\n2 0\r\n0 2\r\n1\r\n4\r\n3 0\r\n5 0\r\n5 2\r\n3 2\r\n6 2\r\n| 7.24 |\r\n\r\nh3. Explicatii\r\n\r\n !problema/robot?robot.gif! \r\n\r\nRobotelul apare punctat si obstacolul este desenat cu linie ingrosata. Cerculetul reprezinta pozitia finala a robotelului. Cu o linie usor ingrosata este marcat si un drum de lungime minima.\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"robot\")==',1142,'task: robot'),('problema/tabela','Tabela','2006-11-24 16:20:00','==Include(page=\"template/taskheader\" task_id=\"tabela\")==\r\n\r\nMacarie, pasionat de numere, si mai ales de matrici, incepe intr-o zi sa umple o foaie infinita de matematica cu numere astfel: in coltul cel mai de sus stanga (1, 1) pune 0, apoi scrie de la stanga la dreapta si de sus in jos cel mai mic numar care nu apare pe linia si coloana respectiva. Dandu-se linia si coloana unei casute din tabela aflati numarul de la acea pozitie.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $tabela.in$ contine pe prima si singura linie numerele $L$ si $C$, linia si coloana patratelului a carui valoare dorim sa o determinam.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $tabela.out$ contine pe prima linie numarul scris pe foaie la linia $L$ si coloana $C$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* L si C sunt numere naturale din intervalul $[1, 2 000 000 000]$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. tabela.in|_. tabela.out|_. tabela.in|_. tabela.out|\r\n|2 3|3|4 5|7|\r\n\r\n_Explicatie_: Prima parte a tabelei va arata in felul urmator:\r\n!problema/tabela?tabela.jpg!\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"tabela\")==',1142,'task: tabela'),('problema/grazing','Grazing','2006-11-24 16:08:58','==Include(page=\"template/taskheader\" task_id=\"grazing\")==\r\n\r\nCiobanasul Ion vrea sa isi modernizeze zona de pasunat si sa construiasca niste carari intre pasunile sale. El are $N$ pasuni, numerotate de la $1$ la $N$ . O carare va uni doua pasuni. Un drum este format dintr-o succesiune de pasuni, astfel incat intre doua pasuni consecutive de-a lungul drumului sa existe o carare de legatura. Lungimea unui drum este egala cu numarul de pasuni aflate pe drumul respectiv. Pentru a-si face oile fericite el trebuie sa indeplineasca o conditie stranie: oilor nu le va place cum sunt construite cararile daca exista trei pasuni $P{~1~}$ , $P{~2~}$ , $P{~3~}$ astfel ca drumul cel mai scurt de la $P{~1~}$ la $P{~2~}$ are aceeasi lungime cu drumul cel mai scurt de la $P{~2~}$ la $P{~3~}$ , si de asemenea aceeasi lungime cu drumul cel mai scurt de la $P{~1~}$ la $P{~3~}$ .\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa-i spuna ciobanasului Ion care este numarul de posibilitati de construire a cararilor care respecta restrictia din enunt.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare numit $grazing.in$ va contine pe prima linie un numar intreg $N$ reprezentand numarul de pasuni.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $grazing.out$ va contine pe prima linie un singur numar reprezentand numarul de modalitati de constructie a cararilor.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 300$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. grazing.in |_. grazing.out |_. Figura |\r\n| 3 | 7 | !problema/grazing?grazing.jpg! |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"grazing\")==',1142,'task: grazing'),('problema/rubarba','Rubarba','2006-11-24 16:17:28','==Include(page=\"template/taskheader\" task_id=\"rubarba\")==\r\n\r\nProaspat evadat din temnita, _Paftenie barbarul_ a decis ca este timpul sa puna capat pentru o vreme aventurilor sale. Intorcandu-se la familia lui, s-a dedicat unui nou hobby: gradinaritul. De data aceasta a plantat in gradina sa $N$ tulpini de rubarba. Nefiind specialist in domeniu, a plantat tulpinile aleator, iar acum se pune problema construirii unei sere. Sera trebuie sa fie de forma dreptunghiulara, sa contina in interiorul sau toate tulpinile de rubarba, iar aria sa sa fie minima.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe gradinarul _Paftenie_ sa rezolve problema!\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare este dat numarul $N$ al tulpinilor de rubarba. Pe urmatoarele $N$ linii se afla cate o pereche de numere intregi, reprezentand coordonatele acestora.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire va contine pe prima linie un singur numar real, reprezentand aria minima a dreptunghiului cerut.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1$ &le; $N$ &le; $100.000$\r\n* coordonatele plantelor sunt numere intregi cuprinse intre $0$ si $1.000.000$\r\n* rezultatul se va afisa cu o precizie de $2$ zecimale\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. rubarba.in |_. rubarba.out |\r\n| 9\r\n2 1\r\n4 2\r\n7 2\r\n1 4\r\n7 4\r\n5 6\r\n6 8\r\n8 8\r\n3 9\r\n| 50.32 |\r\n\r\nh3. Explicatie\r\n\r\n!problema/rubarba?rubarba.jpg!\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"rubarba\")==',1142,'task: rubarba'),('problema/paralelograme','Paralelograme','2006-11-24 16:11:31','==Include(page=\"template/taskheader\" task_id=\"paralelograme\")==\r\n\r\nClod din nou e plictisit la ora matematica si se joaca desenand pe o foaie de patratele paralelograme cu varfurile in colturi ale patratelelor. Tot desenand paralelograme, Clod se intreaba cate astfel de paralelograme poate construi daca stie ca foaia de patratele are $N$ randuri si $M$ coloane.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Clod sa rezolve problema!\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul de intrare $paralelograme.in$ pe prima linie se vor afla doua numere intregi $N$ si $M$ separate printr-un spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $paralelograme.out$ va contine pe prima linie un singur numar intreg reprezentand numarul de paralelograme cerut in problema.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N,M &le; 2.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. paralelograme.in |_. paralelograme.out |\r\n| 2 2\r\n| 22 |\r\n\r\nh3. Explicatii\r\n\r\n!problema/paralelograme?image001.jpg!\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"paralelograme\")==',1142,'task: paralelograme'),('problema/bombar','Bombar','2006-11-24 16:04:54','==Include(page=\"template/taskheader\" task_id=\"bombar\")==\r\n\r\nIn timpul bombardamentelor, Paftenie a devenit genist. Trebuie sa dezamorseze niste bombe aflate adanc in pamant si asta repede. Sunt exact $2*N$ bombe, asezate in doua randuri paralele, ca in figura urmatoare:\r\n\r\n!problema/bombar?bombar0.png!\r\n\r\nIntre oricare doua bombe consecutive din acelasi rand sau o bomba si corespunzatoarea sa din celalalt rand se poate sapa un tunel (bombele intre care se pot sapa tuneluri apar legate in figura). Trebuie sa le dezamorseze pe toate, una care una, sapand exact $2*N-1$ tuneluri si trebuie sa poata circula intre oricare doua bombe numai prin tunelurile sapate. Inainte de a trece la treaba, Paftenie se intreaba in cate moduri se pot sapa tunelurile.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l sa afle pana nu e prea tarziu!\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $bombar.in$ este dat numarul $N$ al bombelor de pe un sir.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bombar.out$ va contine pe prima linie un singur numar, reprezentand numarul de posibilitati in care se pot sapa tunelurile.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 20.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bombar.in |_. bombar.out |\r\n| 2 | 4 | \r\n\r\nh3. Explicatie\r\n\r\nBombele sunt plasate astfel: \r\n\r\n!problema/bombar?bombar1.png!\r\n\r\nPaftenie poate sapa tunelurile in 4 feluri:\r\n\r\n!problema/bombar?bombar2.png!\r\n\r\ntable(example). |_. bombar.in |_. bombar.out |\r\n|3 |15 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bombar\")==',1142,'task: bombar'),('problema/figuri','Figuri','2006-11-24 16:08:22','==Include(page=\"template/taskheader\" task_id=\"figuri\")==\r\n\r\nSe considera $N$ bucati dreptunghiulare de hartie colorata, care sunt asezate una dupa alta pe o foaie alba dreptunghiulara. Stim ca sistemul de coordonate are originea in centrul hartiei albe si ca axele sunt paralele cu laturile foii de hartie albe. Astfel, aceasta foaie alba poate fi impartita in patratele de latura unitate. Bucatile de hartie au marginile paralele cu foaia alba, si incap in intregime pe foaie. In final, daca ne uitam de sus, se vor vedea diferite figuri de diferite culori. Doua regiuni de aceeasi culoare fac parte din aceeasi figura, daca au cel putin un patratel care are cel putin un patratel vecin dintre cele $8$ ale sale, care face parte din cealalta regiune de aceeasi culoare.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine aria fiecarei figuri si numarul maxim de foi care se suprapun cel putin intr-un acelasi patratel comun.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $figuri.in$ se afla trei numere naturale {$a$}, $b$ si {$N$}, unde a reprezinta latimea foii de hartie (in figura de mai jos: numarul de patratele pe orizontala), $b$ reprezinta lungimea foii de hartie (numarul de patratele pe verticala), iar $N$ reprezinta numarul bucatilor de hartie colorata dreptunghiulara.\r\nUrmatoarele $N$ linii contin fiecare cate $5$ numere intregi: $x{~1~}, y{~1~}, x{~2~}, y{~2~}$ si {$c$}, unde $x{~1~}$ si $y{~1~}$ reprezinta coordonatele coltului din stanga jos al dreptunghiului respectiv, x{~2~} si y{~2~} reprezinta coordonatele punctului de pe hartie unde va fi plasat coltul din dreapta sus al dreptunghiului, iar c reprezinta culoarea acestuia. Culoarea este un numar natural.\r\nOrdinea liniilor din fisierul de intrare corespunde ordinii de asezare a dreptunghiurilor.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $figuri.out$ va contine cate o linie in care se descrie cate o figura \"monocolora\".\r\nPe fiecare linie se vor scrie doua numere intregi $c$ si {$d$}, unde c reprezinta codul culorii figurii care se descrie, iar $d$ reprezinta aria figurii respective.\r\nPe ultima linie a fisierului se va scrie un singur numar natural, reprezentand numarul maxim de bucati de hartie care se suprapun cel putin intr-un acelasi patratel comun. Vom numara si foaia alba data initial.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 1000$\r\n* $1 &le; a, b &le; 200$\r\n* $a$ si $b$ sunt numere pare\r\n* $1 &le; c &le; 1000$\r\n* culoarea alba este codificata cu $1$\r\n* {$x{~1~} < x{~2~}$}, {$y{~1~} < y{~2~}$},\r\n* $[-a/2] &le; x{~1~}, x{~2~} &le; [a/2]$\r\n* $[-b/2] &le; y{~1~}, y{~2~} &le; [b/2]$\r\n* Printre dreptunghiurile colorate putem avea si dreptunghiuri de culoare alba.\r\n* Foaia alba initiala (parti din ea) poate face parte dintr-o figura.\r\n* Numarul final de figuri nu depaseste {$1000$}.\r\n* Figurile se vor descrie in fisierul de iesire in ordine crescatoare dupa codul culorii; daca exista mai multe astfel de figuri, ordinea va fi crescatoare dupa arie.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. figuri.in |_. figuri.out |_. Figura |\r\n| 20 12 6\r\n-7 -5 -3 -1 4\r\n-5 -3 5 3 2\r\n-4 -2 -2 2 4\r\n2 -2 3 -1 12\r\n3 1 7 5 1\r\n3 -3 4 -2 12\r\n| 1 172\r\n2 46\r\n4 8\r\n4 12\r\n12 2\r\n4 \r\n| !problema/figuri?figuri.gif! |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"figuri\")==',1142,'task: figuri'),('problema/pedefe','Pedefe','2006-11-24 16:06:56','==Include(page=\"template/taskheader\" task_id=\"pedefe\")==\r\n\r\nZaharel se ocupa de securitatea subiectelor de la finala preONI si a scris textul problemelor sub forma unui sir $S{~0~}$ de numere naturale ordonate crescator. Fiind un pic paranoic, el s-a gandit sa aplice o criptare pe $S{~0~}$, folosind un algoritm inventat de el, algoritmul de criptare Pedefe(TM). Din pacate, calculatorul preONI a fost virusat si datele criptate s-au pierdut. Zaharel a putut recupera trei siruri de date din calculator pe care le vom nota $S{~1~},S{~2~},S{~3~}$. Dupa cateva investigatii si-a dat seama ca $S{~3~}$ este un subsir al lui $S{~0~}$, si in plus $S{~0~}$ se gaseste ca subsir atat in $S{~1~}$ cat si in $S{~2~}$.\r\n\r\nh2. Cerinta\r\n\r\nEvident, cele trei siruri nu sunt deajuns pentru a-l gasi in mod unic pe $S{~0~}$. Ca sa nu-s iroseasca zilele sa recupereze datele, Zaharel vrea sa stie cate posibiltati exista de a-l gasi pe $S{~0~}$ folosind informatiile disponibile. Reamintim ca $S{~0~}$ trebuie sa fie un subsir atat al lui $S{~1~}$ si $S{~2~}$, sa-l contina pe $S{~3~}$ ca subsir, si sa fie crescator.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $pedefe.in$ va contine pe prima linie numerele naturale $N, M$ si $P$. Urmatoarele trei linii vor contine $N, M,$ respectiv $P$ numere naturale, reprezetand sirurile $S{~1~}, S{~2~}, S{~3~}$ in aceasta ordine.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $pedefe.out$ se va afisa numarul de posibilitati cautat, modulo $666013$.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $1 &le; N, M &le; 500$\r\n* $0 &le; P &le; 100, P &le; min(N, M)$\r\n* Sirurile vor contine numere naturale din intevalul $[1, 500]$\r\n* Pentru $50%$ din teste $N, M &le; 256$, iar pentru inca $25%$ din teste numarul de caractere distincte din sirurile $S{~1~}, S{~2~}, S{~3~}$ este $&le; 20$\r\n* Considerand un sir $A=(a{~1~},a{~2~}...a{~N~})$, se numeste subsir al lui $A$, un sir $B=(a{~i1~},a{~i2~}...a{~iK~})$ cu proprietatea $1 &le; i{~1~}<i{~2~}<...<i{~K~} &le; N$.\r\n* Doua solutii se considera distincte considerand pozitiile numerelor in sirurile $S{~1~}$ si $S{~2~}$, nu valoarea acestora (vezi exemplu)\r\n* Se recomanda evitarea folosirii operatiei modulo din limbajul in care lucrati deoarece este foarte consumatoare de timp; se recomanda folosirea operatiei de scadere in schimb\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. pedefe.in |_. pedefe.out |\r\n| 8 9 2\r\n14 1 2 2 15 24 3 4\r\n17 18 1 2 2 3 24 4 19\r\n1 24 | 6 |\r\n\r\nh3. Explicatii\r\n\r\n$S{~0~}$ poate fi:\r\n$1 24 (S{~1,2~} S{~1,6~} S{~2,3~} S{~2,7~})$\r\n$1 2 24 (S{~1,2~} S{~1,3~} S{~1,6~} S{~2,3~} S{~2,4~} S{~2,7~})$\r\n$1 2 24 (S{~1,2~} S{~1,4~} S{~1,6~} S{~2,3~} S{~2,4~} S{~2,7~})$\r\n$1 2 24 (S{~1,2~} S{~1,3~} S{~1,6~} S{~2,3~} S{~2,5~} {~2,7~})$\r\n$1 2 24 (S{~1,2~} S{~1,3~} S{~1,6~} S{~2,3~} S{~2,5~} S{~2,7~})$\r\n$1 2 2 24 (S{~1,2~} S{~1,3~} S{~1,4~} S{~1,6~} S{~2,3~} S{~2,4~} S{~2,5~} S{~2,7~})$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"pedefe\")==',1142,'task: pedefe'),('problema/adunare','A+B','2007-01-14 18:45:39','==Include(page=\"template/taskheader\" task_id=\"adunare\")==\r\n\r\nAdunare simpla\r\n\r\nh2. Date de intrare\r\n\r\nDatele de intrare se citesc din fisierul $adunare.in$:\r\n\r\n* pe prima linie un numar intreg $a$\r\n* pe a doua linie un numar intreg $b$\r\n\r\n\r\nh2. Date de iesire\r\n\r\nDatele de iesire se tiparesc in fisierul $adunare.out$\r\n\r\n* pe prima linie: suma celor doua numere $a + b$\r\n\r\nh2. Restrictii\r\n\r\n* suma celor doua numere nu va depasi niciodata valoarea $2.000.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. adunare.in |_. adunare.out |\r\n| 131\r\n  245\r\n| 376 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adunare\")==\r\n\r\nh2. Discutii pe forum\r\n\r\n== SmfTopic(topic_id=\"27\") ==',1,'task: adunare'),('problema/munte','Munte','2006-11-24 16:13:25','==Include(page=\"template/taskheader\" task_id=\"munte\")==\r\n\r\nGheorghe vrea sa cucereasca un munte. El are anumite informatii despre munte. Stie cat de inalt este muntele si care e distanta pana la celaltalta parte a muntelui. El mai are si o lista cu puncte speciale prin care trebuie sa treaca, despre acest puncte stie inaltimea lor si ordinea in care apar, nu stie distanta dintre aceste puncte. Muntele este format din $3$ tipuri de teren.\r\n\r\n!problema/munte?img4.jpg!\r\n\r\n* Tipul 1: teren crescator, unde muntele creste un metru pe verticala pentru fiecare metru pe orizontala.\r\n* Tipul 2: teren drept. Pe acesta portiune terenul nici nu urca nici nu coboara.\r\n* Tipul 3: teren descrescator , unde muntele scade un metru pe verticala pentru fiecare metru pe orizontala.\r\n\r\nh2. Cerinta\r\n\r\nGheorghe avand toate aceste informati, $N$ (inaltimea maxima a munteleui, presupunand ca muntele incepe la nivelul $0$ si se termina la nivelul $0$), $D$ - distanta pe orizontala a muntelui si inaltimea la fiecare punct special, vrea sa stie cate posibilitati are de a parcurge muntele.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie din fisierul $munte.in$ se va afla numarul $N$ - inaltimea maxima a muntelui, $D$ - distanta pe orizontala a muntelui si $K$ - numarul de puncte speciale.\r\nPe urmatoarele $K$ linii sunt scrise inaltimile punctelor speciale\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului $munte.out$ se va gasi $P$ - numarul de posibilitati de a traversa muntele.\r\n\r\nObservatii\r\n\r\n* Gheoghe incepe la nivelul $0$ si trebuie sa termine la nivelul $0$\r\n* Doar incepul si sfasitul au nivelul $0$!\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 50$\r\n* $1 &le; D &le; 100$\r\n* $0 &le; K &le; 50$\r\n* $0 &le; P &le; 2^63^-1$\r\n\r\nExemple\r\n\r\ntable(example). |_. munte.in |_. munte.out |\r\n| 2 5 0\r\n| 3 |\r\n\r\nh3. Explicatii \r\n\r\nCele 3 posibilitati diferite sunt:\r\n  !problema/munte?img1.jpg!\r\n  !problema/munte?img2.jpg!\r\n  nu este o parcurgere valida pentru ca inaltimea muntelui nu este $2$, ci $1$\r\n\r\ntable(example). |_. munte.in |_. munte.out |\r\n| 2 5 2 \r\n  2\r\n  2\r\n| 1 |\r\n\r\nh3. Explicatii \r\n\r\n!problema/munte?img3.jpg!\r\n\r\nSingura parcurgere posibila este cea de sus\r\n\r\ntable(example). |_. munte.in |_. munte.out |\r\n| 3 8 4\r\n  2\r\n  2\r\n  3\r\n  1 \r\n| 7 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"munte\")==',1142,'task: munte'),('problema/concurs','Concurs','2006-11-22 02:48:06','==Include(page=\"template/taskheader\" task_id=\"concurs\")==\r\n\r\nFuree Pede s-a angajat la BIT (aceasta firma are structura ierarhica in forma de arbore) si a primit sarcina de a gestiona un concurs. La acest concurs participa cu proiecte echipe de cate doi angajati. Numarul de puncte acumulate de echipa este cel daruit de cel mai mic sef comun al celor doi componenti din echipa. Se cunosc echipele participante la concurs, ierarhia firmei si numarul de puncte pe care le poate darui fiecare angajat.\r\n\r\nh2. Cerinta\r\n\r\nFuree Pede va cere ajutorul si vrea sa afle echipa castigatoare (cea care primeste cele mai multe puncte).\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $concurs.in$ se afla $N$ si $M$, separate prin cate un spatiu. $N$ reprezinta numarul angajatilor , iar $M$ numarul echipelor participante la concurs. Pe urmatoarea linie se afla $N$ numere naturale reprezentand punctele pe care le poate darui fiecare angajat. Urmatoarele $N-1$ linii contin cate doua numere $X,Y$ care descriu ierarhia firmei({$X$} este seful lui $Y$). In final urmeaza $M$ linii cu cate doua numere, reprezentand numerele de ordine ale componentilor fiecarei echipe.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului $concurs.out$ se va afisa trei numare, primul reprezentand punctajul echipei castigatoare , iar celelalte doua componentii echipei castigatoare.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 < N < 32001$\r\n* $0 < M < 500001$\r\n* Punctajul maxim este mai mic decat $2.000.000.000$\r\n* In cazul in care un component al unei echipe este seful celuilalt atunci proectul primeste puncte chiar de la acesta.\r\n* In cazul in care mai multe echipe realizeaza acelasi punctaj se va afisa echipa in care numarul de ordine al primului component este mai mic,iar daca si acesta este egal se va afisa echipa in care numarul de ordine celui de-al doilea component este mai mic.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. concurs.in|_. concurs.out|\r\n| 5 2\r\n6 4 2 2 2 \r\n1 2 \r\n1 5 \r\n2 3 \r\n2 4 \r\n3 4 \r\n3 2 | 4 3 2 |\r\n\r\nh3. Explicatie\r\n\r\nSeful comun al lui 3 4 este 2, echipa castiga 4. Seful comun al lui 3 2 este 2 , echipa castiga 4. Raspunsul este 3 2 deoarece 3=3,dar 2<4.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"concurs\")==',1,'task: concurs'),('problema/regine','Regine','2006-11-24 16:16:35','==Include(page=\"template/taskheader\" task_id=\"regine\")==\r\n\r\nPe o tabla triunghiulara de latura $N$, trebuiesc asezate cat mai multe regine, astfel incat acestea sa nu se atace.\r\n\r\nO tabla triunghiulara, de latura $N$, are $N$ linii. Pe linia $i$ sunt $i$ locuri in care reginele pot sta, iar locurile sunt asezate sub forma de triunghi, ca in figura de mai jos. Fiind vorba de o tabla mai speciala si reginele sunt speciale, in sensul ca ele se pot deplasa (ataca) in $6$ directii.\r\n\r\n!problema/regine?regine.jpg!\r\n\r\nIn figura de mai sus este reprezentata o tabla de latura $6$, cu o regina pe linia $5$, coloana $4$. Numerotarea liniilor si coloanelor incepe de la $1$ (din varful tablei in jos - pentru linii si de la stanga la dreapta pentru coloane).\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul maxim de regine ce pot fi asezate pe o tabla de dimensiune $N$ si o asezare posibila a lor (oricare dintre solutiile cu numar maxim).\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului se afla un numar natural $N$, reprezentand dimensiunea tablei.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul va contine pe prima linie un singur numar intreg, $X$, reprezentand numarul maxim de regine ce pot fi asezate. Pe urmatoarele $X$ linii se vor scrie cate $2$ numere separate de un singur spatiu, reprezentand linia si respectiv coloana reginelor.\r\n\r\nh2. Restrictii\r\n\r\n* $1 < N < 1 001$\r\n* daca un test are numarul corect de regine, dar configuratia reginelor nu este valida, se acorda $30%$ din punctajul testului.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. regine.in |_. regine.out |\r\n| 3\r\n| 2\r\n2 1\r\n3 3 |\r\n\r\nh3. Explicatii\r\n\r\nPutem aseza maxim $2$ regine: una pe linia $2$, coloana $1$ si una pe linia $3$, coloana $3$.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"regine\")==',1142,'task: regine'),('problema/patrate','Patrate','2006-11-24 16:10:11','==Include(page=\"template/taskheader\" task_id=\"patrate\")==\r\n\r\nCiobanasul Ion vrea sa isi inchida oile in tarcuri si printr-o coincidenta fericita prietenul lui, Vasile are o firma de construit tarcuri. Cum Vasile este bun prieten cu Ion i-a propus sa ii construiasca tarcurile gratis, cu conditia ca ele sa aiba un cost cat mai mic. Vasile accepta sa construiasca cel mult trei tarcuri de forma unor patrate cu laturile paralele cu axele de coordonate. Aceste patrate trebuie sa contina in interior toate oile, consideram pentru simplitate ca o oaie este un punct in plan. Pentru a obtine un cost cat mai mic, trebuie ca latura celui mai mare tarc sa fie cat mai scurta posibil. Tarcurile se pot intersecta, iar un punct de pe marginea tarcului se considera in interior.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Ion sa gaseasca o solutie care sa il multumeasca pe Vasile.\r\n\r\nh2. Date de Intrare (fisier: $patrate.in$)\r\n\r\nIn fisierul de intrare se afla pe prima linie un numar natural $n$ ce reprezinta numarul oilor lui Ion, iar pe urmatoarele $n$ linii pozitiile oilor, adica fiecare astfel de linie contine doua numere intregi $x, y$ separate printr-un singur spatiu ce reprezinta pozitia unei oi (abscisa si ordonata).\r\n\r\nh2. Date de Iesire (fisier: $patrate.out$)\r\n\r\nFisierul de iesire va contine un numar natural ce reprezinta latura minima care o poate avea cel mai mare tarc dintre cele trei, astfel incat toate oile sa fie in interiorul celor trei tarcuri.\r\n\r\nh2. Restrictii\r\n\r\n* $1&le;n&le;50000$\r\n* Coordonatele oilor sunt numere intregi din intervalul $[0, 50000]$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. patrate.in |_. patrate.out |\r\n|6\r\n1 0\r\n2 1\r\n3 2\r\n3 4\r\n5 4\r\n6 0\r\n| 2 |\r\n\r\nh3. Explicatii\r\n\r\n!problema/patrate?image001.gif!\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"patrate\")==',1142,'task: patrate'),('problema/fractal','Fractal','2006-11-24 15:51:27','==Include(page=\"template/taskheader\" task_id=\"fractal\")==\r\n\r\nHilbert a gasit o curba care poate trece prin fiecare punct al spatiului, aceasta curba se bazeaza pe o constructie recursiva. Numim curba de ordin Hilbert de ordinul $K$ curba curba realizata dupa urmatoarele reguli ce trece prin fiecare nod al unei grile de $2^K^*2^K^$ noduri si trece prin noduri vecine ale grilei.\r\nCurba Hilbert de ordinu 1 este o curba simpla:\r\n!task/fractal?image001.gif!\r\n\r\nVor fi descries in urmatoarele imagini trecerile de la o curba de ordin x la o curba de ordin x+1:\r\nOrdin $1$ -> Ordin $2$\r\n!problema/fractal?image001.gif! !problema/fractal?image002.gif! !problema/fractal?image003.gif! !problema/fractal?image004.gif! !problema/fractal?image005.gif!\r\nOrdin $2$ -> Ordin $3$\r\n!problema/fractal?image006.gif! !problema/fractal?image007.gif! !problema/fractal?image008.gif! !problema/fractal?image009.gif! !problema/fractal?image010.gif!\r\nOrdin $3$ -> Ordin $4$\r\n!problema/fractal?image011.gif! !problema/fractal?image012.gif! !problema/fractal?image013.gif! !problema/fractal?image014.gif! !problema/fractal?image015.gif!\r\nOrdin $4$ -> Ordin $5$\r\n!problema/fractal?image016.gif! !problema/fractal?image017.gif! !problema/fractal?image018.gif! !problema/fractal?image019.gif! !problema/fractal?image020.gif!\r\n\r\nSe dau ca date de intrare din fisierul $fractal.in$ numerele $K, x$ si $y$, unde $K$ este ordinul unei curbe, iar $x$ si $y$ sunt coordanate intregi in interiorul unui patrat de dimensiune $2^K^*2^K^$. Se cere sa scrieti in fisierul de iesire $fractal.out$ in cati pasi se ajunge la coordonatele $(x,y)$ daca punctele din patrat sunt parcurse in ordinea data de curba Hilbert de ordin $K$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; k &le; 15$\r\n* $1 &le; x,y &le; 2^K^$\r\n* Coordonatele $x$ si $y$ sunt intre $1$ si $2^K^$ inclusive, iar coltul din stanga sus are coordonatele $(1,1)$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. fractal.in |_. fractal.out |\r\n| 1 1 1 | 0 |\r\n| 3 2 3 | 13 |\r\n| 2 4 1 | 15 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"fractal\")==',1142,'task: fractal'),('problema/pascal','Pascal','2006-11-24 16:14:37','==Include(page=\"template/taskheader\" task_id=\"pascal\")==\r\n\r\nIon a invatat la ora de matematica despre triunghiul lui Pascal. Fiecare rand din acest triunghi are primul si ultimul element egal cu $0$. Un element din triunghi se calculeaza ca fiind suma celor $2$ elemente exact deasupra acestuia. Randurile sunt numerotate de la $0$, deci, spre exemplu, randul $2$ contine: $1 2 1$. Este un fapt binecunoscut ca valoarea elementului $j$ (cu indexarea elementelor de la $0$) de pe linia $i$ se poate calcula si cu ajutorul formulei: $i!/((i-j)!*j!$) . (Prin $i!$ se intelege produsul $1*2*...*i$).\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Ion sa calculeze cate numere de pe randul $R$ sunt divizibile la $D$.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $pascal.in$ se gasesc numerele $R$ si $D$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului de iesire $pascal.out$ se va gasi numarul cerut.\r\n\r\nh2. Restrictii\r\n\r\n* $0 &le; R &le; 5.000.000$\r\n* $2 &le; D &le; 6$\r\n* Observatie: $0 != 1$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. pascal.in |_. pascal.out |\r\n| 4 2\r\n| 3 |\r\n\r\nh3. Explicatii \r\n\r\n!problema/pascal?pascal.gif! \r\n\r\nRandul $4$ contine elementele :\r\n$1 4 6 4 1$\r\ndintre care $4$, $6$ si $4$ sunt divizible la $2$ \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"pascal\")==',1142,'task: pascal'),('problema/reuniune','Reuniune','2006-11-24 16:16:03','==Include(page=\"template/taskheader\" task_id=\"reuniune\")==\r\n\r\nZaharel a fost provocat de Eugenia sa rezolva urmatoarea problema: se dau trei dreptunghiuri in plan cu laturile paralele cu axele $OX$ si $OY$. Sa se determine aria si perimetrul reuniunii celor trei dreptunghiuri (reuniunea dreptunghiurilor reprezinta multimea de puncte care apartin cel putin unui dreptunghi).\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Zaharel sa realizeze un program care calculeaza datele cerute.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $reuniune.in$ va contine trei linii, cate una pentru fiecare dreptunghi. Fiecare linie va avea patru numere intregi $X{~0~} Y{~0~} X{~1~} Y{~1~}$ reprezentand colturile stanga-jos si dreapta-sus ale dreptunghiului respective.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $reuniune.out$ va o singura linie cu doua numere naturale: aria si perimetrul reuniunii.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $-1.000.000.000 &le; X{~0~}, Y{~0~}, X{~1~}, Y{~1~} &le; 1.000.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. reuniune.in |_. reuniune.out |\r\n| 0 0 8 6\r\n4 2 11 9\r\n2 -2 6 4 | 89 44 | \r\n\r\nh3. Explicatie\r\n\r\n !problema/reuniune?poza.gif!\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"reuniune\")==',1142,'task: reuniune'),('problema/dreptunghiuri','Dreptunghiuri','2006-11-24 16:11:04','==Include(page=\"template/taskheader\" task_id=\"dreptunghiuri\")==\r\n\r\nClod sta intr-o zi plictisit la ora de matematica si in timp ce profesorul explica la tabla teorema lui Pick, Clod se gandea la o problema mai interesanta: pentru o grila de puncte laticiale de dimensiune $N*M$ (punctele laticiale sunt punctele de coordonate intregi) care este numarul de dreptunghiuri cu varfurile in puncte laticiale. Clod este curios daca exista o formula pentru aceasta problema si ar vrea sa stie solutia pentru diferite dimensiuni ale grilei, pentru a putea ghici o asemenea formula.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Clod sa afle raspunsul!\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul de intrare $dreptunghiuri.in$ pe prima linie se vor afla doi intregi $m$ si $n$ separati printr-un spatiu.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $dreptunghiuri.out$ va contine pe prima linie un singur numar intreg reprezentand numarul de dreptunghiuri cerut in problema.\r\n\r\nh2. Restrictii\r\n\r\n* $0 < m, n &le; 400$\r\n* Pentru teste in valoare totala de $60$ de puncte, $0 < m, n &le; 90$.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. dreptunghiuri.in |_. dreptunghiuri.out |\r\n|3 3 |10 |\r\n\r\nh3. Explicatie\r\n\r\nIn cele 10 figuri sunt desenate toate dreptunghiurile ce se pot forma cu colturi in puncte de coordonate intregi pentru o grila de dimensiuni 3x3.\r\n\r\n!problema/dreptunghiuri?image001.jpg!\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"dreptunghiuri\")==',1142,'task: dreptunghiuri'),('problema/jarbore','J-Arbore','2006-11-24 16:14:04','==Include(page=\"template/taskheader\" task_id=\"jarbore\")==\r\n\r\nJ-arborele este un arbore infinit cu urmatoarele proprietati:\r\n\r\n* pe nivelul $1$ al arborelui exista un singur nod (radacina)\r\n* fiecare nod de pe nivelul $i$ are exact $i$ fii\r\n* muchiile arborelui se eticheteaza cu numere intregi consecutive incepand cu primul nivel al arborelui mergand de la stanga la dreapta\r\n* toate nodurile in afara radacinii vor fi etichetate cu numere intregi egale cu suma muchiilor de pe drumul de la radacina la nodul respectiv\r\n\r\nMai jos aveti primele nivele ale unui astfel de arbore.\r\n\r\n!problema/jarbore?jtree.gif!\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un numar natural $X$ vi se cere sa spuneti daca exista un nod etichetat cu valoarea $X$ si sa afisati etichetele muchiilor din drumul de la radcina spre nodul respectiv.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul de intrare $jarbore.in$ vor exista mai multe teste. Pe prima linie se va afla $T$ numarul de teste. Pe urmatoarele $T$ linii se afla cate un numar {$X$}.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $jarbore.out$ vor exista $T$ linii. Pe fiecare linie se vor afla etichetele muchiilor din drumul de radacina catre nodul cu proprietatea ceruta sau $-1$ in cazul in care nu exista un astfel de nod.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; X &le; 10^18^$\r\n* $1 &le; T &le; 1000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. jarbore.in |_. jarbore.out |\r\n| 7\r\n100\r\n1\r\n2\r\n12\r\n17\r\n89\r\n666\r\n| -1\r\n1\r\n-1\r\n1 3 8\r\n1 2 4 10\r\n1 2 5 16 65\r\n1 3 7 22 97 536 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"jarbore\")==',1142,'task: jarbore'),('problema/numere','Numere','2007-01-14 17:48:06','==Include(page=\"template/taskheader\" task_id=\"numere\")==\r\n\r\nCand erau ei mai tineri, lui Mars si lui Mugurel le placea sa se joace cu numerele. Astfel, ei au inventat urmatorul joc: Doi jucatori se joaca cu doua numere pozitive. Jucatorii efectueaza mutari alternativ, iar jucatorul care a efectuat ultima mutare castiga. O mutare consta in scaderea din numarul mai mare a unui multiplu strict pozitiv al numarului mai mic, cu conditia ca acest multiplu sa fie mai mic decat sau egal cu numarul mai mare. Altfel spus, presupunand ca cele doua numere sunt $X$ si $Y$ si ca $X&ge;Y$, o mutare consta in scaderea din numarul $X$ a oricarui numar de forma $K*Y$ ({$K&ge;1$}), cu conditia $K*Y&ge;X$. Jocul se termina cand unul din numere devine egal cu $0$. Scrieti un program care decide care din cei doi jucatori va castiga jocul, considerand ca ambii jucatori joaca optim.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $numere.in$ contine numarul $T$ de jocuri descrise in continuare. Fiecare din urmatoarele $T$ linii contine $2$ numere intregi $X$ si $Y$, separate printr-un spatiu, reprezentand valorile initiale ale celor doua numere.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $numere.out$ veti afisa $T$ linii. Pe fiecare linie veti afisa castigatorul jocului corespunzator din fisierul de intrare. Veti afisa $1$, daca primul jucator (cel care efectueaza prima mutare) va castiga, respectiv $2$, daca al doilea jucator va castiga.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; T &le; 20$\r\n* $1 &le; X,Y &le; 10^9^$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. nume.in |_. nume.out |\r\n| 5\r\n  1 19\r\n  19 1\r\n  27 33\r\n  333333333 273333333\r\n  9997 19999\r\n| 1\r\n  1\r\n  2\r\n  2\r\n  1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"numere\")==',1,'task: numere'),('problema/suma','Suma','2006-11-24 16:19:11','==Include(page=\"template/taskheader\" task_id=\"suma\")==\r\n\r\n\r\nFie suma:\r\n!problema/suma?suma_formula.jpg!.\r\n\r\nCalculati valoarea $S$ mod $P$ (restul impartirii lui $S$ la $P$).\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $suma.in$ se afla 2 numere intregi $N$ si $P$ (separate printr-un spatiu).\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $suma.out$ veti afisa valoarea ({$S$} mod $P$).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 10^9^$\r\n* $1 &le; P &le; 30 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. suma.in|_. suma.out|\r\n|7 29997|112|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"suma\")==',1142,'task: suma');
INSERT INTO `ia_textblock` VALUES ('introducere-in-asamblare','Introducere in asamblare','2006-11-24 16:06:15','h1. Introducere in asamblare\r\n\r\n(Categoria _Limbaje_, autor(i) _Botau Cristian_)\r\n\r\nAcest articol prezinta un limbaj mai putin folosit : limbajul de asamblare. Este folosit de cele mai multe ori pentru marirea vitezei de rulare a programelor. In prima sectiune sunt prezentate cateva avantaje / dezavantaje in folosirea acestui limbaj. Apoi sunt definite notiunile elementare ce trebuie stiute inainte de a trece la tratarea limbajului propriu-zis. De asemenea, sunt prezentate cateva intructiuni si transcrieri ale unor structuri din C/Pascal in limbaj de asamblare. In final sunt comparati timpii de executie intre varianta pascal si varianta assembler ale unei proceduri de {$Bubble Sort$}.\r\n\r\nh2. Limbajul de asamblare : avantaje si dezavantaje in folosirea lui\r\n\r\nDesi este unul dintre cele mai vechi limbaje de programare, limbajul de asamblare este incorporat si in cele mai noi compilatoare cum ar fi Visual C++ si Delphi. Codul de asamblare este foarte apropiat de codul executabil al programelor, asamblorul avand rolul de a codifica instructiunile din limbaj de asamblare in cod masina.\r\n\r\nIn prezent, limbajul de asamblare este din ce in ce mai putin folosit in scrierea programelor, deoarece compilatoarele de ultima generatie au functiile cele mai folosite de programatori deja scrise si optimizate in limbaj de asamblare (gen memmove, memset / fillchar, etc.) incluse in unit-uri si biblioteci. Bineinteles, daca se doreste atingerea unor timpi de executie foarte mici, folosirea limbajului de asamblare este preferabila (cand avem algoritmul de complexitate optima).\r\n\r\nh3. Avantaje ale limbajului de asamblare\r\n\r\n* Viteza foarte mare the executie a programelor (unele programe scrise si optimizate in asamblare au viteza de executie pana la 5-10 de ori mai mare decat cele scrise in C sau Pascal);\r\n* Marimea codului executabil este foarte mica;\r\n* Ajuta utilizatorul sa inteleaga mai bine cum functioneaza microprocesorul si sa scrie programe eficiente si in High Level Languages.\r\n\r\nh3. Dezavantaje ale limbajului de asamblare\r\n\r\n* nu este portabil; un program scris pentru calculatoare IBM PC nu va rula pe un Apple Macintosh (difera unele instructiuni);\r\n* un program in asamblare este mai greu de scris si ia mai mult timp decat un program scris in Pascal sau C;\r\n* un program scris in asamblare este mai greu de depanat;\r\n\r\nMajoritatea compilatoarelor din prezent permit programatorului sa scrie anumite parti de cod sau subprograme in asamblare, astfel incat programatorul sa poata scrie in asamblare doar partea din program care se executa de cele mai multe ori, programul ruland astfel mult mai rapid. Sunt si compilatoare dedicate exclusiv limbajului de asamblare, cum ar fi TASM - Turbo Assembler (il gasiti in directorul BP/Bin), MASM - Microsoft Assembler, etc.\r\n\r\nPentru a scrie o secventa de limbaj de asamblare intr-un program C se foloseste cuvantul rezervat asm :\r\n\r\n== code(cpp) |asm { instructiuni in asamblare };\r\n==\r\n\r\niar in pascal :\r\n\r\n== code(pas) |asm\r\n    cod asamblare\r\nend.\r\n==\r\n\r\nh2. Notiuni de baza ale limbajului de asamblare\r\n\r\nh3. Registrii\r\n\r\nLimbajul de asamblare este foarte apropiat de codul executabil, deci pentru ca programatorul sa fie capabil sa scrie codul in asamblare trebuie sa cunoasca modul in care functioneaza microprocesorul si modul in care acesta executa instructiunile.\r\n\r\nToate operatiile aritmetice/logice/acces la memorie se fac prin intermediul registrilor. Registrii microprocesorului sunt asemanatori variabilelor (pot fi initializati cu anumite valori, se pot efectua operatii asupra lor, pot fi accesati (cititi/modificati)).\r\nRegistrii microprocesorului sunt clasificati in mai multe categorii :\r\n\r\n* registri de uz general : {$eax$}, {$ebx$}, {$ecx$}, {$edx$} si subregistrii lor;\r\n* registri segment : {$cs$} (code segment), {$ds$} (data segment), {$es$} (extra segment), {$ss$} (stack segment) - sunt folositi pentru adresarea memoriei in cazul modelului de memorie segmentat\r\n* registrii index : {$esi$}, $edi$ (source index, destination index);\r\n* registri speciali : {$ebp$}, {$esp$}, {$ip$};\r\n\r\nRegistrii de uz general sunt folositi in executia operatiilor aritmetice si logice. Registrii de segment si cei index sunt folositi in adresarea memoriei, iar cei speciali sunt folositi de microprocesor si S.O. pentru rularea programelor.\r\n\r\nh4. Registrii de uz general\r\n\r\nAcestia sunt :\r\n\r\n* $eax$ - numit si \"accumulator\" - acesta este cel mai folosit in executarea operatiilor aritmetice (adunare, scadere, inmultire, impartire);\r\n* $ebx$ - numit si \"base\" - acesta registru este folosit pentru adresarea indirecta a memoriei;\r\n* $ecx$ - numit si \"count\" - acest registru este folosit mai ales in cadrul \"buclelor\" (in instructiunile repetitive : for/ while do/ do while/ repeat until);\r\n* $edx$ - numit si \"data\" - retine anumite variabile, si este folosit impreuna cu $eax$ in executarea operatiei \"div\", impartire intreaga (avand rolul de a retine restul impartirii).\r\n\r\nDupa cum ati observat, fiecare registru general are o functie specifica, insa oricare din ei pot fi folositi si la operatii aritmetice/logice, adresare memorie sau ca si variabile.\r\n\r\nRegistrii precedati de prefixul \"{$e$}\" sunt pe $32$ de biti, deci pot fi tratati ca si variabile {$unsigned long$}/{$signed long$} ({$doubleword$}). Acestia pot fi folositi si ca registri pe $16$ biti ({$word$}) sau pe $8$ biti ({$byte$}) prin intermediul \"subregistrilor\" : {$ax$}, {$bx$}, {$cx$}, $dx$ (reprezinta word-ul nesemnificativ = cel din dreapta)., {$ah$}, {$bh$}, {$ch$}, $dh$ (byte-ul cel mai semnificativ al {$ax$}, {$bx$}, {$cx$}, {$dx$}), {$al$}, {$bl$}, {$cl$}, {$dl$}(registrii pe 8 biti).\r\n\r\nh4. Registrii de segment si index\r\n\r\nAcesti registri sunt folositi la adresarea memoriei.\r\nDe exemplu\r\nAvem variabila {$void *x;$}({$x : pointer$} in pascal);\r\npentru modelul de memorie segmentata, in adresarea memoriei adresate de $x$ se folosesc intructiunile (vezi \"Intructiunile de baza ale unui microprocesor 8086\") :\r\n\r\n== code(cpp) |// es:[di] va accesa adresa pointata de x;\r\nles di, x\r\n// se copiaza in ax primul word\r\n// de la adresa es:[di]\r\nmov ax, es:[di]\r\n// se copiaza in al cel de-al 3-lea byte\r\n// de la adresa es:[di]\r\nmov al, es:[di+2]\r\n==\r\n\r\nParantezele drepte se refera la zona de memorie adresata de registru.\r\nExemplu :\r\n\r\n\"{$[esi]$}\" se refera la valoarea aflata la adresa de memorie cu offset-ul esi, iar \"{$esi$}\" se refera la valoarea stocata in registrul esi;\r\n\r\ndaca $esi = 100$ atunci [{$esi$}] va reprezenta valoarea care se afla la adresa cu offset-ul {$100$}, iar esi va reprezenta valoarea {$100$}.\r\n\r\nVa sfatuiesc sa NU incercati sa modificati urmatorii registri : $cs$ (care contine segmentul la care se afla incarcat codul executabilului, $ss$ contine segmentul de memorie in care se afla stiva sistemului).\r\n\r\nh4. Registrii speciali\r\n\r\nSunt folositi foarte rar in scrierea efectiva a programelor, deci nu veti accesa prea des acesti registri.De exemplu, $ip$ (instruction pointer) care retine adresa (de fapt offset-ul) la care se afla instructiunea care urmeaza sa fie executata.\r\n\r\nh4. Flagurile microprocesorului\r\n\r\nFlag-urile microprocesorului sunt asemanatoare unor variabile boolene. Cu ajutorul lor putem afla rezultatul unei comparatii sau daca o operatie a produs \"overflow\", etc. Aceste flag-uri nu pot fi accesate direct ca si registrii, ci testarea daca un flag este activat se face prin intermediul \"jump\"-urilor conditionate.(vezi instructiunea {$cmp$}).\r\n\r\nExemplu :\r\nFie {$ax = 1$}. Decrementarea lui $ax$ cu $1$ va duce la activarea flagului numit Zero-Flag.(rezultatul operatiei a fost {$0$}).\r\nFie {$ax = 65535$} ({$0xFFFF$}). Incrementarea lui $ax$ cu $2$ va duce la setarea flagului numit Overflow-Flag (rezultatul operatiei nu \"incape\" in $16$ biti);\r\n\r\nh3. Instructiunile de baza ale microprocesorului 8086 :\r\n\r\nSunt folosite urmatoarele prescurtari :\r\n\r\n* {$reg8$}/ {$reg16$}/ {$reg32$} - se refera la registri pe {$8$}/{$16$}/{$32$} biti;\r\n* {$imm8$}/ {$imm16$}/ {$imm32$} - se refera la valori imediate (constante);\r\n* {$mem8$}/ {$mem16$}/ {$mem32$} - zona memorie de memorie sau variabile pe {$8$}/{$16$}/{$32$} biti;\r\n\r\nh4. Instructiunea MOV\r\n\r\nh5. Sintaxa\r\n\r\n* $mov dest, source$ // echivalenta cu dest = source\r\n\r\nh5. Variante\r\n\r\n* $mov reg8/16/32, mem8/16/32$\r\n* $mov reg8/16/32, reg8/16/32$\r\n* $mov mem8/16/32, reg8/16/32$\r\n* $mov reg8/16/32, imm8/16/32$\r\n* $mov mem8/16/32, imm8/16/32$\r\n\r\nh5. Descriere\r\n\r\nInstructiunea copiaza o valoare dintr-o locatie in alta locatie. Aceasta locatie poate fi zona de memorie, variabila, registru. De retinut este ca nu exista variante ale instructiunii care copiaza direct dintr-o zona de memorie in alta.\r\n\r\nh5. Flaguri afectate\r\n\r\nInstructiunea mov nu modifica nici un flag.\r\n\r\nh5. Restrictii\r\n\r\nAmbii operanzi trebuie sa aiba aceeasi marime. De exemplu pentru ultima varianta a instructiunii mov trebuie specificata marimea zonei de memorie. Instructiunea \"mov [bx], 0\" nu este corecta deoarece compilatorul nu stie ce vrea sa faca instructiunea: sa copieze valoarea 0 in byte-ul, in word-ul sau in doubleword-ul de la adresa bx. Astfel variantele corecte sunt:\r\n\r\n== code(cpp) |mov byte ptr [bx], 0\r\nmov word ptr [bx], 0\r\nmov dword ptr [bx], 0\r\n==\r\n\r\nh5. Exemplu\r\n\r\n== code(cpp) |mov ax, 3 // ax = 3\r\nmov bx, ax // bx = ax\r\n==\r\n\r\nh4. Instructiuni aritmetice. Instructiunile ADD, SUB, INC, DEC\r\n\r\nh5. Sintaxa\r\n\r\n* $add dest, source$ // echivalenta cu dest+=source\r\n* $sub dest, source$ // echivalenta cu dest-=source\r\n* $inc dest$ // echivalenta cu dest++\r\n* $dec dest$ // echivalenta cu dest--\r\n\r\nh5. Variante\r\n\r\n* $add(sub) reg8/16/32, mem8/16/32$\r\n* $add(sub) reg8/16/32, reg8/16/32$\r\n* $add(sub) mem8/16/32, reg8/16/32$\r\n* $add(sub) reg8/16/32, imm8/16/32$\r\n* $add(sub) mem8/16/32, imm8/16/32$\r\n\r\nh5. Descriere\r\n\r\nInstructiunea \"{$add$}\" este folosita pentru a aduna doua valori, \"{$sub$}\" pentru a scadea o valoare din alta, \"{$inc$}\" - incrementarea unei variabile, \"{$dec$}\" - decrementarea unei variabile (registru/memorie).\r\n\r\nh5. Flaguri afectate\r\n\r\n* $carry flag$ - pentru \"signed overflow\"\r\n* $overflow flag$ - pentru overflow\r\n* $sign flag$ - activat daca rezultatul este negativ\r\n* $zero flag$ - activat daca rezultatul operatiei a fost 0\r\n* $parity flag$ - este setat in functie de paritatea rezultatului\r\n\r\nh5. Restrictii\r\n\r\nDestinatia trebuie sa aiba aceeasi marime ca si sursa.\r\n\r\nh5. Exemplu\r\n\r\n== code(cpp) |mov ax, 3 // ax = 3\r\nadd bx, ax // bx = ax+3\r\n==\r\n\r\nh4. Instructiuni pe biti. Instructiunile AND, TEST, OR, XOR, NOT\r\n\r\nh5. Sintaxa\r\n\r\n* $and dest, source$ // echivalenta cu dest&=source\r\n* $test dest, source$ // dest & source\r\n* $or dest, source$ // echivalenta cu dest|=source\r\n* $xor dest, source$ // echivalenta cu dest^=source\r\n* $not dest$ // ~dest\r\n\r\nh5. Variante\r\n\r\nPentru \"{$and$}\", \"{$or$}\", \"{$test$}\", \"{$xor$}\" sunt ca si cele de la \"{$add$}\". Pentru \"{$not$}\" avem doua variante :\r\n\r\n* $not reg8/16/32$\r\n* $not mem$\r\n\r\nh5. Descriere\r\n\r\nExecuta operatiile pe biti corespunzatoare. Instructiunea test (non-destructive and) este asemanatoare lui and, dar nu afecteaza rezultatul ci doar flagurile.\r\n\r\nh5. Flaguri afectate\r\n\r\nInstructiunea \"{$not$}\" nu afecteaza nici un flag.\r\nFlagurile afectate de celalalte instructiuni sunt :\r\n\r\n* {$carry$}, $overflow$ - le dezactiveaza\r\n* $sign flag$ - este copiat bitul cel mai semnificativ din rezultat (semnul rezultatului, de fapt)\r\n* $zero flag$ - activat daca rezultatul operatiei a fost 0\r\n* $parity flag$ - este setat in functie de paritatea rezultatului\r\n\r\nh5. Restrictii\r\n\r\nDestinatia trebuie sa aiba aceeasi marime ca si sursa.\r\nInstructinile $OR/XOR/INC/DEC$ modifica flag-urile microprocesorului: {$Carry$}(numai {$ADD/SUB$}), {$Overflow$}, {$Zero$}, {$Parity$}.\r\n\r\nh5. Exemplu\r\n\r\n== code(cpp) |mov ax, 5 // ax = 3\r\ntest ax, 1 // daca (ax & 1)\r\njz @skip // daca ax este nu este impar sari la @skip\r\n// executa instructiuni\r\n@skip\r\nand bx, FFFEh // bx = bx & 0xFFFE (se sterge bitul cel mai nesemnificativ)\r\n==\r\n\r\nh4. Instructiunile PUSH/POP\r\n\r\nh5. Descriere\r\n\r\nAceste instructiuni sunt folosite pentru accesarea stivei sistemului. Instructiunea PUSH pune pe stiva sistemului o valoare, iar instructiunea POP extrage valoarea din varful stivei.\r\n\r\nh5. Sintaxa\r\n\r\n* $push val$\r\n* $pop val$\r\n\r\nh5. Variante\r\n\r\n* $push reg8/16/32$\r\n* $pop reg8/16/32$\r\n\r\nh5. Exemplu\r\n\r\n== code(cpp) |@lp:\r\npush cx // salvam valoarea cx\r\n... // prelucreaza datele, se poate modifica cx\r\npop cx // scoate de pe stiva valoarea cx\r\ndec cx\r\njnz @lp // daca (cx != 0) atunci sari inapoi la @lp\r\n==\r\n\r\nh4. Instructiunea CMP\r\n\r\nh5. Descriere\r\n\r\nCompara doua valori si seteaza flag-urile microprocesorului cu rezultatele compararii. De cele mai multe ori este folosita in combinatie cu jump-urile (vezi mai jos).\r\n\r\nh5. Sintaxa\r\n\r\n* $cmp val1, val2$\r\n\r\nh5. Variante\r\n\r\n* $cmp reg8/16/32, reg8/16/32$\r\n* $cmp reg8/16/32, imm8/16/32$\r\n* $cmp mem8/16/32, reg8/16/32$\r\n* $cmp mem8/16/32, imm8/16/32$\r\n\r\nh4. Jump-urile neconditionate (JMP) si jump-urile conditionate (JE, JNE, JB, JBE, JA, JAE, JZ, JNZ)\r\n\r\nAceste instructiuni sunt folosite pentru generarea instructiunilor If /while do /do while /repeat /for.Sunt asemanatoare instructiunii goto din C/Pascal.\r\n\r\nh5. Sintaxa\r\n\r\n$instructiune label$\r\n\r\n* $JE$ * \"sare\" cu executia programului la label daca flag-ul equality este setat;\r\n* $JNE$ * \"sare\" cu executia programului la label daca flag-ul equality nu este setat;\r\n* $JB$ * \"sare\" cu executia programului la label daca flag-ul below este setat;\r\n* $JBE$ * \"sare\" cu executia programului la label daca flag-ul below sau flagul equality este setat;\r\n* $JA$ * \"sare\" cu executia programului la label daca flag-ul below nu este setat;\r\n* $JAE$ * \"sare\" cu executia programului la label daca flag-ul equality este setat sau flag-ul below nu este setat;\r\n* $JZ$ * \"sare\" cu executia programului la label daca flag-ul zero este setat;\r\n* $JNZ$ * \"sare\" cu executia programului la label daca flag-ul zero nu este setat;\r\n* $JMP$ * \"sare\" cu executia programului la label;\r\n\r\nh5. Exemplu\r\n\r\n== code(cpp) |mov ax, 1\r\n@loop :\r\n    instr1\r\n    instr2\r\n    *\r\n    inc ax\r\n    // compara ax cu valoarea 10 si seteaza flagurile\r\n    cmp ax, 10\r\n    // daca ax != 10 sari inapoi la @loop\r\njne @loop\r\n\r\n== code(cpp) |instr1\r\njmp @label1\r\n    instr2\r\n    instr3\r\n@label1 :\r\n==\r\n\r\nIn ultimul exemplu instr2 si instr3 nu vor fi executate deoarece inaintea lor se afla instructiunea jump care face ca programul sa sara cu executia la instructiunea imediat urmatoare etichetei \"label1\".\r\n\r\nh4. Instructiunea LOOP\r\n\r\nInstructiunea \"loop\" este folosita de obicei in transcrierea for-urilor si a buclelor.\r\n\r\nh5. Sintaxa\r\n\r\n* $loop label$\r\n\r\nh5. Descriere\r\n\r\nEchivalenta cu :\r\n\r\n== code(cpp) |dec ecx (sau dec cx)\r\njz label\r\n==\r\n\r\nh4. Instructiunea INT\r\n\r\nh5. Descriere\r\n\r\nInstructiunea INT apealeaza o intrerupere.\r\n\r\nh5. Sintaxa\r\n\r\n* $INT nr_intrerupere$ (un numar cuprins intre 0 si 255);\r\n\r\nIntreruperile opresc programul din rulare, executa un anumit cod si apoi permit continuarea rularii programului. Cu ajutorul apelului intreruperilor aplicatia poate sa comunice cu sistemul de operare, si cu unele componente hardware ale calculatorului (mouse-ul, tastatura, imprimanta, etc). Fiecare intrerupere are asociat un numar.\r\n\r\nh5. Exemple\r\n\r\n* $0x9$ : intreruperea pentru tastatura;\r\n* $0x10$ : intreruperea care ofera serviciile BIOS pentru accesul la placa video;\r\n* $0x21$ : intreruperea sistemului de operare DOS;\r\n* $0x33$ : intreruperea pentru mouse;\r\n\r\nIn DOS pentru initializarea mouse-ului se va apela functia numarul $0$ a intreruperii $0x33$ :\r\n\r\n== code(cpp) |asm\r\n{\r\n    mov ax, 0\r\n    // seteaza registrul ax cu valoarea 0 pentru ca\r\n    // driverul ce gestioneaza intreruperea 0x33\r\n    //sa stie ca trebuie sa initializeze mouse-ul\r\n    int 0x33\r\n}\r\n==\r\n\r\nPentru afisarea mouse-ului :\r\n\r\n== code(cpp) |asm\r\n{\r\n    mov ax, 1\r\n    int 0x33\r\n}\r\n==\r\n\r\nPentru ascunderea cursorului de la mouse :\r\n\r\n== code(cpp) |asm\r\n{\r\n    mov ax, 2\r\n    int 0x33;\r\n}\r\n==\r\n\r\nh2. Transcrierea unor instructiuni C/PASCAL in asamblare\r\n\r\nh3. IF cond THEN instr\r\n\r\nExemplu : \r\n\r\n== code(cpp) |if (a==5) b=a; // a, b : integer\r\n==\r\n\r\n== code(cpp) |mov ax, a\r\ncmp ax, 5\r\n// ne intrebam daca !cond\r\njnz @skip_if\r\nmov b, ax\r\n@skip_if :\r\n==\r\n\r\nh3. IF cond THEN instr1 ELSE instr2\r\n\r\nExemplu: \r\n\r\n== code(cpp) |if (a==b) a-=b; else b-=a;\r\n==\r\n\r\nTranscrierea in asamblare :\r\n\r\n== code(cpp) |mov ax, a\r\nmov bx, b\r\n// compara ax cu bx si seteaza flag-urile\r\ncmp ax, bx\r\nje @if_then\r\n// if (ax == bx) sari la @if_then\r\nsub b, ax\r\njmp @end_if :\r\n@if_then :\r\nsub a, bx\r\n@end_if :\r\n==\r\n\r\n\r\nh3. DO { inst } WHILE\r\n\r\nExemplu :\r\n\r\n== code(cpp) |int i, a, n;\r\ni = 0;\r\na = 0;\r\ndo\r\n{\r\n    i++;\r\n    a+=i;\r\n} while (i<=n);\r\n==\r\n\r\nCodul in asamblare :\r\n\r\n== code(cpp) |// cx = 0, instructiunea xor cx, cx este\r\n// mai rapida decat mov cx, 0\r\nxor cx, cx\r\nxor ax, ax\r\nmov bx, n\r\n@while :\r\n    inc cx\r\n    add ax, cx\r\n    cmp cx, bx\r\n    jne @while\r\nmov a, ax\r\nmov I, cx\r\n==\r\n\r\nSau folosind instructiunea loop (pornim invers) :\r\n\r\n== code(cpp) |mov cx, n\r\n@while:\r\n    add ax, cx\r\nloop @while\r\n==\r\n\r\nIn codul de mai sus (prima varianta) puteti observa cateva mici optimizari : retinerea variabilelor in registri (accesul la registri este mult mai rapid decat la memorie), inlocuirea instructiunii {$mov reg, 0$ cu {$xor reg, reg$}. Varianta \"xor\" este mai rapida (desi $mov$ si $xor$ \"teoretic\" au tot atatea ceasuri de procesor) deoarece instructiunea $mov reg, 0$ transcrisa in cod masina este mai \"lunga\" (are cu $2-4$ bytes mai mult decat {$xor reg, reg$}). Aceeasi regula se aplica si in cazul \"{$or reg, reg$}\" in testarea daca valoarea unui registru este egala cu {$0$}, intrucat instructiunea \"{$or$}\" modifica flagurile procesorului ({$ZeroFlag$}). O alta optimizare este folosirea registrului $ax$ pentru calcule (in majoritatea cazurilor instructiunile care folosesc registrul $(e)ax$ sunt mai rapide).\r\n\r\nh2. Program demonstrativ\r\n\r\nExemplu de functie in realizata in C/Asamblare (compilator folosit BC++ 3.1):\r\n\r\n== code(cpp) |// BSort.CPP\r\n#include <stdio.h>\r\n#include <conio.h>\r\n\r\nint a[20], n;\r\n\r\nvoid bsort()\r\n{\r\n	asm {\r\n		mov di,seg a\r\n		mov es,di\r\n		mov di,offset a\r\n		// es:[di] inceputul vectorului\r\n		// es - adresa segment\r\n		// di - adresa offset\r\n	};\r\n\r\ndo_while_not_ok :\r\n	asm {\r\n		// ok = 1;\r\n		mov dx, 1\r\n		// cx = n;\r\n		mov cx, n\r\n		// cx = n-1\r\n		dec cx\r\n		// ax = a[0]\r\n		mov ax, es:[di]\r\n		// punem di pe stiva\r\n		push di\r\n	}\r\ninner_for :\r\n	asm {\r\n		// bx = a[i-1]\r\n		mov bx, ax\r\n		// ne mutam pe noua pozitie in vector\r\n		add di, 2\r\n		// ax = a[i]\r\n		mov ax, es:[di]\r\n		// comparam ax cu bx (a[i-1] cu a[i])\r\n		cmp bx, ax\r\n		// if (a[i-1] <= a[i]) don\'t swap\r\n		jbe if_not\r\n		// interschimbam a[i-1] cu a[i]\r\n		xchg bx, ax\r\n		// le scriem in memorie\r\n		mov es:[di], ax\r\n		mov es:[di-2], bx\r\n		// ok = 0\r\n		xor dx, dx\r\n	}\r\nif_not :\r\n	asm {\r\n		// cx--;\r\n		dec cx\r\n		jnz inner_for\r\n		// daca cx != 0 atunci continuam for-ul\r\n		pop di\r\n		// compara dx cu 0\r\n		// (mai rapid decat cmp dx, 0)\r\n		or dx, dx\r\n		// if (ok) executam inca odata while-ul\r\n		jz do_while_not_ok\r\n	}\r\n}\r\n\r\nvoid citire()\r\n{\r\n	printf(\"Numarul de elemente : \");\r\n	scanf(\"%d\", &n);\r\n	for (int i=0; i<n; i++)\r\n	{\r\n		printf(\"a[%d] = \", i);\r\n		scanf(\"%d\", &a[i]);\r\n	}\r\n}\r\n\r\nvoid afis()\r\n{\r\n	for (int i=0; i<n; i++)\r\n		printf(\"%d \", a[i]);\r\n}\r\n\r\nint main()\r\n{\r\n	citire();\r\n	bsort();\r\n	afis();\r\n	return 0;\r\n}\r\n==\r\n\r\nVarianta Pascal + Asm (compilata cu BP 7.0):\r\n\r\n== code(pas) |program b_sort;\r\n\r\nconst   max_N = 1000;\r\n        n_tests = 100;\r\n\r\nvar N : Integer;\r\n    a, b : array [1..max_N] of Integer;\r\n\r\nprocedure citire;\r\nvar f : Text;\r\n    i : Integer;\r\nbegin\r\n    Assign(f, \'bsort.in\'); Reset(f);\r\n    readln(f, N);\r\n    for i := 1 to N do\r\n        read(f, b[i]);\r\n    Close(f)\r\nend;\r\n\r\nprocedure flip;\r\nvar i : Integer;\r\nbegin\r\n    for i:=1 to N do\r\n        a[i] := b[i];\r\nend;\r\n\r\nvar p : pointer;\r\n\r\nprocedure bsort; assembler;\r\nasm\r\n{ les <=> es = seg(p), di = offset(p) }\r\n    les di, p\r\n    @do_while_not_ok :\r\n        mov dx, 1\r\n        mov cx, N\r\n        dec cx\r\n        mov ax, es:[di]\r\n        push di\r\n        @inner_for :\r\n            mov bx, ax\r\n            add di, 2\r\n            mov ax, es:[di]\r\n            cmp bx, ax\r\n            jbe @if_not\r\n            xchg bx, ax\r\n            mov es:[di], ax\r\n            mov es:[di-2], bx\r\n            xor dx, dx\r\n            @if_not :\r\n                dec cx\r\n                jnz @inner_for\r\n        pop di\r\n        or dx, dx\r\n    jz @do_while_not_ok\r\nend;\r\n\r\nprocedure bsort2;\r\nvar ok : Boolean;\r\n    i, aux : Integer;\r\nbegin\r\n    repeat\r\n        ok := true;\r\n        for i := 1 to n-1 do\r\n            if (a[i] > a[i+1]) then\r\n            begin\r\n                aux := a[i];\r\n                a[i] := a[i+1];\r\n                a[i+1] := aux;\r\n                ok := false;\r\n            end;\r\n    until ok;\r\nend;\r\n\r\nvar i : Integer;\r\n    starttick, endtick : LongInt;\r\n    time : Longint absolute $0000:$046C;\r\n\r\n{ timer pentru masurarea timpului }\r\nconst tickspersecond = 18.206;\r\n\r\nprocedure starttimer;\r\nbegin\r\n    starttick := time;\r\nend;\r\n\r\nfunction elapsedtime : real;\r\nbegin\r\n    endtick := time;\r\n    elapsedtime := (endtick - starttick)*\r\n        (1 / tickspersecond);\r\nend;\r\n\r\nbegin\r\n    citire;\r\n    p := @a;\r\n    starttimer;\r\n    for i:=1 to n_tests do\r\n    begin\r\n        flip;\r\n        bsort;\r\n    end;\r\n    writeln(n_tests, \' rulari ale bsort in asamblare\r\n        au rulat in : \', elapsedtime : 6:3, \' secunde\');\r\n    starttimer;\r\n    for i:=1 to n_tests do\r\n    begin\r\n        flip;\r\n        bsort2;\r\n    end;\r\n    writeln(n_tests, \' rulari ale bsort obisnuit\r\n            au rulat in : \',elapsedtime : 6:3, \' secunde\');\r\nend.\r\n==\r\n\r\nOutput program pascal (pe pc-ul meu: Duron $750$ Mhz):\r\n$100$ rulari ale bsort in asamblare au rulat in : $1.263$ secunde\r\n$100$ rulari ale bsort obisnuit au rulat in : $4.614$ secunde\r\n\r\nDe precizat este ca nu am optimizat programul aproape deloc (am transcris codul din pascal in asm). Cu optimizari \"hardcore\" se pot obtine timpi mult mai buni. Diferenta dintre varianta asm si varianta high level language este mai mica pe compilatoarele mai noi, cum ar fi GCC sau FreePascal deoarece acestea stiu genera un cod mai optimizat. Totusi, nici un compilator nu poate bate creierul uman.\r\n\r\nh2. Linkuri\r\n\r\n\"Link #1\":http://www.arl.wustl.edu/~lockwood/class/cs306/books/\r\n\"Link #2\":http://artofasm/toc.html\r\n\r\nCartea \"The Art of Assembly Language Programming\". Este detaliata. Foarte buna atat pentru incepatori cat si pentru avansati.\r\n\r\n\"Link #3\":http://www.goof.com/pcg/doc/pentopt.txt\r\n\r\nUn tutorial bun pentru optimizarea programelor in asamblare pentru procesoarele din familia Pentium. Tutorialul este pentru avansati.\r\n\r\n\"Link #4\":http://www.techtutorials.info/assembly.html\r\n\r\nMai multe tutoriale despre assembly language.\r\n\r\nh2. Doua cuvinte conclusive...\r\n\r\nAcest articol trateaza \"bazele\" programarii in asamblare, dupa cum ii zice numele este doar o introducere. Pentru a sti sa programezi in asm, trebuie invatate mult mai multe lucruri. Scopul articolului este de a starni interesul cititorilor si de a le oferi o imagine asupra acestui limbaj. Cei ce doresc sa invete mai multe despre assembly language sunt invitati sa citeasca cartile / tutorialele din sectiunea linkuri.\r\n',1,'public'),('ciurul-lui-erathostene','Ciurul lui Erathostene','2006-11-22 02:15:10','h1. Ciurul lui Erathostene\r\n\r\n(Categoria _Teoria numerelor_, autor(i) _Cosmin_)\r\n\r\nArticolul de fata incearca o implementarea mai eficienta a acestui algoritm clasic. Se poate optimiza pentru a folosi doar $O(sqrt(n))$ memorie, varianta prezentata aici folosind $O(n / log n)$ memorie, unde log n e numarul de biti al unui cuvant.\r\n\r\nCiurul lui Erathostene e un algoritm clasic care se invata la scoala impreuna cu conceptul de numere prime inca din clasa a 6. Acest algoritm determina toate numerele prime mai mici decat un numar dat ca parametru. Ideea lui de abordare a acestei probleme poate fi modificata pentru a rezolva si alte probleme precum problema Fractii din arhiva infoarena, problema \"Riemann vs Mertens\":http://acm.uva.es/p/v107/10738.html din arhiva \"uva\":http://acm.uva.es/, problema \"Divizibilitate\":http://algoritmus.org/probleme/Probleme_Runda04.php a rundei 4 a concursului algoritmus, sau problema \"Square Free\":http://www.topcoder.com/stat?c=problem_statement&pm=2342&rd=4770 a SRM-ului 190 de pe TOPCODER, rezolvarea ei o gasiti \"aici\":http://www.topcoder.com/index?t=statistics&c=srm190_prob. \r\nIn articolul acesta nu ne vom concentra asupra acestor probleme ci asupra implementarii optimizate ale algoritmului original.\r\n\r\nAm mai scris despre aceste optimizari intr-un articol din ginfo, dar codul de acolo nu era testat si nu merge :).\r\n\r\nIdeea la acest algoritm e ca marcam intr-un sir fiecare multiplu al unui numar prim si numerele ramase nemarcate sunt numere prime, o descriere mai grafica gasiti la \"adresa\":http://mathworld.wolfram.com/SieveofEratosthenes.html.\r\n\r\nSa incercam o prima implementare a acestui algoritm (implementarile vor folosi limbajul java, dar sunt foarte usor transformabile in C/C++).\r\n\r\n== code(java) | \r\n  //class PrimeNumbersSieve1\r\n  final int MAXSIZE = 1000001;\r\n  char[] p = new char[MAXSIZE];\r\n  //p[i] == 0 if i is prime\r\n  public int getTheNumber(int n) {\r\n    int i, j, nr = 0;\r\n    for (i = 2; i <= n; ++i) {\r\n      if (p[i] == 0) {\r\n        nr++;\r\n        for (j = i + i; j <= n; j += i) {\r\n          p[j] = 1;\r\n        }\r\n      }\r\n    }\r\n    return nr;\r\n  }\r\n==\r\n\r\nO prima idee de optimizare ar fi sa nu mai luam in calcul numerele pare pentru ca stim ca singurul numar prim par e {$2$}. Deci sa vedem noua varianta a programului:\r\n\r\n== code(java) | \r\n  //class PrimeNumbersSieve2\r\n  final int MAXSIZE = 1000001;\r\n  char[] p = new char[MAXSIZE];\r\n\r\n  //p[i] == 0 if i is prime\r\n  \r\n  public int getTheNumber(int n) {\r\n    int i, j, nr = 1;\r\n    for (i = 3; i <= n; i += 2) {\r\n      if (p[i] == 0) {\r\n        nr++;\r\n        for (j = i + i + i; j <= n; j += i << 1) {\r\n          p[j] = 1;\r\n        }\r\n      }\r\n    }\r\n    return nr;\r\n  }\r\n==\r\n\r\nPutem incerca o optimizare de memorie, pentru ca nu mai avem nevoie de elementele cu index par din sirul {$p$}. Acum semnificatia lui $p{~i~}$ s-a schimbat $p{~i~}$ fiind 0 daca $2*i+1$ e numar prim si $1$ daca nu.\r\n\r\n== code(java) | \r\n  // class PrimeNumbersSieve3 \r\n  final int MAXSIZE = 1000000/2+1;\r\n  char[] p = new char[MAXSIZE];\r\n\r\n  //p[i] == 0 if 2*i + 1 is prime\r\n  \r\n  public int getTheNumber(int n) {\r\n    int i, j, nr = 1;\r\n    for (i = 1; (i << 1) + 1 <= n; i += 1) {\r\n      if (p[i] == 0) {\r\n        nr++;\r\n        for (j = i + i + i + 1; (j << 1) + 1 <= n; j += (i << 1) + 1) {\r\n          p[j] = 1;\r\n        }\r\n      }\r\n    }\r\n    return nr;\r\n  }\r\n==\r\n\r\nUrmatoarea optimizare va fi marcarea multiplilor numarului prim $i$ de la $i*i$ nu de la $2*i$ cum am facut in prima varianta sau de la $3*i$ cum am facut in a {$2$}-a. Aceasta optimizare este evidenta: orice numar prim compus multiplu de $i$ mai mic decat $i*i$ are un factor prim mai mic decat {$i$}, si acel factor l-a marcat mai devreme, deci nu are rost sa il marcam si la pasul {$i$}. Ideea aceasta este exact ideea ce se foloseste la rezolvarea problemei \"Numere Prime\":http://www.infoarena.ro/task/prim din arhiva infoarena. Sa vedem acum codul sursa:\r\n\r\n== code(java) | \r\n  //class PrimeNumbersSieve4 \r\n  final int MAXSIZE = 1000000/2+1;\r\n  char[] p = new char[MAXSIZE];\r\n\r\n  //p[i] == 0 if 2*i + 1 is prime\r\n  \r\n  public int getTheNumber(int n) {\r\n    int i, j, nr = 1;\r\n    for (i = 1; ((i * i) << 1) + (i << 1) <= n; i += 1) {\r\n      if (p[i] == 0) {\r\n        for (j = ((i * i) << 1) + (i << 1); (j << 1) + 1 <= n; j += (i << 1) + 1) {\r\n          p[j] = 1;\r\n        }\r\n      }\r\n    }\r\n    for (i=1; 2 * i + 1 <= n; ++i) \r\n        if (p[i] == 0) nr++;\r\n    return nr;\r\n  }\r\n==\r\n\r\nCodul sursa arata putin urat pentru ca nu lucram direct cu $i$ ci cu {$2*i+1$}, am mai facut optimizarea ce apare si in \"mathworld\":http://mathworld.wolfram.com/, nu parcurgem numerele pana la $n$ pentru marcarea multiplilor ci pana la $sqrt(n)$ lucru care e evident dupa cele explicate mai sus.\r\n\r\nUltima imbunatatire care o vom aduce este aceea de a folosi mai putina memorie. Cum pentru fiecare numar e necesara doar o informatie booleana, aceasta o putem tine intr-un bit, nu este necesar un char intreg. Sa vedem cum arata codul:\r\n\r\n== code(java) | \r\n  //class PrimeNumbersSieve5 \r\n  final int MAXSIZE = 100000000/2/8+1;\r\n  char[] p = new char[MAXSIZE];\r\n\r\n  //p[i] == 0 if 2*i + 1 is prime\r\n  \r\n  public int getTheNumber(int n) {\r\n    int i, j, nr = 1;\r\n    for (i = 1; ((i * i) << 1) + (i << 1) <= n; i += 1) {      \r\n      if ((p[i >> 3] & (1 << (i & 7))) == 0) {\r\n        for (j = ((i * i) << 1) + (i << 1); (j << 1) + 1 <= n; j += (i << 1) + 1) {\r\n          p[j >> 3] |= (1 << (j & 7));\r\n        }\r\n      }\r\n    }\r\n    for (i = 1; 2 * i + 1 <= n; ++i)  \r\n         if ((p[i >> 3] & (1 << (i & 7))) == 0) \r\n             nr++;\r\n    return nr;\r\n  }\r\n==\r\n\r\nCodul {@p[i >> 3] & (1 << (i & 7)) @}&#0061;&#0061;{@ 0@} testeaza daca al {@i@}-lea bit din sirul de biti e $0$ (deci daca {@2*i+1@} e prim). {@i >> 3@} e echivalent cu {@i / 8@} deci se gaseste pt bitul al {@i@}-lea in ce char e el stocat din sirul nostru de charuri. {@i & 7@} e echivalent cu {@i % 8@} ca sa aflam pe ce bit al charului e stocat numarul prim {@i@}.\r\n\r\nCodul {@p[j >> 3] |= (1 << (j & 7))@} seteaza bitul {@j % 8@} al charului {@j / 8@} in {@1@}, pentru ca sa stim ca numarul {@2 * j + 1@} nu e prim.\r\n\r\nUltima varianta arata destul de urat fata de prima, sa vedem daca s-a meritat efortul. Urmatoarele date sunt obtinute pe un procesor Athlon XP la 1.8 Ghz:\r\n\r\n* 10 runs of {@BruteForcePrimes().method1(1000000)@} lasted: 24.956 seconds\r\n* 10 runs of {@PrimeNumbersSieve1().getTheNumber(1000000)@} lasted: 3.024 seconds\r\n* 10 runs of {@PrimeNumbersSieve2().getTheNumber(1000000)@} lasted: 1.842 seconds\r\n* 10 runs of {@PrimeNumbersSieve3().getTheNumber(1000000)@} lasted: 1.422 seconds\r\n* 10 runs of {@PrimeNumbersSieve4().getTheNumber(1000000)@} lasted: 0.971 seconds\r\n* 10 runs of {@PrimeNumbersSieve5().getTheNumber(1000000)@} lasted: 0.22 seconds\r\n\r\nCodul folosit pentru testare e:\r\n\r\n== code(java) | \r\n  public static void main(String[] arg) {\r\n    double tick = System.currentTimeMillis();\r\n    for (int i = 0; i < 10; ++i) {\r\n      System.out.println(\"Run \" + i \r\n    + \" result: \"+\r\n      new PrimeNumbersSieve1().\r\n      getTheNumber(1000000));\r\n    }\r\n    System.out.println(\" 10 runs of \"\r\n  + \"PrimeNumbersSieve1().\" \r\n  + \"getTheNumber(1000000) \" \r\n  + \"lasted: \" \r\n  + (System.currentTimeMillis() \r\n  - tick) \r\n  * 1e-3 + \" seconds\");\r\n  }\r\n==\r\n\r\nS-a rulat fiecare cod de $10$ ori pentru a da ocazia optimizarilor Just In Time din java sa isi faca treaba.\r\n\r\nSe pare ca optimizarile codului initial au dus la o imbunatatire a vitezei cu un factor de {$10$}.\r\n\r\nProblemele sugerate la inceputul articolului sunt destul de frumoase si ar trebui rezolvate. Pentru fiecare dintre ele puteti sa va testati rezolvarea: la algoritmus sunt disponibile fisierele de intrare si iesire, infoarena si uva au evaluatoare automate si pentru problema de pe \"TOPCODER\":http://www.topcoder.com/tc puteti intra in applet-ul lor si sa incercati sa o rezolvati in practice roomul asociat SRM-ului 190 dupa ce o rezolvati folositi optiunea Run System Test din Practice Room Options.\r\n\r\n',1,'public'),('stl','STL','2006-11-22 02:17:09','h1. STL\r\n\r\n(Categoria _Limbaje_, autor(i) _Radu Grigore_)\r\n\r\nBiblioteca standard C++ are doua componente mari: \"standard template library\" (STL) si stream-uri de intrare/iesire. Acest articol prezinta un subset al STL pe care il folosesc adesea in practica.\r\n\r\nh2. Introducere\r\n\r\nSTL se bazeaza pe trei concepte centrale: containeri, iteratori si algoritmi. Ca tehnica de programare folosita e bine sa stiti ca orientarea pe obiecte aproape ca lipseste. In schimb se utilizeaza din plin polimorfismul parametric. In C++ numele acestuia este \"template\"; in C# si Java se obisnuieste sa se spuna \"generice\".\r\n\r\nIn continuare voi presupune ca sunteti familiari cu utilizarea template-urilor si cunoasteti bine limbajul C. Codul folosit presupune ca la inceputul fisierului exista:\r\n\r\n== code(cpp) |#include <iostream>\r\n#include <deque>\r\n#include <list>\r\n#include <vector>\r\n#include <set>\r\n#include <map>\r\n#include <iterator>\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <string>\r\nusing namespace std;\r\n==\r\n\r\nh2. Containeri\r\n\r\nIn limbajul de baza avem la dispozitie tablourile pentru reprezentarea unei secvente indexate de elemente. Dimensiunea unui tablou trebuie fie sa fie cunoscuta la compilare, fie sa fie gestionata explicit de programator prin alocare dinamica. Principalul avantaj al STL este ca ne scapa de aceasta grija. In afara de adresarea indexata obisnuita secventele STL au si operatia {$push_back$}: adauga un element la sfarsit (si, evident, creste dimensiunea cu {$1$}). Exista si operatia inversa {$pop_back$}: elimina ultimul element. Cele trei secvente STL care suporta aceste operatii sunt {$vector$}, $deque$ si {$list$}. Un exemplu de utilizare este:\r\n\r\n== code(cpp) |// v are 10 elemente egale cu 0\r\nvector<int> v(10);\r\n// acces indexat\r\nv[1] = 2; cout << v[0] << endl;\r\nv.push_back(3); cout << v[10] << endl;\r\nv.pop_back();\r\n==\r\n\r\nCele trei secvente difera prin implementare. Pe scurt, $vector$ tine datele intr-o zona continua de memorie, $list$ este o lista dublu inlantuita a elementelor, iar $deque$ este ceva intre: o lista inlantuita de pachete continue. (deque vine de la \"double ended queue\" dar se pronunta \"deck\" -- pachet tocmai pentru a sugera implementarea)\r\n\r\nEste util sa stim in mare care e implementarea pentru a alege secventa in functie de operatiile pe care le avem de facut si de frecventa lor. De exemplu $vector$ are cel mai rapid acces indexat; pe de alta parte adaugarea unui element poate duce la copierea intregului continut daca nu mai exista memorie rezervata la coada (adica {$v.capacity() == v.size()$}). Lista este rapida pentru inserari de elemente in interior dar este lenta pentru accesele indexate. $Deque$ este mai eficienta decat $vector$ daca se fac multe operatii $push_back$ dar este ceva mai lenta pentru accese indexate uzuale. In plus mai exista si o diferenta de interfata. Atat $deque$ cat si $list$ ofera in plus fata de vector operatiile $push_front$ si {$pop_front$}. Aceasta deoarece in cazul vectorilor ele ar fi avut complexitatea $O(n)$ daca se dorea pastrarea rapiditatii accesului indexat.\r\n\r\nSa vedem o implementare de jucarie a unei cozi cu ajutorul $deque$ pentru a mai ilustra cateva functii membre.\r\n\r\n== code(cpp) |template <typename T>\r\nclass Queue\r\n{\r\n    private:\r\n        deque<T> data;\r\n    public:\r\n        void Push(const T& el)\r\n        {\r\n            data.push_back(el);\r\n        }\r\n        T Pop()\r\n        {\r\n            assert(!data.empty());\r\n            T result(data.front());\r\n            data.pop_front();\r\n            return result;\r\n        }\r\n};\r\n==\r\n\r\nInteresant este ca STL are deja astfel de adaptori ale secventelor simple: {$stack$}, $queue$ si {$priority_queue$}. Metodele uzuale sunt {$pop$}, $push$ si {$top$}; $push$ si $pop$ au semantica uzuala iar $top$ intoarce o referinta la elementul care va fi inlaturat de urmatorul {$pop$}. In plus se mai poate testa daca containerul e gol cu {$empty$}. Voi da un exemplu de utilizare a {$priority_queue$}:\r\n\r\n== code(cpp) |priority_queue<int> pq;\r\npq.push(3);\r\npq.push(4);\r\npq.push(1);\r\ncout << pq.top() << endl; pq.pop(); // scrie 4\r\ncout << pq.top() << endl; pq.pop(); // scrie 3\r\ncout << pq.top() << endl; pq.pop(); // scrie 1\r\ncout << pq.empty() << endl; // scrie 1 (=true)\r\n==\r\n\r\nDesigur, putem redefini operatorul \"mai mic\" daca dorim o ordonare diferita. De exemplu putem afla cel mai apropiat punct de ({$0, 0, 0$}) astfel:\r\n\r\n== code(cpp) |struct Point {\r\n    int x, y, z;\r\n    bool operator < (const Point& o) const {\r\n        return x*x+y*y+z*z > o.x*o.x+o.y*o.y+o.z*o.z;\r\n    }\r\n};\r\npriority_queue<Point> pq;\r\n==\r\n\r\nIntrucat operatiunile de extindere/micsorare la capete sunt uzuale pentru adaptorii stack/queue acestia folosesc in mod obisnuit drept container un deque. Iar o coada de prioritati este implementata cu heap-uri asa incat rapiditatea accesului indexat este importanta si vector-ul este alegerea default. Aceste alegeri pot fi insa configurate. De exemplu daca aveti o coada de prioritati in care stiti ca veti introduce foarte multe elemente si veti extrage doar cateva ar fi poate mai bine sa folositi:\r\n\r\n== code(cpp) |\r\npriority_queue<int, deque<int> > pq;\r\n==\r\n\r\nCam atat despre secvente. Celalalt tip important de containeri sunt containerii asociativi: $map$ si $set$ (mai exista $multimap$ si $multiset$ dar nu voi vorbi despre ei). Primul este o multime de perechi (cheie, valoare) ce pot fi regasite rapid dupa cheie, care este unica. Implementarea este cu arbori rosu-negru asa incat timpul de inserare si cel de cautare este {$O(lg n)$}. O utilizare tipica pentru $map$ este:\r\n\r\n== code(cpp) |map<string, int> name_to_phone;\r\nname_to_phone[\"Ion Ion\"] = 8234783;\r\nname_to_phone[\"Me\"] = 8237462;\r\ncout << name_to_phone[\"Ion Ion\"] << endl;\r\n==\r\n\r\nPentru un set utilizarea uzuala este:\r\n\r\n== code(cpp) |set<string> s;\r\ns.insert(\"Ion ion\");\r\ns.insert(\"baubau\");\r\n// scrie 0=false\r\ncout << (s.find(\"Gica\") != s.end()) << endl;\r\n// scrie 1=true\r\ncout << (s.find(\"baubau\") != s.end()) << endl;\r\n==\r\n\r\nPentru a se putea construi un arbore de cautare pentru chei de tipul $T$ atat $set$ cat si $map$ necesita ca $less<T>$ sa fie bine definit. Daca nu oferiti voi o specializare a template-ului, cea generica apeleaza operatorul {$<$}. Cu alte cuvinte cu exceptia unor situatii deosebite ce probabil nu apar intr-un concurs e ok de retinut ca trebuie sa fie definit operatorul {$<$}.\r\n\r\nUn map este foarte util pentru a memoiza o functie recursiva.\r\n\r\n== code(cpp) |template <typename T, typename U>\r\nU my_func(T t)\r\n{\r\n    // se autoapeleaza\r\n    // nu are \"side-effects\"\r\n    return result;\r\n}\r\n==\r\n\r\nSe transforma in:\r\n\r\n== code(cpp) |map<T, U> cache;\r\ntemplate <typename T, U>\r\n\r\nU my_func(T t)\r\n{\r\n    map<T, U>::const_iterator it =  cache.find(t);\r\n    if (it != cache.end()) return *it;\r\n    // corpul vechi\r\n    return cache[t] = result;\r\n}\r\n==\r\n\r\nTransformarea e automata si se face foarte usor. In multe cazuri plusul de viteza este suficient si nu e nevoie ca tot codul sa fie transformat in varianta programare dinamica. In plus solutia de mai sus merge si atunci cand $t$ poate avea valori foarte mari sau nu este un intreg (de exemplu e o structura, un string, etc.) si deci trecerea la programare dinamica n-ar fi evidenta si ar lua ceva timp de gasit o solutie.\r\n\r\nExemplul de mai sus foloseste o functie template numai pentru a sugera ca acolo pot fi orice tipuri (nu doar intregi). In practica template-urile mai mult se folosesc decat se scriu.\r\n\r\nSa trecem acum la iteratori.\r\n\r\nh2. Iteratori\r\n\r\nGanditiva la algoritmul de gasire a maximului. El nu depinde de implementarea folosita pentru reprezentarea multimii! Tot ceea ce trebuie sa faci este sa accesezi toate elementele.. nici macar nu conteaza ordinea. Ei bine iteratorii permit o astfel de decuplare intre structurile de date si algoritmi.\r\n\r\nExemplu:\r\n\r\n== code(cpp) |template <typename T>\r\ntypename T::value_type max(\r\n        typename T::const_iterator begin,\r\n        typename T::const_iterator end)\r\n{\r\n        assert (begin != end); // container empty\r\n            typename T::const_iterator it;\r\n                typename T::value_type r = *begin;\r\n                    for (it = begin; it != end; ++it)\r\n                                if (*it > r) r = *it;\r\n                        return r;\r\n}\r\n\r\n==\r\n\r\nObservati ca sintaxa pentru iteratori seamana mult cu sintaxa pentru pointeri. Iteratorii din C++ sunt analogul enumeratorilor din C# si Java, doar ca sunt mai flexibili. Operatile care se pot face cu ei sunt: \"treci la urmatorul element\" {$(++it)$}, \"treci la elementul anterior\" {$(--it)$}, \"da-mi o referinta la elementul catre care arati\" $(*it)$ si compararea ({$it_a == it_b$}, {$it_a != it_b$}). Unii iteratori pot in plus sa se deplaseze cu $n$ pozitii ({$it += n$}, {$it -= n$}).\r\n\r\nCodul de mai sus poate fi utilizat pentru oricare dintre cele trei secvente prezentate anterior astfel:\r\n\r\n== code(cpp) |#define ALL(c) (c).begin(), (c).end()\r\ndeque<int> d;\r\nvector<int> v;\r\n// ... some work ..\r\ncout << max(ALL(d)) << endl;\r\ncout << max(ALL(v)) << endl;\r\n==\r\n\r\nh2. Algoritmi\r\n\r\nDupa cum vedeti utilizarea functiei max este simpla, mai complicata este definitia. Din fericire header-ul {@<@}{$algorithm$}{@>@} are deja scrise tot felul de astfel de functii dragute. Una de care s-ar putea sa va indragostiti :) este {$next_permutation$}. Ia primeste ca parametrii limitele unei secvente (ca mai sus) si transforma acea secventa in urmatoarea permutare in ordine lexicografica si intoarce true, sau intoarce false daca ordonarea este deja ultima. Iata cum se foloseste:\r\n\r\n== code(cpp) |string handle(\"rgrig\");\r\nsort(ALL(handle)); // alta functie draguta\r\ndo {\r\n    cout << handle << endl;\r\n\r\n} while (next_permutation(ALL(handle));\r\n==\r\n\r\nCodul de mai sus ilustreaza o alta functie utila: {$sort$}. In exemplul urmator vom vedea cum poate fi folosita $next_permutation$ pentru a genera toate combinarile de $n$ elemente luate cate {$k$}.\r\n\r\n== code(cpp) |vector<int> choose(n);\r\nfor (int i = n-k; i < n; ++i)\r\nchoose[i] = 1;\r\ndo {\r\n    // .. foloseste choose ..\r\n} next_permutation(ALL(choose));\r\n==\r\n\r\nAm utilizat un vector de intregi si nu unul de booleeni asa cum ar dicta \"spiritul\" C++ pentru ca secventa vector are o specializare pentru tipul bool si impacheteaza cate $32$ de elemente intr-un intreg nativ. Asta are tot felul de efecte neplacute printre care scaderea vitezei. Exista si un efect \"placut\" dar util probabil in conjuncturi speciale: ocupa mai putin spatiu.\r\n\r\nO alta functie interesanta este {$copy$}. Pe aceasta o putem folosi pentru a concatena doua secvente sau pentru a tipari continutul unei secvente.\r\n\r\n== code(cpp) |vector<int> a, b;\r\n// .. pune niste valori in a si b ..\r\n// pune tot continutul lui b la sfarsitul lui a\r\ncopy(ALL(b), back_inserter(a));\r\n// tipareste continutul lui a\r\ncopy(ALL(a), ostream_iterator<int>(cout, \", \"));\r\n==\r\n\r\nO functie utila pentru prelucrarea sirurilor inainte de parsare este {$replace$}. De exemplu pentru a inlocui toate virgulele cu spatii intr-un sir se procedeaza astfel:\r\n\r\n== code(cpp) |string s(\"a,b,c,d\");\r\nreplace(ALL(s), \',\', \' \');\r\n==\r\n\r\nDaca doriti sa cautati o sub-secventa intr-o secventa mai mare atunci puteti folosi {$search$}. Acesta intoarce un iterator care arata la locul unde s-a gasit sub-secventa sau \"end\" in caz contrar. De exemplu, pentru a gasi toate aparitiile unui cuvant intr-un sir putem scrie:\r\n\r\n== code(cpp) |// un deque e mai eficient decat string pt. texte lungi\r\ndeque<char> text;\r\nstring word;\r\n// .. pune niste valori in text si word ..\r\ndeque<char>::iterator it = text.begin();\r\nint c = 0;\r\nwhile (\r\n\r\n        (it = search(it, text.end(), ALL(word))) != text.end()) {\r\n    ++c; ++it;\r\n}\r\n// c contine numarul de aparitii al lui word in text\r\n==\r\n\r\nAtentie: complexitatea functiei $search$ este $O(mn)$ asa incat uneori va trebui sa faceti totusi cautarea de mana.\r\n\r\nPentru a numara de cate ori apare un element intr-o secventa putem utiliza functia {$count$}.\r\n\r\n== code(cpp) |#define ALLARRAY(a) (a), ((a) + sizeof(a)/sizeof(a[0]))\r\nint av[] = {1, 2, 3, 1, 2, 3, 1};\r\n// un mod de a pune date in v\r\nvector<int> v(ALLARRAY(av));\r\ncout << count(ALL(v), 1) << endl; // prints 3\r\nif (!count(ALL(v), 4))\r\n    cout << \"v nu contine 4\" << endl;\r\n==\r\n\r\nDaca vrem sa stim numai daca un element apare sau nu intro secventa o varianta ce se poate dovedi mai rapida in situatii foarte particulare este sa folosim {$find$}.\r\n\r\n== code(cpp) |if (find(ALL(v), 4) == v.end())\r\n    cout << \"v nu contine 4\" << endl;\r\n==\r\n\r\nIn sfarsit, o ultima functie interesanta ce lucreaza pe secvente este {$reverse$}. Utilizare tipica:\r\n\r\n== code(cpp) |int av[] = {1, 1, 2, 1};\r\nvector<int> v(ALLARRAY(av));\r\nreverse(ALL(v)); // acum v contine 1, 2, 1, 1\r\n==\r\n\r\nAlte mici utilitare care operaza cu valori normale (nu containeri) sunt: {$max$}, {$min$}, {$swap$}. Semantica este probabil evidenta din nume, dar voi da totusi un exemplu de utilizare:\r\n\r\n== code(cpp) |int a = 2, b = 1;\r\nint m = min(a, b);\r\nint M = max(a, b);\r\nswap(m, M);\r\ncout << M << \" \" << m << endl; // prints \"1 2\"\r\n==\r\n\r\nh2. Concluzie si referinte\r\n\r\nCe am prezentat in acest articol reprezinta o portiune reprezentativa a STL, dar este totusi doar o portiune. Am preferat sa dau multe exemple simple in locul unor explicatii mai teoretice. Uneori mi-a fost tare greu sa ma abtin :) de exemplu sa nu povestesc mai in detaliu cum e gestionata implicit zona de memorie \"rezervata\" si de ce...\r\n\r\nPentru mai multe detalii puteti fie sa consultati o referinta electronica, fie sa luati cartea lui Bjarne Stroustrup \"Limbajul C++\" aparuta la teora. Vezi si:\r\n\r\n# \"O alta prezentare introductiva\":http://www.topcoder.com/index?t=features&c=feat_082803\r\n# \"Referinta SGI\":http://www.sgi.com/tech/stl/\r\n# \"Referinta Dinkumware\":http://www.dinkumware.com/refxcpp.html\r\n# \"Standardul\":http://www.csci.csusb.edu/dick/c++std/cd2/\r\n\r\n',1,'public'),('problema/parcare','Parcare','2006-11-22 02:49:40','==Include(page=\"template/taskheader\" task_id=\"parcare\")==\r\n\r\nPentru a face rost de bani, Cezar s-a angajat, pe perioada verii ca administrator al unei parcari. Parcarea este un patrat format din blocuri de beton, de asemenea patrate, cu latura de un metru. Parcarea are o singura iesire pe latura dinspre nord, in rest este inconjurata de ziduri pe care masinile nu le pot depasi. Masinile din parcare sunt dreptunghiuri cu latimea de $1m$ si lungimea mai mare sau egala cu $2m$. Ele sunt orientate nord-sud sau est-vest. Atunci cand s-a angajat, Cezar nu credea ca aceasta slujba ii va crea probleme, dar astazi este intr-o situatie delicata : un client i-a cerut sa-i scoata masina din parcare. Cezar are cheile de la toate masinile, dar nu este un sofer foarte bun : el nu poate lua viraje, poate merge doar inainte si in marsarier. A incercat timp de o ora sa scoata masina din parcare, dar nu a reusit si s-a gandit sa apeleze la ajutorul vostru. El a facut o harta a parcarii : a reprezentat cu $`.\'$ portiunile de asfalt, cu $`#\'$ zidurile parcarii si cu litere mari consecutive ale alfabetului latin masinile. Masina care trebuie scoasa din parcare a reprezentat-o cu $`A\'$.\r\n\r\nh2. Cerinta\r\n\r\nEl va roaga sa-i scrieti un program care sa scoata masina din parcare in mai putin de $100$ miscari. El considera o miscare mutarea unei masini, intr-o anumita directie, cu un numar intreg de metri.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $parcare.in$ se afla un numar intreg $N$ reprezentand dimensiunea hartii. Pe urmatoarele $N$ linii se afla cate $N$ caractere reprezentand codificarea hartii.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului $parcare.out$ se va afla numarul de miscari $M$ prin care a fost rezolvata problema. Pe urmatoarele $M$ linii se vor afla $3$ caractere ce reprezinta o mutare. Primul reprezinta litera asociata masinii ce va fi mutata, al doilea directia in care va fi mutata ({$N$}- nord, $S$-sud, $E$-est, $V$-vest), iar al treilea numarul de blocuri cu care va fi mutata. In locul miscarii prin care masina $`A\'$ paraseste parcarea se va afisa $`Exit\'$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $7 &le; N &le; 9$\r\n* Sunt maxim $10$ masini in parcare.\r\n* Pe a doua linie a fisierului de intrare se va gasi un caracter $`.\'$ (iesirea)\r\n* Daca o masina are o anumita litera a alfabetului atunci exista exact o masina atribuita fiecarei litere mai mici decat litera respectiva.\r\n* Nu exista doua masini cu aceeasi litera.\r\n* Este imposibil ca alta masina sa poata parasi parcarea inaintea masinii $`A\'$\r\n* Se garanteaza existenta unei solutii.\r\n* Orice solutie cu mai putin $100$ miscari va primi punctajul maxim.\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. parcare.in |_. parcare.out |\r\n| 8\r\n  ###.####\r\n  #..BBBC#\r\n  #..A..C#\r\n  #..A..C#\r\n  #.....C#\r\n  #.....C#\r\n  #......#\r\n  ########\r\n| 3\r\n  CS1\r\n  BE1\r\n  Exit |\r\n| 8\r\n  ###.####\r\n  #HHH.G.#\r\n  #....GF#\r\n  #.EEE.F#\r\n  #..A..F#\r\n  #B.A...#\r\n  #BCCCDD#\r\n  ########\r\n| 8\r\n  BN1\r\n  CV1\r\n  DV1\r\n  FS2\r\n  GS3\r\n  EE2\r\n  HE3\r\n  Exit |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"parcare\")==',1,'task: parcare'),('djgpp-instalarea-de-la-a-la-z','DJGPP - instalarea de la A la Z','2006-12-14 18:14:40','h1. DJGPP - instalarea de la A la Z\r\n\r\n(Categoria _Diverse_, autor _Aursulesei Tudor_)\r\n\r\nProbabil ca ai auzit de puternicul compilator $Gnu C$. Este acela folosit pe la mai toate competitiile mai mari de nationala (inclusiv). Avantaje:\r\n\r\n* lucreaza pe 32 de biti; asta inseamna ca programele compilate cu el vor merge mult mai repede!\r\n* stiva mai mare &#8658; erorile gen $stack overflow$ vor apare mult mai rar.\r\n* memorie mai mare &#8658; @long x[10000000]@ chiar exista\r\n\r\nAcest ghid este valabil pentru $Windows XP$.\r\nInainte sa incepem, trebuie sa raspundem la cateva intrebari:\r\n\r\nh2. Ce este DJGPP?\r\n\r\nO colectie de programe de $UNIX$ portate pentru $DOS$. Vizitati \"http://delorie.com/djgpp\":http://delorie.com/djgpp pentru detalii. Cel mai important, dupa ce veti instala corect $DJGPP$, veti putea scrie din linia de comanda in $DOS$ comenzi gen $gcc test.c *o test.exe$.\r\n\r\nh2. Ce este RHIDE?\r\n\r\nEste un $IDE (Integrated Development Environment)$ pentru $DJGPP$. Deosebit de puternic si seamana cu $Borland C 3.1$ la culoare ${:)}$. Se impaca de minune cu $GCC$! Important; ${NU}$ vom folosi versiunea de ${RHIDE}$ pe care ne-o ofera ${DJGPP}$, ci vom folosi una mai noua, dezvoltata de \"SET\":http://setedit.sourceforge.net. Are propriul lui editor, $Setedit$, dar a dezvoltat si $RHIDE$, eliminand o parte din buguri.\r\n\r\nVersiunea lui se gaseste la \"http://sourceforge.net/project/showfiles.php?group_id=32835\":http://sourceforge.net/project/showfiles.php?group_id=32835 , sectiunea extra! Recomand sa o luati acum: $pachetul RHIDE 1.5 + Ed 0.5.4 + gdb 6.1.1$ \r\n\r\nh2. Sa incepem\r\n\r\nAccesam link-ul \"http://www.delorie.com/djgpp/zip-picker.html\":http://www.delorie.com/djgpp/zip-picker.html si alegem optiunile (pe rand)\r\n\r\n* Build and run programs with DJGPP\r\n* Windows 2000/XP\r\n* Yes\r\n* C si C++\r\n\r\nLa $Integrated Development Environments and Tools$ aveti grija sa nu fie selectat $RHIDE$ (dupa cum am zis si mai sus, vom folosi o alta versiune).\r\n\r\nDe asemenea, alegem $No$ la Optiunea $Would you like GDB?$ Contiunam cu $Tell me which files I need$\r\n\r\nAr trebui sa obtinem urmatoarea lista:\r\n\r\n* unzip32.exe to unzip the zip files 95kb\r\n* v2/copying.dj Copyright info 3kb\r\n* v2/djdev203.zip Basic Development Kit 1.5mb\r\n* v2/faq230b.zip F.A.Q. 664kb\r\n* v2/readme.1st Installation instructions 22kb\r\n* v2gnu/bnu2161b.zip Basic assembler, linker 3.3mb\r\n* v2gnu/gcc401b.zip Basic GCC compiler 4.0mb\r\n* v2gnu/gdb611b.zip GNU debugger 1.5mb\r\n* v2gnu/gpp401b.zip C++ compiler 4.4mb\r\n* v2gnu/mak3791b.zip Make (processes makefiles)267b\r\n* v2gnu/txi48b.zip Info file viewer 779kb\r\n\r\nDownloadati-le!\r\n\r\nIncercati sa le puneti pe toate intr-un director gen $c:\\djgpp\\$ (de altfel, pe acesta il folosesc eu si vi-l recomand). Deschideti o fereastra de $Explorer$ si faceti drag-n-drop la fiecare arhiva peste executabilul $unzip32.exe$. Ar trebui sa va apara directoare gen $bin$ si $include$. Sa nu uitam de versiunea de $RHIDE$ pe care am mentionat-o mai sus. Despachetati-o si pe aceasta in acelasi mod!\r\n\r\nVom contiuna cu setarea variabilei de mediu $DJGPP$. (foarte important)\r\nClick dreapta pe $My Computer &#8594; Properties &#8594; Advanced &#8594; Environment Variables$.\r\nEditati variabila $PATH$ astfel incat aceasta sa arate si spre calea $C:\\DJGPP\\BIN$. De asemenea, creeati o variabila noua numita $DJGPP$ care sa \"pointeze\" catre $C:\\DJGPP\\DJGPP.ENV$.\r\n\r\nRecomand creerea unui fisier batch care sa lanseze $RHIDE$. Va prezint un exemplu:\r\n\r\n== code(c) |@echo off\r\nset PATH=c:/djgpp/bin;%PATH%\r\nset DJGPP=c:/djgpp/djgpp.env\r\nchdir c:/djgpp/lucru\r\nc:/djgpp/bin/rhide.exe\r\n==\r\n\r\nRulati batch-ul. Ar trebui $sa nu dati$ de o eroare care zice ceva de variabila $PATH$ pusa gresit sau de variabila $DJGPP$. Daca va apare, cititi fisierul $readme.1st$ (deschideti-l cu $Word$, nu cu $Notepad$) . Daca nu aveti nici o eroare, ar trebui sa fiti intampinati de o fereastra in care se zice ceva de $Robert Hohne (RH din RHIDE) si Salvador Eduardo Tropea (omul care a imbunatatit RHIDE)$. Creeati un fisier nou in care sa bagati cateva linii de test.\r\n\r\n== code(c) |#include <stdio.h>\r\nint main()\r\n{\r\n    printf(\"%d %d %d\" , 1, 2, 3);\r\n    return 0;\r\n}\r\n==\r\n\r\n$Ctrl+F9$ ca sa compilati. $Ctrl+F2$ reset la program. $Shift + F4 $ruleaza pana la linia la care se afla cursorul. $Shift+F8$ e $Step Over$ fara sa se schimbe modul monitorului (fara flick la monitor). $Shift+F7$ e $Run Into$ fara sa se schimbe modul monitorului. $Shift+F2$ e $GREP$ (utilitar UNIX portat). $Alt + F5$ arata rezultatul rularii programului (in versiunea de $RHIDE$ de pe $DJGPP$, nu prea mergea aceasta functie). Recomand optiunile din $Options &#8594; Environment &#8594; Preferences$.\r\n\r\n* Screen Mode 80 x 50\r\n* Syntax highlighting\r\n\r\nIar tot din $Options &#8594; Environment &#8594; Editor &#8594; Editor Options$\r\n\r\n* Autoindent\r\n* Use Tabs\r\n* Intelligent C indent\r\n* Match pair on the fly\r\n\r\n...Si altele , pe care va las sa le descoperiti singuri.\r\n\r\nAvertizare. Desi aceasta versiune de $RHIDE$ este mai stabila decat cea de pe $DJGPP$, este sansa sa se prabuseasca la $Debugging$ ceva mai complex (crash ${:)}$). Nimic nu este perfect. Eu am renuntat la orice alt $IDE$, deoarece $RHIDE$ e cel mai bun. Daca o sa te deranjeze crash-urile, ramai la $Borland C$. Nu este greu sa te inveti cu toate capriciile acestui program care te forteaza sa salvezi din 15 in 15 secunde, lucru benefic de alt fel. Dupa ce va obisnuiti, crash-urile vor ramane o amintire neplacuta!\r\n\r\nAmintiti-va totusi sa salvati cat mai des si sa nu urmariti evolutia unor variabile prea mari gen @x[10000000]@ ${:)}$. De asemenea nu incercati sa afisati pe ecran si sa vedeti ce rezultat a iesit cu $Alt+F5$. S-ar putea sa nu mearga. Daca aveti probleme $MARI$ cu programul, stergeti\r\n\r\n* rh_opt.gpr\r\n* rh_opt.gdt\r\n\r\nAsta o sa il faca ca nou, in caz ca refuza sa porneasca sau e mai instabil decat era cand l-ati instalat.\r\n\r\nRecomand de asemenea sa explorati fiecare meniu si scurtatura a programului, deoarece eu v-am prezentat sumar aproximativ $30%$ din functii si $30%$ din optiunile lui optime de functionare! Insist sa verificati sistematic si metodic optiunile; Nu o sa regretati! De asemenea, poate lucra cu $FPC (Free Pascal Compiler)$ , insa va recomand $IDE$-ul din $Free Pascal$. Este o opera de arta pentru pascalisti!\r\n',332,'public'),('doua-probleme-de-la-runda-6-a-concursului-algoritmus','Doua probleme de la runda 6 a concursului Algoritmus','2006-11-22 02:18:26','h1. Doua probleme de la runda 6 a concursului Algoritmus\r\n\r\n(Categoria _Competitii_, autor(i) _Cosmin_)\r\n\r\nDupa incheierea brusca a concursului Algoritmus, ideile de rezolvare ale rundei 6 nu au mai aparut pe site. In acest articol va voi prezenta ideile de rezolvare la problemele la care eu am realizat solutiile oficiale.\r\n\r\nh2. Problema 1: Suprafata\r\n\r\nPentru a rezolva problema folosim paradigma liniei de baleiere folosita mult in rezolvarea problemelor de geometrie computationala (vezi si articolul arbori de intervale din sectiunea download pt alte exemple de probleme in care se foloseste linia de baleiere). Vom considera ca puncte eveniment toate punctele de intersectie intre oricare doua cercuri si punctele de $y maxim$ si de $y minim$ pentru un cerc. Noi avem nevoie numai de coordonata $y$ a acestor puncte pe care o punem intr-un sir. Sortam acest sir ce are maxim $n*(n-1) + 2*n$ coordonate distincte ( $n*(n-1)$ provin din intersectii a cate doua cercuri iar celelalte $2*n$ din $y maxim$ si $y minim$ pentru fiecare cerc). Intre doua coordonate $Y$ consecutive din vectorul sortat nu exista nici o intersectie intre cercuri. Intersectia unui cerc cu o banda determinata de $Y{~i~}$ si $Y{~i+1~}$ este un fel de trapez curbat pe care ni-l putem imagina ca o paranteza deschisa si una inchisa. Pentru a determina aria intersectiei multimii de cercuri cu banda determinata de $Y{~i~}$ si $Y{~i+1~}$ putem sa facem un algoritm care sorteaza intai \"parantezele\" si dupa aceea parcurge sirul sortat al parantezelor. Cand nivelul de imbricare e $0$ inseamna ca tocmai am iesit din cercuri iar nivel de imbricare mai mare ca $0$ inseamna ca suntem in interiorul intersectiei. De aici scoatem un algoritm liniar care ne determina intersectia cercurilor cu aceasta banda. Pentru a determina aria ocupata de un trapez curbat trebuie sa putem determina aria dintre coarda si arcul de cerc corespunzator, aceasta arie se poate gasi daca stim unghiul $alfa$ ce se opune coardei pentru ca aceasta arie e diferenta dintre aria sectorului de cerc ( {$r*r*alpha/2$}) si aria triunghiului format dintre centrul cercului si coarda ({$r*r*sin alpha /2$}), unghiul $alpha$ il aflam folosind functia $arccos$ si $cos alpha$ il determinam cu ajutorul teoremei lui Pitagora generalizate. O mica problema apare in sortarea parantezelor pentru ca daca parantezele provin din cercuri diferite dar le corespunde aceeiasi coarda atunci trebuie sa fim atenti la ordinea in care punem parantezele. Aceasta problema e rezolvata daca gasim un $X3$ pentru fiecare coarda numar ce reprezinta coordonata $X$ a intersectiei parantezei repsective cu linia orizontala de ordonata {$(Y{~i~} + Y{~i+1~}) / 2$}. Am aratat astfel cum se realizeaza determinarea ariei reuniunii cercurilor cu o banda ce nu contine nici o intersectie in {$O(n log n)$}. Din cauza faptului ca sunt in total maxim $O(n^2^)$ benzi repetand algoritmul pe fiecare banda obtinem aria reuniunii\r\ncercurilor in timp {$O(n^3^ log n)$}.\r\n\r\nh2. Problema 4: Joc\r\n\r\nProblema cere determinarea numarului maxim de drumuri disjuncte relativ la noduri pornind de la nodul $A$ si terminandu-se in nodul {$B$}. Daca ar fi restrictia numai pentru muchii nu si pentru noduri atunci raspunsul ar fi egal cu fluxul maxim in reteaua de transport formata astfel: sursa e nodul {$A$}, destinatia e nodul $B$ iar orice muchie ({$i,j$}) din graful initial e dublata in reteaua de transport ({$i,j$}) si ({$j,i$}) fiecare muchie avand capacitate {$1$}. Acesta afirmatie e intiutiva, o demonstratie matematica a ei ar fi aplicarea teoremei clasice: fluxul maxim intr-o retea reziduala este egala cu taietura minima in acea retea si a teoremei lui Menger: numarul maxim de drumuri disjuncte relativ la muchii de la $S$ la $T$ este egal cu taietura minima.\r\n\r\nProblema noastra mai are insa o dificultate, aceea ca trebuie sa nu avem acelasi nod in doua drumuri diferite. Aceasta problema o rezolvam dubland fiecare nod si muchiile ce intrau in nod intra acum in primul dintre cele doua noduri, muchiile ce ieseau ies acum din al doilea nod si mai adaugam o muchie intre primul nod si al doilea nod. Acum drumurile disjuncte relativ la muchii din aceasta retea corespund unor drumuri disjuncte relativ la noduri in prima retea.\r\n\r\nAstfel am redus problema initiala la una de flux in graf pe graful transformat. Complexitatea algoritmului e {$O(n*m)$}. Implementarea nu mai dubleaza nodurile la propriu ci foloseste {$c{~i,i~}$} pentru a reprezenta muchia intre cele doua noduri ce reprezinta nodul $i$ din graful initial.\r\n\r\n',1,'public'),('moisil-by-net-2006/clasament-11-12','Clasament moisil4','2006-11-24 18:25:13','h1. Clasament ==roundparam(round_id=\"moisil4\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"moisil4\")==',961,'protected'),('utilizator/eval','Profil eval','2006-12-13 22:10:10','h2. Despre mine\r\n\r\nbq. Vorbesc putin dar \"fac multe\":monitor.\r\n\r\nNu-mi trimite PM-uri ca nu-ti raspund.\r\n\r\nh2. Distinctii -primite- date\r\n\r\nToate punctele pe care le-ati primit pe infoarena vi le-am dat eu.\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* ==User(user=\"wickedman\" type=\"tiny\")==\r\n* ==User(user=\"fluffy\" type=\"tiny\")==\r\n* ==User(user=\"azotlichid\" type=\"tiny\")==\r\n* ==User(user=\"chucknorris\" type=\"tiny\")==',18,'protected'),('docs/security','Docs/security','2006-11-22 00:25:56','==include(page=\"docs/security_levels\")==',1142,'public'),('links','Links','2006-12-12 07:06:46','h1. Link-uri\r\n\r\nh2. Olimpiade\r\n\r\n* \'olimpiada.info\':http://olimpiada.info/\r\nPagina de plecare a Olimpiadei Nationale de Informatica. Nu te-ai saturat sa cauti in fiecare an un nou site, o noua adresa, o noua locatie a olimpiadei? Ei bine, de acum inainte tot ce este nevoie sa tii minte este http://olimpiada.info. \r\n* \'Olimpiade.ro\':http://www.olimpiade.ro ( ==user(user=\"fluffy\" type=\"tiny\")== @ 2004-11-19)\r\nNu este strict despre informatica, este site-ul tuturor olimpiadelor romanesti. Are un numar mare de subiecte de pe la olimpiade.\r\n* \'Olimpiada Nationala de Informatica 2004\':http://olimpiada.info/oni2004/ ( ==user(user=\"gigi\" type=\"tiny\")== @ 2004-08-11)\r\nSite-ul oficial al Olimpiadei Nationale de Informatica 2004, Buzau.\r\n* \'Olimpiada Judeteana de Informatica\':http://www.e-vrancea.com/oji/ ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-08-11)\r\nEste pagina oficiala a Olimpiadei Judetene de Informatica si ofera informatii real-time despre aceasta competitie. Tot aici se calculeaza listele de elevi ce se califica la ONI.\r\n\r\nh2. Concursuri online\r\n\r\n* \'.campion\':http://campion.edu.ro/\r\n&quot;.campion&quot; este un program de pregatire de performanta in informatica sustinut de profesori de prestigiu din tara - membri ai Comisiei Nationale de Informatica si de studenti - fosti olimpici internationali la informatica.\r\n* \'Saratov State University :: Online Contester\':http://acm.sgu.ru ( ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10)\r\nSite de antrenament pentru ACM, contine aproape 200 de probleme, dar nivelul de dificultate al problemelor este mult mai ridicat decat la celalte site-uri de acest tip.\r\n* \'TopCoder\':http://www.topcoder.com/tc ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nUn concurs de programare foarte popular. Accentul este pus mai mult pe viteza si acuratete decat pe probleme foarte grele.\r\n* \'IPSC - Internet Problem Solving Contest\':http://ipsc.ksp.sk/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nCel mai prestigios concurs online pe echipe. Problemele sunt frumoase si e primul concurs care cere nu surse de solutii ci outputuri pentru testele publicate.\r\n* \'Sphere Online Judge\':http://spoj.sphere.pl/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nOnline Judge cu probleme date la concursuri din Polonia.\r\n* \'Waterloo Programming Contests\':http://plg.uwaterloo.ca/~acm00/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nUniversitatea Waterloo din Canada organizeaza concursuri de pregatire pentru ACM. Pe acest site gasiti texte, teste si solutii ale acestor concursuri. Probleme de aici au fost folosite ca surse de inspiratie pt lotul roman si pentru balcaniada in 2000 parca ...\r\n* \'infoarena\':http://www.infoarena.ro/ ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-08-13)\r\nSite-ul infoarena vine in sprijinul elevilor, studentilor si profesorilor pasionati de informatica punand la dispozitie o arhiva de probleme de informatica atent alese, un evaluator online disponibil 24/7 si un forum. Tot aici se organizeaza periodic concursuri online de informatica.\r\n* \'Contaminare in programare\':http://www.contaminare.ro/ ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-08-13)\r\nContaminare.ro este un proiect al Palatul National al Copiilor, una din cele mai prestigioase institutii de instruire a copiilor in informatica din invatamantul preuniversitar. Contaminare.ro este una din cele mai indraznete modalitati interactive de pregatire a copiilor pasionati de programare. \r\n* \'ACM, University of Vallaloid\':http://acm.uva.es/ ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-08-11)\r\nEste cel mai mare site din reteaua ACM, ofera o arhiva de peste 1000 de probleme si o lista de discutii de cateva zeci de mii de membri. Site-ul organizeaza regulat concursuri online.\r\n* \'ACM, Ural State University\':http://acm.timus.ru/ ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-08-10)\r\nSite din reteaua ACM intretinut de Ural State University. O buna parte din problemele de aici sunt foarte interesante si pregatitoare. Demn de mentionat este faptul ca la realizarea acestei arhive au contribuit si cativa olimpici romani internationali.\r\n\r\nh2. Liste de discutii\r\n\r\n* \'Forum-ul oficial GInfo\':http://ba.toptalent.ro/forum/index.php ( ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17)\r\nForumul oficial al revistei GInfo,\r\nrevista viitorilor specialisti in tehnologia informatiei.\r\n* \'Lista lui Francu\':http://probleme.francu.com ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-08-11)\r\n&quot;... o lista de e-mail care isi propune in principal sa ajute la pregatirea elevilor de liceu pentru concursurile de informatica.&quot;\r\n\r\nh2. Limbaje, compilatoare\r\n\r\n* \'Free Pascal\':http://www.freepascal.org/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nPagina oficiala a unui compilator pascal pe 32 de biti, gratuit folosit la concursurile internationale. La ACM ICPC s-a luat decizia ca in viitorul apropiat sa se renunte la limbajul pascal. Deja in unele concursuri regionale nu mai e folosit.\r\n* \'DJGPP\':http://www.delorie.com/djgpp/ ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-08-10)\r\nAceasta este pagina oficiala a distributiei DJGPP - un compilator ANSI C ce ruleaza pe sisteme Microsoft Windows. DJGPP este folosit cu precadere la olimpiadele si concursurile nationale si internationale.\r\n\r\nh2. Editoare, platforme\r\n\r\n* \'RHIDE\':http://www.rhide.com/ ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-08-12)\r\nRHIDE este unul dintre cele mai folosite IDE-uri la olimpiada. Seamana foarte mult cu interfata &quot;albastra&quot; Borland, are debugging integrat si functioneaza atat pe Windows cat si pe Linux.\r\n\r\nh2. Carti si publicatii\r\n\r\n* \'Solutii pentru cateva probleme din CLR\':http://www.itu.dk/people/beetle/teaching/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2005-03-24)\r\nVeti gasi pe aceasta pagina cateva solutii pentru problemele din cartea &quot;Introducere in algoritmi&quot;, parcurgerea lor e un bun pas inspre rezultate bune la olimpiadele de informatica.\r\n* \'Algoritmi Fundamentali\':http://www.cwu.edu/~andonie/Cartea%20de%20algoritmi/toc.htm ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2005-03-10)\r\nO carte online scrisa de Prof. Razvan Andonie si Ilie Garbacea.\r\nCartea prezinta structurile de date uzuale, analiza eficientei algoritmilor, tehnici de programare, algoritmi de explorare a grafurilor si concepte OOP.\r\nLa sfarsitul fiecarui capitol sunt adaugate exercitii, multe dintre ele rezolvate.\r\n* \'Introduction to Algorithms\':http://zhuzeyuan.hp.infoseek.co.jp/ita/toc.htm ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-12)\r\nNu are nevoie de introducere.\r\n* \'Algorithms Courses on the WWW\':http://www.cs.pitt.edu/~kirk/algorithmcourses/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nUn site cu linkuri spre cursuri de algoritmica ale universitatilor puternice din State. Materialul in general este accesibil unui elev de liceu ce se pregateste pt ONI sau alte concursuri mai puternice.\r\n* \'Ferguson: Game Theory\':http://www.math.ucla.edu/~tom/Game_Theory/Contents.html ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nCarte despre teoria jocurilor. Capitolul I este interesant pentru unele probleme folosite in concursurile de programare.\r\n* \'EWD Archive\':http://www.cs.utexas.edu/users/EWD/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nArticole din corespondenta lui Dijkstra cu colegii algoritmicieni. Multe din articole sunt stufoase si greu de citit dar se gasesc si foarte multe idei interesante.\r\n* \'Numerical Recipes in C\':http://www.library.cornell.edu/nr/bookcpdf.html ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nPoate majoritatea subiectelor tratate in carte sunt prea avansate pentru elevii de liceu, dar sunt si subiecte accesibile si folositoare.\r\n* \'Revista GInfo\':http://www.ginfo.ro/ ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-08-12)\r\nFoarte populara in randurile informaticienilor, GInfo este o revista de prestigiu in domeniu ce pune la dispozitia cititorilor articole foarte valoroase despre informatica si concursuri de programare. Site-ul ofera spre download gratuit toate numerele revistei (in afara de ultimul) in format PDF. \r\n\r\nh2. Algoritmi\r\n\r\n* \'Topcoder algorithm tutorials\':http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=index ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2005-05-17)\r\nO serie de tutoriale pentru cunostintele de  baza de care aveti nevoie in concursurilor de programare, deocamdata cateva subiecte interesante sunt geometrie computationala, greedy, programare dinamica, matematica pt concursuri de programare si folosirea expresiilor regulare.\r\n* \'Algorithmist\':http://www.algorithmist.com/index.php/Main_Page ( ==user(user=\"domino\" type=\"tiny\")== @ 2005-03-13)\r\nSite cu explicatii pentru diversi algoritmi si solutii pentru cateva probleme de la ACM.UVA.ES\r\n* \'comp.graphics.algorithms Frequently Asked Questions\':http://www.faqs.org/faqs/graphics/algorithms-faq/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nO lista de intrebari si raspunsuri frecvente legate de geometrie computationala.\r\n* \'Graph Theory\':http://www.math.fau.edu/locke/graphthe.htm ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nNotiuni si teoreme legate de teoria grafurilor.\r\n* \'The Aggregate Magic Algorithms\':http://aggregate.org/MAGIC/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nAlgoritmi low level, optimizari, operatii pe biti.\r\n* \'Stony Brook Algorithm Repository\':http://www.cs.sunysb.edu/~algorith/ ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-08-12)\r\nUn site ce serveste ca o colectie comprehensiva de implementari de algoritmi, intretinut de Steven Skiena - unul dintre cei mai prestigiosi algoristi din lume.\r\n\r\nh2. General\r\n\r\n* \'TJHSST&#039;s Senior Computer Team\':http://activities.tjhsst.edu/sct/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2005-05-27)\r\nSiteul de pregatire pentru concursuri de programare a liceului Thomas Jefferson, cel mai tare liceu din SUA la acest capitol.\r\n* \'Pareri ale fostilor olimpici despre olimpiada de informatica\':http://olimpiada.info/index.php?cid=quotes ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2005-03-10)\r\nO lista de pareri ale fostilor olimpici la informatica ai Romaniei. Daca nu sunteti siguri la ce e buna olimpiada si informatica in general cititi cateva randuri de acolo. ;)\r\n* \'Cut the Knot\':http://www.cut-the-knot.org/content.shtml ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-20)\r\nInteractive Mathematics Miscellany and Puzzles\r\n* \'Don Knuth: Musings\':http://scpd.stanford.edu/knuth/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nProfesorul Knuth nu mai preda dar tine din cand in cand cate un curs despre ceva legat de algoritmica ce i se pare lui interesant. Aveti pe acest site acces la cateva din aceste cursuri ce au fost filmate. Din pacate trebuie o conexiune destul de buna.\r\n* \'Personal homepage of Zeyuan Zhu\':http://zhuzeyuan.hp.infoseek.co.jp/index.htm ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nPagina personala a unui reprezentant al Chinei la IOI. Contine idei la multe probleme de pe acm.timus.ru si probleme interesante ale autorului. De asemenea contine si versiunea online a cartii Introduction to Algorithms de Cormen, Leiserson si Rivest, carte de baza pentru concursurile de programare.\r\n* \'Google\':http://www.google.com ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nCel mai util site ;)\r\n* \'MathWorld\':http://mathworld.wolfram.com/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nDaca intalniti o notiune de matematica care nu o intelegeti sau vreti sa o aprofundati acest site este ceea ce cautati.\r\n* \'On-Line Encyclopedia of Integer Sequences\':http://www.research.att.com/~njas/sequences/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nDaca intalniti un sir si credeti ca ar putea fi unul celebru, puteti il cautati pe acest site.\r\n* \'TyperA - test your typing skills\':http://www.typera.tk/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nDaca nu ati vazut pe cineva care sa tasteze mai repede ca voi, va puteti compara viteza cu cei mai buni din lume pe acest site.\r\n* \'How To Become A Hacker\':http://www.catb.org/~esr/faqs/hacker-howto.html ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nUn document interesant care ne ajuta sa intelegem modul de gandire a hackerilor.\r\n* \'Omnibus Useful Links Page\':http://sourceforge.net/forum/forum.php?thread_id=1039803&forum_id=48211 ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-11-10)\r\nGasiti aici o colectie impresionanta de link-uri catre carti si publicatii online (download-abile!) despre programare.\r\n* \'How To Be A Programmer\':http://samizdat.mines.edu/howto/HowToBeAProgrammer.pdf ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nDocument mai general ce nu e orientat inspre olimpici ci inspre un tip ce isi castiga painea din programare.\r\n* \'The rec.puzzles archive\':http://rec-puzzles.org/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nArhiva de problemutze de pe lista de discutii rec.puzzles de pe usenet.\r\n* \'MathLinks\':http://www.mathlinks.ro/Forum/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\nCel mai mare forum ce se ocupa cu probleme de matematica.\r\n* \'Ponder This\':http://www.research.ibm.com/ponder/ ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-10)\r\n&quot;Welcome to our Monthly Puzzles  \r\nYou are cordially invited to match wits with some of the best minds in IBM Research.&quot;\r\n\r\n* \'Usaco training gateway\':http://ace.delos.com/usacogate ( ==user(user=\"Cosmin\" type=\"tiny\")== @ 2004-11-08)\r\nSite american de pregatire pentru olimpiade. Cel mai bun site pentru incepatori. Siteul este impartit in sectiuni si pentru a trece de la o sectiune la urmatoarea trebuie rezolvate toate problemele din sectiunea curenta. In fiecare sectiune exista si documentatie referitoare la tehnica de programare ce poate fi folosita pentru a rezolva problemele acelei sectiuni.\r\n* \'e - Edu\':http://www.e-edu.go.ro/ ( ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-08-13)\r\nUn site aflat intr-o permanenta actualizare ce se adreseaza tuturor celor interesati in probleme de informatica.\r\n\r\nh2. Articole\r\n\r\n* \'Coding Style for C Programming\':http://www.cs.usyd.edu.au/~scilect/tpop/handouts/Style.htm ( ==user(user=\"silviug\" type=\"tiny\")== @ 2004-11-10)\r\nArticolul cuprinde recomandari pentru formarea un stil de implementare in limbajul C++.\r\n',13,'protected'),('articole','Articole','2007-01-28 20:48:26','h1. Articole\r\n\r\nAceste pagini, ca intreg site-ul infoarena, sunt intr-o continua miscare. Utilizatorii infoarena pot edita pagini sau sa creeze altele noi. \r\n\r\n\"Afla cum poti edita si tu articole\":documentatie/articole.\r\n\r\ntable(layout). |_. Algoritmi |_. Structuri de date |\r\n| * !>Al-K-lea-drum-minim?kshortest_tree.png 40%! \'Automate finite si KMP\':Automate-finite-si-KMP\r\n* \'Aplicatii ale cautarii binare\':Aplicatii-ale-cautarii-binare\r\n* \'Al K-lea drum minim\':Al-K-lea-drum-minim\r\n* \'Ciclu hamiltonian in graf dens\':Ciclu-hamiltonian-in-graf-dens\r\n|* !>LCA-Lowest-common-ancestor?euler.jpg 40%! \'LCA: Lowest common ancestor\':LCA-Lowest-common-ancestor\r\n* \'Skiplists\':Skiplists\r\n* \'Hashing\':Hashing |\r\n|_. Limbaje |_. Matematica|\r\n|* \'STL\':STL\r\n* \'Introducere in asamblare\':Introducere-in-asamblare\r\n* {\'12 ponturi pentru programatorii C/C++\':12-ponturi-pentru-programatorii-CC}\r\n* \'Multe &quot;smenuri&quot; de programare in C/C++... si nu numai!\':Multe-smenuri-de-programare-in-CC-si-nu-numai\r\n|* \'Algoritmul lui Euclid\':Algoritmul-lui-Euclid\r\n* \'Ciurul lui Erathostene\':Ciurul-lui-Erathostene|\r\n|_. Despre infoarena |_. Diverse |\r\n|* \'Despre infoarena\':Despre\r\n* \'Asociatia infoarena\':Asociatia-infoarena\r\n|* \'F.A.Q. Pregatire bacalaureat 2005\':FAQ-Pregatire-bacalaureat-2005\r\n* \'DJGPP - instalarea de la A la Z\':DJGPP-instalarea-de-la-A-la-Z\r\n* \'The Monty Hall Problem\':The-Monty-Hall-Problem |\r\n|\\2_. Solutii (oficiale) la diverse competitii |\r\n|* \'Unirea 2007\':unirea-2007/solutii\r\n* \'preONI 2007 runda #1 - solutii\':preoni-2007/runda-1/solutii\r\n* !>articole?preoni2006.gif 50%! \'preONI 2005 runda #1 - solutii\':preoni-2005/runda-1/solutii\r\n* \'preONI 2005 runda #2 - solutii\':preoni-2005/runda-2/solutii\r\n* \'preONI 2005 runda #3 - solutii\':preoni-2005/runda-3/solutii\r\n* \'Solutii preONI 2006 - Runda 1\':preoni-2006/runda-1/solutii\r\n* \'Solutii preONI 2006 - Runda a 2-a\':preoni-2006/runda-2/solutii\r\n* \'Solutii preONI 2006 - Runda a 3-a\':preoni-2006/runda-3/solutii\r\n* \'Solutii preONI 2006, Runda a 4-a\':preoni-2006/runda-4/solutii\r\n* \'Solutii preONI 2006, Runda finala\':preoni-2006/finala/solutii\r\n* \'Solutii - Summer Challenge Unu\':summer-challenge-unu/solutii\r\n* \'Solutii - Summer Challenge Doi\':summer-challenge-2/solutii\r\n* \'Solutii - Summer Challenge Trei\':summer-challenge-3/solutii\r\n* \'Solutii Autumn WarmUp 2006\':warm-up-2006/solutii\r\n|* \'Solutiile oficiale pentru Concursul &quot;de incalzire&quot;\':warm-up-2004/solutii\r\n* \'Concursul Agora - Etapa Finala - Solutii\':agora-finala/solutii\r\n* \'Doua probleme de la runda 6 a concursului Algoritmus\':Doua-probleme-de-la-runda-6-a-concursului-Algoritmus\r\n* \'USACO dec 2004, divizia GOLD\':USACO-dec-2004-divizia-GOLD\r\n* \'Usaco ian 2005, divizia GOLD\':Usaco-ian-2005-divizia-GOLD\r\n* \'USACO oct 2005, divizia GOLD\':USACO-oct-2005-divizia-GOLD\r\n* \'USACO nov 2005, divizia GOLD\':USACO-nov-2005-divizia-GOLD\r\n* \'USACO dec 2005, divizia GOLD\':USACO-dec-2005-divizia-GOLD |',1,'protected'),('template/taskfooter','template/taskfooter','2006-11-24 16:38:05','== TaskSubmit(task_id=\"%task_id%\") ==\r\n\r\n\"Cum se trimit solutii?\":documentatie/pentru-utilizatori',1142,'protected'),('preoji-2004/clasament-9-10','Clasament preOJI 2004, clasele 9-10','2006-11-24 00:12:20','h1. Clasament \'preOJI 2004\':preoji-2004, clasele 9-10\r\n\r\n==Rankings(rounds = \"preoji1\")==',1142,'protected'),('problema/overlap','Overlap','2006-11-22 02:51:21','==Include(page=\"template/taskheader\" task_id=\"overlap\")==\r\n\r\nFie $N$ puncte in plan cu coordonate intregi $x{~i~} , y{~i~}$. Acestea sunt rotite cu $k*90$ grade ({$k = 0 , 1 , 2$} sau $3$) si/sau translatate, astfel incat se obtin alte $N$ puncte, diferite doua cate doua de primele.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se $N$(numar par) puncte, determinati o impartire a lor in doua submultimi de cardinal $N/2$ astfel incat a doua sa poata fi obtinuta din prima prin operatiile descrise.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $overlap.in$ se afla $N$, numarul de puncte, iar pe urmatoarele $N$ linii se afla cate o pereche $x{~i~}$, $y{~i~}$ - pe cea de-a $i-a$ linie se afla coordonatele punctului $i$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $overlap.out$ va contine $N$ linii, iar pe fiecare linie va exista un singur caracter $1$ sau $2$ cu semnificatia ca punctele etichetate cu $1$ fac parte din prima multime, iar punctele etichetate cu $2$ fac parte din cea de-a doua multime. Daca exista mai multe solutii se cere oricare dintre acestea; se garanteaza existenta cel putin a unei solutii.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 800$\r\n* $0 &le; x{~i~}, y{~i~} &le; 100.000$\r\n* Prin \"rotatie\" se intelege fixarea unui punct oarecare in plan si rotirea tuturor punctelor initiale fata de acesta.\r\n* Prin \"translatie\" se intelege alegerea numerelor constante $shift_x$ si $shift_y$, si transformarea coordonatelor $(Pi{~x~}, Pi{~y~})$ in $(Pi{~x~}+shift_x, Pi{~y~}+shift_y)$ pentru orice punct $i$.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. overlap.in |_. overlap.out |\r\n| 6\r\n  5 5\r\n  9 1\r\n  6 1\r\n  3 2\r\n  6 3\r\n  3 5\r\n| 1\r\n  2\r\n  2\r\n  1\r\n  2\r\n  1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"overlap\")==',1,'task: overlap'),('documentatie/macro-uri','Macro-uri','2006-11-25 13:55:31','h1. Macro-uri\r\n\r\nMacro-uri sunt niste blocuri speciale de text care sunt tratate \'special\' de wiki-ul infoarena. Cu macro-uri se pot face foarte multe lucruri, de la linkuri catre utilizatori pana la tabele de scoruri.\r\n\r\nh2. Sintaxa\r\n\r\nMacro-uri sunt introduse cu o sintaxa de genul @==User(user=\"domino\" type=\"tiny\")==@, si se obtine ==User(user = \"domino\" type=\"tiny\")==. Momentan sintaxa de macro-uri este *foarte* stricta, dar poate cu timpul va fi \"relaxata\". Atentie:\r\n\r\n* Numele macro-urilor nu sunt case-sensitive.\r\n* Parantezele, egalul si ghilimele sunt obligatorii.\r\n* Nu se accepta parameteri dubli sau virgule intre parametetri.\r\n\r\nh2. Macro-uri comune:\r\n\r\n* debug\r\n* gallery\r\n* grep\r\n* hello\r\n* image?\r\n* include\r\n* rankings\r\n* tableofcontents\r\n* tasks\r\n* user\r\n\r\nh2. Propune si tu un macro!\r\n\r\nDaca iti doresti un macro nu trebuie decat sa ne ceri si vom incerca sa rezolvam. Poti face o cerere de macro \'aici\':http://hackers.devnet.ro/newticket (\'explicatii\':documentatie/development).',1142,'public'),('problema/popandai2','Popandai2','2006-11-24 16:15:36','==Include(page=\"template/taskheader\" task_id=\"popandai2\")==\r\n\r\nPopandaii de pe \"tarlaua vesela\" au scapat de atacul vulturilor si acum trebuie sa se adaposteasca de lupi in vizuinile lor. Aceste vizuini se pot identifica prin puncte avand coordonate intregi in plan si sunt dispuse in colturile unui poligon convex. Pentru a fi protejati de atacul lupilor, popandaii vor sa stabileasca un perimetru de siguranta cat mai mare posibil, unde se pot misca in voie. Acest perimetru va fi in forma de patrulater si va avea varfurile situate in patru din cele $N$ puncte care reprezinta vizuinile.\r\n\r\nh2. Cerinta\r\n\r\nAjutati popandaii sa determine zona de arie maxima care satisface conditiile de mai sus!\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $popandai2.in$ se afla un numar intreg $N$ , reprezentand numarul vizuinilor. Urmatoarele $N$ linii contin fiecare cate doua numaere intregi ({$X{~i~} , Y{~i~}$}) (separate printr-un spatiu) reprezentand coordonatele celei de-a {$i$}-a vizuina. Aceste coordonate vor fi date in ordine trigonometrica.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului de iesire $popandai2.out$ va fi afisat un singur numar real cu o zecimala exacta reprezentand aria maxima a patrulaterului cautat.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $4 &le; N &le; 1.000$\r\n* $1 &le; X{~i~}, Y{~i~} &le; 30.000$\r\n* Pentru $60%$ din punctaj rezolvati problema pe cazul $3 &le; N &le; 300$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. popandai2.in |_. popandai2.out |_. Figura |\r\n| 7\r\n3 2\r\n6 1\r\n9 3\r\n8 7\r\n6 9\r\n3 8\r\n2 4\r\n| 28.5 \r\n| !problema/popandai2?popandai2.jpg! |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"popandai2\")==',1142,'task: popandai2'),('problema/dame','Dame','2006-11-24 16:10:36','==Include(page=\"template/taskheader\" task_id=\"dame\")==\r\n\r\nBronzarel s-a apucat serios de informatica si cu ajutorul lui Zaharel spera sa devina un mare programator. Printre primele problemele pe care le-a rezolva, a fost problema clasica a damelor: dandu-se o tabla de sah $N*N$ sa se determine toate modurile in care se poate amplasa un numar maxim de dame pe tabla astfel incat sa nu se atace intre ele (doua dame se ataca intre ele daca sunt pe aceeasi linie, aceeasi coloana sau aceeasi diagonala). Fiindca rezultatul este calculabil doar pentru valori mici ale lui $N$, Bronzarel a scris repede un program care foloseste \"backtracking\", metoda lui preferata. Vazandu-l foarte multumit de el, Zaharel ii zice sa faca un program care determina doar o modalitate de amplasare, dar pentru valori mai mari ale lui $N$. Se pare ca aceasta problema il depaseste pe Bronzarel, metoda lui favorita fiind nefolositoare de data aceasta.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program in locul lui Bronzarel care sa determine un mod in care se pot amplasa un numar maxim de dame pe o tabla de sah $N*N$.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie din fisierul de intrare $dame.out$ va contine numarul natural $N$.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie din fisierul de iesire $dame.out$ se va scrie numarul $Max$, reprezentand numarul maxim de dame care se pot amplasa pe tabla. Urmatoarele $Max$ linii vor contine perechi de numere naturale reprezentand linia si coloana pe care se va afla o dama.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $1 &le; N &le; 1.000$\r\n* Liniile si coloanele tablei sunt numerotate de la $1$ la $N$\r\n* Pentru $30%$ din teste $N &le; 25$ iar pentru $60%$ din teste $N &le; 200$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. dame.in |_. dame.out |\r\n|8 |8\r\n 1 4\r\n 2 7\r\n 3 3\r\n 4 8\r\n 5 2\r\n 6 5\r\n 7 1\r\n 8 6 |\r\n\r\nh3. Explicatii\r\n\r\n!problema/dame?image001.jpg!\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"dame\")==',1142,'task: dame'),('problema/apdm','APDM','2006-11-24 16:03:02','==Include(page=\"template/taskheader\" task_id=\"apdm\")==\r\n\r\nVom considera un graf conex, neorientat, cu $N$ varfuri si $M$ muchii. Fie $D(i, j)$ distanta minima dintre varfurile $i$ si $j$. Prin diametrul grafului vom defini valoarea $Max { D(i,j) (1 &le; i < j &le; N) }$.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine arborele partial de diametru minim al grafului dat!\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $apdm.in$ se afla $N$ si $M$. Pe fiecare din urmatoarele $M$ linii se afla cate doua numere intregi sub forma $x y$, indicand prezenta unei muchii intre varfurile $x$ si $y$.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului $apdm.out$ se va afisa diametrul arborelui obtinut.\r\n\r\nh2. Restrictii\r\n\r\n* $3 &le; N &le; 150$\r\n* $N &le; M &le; 5000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. apdm.in |_. apdm.out |\r\n| 8 13\r\n1 2\r\n1 5\r\n2 4\r\n1 7\r\n2 3\r\n3 4\r\n3 8\r\n4 5\r\n4 6\r\n5 6\r\n5 7\r\n6 7\r\n6 8\r\n| 4 | \r\n\r\nh3. Explicatie\r\n\r\nIn desen observam colorate cu verde muchiile unui arbore partial de diametru 4, acestea sunt: (1, 5), (2, 4), (3, 4), (4, 5), (4, 6), (5, 7), (6, 8)\r\n\r\n!problema/apdm?image001.gif!\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"apdm\")==',1142,'task: apdm'),('problema/arbciclu','Arbore de cicluri','2006-11-24 15:54:02','==Include(page=\"template/taskheader\" task_id=\"arbciclu\")==\r\n\r\nUn arbore de cicluri este un graf neorientat care are una din urmatoarele proprietati:\r\n\r\n* este un ciclu de lungime $K$ ({$K &ge; 3$})\r\n* este un graf obtinut prin atasarea unui ciclu $C$ de lungime $K$ ({$K &ge; 3$}) la o muchie dintr-un arbore de cicluri $CT$\r\n\r\nAtasarea unui ciclu la o muchie dintr-un graf inseamna inlocuirea unei muchii din ciclu cu o muchie din graf (si de asemenea inlocuirea celor doua noduri ale muchiei din ciclu cu cele doua noduri ale muchiei din graf).\r\n!problema/arbciclu?arbciclu.jpg! &nbsp;\r\nDandu-se mai multe grafuri sa se determine pentru fiecare daca este un arbore de cicluri.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare $arbciclu.in$ contine un numar natural $T$, reprezentand numarul de grafuri care se dau. Pentru fiecare graf dat, prima linie va contine doua numere naturale: $N$ si $M$. $N$ este numarul de noduri din graf si $M$ este numarul de muchii. Urmatoarele $M$ linii vor contine cate doua numere intregi $A$ si $B$, cu semnificatia ca exista o muchie intre nodul $A$ si nodul $B$. Nodurile din graf sunt numerotate cu numere de la $1$ la $N$.\r\n\r\nh2. Date de iesire\r\n\r\nPentru fiecare graf, in ordinea data in fisierul de intrare, se va afisa in fisierul $arbciclu.out$ sirul $YES$ daca graful este un arbore de cicluri, sau $NO$ in caz contrar.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; T &le; 10$\r\n* $1 &le; N &le; 100.000$\r\n* $1 &le; M &le; 200.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. arbciclu.in |_. arbciclu.out |\r\n|2\r\n3 3\r\n1 2\r\n1 3\r\n3 2\r\n4 5\r\n1 2\r\n1 3\r\n3 2\r\n4 3\r\n2 4 \r\n| YES\r\nYES |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"arbciclu\")==',1142,'task: arbciclu'),('problema/expresii','Expresii algebrice','2006-11-24 16:07:35','==Include(page=\"template/taskheader\" task_id=\"expresii\")==\r\n\r\nO expresie algebrica poate fi reprezentata printr-un arbore. Putem evalua expresia parcurgand arborele ei corespunzator. Reprezentarea sub forma de arbore a unei expresii algebrice nu este obligatoriu unica. De exemplu, expresia {@1+2+3*4@} poate fi reprezentata prin urmatorii doi arbori:\r\n\r\n!problema/expresii?expresii.jpg!\r\n\r\nLa o privire atenta observam ca succesiunea operatiilor {@+@} si {@*@} se mentine, iar ordinea operanzilor ramane neschimbata. In primul arbore ordinea evaluarii va fi: {@3*4 = 12@}; {@2+12 = 14@}; {@1+14 = 15@}. In al doilea arbore, expresia va fi evaluata astfel: {@1+2 = 3@}; {@3*4 = 12@}; {@3+12 = 15@}. Ambele reprezentari produc rezultatul dorit.\r\n\r\nIn aceasta problema vom considera expresii algebrice simple ce contin doar numere dintr-o singura cifra, {@+@}, {@*@} si paranteze. Expresia se evalueaza dupa regulile algebrice normale.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul de reprezentari sub forma de arbore care evalueaza expresia correct.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $expresii.in$ contine numarul de teste {$T$}. Urmatoarele linii contin cele $T$ teste. Fiecare test este format dintr-o singura linie, ce contine expresia algebrica.\r\n\r\nh2. Date de Iesire\r\n\r\nPentru fiecare test, afisati in fisierul $expresii.out$ o linie ce respecta urmatorul format: \"Numarul de arbori = {$XXX$}.\", unde $XXX$ va fi inlocuit de numarul de reprezentari care vor evalua expresia correct. Daca expresia algebrica este incorecta din punct de vedere sintactic atunci numarul reprezentarilor corecte este {$0$}.\r\n\r\nh2. Restrictii\r\n\r\n* expresia nu contine spatii si lungimea ei este intre $1$ si $50$\r\n* $0 < T < 120$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. expresii.in |_. expresii.out |\r\n| 6\r\n1+2+3+4\r\n(1+2)+(3+4)\r\n1+2+3*4\r\n1+2+(3*4)\r\n1+*7\r\n1+2*(3+(4*5)\r\n| Numarul de arbori = 5.\r\nNumarul de arbori = 1.\r\nNumarul de arbori = 2.\r\nNumarul de arbori = 2.\r\nNumarul de arbori = 0.\r\nNumarul de arbori = 0. |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"expresii\")==',1142,'task: expresii'),('happy-coding-2006','Happy Coding 2006','2006-11-24 17:44:58','h1. Happy Coding 2006\r\n\r\nConcursul s-a desfasurat incepand cu ora 10:00, Luni 9 Ocombrie 2006, pana Duminica la ora 22:00, 15 Octombrie 2006. Concurentii au avut la dispozitie o saptamana pentru rezolvarea celor 20 de probleme propuse.\r\n\r\nProblemele au fost propuse in mare parte de Mugurel Ionut Andreica, un set de probleme folosite pentru selectia echipe de ACM a Universitatii Politehnica Bucuresti. La acestea s-au adaugat cateva probleme ale lui Mircea Pasoi, Adrian Vladu si Daniel Pasaila.\r\n\r\nh2. \'Clasament\':happy-coding-2006/clasament\r\n\r\n!>happy-coding-2006?logo.jpeg!\r\n\r\n== Tasks(round_id=\"happy2006\" pager_style=\"none\") ==\r\n',961,'protected'),('utilizator/danielp','Profil danielp','2006-11-27 01:23:06','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',48,'protected'),('utilizator/cosmin','Profil Cosmin','2006-11-27 01:23:08','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',58,'protected'),('utilizator/greco','Profil greco','2006-11-27 01:23:09','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',66,'protected'),('utilizator/tbog','Profil TBog','2006-11-27 01:23:11','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',76,'protected'),('utilizator/snaked31','Profil snaked31','2006-11-27 01:23:22','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',142,'protected'),('utilizator/vali','Profil vali','2006-11-27 01:23:32','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',201,'protected'),('utilizator/e_udrea','Profil e_udrea','2006-11-27 01:23:33','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',205,'protected'),('utilizator/filipb','Profil filipb','2006-12-12 18:10:04','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\nElev in clasa a XI-a la Colegiul National \'Vasile Alecsandri\' din Galati\r\n\r\nh2. Distinctii primite\r\n\r\n* Premiul I la Olimpiada Nationala de Informatica, Targoviste, 2006, clasa a X-a\r\n* Premiul al II-lea la Concursul National \"Stelele Informaticii\", 2006, Bucuresti, clasa a XI-a\r\n* Premiul I la Olimpiada Nationala de Informatica, Galati, 2005, clasa a IX-a\r\n* Premiul I la Olimpiada Nationala de Informatica, Focsani, 2003, clasa a VII-a\r\n',256,'protected'),('utilizator/monica','Profil monica','2006-11-27 01:24:15','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',453,'protected'),('utilizator/hitandyrun','Profil hitandyrun','2006-11-27 01:24:48','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',630,'protected'),('utilizator/mirela lazar','Profil mirela lazar','2006-11-27 01:24:54','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',666,'protected'),('utilizator/fluffy','Profil fluffy','2006-12-13 09:14:04','h2. Contact\r\n\r\nBug-uri pe ==smflink(link=\"topic\" topic=\"1359\" caption=\"forum\")==\r\n\r\nh2. Despre mine\r\n\r\nbq.. Eu sunt o valoare, eu sunt number one\r\nEu sunt un baiat super unicat.\r\n\r\nh2. Distinctii primite\r\n\r\nbq.. Nu este nevoie ca sa ma prezint\r\nSunt si platina si aur si argint.\r\n\r\nh2. Arte martiale\r\n\r\nbq.. Dau cu sabia, dau cu paru\'\r\nNu se satura dusmanu\'',1142,'protected'),('sanduleac_dan','Profil sandyxp','2006-11-27 01:25:38','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',909,'protected'),('utilizator/domnina','Profil domnina','2006-11-27 01:25:46','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',951,'protected'),('utilizator/ditzonec','Profil DITzoneC','2006-12-15 19:43:10','h2. Studii\r\n\r\n* Student la Universitatea Bucuresti, \"Facultatea de Matematica si Informatica\":http://fmi.unibuc.ro/ro/, sectia Informatica\r\n* Student la Universitatea Politehnica Bucuresti, \"Facultatea de Automatica si Calculatoare\":http://www.acs.pub.ro/, sectia Calculatoare\r\n* \"Absolvent al Colegiului National de Informatica {@\"Tudor Vianu\"@}\":http://www.lbi.ro/, Bucuresti\r\n\r\nh2. Distinctii primite\r\n\r\n* 2006 - Calificare faza finala a \"The ACM International Collegiate Programming Contest\":http://icpc.baylor.edu/icpc/finals/default.htm\r\n* 2006 - Medalie de bronz la \"Olimpiada Europei Centrale de Informatica\":http://jagor.srce.hr/hsin/ceoi2006/\r\n* 2006 - Castigator al concursului \".campion\":http://campion.edu.ro/index.php\r\n* 2005-2006 - Membru al lotului national de informatica\r\n* 2003-2006 - Premii si mentiuni la Olimpiada Nationala de Informatica\r\n* 2003-2005 - Calificat la Olimpiada Nationala de Fizica\r\n* 2006 - Calificat la Olimpiada Nationala de Matematica\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* ==User(user=\"cimi\" type=\"tiny\")==\r\n\r\n* ==User(user=\"domino\" type=\"tiny\")==\r\n* ==User(user=\"greco\" type=\"tiny\")==\r\n* ==User(user=\"azotlichid\" type=\"tiny\")==\r\n* ==User(user=\"cosmin\" type=\"tiny\")==\r\n* ==User(user=\"fluffy\" type=\"tiny\")==\r\n* ==User(user=\"silviug\" type=\"tiny\")==\r\n* ==User(user=\"wickedman\" type=\"tiny\")==\r\n* ==User(user=\"filipb\" type=\"tiny\")==\r\n* ==User(user=\"danielp\" type=\"tiny\")==\r\n* ==User(user=\"svalentin\" type=\"tiny\")==\r\n\r\n\r\n\r\n',961,'protected'),('utilizator/mrmagic','Profil MrMagic','2006-11-27 01:25:50','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',970,'protected'),('utilizator/tabara','Profil tabara','2006-11-27 01:26:00','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1024,'protected'),('utilizator/gaby','Profil Gaby','2006-11-27 01:26:21','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1137,'protected'),('utilizator/hda','Profil hda','2006-11-27 01:26:28','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1164,'protected'),('utilizator/bogdang1723','Profil bogdang1723','2006-11-27 01:26:54','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1287,'protected'),('utilizator/littleman','Profil littleman','2006-11-27 01:27:01','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1325,'protected'),('utilizator/expertu','Profil expertu','2006-11-27 01:27:05','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1343,'protected'),('utilizator/misha','Profil misha','2006-11-27 01:27:35','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1501,'protected'),('utilizator/george126','utilizator/george126','2006-12-11 10:18:39','',1503,'public'),('utilizator/roberto','Profil roberto','2006-11-27 01:28:05','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1631,'protected'),('utilizator/_cont_','Profil _cont_','2006-11-27 01:28:10','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1636,'protected'),('utilizator/drroty','Profil Drroty','2006-11-27 01:28:20','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1666,'protected'),('utilizator/dianah','Profil DianaH','2006-11-27 01:28:21','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1670,'protected'),('utilizator/szaki','Profil szaki','2006-11-27 01:28:26','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1689,'protected'),('utilizator/vax187','Profil vax187','2006-11-27 01:28:29','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1696,'protected'),('utilizator/xlf','Profil xlf','2006-11-27 01:28:49','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1779,'protected'),('utilizator/_darlene_','Profil _darlene_','2006-11-27 01:29:21','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1935,'protected'),('utilizator/k_ionutz','Profil K_ionutz','2006-11-27 01:29:27','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1967,'protected'),('utilizator/ltugmaria','Profil ltugmaria','2006-11-27 01:29:41','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2029,'protected'),('utilizator/tudorel','Profil tudorel','2006-11-27 01:30:18','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2180,'protected'),('utilizator/sarge','Profil sarge','2006-11-27 01:30:20','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2186,'protected'),('utilizator/ionelya15','Profil ionelya15','2006-11-27 01:30:34','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2256,'protected'),('utilizator/dandreica','Profil dandreica','2006-11-27 01:30:46','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2311,'protected'),('utilizator/bacinfo2005','Profil bacinfo2005','2006-11-27 01:30:46','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2315,'protected'),('utilizator/veleavlad','Profil veleavlad','2006-11-27 01:30:59','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2377,'protected'),('utilizator/alinutzu_vip','Profil alinutzu_vip','2006-11-27 01:31:16','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2455,'protected'),('utilizator/aln','Profil aln','2006-11-27 01:31:28','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2511,'protected'),('utilizator/sims_gl','Profil sims_gl','2006-11-27 01:31:33','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2524,'protected'),('utilizator/sdmagor','Profil sdmagor','2006-11-27 01:31:37','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2537,'protected'),('utilizator/cioryboy','Profil cioryboy','2006-11-27 01:31:40','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2546,'protected'),('utilizator/brenda','Profil brenda','2006-11-27 01:31:49','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2580,'protected'),('utilizator/adrian_006','Profil adrian_006','2006-11-27 01:32:00','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2631,'protected'),('utilizator/adinachiv','Profil adinachiv','2006-11-27 01:32:36','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2794,'protected'),('utilizator/clau12345','Profil clau12345','2006-11-27 01:32:39','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2807,'protected'),('utilizator/ana724','Profil ana724','2006-11-27 01:33:05','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2928,'protected'),('utilizator/marius_902002','Profil marius_902002','2006-11-27 01:33:19','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2986,'protected'),('utilizator/popmar72','Profil POPMAR72','2006-11-27 01:33:33','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3044,'protected'),('utilizator/victor_onaga','Profil victor_onaga','2006-11-27 01:33:44','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3095,'protected'),('utilizator/bogdanbl','Profil BogdanBl','2006-11-27 01:34:27','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3257,'protected'),('utilizator/dragosh','Profil dragosh','2006-11-27 01:34:33','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3280,'protected'),('utilizator/skynet','Profil Skynet','2006-11-27 01:34:50','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3353,'protected'),('utilizator/alexxxx','Profil Alexxxx','2006-11-27 01:34:54','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3369,'protected'),('utilizator/ursusevastian','Profil ursusevastian','2006-11-27 01:35:01','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3403,'protected'),('utilizator/faxmodem','Profil faxmodem','2006-11-27 01:35:16','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3467,'protected'),('utilizator/filipman','Profil filipman','2006-11-27 01:35:19','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3481,'protected'),('utilizator/smi','Profil smi','2006-11-27 01:37:02','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3883,'protected'),('utilizator/daysleeper','Profil daysleeper','2006-11-27 01:37:15','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3935,'protected'),('utilizator/bmihai','Profil bmihai','2006-11-27 01:37:21','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3959,'protected'),('utilizator/denis','Profil denis','2006-11-27 01:37:23','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',3968,'protected'),('utilizator/adrienne','Profil adrienne','2006-11-27 01:37:38','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4030,'protected'),('utilizator/redskirt','Profil redskirt','2006-11-27 01:37:42','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4049,'protected'),('utilizator/lrazvan','Profil lrazvan','2006-11-27 01:37:58','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4115,'protected'),('utilizator/irina_marincas','Profil irina_marincas','2006-11-27 01:38:05','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4140,'protected'),('utilizator/febra_oji','Profil Febra_OJI','2006-11-27 01:38:09','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4159,'protected'),('utilizator/testall','Profil testall','2006-11-27 01:38:24','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4197,'protected'),('utilizator/nicol','Profil nicol','2006-11-27 01:38:54','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4313,'protected'),('utilizator/moraru','Profil moraru','2006-11-27 01:38:55','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4318,'protected'),('utilizator/villy_the_first','Profil Villy_the_first','2006-11-27 01:39:00','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4340,'protected'),('utilizator/moldi','Profil moldi','2006-11-27 01:39:03','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4351,'protected'),('utilizator/pleasure','Profil Pleasure','2006-11-27 01:39:05','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4357,'protected'),('utilizator/tudor_tudy','Profil tudor_tudy','2006-11-27 01:39:29','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4429,'protected'),('utilizator/vinete','Profil vinete','2006-11-27 01:39:42','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4481,'protected'),('utilizator/eta_trial','Profil eta_trial','2006-11-27 01:40:28','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4663,'protected'),('utilizator/voronoi','Profil voronoi','2006-11-27 01:40:32','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4681,'protected'),('downloads','Downloads','2007-01-29 18:24:28','h1. Downloads\r\n\r\nh2. OJI (5 link-uri)\r\n\r\n* \'OJI 2001\':downloads?subiecteJudete.zip ( _613095_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele de la Olimpiada Judeteana de Informatica, anul 2001.\r\n* \'OJI 2002\':downloads?oji2002.zip ( _798994_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale la Olimpiada Judeteana de Informatica, anul 2002.\r\n* \'OJI 2003\':downloads?oji2003.zip ( _1097174_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale la Olimpiada Judeteana de Informatica, anul 2003.\r\n* \'OJI 2004\':downloads?oji2004.zip ( _744932_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale la Olimpiada Judeteana de Informatica, anul 2004.\r\n* \'OJI 2005\':downloads?oji2005.zip ( _365217_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale la Olimpiada Judeteana de Informatica, anul 2005.\r\n\r\nh2. ONI (5 link-uri)\r\n\r\n* \'ONI 2005\':downloads?oni2005.zip ( _6338659_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele, testele si solutiile oficiale din cadrul Olimpiadei Nationale de Informatica 2005, Galati.\r\n* \'ONI Gimnaziu 2002-2005\':downloads?onigim.zip ( _6020215_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele, solutiile si rezultatele de la Olimpiada Nationala pentru Gimnaziu, anii 2002-2005.\r\n* \'ONI2003\':downloads?oni03.zip ( _9734608_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-02-24 )\r\nSubiectele propuse in cadrul olimpiadei nationale de informatica 2003\r\n* \'ONI 2004\':downloads?ONI04.zip ( _7812828_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-02-21 )\r\nSubiectele propuse in cadrul olimpiadei nationale de informatica 2004\r\n* \'ONI2002\':downloads?ONI02.ZIP ( _2575564_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-02-21 )\r\nSubiectele propuse in cadrul olimpiadei nationale de informatica 2002\r\n\r\nh2. Lot (3 link-uri)\r\n\r\n* \'lot2004\':downloads?lot2004.rar ( _3434709_ bytes, ==user(user=\"cip\" type=\"tiny\")== @ 2006-02-04 )\r\nSubiectele, testele si solutiile oficiale din cadrul taberelor de pregatire ale lotolui largit, anul 2005.\r\n* \'lot2002\':downloads?lot2002.rar ( _1520669_ bytes, ==user(user=\"cip\" type=\"tiny\")== @ 2006-02-03 )\r\nSubiectele, testele si solutiile oficiale din cadrul taberelor de pregatire ale lotolui largit, anul 2002.\r\n* \'lot 2003\':downloads?lot2oo3.rar ( _15169596_ bytes, ==user(user=\"cip\" type=\"tiny\")== @ 2006-02-03 )\r\nSubiectele, testele si solutiile oficiale din cadrul taberelor de pregatire ale lotolui largit, anul 2003.\r\n\r\nh2. BOI (6 link-uri)\r\n\r\n* \'BOI 2005\':downloads?boi2005.zip ( _354783_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale de la BOI 2005 Grecia.\r\n* \'BOI 2004\':downloads?boi2004.zip ( _354835_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nProbleme si solutii oficiale de la BOI 2004\r\n* \'BOI 2003\':downloads?boi2003.zip ( _99072_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nProbleme si solutii oficiale de la BOI 2003\r\n* \'BOI 2002\':downloads?boi2002.zip ( _401602_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-08 )\r\nProbleme, solutii si rezultatele de la BOI 2002\r\n* \'BOI 2001\':downloads?boi2001.zip ( _16638_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-07 )\r\nProblemele de la BOI 2001\r\n* \'BOI 2000\':downloads?boi2000.zip ( _61296_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-06 )\r\nProblemele de la BOI 2000\r\n\r\nh2. CEOI (6 link-uri)\r\n\r\n* \'CEOI 2005\':downloads?ceoi2005.zip ( _1067059_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale de la CEOI 2005 Ungaria.\r\n* \'CEOI 2004\':downloads?ceoi-2004.zip ( _341294_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nProbleme, solutii oficiale si surse oficiale de la CEOI 2004 Polonia\r\n* \'CEOI 2003\':downloads?ceoi2003.zip ( _814025_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nProbleme, solutii oficiale si surse oficiale de la CEOI 2003 Germania\r\n* \'CEOI 2002\':downloads?ceoi2002.zip ( _316854_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-08 )\r\nProbleme, solutii oficiale si surse oficiale de la CEOI 2002 Slovacia\r\n* \'CEOI 2001\':downloads?CEOI_2001.zip ( _45819_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-07 )\r\nProbleme si solutii oficiale de la CEOI 2001 Ungaria\r\n* \'CEOI 2000\':downloads?CEOI_2000.zip ( _28537_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-06 )\r\nProblemele de la CEOI 2000 Romania\r\n\r\nh2. IOI (6 link-uri)\r\n\r\n* \'IOI 2005\':downloads?ioi2005.zip ( _584396_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale de la IOI 2005 Polonia.\r\n* \'IOI 2004\':downloads?ioi2004.zip ( _338911_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nSubiectele si solutiile oficiale de la IOI 2004 Grecia\r\n* \'IOI 2003\':downloads?ioi2003.zip ( _1213299_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nSubiecte in limba romana, solutii oficiale si rezultatele de la IOI 2003 USA\r\n* \'IOI 2002\':downloads?ioi2002.zip ( _1893445_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-08 )\r\nSubiecte, solutii, teste si handbook-ul de la IOI 2002 Coreea\r\n* \'IOI 2001\':downloads?IOI_2001.zip ( _465557_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-07 )\r\nSubiecte, solutii oficiale si rezultatele de la IOI 2001 Finlanda\r\n* \'IOI 2000\':downloads?IOI_2000.zip ( _1191184_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-06 )\r\nSubiecte, solutii oficiale si testele de la IOI 2000 China\r\n\r\nh2. USACO (5 link-uri)\r\n\r\n* \'USACO Gold - DEC05\':downloads?usaco.zip ( _2009498_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2006-01-31 )\r\nSetul de probleme si datele de test pentru concursul Usaco, diviza Gold, decembrie 2005. \r\n* \'Usaco Gold - NOV05\':downloads?usaco_nov05.zip ( _36878_ bytes, ==user(user=\"ditzonec\" type=\"tiny\")== @ 2005-11-22 )\r\nSetul de probleme si datele de test pentru concursul Usaco, diviza Gold, noiembrie 2005.\r\n* \'Usaco Gold - JAN05\':downloads?usaco_gold_jan05.zip ( _775374_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-03-02 )\r\nSetul de probleme, datele de test si clasamentul concursului Usaco, divizia Gold, ianuarie 2005.\r\n* \'Usaco Silver - DEC04\':downloads?silver.zip ( _736744_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-01-09 )\r\nSetul de probleme, testele si rezultatele concursului Usaco, divizia Silver, decembrie 2004 \r\n* \'Usaco Gold - DEC04\':downloads?gold_dec04.zip ( _1291870_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2004-12-20 )\r\nSetul de probleme, testele si rezultatele concursului Usaco, divizia Gold, decembrie 2004\r\n\r\nh2. BalticOI (6 link-uri)\r\n\r\n* \'BalticOI 2005\':downloads?baltic2005.zip ( _1781109_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale de la Olimpiada Baltica de Informatica 2005.\r\n* \'BalticOI 1995-1997\':downloads?boi1995_97.zip ( _1773528_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSolutiile oficiale si testele de la Olimpiada Baltica de Informatica, anii 1995 - 1997.\r\n* \'BalticOI 2004\':downloads?baltic2004.zip ( _74176_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nProbleme si solutii oficiale de la Olimpiada Baltica de Informatica 2004 \r\n* \'BalticOI 2003\':downloads?baltic2003.zip ( _560373_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nProbleme si solutii oficiale de la Olimpiada Baltica de Informatica 2003\r\n* \'BalticOI 2002\':downloads?baltic2002.zip ( _236152_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-08 )\r\nProbleme si solutii oficiale de la Olimpiada Baltica de Informatica 2002 \r\n* \'BalticOI 2001\':downloads?baltic2001.zip ( _326933_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-07 )\r\nProbleme si solutii oficiale de la Olimpiada Baltica de Informatica 2001\r\n\r\nh2. preONI (2 link-uri)\r\n\r\n* \'PreONI 2003\':downloads?preoni2.zip ( _32577_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nAl doilea concurs PreONI organizat de Stefan Ciobaca; majoritatea participantilor au fost membrii ai canalului #olimpiada. Formatul concursului a fost asemanator cu al primului concurs PreONI.\r\n* \'PreONI 2002\':downloads?preoni1.zip ( _316146_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nPrimul concurs PreONI organizat de Stefan Ciobaca si Mugurel Andreica; majoritatea participantilor au fost membrii ai canalului #olimpiada. Concurentii au avut de rezolvat 11 probleme in 24h.\r\n\r\nh2. Articole (4 link-uri)\r\n\r\n* \'Rotatie minim lexicografica\':downloads?Rotatie.pdf ( _131723_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2006-02-02 )\r\nUn articol scris de Mircea Pasoi in cadrul Gazetei de Informatica (www.ginfo.ro), numarul din decembrie 2005\r\n* \'Ghid complet pentru concursurile de informatica\':downloads?Ghid_complet_pentru_concursurile_de_informatica.pdf ( _162832_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2006-02-02 )\r\nUn articol scris de Mircea Pasoi in cadrul Gazetei de Informatica (www.ginfo.ro), numarul din octombrie 2005. \r\n* \'Cautari Ortogonale\':downloads?Cautari_Ortogonale.doc ( _80384_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-29 )\r\nAcest articol , scris de Cosmin Negruseri, prezinta algoritmi de cautari ortogonale, cat si aplicatii. Articolul a aparut si in Gazeta de Informatica 15/5, si a fost folosit initial la pregatirea lotului in 2005.\r\n* \'Arbori de intervale si aplicatii in geometria computationala\':downloads?arbori_de_intervale.zip ( _115043_ bytes, ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-11-10 )\r\nAcesta este un curs despre arbori de intervale si aplicatiile lor in geometria computationala. Cursul a fost predat de Prof. Dana Lica in cadrul sesiunii de pregatire a lotului largit de informatica 2004. Pe langa explicatii amanuntite veti gasi si exemple de cod sursa in C si Pascal.\r\n\r\nh2. Utilitare (1 link)\r\n\r\n* \'Rhide\':downloads?rhide-1.5.20050823.tbz2 ( _4344271_ bytes, ==user(user=\"azotlichid\" type=\"tiny\")== @ 2006-07-12 )\r\nBinar pentru RHIDE functional pentru cele mai multe distributii de Linux. Provided by ==user(user=\"thestick\" type=\"tiny\")== . Detalii despre instalare gasiti pe \'forum\':http://infoarena.ro/forum/index.php/topic,1005.0.html. \r\n',4148,'public'),('utilizator/stancovz','Profil stancovz','2006-11-27 01:40:53','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',4764,'protected'),('utilizator/cristinutza_g1989','Profil cristinutza_g1989','2006-11-27 01:42:05','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',5040,'protected'),('utilizator/madutza','Profil madutza','2006-11-27 01:42:16','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',5083,'protected'),('utilizator/ivanescu_miruna','Profil Ivanescu_miruna','2006-11-27 01:42:33','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',5147,'protected'),('utilizator/yourlove','Profil yourlove','2006-11-27 01:42:57','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',5237,'protected'),('utilizator/iuliavls','Profil iuliavls','2006-11-27 01:43:01','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',5252,'protected'),('utilizator/hajek_hajni','Profil hajek_hajni','2006-11-27 01:43:12','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',5292,'protected'),('utilizator/jsin','Profil jsin','2006-11-27 01:43:36','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',5383,'protected'),('preoni-2005/clasament-9-10','Clasament preoni5a','2006-11-25 13:48:16','h1.  Clasament global preONI 2005 (Clasele IX-X)\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni52a|preoni53a\")==',961,'protected'),('preoni-2005/clasament-11-12','Clasament preoni5b','2006-11-25 13:48:12','h1.  Clasament global preONI 2005 (Clasele XI-XII)\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni52b|preoni53b\")==',961,'protected'),('preoni-2005/runda-1/clasament-9-10','Clasament preoni51a','2006-11-24 23:52:21','h1. Clasament ==roundparam(round_id=\"preoni51a\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni51a\")==',961,'protected'),('preoni-2005/runda-1/clasament-11-12','Clasament preoni51b','2006-11-24 23:53:42','h1. Clasament ==roundparam(round_id=\"preoni51b\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni51b\")==',961,'protected'),('preoni-2005/runda-2/clasament-9-10','Clasament preoni52a','2006-11-24 23:59:16','h1. Clasament ==roundparam(round_id=\"preoni52a\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni52a\")==',961,'protected'),('preoni-2005/runda-2/clasament-11-12','Clasament preoni52b','2006-11-25 00:00:04','h1. Clasament ==roundparam(round_id=\"preoni52b\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni52b\")==',961,'protected'),('preoni-2005/runda-3/clasament-9-10','Clasament preoni53a','2006-11-25 00:04:11','h1. Clasament ==roundparam(round_id=\"preoni53a\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni53a\")==',961,'protected'),('preoni-2005/runda-3/clasament-11-12','Clasament preoni53b','2006-11-25 00:05:25','h1. Clasament ==roundparam(round_id=\"preoni53b\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni53b\")==',961,'protected'),('preoni-2006/runda-2/clasament-9','Clasament preoni62a','2006-11-25 01:34:53','h1. Clasament ==roundparam(round_id=\"preoni62a\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni62a\")==',961,'protected'),('preoni-2006/runda-3','Runda 3, preONI 2006','2006-11-27 16:16:11','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Runda 3\r\n\r\nConcursul s-a desfasurat sambata, 21 ianuarie, la ora 09:00. Pe parcursul celor 4 ore de concurs participantii au avut de rezolvat 3 probleme. \r\n\r\nh2. Comisii\r\n\r\nh3. Stiintific\r\n\r\n* clasa a 9-a (si gimnaziu)\r\n** Adrian Diaconu\r\n** Daniel Pasaila \r\n* clasa a 10-a\r\n** Mircea Pasoi\r\n** Tiberiu Florea \r\n* clasele 11-12\r\n** Cosmin Negruseri\r\n** Adrian Vladu\r\n** Silviu Ganceanu\r\n\r\nh3. Organizatoric\r\n\r\nPentru intrebari de factura organizatorica / tehnica poti contacta urmatoarele persoane:\r\n\r\n* Cristian Strat\r\n* Crestez Leonard \r\n\r\nh2. Solutii\r\n\r\nSolutiile problemelor le puteti gasi \"aici\":preoni-2006/runda-3/solutii\r\n\r\nh2. Clasa a 9-a si gimnaziu (\'Clasament\':preoni-2006/runda-3/clasament-9)\r\n\r\n!>preoni-2006/runda-3?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni63a\" pager_style=\"none\") ==\r\n\r\nh2. Clasa a 10-a(\'Clasament\':preoni-2006/runda-3/clasament-10)\r\n\r\n!>preoni-2006/runda-3?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni63b\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':preoni-2006/runda-3/clasament-11-12)\r\n\r\n!>preoni-2006/runda-3?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni63c\" pager_style=\"none\") ==\r\n\r\n==include(page=\"template/preoni-2006/footer\")==',13,'protected'),('preoni-2006/runda-3/clasament-11-12','Clasament preoni63c','2006-11-25 01:42:55','h1. Clasament ==roundparam(round_id=\"preoni63c\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni63c\")==',961,'protected'),('preoni-2006/runda-3/clasament-10','Clasament preoni63b','2006-11-25 01:43:01','h1. Clasament ==roundparam(round_id=\"preoni63b\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni63b\")==',961,'protected'),('preoni-2006/runda-3/clasament-9','Clasament preoni63a','2006-11-25 01:43:07','h1. Clasament ==roundparam(round_id=\"preoni63a\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni63a\")==',961,'protected'),('preoni-2006/runda-4/clasament-11-12','Clasament preoni64c','2006-11-25 02:53:06','h1. Clasament ==roundparam(round_id=\"preoni64c\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni64c\")==',961,'protected'),('preoni-2006/runda-4/clasament-10','Clasament preoni64b','2006-11-25 02:53:12','h1. Clasament ==roundparam(round_id=\"preoni64b\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni64b\")==',961,'protected'),('preoni-2006/runda-4/clasament-9','Clasament preoni64a','2006-11-25 02:53:20','h1. Clasament ==roundparam(round_id=\"preoni64a\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni64a\")==',961,'protected'),('preoni-2006/finala','Finala in Focsani, preONI 2006','2006-12-01 18:28:26','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Finala in Focsani \r\n\r\n*Primii 10* concurenti de la fiecare grupa din clasamentul rundelor online (#1 + #2 + #3 + #4) sunt invitati la runda finala. Aceasta se va desfasura in *Focsani*, mai exact:\r\n\r\n* cazare + mic dejun la *Hotel Unirea, Focsani*\r\n* concursul on-site la *{\'Colegiul National Unirea\':http://cnu.lufo.ro/}*\r\n\r\n\'Premiile concursului\':preoni-2006/premii preONI se vor acorda in functie de rezultatele rundei finale. Punctajele obtinute in perioada de calificare vor servi doar la departajare.\r\nPentru concurentii care nu s-au calificat in finala, vom gazdui si o varianta online. Aveti ocazia sa va comparati performanta cu cei care au ajuns in finala! ;)\r\n\r\nh2. Probleme\r\n\r\nSolutiile problemelor le puteti gasi \"aici\":preoni-2006/finala/solutii.\r\n\r\nh3. Clasa a 9-a si gimnaziu (\'Clasament\':preoni-2006/finala/clasament-9)\r\n\r\n!>preoni-2006/finala?logo.jpg!\r\n\r\n== Tasks(round_id=\"preoni65a\" pager_style=\"none\") ==\r\n\r\nh3. Clasa a 10-a(\'Clasament\':preoni-2006/finala/clasament-10)\r\n\r\n!>preoni-2006/finala?logo.jpg!\r\n\r\n== Tasks(round_id=\"preoni65b\" pager_style=\"none\") ==\r\n\r\nh3. Clasele 11-12 (\'Clasament\':preoni-2006/finala/clasament-11-12)\r\n\r\n!>preoni-2006/finala?logo.jpg!\r\n\r\n== Tasks(round_id=\"preoni65c\" pager_style=\"none\") ==\r\n\r\nh2. Sponsori finala\r\n\r\nSponsorii finalei sunt:\r\n\r\n\"!preoni-2006?Oracle_ro.gif!\":http://www.oracle.com/global/ro/index.html\r\n\r\n\"Colegiul National Unirea, Focsani\":http://cnu.lufo.ro/\r\n\r\n*Hotel Unirea, Focsani*\r\n\r\nMultumim d-lui *Prof. Emil Onea* pentru ca a facut posibila organizarea acestei finale!\r\n\r\nh2. Calificare \r\n\r\nCalificarea in aceasta etapa se face exclusiv pe baza clasamentului din primele 4 runde. De la fiecare grupa vor fi selectati ocupantii primelor *10* pozitii. Mentionam ca o persoana se poate califica la finala doar la grupa destinata lui si ca se va face si o identificare prin intermediul Cartii de Identiate (Buletin) pentru a evita frauda. Daca aveti nelamuriri revedeti si \'regulamentul\':preoni-2006/regulament. \r\nConcurentiilor li se vor asigura cazarea si *masa integral*. Costul transportului pana la locul unde se va desfasura finala va fi suportat de catre concurenti. Pentru motivarea absentelor pe perioada finalei se va elibera un document oficial.\r\n\r\nh2. Program \r\n\r\nIntrucat programul elevilor este in general incarcat in aceasta perioada, durata rundei finale este de numai *3 zile*. Perioada de desfasurare: *24-26 martie 2006* (vineri, sambata, duminica). Teoretic, luni sunteti inapoi la scoala :) Va rugam sa vizitati aceasta sectiune periodic pentru a fi la curent. Programul provizoriu al finalei este:\r\n\r\n|_. Ziua |_. Actvitate |\r\n| *24 martie 2006* | Sosirea participantilor\r\nDeschidere oficiala\r\nAcomodare |\r\n| *25 martie 2006* | Concurs (dimineata)\r\nPrezentare ORACLE\r\nEvaluare si contestatii\r\nPremiere\r\nCina festiva |\r\n| *26 martie 2006* | Excursie la _Valea Putnei_\r\nPlecare |\r\n\r\nConcursul va dura *5* ore in care concurentii vor primi spre rezolvare *3* probleme cu grad de dificultate un pic mai ridicat decat cel de la etapele anterioare. Programul nu este fix, si asteptam sugestii din partea voastra.\r\nCei care nu s-au calificat in runda finala vor putea sa participe in paralel on-line pe _infoarena_. Modul de desfasurare va fi identic cu acela al primelor patru. Participantii online nu vor primii premii.\r\n\r\nh2. Mediul de lucru \r\n\r\nRunda finala se desfasoara in laboratoarele de informatica ale *{\'Colegiului National Unirea\':http://cnu.lufo.ro/}* din Focsani. Vom incerca sa punem la dispozitia concurentilor aceleasi versiuni de compilatoare ca cele folosite pe site in timpul rundei. Asteptam sugestiile voastre in privinta soft-ului care doriti sa fie instalat pe calculatoare.\r\n\r\nh2. Regulament \r\n\r\nPe langa \'regulamentul concursului\':preoni-2006/regulament, la editia finala vor exista urmatoarele adaugiri la regulament pentru cei calificati. \'Echipa infoarena\':echipa-infoarena isi rezerva dreptul de a modifica acest regulament in orice fel pana la data desfasurarii finalei.\r\n\r\n* Concurentii vor fi prezenti in salile de concurs la orele anuntate\r\n* Fiecare concurent va primi subiectele in forma listata si foi pentru ciorne (pix nu este inclus)\r\n* Timp de 1 ora dupa primirea subiectelor concurentii pot formula intrebari referitoare la enunturile problemelor; intrebarile se vor formula in scris, pe foaia cu intrebari fiind precizate numele problemei si al concurentului; modalitate de formulare a intrebarile este identica cu cea de la primele 4 runde\r\n* In timpul probelor de concurs, concurentii:\r\n** nu vor avea asupra lor telefoane mobile sau alte mijloace de comunicatie\r\n** nu vor utiliza suporturi externe proprii (dischete/CD/flash-disk)\r\n** nu vor utiliza alte surse de documentare decat cele prezente pe calculator\r\n** nu vor incerca sa interfereze in nici un mod cu activitatile altui concurent\r\n** nu vor deteriora mediile de lucru\r\n** nu vor incerca sa interfereze cu sistemul de evaluare\r\n* In programele concurentilor nu sunt permise urmatoarele:\r\n** schimbarea drepturilor de acces la fisiere\r\n** atacul asupra securitatii sistemului sau evaluatorului\r\n** accesarea informatiilor despre sistemul de fisiere\r\n** executarea unor alte programe\r\n\r\nOrice incercare de frauda sau de a sabota desfasurarea corecta a concursului va fi urmata imediat de eliminarea elevului respectiv din concurs, cat si de pe _infoarena_.\r\n\r\nh2. Participanti \r\n\r\n\'Click aici\':preoni-2006/clasament pentru clasamentul rundelor online.\r\nLista oficiala a participantilor va fi anuntata dupa ce validam identitatea celor calificati online.\r\n\r\nh2. Divertisment :p \r\n\r\nCa sa nu ne plictisim vom pleca intr-o excursie la _Valea Putnei_ pentru a discuta informatica si calculatoare intr-un cadru aparte. :)',1142,'protected'),('utilizator/silviug','Profil silviug','2006-11-27 01:23:00','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',15,'protected'),('utilizator/ira','Profil ira','2006-11-27 01:23:14','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',93,'protected'),('template/userrating','template/userrating','2006-12-08 04:32:20','h2. Rating %user%\r\n\r\np. ! http://infoarena.ro/plot/rating?user=%user% (Evolutie rating %user%) !\r\n\r\nh3. Concursuri cu rating la care a participat\r\n\r\n==Rounds(user=\"%user%\" only_rated=\"1\")==\r\n\r\np. ! http://infoarena.ro/plot/distribution?user=%user% (Distributie rating %user%) !\r\n\r\n*{\"Ce inseamna si cum se calculeaza rating-ul?\":documentatie/rating}*',13,'protected'),('home','infoarena 2','2007-01-27 17:02:57','&nbsp;\r\n\r\ntable=. |_=. \'*Unirea 2007, concurs cu premii si diplome&hellip;*\':unirea-2007 |\r\n\r\np. Acesta este *noul site infoarena*! Am inlocuit vechiul infoarena.devnet.ro dupa aproape 3 ani de functionare.\r\nSunt multe de spus despre noua versiune asa ca incepem cu ce e mai important ...\r\n\r\ntable(layout3). | *infoarena este un wiki*\r\nSchimba continutul paginilor sau sa creaza pagini noi.\r\n\'Afla mai multe&hellip;\':documentatie/wiki\r\n| *infoarena iti da rating*\r\nIti calculam rating-ul: un numar care reflecta performantele tale.\r\n\'Afla mai multe&hellip;\':documentatie/rating\r\n| *Forum integrat*\r\nAm avut grija ca forum-ul sa fie bine integrat in experienta infoarena.\r\n\'Afla mai multe&hellip;\':documentatie/forum |\r\n| *Fa-ti pagina personala*\r\nPrezinta-te comunitatii infoarena: cine esti, de unde vii, distinctii primite etc.\r\n\'Afla mai multe&hellip;\':documentatie/pagina-de-profil\r\n| *Un nou evaluator*\r\nEvaluatorul nou masoara mai exact timpii de executie si suporta tipuri noi de probleme si concursuri.\r\n\'Afla mai multe&hellip;\':documentatie/evaluator\r\n| *Mai usor de folosit*\r\nNoul infoarena este mai usor de navigat si de folosit.\r\n\'Afla mai multe&hellip;\':documentatie/pentru-utilizatori |\r\n\r\nh1. Ne trebuie feedback!\r\n\r\nNe asteptam sa gasim multe bug-uri si deficiente in noua versiune. Ajuta-ne sa facem o infoarena ca _Soarele sfant de pe cer_ :)\r\nAsteptam bug reports, sugestii, intrebari pe forum. Iata niste topic-uri de feedback:\r\n\r\n==SmfTopics(board_id=\"33\")==\r\n\r\nh1. Ce este infoarena?\r\n\r\ninfoarena este un site web care ajuta elevi si studenti sa obtina performanta in informatica! \'Afla mai multe&hellip;\':despre-infoarena\r\n\r\nCu ce ne ocupam?\r\n\r\n* Concursuri online de informatica pentru studenti si elevi\r\n* Stiri si articole despre informatica\r\n* Discutam pe forum tot despre informatica\r\n\r\nDaca stii PHP / tehnologii web / webdesign sau vrei sa inveti alaturi de noi, intra pe \"pagina de development\":documentatie/development. \r\n\r\nh1. Ultimele Stiri\r\n\r\n==News(pager_style=\"none\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':stiri',13,'protected'),('stiri/unirea-2007','Concursul Unirea 2007','2007-01-24 01:31:16','infoarena organizeaza concursul de informatica Unirea 2007.\r\n\r\nConcursul, la care castigatorii vor primi diplome si premii, incepe *Sambata, 27 ianuarie la ora 14^00^* si dureaza *3h*.\r\n\r\nInformatii se gasesc pe \'pagina concursului\':unirea-2007.',13,'public'),('preoni-2007','preONI 2007','2007-01-21 15:08:23','==Include(page=\"template/preoni-2007\")==\r\n\r\npreONI, concursul de pregatire pentru Olimpiada Nationala de Informatica, a ajuns la a patra editie.\r\n\r\npreONI 2007 incepe cu 4 runde online de calificare. Cei mai buni de la fiecare grupa sunt invitati la finala on-site. Castigatorii rundei finale sunt premiati in bani si obiecte.\r\n\r\np. &rarr; \'Remember preONI 2006\':preoni-2006\r\n\r\nh2. Program concurs\r\n\r\ntable{width: 50%}. |_. Runda|_. Data |_. Ora |\r\n|\"*Runda 1*\":preoni-2007/runda-1|*Duminica, 21 ianuarie 2007*| *09^00^ - 13^30^* |\r\n|\"Runda 2\":preoni-2007/runda-2|_Duminica, 18 februarie 2007_| _09^00^ - 13^00^_ |\r\n|\"Runda 3\":preoni-2007/runda-3|_Duminica, 4 martie 2007_| _09^00^ - 13^00^_ |\r\n|\"Runda 4\":preoni-2007/runda-4|_Duminica, 25 martie 2007_| _09^00^ - 13^00^_ |\r\n|\"Runda finala\":preoni-2007/finala| _6-8 aprilie 2007_ |  |\r\n\r\nClick pe titlul unei runde pentru informatii detaliate.\r\n\r\nDatele scrise _inclinat_ sunt provizorii. Este posibil sa le schimbam pe parcurs.\r\n\r\nh2. Despre preONI\r\n\r\npreONI, concursul de marca al comunitatii infoarena, este dedicat elevilor de liceu ce se pregatesc pentru ONI (\'Olimpiada Nationala de Informatica\':http://olimpiada.info/).\r\n\r\nConcursul este impartit in 3 grupe: clasa a IX-a si gimnaziu, clasa a X-a si clasele XI-XII. Se organizeaza 4 runde online de calificare. In urma acestora, cei mai buni de la fiecare grupa sunt invitati la o \'runda finala\':preoni-2007/finala.\r\n\r\nIn cadrul unei runde, concurentii au de rezolvat 3 probleme in 4 ore. Castigatorii rundei finale sunt premiati cu bani si/sau obiecte.\r\n\r\nVezi \'preONI 2006\':preoni-2006, \'preONI 2005\':preoni-2005.\r\n\r\nh2. Cum particip?\r\n\r\nInainte de toate trebuie sa \'te inregistrezi\':register pe site-ul nostru.\r\n\r\nOricine este invitat sa participe. In ziua de concurs intri pe site, citesti probleme, le rezolvi si trimiti solutiile inainte de expirarea timpului de lucru. La sfarsitul rundei, \'evaluatorul\':evaluator infoarena iti va testa solutiile pentru corectitudine. Clasamentul se va actualiza in timp real pe parcursul evaluarii.\r\n\r\nPoti sa rezolvi probleme de la orice grupa de varsta. Totusi, te vei califica la runda finala numai daca te incadrezi in grupa la care ai concurat.\r\n\r\nh2. Prima data pe infoarena?\r\n\r\ninfoarena ajuta elevi si studenti sa devina excelenti in informatica! Gratuit ;) \'Citeste mai multe\':despre-infoarena despre noi.\r\n\r\nVezi \'ghidul utilizatorului\':documentatie/pentru-utilizatori.\r\n\r\n==include(page=\"template/preoni-2007/footer\")==\r\n',1,'protected'),('documentatie/pagina-de-profil','Fa-ti pagina de profil!','2006-12-11 02:12:27','h1. Fa-ti pagina de profil!\r\n\r\n==include(page=\"template/todo\")==\r\n\r\n* Autentifica-te (\'login\':login)\r\n* Viziteaza-ti pagina ta de profil (click pe avatar/username din coltul din dreapta sus al ecranului)\r\n* Click pe _Editeaza_\r\n\r\nCa sa formatezi textul va trebui sa folosesti \'sintaxa textile\':documentatie/textile. Afla mai multe despre cum se editeaza paginile infoarena \'din documentatie\':documentatie/wiki.\r\n\r\nh2. Ce sa scriu in pagina de profil?\r\n\r\nAceasta este pagina cu care te prezinti comunitatii infoarena. Ne-ar interesa sa stim cine esti, unde inveti, profesori pregatitori, distinctii primite, carti si probleme preferate samd.\r\n\r\nEsti liber sa scrii ce doresti dar nu exagera si nu incalca \'regulamentul infoarena\':regulament.\r\n\r\nh2. De ce sa-mi fac pagina de profil?\r\n\r\nInfoarena nu este doar un site cu probleme, ci o comunitate de elevi si studenti interesati de programare si informatica. Ne facem fiecare o pagina de profil ca sa ne prezentam / sa ne cunoastem mai bine.\r\n',13,'protected'),('documentatie/pentru-propunatori','Pentru propunatori','2006-12-10 17:39:32','h1. Pentru propunatori.\r\n\r\nUnul dintre principalele motive pentru care noi am rescris infoarena este ca sa facem mai usor sa propui probleme. Momentan aceste facilitati nu sunt gata, dar vor fi in curand.\r\n\r\nDa ca stii sa programezi in php/mysql (sau vrei sa inveti) poti sa ne ajuti si pe partea de \'web-development\':documentatie/development.',1142,'public'),('template/despre-infoarena','template/despre-infoarena','2007-01-15 15:39:24','(vmenu)* \'Despre infoarena\':despre-infoarena\r\n* \'Regulament\':regulament\r\n* \'Echipa\':echipa-infoarena\r\n* \'Colaboratori\':colaboratori\r\n* \'Asociatia infoarena\':asociatia-infoarena\r\n',1,'protected'),('despre-infoarena','Despre infoarena','2007-01-15 15:37:55','h1. Despre infoarena\r\n\r\n==include(page=\"template/despre-infoarena\")==\r\n\r\n*infoarena ajuta elevi si studenti sa devina excelenti in informatica!* Gratuit ;)\r\n\r\nh2. Cu ce ne ocupam?\r\n\r\n* Concursuri online de informatica pentru studenti si elevi\r\n* Stiri si articole despre informatica\r\n* Discutam pe forum tot despre informatica\r\n* Cateodata organizam concursuri on-site.\r\n\r\ninfoarena functioneaza din 2002 si este dezvoltata de noi, \'echipa infoarena\':echipa-infoarena.\r\nSuntem o mana de studenti si elevi innebuniti de info. Tinem neaparat sa-i ajutam si pe altii sa innebuneasca :)\r\n\r\nComunitatea noastra cuprinde aproape toti elevii romani ce participa la concursuri de informatica nationale si internationale. Ne mandrim cu valoarea concursurilor si a materialelor prezentate pe site.\r\n\r\nDemn de mentionat este evaluatorul infoarena, un program care evalueaza solutiile trimise de concurenti. Evaluatorul iti spune aproape instantaneu daca (si cat de bine) ai rezolvat o problema (\"vezi Evaluator\":documentatie/evaluator).\r\n\r\nh2. Citate\r\n\r\n&nbsp;\r\n\r\nbq. People have been known to achieve more as a result of working with others than against them.\r\n\r\n*Dr. Allan Fromme*\r\n\r\n&nbsp;\r\n\r\nbq. infoarena este un proiect remarcabil, realizat cu entuziasm, generozitate si profesionalism. Este locul in care tinerii pasionati de informatica se pot intalni, atat de o parte, cat si de cealalta parte a baricadei, ca propunatori sau ca rezolvitori de probleme, isi pot impartasi experienta competitionala, pot constitui modele, pot ajuta la formarea a noi si noi generatii de performanta.\r\n\r\n*Emanuela Cerchez*\r\nCoordonator stiintific in Comisia Nationala de Informatica, Prof. grad I - Lic. de Informatica \"Grigore Moisil\" Iasi\r\n\r\n&nbsp;\r\n\r\nbq. infoarena e plin de energie, e dinamic si riguros, gratie unei echipe curajoase. Site-ul infoarena reprezinta cea mai originala forma de pregatire pe net a performerilor in informatica din Romania. Mecanism de lucru excelent, probleme propuse, fara cusur. Felicitari!\r\n\r\n*Emil Onea*\r\nInspector scolar informatica, Comisia Nationala de Informatica pentru Invatamant Preuniversitar\r\n',1,'public'),('documentatie/evaluator','Evaluatorul infoarena','2007-01-18 03:22:35','h1. Evaluatorul infoarena\r\n\r\n... este responsabil de evaluarea solutiilor trimise de utilizator.\r\n\r\nh2. Cum se evalueaza o problema\r\n\r\nMai intai, codul sursa trimis de concurent se compileaza (vezi tabelul de mai jos). Apoi, solutia se _evalueaza_: se ruleaza programul compilat pentru diferite date de intrare (teste). In urma rularii, un program specializat decide daca raspunsul dat de solutia concurentului este corect si acord un punctaj pe masura.\r\n\r\nFiecare program compilat are dreptul de a rula doar un anumit interval de timp (specificat in descrierea problemei). in cazul in care timpul de executie este depasit, programul este terminat automat de sistem. Analog, se pot impune si limite de memorie.\r\n\r\nEvaluarea se face intr-un mediu restrictionat. Programele compilate pot citi/scrie fisiere doar din/in directorul curent si nu au acces la unele functii sistem.\r\n\r\nh2. Compilatoare folosite\r\n\r\nIata *lista oficiala* de compilatoare folosite de evaluatorul infoarena:\r\n\r\n|_. Compilator si versiune|_. Comanda de compilare |_. Extensie implicita |\r\n| GNU GCC 3.3.5 | $gcc -Wall -O2 -static &hellip; -lm$ | c |\r\n| GNU G++ 3.3.5 | $g++ -Wall -O2 -static &hellip; -lm$ | cpp |\r\n| FreePascal Compiler 202 | $fpc -O2 -Xs &hellip;$               | pas |\r\n\r\nh2. Configuratia sistemului de evaluare\r\n\r\nEvaluatorul ruleaza pe un calculator dedicat, oferit de ==User(type=\"tiny\" user=\"fluffy\")==. (Multumim, Leo!)\r\n\r\n* Sistem de operare: Debian stable(sarge)\r\n* Procesor: Pentium IV, $2.0 GHz$\r\n* Memorie: $512 MB RAM$\r\n\r\nh2. Gazduire !>documentatie/evaluator?hqn.png!\r\n\r\nEvaluatorul infoarena este gazduit cu placere de catre \"HQN (High Quality Networks)\":http://hqn.ro/.\r\n\r\nh2. Mesage de evaluare.\r\n\r\nPentru cei care nu sunt familiari cu sistemele unix sau sunt incepatori in programare, multe dintre mesajele evaluatorului pot parea oarecum criptice.\r\n\r\n* Eroare de sistem: Daca ai obtinut aceast mesaj te rugam sa ne contactezi, preferabil pe \'forum\':forum. Te rugam sa mentionezi si id-ul job-ului.\r\n* OK: Totul a functionat perfect.\r\n* Memory limit exceeded: Ai depasit limita de memorie. Majoritatea problemelor au o limita de 64 de mega, pe care noi o consideram destul de generoasa.\r\n* Time limit exceeded: Programul tau a depasit limita de timp. Asta inseamna ca programul tau nu este destul de rapid.\r\n* Wall time limit exceeded: Evaluarea a durat prea mult si a fost abandonata. Evaluatorul infoarena masoara doar timpul folosit de programul tau pentru a determina daca iti da TLE, dar exista si o limita fata de \"ceasul de perete\". Acest mesaj poti sa il obtii daca faci sleep, scanf de la stdin si alte functii care stau degeaba fara sa consume efectiv procesorul.\r\n* Non-zero exit status: Programul tau a returnat o valoare diferita de 0. Cel mai probabil ai uitat return 0; sau ceva similar.\r\n* Blocked system call: Ai accesat o functie la care nu ai access. Nu ar trebui sa primesti aceasta functie decat daca incerci explicit sa faci ceva interzis.\r\n* Killed by signal: Cea mai frecventa eroare cand ai un bug in program. Cand un program incalca anumite conventii in UNIX acel program primeste un \"semnal\" care de cele mai multe ori il opreste. Cateva semnale comune:\r\n** 11(SIGSEGV): Segmentation fault. Asta in 99% din cazuri inseamna ca ai probleme cu accesul la memorie. Ai iesit din limitele unui vector, ai facut stack overflow, etc.\r\n** 8(SIGFPE): Floating point error. Cauza cel mai frecvent de impartiri la 0.\r\n\r\nEvaluatoarele problemelor iti vor da si ele un mesaj scurt, cel mai frecvent ceva de genul \"OK\" sau \"Wrong Answer\", dar unii propunatorii au umor :).\r\n\r\nh2. Troubleshooting\r\n\r\nPentru programatorii in Borland C/Pascal este important de tinut minte ca evaluatorul infoarena este un mediu *foarte* diferit fata de dos. Cateva erori comune si cum pot fi rezolvate\r\n\r\n* Pe infoarena se face I/O din fisiere, nu de la stdin, stdout. Daca faci scanf de la stdin vezi obtine cel mai probabil \"Wall time limit exceeded\" (vezi mai sus) iar daca faci printf la stdout rezultatul tau va fi ignorat.\r\n* tipul int din GCC este pe 32 de biti, nu 16 ca in Borland C/C++, char - 8 biti, short - 16 biti, long - 32, long long - 64\r\n* folositi sprintf in loc de itoa sau ltoa.\r\n* programul de evaluare ruleaza pe un sistem de operare UNIX. Folositi \"\\n\" pentru terminarea liniei curente, nu \"\\r\\n\"\r\n* aveti grija ca functia main sa fie de tip int si sa intoarca 0 (return 0;)\r\n* nu folositi librarii dependente de sistemul de operare (ex. dos.h, graphics.h in C sau dos, crt, graph in pascal). Aceste librarii nu sunt necesare pentru a rezolva problemele de pe infoarena.\r\n* nu folositi modificatorii far, huge, _huge, __huge pentru ca nu exista in GCC. De asemenea, nu exista nici functiile care folosesc aceste tipuri de date (de ex. farmalloc, farfree etc.) si nici conceptul de memory model (tiny, small, medium, large, huge). De toate acestea nu mai e nevoie intrucat puteti avea acces la toata memoria prin functii standard si pointer-i standard - new, delete, malloc etc.',13,'protected'),('clasament-rating','Clasament dupa rating','2007-01-19 21:01:37','(htabs)*(active) \'Clasament dupa rating\':clasament-rating\r\n* \'Clasamentul arhivei de probleme\':clasament-arhiva\r\n\r\nh1. Clasament dupa \'rating\':documentatie/rating\r\n\r\nAcest clasament ordoneaza utilizatorii dupa *performantele obtinute in regim de concurs*.\r\nDoar o parte din utilizatorii infoarena au participat la concursuri cu rating. Marea majoritate au rezolvat numai probleme din arhiva.\r\n\r\n\'Afla mai multe\':/documentatie/rating despre rating.\r\n\r\n== TopRated() ==',3270,'public'),('clasament-arhiva','Clasamentul arhivei de probleme','2006-12-11 01:33:38','(htabs)* \'Clasament dupa rating\':clasament-rating\r\n*(active) \'Clasamentul arhivei de probleme\':clasament-arhiva\r\n\r\nh1. Clasamentul \'arhivei de probleme\':arhiva\r\n\r\nClasamentul arhivei ordoneaza membrii infoarena dupa punctele obtinute rezolvand problemele din arhiva.\r\nAcest clasament reflecta *munca depusa in pregatire* pe infoarena si nu performanta concurentului in regim de concurs.\r\n\r\n== Rankings(rounds=\"arhiva\") ==',13,'protected'),('documentatie/forum','Forum infoarena','2006-12-11 02:00:02','h1. Forum infoarena\r\n\r\n==include(page=\"template/todo\")==\r\n\r\nSite-ul infoarena integreaza un forum \'SMF\':http://www.simplemachines.org.\r\n\r\nAtunci cand iti creezi cont pe infoarena, ti se creaza automat un cont de acces si pe forum.\r\n\r\nAcceseaza forum-ul cu click pe tab-ul _forum_ din bara principala de navigare.\r\nPoti sa trimiti si sa primesti mesaje personale de la alti utilizatori. Click pe _mesaje_ in bara principala de navigare.\r\n\r\nUnele pagini precum \'prima pagina\':home sau \'arhiva de probleme\':arhiva afiseaza liste cu ultimelor discutii / mesaje aparute pe forum. Facand click in aceste lin-uri poti sa ajungi direct pe forum.',13,'public'),('documentatie/rating','Rating infoarena','2006-12-12 07:03:20','h1. Rating-ul infoarena\r\n\r\nSistemul de rating infoarena ofera un mod de a ordona si diferentia utilizatorii in functie de performantele acestora in regim de concurs. Rating-urile se calculeaza folosind elemente de statistica si probabilitati.\r\n\r\nEste important de retinut ca rating-ul unui utilizator se actualizeaza doar dupa finalizarea unui concurs organizat pe infoarena. Activitatea de pregatire din arhiva de probleme nu influenteaza rating-ul.\r\n\r\nh2. La ce serveste?\r\n\r\nSistemul de rating ideal ne-ar permite sa afirmam care dintre doi concurenti este _mai puternic_. Evident, acest sistem ideal nu exista (chiar notiunea de _mai puternic_ este discutabila), totusi putem aproxima unul.\r\n\r\nRating-ul infoarena te ajuta sa...\r\n\r\n* iti urmaresti *evolutia personala* in regim de concurs\r\n* iti raportezi performantele la ceilalti utilizatori infoarena\r\n\r\nh2. Cum imi cresc rating-ul?\r\n\r\nParticipa la concursurile infoarena si rezolva cat mai multe probleme. Tu iti vezi de treaba si rating-ul te urmareste :)\r\n\r\nh2. Cum se calculeaza?\r\n\r\ninfoarena foloseste un sistem de rating relativ standard numit \'Glicko\':http://math.bu.edu/people/mg/glicko/glicko.doc/glicko.html, adaptat la nevoile noastre.\r\n\r\nGlicko este un sistem de rating folosit in turnamentele de sah, o varianta imbunatatita a algoritmului larg acceptat \'ELO\':http://en.wikipedia.org/wiki/Elo_rating_system.\r\n\r\nh3. Distributie\r\n\r\n!http://infoarena.ro/plot/distribution!\r\n\r\nDin grafic se observa ca rating-urile infoarena aproximeaza \'distributia normala - Gauss\':http://en.wikipedia.org/wiki/Normal_distribution.  Desi asta nu dovedeste nimic in particular, e un semn bun ca algoritmul functioneaza :) Nota: Varful neasteptat de inalt dintre 450 si 500 se datoreaza utilizatorilor care au participat la prea putine concursuri.\r\n\r\nh3. Detalii despre implementare\r\n\r\nVezi direct \'codul sursa al implementarii noastre de Glicko\':http://hackers.devnet.ro/browser/trunk/infoarena2/common/rating.php.\r\nFata de \'algoritmul standard Glicko\':http://math.bu.edu/people/mg/glicko/glicko.doc/glicko.html, am modificat urmatoarele:\r\n\r\n* Glicko a fost inventat pentru jocuri de sah (sau, mai general, jocuri head-to-head) insa concursurile de informatica includ mai multi participanti. Astfel, consideram fiecare pereche de concurenti ca un joc head-to-head.\r\n* Functia care calculeaza scorul probabil (expected value) normalizeaza diferentele de rating mai mari decat $IA_RATING_MAX_DIFF$\r\n* Glicko acorda $0$ pentru infrangere, $1/2$ pentru remiza si $1$ pentru victorie. Am facut o functie care acorda un numar real din intervalul $[0, 1]$ in functie de \'deviatia standard\':http://en.wikipedia.org/wiki/Standard_deviation. Astfel, acordam un numar real in intervalul $[0, 1/2)$ pentru o infrangere, $1/2$ pentru o remiza, respectiv un numar in intervalul $(1/2, 1]$ pentru o victorie.\r\n',13,'public'),('colaboratori','Colaboratori infoarena','2007-01-15 15:40:19','h1. Colaboratori infoarena\r\n\r\n==include(page=\"template/despre-infoarena\")==\r\n\r\n==include(page=\"template/todo\")==\r\n\r\n',1,'public'),('regulament','Regulament','2006-12-11 03:21:52','h1. Regulamentul infoarena\r\n\r\n==include(page=\"template/despre-infoarena\")==\r\n\r\nIn afara de regulile de bun simt, pe care nu le scriem aici, la infoarena nu sunt prea multe restrictii&hellip;\r\n\r\n# *Distrati-va cat mai mult!* Faceti cunostinta cu alti oameni care va impartasesc interesele.\r\n# Castigati cat mai multe premii la concursurile gazduite aici.\r\n# Nu incercati sa trisati! Nu este distractiv. In plus, se penalizeaza cu descalificare.\r\n# Nu adaugati continut ofensiv pe paginile infoarena sau pe pagina personala\r\n',13,'protected'),('termeni-si-conditii','Termeni si conditii de utilizare a site-ului infoarena','2006-12-11 03:27:51','h1. Termeni si conditii de utilizare a site-ului infoarena\r\n\r\n==include(page=\"template/todo\")==\r\n\r\nPentru a folosi site-ul infoarena trebuie sa fii de acord cu urmatoarele conditii:\r\n\r\n* Vei respecta \'regulamentul\':regulament.\r\n* *Nu ne asumam responsabilitatea fata de continutul pe care utilizatorii il adauga pe site!* Ne straduim sa filtram si sa moderam ceea ce utilizatorii adauga / editeaza pe site dar nu garantam ca o vom face in timp util pentru tine.\r\n* Cu exceptia cazurilor in care se specifica altfel, continutul acestui site este sub licenta \'Creative Commons Attribution-NonCommercial 2.5.\':http://creativecommons.org/licenses/by-nc/2.5/.\r\n* Conditiile de utilizare se pot schimba in timp fara a fi informat in prealabil.',13,'protected'),('stiri/lansare-infoarena-2','Am lansat infoarena 2!','2006-12-14 13:03:44','h1. Am lansat infoarena 2!\r\n\r\nAm lansat infoarena 2!\r\nVechiul site (infoarena.devnet.ro), care ne-a servit timp de aproape 3 ani, a fost inchis.\r\n\r\nAfla mai multe despre noul infoarena vizitand pagina indicata mai sus.\r\n',4439,'public'),('ia_in_ie7','Cum arata infoarena in internet explorer 7','2006-12-11 06:25:56','Momentan, nici un bug vizibil in IE7.\r\n\r\n* FIXED -footer afisat prost-\r\n* FIXED -vezi partea din stanga, problema cu casuta cu utilizatorul pare rezolvata-\r\n\r\n* FIXED -inca un bug chiar pe pagina asta - ce se intampla ca daca imaginea nu incape in fereastra -- a se observa spatiul liber intre textul \'footer afisat prost\' si poza; daca fereastra este destul de mare sa incapa poza, spatiul dispare-\r\n',1490,'public'),('utilizator/slayerdme','Profil slayerdme','2006-12-13 16:29:18','== include(page=\"infoarena.ro/utilizator/slayerdme/test.html\") ==\r\n!slayerdme?test.html!\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1975,'protected'),('summer-challenge-unu','Summer Challenge Unu','2006-12-11 15:55:43','h1. Summer Challenge Unu\r\n\r\nConcursul s-a desfasurat pe 3/8/2006.\r\n\r\nConcursul a avut 3 probleme, care au fost adaugate in \'arhiva\':arhiva.\r\n\r\nArticolul cu solutii se gaseste \'aici\':summer-challenge-unu/solutii.\r\n\r\nh2. \'Clasament\':summer-challenge-unu/clasament\r\n\r\n!>summer-challenge-unu?logo!\r\n\r\n== Tasks(round_id=\"summer06\" pager_style=\"none\") ==',961,'protected'),('utilizator/meremy','Profil meREMY','2006-12-12 07:30:23','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',5425,'public'),('documentatie/editare-de-runde','documentatie/editare-de-runde','2006-12-12 16:53:29','Scrie aici despre documentatie/editare-de-runde',3775,'public'),('utilizator/domino','Profil domino','2007-01-27 10:26:23','h2. Despre mine\r\n\r\n*Studii:*\r\n\r\n* Colegiul National \"I. L. Caragiale\" Ploiesti\r\n* Universitatea Bucuresti, Facultatea de informatica\r\n\r\n*Profesori pregatitori:* Dana Lica\r\n\r\nh2. Distinctii primite\r\n\r\n*2006 (clasa a XII-a):*\r\n\r\n* Premiul I la etapa judeteana de informatica\r\n* Premiul II la concursul international de programare on-line Bitwise (http://www.bitwise.iitkgp.ernet.in/), in echipa cu Adrian Vladu  concurentii au fost majoritatea studenti\r\n* Locul I la concursul international USACO februarie 2006 (http://ace.delos.com/FEB06results), folosit si pentru selectarea lotului national de informatica din S.U.A.\r\n* Locul I la concursul international USACO martie 2006 (http://ace.delos.com/FEB06results), folosit si pentru selectarea lotului national de informatica din S.U.A.\r\n* Invitat alaturi de lotul american de informatica la USA International Computing Olympiad 2006 \r\n* Locul I la Olimpiada Nationala de Informatica, Targoviste\r\n* Locul al III-lea la faza finala a concursului international \".campion\"\r\n* Medalie de argint la Olimpiada Central Europeana de Informatica,Vrsar, Croatia, 8 iulie\r\n* Medalie de aur (locul 7) la Olimpiada Internationala de Informatica, Merida, Mexic, 20 august\r\n\r\n*2005 (clasa a XI-a):*\r\n\r\n* Premiul I la etapa judeteana de informatica\r\n* Locul I la Olimpiada Nationala de Informatica, Galati\r\n* Locul al IV-lea (premiu special) la faza finala a concursului national \".campion\",14-19 aprilie\r\n* Medalie de argint la Olimpiada Internationala de Informatica, Nowy Sacz, Polonia, 18 august\r\n* Premiul III la Concursul National \"Stelele Informaticii\", Bucuresti, 3-4 decembrie\r\n\r\n*2004 (clasa a X-a):*\r\n\r\n* Premiul I la etapa judeteana de informatica\r\n* Mentiune la Olimpiada Nationala de Informatica, Buzau (locul 4)\r\n* Premiul al III-lea la faza finala a concursului national \".campion\", 16 aprilie\r\n* Diploma de onoare pentru rezultate deosebite in Invatamantul de Excelenta Prahovean,17 mai\r\n* Mentiune la Concursul National de Informatica PACO, programare, 29 mai\r\n* Locul al II-lea la Concursul National de Soft \"Grigore Moisil\", Lugoj, programare, 13 iunie\r\n* Medalie de argint la Olimpiada Balcanica de Informatica, Plovdiv, Bulgaria, 9 iulie\r\n* Locul al II-lea la faza finala a concursului international \"Bursele Agora\", 25 septembrie\r\n\r\n*2003 (clasa a IX-a):*\r\n\r\n* Premiul al II-lea la etapa judeteana de informatica\r\n* Diploma de excelenta pentru rezultate la informatica in cadrul Centrului de Excelenta Ploiesti\r\n* Premiul I  la Olimpiada Nationala de Informatica, Focsani	\r\n* Diploma de Onoare oferita de grupul \"Romanians at Microsoft\", aprilie\r\n* Diploma de Merit pentru calificarea in lotul Olimpic National  de Informatica al Romaniei \r\n* Premiul I la Concursul National de Informatica InfoKids, Bucuresti, programare, 1 iunie\r\n* Diploma Excellentia pentru rezultate la Olimpiada Nationala de Informatica, 13 iunie\r\n* Premiul I la Concursul National \"Stelele Informaticii\", Bucuresti, noiembrie\r\n* Diploma \"Elevul Anului 2003\" pentru reprezentarea merituoasa a invatamantului ploiestean\r\n\r\n*2002 (clasa a VIII-a):*\r\n\r\n* Premiul I la Concursul National de Informatica InfoKids, Bucuresti, programare, 22 martie\r\n* Locul al II-lea la Olimpiada Nationala de Informatica pe Internet, Braila, clasa a IX-a\r\n* Premiul al II-lea la Concursul National de Soft \"Grigore Moisil\", Lugoj, programare\r\n* Premiul I la etapa judeteana de informatica, 8 iunie\r\n* Premiul I la Concursul National de Informatica PACO, Bucuresti, programare, 17 iulie \r\n* Locul I la Concursul National de Programare de la Satu Mare, 12 octombrie\r\n* Diploma de onoare acordata in cadrul Concursul National de Programare de la Satu Mare\r\n* Diploma acordata de Fundatia \"Excellentia 21\" Ploiesti pentru rezultate deosebite, octombrie \r\n\r\n*2001 (clasa a VII-a):*\r\n\r\n* Premiul al II-lea la etapa judeteana de limba engleza, 28 aprilie\r\n* Premiul I la Concursul National de Soft \"Grigore Moisil\", Lugoj, sectiunea pagini web\r\n* Premiul al III-lea la Concursul National de Soft \"Grigore Moisil\", Lugoj, sectiunea software\r\n* Locul al III-lea la Concursul National \"Multimedia & Games\", sectiunea jocuri, 12 iulie\r\n* Locul al II-lea la Concursul National \"Multimedia & Games\", sectiunea pagini web, 12 iulie\r\n* Premiul al III-lea la Concursul National de Informatica pentru gimnaziu, Galaciuc, august\r\n* Mentiune la Concursul National de Informatica de la Piatra-Neamt, 1 septembrie\r\n* Premiul I la Concursul National de Informatica PACO, Bucuresti, programare, 14 septembrie\r\n* Premiul II la Concursul National de Informatica PACO, Bucuresti, pagini web, 14 septembrie\r\n\r\n*2000 (clasa a VI-a):*\r\n\r\n* Premiul al III-lea la etapa judeteana de matematica, 13 mai\r\n* Premiul al II-lea la Concursul National de Soft \"Grigore Moisil\", Lugoj, sectiunea software\r\n* Mentiune la Concursul National de Soft \"Grigore Moisil\",Lugoj,sectiunea programare cls 5-6\r\n* Premiul I la Olimpiada Judeteana de Informatica (la clasele a VI-a, a VII-a si a VIII-a),14 mai\r\n* Premiul al III-lea la Concursul National de Informatica de la Piatra-Neamt, iunie\r\n* Premiu Special la Concursul National INFOeducatie Galaciuc, 17 iulie\r\n',1,'protected'),('utilizator/azotlichid','Profil azotlichid','2006-12-13 22:11:09','h2. Despre mine\r\n\r\n* Yes.\r\n* No.\r\n\r\nh2. Distinctii primite\r\n\r\n* This text does not exist.\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* ==User(user=\"cartman\" type=\"tiny\")==\r\n* ==User(user=\"chucknorris\" type=\"tiny\")==\r\n* ==User(user=\"eval\" type=\"tiny\")==\r\n\r\n',18,'protected'),('sandyxp','sandyxp','2006-12-13 11:25:27','Paginea mea... Still to come',909,'public'),('utilizator/tanasefl0rin9','Profil tanasefl0rin9','2006-12-14 05:43:16','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',5474,'public'),('cat','arbori bicolori','2006-12-14 13:09:30','Scrie aici despre cat',5505,'public'),('rabbits.jpg','rabbits.jpg','2006-12-15 16:03:12','what\'s up duck?',1931,'public'),('utilizator/anchidinraluca','Profil anchidinraluca','2007-01-03 16:25:50','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',5586,'public'),('art','art','2007-01-05 17:11:48','Scrie aici despre art',5594,'public'),('regulament_preoni_2006','regulament_preoni_2006','2007-01-09 11:09:08','Scrie aici despre regulament_preoni_2006',5606,'public'),('sandbox','Sandbox','2007-01-27 20:33:36','h1. Sandbox\r\n\r\n*Worship me*\r\n\r\nFeel free to play around, but \'Big Brother\':/changes is watching you.\r\n\r\nCapsuni.\r\n\r\n\'codetest\':sandbox/code-test\r\n\r\nWhat does \'this\':sandbox?action=edit button do?\r\n\r\nlalallaa\r\n\r\nIntrebare: cum poti seta culoarea cu care scrii?\r\nUite asa: %{color:red}scris cu rosu%\r\n\r\nSiteul sub IE 7 -- vezi \'pagina dedicata\':ia_in_ie7\r\n\r\nSiteul sub FF 2 - mica problema panoul de \'editeaza\', \'vezi istoria\', \'sterge\' etc (in IE7 panoul nu se suprapune)\r\n!sandbox?IA_bug_in_FF2.jpg!\r\n\r\n[test]\r\n*OMG* test, good work people :D\r\nAcuma doar trebuie putin stimulata comunitatea\r\n[/test]\r\n\r\nInteresting choice of words.\r\na very bold **MAN**\r\n_CAPSOMANII-I DESPISE THEM_\r\n\r\ngasise pe-un teren viran,\r\nun geamantan.\r\n\r\nsi-n geamantan,\r\nun pachet.\r\n\r\nsi in pachet,\r\nun pachetel gasise el.\r\n\r\nsi-n pachetel,\r\nalt pachetel.\r\n\r\nsi-un pachetel in pachetel,\r\nlegat cu funde elegante.\r\n\r\nsi-n pachetel...vreo 40 de diamante...\r\n...\r\nAdio voi...va las si plec fiindca mi-e dor...\r\nsi a plecat Apolodor\r\n!!!<>\r\n\r\ntralalala blablabla lala\r\n\r\nMoraru Ionut has been here. :))\r\n\r\n\r\nma joc si eu putin pe aici :-P\r\nlog ~21sda~ NNNN',4231,'public'),('task/proc','task/proc','2007-01-11 10:37:47','Scrie aici despre task/proc',2215,'public'),('preoni-2005','Preoni 2005','2007-01-13 21:42:49','h1. preONI 2005\r\n\r\nConcursul preONI 2005 s-a desfasurat in 3 runde avand ca principal scop pregatirea participantilor pentru olimpiada nationala de informatica ONI2005.\r\n\r\nFormatul concursului: 2 grupe (clasele IX-X, XI-XII), 3 probleme in fiecare grupa si un timp de lucru de 4h.\r\n\r\nh2. Runde\r\n\r\n* \"Runda 1\":preoni-2005/runda-1 :Duminica, 23 ianuarie, ora 15:00\r\n* \"Runda 2\":preoni-2005/runda-2 :Miercuri, 23 februarie ora 16:00\r\n* \"Runda 3\":preoni-2005/runda-3 :Duminica, 20 martie la ora 10:00\r\n\r\nh2. \"Clasament IX-X\":preoni-2005/clasament-9-10\r\n\r\nh2. \"Clasament XI-XII\":preoni-2005/clasament-11-12',1,'round: preoni-2005'),('concursuri','Concursuri','2007-01-29 01:46:36','h1. Concursuri\r\n\r\nIn aproape 3 ani de activitate, infoarena a organizat cateva zeci de concursuri/runde online.\r\n\r\nFiecare concurs are un format aparte. De la o runda la cinci, de la cateva ore la cateva zile sau chiar o saptamana, de la cateva probleme la 20, concursurile infoarena variaza in amploare, dificultate si popularitate.\r\n\r\n\r\nh2. Seria preONI\r\n\r\nConcursul _de marca_ infoarena se organizeaza anual si pregateste elevii pentru \"Olimpiada Nationala de Informatica\":http://olimpiada.info/. Este cel mai popular concurs al nostru.\r\n\r\nh3. \'preONI 2007\':preoni-2007 (In desfasurare!)\r\n\r\n* *{\'Runda 1\':preoni-2007/runda-1}* \r\n* Runda 2\r\n* Runda 3\r\n* Runda 4\r\n* Finala\r\n\r\nh3. preONI 2006 (\'pagina concursului\':preoni-2006)\r\n\r\nA 3-a editie a concursului preONI (editia din 2006), primii 10 calificati de la fiecare grupa au participat intr-o finala on-site in Focsani, jud. Vrancea. Concursul a fost sponsorizat de ORACLE Romania, IP Devel, C.N. \"Unirea\" Focsani si altii.\r\n\r\n* *{\'Runda 1\':preoni-2006/runda-1}*\r\n* *{\'Runda 2\':preoni-2006/runda-2}*\r\n* *{\'Runda 3\':preoni-2006/runda-3}*\r\n* *{\'Runda 4\':preoni-2006/runda-4}*\r\n* *{\'Finala in Focsani\':preoni-2006/finala}*\r\n\r\nh3. preONI 2005 (\'pagina concursului\':preoni-2005)\r\n\r\nPrimul concurs preONI cu premii. A fost sponsorizat de Microsoft Romania.\r\n\r\n* *{\'Runda 1\':preoni-2005/runda-1}*\r\n* *{\'Runda 2\':preoni-2005/runda-2}*\r\n* *{\'Runda 3\':preoni-2005/runda-3}*\r\n\r\nh3. preONI 2004 (\'pagina concursului\':preoni-2004)\r\n\r\n* *{\'Runda 1\':preoni-2004/runda-1}*\r\n* *{\'Runda 2\':preoni-2004/runda-2}*\r\n\r\nh2. Happy Coding\r\n\r\nUn concurs infoarena mai neobisnuit. _Happy Coding inseamna programare cu zambetul pe buze, placere si distractie pura!_\r\n\r\nConcursurile Happy Coding dispun de evaluator live si au timp de lucru lejer. Nu vei mai fi stresat de pana la aflarea rezultatelor. Afli pe loc daca solutiile tale sunt bune. In plus, poti lucra si ziua si noaptea, dupa sau in timpul orelor de scoala.\r\n\r\n* *{\'Happy coding 1 (2005)\':happy-coding-2005-1}*\r\n* *{\'Happy coding 2\':happy-coding-2005-2}*\r\n* *{\'Happy coding 3 (2006)\':happy-coding-2006}*\r\n\r\nh2. Summer Challenge\r\n\r\nO serie noua de concursuri infoarena. Acestea se organizeaza in timpul vacantei de vara pentru cei care nu vor _sa-si iasa din mana_. :)\r\n\r\n* *{\'Summer challenge 1\':summer-challenge-unu}*\r\n* *{\'Summer challenge 2\':summer-challenge-2}*\r\n* *{\'Summer challenge 3\':summer-challenge-3}*\r\n\r\nh2. Alte concursuri infoarena\r\n\r\n* *{\'Unirea 2007\':unirea-2007}*\r\n* *{\'Concurs de incalzire\':warm-up-2004}*\r\n* *{\'preOJI 2004\':preoji-2004}*\r\n* *{\'Bursele agora, editia 6, finala online\':agora-finala}*\r\n* *{\'Autumn warmUp 2006\':warm-up-2006}*\r\n* *{\'Grigore Moisil By Net 2006\':moisil-by-net-2006}*\r\n* *{\'Bacalaureat 2005\':bacalaureat-2005}* \r\n',1,'protected'),('template/preoni-2007/header','template/preoni-2007/header','2007-01-18 02:56:05','table{margin: 0; width: 99%; background-image: url(/template/preoni-2007/header?action=download&file=hbk.png); background-repeat: repeat-x; background-position: 0 0;}. |{border: 0px;}. !preoni-2007?logo.png!:/preoni-2007 |{border: 0px; text-align: right; vertical-align: bottom}. |\r\n',13,'protected'),('template/preoni-2007','template/preoni-2007','2007-01-18 03:18:56','==include(page=\"template/preoni-2007/header\")==\r\n\r\n(vmenu)*(section) \'Home\':preoni-2007\r\n* \'Clasament\':preoni-2007/clasament\r\n* \'Organizatori\':preoni-2007/comisie\r\n* \'Sponsori si premii\':preoni-2007/premii\r\n* \'Regulament\':preoni-2007/regulament\r\n* \'Aparitii in presa\':preoni-2007/presa\r\n*(section) Runde\r\n* \'Runda 1\':preoni-2007/runda-1\r\n* \'Runda 2\':preoni-2007/runda-2\r\n* \'Runda 3\':preoni-2007/runda-3\r\n* \'Runda 4\':preoni-2007/runda-4\r\n* \'Runda finala\':preoni-2007/finala\r\n',13,'protected'),('problema/perm4','Permutari 4','2007-01-15 13:59:49','== include(page=\"template/taskheader\" task_id=\"perm4\") ==\r\n\r\nPe langa pasiunea sa pentru numere, Zaharel este un mare pasionat de permutari. Astazi, si-a propus sa studieze numai permutarile $P$ de lungime $N$ care au o proprietate interesanta: contin $K$ pozitii distincte $1<i{~1~},i{~2~},...,i{~K~} &le; N$ pentru care $P[i{~x~}]=P[i{~x~}-1]+1$.\r\nScrieti un program care determina cate permutari va studia Zaharel astazi.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $perm4.in$ sunt scrise cele doua numere naturale $N$ si $K$, separate printr-un singur spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie a fisierului $perm4.out$ va contine numarul de permutari. Deoarece rezultatul poate fi foarte mare, se va afisa in schimb restul impartirii rezultatului la numarul $666013$.\r\n\r\nh2. Restrictii\r\n\r\n* $0 &le; K < N &le; 3.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. perm4.in |_. perm4.out |\r\n| 4 1\r\n| 9\r\n| \r\n\r\nh3. Explicatie\r\n\r\nCele 9 permutari sunt:\r\n$1243$\r\n$1342$\r\n$1423$\r\n$2134$\r\n$2314$\r\n$3421$\r\n$3124$\r\n$4231$\r\n$4312$\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"perm4\") ==\r\n\r\n== SmfTopic(topic_id=\"1441\") ==\r\n',1,'task: perm4'),('problema/criptare','Criptare','2007-01-15 14:01:21','== include(page=\"template/taskheader\" task_id=\"criptare\") ==\r\n\r\nZaharel si Bronzarel se intrec adesea in criptare. De data aceasta, Zaharel a criptat un sir de $N$ numere naturale $a{~0~}, a{~1~},... a{~N-1~}$ astfel: a luat un numar natural $M$ si a construit urmatorul sir: $b{~i~} = a{~i~} + a{~(i+1) mod N~} + a{~(i+2) mod N~} + ... + a{~(i+M-1) mod N~}$; apoi, l-a intrebat pe Bronzarel daca poate sa determine sirul initial $a{~0~}, a{~1~},... a{~N-1~}$ daca i se da acest nou sir, precum si numarul $M$.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $criptare.in$ sunt scrise cele doua numere naturale $N, M$, separate printr-un singur spatiu. Pe urmatoarea linie se vor scrie $N$ numere naturale separate printr-un singur spatiu, reprezentand sirul $b{~0~}, b{~1~},... b{~N-1~}$.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie a fisierului $criptare.out$ va contine $N$ numere naturale separate printr-un singur spatiu, reprezentand sirul $a{~0~}, a{~1~},... a{~N-1~}$. Desi pot exista mai multe solutii, Bronzarel stie ca sirul criptat de Zaharel este cel minim lexicografic dintre toate solutiile posibile.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N, M &le; 50.000$\r\n* $0 &le; b{~i~} &le; 10^9^$\r\n* Prin a mod b se intelege restul impartirii lui a la b\r\n* Se garanteaza existenta a cel putin unei solutii\r\n* Sirul $a{~0~}, a{~1~},... a{~N-1~}$ trebuie sa contina numere naturale (nu neaparat nenule)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. criptare.in |_. criptare.out |\r\n| 3 2\r\n3 5 4\r\n| 1 2 3 |\r\n| 6 4\r\n8 13 11 13 17 10\r\n| 2 5 0 1 7 3 \r\n|\r\n\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"criptare\") ==\r\n\r\n== SmfTopic(topic_id=\"1442\") ==',1,'task: criptare'),('problema/nr','Nr','2007-01-15 13:52:33','== include(page=\"template/taskheader\" task_id=\"nr\") ==\r\n\r\nZaharel este un mare pasionat de numere. Astazi, se joaca cu numere de $N$ cifre scrise in baza $B$. Fie $NR=nr{~0~}nr{~1~}...nr{~N-1~}$  un astfel de numar in baza $B$ ({$nr{~0~}, nr{~1~}$} etc. reprezinta cifrele numarului $NR$ scrise de la stanga la dreapta), definim imaginea acestui numar ca fiind numarul $I(NR)=i{~0~}i{~1~}...i{~N-2~}$ cu proprietatea $i{~p~}=min(i{~p~},i{~p+1~})$. Avand o groaza de timp liber, Zaharel s-a gandit sa calculeze pentru fiecare numar posibil de $N$ cifre (numarul poate incepe cu cifre de 0) in baza $B$ produsul cifrelor imaginii numarului si sa adune aceste valori.\r\nScrieti un program care il scuteste pe Zaharel de aceste calcule, si determina aceasta suma in timp util.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $numere.in$ sunt scrise cele doua numere naturale $N, B$, separate printr-un singur spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie a fisierului $numere.out$ va contine suma dorita de Zaharel. Deoarece rezultatul poate fi foarte mare, este de ajuns afisarea restului impartirii rezultatului la numarul $666013$.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 20.000$\r\n* $2 &le; B &le; 1.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. nr.in |_. nr.out |\r\n| 2 4\r\n| 14\r\n| \r\n\r\nh3. Explicatie\r\n\r\n$NR=00, I(NR)=0$ se aduna $0$\r\n$NR=01, I(NR)=0$ se aduna $0$\r\n$NR=02, I(NR)=0$ se aduna $0$\r\n$NR=03, I(NR)=0$ se aduna $0$\r\n$NR=10, I(NR)=0$ se aduna $0$\r\n$NR=11, I(NR)=1$ se aduna $1$\r\n$NR=12, I(NR)=1$ se aduna $1$\r\n$NR=13, I(NR)=1$ se aduna $1$\r\n$NR=20, I(NR)=0$ se aduna $0$\r\n$NR=21, I(NR)=1$ se aduna $1$\r\n$NR=22, I(NR)=2$ se aduna $2$\r\n$NR=23, I(NR)=2$ se aduna $2$\r\n$NR=30, I(NR)=0$ se aduna $0$\r\n$NR=31, I(NR)=1$ se aduna $1$\r\n$NR=32, I(NR)=2$ se aduna $2$\r\n$NR=33, I(NR)=3$ se aduna $3$\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"nr\") ==\r\n\r\n== SmfTopic(topic_id=\"1440\") ==\r\n',1,'task: nr'),('template/preoni-2007/footer','template/preoni-2007/footer','2007-01-18 00:13:32','',13,'protected'),('echipa-infoarena','Echipa infoarena','2007-01-15 15:38:57','h1. Echipa infoarena\r\n\r\n==include(page=\"template/despre-infoarena\")==\r\n\r\n* ==user(user=\"wickedman\" type=\"normal\")==\r\n* ==user(user=\"fluffy\" type=\"normal\")==\r\n* ==user(user=\"Cosmin\" type=\"normal\")==\r\n* ==user(user=\"domino\" type=\"normal\")==\r\n* ==user(user=\"ditzoneC\" type=\"normal\")==\r\n* ==user(user=\"silviug\" type=\"normal\")==\r\n* ==user(user=\"filipb\" type=\"normal\")==\r\n* ==user(user=\"danielp\" type=\"normal\")==\r\n* ==user(user=\"azotlichid\" type=\"normal\")==\r\n* ==user(user=\"greco\" type=\"normal\")==\r\n* ==user(user=\"svalentin\" type=\"normal\")==\r\n\r\n_(aici trebuie sa punem un macro cu atribute/tags de utilizatori)_\r\n',1,'protected'),('preoni_2006','preoni_2006','2007-01-18 13:56:41','Scrie aici despre preoni_2006',5685,'public'),('preoni-2007/comisie','Organizatori preONI 2007','2007-01-18 00:10:35','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Organizatori\r\n\r\n\'Echipa infoarena\':echipa-infoarena se ocupa de organizarea si desfasurarea concursului *preONI 2007*.\r\n\r\nh2. Organizare \r\n\r\n* == user(user=\"wickedman\" type=\"tiny\") == : coordonator, promovare concurs\r\n* == user(user=\"fluffy\" type=\"tiny\") == : coordonator tehnic (site-ul, evaluatorul etc.)\r\n* == user(user=\"svalentin\" type=\"tiny\") == : suport tehnic\r\n\r\nh2. Echipa stiintifica\r\n\r\nCei care se vor ocupa de buna desfasurarea a concursului din punct de vedere stiintific (redactarea si compunerea problemelor, realizarea testelor, clarificarea intrebarilor, etc.) sunt:\r\n\r\n* == user(user=\"domino\" type=\"tiny\") ==\r\n* == user(user=\"Cosmin\" type=\"tiny\") ==\r\n* == user(user=\"ditzoneC\" type=\"tiny\") ==\r\n* == user(user=\"silviug\" type=\"tiny\") ==\r\n* == user(user=\"filipb\" type=\"tiny\") ==\r\n* == user(user=\"danielp\" type=\"tiny\") ==\r\n* == user(user=\"azotlichid\" type=\"tiny\") ==\r\n* == user(user=\"greco\" type=\"tiny\") ==\r\n\r\nh2. Multumim\r\n\r\n* &hellip; lui Alexandru Marinescu pentru sigla preONI 2007 :)\r\n\r\n==include(page=\"template/preoni-2007/footer\")==',13,'protected'),('preoni-2007/premii','Sponsori si premii preONI 2007','2007-01-18 00:12:58','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Sponsori si premii\r\n\r\nSponsorii si premiile se vor anunta in curand. Intre timp, vezi \'premiile de anul trecut\':preoni-2006/premii.\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==\r\n',13,'protected'),('preoni-2007/program','Program preONI 2007','2007-01-15 15:57:51','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Program\r\n\r\n_in curand_\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==',1,'protected'),('preoni-2007/regulament','Regulament preONI 2007','2007-01-18 18:24:07','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Regulament\r\n\r\nSe recomanda, pe langa citirea acestui regulament, citirea \"regulamentului\":regulament general infoarena.\r\n\r\n\'Echipa infoarena\':echipa-infoarena isi rezerva dreptul de a modifica prezentul regulament pe parcursul desfasurarii concursului. Daca apar prevederi noi sau daca anumite prevederi ale regulamentului sunt modificate sau eliminate, atunci acestea vor fi anuntate pe site-ul concursului. Orice modificare a regulamentului va intra in vigoare, in functie de situatie, fie din momentul publicarii ei, fie dupa incheierea rundei aflate in desfasurare. In momentul anuntarii modificarii va fi precizat si momentul din care aceasta intra in vigoare.\r\n\r\nh2. Dreptul de participare\r\n\r\nPersoanele care fac parte din \'echipa infoarena\':echipa-infoarena cat si alti contribuitorii implicati direct in organizarea concursului *preONI 2007* nu au dreptul de a participa. De asemenea, orice concurent care are un comportament considerat inadecvat fata de echipa infoarena sau fata de alti concurenti va fi descalificat. Un concurent se poate califica la finala doar daca se incadreaza in grupa la care a concurat (aceasta verificare se va face prin prezentarea unei dovezi legale care il incadreaza pe concurent la aceea grupa).\r\n\r\nh2. Repartizarea\r\n\r\nToti participantii vor fi repartizati in 3 grupe, in concordanta cu varsta lor. Repartizarii este asemanatoare cu acea facuta la olimpiadele de informatica.\r\n\r\n* Clasa a 9a si gimnaziu\r\n* Clasa a 10a\r\n* Clasele 11-12 \r\n\r\nOricine poate participa la o alta grupa decat cea la care se incadreaza, dar calificarea la finala cat si impartirea premiilor se va face conform regulamentului respectiv, fara nici o exceptie.\r\n\r\nh2. Inscriere\r\n\r\nTot ce trebuie sa faceti pentru a participa la concursul *preONI 2007* este sa aveti un cont la infoarena. Inregistrarea se poate face pe site-ul infoarena. Acelasi cont va fi folosit pentru a accesa forum-ul.\r\n\r\nh2. Runde\r\n\r\nVor exista 4 runde de calficare, iar in urma clasamentului stabilit primii de la fiecare grupa vor fi selectati pentru etapa finala desfasurata in cadrul unei tabere. Cele 4 runde vor avea loc sambata si duminica, incepand cu ora 9:00, desi pot interveni exceptii. Durata lor va fi de 4 ore. Pentru un program detaliat al concursului \"click aici\":preoni-2007/program.\r\n\r\nh2. Intrebari\r\n\r\nIn prima ora vor putea fi formulate eventualele intrebari, pe forum, in topicurile special create. Orice intrebare pusa in alt mod (primita ca personal message, pe mail, etc.) va fi ignorata. Raspunsuri vor fi oferite doar la intrebarile puse in prima ora . Intrebarile trebuie formulate astfel incat sa se poate raspunda cu DA sau NU. In caz contrar sau in cazul in care raspunsul se afla in textul problemei se va raspunde cu NO COMMENT. Nu vor exista exceptii de la aceaste reguli. Daca echipa va considera ca raspunsul la o anumita intrebare este de interes general si clarifica anumite aspecte, atunci se va face un anunt general care va aparea atat pe forum cat si in sectiunea Mesaje de la organizatori a grupei respective. Fiecare grupa va avea doi administratori care se vor ocupa de raspunsul acestor intrebari.\r\n\r\nh2. Trimiterea solutiilor\r\n\r\nTrimitrea solutiile se va face prin intermediul interfetei site-ului infoarena.\r\nOdata logati in contul vostru, veti putea selecta arhiva la care doriti sa lucrati (in cazul acesta una din arhivele {*preONI 2007*}) si veti putea folosi link-ul trimite solutii.\r\n\r\nh2. Evaluare\r\n\r\nDupa expirarea timpului de trimitere a solutiilor acestea vor fi evaluate (\"mai multe detalii aici\":documentatie/evaluator). In mod normal, evaluarea se va face imediat dupa concurs, desi exista posibilitatea ca echipa infoarena sa amane evaluarea din motive obiective. Veti putea vizualiza pozitia ocupata in clasament dupa evaluarea in rubrica Clasament.\r\n\r\nSe recomanda sa instalati pe calculatorul vostru aceleasi versiuni de compilatoare ca cele specificate la link-ul de mai sus. \'Echipa infoarena\':echipa-infoarena nu este responsabila pentru diferentele intre versiuni de compilatoare si nu va efectua reevaluaari in astfel de cazuri.\r\n\r\nh2. Contestatii\r\n\r\nEchipa infoarena isi rezerva dreptul de a reevalua orice problema in situatia in care se detecteaza erori in teste sau in programul de verificare dupa evaluare. Cum testele problemelor nu vor fi facute publice, posiblitatile de a contesta sunt limitate. Pentru a asigura o evaluarea corecta, echipa infoarena va garanteaza ca va testa intens toate problemele inainte de concurs si ca va verifica corectitudinea procesului de evaluare dupa terminare. In caz ca totusi aveti o contestatie, aceasta trebuie trimisa pe mail la adresa _mircea.pasoi -at- gmail.com_ in termen de 24 de ore de la afisarea rezultatelor rundei curente pe site. Ele vor fi rezolvate in termen de maxim 5 zile, iar dupa rezolvarea lor rezultatele vor fi declarate finale.\r\n\r\nh2. Solutii\r\n\r\nLa scurt timp dupa terminarea evaluarii se va publica un articol cu solutiile pentru problemele rundei respective. Testele utilizate pentru evaluare nu vor fi facute publice.\r\n\r\nh2. Transferul problemelor\r\n\r\nProblemele vor fi mutate dupa evaluare in Arhiva de probleme infoarena, avand astfel la dispozitie un evaluator 24 din 24 si posiblitatea de a finisa solutiile la problemele nerezolvate in timpul concursului.\r\n\r\nh2. Trisare\r\n\r\n*preONI 2007* este un concurs individual, asadar orice tentativa de colaborare va aduce descalificarea celor implicati. \'echipa infoarena\':echipa-infoarena isi rezerva dreptul de a verifica sursele concurentilor, iar in caz ca se descopera surse aproximativ identice, concurentii respectivi vor fi descalificati din concurs iar user-ul lor de pe infoarena eliminat. Tentativele de frauda (concurarea sub un alt nume decat cel adevarat, etc.) sau orice atac asupra sistemului de evaluare sau asupra paginilor infoarena vor fi pedepsite in aceeasi masura. \r\n',1,'protected'),('preoni-2007/presa','Aparitii in presa preONI 2007','2007-01-18 00:15:09','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Aparitii in presa\r\n\r\n_Mai asteptam &hellip; :)_\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==',13,'protected'),('preoni-2007/clasament','Clasament preONI 2007','2007-01-21 20:27:30','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Clasament\r\n\r\nh2. Clasament Runda 1\r\n\r\n* \'Clasa a 9-a si gimnaziu\':preoni-2007/clasament/runda-1/9\r\n* \'Clasa a 10-a\':preoni-2007/clasament/runda-1/10\r\n* \'Clasele 11-12\':preoni-2007/clasament/runda-1/11-12\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==',13,'protected'),('preoni-2007/runda-2','Runda 2 preONI 2007','2007-01-18 00:16:37','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Runda 2\r\n\r\nInformatii despre aceasta runda vor aparea cu 2-3 saptamani inainte.\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==',13,'protected'),('preoni-2007/runda-3','Runda 3 preONI 2007','2007-01-18 00:16:45','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Runda 3\r\n\r\nInformatii despre aceasta runda vor aparea cu 2-3 saptamani inainte.\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==',13,'protected'),('preoni-2007/runda-4','Runda 4 preONI 2007','2007-01-18 00:16:53','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Runda 4\r\n\r\nInformatii despre aceasta runda vor aparea cu 2-3 saptamani inainte.\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==',13,'protected'),('preoni-2007/finala','Runda Finala preONI 2007','2007-01-18 00:17:01','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Runda Finala\r\n\r\nInformatii despre aceasta runda vor aparea in curand.\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==',13,'protected'),('template/newround','%round_id%','2007-01-20 17:27:56','h1. == roundparam(round_id=\"%round_id%\" param=\"title\") ==\r\n\r\np>. ==roundstatus(round_id=\"%round_id%\")==\r\n\r\n== roundregister(round_id=\"%round_id%\") ==\r\n\r\nConcursul incepe ==roundparam(round_id=\"%round_id%\" param=\"start_time\")== si dureaza ==roundparam(round_id=\"%round_id%\" param=\"duration\")== ore.\r\n\r\nClasamentul poate fi vizualizat \'aici\':%round_id%/clasament\r\n\r\nh2. Probleme\r\n\r\nAceasta lista va deveni vizibila doar in momentul inceperii concursului.\r\n\r\n== Tasks(round_id=\"%round_id%\" score=\"1\")==',1,'protected'),('newsletter/2007-01-18','preONI 2007, Runda #1','2007-01-18 15:02:50','Buna, %full_name%!\r\n\r\nIncepe o noua editie preONI, concursul cu premii care te pregateste\r\npentru Olimpiada Nationala de Informatica.\r\n\r\nPrima runda a concursului va avea loc ...\r\n\r\n    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\r\n    Duminica, 21 ianuarie 2007, orele 09:00 - 13:00\r\n    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\r\n\r\nPagina rundei: %url_infoarena%preoni-2007/runda-1\r\n\r\n== Atentie! Concurs cu rating! ==\r\n\r\nParticiparea la aceasta runda iti va afecata rating-ul pe infoarena.\r\nO prestatie buna te poate aduce mai aproape te varful clasamentului.\r\n%your_rating_is%\r\nRating-ul este un indicator al performantei tale in conditii de\r\nconcurs. Despre rating: %url_infoarena%documentatie/rating.\r\n\r\n== Despre preONI ==\r\n\r\npreONI, concursul de marca al comunitatii infoarena, este dedicat\r\nelevilor de liceu ce se pregatesc pentru ONI (Olimpiada Nationala de\r\nInformatica).\r\n\r\nConcursul este impartit in 3 grupe: clasa a IX-a si gimnaziu, clasa\r\na X-a si clasele XI-XII. Se organizeaza 4 runde online de calificare.\r\nIn urma acestora, cei mai buni de la fiecare grupa sunt invitati la\r\no runda finala.\r\n\r\nIn cadrul unei runde, vei avea de rezolvat 3 probleme in 4h.\r\nCastigatorii rundei finale sunt premiati cu bani si/sau obiecte.\r\n\r\nPe pagina concursului ( %url_infoarena%preoni-2007 ) vei gasi\r\ninformatii despre cum participi, cine propune probleme, premii si\r\nsponsori, regulamentul concursului samd.\r\n\r\n== Prima data la infoarena? ==\r\n\r\ninfoarena ajuta elevi si studenti sa devina excelenti in informatica!\r\nGratuit ;)\r\n\r\nDespre infoarena: %url_infoarena%despre-infoarena\r\nGhidul utilizatorului: %url_infoarena%documentatie/pentru-utilizatori\r\n\r\n\r\nRamai alaturi de noi. Te ajutam sa devii olimpic!\r\n\r\nSucces!\r\nEchipa infoarena\r\n\r\n== Mesaj nesolicitat? ==\r\n\r\nEsti inscris pe %url_infoarena% cu numele\r\n\"%full_name%\", utilizator \"%username%\"\r\nsi ai acceptat sa primesti mesaje de instiintare.\r\n\r\nDaca nu mai doresti instiintari, da click pe acest link:\r\n%url_unsubscribe%\r\n',13,'protected'),('documentatie/tutorial','Tutorial infoarena','2007-01-18 14:12:20','h1. Tutorial infoarena\r\n\r\n==include(page=\"template/todo\")==\r\n\r\n==include(page=\"template/raw\")==\r\n\r\nh2. Citirea problemelor\r\n\r\nProblemele de pe acest site sunt grupate in mai multe seturi(cate un set pentru fiecare concurs, un set mare care grupeaza problemele de olimpiada si un set special pentru problemele de bac). Ne vom referi la un set ca la o arhiva de probleme.\r\n\r\nAccesul problemelor se face mergand la sectiunea Citeste probleme. Din aceasta pagina se va selecta arhiva pentru care se doreste vizualizarea problemelor.\r\n\r\nOdata ajunsi aici va aparea o lista cu probleme. Selectati problema al carei text doriti sa il cititi.\r\n\r\nh2. Trimiterea solutiilor\r\n\r\nPentru a trimite o rezolvare trebuie mai intai sa va logati. Daca nu aveti inca un cont personal accesati sectiunea Inregistrare. Odata logati mergeti la Trimitere solutii unde va trebui eventual sa alegeti arhiva pentru care doriti sa submitati solutia. Daca nu sunteti in arhiva corespunzatoarea alegeti optiunea Alege alta arhiva si faceti optiunea dorita.\r\n\r\nOdata aleasa arhiva pentru care veti trimite rezolvarea veti avea de completat:\r\n\r\n* problema pentru care veti trimite ( aceasta va fi aleasa din lista corespunzatoare)\r\n* fisierul de trimis (veti specifica calea de pe hard-disk a fisierului)\r\n* compilatorul pe care doriti sa se foloseasca (acesta se poate completa automat in functie de extensia sursei). \r\n\r\nAcum sunteti gata, apasati butonu Trimite soltuie! si asteptai mesajul de confirmare.\r\n\r\nh2. Vizualizare clasament\r\n\r\nClasamentul poate fi vizualizat in sectiunea Clasamente si alte statistici. Pentru concursurile on-line aceasta sectiune va fi disponibila doar dupa incheierea concursului si evaluarea solutiilor.\r\n\r\nPentru un borderou exact puteti merge la Monitorul de evalouare(aflat tot in sectiunea de Clasamente si statistici) si sa alegeti sursa pentru care doriti borderoul.\r\n\r\nh2. Alte resurse\r\n\r\nPentru articole despre diversi algoritmi, arhive cu teste si solutii de pe la diverse concursuri nationale si internationale mergeti \'pagina de articole\':articole.\r\n\r\nPentru discutii despre o anumita problema sau alte lucruri care tin de domeniul informaticii accesati \'forumul infoarena\':forum. \r\n',13,'public'),('documentatie/pentru-utilizatori','Ghid utilizatori','2007-01-18 14:44:50','h1. Ghid utilizatori\r\n\r\n==include(page=\"template/todo\")==\r\n\r\nAici centralizam toate paginile care explica modul in care utilizatorii pot folosi site-ul infoarena.\r\n\r\n* {\'Tutorial infoarena\':documentatie/tutorial}: Un tutorial infoarena\r\n* {\'Monitorul de evaluare\':documentatie/monitorul-de-evaluare}: Ce este si cum se foloseste monitorul de evaluare.\r\n* {\'Trimiterea solutiilor\':documentatie/trimiterea-solutiilor}: Cum se trimit solutii.\r\n* {\'Pagina de profil\':documentatie/pagina-de-profil}: Cum se face o pagina de profil pe infoarena.\r\n* {\'Rating\':documentatie/rating}: Ce este si cum functioneaza sistemul de rating\r\n',13,'public'),('utilizator/vali_mi','Profil vali_mi','2007-01-19 09:20:57','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',5695,'public'),('problema/elimin','elimin','2007-01-19 20:32:37','== include(page=\"template/taskheader\" task_id=\"elimin\") ==\r\n\r\nSe da o matrice cu $M$ linii si $N$ coloane cu elemente numere naturale. Sa se elimine exact $R$ linii si $C$ coloane din matrice astfel incat matricea rezultata sa aiba suma elementelor maxim posibila.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $elimin.in$ are urmatoarea structura: pe prima linie se vor afla patru numere naturale despartite de exact un spatiu, {$M$}, {$N$}, {$R$} si {$C$}, cu semnificatia precizata mai sus. Fiecare din urmatoarele {$M$} linii contine cate {$N$} numere naturale.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie a fisierului de iesire $elimin.out$ contine suma maxima obtinuta.\r\n\r\nh2. Restrictii\r\n\r\n* {$0 &le; R < M$}\r\n* {$0 &le; C < N$}\r\n* Valorile elementelor matricii nu depasesc $32 000$\r\n* La corectare vor exista 10 teste, fiecare valorand 10 puncte. In tabelul de mai jos se regasesc ariile matricilor pentru fiecare test in parte:\r\n\r\n|_. T1|_. T2|_. T3|_. T4|_. T5|_. T6|_. T7|_. T8|_. T9|_. T10|\r\n|32|50|100|266|539|1630|3495|3653|5866|7294|\r\n\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. elimin.in |_. elimin.out |\r\n|3 3 1 1\r\n8 1 2\r\n6 1 4\r\n0 9 0\r\n|20| \r\n\r\nh3. Explicatie\r\n\r\nSuma maxima se obtine eliminand a doua coloana si ultima linie.\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"elimin\") ==\r\n',256,'task: elimin'),('problema/diviz','diviz','2007-01-19 21:01:15','== include(page=\"template/taskheader\" task_id=\"diviz\") ==\r\n\r\nFie un numar natural $N$ dat. Sa se determine cate numere naturale distincte nenule sunt subsiruri ale numarului {$N$}, sunt divizibile cu {$K$} si au intre {$A$} si {$B$} cifre.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului $diviz.in$ contine trei numere naturale, {$K$}, {$A$} si {$B$}. Pe a doua linie se gaseste numarul $N$ de cel mult $200$ de cifre.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie a fisierului $diviz.out$ contine numarul de subsiruri existente cu proprietatile cerute, modulo $30103$ ( adica restul impartirii numarului de subsiruri la $30103$ ).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* {$1 < K &le; 100$}\r\n* {$0 < A &le; B &le; numarul de cifre ale numarului N$}\r\n* Orice numar natural trebuie sa inceapa cu cifra nenula\r\n* Un numar $X$ este subsir al numarului $Y$ daca si numai daca $X$ se poate obtine din $Y$ in urma stergerii unor cifre din acesta. De exemplu, numarul 508 este subsir al numarului 1530998, pentru ca se poate obtine din 1530998 prin stergerea cifrelor 1, 3, 9 si 9.\r\n* Orice numar $X$ este propriul lui subsir\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. diviz.in |_. diviz.out |_. diviz.in|_. diviz.out|\r\n|8 1 2\r\n24\r\n|1\r\n|3 3 5\r\n12055\r\n|4| \r\n\r\nh3. Explicatie\r\n\r\nPentru primul exemplu, singurul numar posibil este {$24$}. Cele 4 posibilitati pentru al doilea exemplu sunt {$105$}, {$120$}, {$255$}, {$2055$}.\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"diviz\") ==\r\n',256,'task: diviz'),('template/taskheader','template/taskheader','2007-01-19 22:25:50','| *Fisierul intrare/iesire:* | ==TaskParam(param=\"id\" task_id=\"%task_id%\")==.in, ==TaskParam(param=\"id\" task_id=\"%task_id%\")==.out |||\r\n| *Autor* | ==TaskParam(param=\"author\" task_id=\"%task_id%\")== | *Sursa* | ==TaskParam(param=\"source\" task_id=\"%task_id%\")== |\r\n| *Timp executie pe test* | ==TaskParam(param=\"timelimit\" task_id=\"%task_id%\")== sec | *Limita de memorie* | ==TaskParam(param=\"memlimit\" task_id=\"%task_id%\")== kbytes |\r\n\r\nh1. ==TaskParam(param=\"title\" task_id=\"%task_id%\")==\r\n\r\n',1,'protected'),('problema/radiatie','Radiatie','2007-01-20 19:52:12','== include(page=\"template/taskheader\" task_id=\"radiatie\") ==\r\n\r\nZaharel este cercatator de fizica nucleara si lucreaza la un complex de cercetare secret format din $N$ laboratoate, numerotate convenabil cu numere de la $1$ la $N$. De asemenea, aceste laboratoare sunt conectate prin $M$ tunele bidirectionale, de diverse lungimi. Desi laboratoarele sunt concepute astfel incat cercetatorii sa nu fie expusi la radiatii, tunelele nu protejeaza complet, astfel incat daca un cercetator foloseste un anumit tunel de legatura va fi expus la un nivel de radiatii direct proportional cu lungimea tunelului. \r\nZaharel are de efectuat $K$ drumuri intre diverse perechi de laboratoare. Stiind ca expunerea pentru un timp indelungat la radiatii are efecte daunatoare, el va alege mereu un drum in care lungimea maxima a unui tunel parcurs este minima. Determinati care vor fi drumurile pe care le va alege Zaharel.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare $radiatie.in$ va contine numerele naturale $N, M, K$ separate prin spatii. Urmatoarele $M$ linii vor contine cate trei numere naturale $a b c$ cu semnificatia ca exista un tunel intre laboratorul cu numar $a$ si laboratorul cu numar $b$, de lungime $c$. In continuare, urmatoarele $K$ linii vor contine perechi de numere naturale $x y$ avand semnificatia ca Zaharel va efectua un drum intre laboratoarele $x$ si $y$. \r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $radiatie.out$ va contine $K$ linii, fiecare continand lungimea maxima minima considerand tunelele parcurse de Zaharel pentru fiecare drum. Rezultatele se vor afisa in ordinea in care sunt date cele $K$ drumuri in fisierul de intrare.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N, K &le; 15.000$\r\n* $1 &le; M &le; 30.000$\r\n* Lungimea unui tunel este un numar natural din intervalul $[1, 10^9^]$\r\n* Un drum reprezinta o succesiune de laboratoare $a{~1~}, a{~2~} ... a{~x~}$ cu proprietatea ca exista un tunel intre $a{~i~}$ si $a{~i+1~}$ pentru orice $i < x$\r\n* Se garanteaza ca exista cel putin un drum intre fiecare din cele $K$ perechi de laboratoare din fisierul de intrare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. radiatie.in |_. radiatie.out |\r\n| 6 6 8\r\n1 2 5\r\n2 3 4\r\n3 4 3\r\n1 4 8\r\n2 5 7\r\n4 6 2\r\n1 2\r\n1 3\r\n1 4\r\n2 3\r\n2 4\r\n5 1\r\n6 2\r\n6 1\r\n| 5\r\n5\r\n5\r\n4\r\n4\r\n7\r\n4\r\n5\r\n| \r\n\r\n== include(page=\"template/taskfooter\" task_id=\"radiatie\") ==\r\n',1,'task: radiatie'),('runda/preoni-2007','preoni-2007','2007-01-19 23:27:51','h1. == roundparam(round_id=\"preoni-2007\" param=\"title\") ==\r\n\r\np>. ==roundstatus(round_id=\"preoni-2007\")==\r\n\r\nConcursul incepe ==roundparam(round_id=\"preoni-2007\" param=\"start_time\")== si dureaza\r\n==roundparam(round_id=\"preoni-2007\" param=\"duration\")== ore.\r\n\r\nClasamentul poate fi vizualizat \'aici\':preoni-2007/clasament\r\n\r\nh2. Probleme\r\n\r\nAceasta lista va deveni vizibila doar in momentul inceperii concursului.\r\n\r\n== Tasks(round_id=\"preoni-2007\" score=\"1\")==',1,'round: preoni-2007'),('runda/preoni-2007/clasament','Clasament preoni-2007','2007-01-19 23:27:51','h1. Clasament ==roundparam(round_id=\"preoni-2007\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni-2007\")==',1,'round: preoni-2007'),('documentatie','Documentatie','2007-01-20 18:03:00','h1. Documentatie\r\n\r\nAici centralizam toate paginile care prezinta modul in care se utilizeaza site-ul si evaluatorul infoarena.\r\n\r\n* {\'Wiki\':documentatie/wiki}: O introducere in wiki-ul infoarena.\r\n** {\'Sintaxa Textile\':documentatie/textile}: Detalii hardcore despre formatarea cu textile.\r\n** {\'Macro-uri\':documentatie/macro-uri}: Ce sunt, cum se folosesc, cateva macro-uri comune.\r\n** {\'Conventii de formatare\':documentatie/conventii-de-formatare}: Cum anume se foloseste formatarea pentru a ajunge la un look uniform.\r\n* {\'Ghid utilizator\':documentatie/pentru-utilizatori}: Inregistrare, submit, monitor, clasament. Cat mai scurt.\r\n** {\'Monitorul de evaluare\':documentatie/monitorul-de-evaluare}: Ce este si cum se foloseste monitorul de evaluare.\r\n** {\'Trimiterea solutiilor\':documentatie/trimiterea-solutiilor}: Cum se trimit solutii.\r\n** {\'Pagina de profil\':documentatie/pagina-de-profil}: Cum se face o pagina de profil pe infoarena.\r\n** {\'Rating\':documentatie/rating}: Ce este si cum functioneaza sistemul de rating\r\n** {\'Tutorial infoarena\':documentatie/tutorial}: Un tutorial infoarena\r\n* {\'Ghid propunatori\':documentatie/pentru-propunatori}: Cum devii propunator, ce inseamna.\r\n** {\'Editare de probleme\':documentatie/editare-de-probleme}: cum se pun teste, cum se verifica etc.\r\n** {\'Editare de runde\':documentatie/editare-de-runde}: cum sa fac un concurs privat.\r\n* {\'Ghid administrare\':documentatie/administrare}\r\n** {\'Securitate\':documentatie/securitate}\r\n** {\'Development stuff\':documentatie/development}\r\n** {\'Pagini speciale\':documentatie/pagini-de-administrare}',1,'public'),('problema/1-sir','1-sir','2007-01-21 14:02:55','== include(page=\"template/taskheader\" task_id=\"1-sir\") ==\r\n\r\nDefinim un {$1-sir$} de lungime $N$ un sir $s$ cu proprietatea {$|s{~i~} - s{~i+1~}| = 1$} pentru {$0 < i < N$} si {$s{~1~} = 0$}. Calculati numarul de 1-siruri de lungime $N$ cu suma tuturor termenilor $S$.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului {$1-sir.in$} se afla numerele $N$ si $S$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului {$1-sir.out$} se va afisa numarul de 1-siruri de lungime $N$ care au suma $S$, modulo $194767$.\r\n\r\nh2. Restrictii\r\n\r\n* $1 < N &le; 256$\r\n* $-2^31^ < S < 2^31^$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. 1-sir.in |_. 1-sir.out |\r\n| 4 4\r\n| 1\r\n| \r\n\r\n== include(page=\"template/taskfooter\" task_id=\"1-sir\") ==\r\n',1,'task: 1-sir'),('problema/pachete','Pachete','2007-01-21 01:09:29','== include(page=\"template/taskheader\" task_id=\"pachete\") ==\r\n\r\nZaharel si-a facut firma de curierat si trebuie sa transporte cate un pachet fiecaruia din cei $N$ clienti din oras. Orasul in care locuieste Zaharel este foarte asemanator cu Manhattan, in sensul ca te poti deplasa doar pe directiile nord-sud si est-vest. De asemenea, fiecare client, cat si sediul firmei, poate fi reprezentat printr-un punct in plan. Fiecare pachet trebuie livrat cat de repede posibil, astfel incat livrarea pachetelor se va face mereu pe un drum de distanta (Manhattan) minima. Deoarece predarea pachetului unui client se face foarte repede, pe drumul catre un client, Zaharel poate alege sa livreze pachete si altor clienti, cu conditia sa se pastreze distanta minima.\r\nStiind locatia sediului si a celor $N$ clienti, determinati numarul minim de drumuri pe care trebuie sa le faca Zaharel pentru a livra toate pachetele. \r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul $pachete.in$ se afla pe prima linie numarul natural $N$ reprezentand numarul de clienti. A doua linie va contine doua numere naturale $Ox Oy$ reprezentand coordonatele $x$, respctiv $y$ a sediului firmei. Urmeaza $N$ linii fiecare continand doua numere naturale $X{~i~}$ $Y{~i~}$, reprezentand coordonatele clientilor.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $pachete.out$ va contine o singura linie pe care se va afla numarul minim de drumuri pe care trebuie sa le faca Zaharel.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 50.000$\r\n* Distana Manhattan dintre doua puncte $(x{~1~},y{~1~})$ si $(x{~2~},y{~2~})$ este $|x{~1~}-x{~2~}|+|y{~1~}-y{~2~}|$\r\n* Toatele cele $N$ puncte, cat si sediul firmei, au coordonatele $x$ diferite doua cate doua, cat si coordonatele $y$\r\n* $0 &le; x{~i~}, y{~i~} &le; 2*10^9^$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. pachete.in |_. pachete.out |\r\n| 4\r\n0 3\r\n1 2\r\n2 5\r\n3 0\r\n4 1\r\n| 3 |\r\n\r\nh3. Explicatie\r\n\r\nCele 3 drumuri sunt:\r\n$(0,3) -> (2,5)$\r\n$(0,3) -> (1,2) -> (3,0)$\r\n$(0,3) -> (4,1)$\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"pachete\") ==\r\n',1,'task: pachete'),('problema/patrate3','patrate3','2007-01-20 20:41:13','== include(page=\"template/taskheader\" task_id=\"patrate3\") ==\r\n\r\nJohnie a desenat pe o hartie $N$ puncte, si le-a incadrat intr-un reper cartezian. El se intreaba acum cate patrate exista care sa aiba colturile in punctele desenate de el.\r\nStiind numarul de puncte si coordonatele acestea, se cere sa determinati numarul de patrate ce se pot forma folosind drept colturi punctele date.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $patrate3.in$ se afla $N$, numarul de puncte. Pe urmatoarele $N$ linii se gaseste cate o pereche {$x y$}, reprezentand coordonatele ( absicsa si ordonata ) unui punct din cele {$N$} date.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul $patrate3.out$ contine pe prima linie numarul cerut.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 1000$\r\n* Coordonatele punctelor sunt numere reale cu exact $4$ zecimale din intervalul $[-10000, 10000]$\r\n* Punctele date sunt distincte\r\n* Patratele ce se formeaza nu au neaparat laturile paralele cu axele\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. patrate3.in |_. patrate3.out |\r\n|10\r\n18.3350 44.1050\r\n91.3200 13.3600\r\n49.1500 50.6900\r\n35.9300 34.8700\r\n42.0900 17.6800\r\n9.1000 26.5100\r\n88.9000 53.1100\r\n51.5700 10.9400\r\n26.6950 17.2750\r\n74.9300 28.6800\r\n|2| \r\n\r\n== include(page=\"template/taskfooter\" task_id=\"patrate3\") ==',256,'task: patrate3'),('problema/triplete','Triplete','2007-01-24 22:55:14','== include(page=\"template/taskheader\" task_id=\"triplete\") ==\r\n\r\nZaharel are o ferma de $N$ animale, numerotate convenabil cu numere de la $1$ la $N$. Observand activitatea animalelor a constatat ca anumite animale sunt prietene intre ele. Curios de felul lui, Zaharel si-a pus intrebarea cate triplete de animale exista astfel incat oricare doua animale din triplet sa fie prietene. \r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $triplete.in$ va contine pe prima linie doua numere naturale $N M$ separate prin cate un spatiu, reprezentand numarul de animale si numarul de relatii de prietenie.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $triplete.out$ va contine un singur numar natural pe prima linie reprezetand numarul de triplete care se pot forma.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 4096$\r\n* $1 &le; M &le; 65536$\r\n* Daca animalul $a$ este prieten cu animalul $b$, atunci si animalul $b$ este prieten cu animalul $a$\r\n* Toate relatiile de prietenie din fisierul de intrare sunt distincte\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. triplete.in |_. triplete.out |\r\n| 4 5\r\n1 2\r\n2 3\r\n1 3\r\n2 4\r\n3 4\r\n| 2 | \r\n\r\n== include(page=\"template/taskfooter\" task_id=\"triplete\") ==\r\n',18,'task: triplete'),('runda/preoni2007_runda1_9/clasament','Clasament preoni2007_runda1_9','2007-01-20 21:42:53','h1. Clasament ==roundparam(round_id=\"preoni2007_runda1_9\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni2007_runda1_9\")==',1,'round: preoni2007_runda1_9'),('runda/preoni2007_runda1_10/clasament','Clasament preoni2007_runda1_10','2007-01-20 22:41:46','h1. Clasament ==roundparam(round_id=\"preoni2007_runda1_10\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni2007_runda1_10\")==',1,'round: preoni2007_runda1_10'),('runda/preoni2007_runda1_1112/clasament','Clasament preoni2007_runda1_1112','2007-01-20 22:47:03','h1. Clasament ==roundparam(round_id=\"preoni2007_runda1_1112\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni2007_runda1_1112\")==',1,'round: preoni2007_runda1_1112'),('preoni-2007/clasament/runda-1/9','Clasament preONI 2007, Runda 1, Clasa a 9-a si gimnaziu','2007-01-21 11:49:39','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. == roundparam(round_id=\"preoni2007_runda1_9\" param=\"title\") ==\r\n\r\n==include(page=\"template/preoni-2007/clasament-header\")==\r\n\r\n(htabs)*(active) \'Clasa a 9-a si gimnaziu\':preoni-2007/clasament/runda-1/9\r\n* \'Clasa a 10-a\':preoni-2007/clasament/runda-1/10\r\n* \'Clasele 11-12\':preoni-2007/clasament/runda-1/11-12\r\n\r\np<. == Rankings(rounds=\"preoni2007_runda1_9\") == \r\n\r\n==include(page=\"template/preoni-2007/footer\")==\r\n',13,'protected'),('preoni-2007/clasament/runda-1/10','Clasament preONI 2007, Runda 1, Clasa a 10-a','2007-01-21 11:49:27','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. == roundparam(round_id=\"preoni2007_runda1_10\" param=\"title\") ==\r\n\r\n==include(page=\"template/preoni-2007/clasament-header\")==\r\n\r\n(htabs)* \'Clasa a 9-a si gimnaziu\':preoni-2007/clasament/runda-1/9\r\n*(active) \'Clasa a 10-a\':preoni-2007/clasament/runda-1/10\r\n* \'Clasele 11-12\':preoni-2007/clasament/runda-1/11-12\r\n\r\np<. == Rankings(rounds=\"preoni2007_runda1_10\") == \r\n\r\n==include(page=\"template/preoni-2007/footer\")==\r\n',13,'protected'),('preoni-2007/clasament/runda-1/11-12','Clasament preONI 2007, Runda 1, Clasele 11-12','2007-01-21 11:48:44','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. == roundparam(round_id=\"preoni2007_runda1_1112\" param=\"title\") ==\r\n\r\n==include(page=\"template/preoni-2007/clasament-header\")==\r\n\r\n(htabs)* \'Clasa a 9-a si gimnaziu\':preoni-2007/clasament/runda-1/9\r\n* \'Clasa a 10-a\':preoni-2007/clasament/runda-1/10\r\n*(active) \'Clasele 11-12\':preoni-2007/clasament/runda-1/11-12\r\n\r\n\r\np<. == Rankings(rounds=\"preoni2007_runda1_1112\") == \r\n\r\n==include(page=\"template/preoni-2007/footer\")==\r\n',13,'protected'),('template/inscriere','template/inscriere','2007-01-21 02:27:10','Inscrierea este necesara pentru a putea participa la concurs. Doresti sa continui?\r\n\r\n*Atentie!* \'Rating-ul\':documentatie/rating tau va fi afectat, chiar si daca nu vei trimite solutii!\r\n\r\n\'Vezi cine s-a inscris\':lista-inregistrare/%round%',13,'protected'),('runda/test-cristi','test-cristi','2007-01-20 23:22:29','h1. == roundparam(round_id=\"test-cristi\" param=\"title\") ==\r\n\r\np>. ==roundstatus(round_id=\"test-cristi\")==\r\n\r\n== roundregister(round_id=\"test-cristi\") ==\r\n\r\nConcursul incepe ==roundparam(round_id=\"test-cristi\" param=\"start_time\")== si dureaza ==roundparam(round_id=\"test-cristi\" param=\"duration\")== ore.\r\n\r\nClasamentul poate fi vizualizat \'aici\':test-cristi/clasament\r\n\r\nh2. Probleme\r\n\r\nAceasta lista va deveni vizibila doar in momentul inceperii concursului.\r\n\r\n== Tasks(round_id=\"test-cristi\" score=\"1\")==',13,'round: test-cristi'),('runda/test-cristi/clasament','Clasament test-cristi','2007-01-20 23:22:29','h1. Clasament ==roundparam(round_id=\"test-cristi\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"test-cristi\")==',13,'round: test-cristi'),('problema/test-p1','test-p1','2007-01-20 23:23:33','== include(page=\"template/taskheader\" task_id=\"test-p1\") ==\r\n\r\nPoveste si cerinta...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n... &le; ...\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. test-p1.in |_. test-p1.out |\r\n| This is some\r\n  text written on\r\n  multiple lines.\r\n| This is another\r\n  text written on\r\n  multiple lines.\r\n| \r\n\r\nh3. Explicatie\r\n\r\n...\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"test-p1\") ==\r\n',13,'task: test-p1'),('preoni-2007/runda-1/9','preONI 2007, Runda 1, Clasa a 9-a si gimnaziu','2007-01-21 14:12:45','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. == roundparam(round_id=\"preoni2007_runda1_9\" param=\"title\") ==\r\n\r\n==roundregister(round_id=\"preoni2007_runda1_9\" template=\"template/preoni-2007/inscriere-runda\")==\r\n\r\nAceasta runda s-a incheiat. \'*Vezi clasamentul*\':preoni-2007/clasament/runda-1/9.\r\n\r\nRunda s-a desfasurat Duminica 21 ianuarie, la ora {*09^30^*} si a durat 4h.\r\nParticipantii au avut de rezolvat 3 probleme de natura algoritmica.\r\n\r\nh2. Probleme\r\n\r\n== Tasks(round_id=\"preoni2007_runda1_9\" score=\"1\")==\r\n\r\nh2. Discutii pe forum\r\n\r\nVrei sa adresezi intrebari comisiei? Fa-o pe forum.\r\n\r\n==SmfTopics(board_id=\"35\" count=\"10\")==\r\n\r\n==include(page=\"template/preoni-2007/footer\")==\r\n',13,'protected'),('preoni-2007/runda-1/10','preONI 2007, Runda 1, Clasa a 10-a','2007-01-21 14:13:37','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. == roundparam(round_id=\"preoni2007_runda1_10\" param=\"title\") ==\r\n\r\n==roundregister(round_id=\"preoni2007_runda1_10\")==\r\n\r\nAceasta runda s-a incheiat. \'*Vezi clasamentul*\':preoni-2007/clasament/runda-1/10.\r\n\r\nRunda s-a desfasurat Duminica 21 ianuarie, la ora {*09^30^*} si a durat 4h.\r\nParticipantii au avut de rezolvat 3 probleme de natura algoritmica.\r\n\r\nh2. Probleme\r\n\r\n== Tasks(round_id=\"preoni2007_runda1_10\" score=\"1\")==\r\n\r\nh2. Discutii pe forum\r\n\r\nVrei sa adresezi intrebari comisiei? Fa-o pe forum.\r\n\r\n==SmfTopics(board_id=\"35\" count=\"10\")==\r\n\r\n==include(page=\"template/preoni-2007/footer\")==\r\n',13,'protected'),('preoni-2007/runda-1/11-12','preONI 2007, Runda 1, Clasele 11-12','2007-01-21 14:14:30','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. == roundparam(round_id=\"preoni2007_runda1_1112\" param=\"title\") ==\r\n\r\n==roundregister(round_id=\"preoni2007_runda1_1112\")==\r\n\r\nAceasta runda s-a incheiat. \'*Vezi clasamentul*\':preoni-2007/clasament/runda-1/11-12.\r\n\r\nRunda s-a desfasurat Duminica 21 ianuarie, la ora {*09^30^*} si a durat 4h.\r\nParticipantii au avut de rezolvat 3 probleme de natura algoritmica.\r\n\r\nh2. Probleme\r\n\r\n== Tasks(round_id=\"preoni2007_runda1_1112\" score=\"1\")==\r\n\r\nh2. Discutii pe forum\r\n\r\nVrei sa adresezi intrebari comisiei? Fa-o pe forum.\r\n\r\n==SmfTopics(board_id=\"35\" count=\"10\")==\r\n\r\n==include(page=\"template/preoni-2007/footer\")==\r\n',13,'protected'),('stiri/preoni-2007-runda-1','S-a incheiat Runda din preONI 2007!','2007-01-22 22:04:00','h1. S-a incheiat Runda din preONI 2007!\r\n\r\nPrima runda a concursului \'preONI 2007\':preoni-2007 s-a incheiat. Gasiti pe \'pagina rundei\':preoni-2007/runda-1 problemele , clasamentele si articolul cu solutii.',1,'public'),('preoni-2007/runda-1','Runda 1 preONI 2007','2007-01-22 22:04:38','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Runda 1\r\n\r\nRunda 1 s-a incheiat.\r\n\r\nRunda a inceput Duminica 21 ianuarie, la ora {*09^30^*} si a durat 4h. Participantii au avut de rezolvat 3 probleme de natura algoritmica.\r\n\r\nh2. Despre inscriere\r\n\r\np{color:red}. *ATENTIE!* Ca sa poata participa la aceasta runda, concurentii au trebuit sa se inscrie *inainte de ora 09^30^* la grupa de varsta corespunzatoare! *Nu au putut participa* elevii care nu s-au inscris la o grupa de varsta *inainte de ora 09^30^*.\r\n\r\nAceeasi procedura se va urma la fiecare runda preONI. Timp de cateva zile inainte de inceperea unei noi runde, concurentii se pot inscrie la grupa lor de varsta. Inscrierea se face printr-un simplu click. *Nu trebuie sa va inregistrati din nou pe site!*\r\n\r\nInscrierile se pot face pana la inceperea rundei. Dupa afisarea problemelor, concurentii nu pot participa daca nu s-au inscris.\r\n\r\nh2. Probleme\r\n\r\nClick pe grupa de varsta&hellip;\r\n\r\n* \'Clasa a 9-a si gimnaziu\':preoni-2007/runda-1/9\r\n* \'Clasa a 10-a\':preoni-2007/runda-1/10\r\n* \'Clasele 11-12\':preoni-2007/runda-1/11-12\r\n\r\nPoti vedea solutiile problemelor \'aici\':preoni-2007/runda-1/solutii\r\n\r\nh2. Clasament Runda 1\r\n\r\n* \'Clasa a 9-a si gimnaziu\':preoni-2007/clasament/runda-1/9\r\n* \'Clasa a 10-a\':preoni-2007/clasament/runda-1/10\r\n* \'Clasele 11-12\':preoni-2007/clasament/runda-1/11-12\r\n\r\nh2. Discutii preONI pe forum\r\n\r\n==SmfTopics(board_id=\"35\" count=\"10\")==\r\n\r\nh2. Organizatori\r\n\r\n* Subiectele vor fi propuse de:\r\n==User(user=\"danielp\" type=\"tiny\")==\r\n==User(user=\"ditzonec\" type=\"tiny\")==\r\n==User(user=\"domino\" type=\"tiny\")==\r\n==User(user=\"filipb\" type=\"tiny\")==\r\n==User(user=\"greco\" type=\"tiny\")==\r\n\r\n* Pentru intrebari de factura organizatorica / tehnica poti contacta urmatoarele persoane:\r\n==User(user=\"fluffy\" type=\"tiny\")==\r\n==User(user=\"svalentin\" type=\"tiny\")==\r\n==User(user=\"wickedman\" type=\"tiny\")==\r\n\r\n*{\'Echipa infoarena\':echipa-infoarena}* iti ureaza mult succes!\r\n\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==',1,'protected'),('template/preoni-2007/clasament-header','template/preoni-2007/clasament-header','2007-01-22 22:01:54','&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;\r\n\r\n&nbsp;',1,'protected'),('template/userheader','template/userheader','2007-01-21 14:06:01','h1. ==UserInfo(user=\"%user%\" info=\"fullname\")== (%user%)\r\n\r\n== include(page=\"template/userinfo\" user=\"%user%\") ==\r\n',13,'protected'),('runda/unirea9-10/clasament','Clasament unirea9-10','2007-01-22 16:12:12','h1. Clasament ==roundparam(round_id=\"unirea9-10\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"unirea9-10\")==',1,'round: unirea9-10'),('runda/unirea11-12/clasament','Clasament unirea11-12','2007-01-22 16:31:00','h1. Clasament ==roundparam(round_id=\"unirea11-12\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"unirea11-12\")==',1,'round: unirea11-12'),('problema/maxsecv','maxsecv','2007-01-27 10:58:25','== include(page=\"template/taskheader\" task_id=\"maxsecv\") ==\r\n\r\nJohnie areun vector binar de $N$ elemente. El poate extrage o anumita subsecventa din vector, ramanand astfel cu un vector mai mic. Apoi, el poate insera subsecventa extrasa la orice pozitie din vectorul rezultat.\r\nSe cere sa se afle lungimea maxima a unei subsecvente pline de $1$ pe care o poate obtine Johnie daca efectueaza o singura operatie.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $maxsecv.in$ se afla $N$, dimensiunea vectorului. Urmeaza apoi pe urmatoarea linie $N$ numere de $0$ si $1$, reprezentand elementele vectorului.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $maxsecv.out$ trebuie sa contina un singur numar, reprezentand valoarea ceruta.\r\n\r\nh2. Restrictii\r\n\r\n*    $1 &le; N &le; 1 000 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. maxsecv.in |_. maxsecv.out |\r\n|6\r\n1 1 0 1 1 1\r\n|5| \r\n|13\r\n0 1 1 1 0 1 1 1 1 0 1 1 0\r\n|7|\r\n\r\nh3. Explicatie\r\n\r\nLa primul exemplu Johnie poate muta subsecventa formata din ultimele 3 elemente ale vectorului la inceputul acestuia, obtinand o subsecventa formata din 5 de 1.\r\nLa al doilea exemplu Johnie poate selecta secventa de 4 de 1 din interiorul vectorului si o poate muta langa secventa de 3 de 1 de la inceput.\r\n\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"maxsecv\") ==\r\n',256,'task: maxsecv'),('preoni-2007/runda-1/solutii','Solutii preONI 2007, Runda 1','2007-01-23 19:38:37','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Solutii Runda 1\r\n\r\nh2. Aprindere \r\n\r\nh3. (problema usoara, clasa a 9-a)\r\n\r\nEste evident ca nu are rost sa actionam un intrerupator de mai multe ori. In aceste conditii, solutia este unica, deoarece nu putem avea doua intrerupatoare intr-o singura camera. Cu alte cuvinte, daca parcurgem camerele de la stanga la dreapta si intalnim o camera cu becul inchis, va trebui sa actionam intrerupatorul unic din camera respectiva. Daca am fi permis ca o camera sa aiba mai multe intrerupatoare, problema s-ar fi complicat semnificativ.\r\nSe pot afla usor intrerupatoarele care trebuie actionate astfel: se parcurg camerele de la stanga la dreapta, iar in momentul in care ajungem la o camera cu becul inchis trebuie sa actionam intrerupatorul din camera respectiva (daca nu exista intrerupator, atunci nu avem solutie). Cum intrerupatorul respectiv actioneaza becuri din camere &ge; $i$, nu vom modifica nimic din becurile precedente. De asemenea, vom aduna costul lor la rezultat. \r\n\r\nh2. Patrate3 \r\n\r\nh3. (problema medie, clasa a 9-a)\r\n\r\nMai intai sortam punctele crescator dupa abscisa, iar pentru abscise egale dupa ordonata. Acum, folosind cautarea binara putem cauta orice punct in timp logaritmic. Pentru fiecare pereche de puncte vom forma patratul care are o diagonala formata din perechea respectiva. Dupa ce calculam si celelalte 2 puncte, le cautam binar in vectorul sortat. Daca le gasim, inseamna ca am mai gasit un patrat. Complexitatea solutiei este $O(N^2^ log N)$. Precizia recomandata este de $10^-4^$.\r\nSingura problema care ramane de rezolvat acum e calcularea punctelor patratului daca stim doar o diagonala. O metoda simpla de gasire a lor, ce nu necesita cunostiinte avansate de geometrie, este observarea simetriilor care se formeaza fata de centrul patratului. Fie $x0, y0$ si $x1, y1$ coordonatele diagonalei cunoscute iar $x2, y2$ si $x3, y3$ coordonatele necunoscute. Centrul patratului este mijlocul unei diagonale, deci coordonatele lui sunt $mijx = (x0 + x1) / 2$ si $mijy = (y0 + y1) / 2$. Sa notam $dx = abs(mijx - x0)$ si $dy = abs(mijy - y0)$. Se observa ca daca $y0 < y1$ atunci $x2 = mijx + dy, y2 = mijy - dx, x3 = mijx - dy$ iar $y3 = mijy + dx$. In caz contrar, avem $x2 = mijx - dy, y2 = mijy - dx, x3 = mijx + dy$ iar $y3 = mijy + dx$.\r\n\r\nh2. Elimin \r\n\r\nh3. (problema grea, clasa a 9-a / problema medie, clasa a 10-a)\r\n\r\nDaca $S$ este suprafata ( aria ) matricii, este evident ca {$minim(M, N) &le; sqrt(S)$}. Pentru primele $3$ teste se observa ca cel putin o dimensiune este &le; 10. Pentru celelalte teste avem:\r\n\r\n* 266 = 2 * 7 * 19\r\n* 539 = 7 * 7 * 11\r\n* 1630 = 2 * 5 * 163\r\n* 3495 = 3 * 5 * 233\r\n* 3653 = 13 * 281\r\n* 5866 = 2 * 7 * 419\r\n* 7294 = 2 * 7 * 521\r\n\r\nSe observa ca in toate cazurile de mai sus, oricum am grupa numerele prime pentru a obtine dimensiunile matricii, cea mai mica dintre dimensiuni nu poate depasi {$15$}. Deci, in toate testele, stim sigur ca {$min(M, N) &le; 15$}. Sa presupunem ca aceasta dimensiune este numarul coloanelor, {$N$}, celalalt caz rezolvandu-se identic, rotind matricea.\r\nPutem genera toate posibilitatile de a elimina exact {$C$} coloane din numarul total de {$N$}. Pentru fiecare caz generat, calculam suma elementelor ramase pentru fiecare linie in parte, si sortam aceste sume. Evident, vom elimina cele mai mici {$R$} sume.\r\nComplexitatea unui astfel de algoritm este deci {$O(2^N^  * (M log M + M*N))$}.\r\n\r\nh2. Triplete\r\n\r\nh3. (problema usoara, clasa a 10-a)\r\n\r\nPutem considera cele $N$ animale ca fiind noduri ale unui graf neorientat si o relatie de forma $i j$ ca fiind muchie intre nodurile $i$ si {$j$}. Problema cere determinarea numarului de triunghiuri in graful astfel construit ( numarul de triplete de noduri astfel incat intre oricare doua noduri din triplet exista muchie ). O solutie imediata are complexitatea {$O(N^3^)$}, prin generarea tuturor tripletelor. O solutie mai buna se bazeaza pe urmatorul rationament: pentru fiecare muchie din graf $a b$ trebuie sa vedem cate noduri adiacente cu $a$ si $b$ exista in graf ( adica cate triunghiuri care contin nodurile $a$ si $b$ se pot forma ). Pentru o muchie fixata este suficienta iterarea prin lista de adiacenta a nodurilor $a$ si $b$ si adunarea la numarul total de solutii a numarului de noduri comune. Acest algoritm are complexitatea {$O(M * N)$}, pentru ca parcurgerea unei liste de adiacenta se realizeaza in $O(N)$. Algoritmul de mai sus poate fi optimizat prin tinerea pe grupuri de biti a listei de adiacenta. Astfel, pentru orice nod {$i$}, primii $B$ biti din lista lui de adiacenta vor reprezenta legaturile cu primele $B$ noduri din cele {$N$} ( bit 1 pentru legatura si 0 altfel ), urmatorii $B$ biti legaturile cu nodurile $B+1...2*B$, etc. Pentru a vedea cate noduri adiacente comune au $a$ si $b$ este suficient sa realizam o operatie AND intre grupurile corespunzatoare de biti din listele de adiacenta ale lui $a$ si ale lui $b$ si sa adunam la numarul total de solutii numarul de biti de 1 din acest numar. Complexitatea acestui algoritm este {$O(M*N/B)$}, unde $B$ este numarul de biti dintr-un grup.\r\n\r\nh2. Pachete\r\n\r\nh3. (problema grea, clasa a 10-a)\r\n\r\nSa consideram initial ca oficiul postal este in punctul de coordonate {$(0, 0)$} si restul oraselor au coordonate pozitive ( sunt toate in primul cadran ). Se sorteaza orasele dupa abscisa {$X$}. Dupa sortare, acestea trebuie partitionate intr-un numar minim de subsiruri astfel incat intr-un subsir coordonatele punctelor ({$Y$}) sa fie crescatoare. Un astfel de subsir reprezinta drumul unui postas (este de cost minim deoarece mereu merge in dreapta si in sus). Algoritmul optim pentru aflarea numarului minim de subsiruri crescatoare in care poate fi partitionat un sir are complexitatea {$O(NlogN)$}. Primul element va face parte din primul subsir. La pasul {$i$}, {$i>1$}, elementul al $i$-lea va fi introdus in acel subsir care se termina intr-un element cu valoare mai mica decat elementul curent si care are valoarea maxima dintre toate elementele de acest tip. Cautarea se poate face cu o cautare binara in raport cu ultimele pozitii pentru fiecare subsir, pentru ca se observa ca printr-un astfel de procedeu ultimile valori vor fi intotdeauna sortate descrescator.\r\nDaca oficiul postal se afla in {$(Px, Py)$}, acest punct imparte planul in {$4$} cadrane, si se aplica aceeasi rezolvare de mai sus pentru fiecare cadran.\r\n\r\n\r\nh2. 1-sir\r\n\r\nh3. (problema usoara, clasele 11-12)\r\n\r\nPrima observatie este aceea ca valoarea maxima pe care o poate lua $S$ este {$N * (N-1) / 2$}, sirul {$s$} fiind egal cu {$(0, 1, 2... N-1)$}, iar valoarea minima {${@-N * (N-1) / 2@}$}, caz in care sirul este egal cu {$(0, {@-1@}, {@-2@}... {@-(N-1)@})$}. Daca notam cu {$D[N][S]$} numarul de 1-siruri cu $N$ termeni care au suma elementelor $S$, atunci se observa ca {$D[N][S] = D[N-1][S-(N-1)] + D[N-1][S+(N-1)]$}, deoarece avem doua posibilitati de alegere pentru al doilea element (1 sau -1), si fiecare alegere poate fi interpreta ca o translatie pentru fiecare din elementele urmatoare cu 1 sau -1 ( deci in total o translatie in functie de suma de {$N-1$}, cu plus sau cu minus ). Pentru a evita folosirea indicilor negativi pentru suma este suficient sa observam ca {$D[N][S] = D[N][-S]$}, pentru orice {$S > 0$}, relatie evidenta din faptul ca se poate forma o bijectie intre 1-sirurile cu suma {$S$} si cele cu suma {${@-S@}$} printr-o simpla inmultire cu -1. Pentru ca algoritmul sa se incadreze in limita de memorie este suficient sa retinem doar ultimele doua linii din tabloul $D$. Un astfel de algoritm are complexitate $O(N^3^)$ si obtine punctajul maxim.\r\n\r\nh2. Diviz\r\n\r\nh3. (problema medie, clasele 11-12)\r\n\r\nProblema se rezolva prin metoda programarii dinamice. Fie {@M[j][i][r]@} numarul de moduri de a alege subsiruri distincte de lungime $j$ din primele $i$ cifre ale numarului {$N$}, subsiruri care sa dea restul $r$ la impartirea {$K$}. Daca ne aflam in starea {$(j, i, r)$} putem sa actualizam starea {$(j+1, first[cif][i+1], (r*10+cif) mod K)$}, considerand ca am adaugat la sfarsitul fiecarui subsir definit de {$(j, i, r)$} cifra {$cif$}. Prin {$first[cif][i]$} se defineste prima aparitie in numarul $N$ a cifrei $cif$ dupa pozitia {$i$}. Tabloul $first$ va fi, evident, preprocesat. Pentru a numara subsirurile distincte ( adica sa nu numaram subsiruri egale de doua ori ), daca suntem in starea {$(j, i, r)$} actualizam starea {$(j+1, first[cif][i+1], (r*10+cif) mod K)$} daca si numai daca intre pozitiile $i+1$ si $first[cif][i+1]-1$ in numarul $N$ nu mai apare nici o cifra {$cif$}. Acest lucru poate fi deasemenea calculat prin preprocesare, inainte de a incepe algoritmul de programare dinamica.\r\nComplexitatea finala a algoritmului este {$O(K * L^2^)$}, unde L este numarul de cifre ale numarului {$N$}.\r\n\r\nh2. Radiatie\r\n\r\nh3. (problema grea, clasele 11-12)\r\n\r\nPrimul pas in rezolvarea problemei este construirea arborelui partial de cost minim a grafului dat in {$O(M*logM)$}, folosind unul din algoritmii clasici precum Kruskal sau Prim. Se poate demonstra ca o interogare in graful initial este echivalenta cu o interogare in arborele partial minim.\r\nPentru a determina cea mai mare valoare a unei muchii pe drumul unic din arbore intre nodurile $i$ si $j$ procedam astfel: pentru orice nod $i$ din arbore si pentru orice $j$, fie {$A[i][j]$} = al {$2^j^$}-lea stramos al nodului $i$ in drumul spre radacina ( aleasa aleator la inceput ) si {$B[i][j]$} = muchia de cost maxim dintre cei {$2^j^$} stramosi ai nodului {$i$}. Precalculand aceste matrici in {$O(N*logN)$} se poate raspunde la un query in {$O(log N)$}, mergand inspre radacina simultan din $x$ si $y$ pe stramosi pe baza puterilor lui 2 pana cand intalnim primul nod care este stramos al ambelor noduri. La fiecare pas vom actualiza raspunsul prin compararea cu valorea elementelor corespunzatoare din tabloul $B$.\r\nO solutie si mai simpla de implementat este folosirea arborelui care rezulta in urma algoritmului lui Kruskal, renuntand la euristica de compresie a drumului, si folosind doar euristica dupa rang. Se poate demonstra ca o interogare in arborele partial minim este echivalenta cu o interogare in arborele de multimi disjuncte obtinut din algoritmul lui Kruskal. Cum acest arbore are inaltimea {$O(logN)$}, se poate folosi o parcurgere triviala pentru a raspunde la orice query.\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==',1490,'public'),('unirea-2007','Unirea 2007','2007-01-28 20:49:26','(htabs)*(active) \'*Home*\':unirea-2007\r\n* \'Clasele IX-X\':unirea-2007/clasele-9-10\r\n* \'Clasele XI-XII\':unirea-2007/clasele-11-12\r\n* \'Rezultate\':unirea-2007/rezultate-9-10\r\n\r\nh1. Unirea 2007\r\n\r\nCa parte din cadrul manifestarilor _Zilele Unirii_, infoarena gazduieste un concurs de informatica online - *cu premii si diplome* - la care sunt invitati elevi din toata tara.\r\n\r\nConcursul incepe *Sambata, 27 ianuarie la ora 14^00^* si dureaza *3h*.\r\n\r\np{color:red}. *ATENTIE!* Pentru a participa la acest concurs, trebuie sa te inscrii inainte de ora 14^00^, 27 ian. la grupa de varsta corespunzatoare! Nu pot participa elevii care nu se inscriu la grupa lor de varsta inainte de ora 14^00^, 27 ian.\r\n\r\nInscrierea se face printr-un simplu click. Nu trebuie sa te inregistrezi din nou pe site!\r\n\r\nh2. Alege-ti grupa de varsta\r\n\r\n* \'*Clasele IX si X*\':unirea-2007/clasele-9-10\r\n* \'*Clasele XI si XII*\':unirea-2007/clasele-11-12\r\n\r\nSolutiile oficiale la probleme se gasesc \'aici\':unirea-2007/solutii.\r\n\r\nh2. Despre Unirea 2007\r\n\r\nIn perioada 26 - 28 ianuarie 2007, Colegiul National Unirea, Primaria Focsani, Inspectoratul Scolar Vrancea si Microsoft Romania organizeaza, in cadrul manifestarilor _Zilele Unirii_, intalnirea cu tema Resurse IT&amp;C in educatie.\r\n\r\nCele doua zile dedicate acestei intalniri vor cuprinde:\r\n\r\n* concurs online de informatica gazduit de infoarena.ro\r\n* concurs de proiecte realizate de elevi in domeniile: pagini web, software educational &amp; utilitar, multimedia\r\n* concurs de matematica\r\n\r\n&rarr; \'Vezi pagina oficiala a acestei manifestari\':http://unirea.lufo.ro/\r\n\r\nh2. Cum particip?\r\n\r\nInainte de toate trebuie sa \'te inregistrezi\':register pe site-ul nostru.\r\n\r\nOricine este invitat sa participe. In ziua de concurs intri pe site, citesti probleme, le rezolvi si trimiti solutiile inainte de expirarea timpului de lucru. La sfarsitul rundei, \'evaluatorul\':evaluator infoarena iti va testa solutiile pentru corectitudine. Clasamentul se va actualiza in timp real pe parcursul evaluarii.\r\n\r\nh2. Prima data pe infoarena?\r\n\r\ninfoarena ajuta elevi si studenti sa devina excelenti in informatica! Gratuit ;) \'Citeste mai multe\':despre-infoarena despre noi.\r\n\r\nVezi \'ghidul utilizatorului\':documentatie/pentru-utilizatori.\r\n',1,'protected'),('newsletter/2007-01-24','Concursul de informatica Unirea','2007-01-24 02:17:37','Buna, %full_name%!\r\n\r\nTe invitam sa participi la Unirea 2007, un concurs de informatica\r\ngazduit de infoarena. Castigatorii vor primi diplome si premii din\r\npartea organizatorilor.\r\n\r\nConcursul se va desfasura ...\r\n\r\n    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\r\n    Sambata, 27 ianuarie 2007, orele 14:00 - 17:00\r\n    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\r\n\r\nPe acesta pagina gasesti informatii detaliate despre concursul Unirea:\r\n%url_infoarena%unirea-2007\r\n\r\n== Atentie! Concurs cu rating! ==\r\n\r\nParticiparea la acest concurs iti va afecta rating-ul pe infoarena.\r\nO prestatie buna te poate aduce mai aproape te varful clasamentului.\r\n%your_rating_is%\r\nDespre rating: %url_infoarena%documentatie/rating.\r\n\r\n== Prima data la infoarena? ==\r\n\r\ninfoarena ajuta elevi si studenti sa devina excelenti in informatica!\r\nGratuit ;)\r\n\r\nDespre infoarena: %url_infoarena%despre-infoarena\r\nGhidul utilizatorului: %url_infoarena%documentatie/pentru-utilizatori\r\n\r\n\r\nRamai alaturi de noi. Te ajutam sa devii olimpic!\r\n\r\nSucces!\r\nEchipa infoarena\r\n\r\n== Mesaj nesolicitat? ==\r\n\r\nClick pe acest link ca sa nu mai primesti instiintari:\r\n%url_unsubscribe%\r\n\r\ninfoarena nu trimite mesaje nesolicitate!\r\nEsti inscris pe %url_infoarena% cu numele\r\n\"%full_name%\", utilizator \"%username%\"\r\nsi ai acceptat sa primesti mesaje de instiintare.\r\n',13,'protected'),('utilizator/birsan','Profil birsan','2007-01-27 10:55:23','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',5855,'public'),('problema/amenzi','amenzi','2007-01-27 12:05:06','== include(page=\"template/taskheader\" task_id=\"amenzi\") ==\r\n\r\nIon este politist intr-un mare oras. In oras exista $N$ intersectii legate intre ele prin intermediul a $M$ strazi pe care se poate circula in ambele sensuri. Pentru fiecare strada se stie timpul $C{~i~}$ necesar pentru a o parcurge. Informat de o sursa sigura Ion stie ca in cursul urmatoarei zile se vor petrece $K$ infractiuni. Pentru fiecare infractiune $i$ se cunosc urmatoarele date: $T{~i~}$ - timpul la care infractiunea are loc, $A{~i~}$ - intersectia in care infractiunea are loc, $S{~i~}$ - amenda pe care Ion o poate da daca se afla in intersectia $A{~i~}$ la momentul $T{~i~}$.\r\n\r\nStie ca in cursul zilei urmatoare trebuie sa se intalneasca cu sotia sa, dar nu mai stie exact nici timpul nici ora la care trebuie sa faca acest lucru. Tot ce isi aminteste sunt $P$ perechi de forma $X{~i~}$, $Y{~i~}$ care semnifica faptul ca s-ar putea sa trebuiasca sa se intalneasca cu sotia sa la momentul $Y{~i~}$ in intersectia {$X{~i~}$}.\r\n\r\nAvand la dispozitie toate aceste date ajutati-l pe Ion sa afle valoare maxima totala a amenzilor pe care o poate da pentru fiecare din cele $P$ perechi pe care si le aminteste. Din momentul in care se intalneste cu sotia sa Ion nu va mai da amenzi.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $amenzi.in$ se afla patru numere intregi {$N$}, {$M$}, {$K$} si {$P$} cu semnificatia din enunt. Urmatoarele $M$ linii contin cate trei numere {$a$}, $b$ si $c$ cu semnificatia ca exista o strada ce leaga intersectiile $a$ si $b$ si care poate fi parcursa in $c$ unitati de timp. Urmatoarele $K$ linii contin cate trei numere {$a$}, $b$ si $c$ cu semnificatia ca va avea loc o infractiune in intersectia {$a$}, la timpul $b$ si pentru care se va da o amenda in valoare de {$c$} unitati monetare. Apoi urmeaza $P$ linii cu cate doua numere $a$ si $b$ cu seminficatia ca este posibil ca Ion sa se intalneasca cu sotia sa in intersectia $a$ la momentul {$b$}.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $amenzi.out$ vor exista $P$ linii continand valoarea totala maxima pe care Ion o va obtine din amenzi in fiecare din cele $P$ cazuri descrise in fisierul de intrare. Daca Ion nu poate ajunge sub nici o forma in intersectia respectiva la momenul stabilit afisati $-1$ pe testul respectiv.\r\n\r\nh2. Restrictii\r\n\r\n* Initial Ion se afla in intersectia $1$ la momentul {$0$}.\r\n* Timpii la care se petrec infractiunile si la care Ion se poate intalni cu sotia sa sunt in intervalul [{$0, 3500$}]\r\n* {$0 &le; K &le; 12000$}\r\n* {$0 &le; P &le; 8000$}\r\n* {$1 &le; N &le; 150$}\r\n* {$1 &le; M &le; 1500$}\r\n* Timpul necesar parcurgerii unei strazi este un numar intreg strict pozitiv\r\n* Costul unei amenzi va fi un intreg din intervalul [{$1, 10000$}]\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. amenzi.in |_. amenzi.out |\r\n| 5 7 4 2\r\n5 4 4\r\n4 3 5\r\n2 3 7\r\n3 1 3\r\n5 2 3\r\n4 1 10\r\n4 2 1\r\n2 6 5736\r\n2 20 2567\r\n5 6 1530\r\n3 3 4067\r\n1 50\r\n3 15\r\n| 6634\r\n4067\r\n| \r\n\r\nh3. Explicatie\r\n\r\nPentru primul caz Ion va merge in intersectia 3 unde va ajunge la momentul 3 exact la timp pentru a da o amenda in valoare de 4067. Apoi merge in intersectia 2 unde ajunge la momentul 10. Aici asteapta pana la momentul 20 cand da amenda in valoare de 2567. El merge apoi la intersectia 1 unde isi va astepta sotia pana la momentul 50.\r\n\r\nPentru al doilea caz Ion merge in intersectia 3 unde ajunge la momentul 3, da amenda in valoare de 4067 apoi isi asteapta sotia pana la momentul 15.\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"amenzi\") ==\r\n',961,'task: amenzi'),('utilizator/astronomy','Profil astronomy','2007-01-26 19:50:39','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\nSunt incolor.\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',2092,'protected'),('problema/secv5','secv5','2007-01-27 12:34:19','== include(page=\"template/taskheader\" task_id=\"secv5\") ==\r\n\r\nZaharel are de rezolvat inca o problema cu secvente! De data aceasta el are un sir de $N$ numere naturale si vrea sa stie cate subsecvente care au intre $L$ si $U$ elemente distincte exista in sirul respectiv.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare $secv5.in$ contine numerele naturale $N, L, U$. Urmatoarele $N$ vor contine cate un numar natural, fiecare reprezentand un element din sir.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie din fisierul $secv5.out$ se va afisa numarul de subsecvente care contin intre $L$ si $U$ elemente distincte.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; L &le; U &le; N &le; 2^20^$\r\n* Valoarea unui element din sir este un numar natural din intervalul $[1...2^32^-1]$\r\n* O subsecventa este un subsir de elemente care apar pe pozitii consecutive in sirul initial\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. secv5.in |_. secv5.out |\r\n| 5 2 3\r\n13\r\n13\r\n7\r\n9\r\n9\r\n| 8 | \r\n\r\nh2. Explicatie\r\n\r\nCele 8 secvente sunt:\r\n\r\n* {$13 13 7$}\r\n* {$13 13 7 9$}\r\n* {$13 13 7 9 9$}\r\n* {$13 7$}\r\n* {$13 7 9$}\r\n* {$13 7 9 9$}\r\n* {$7 9$}\r\n* {$7 9 9$}\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"secv5\") ==\r\n',961,'task: secv5'),('problema/aprindere','Aprindere','2007-01-27 07:33:16','== include(page=\"template/taskheader\" task_id=\"aprindere\") ==\r\n\r\nJohnie vrea sa sparga o banca, in care seifurile sunt asezate in $N$ camere alaturate. Astfel camerele sunt asezate in ordinea $0, 1, 2 ... N - 1$. Pentru a putea gasi cifrurile seifurilor, Johnie are nevoie de lumina. El cunoaste initial camerele in care lumina este aprinsa, si in care nu. De asemenea, stie ca in unele camere sunt intrerupatoare care modifica starea unor becuri. Fiind un hot priceput, Johnie a programat intrerupatoarele camerelor astfel incat un intrerupator din camera $i$ ( $0 &le; i &le; N - 1$ ) sa modifice atat becul din camera respectiva, cat si eventual unele becuri din camere de dupa $i$. De asemenea, stie ca pentru fiecare intrerupator i are nevoie de un timp $T{~i~}$ pentru a-l actiona. \r\nCunoscand numarul de camere, starea lor initiala,  configuratia intrerupatoarelor (programate de Johnie) cat si timpul de actionare a acestora se cere sa determinati, daca este posibil, timpul minim in care Johnie poate face lumina in toate camerele.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $aprindere.in$ se gaseste $N$, numarul de camere si $M$, numarul de intrerupatoare. Pe urmatoarea linie gasim $N$ cifre de {$0$} sau {$1$}, $0$ reprezentand o camera in care lumina este inchisa iar $1$ o camera in care lumina e deschisa. Pe urmatoarele $M$ linii gasim mai intai $3$ numere $C$, $T{~C~}$ si $NR{~C~}$, reprezentand camera intrerupatorului, timpul necesar actionarii intrerupatorului respectiv si numarul de camere in care modifica starea becurilor. Urmeaza apoi $NR{~C~}$ numere reprezentand indicii camerelor in care becurile sunt schimbate de intrerupatorul curent (camera $i$ se va afla mereu in aceasta multime).\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $aprindere.out$ se gaseste un singur numar, cu semnificatia de mai sus.\r\n\r\nh2. Restrictii\r\n\r\n*    $1 &le; N &le; 1000$\r\n*    $1 &le; M &le; N$\r\n*    $1 &le; NR{~i~} &le; 100$\r\n*    $1 &le; T{~i~} &le; 1000$\r\n*    Intr-o camera poate exista maxim un intrerupator\r\n*    Pentru datele de test folosite va exista mereu solutie\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. aprindere.in |_. aprindere.out |\r\n|5 4\r\n0 1 0 0 1\r\n0 3 2 0 2\r\n1 3 2 1 2\r\n3 1 2 3 4\r\n4 2 1 4\r\n|6| \r\n\r\nh3. Explicatie\r\n\r\nSe actioneaza intrerupatoarele din camerele $0$, $3$ si $4$. Timpul total este $3 + 1 + 2 = 6$.\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"aprindere\") ==\r\n',48,'task: aprindere'),('template/userinfo','template/userinfo','2007-01-27 10:35:30','table(compact). |/5. !utilizator/%user%?avatar 150x150! \r\n\'Vezi solutiile trimise\':monitor?user=%user%\r\n|_. Nume | == userinfo(user=\"%user%\" info=\"fullname\")== |\r\n| |_. Cont | ==userinfo(user=\"%user%\" info=\"username\")== |\r\n| |_. Rating | ==userinfo(user=\"%user%\" info=\"rating\")== |\r\n| |_. Statut | ==userinfo(user=\"%user%\" info=\"security\")== |\r\n|_. Forum | ==SmfLink(user=\"%user%\" link=\"pm\" caption=\"trimite mesaj privat\")==, ==SmfLink(user=\"%user%\" link=\"stats\" caption=\"vezi activitate\")== |\r\n\r\n\r\n',1,'protected'),('unirea-2007/clasele-9-10','Unirea 2007, Clasele IX - X','2007-01-27 15:40:07','(htabs)* \'*Home*\':unirea-2007\r\n*(active) \'Clasele IX-X\':unirea-2007/clasele-9-10\r\n* \'Clasele XI-XII\':unirea-2007/clasele-11-12\r\n* \'Rezultate\':unirea-2007/rezultate-9-10\r\n\r\nh1. == roundparam(round_id=\"unirea9-10\" param=\"title\") ==\r\n\r\n== roundregister(round_id=\"unirea9-10\") ==\r\n\r\nConcursul incepe *Sambata, 27 ianuarie, ora 14^00^* si dureaza *3 ore*.\r\n\r\nh2. Probleme\r\n\r\n== Tasks(round_id=\"unirea9-10\" score=\"1\") ==\r\n\r\nh2. Discutii pe forum\r\n\r\nVrei sa adresezi intrebari comisiei? Fa-o pe forum.\r\n\r\n==SmfTopics(board_id=\"36\" count=\"10\")==\r\n\r\nh2. Organizatori\r\n\r\n* Subiectele vor fi propuse de:\r\n==User(user=\"danielp\" type=\"tiny\")==\r\n==User(user=\"azotlichid\" type=\"tiny\")==\r\n\r\n* Pentru intrebari de factura organizatorica / tehnica poti contacta urmatoarele persoane:\r\n==User(user=\"wickedman\" type=\"tiny\")==\r\n\r\n*{\'Echipa infoarena\':echipa-infoarena}* iti ureaza mult succes!\r\n',13,'round: unirea9-10'),('unirea-2007/clasele-11-12','Unirea 2007, clasele 11-12','2007-01-27 15:40:15','(htabs)* \'*Home*\':unirea-2007\r\n* \'Clasele IX-X\':unirea-2007/clasele-9-10\r\n*(active) \'Clasele XI-XII\':unirea-2007/clasele-11-12\r\n* \'Rezultate\':unirea-2007/rezultate-9-10\r\n\r\nh1. == roundparam(round_id=\"unirea11-12\" param=\"title\") ==\r\n\r\n== roundregister(round_id=\"unirea11-12\") ==\r\n\r\nConcursul incepe *Sambata, 27 ianuarie, ora 14^00^* si dureaza *3 ore*.\r\n\r\nh2. Probleme\r\n\r\n== Tasks(round_id=\"unirea11-12\" score=\"1\") ==\r\n\r\nh2. Discutii pe forum\r\n\r\nVrei sa adresezi intrebari comisiei? Fa-o pe forum.\r\n\r\n==SmfTopics(board_id=\"36\" count=\"10\")==\r\n\r\nh2. Organizatori\r\n\r\n* Subiectele vor fi propuse de:\r\n==User(user=\"ditzonec\" type=\"tiny\")==\r\n==User(user=\"domino\" type=\"tiny\")==\r\n\r\n* Pentru intrebari de factura organizatorica / tehnica poti contacta urmatoarele persoane:\r\n==User(user=\"wickedman\" type=\"tiny\")==\r\n\r\n*{\'Echipa infoarena\':echipa-infoarena}* iti ureaza mult succes!\r\n',13,'round: unirea11-12'),('unirea-2007/rezultate-11-12','Unirea 2007, Clasament pentru clasele XI-XII','2007-01-27 15:36:37','(htabs)* \'*Home*\':unirea-2007\r\n* \'Clasele IX-X\':unirea-2007/clasele-9-10\r\n* \'Clasele XI-XII\':unirea-2007/clasele-11-12\r\n*(active) \'Rezultate\':unirea-2007/rezultate-11-12\r\n\r\np=. \'*Clasele IX-X*\':unirea-2007/rezultate-9-10 | *Clasele XI-XII*\r\n\r\nh2. Clasament XI-XII\r\n\r\n== Rankings(rounds=\"unirea11-12\") == \r\n',13,'protected'),('unirea-2007/rezultate-9-10','Unirea 2007, Clasament pentru clasele IX-X','2007-01-27 15:47:56','(htabs)* \'*Home*\':unirea-2007\r\n* \'Clasele IX-X\':unirea-2007/clasele-9-10\r\n* \'Clasele XI-XII\':unirea-2007/clasele-11-12\r\n*(active) \'Rezultate\':unirea-2007/rezultate-11-12\r\n\r\np=. *Clasele IX-X* | \'*Clasele XI-XII*\':unirea-2007/rezultate-11-12\r\n\r\nh2. Clasament IX-X\r\n\r\n== Rankings(rounds=\"unirea9-10\") == \r\n',13,'protected'),('stiri/s-a-incheiat-unirea-2007','S-a incheiat concursul Unirea 2007','2007-01-27 17:04:38','h1. S-a incheiat Unirea 2007\r\n\r\nEvaluarea a inceput imediat dupa terminarea timpului de lucru. \'Rezultatele au fost publicate\':unirea-2007/rezultate-9-10 iar problemele au fost adaugate in \'arhiva\':arhiva.\r\n\r\nLa acest concurs s-au inscris *342 de concurenti*. 237 concurenti au trimis cel putin o solutie. In total au fost evaluate *545 de solutii*.\r\n\r\nFelicitari tuturor concurentilor si in special castigatorilor :)\r\n\r\n\'*Vezi clasamentul Unirea 2007*\':unirea-2007/rezultate-9-10\r\n\r\nDe asemenea, in urma concursului au fost recalculate \'rating-urile\':documentatie/rating utilizatorilor. Vezi si \'cei mai bine cotati\':clasament-rating utilizatori infoarena.',13,'protected'),('utilizator/svalentin','Profil svalentin','2007-01-27 19:46:05','h2. Infoarena development\r\n\r\n* Buguri, sugestii, etc pe ==smflink(link=\"board\" board=\"33\" caption=\"forum\")==\r\n* contact: mesaj privat sau svalentin.public _at_ gmail _dot_ com\r\n\r\nh2. Despre mine\r\n\r\n* Age - 18\r\n* Location - Bucharest\r\n* More info on \'hi5\':http://svalentin01.hi5.com\r\n\r\n* Cont pe TopCoder - \'svalentin\':http://www.topcoder.com/tc?module=MemberProfile&cr=11931649\r\n* Poze de la diferite evenimente - \'picasaweb\':http://picasaweb.google.com/valentin.stanciu\r\n* Cont pe deviantart - \'svnightblade\':http://svnightblade.deviantart.com (fotografii)\r\n** samples:\r\n*** !http://tn3-2.deviantart.com/fs11/300W/i/2006/190/e/0/School_Musician_by_svNightBlade.jpg!:http://www.deviantart.com/deviation/28295559/\r\n*** !http://tn3-2.deviantart.com/fs11/300W/i/2006/189/c/a/Panoramic_mountains_by_svNightBlade.jpg!:http://www.deviantart.com/deviation/35987288/\r\n\r\nh2. Distinctii primite\r\n\r\n* premiul I ONI in clasa a 8-a  (2004)\r\n* premiul I ONI in clasa a 10-a (2005)\r\n* Medalie de argint la concursul Tuymaada din Yakutia (2005)\r\n* premiul I ONI in clasa a 11-a (2006)\r\n* membru al lotului national de informatica din 2006\r\n* luat recent un premiu 2 la Stelele Informaticii\r\n* more small stuff\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* ==User(user=\"wefgef\" type=\"normal\")==\r\n* ==User(user=\"cimi\" type=\"normal\")==\r\n* ==User(user=\"cyber\" type=\"normal\")==\r\n* more to come\r\n* special friend: ==User(user=\"chucknorris\" type=\"normal\")==',75,'protected'),('unirea-2007/solutii','Solutii Unirea 2007','2007-01-28 20:47:15','h1. Solutii\r\n\r\n\r\nh2. Maxsecv\r\n\r\nh3. (clasele 9-10)\r\n\r\nSe observa ca secventa maxima de $1$ care se poate obtine are lungimea egala cu suma primelor doua secvente maxime din vectorul original. Printr-o operatie descrisa se pot alatura cu usurinta cele doua secvente. \r\nPentru obtinerea unei solutii liniare e suficient sa parcurgem vectorul de la stanga la dreapta si sa updatam la fiecare pas lungimea secventei curente de $1$. In momentul in care ajungem la capatul unei astfel de secvente facem un update pentru primul si al 2-lea maxim, dupa caz.\r\n\r\n\r\nh2. Chernel\r\n\r\nh3. (clasele 9-10)\r\n\r\nConsiderandu-se sirul $a{~1~} a{~2~} ... a{~N~}$ pentru un $N$ fixat, se observa ca dupa $N-1$ transformari, acesta devine $a{~1~} * C{~N-1~}^0^ + a{~2~} * C{~N-1~}^1^ + a{~3~} * C{~N-1~}^2^ + ... + a{~N~} * C{~N-1~}^N-1^$ . De aici reiese ca elementele sirului initial a calor valoare nu influenteaza numarul caracteristic (numarul din ultimul sir obtinut $modulo M$) sunt cele ai caror coeficienti sunt multipli ai lui $M$. Astfel problema se reduce la numararea combinarilor de $N-1$ luate cate $i$ (cu $i$ intre $0$ si $N-1$) care sunt multipli de $M$. Aceasta se realizeaza simplu \"generand\" combinarile respective: ne bazam pe recurenta $C{~N~}^k+1^ = C{~N~}^k^ * (n-k) / (k+1)$ si verificam cate dintre acestea sunt divizibile cu $M$. Problema este ca aceste valori vor deveni uriase destul de rapid, iar stocarea lor in memoria calculatorului este ineficienta. Din acest motiv nu se vor retine numerele propriu zise, ci doar exponentii factorilor primi ai lui $M$, (numarul maxim de factori primi ai lui fiind aproximat la $O(ln ln M)$, si $9$ pentru datele de test ale problemei) care se vor actualiza pentru fiecare combinare procesata.\r\nComplexitatea finala a algoritmului devine astfel $O(N * ln ln M)$.\r\n\r\nh2. Amenzi\r\n\r\nh3. (clasele 11-12)\r\n\r\nProblema se poate rezolva folosind metoda programarii dinamice. Se construieste matricea $A{~t,i~}$ in care se retine valoarea totala a amenzilor ce poate fi data pana la momentul $t$ astfel incat la momentul $t$ sa fim in intersectia {$i$}. Pentru toate muchiile ({$j,i$}) de cost $c$ vom compara {$A{~t,i~}$} cu {$A{~t-c,j~}$} alegand maximul dintre aceste valori. De fapt ar trebui inspectate toate valorile {$A{~t-c,j~}$} {$A{~t-c-1,j~}$} ... {$A{~1,j~}$} {$A{~0,j~}$} dar este clar ca maximul acestor valori se afla in {$A{~t-c,j~}$}. Deasemenea trebuie considerat cazul cand politistul sta pe loc deci ne vom uita si la valoarea din {$A{~t-1,i~}$}. Apoi politistul va da toate amenzile posibile la momentul respectiv in intersectia respectiva deci vom aduna respectiva suma la {$A{~t,i~}$}.\r\nAvand construita aceasta matrice se poate raspunde in $O(1)$ la fiecare intrebare.\r\nComplexitatea totala va fi $O(Tmax * M)$ ca timp si $O(Tmax * N)$ ca memorie. \r\n\r\nh2. Secventa 5\r\n\r\nh3. (clasele 11-12)\r\n\r\nVom construi o procedura cu ajutorul careia vom numara cate secvente exista care contin cel mult $X$ elemente distincte. Folosind aceasta procedura, rezultatul problemei va fi: numarul de secvente cu cel mult $U$ elemente distincte - numarul de secvente cu cel mult $L-1$ elemente distincte. \r\nLa primul pas, vom normaliza valorile din sirul de intrare, inlocuind fiecare valoare cu un numar de la $1$ la $N$ (spre exemplu sirul $13 13 47 9 9$ devine $1 1 2 3 3$). Aceasta normalizare se poate face in $O(N*lg N)$ cu o sortare, dar aceasta solutie va obtine doar $80$ de puncte. Pentru $100$ de puncte normalizarea trebuie facuta folosind o tabela \'hash\':hashing.\r\nFie $L{~i~}$ cel mai mic indice astfel incat secventa cu elementele $L{~i~}...i$ contine cel mult $X$ elemente distincte (cu alte cuvinte cea mai lunga secventa cu maxim $X$ elemente distincte care se termina pe pozitia $i$). Numarul total de subsecvente va fi $(1-L{~1~}+1) + (2-L{~2~}+1) + (3-L{~3~}+1) + ... + (N-L{~N~}+1)$.\r\nEste usor de aratat ca $L{~i~} &le; L{~i+1~}$ pentru orice $i$. Asadar, pe masura ce trecem de la $i$ la $i+1$ vom incepe calculul lui $L{~i+1~}$ de la valoarea $L{~i~}$. Pentru a stii la fiecare moment cate elemente distincte sunt in secventa $L{~i~}...i$ vom mentine un vector $V$ cu proprietatea ca $V{~x~}$ = de cate ori apare $x$ in secventa si o variabila $Nr$ reprezentand numarul de valori distincte din secventa. Valorea lui $Nr$ va creste doar cand $V{~x~}$ se schimba din $0$ in $1$, si va scade doar cand $V{~x~}$ se schimba din $1$ in $0$ (pentru un $x$ oarecare). Complexitatea totala a algoritmului este $O(N)$.',1,'public'),('problema/chernel','Chernel','2007-01-28 23:32:40','== include(page=\"template/taskheader\" task_id=\"chernel\") ==\r\n\r\nChernel a renuntat la afaceri si s-a apucat de matematica. De aceasta data, el studiaza niste siruri mai speciale. Chernel porneste de la un sir de $N$ numere naturale $a{~1~} a{~2~} ... a{~N~}$, pe care aplica transformari succesive care schimba un sir de $X$ elemente $a{~1~} a{~2~} ... a{~X~}$ in sirul de $X-1$ elemente $a{~1~}+a{~2~} a{~2~}+a{~3~} ... a{~X-1~}+a{~X~}$. Chernel repeta aceasta operatie pana cand ramane cu un singur element. De aici obtine $numarul caracteristic$ al sirului, ca fiind restul impartirii aceslui ultim element ramas la un numar natural $M$.\r\n\r\nChernel observa ca valorile unor elemente din sirul initial nu influenteaza $numarul caracteristic$ al sirului, altfel spus oricare ar fi valoarea acestora, $numarul caracteristic$ ramane acelasi.\r\n\r\nPentru $N$ si $M$ date, ajutati-l pe Chernel sa afle cate astfel de valori exista in sirul initial.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $chernel.in$ se gasesc cele doua numere naturale $N$ si $M$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului de iesire $chernel.out$ se va gasi un singur numar natural, reprezentand numarul de elemente din sirul initial a caror valoare nu influenteaza $numarul caracteristic$ al sirului.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 100.000$\r\n* $1 &le; M &le; 1.000.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. chernel.in |_. chernel.out |\r\n| 3 2\r\n| 1\r\n| \r\n\r\nh3. Explicatie\r\n\r\nFie sirul initial $a{~1~} a{~2~} a{~3~}$. Acesta se transforma in $a{~1~}+a{~2~} a{~2~}+a{~3~}$ apoi in $a{~1~}+2*a{~2~}+a{~3~}$. Pentru $M = 2$, singura valoare a sirului initial care nu influenteaza $numarul caracteristic$ este $a{~2~}$\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"chernel\") ==\r\n',1,'task: chernel');
/*!40000 ALTER TABLE `ia_textblock` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_textblock_revision`
--

DROP TABLE IF EXISTS `ia_textblock_revision`;
CREATE TABLE `ia_textblock_revision` (
  `name` varchar(64) collate latin1_general_ci default NULL,
  `title` varchar(64) collate latin1_general_ci default NULL,
  `timestamp` datetime NOT NULL,
  `text` longtext collate latin1_general_ci,
  `user_id` int(10) unsigned NOT NULL,
  `security` varchar(64) collate latin1_general_ci default NULL,
  KEY `name_index` (`name`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_textblock_revision`
--

LOCK TABLES `ia_textblock_revision` WRITE;
/*!40000 ALTER TABLE `ia_textblock_revision` DISABLE KEYS */;
INSERT INTO `ia_textblock_revision` VALUES ('lca-lowest-common-ancestor','LCA: Lowest common ancestor','2004-11-08 00:00:00','h1. LCA: Lowest common ancestor\n\n(Creat de \'_wickedman_\':user/wickedman la data de _2004-11-08_ categoria _Arbori_, autor(i) _Miron Emilian_)\n\n*Continut scurt:*\n Problema luata in discutie este ca, avand un arbore dat sa putem raspunde rapid la multe intrebari de genul care este stramosul comun cel mai apropiat dintre doua noduri din arbore.\n\n\n*Continut lung:*\nProblema luata in discutie este ca, avand un arbore dat sa putem raspunde rapid la multe intrebari de genul care este stramosul comun cel mai apropiat dintre doua noduri din arbore.\n\n\n\nExemplu\n\nPentru arborele din imagine, avem ca exemplu urmatoarele query-uri:\n\nlca(2,3) = 1\n\nlca(4,5) = 1\n\nlca(5,6) = 3\n\nlca(1,5) = 1\n\nlca(5,3) = 3\n\n\n\nAplicabilitate\n\nDandu-se un arbore cu costuri sa se raspunda rapid la intrebari de genul: care este distanta minima intre doua noduri date?\n\nSolutie:\n\n* agatam arborele intr-un nod oarecare si obtinem un arbore cu radacina.\n* pentru fiecare nod precalculam dist[i], reprezentand distanta sa pana la radacina.\n* precalculam cele necesare pt LCA.\n* raspundem la intrebari de forma d(i,j) prin dist[i] + dist[j] ?? 2 * dist(lca(i,j)).\n* Probleme adhoc care se reduc sau folosesc LCA. (de exemplu problema petrol (baraje Slatina 2003).\n\nMod de calcul\n\nIn prima etapa a algoritmului facem o parcurgere euleriana a arborelui dat. O parcurgere euleriana este o parcurgere a arborelui in ordinea din figura: se parcurg fii si se intercaleaza intre ei tatal, obtinand o parcurgere continua.\n\nMai exact pentru fiecare nod procedam astfel, incepand cu radacina:\n\n* daca nodul curent este frunza il adaugam la parcurgere\n* daca are fii atunci il punem la inceput, la sfarsit si intre parcurgerile euler ale fiilor\n* Cand facem aceasta parcurgere retinem de asemenea si urmatoarele informatii suplimentare:\n* adancimea fiecarui nod din parcurgere, obtinand un sir de adancimi\n* una din pozitiile pe care fiecare nod apare in parcurgere\n\nIdeea este ca lca(i, j) este chiar nodul cu cea mai mica adancime intre pozitiile lui i si a lui j in parcurgere. Pentru graful din figura avem:\n\nEuler: 12421353631\n\nAdancimi: 12321232321\n^ ^\n\n4 3\n\nlca(4,3)=min(adancimi de la pos[4] la pos[3]) = 1\n\nAm redus problema la aflarea minimului intre doua pozitii a unui sir (RMQ ?? range minimum query). Aceasta subproblema o putem rezolva optim folosind arbori de intervale, sau o metoda folosind spatiu supraliniar (NlgN) a minimelor pe intervale de puteri de 2, incepand de la pozitia i. Timpul de preprocesare este O(N) pentru arbori de intervale si O(NlgN) pentru a doua metoda. Timpul de interogare este O(lgN);\nVom discuta metoda cu spatiu NlgN. Calculam minimele inductiv, pastrand min[i][k] = minimul pe intervalui i..i + 2^k ?? 1 (de lungime 2^k), si minpos[i][k] pozitia minimului de pe intervalul i..i + 2^k ?? 1.\n\npt k = 0\nmin[i][0] = a[i], minpos[i][0] = i;\n\n\n\npt k > 0\nmin[i][k] = minim(min[i][k-1],min[i+2^(k-1)][k-1])\nminpos[i][k] = pozitia minimului\n\n(minpos[i][k-1] sau minpos[i+2^(k-1)][k-1])\n\nPentru query intre pozitiile l, r procedam astfel:\nFie k cel mai mare nr astfel incat 2^k <= lungimea intervalului (r ?? l + 1)\n\nmin(l, r) = minim( min[l][k], min[r ?? 2^k + 1][k])\n\npozmin(l, r) = pozitia minimului\n\nDaca l = pos[i], r = pos[j] (pos[i] < pos[j]) la sfarsitul query-ului euler[pozmin] este chiar lca(i, j).\n\n',0,''),('problema/poly','poly','2006-11-11 11:23:58','== include(page=\"template/taskheader\" task_id=\"poly\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| poly.in | poly.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"poly\") ==\r\n',0,''),('problema/catun','catun','2006-11-11 11:23:56','== include(page=\"template/taskheader\" task_id=\"catun\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| catun.in | catun.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"catun\") ==\r\n',0,''),('problema/vila','vila','2006-11-11 11:23:56','== include(page=\"template/taskheader\" task_id=\"vila\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| vila.in | vila.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"vila\") ==\r\n',0,''),('problema/aladdin2','aladdin2','2006-11-11 11:23:55','== include(page=\"template/taskheader\" task_id=\"aladdin2\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| aladdin2.in | aladdin2.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"aladdin2\") ==\r\n',0,''),('problema/lesbulan','lesbulan','2006-11-11 11:23:53','== include(page=\"template/taskheader\" task_id=\"lesbulan\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| lesbulan.in | lesbulan.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"lesbulan\") ==\r\n',0,''),('problema/popandai2','popandai2','2006-11-11 11:23:53','== include(page=\"template/taskheader\" task_id=\"popandai2\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| popandai2.in | popandai2.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"popandai2\") ==\r\n',0,''),('problema/cercuri2','cercuri2','2006-11-11 11:23:52','== include(page=\"template/taskheader\" task_id=\"cercuri2\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| cercuri2.in | cercuri2.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"cercuri2\") ==\r\n',0,''),('problema/invsort','invsort','2006-11-11 11:23:51','== include(page=\"template/taskheader\" task_id=\"invsort\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| invsort.in | invsort.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"invsort\") ==\r\n',0,''),('problema/euro','euro','2006-11-11 11:23:51','== include(page=\"template/taskheader\" task_id=\"euro\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| euro.in | euro.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"euro\") ==\r\n',0,''),('problema/telegraf','telegraf','2006-11-11 11:23:50','== include(page=\"template/taskheader\" task_id=\"telegraf\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| telegraf.in | telegraf.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"telegraf\") ==\r\n',0,''),('problema/matrix','matrix','2006-11-11 11:23:49','== include(page=\"template/taskheader\" task_id=\"matrix\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| matrix.in | matrix.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"matrix\") ==\r\n',0,''),('problema/gfact','gfact','2006-11-11 11:23:49','== include(page=\"template/taskheader\" task_id=\"gfact\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| gfact.in | gfact.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"gfact\") ==\r\n',0,''),('problema/pavare2','pavare2','2006-11-11 11:23:49','== include(page=\"template/taskheader\" task_id=\"pavare2\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| pavare2.in | pavare2.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"pavare2\") ==\r\n',0,''),('problema/desc','desc','2006-11-11 11:23:48','== include(page=\"template/taskheader\" task_id=\"desc\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| desc.in | desc.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"desc\") ==\r\n',0,''),('problema/santa','santa','2006-11-11 11:23:47','== include(page=\"template/taskheader\" task_id=\"santa\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| santa.in | santa.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"santa\") ==\r\n',0,''),('problema/supersf','supersf','2006-11-11 11:23:48','== include(page=\"template/taskheader\" task_id=\"supersf\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| supersf.in | supersf.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"supersf\") ==\r\n',0,''),('problema/cai','cai','2006-11-11 11:23:45','== include(page=\"template/taskheader\" task_id=\"cai\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| cai.in | cai.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"cai\") ==\r\n',0,''),('problema/calatorie','calatorie','2006-11-11 11:23:44','== include(page=\"template/taskheader\" task_id=\"calatorie\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| calatorie.in | calatorie.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"calatorie\") ==\r\n',0,''),('problema/numere','numere','2006-11-11 11:23:44','== include(page=\"template/taskheader\" task_id=\"numere\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| numere.in | numere.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"numere\") ==\r\n',0,''),('problema/string','string','2006-11-11 11:23:44','== include(page=\"template/taskheader\" task_id=\"string\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| string.in | string.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"string\") ==\r\n',0,''),('problema/sediu','sediu','2006-11-11 11:23:43','== include(page=\"template/taskheader\" task_id=\"sediu\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| sediu.in | sediu.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"sediu\") ==\r\n',0,''),('problema/tvshow','tvshow','2006-11-11 11:23:40','== include(page=\"template/taskheader\" task_id=\"tvshow\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| tvshow.in | tvshow.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"tvshow\") ==\r\n',0,''),('problema/frac','frac','2006-11-11 11:23:40','== include(page=\"template/taskheader\" task_id=\"frac\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| frac.in | frac.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"frac\") ==\r\n',0,''),('problema/rubarba','rubarba','2006-11-11 11:23:38','== include(page=\"template/taskheader\" task_id=\"rubarba\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| rubarba.in | rubarba.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"rubarba\") ==\r\n',0,''),('problema/sobo','sobo','2006-11-11 11:23:37','== include(page=\"template/taskheader\" task_id=\"sobo\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| sobo.in | sobo.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"sobo\") ==\r\n',0,''),('problema/party','party','2006-11-11 11:23:36','== include(page=\"template/taskheader\" task_id=\"party\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| party.in | party.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"party\") ==\r\n',0,''),('problema/loto','loto','2006-11-11 11:23:35','== include(page=\"template/taskheader\" task_id=\"loto\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| loto.in | loto.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"loto\") ==\r\n',0,''),('problema/tort','tort','2006-11-11 11:23:35','== include(page=\"template/taskheader\" task_id=\"tort\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| tort.in | tort.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"tort\") ==\r\n',0,''),('problema/pavare','pavare','2006-11-11 11:23:35','== include(page=\"template/taskheader\" task_id=\"pavare\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| pavare.in | pavare.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"pavare\") ==\r\n',0,''),('problema/perm2','perm2','2006-11-11 11:23:34','== include(page=\"template/taskheader\" task_id=\"perm2\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| perm2.in | perm2.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"perm2\") ==\r\n',0,''),('problema/pietre','pietre','2006-11-11 11:23:34','== include(page=\"template/taskheader\" task_id=\"pietre\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| pietre.in | pietre.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"pietre\") ==\r\n',0,''),('problema/cifra','cifra','2006-11-11 11:23:34','== include(page=\"template/taskheader\" task_id=\"cifra\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| cifra.in | cifra.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"cifra\") ==\r\n',0,''),('problema/flip','flip','2006-11-11 11:23:33','== include(page=\"template/taskheader\" task_id=\"flip\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| flip.in | flip.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"flip\") ==\r\n',0,''),('ciclu-hamiltonian-in-graf-dens','Ciclu hamiltonian in graf dens','2004-11-09 00:00:00','h1. Ciclu hamiltonian in graf dens\n\n(Creat de \'_fluffy_\':user/fluffy la data de _2004-11-09_ categoria _Grafuri_, autor(i) _Crestez Leonard_)\n\n*Continut scurt:*\n In acest articol va voi prezenta un algoritm ce necesita O(n^2) timp de executie pentru gasirea unui ciclu hamiltonian intr-un graf neorientat dens - in care fiecare nod are macar (n + 1) / 2 muchii incidente.\n\n\n*Continut lung:*\nIn acest articol va voi prezenta un algoritm pentru gasirea unui ciclu hamiltonian intr-un graf neorientat dens - in care fiecare nod are macar (n + 1) / 2 muchii.\n\nIn general, gasirea unui ciclu hamiltonian intr-un graf neorientat este un exemplu clasic de problema NP - completa. Insa, daca graful este dens - fiecare nod are cel putin (n+1) / 2 muchii incidente (n este numarul de noduri) - se poate gasi o solutie de complexitate O(n^2).\n\nAlgoritm\n\nLa inceput formam un ciclu la intamplare, fara a tine cont daca muchiile luate in considerare chiar exista in graf. Astfel, putem alege chiar ciclul 1, 2, 3, 4, ... n. Daca acest ciclu este valid, atunci avem noroc si solutia a fost gasita. Altfel, trebuie sa incercam sa \"umplem gaurile\" din ciclu (adica muchiile pe care le-am ales la intamplare si care nu exista in graf).\n\nGasim prima muchie de acest fel, fie ea (A, B). Cautam apoi doua alte noduri adiacente in ciclul nostru, notate cu C si D, astfel incat sa avem muchie de la A la C si de la B la D. Se poate demonstra ca vom gasi mereu C si D. Acum vom \"incrucisa\" A B cu C D. Prin \"incrucisare\" se intelege transfromarea unui ciclu \"...AB...CD...\" in \"...AC...BD...\" (sau \"...CD...AB...\" in \"...CA...DB...\") . Atentie, secventa de la B la C (respectiv de la D la A) va fi inversata complet!\n\nSe observa ca a scazut numarul de \"gauri\" din sir, AB a fost eliminata si nu au fost adaugate \"gauri\" noi. Repetam \"umplerea gaurilor\" pana nu mai avem ce umple, deci am gasit solutie.\n\nDesi suna complicat, \"umplerea unei gauri\" necesita doar O(n) timp pentru cautarea nodurile AB, CD, si incrucisare. Avand in vedere ca sunt maxim n gauri la inceput, algoritmul necesita O(n^2) ca timp de executie.\n\nMai sus am folosit o afirmatie fara a o demonstra. Demonstratia e relativ intuitiva. Daca nu o descoperiti singuri, puteti sa intrebati pe [1]forum.\n\nProblema luata in discutie este propusa pe lista [2]acm.sgu.ru, nr. 122, unde exista si evaluator online. Atentie la implementare! Citirea si scrierea folosind functii standard pot iesi din timp!\n\nReferences\n\nVisible links\n1. http://info.devnet.ro/forum.php\n2. http://acm.sgu.ru/\n\n',0,''),('usaco-ianuarie-2005-divizia-gold','Usaco ianuarie 2005, divizia GOLD','2005-03-03 00:00:00','h1. Usaco ianuarie 2005, divizia GOLD\n\n(Creat de \'_silviug_\':user/silviug la data de _2005-03-03_ categoria _Competitii_, autor(i) _Silviu Ganceanu, Mircea Pasoi_)\n\n*Continut scurt:*\n Acest set de probleme a fost considerat unul dintre cele mai grele, daca nu cel mai greu, de pana acum. Problemele au fost intr-adevar dure cu atat mai mult cu cat timpul de lucru a fost mic (3 ore). In ciuda acestui fapt concurentii din Romania s-au comportat bine, concursul marcand primul succes de pe anul acesta al tarii noastre: locul 5 obtinut de Adrian Vladu.\n\n\n*Continut lung:*\nDesi rezultatele i-au determinat pe antrenorii americani sa considere setul de probleme cel mai greu de pana acum, pentru multi dintre elevii Romaniei problemele nu au fost in totalitate noi: cover a fost propusa (sub o forma un pic diferita) la CEOI, o varinta ceva mai blanda a problemei juice (cu limite mai mici) am putut vedea si in finala rundei .Campion de anul trecut iar ideea de rezolvare pentru naptime nu era noua (o problema din concursul \"Stelele Informaticii\" de anul trecut se pare ca semana mult cu aceasta).\n\nCu toate aceastea problemele au fost deosebit de dificile necesitand concentrare maxima. Rezultatele elevilor din Romania s-au imbunatatit semnificativ fata de concursul precedent, acestia obtinand locuri mai bune. O parte din succesul acestora indraznesc sa o pun si pe seama faptului ca problema cea mai grea din concurs era cunoscuta la noi in tara. Avem astfel urmatorul clasament:\n\n1. Adrian Vladu 958 puncte\n2. Sorin Stancu-Mara 703 puncte\n3. Mircea Pasoi 700 puncte\n4. Andrei Teodorescu 640 puncte\n5. Dan-Ionut Fechete 547 puncte\n6. Adrian Diaconu 502 puncte\n\nRestul concurentilor au obtinut punctaje frumoase dar mai mici de 400 de puncte. Sunt de remarcat comportarile bune de pana acum ale lui Andrei Teodorescu care reuseste sa se \"tina\" de mult mai titratii elevi ai Romaniei care au deja in palmares cel putin o medalie internationala.\n\nSetul de probleme, impreuna cu testele si clasamentul, se gaseste in cadrul [1]sectiunii download. In continuare vom prezenta solutiile:\n\nCover\n\nProblema nu era foarte dificila, cu atat mai mult cu cat ideea de rezolvare a problemei guards din concursul CEOI 2002 era aceeasi: se construieste un graf bipartit avand intr-o multime barele orizontale (set maximal de pozitii de pe o linie din matrice in care avem noroi) si in cealalta multime barele verticale (definite analog dar pentru coloane). Intre doua noduri din acest graf bipartit vom avea muchie doar daca barele corespunzatoare lor au o celula comuna. Pentru exemplificare vom lucra cu exemplul din enunt:\n\n*.*.\n\n.***\n\n***.\n\n..*.\n\nIata cum vom construi prima multime a grafului bipartit (vom pune numarul nodului din graf corespunzator fiecarei celule):\n\n1.2.\n\n.333\n\n444.\n\n..5.\n\nA doua multime a grafului bipartit va arata astfel (nodurile vor fi numerotate incepand tot cu 1):\n\n1.2.\n\n.324\n\n532.\n\n..2.\n\nMuchiile din graful bipartit vor fi urmatoarele:\n\n(1, 1) (2, 2) (3, 3) (3, 2) (3, 4) (4, 5) (4, 3) (4, 2) (5, 2)\n\nAsadar fiecarei celule din harta terenului ii corespunde o singura muchie in acest graf bipartit. Avand construit graful trebuie sa aflam numarul minim de noduri selectate astfel incat orice muchie sa aiba cel putin un capat intre nodurile selectate (in literatura de specialitate aceasta problema se numeste \"Minimum Vertex Cover\"). Explicatia acestui lucru este simpla: orice muchie, fiind de fapt o celula, ea trebuie sa fie \"acoperita\" de cel putin un nod din graf (adica o placa orizontala sau verticala utilizata de FJ). Problema acesta este NP-completa pentru grafuri generale dar in cazul grafurilor bipartite ea se poate rezolva in timp polinomial. De asemenea s-a demonstrat ca numarul minim de noduri dintr-un astfel de set este egal cu cardinalul cuplajului maximal din graful bipartit. De aici nu mai e decat un pas spre solutia finala. Avem, astfel, urmatorii pasi in algoritmul de rezolvare a problemei:\n\n\n\nPAS 1: Construirea grafului bipartit\n\nPAS 2: Aflarea cuplajului maximal\n\n\n\nPrimul pas este banal si consta din simple parcurgeri ale matricii. Pentru aflarea cuplajului maximal se poate afla utilizand un algoritm de aflarea a fluxului maxim in reteaua asociata grafului bipartit sau se poate algoritmul bazat pe gasirea succesiva a drumurilor in crestere in graf.\n\nComplexitatea finala a algoritmului va fi O(N^2*M^2) deoarece in graful bipartit avem maxim N*M muchii si vom N*M noduri. Cum algoritmul pentru aflarea cuplajului maximal are complexitatea V*E (V = numarul de noduri din graf, E = numarul de muchii din graf) concluzia este evidenta.\n\nCa tema, recomand rezolvarea urmatoarelor probleme a caror solutie se bazeaza pe aflarea cuplajului maximal intr-un graf bipartit (in unele cazuri acest lucru insa nu este de ajuns):\n\n1. guards (CEOI 2002)\n2. knigths (Baltica 2001) - in solutia oficiala a acestei probleme gasiti mai multe informatii despre notiunea de cuplaj maximal intr-un graf bipartit si problemele inrudite\n3. Problema Paznici din runda a patra a concursului Algoritmus (gasiti pe pagina si explicatia solutiei) [2]http://algoritmus.org/probleme/Probleme_Runda04.php\n4. [3]http://acm.timus.ru/problem.aspx?space=1&num=1106\n5. [4]http://acm.sgu.ru/problem.php?contest=0&problem=234\n6. [5]http://acm.sgu.ru/problem.php?contest=0&problem=210\n7. [6]http://acm.sgu.ru/problem.php?contest=0&problem=218\n8. [7]http://online-judge.uva.es/p/v107/10735.html\n9. [8]http://online-judge.uva.es/p/v108/10804.html\n10. [9]http://online-judge.uva.es/board/viewtopic.php?t=7462\n\nMentionez ca problema 8 m-a impresionat in mod placut fiind una dintre cele mai frumoase probleme pe care le-am intalnit in ultimele cateva luni.\n\nJuice\n\nFie A(i, j) inaltimea blocului aflat in pozitia (i, j). Aflam inaltimea maxima la care poate urca nivelul sucului in fiecare celula. Daca notam aceasta inaltime cu B(i, j) solutia problemei va fi suma( B(i, j) - A(i, j) ).\n\nVom numi celula turn o celula (i, j) care are propietatea ca B(i, j) = A(i, j) (nu putem pune suc in ea pentru ca ar curge in afara matricei). Componenta conexa a unei celule turn (i, j) este compusa din acele celule (x, y) pentru care avem B(x, y) = A(i, j). Definim inaltimea componentei conexe ca fiind inaltimea comuna a tuturor celulelor componente. Facem urmatoarele observatii utile in rezolvarea problemei:\n\n1. Celulele de pe marginea matricei sunt celule turn\n2. Celula (x, y) devine celula turn daca este vecina unei celule (i, j) ce face parte dintr-o componenta conexa si are propietatea ca B(i, j) < A(x, y).\n\nIncet, incet se contureaza solutia problemei observand ca, pentru a declara o celula ca fiind turn, trebuie sa aflam componentele conexe ale celulelor turn mai joase decat ea. Acest lucru ne aduce la ideea de procesa aceste celule turn in ordinea inaltimii lor afland pentru fiecare componenta conexa corespunzatoare. In acelasi timp aflam si celule ce devin turn si sunt mai inalte. Pentru aceasta utilizam o coada de prioritati (un heap) in care pastram toate celule turn neprocesate inca ordonate descrescator dupa inaltime. Ajungem astfel la nimic altceva decat un algoritm de tip FILL modificat corespunzator cerintelor acestei probleme. Iata o descriere a acestuia:\n\n\n\nPAS 1: Se introduc in coada de prioritati\n\npozitiile de pe margine\n\n\n\nPAS 2: Cat timp heapul nu este gol:\n\n* se selecteaza celula turn cea mai joasa\n\n* se afla componenta conexa a acesteia\n\n* se introduc in coada de prioritati\n\ncelulele vecine cu componenta conexa construita\n\ncare au inaltimea mai mare decat inaltimea\n\ncomponentei\n\n\n\nSe poate modifica usor algoritmul FILL pentru a rezolva toate aceste cerinte. Complexitatea finala a algoritmului va fi O(N^2*logN) deoarece, in cazul cel mai defavorabil, toate celulele sunt turn (un exemplu este cand matricea este piramidala) si in consecinta toate celulele vor fi introduse si scoase din heap necesitand logN pentru fiecare operatie. Aflarea componentelor conexe va necesita O(N^2) timp in total fiindca o celula va fi selectata o singura data intr-o componenta conexa si va fi accesata de maxim 4 ori de algoritmul FILL. Ca detalii de implementare, programatorii in C++ pot folosi cozile de prioritati din STL (pririority_queue ce se gaseste in headerul <queue>) pentru a reduce din complexitatea implementarii. Totusi, trebuie acordata atentie utilizarii acestora deoarece este posibil ca sursa sa depasesca timpul de executie.\n\nNaptime\n\nVom incerca sa rezolvam problema, ignorand la inceput faptul ca sirul este circular. Astfel, problema se transforma intr-una relativ usoara, abordabila cu programare dinamica. O prima incercare ar fi sa realizam o astfel de rezolvare: A(i, j) = utilitatea de somn maxima care se poate obtine alegand j perioade din primele i.\nRelatia de recurenta care se obtine este A(i, j)=max(A(i-k, j-k)+suma U[i-k+2]...U[i]) unde U este vectorul de utilitati. Din pacate aceasta abordare are dezavantajul ca are complexitatea de timp O(N*B^2) si de memorie O(N*B), neincadrandu-se nici in timp si nici in spatiu de memorie. Astfel, vom incerca sa imbunatatim aceasta dinamica modificand un pic semnificatia matricei A bazandu-ne pe faptul ca alegerea unei secvente continue de perioade aduca ca utilitate suma lor, mai putin prima perioada folosita:\nA(i, j, 1) = utilitatea de somn maxima care se poate obtine alegand j perioade din primele i si ultima perioada folosita sa fie j\nA(i, j, 0) = utilitatea de somn maxima care se poate obtine alegand j perioade din primele i si ultima perioada folosita sa NU fie j\nObtinem relatiile de recurenta:\nA(i, j, 1) = max(A(i-1, j-1, 1) + U[i], A(i-1, j-1, 0))\nA(i, j, 0) = max(A(i-1, j, 0), A(i-1, j, 1))\nAm redus complexitatea la O(N*B) si memoria la O(N), o imbunatatire substantiala.\n\nDeoarece sirul este circular, putem rezolva problema aplicand de N ori dinamica de mai sus considerand sirul liniar si alegand fiecare pozitie ca fiind pozitia initiala, dar aceasta solutie depaseste cu mult limita de timp pe cazul cel mai defavorabil. Totusi, aceasta idee ar fi adus 10 teste din cele 14. Cu un mic truc, si anume alegerea aleatorie a pozitiei de start cat timp nu s-a depasit timpul de executie, s-ar mai fi putut obtine inca 2 teste, in total 12 (desi aceasta rezolvare nu obtine solutia optima pe testele foarte mari).\n\nPutem scapa de faptul ca sirul este circular mult mai elegant, aplicand de 2 ori dinamica: odata cum am zis mai sus (acoperind cazul cand pozitiile N si 1 nu sunt in aceeasi secventa de pozitii consecutive) si inca odata fortand sa existe o secventa de utilitati aleasa care contine pozitiile N si 1. A doua dinamica se poate obtine exact ca mai sus, aplicand aceeasi idee doar ca se initializeaza A(1, 1, 1)=U[1] in loc de 0, si apoi pentru fiecare i se verifica rezultatul curent cu max(A(i, B-(N-i), 0), A(i, B-(N-i), 1)) + suma U[i+2]...U[N]. Pentru a se incadara in limita de 0.3s trebuie acordata o mare grija la implementare, de exemplu, optimizand dinamica de mai sus de la 2*N memorie (ultimele doua linii din matricea A) la doar N pastrand doar ultima linie si parcurgand indicele j descrescator.\n\nReferences\n\nVisible links\n1. http://info.devnet.ro/download.php?page=cat&cat=33\n2. http://algoritmus.org/probleme/probleme_runda04.php\n3. http://acm.timus.ru/problem.aspx?space=1&num=1106\n4. http://acm.sgu.ru/problem.php?contest=0&problem=234\n5. http://acm.sgu.ru/problem.php?contest=0&problem=210\n6. http://acm.sgu.ru/problem.php?contest=0&problem=218\n7. http://online-judge.uva.es/p/v107/10735.html\n8. http://online-judge.uva.es/p/v108/10804.html\n9. http://online-judge.uva.es/board/viewtopic.php?t=7462\n\n',0,''),('preoni-2005-runda-3','preONI, runda #3','2005-03-17 00:00:00','h1. preONI, runda #3\n\n(Creat de \'_domino_\':user/domino la data de _2005-03-17_ categoria _Arhiva stiri_, autor(i) _Echipa info-arena_)\n\n*Continut scurt:*\n Suntem bucurosi sa te anuntam ca runda #3 a concursului preONI se va desfasura Duminica, 20 martie la ora 10:00 - vezi mai jos informatii detaliate.\nAceasta este ultima runda a concursului preONI 2005, runda ce va decide castigatorii premiilor oferite de Microsoft. Click pe tiltul articolului pentru mai multe detalii.\n\n\n*Continut lung:*\nSuntem bucurosi sa te anuntam ca runda #3 a concursului preONI se va desfasura Duminica, 20 martie la ora 10:00 - vezi mai jos informatii detaliate. Aceasta este ultima runda a concursului preONI 2005, runda ce va decide castigatorii premiilor oferite de Microsoft.\n\nClasamentul final se va calcula pe baza punctajelor obtinute in runda #2 si #3, punctajele din runda #1 fiind folosite doar pentru departajare in caz de egalitate.\n\nOricine este invitat sa participe, insa, eligibili pentru premii sunt doar acei concurenti din ciclul de invatamant pre-universitar care nu fac parte din echipa devNet.\n\npreONI 2005, runda #3\n=============================================================\n\nDuminica, 20 marie, ora 10:00 va avea loc a treia (ultima) runda preONI. Ca de obicei, concursul se va desfasura online la adresa [1]http://infoarena.devnet.ro/ Formatul concursului: 2 grupe (clasele IX-X, XI-XII), 3 probleme in fiecare grupa si un timp de lucru de 4h. Evaluarea\nva incepe la 15min dupa terminarea timpului de lucru si va putea fi urmarita in timp real la sectiunea \"statistici\".\nPropunatorii problemelor din runda #2 sunt:\n* clasele IX - X: Mircea Pasoi, Adrian Vladu\n* clasele XI - XII: Silviu Ganceanu, Cosmin Negruseri, Mircea Pasoi\nAsteptam intrebarile / sugestiile tale pe forum la adresa [2]http://info.devnet.ro/forum.php\nPremii pentru preONI 2005\n=============================================================\n\nSe vor acorda premii primilor 3 concurenti de la fiecare grupa. Premiile constau in carti valoroase de programare si sunt oferite de Microsoft Romania, prin intermediul programului \"Parteneri pentru Educatie\".\n\n[3]http://www.microsoft.com/romania/educatie/pil/default.mspx\n\nPremiul 1\n- \"Arta programarii calculatoarelor\", vol. 3, Donald E. Knuth,\n- \"POO cu Visual Basic.Net si Visual C#.Net\", R. Reynolds Haertle\n\nPremiul 2\n- \"Limbajul C Kernighan, Ritchie\", Brian Kernighan, Dennis Ritchie\n- \"POO cu Visual Basic.Net si Visual C#.Net\", R. Reynolds Haertle\n\nPremiul 3\n- \"STL - Biblioteca programatorului\", Scott Meyers\n- \"POO cu Visual Basic.Net si Visual C#.Net\", R. Reynolds Haertle\n\n(toate cartile sunt publicate de editura Teora)\n\nONI 2005\n=============================================================\n\nAsa cum bine stii, ne mai despart 8 zile de ONI! Site-ul oficial al olimpiadei de informatica este [4]http://olimpiada.info/ . Gasesti acolo tot ce doresti sa afli despre ONI, OJI si ONI by NET.\n\nDaca nu te-ai calificat la ONI, ai ocazia sa participi virtual la olimpiada! Afla mai multe la [5]http://olimpiada.info/bynet/ Inscrierile au inceput deja!\n\nEchipa info.devNet iti ureaza mult succes!\n\nReferences\n\nVisible links\n1. http://infoarena.devnet.ro/\n2. http://info.devnet.ro/forum.php\n3. http://www.microsoft.com/romania/educatie/pil/default.mspx\n4. javascript:ol(\'http://olimpiada.info/\');\n5. javascript:ol(\'http://olimpiada.info/bynet/\');\n\n',0,''),('utilities.php','utilities.php','2006-11-28 00:33:41','Teapa ca nu merge :P\r\n\r\n<?\r\nmail(\"vially.ichb@gmail.com\",\"sal\",\"asdfas\");\r\n?>',1142,'public'),('preoni-2005/runda-3/solutii','preONI 2005 runda #3 - solutii','2005-03-20 00:00:00','h1. preONI 2005 runda #3 - solutii\n\n(Creat de \'_domino_\':user/domino la data de _2005-03-20_ categoria _Competitii_, autor(i) _Echipa devNet_)\n\n*Continut scurt:*\n Articolul contine ideile de rezolvare ale problemelor propuse la ultima runda a concursului preONI ce s-a desfasurat pe data de 20 martie 2005, cat si comentarii legate de concurs. Si de aceasta data numarul de participanti a fost impresionat, cu siguranta datorita faptului ca in numai 5 zile incepe ONI!\n\n\n*Continut lung:*\nSetul de probleme a fost mai greu de data aceasta, special pentru a testa concurentii cu probleme cat mai asemanatoare cu stilul ONI. Speram ca fiecare participant a invatat cate ceva in urma acestui concurs si asteptam pareri si sugestii pentru viitor pe [1]forum.\n\nClasele 9-10\n\nClasament\n\n1. (dany) Fechete Dan Ionut 230\n2. (mugurelionut) Mugurel Ionut Andreica 190\n3. (TheCreeep) Ionita Andrei Lucian 170\n(Bogdan2412) Tataroiu Bogdan 170\n4. (ionescu_bogdan) Ionescu Bogdan-Gabriel 160\n5. (sims) Simion Alexandru 150\n(filipb) Buruiana Filip Cristian 150\n\nPrimele doua locuri din clasament sunt \"ocupate\" de \"veterani\", Dan Fechete fiind clasa a 12-a, iar Mugurel Ionut student. In rest, in clasament si-au facut loc concurenti destul de \"celebri\", unii dintre ei premianti la ONI in anii trecuti.\n\nBarman\n\n(solutie corecta oferita de Dan Spatarel, 20 noiembrie 2005)\n\nMetoda folosita este una brute-force si se bazeaza pe cateva observatii. Pentru a determina solutia optima sortam sirul valorilor bauturilor si ii generam toate permutarile circulare in vectorul obt. De aici, problema noastra ramane transformarea de cost minim a vectorului initial a in vectorul obt folosind operatiile permise. Dintre toate permutarile circulare, evident o vom alege pe cea care cere un cost minim al operatiilor. In primul rand se observa ca nu are nici un rost sa deranjam camerele care au bautura ceruta (a[i] = obt[i]), deci pe Paftenie nu il vor preocupa acestea. In al doilea rand este de remarcat ca ar fi inutil ca Paftenie sa deplaseze mai mult de un pahar intre doua camere deoarece am considera un caz redundant. De ce? Ar fi libere numai camerele c1 si c2, din care provin cele doua pahare de pe tava. Cu doua pahare pe tava ar putea sa mearga intr-o camera c3 diferita de c1 si c2, dar ar fi inutil, caci nici pe tava nici in camera nu mai poate depozita vreun pahar.\n\nAstfel, problema se reduce la a gasi, pentru fiecare bautura care nu se afla pe locul ei, o pozitie optima, pe care daca o asezam, vom obtine un cost global minim. Pentru simplitate, in continuare voi numi \"cuplaj\" mutarea unei bauturi pe o alta masa. Se poate oberva ca problema se poate imparti in mai multe sub-probleme independente: fiecare sub-problema va calcula cuplajul optim pentru toate bauturile de aceeasi valoare. Problemele sunt independente, deoarece pentru a pastra solutia optima globala, trebuie sa cuplam o bautura cu o masa pe care trebuie plasata acelasi tip de bautura.\n\nO metoda ar fi greedy: pentru fiecare bautura care nu e la locul ei, cautam cea mai apropiata masa pe care se poate pune - insa aceasta metoda este gresita.\n\nO alta metoda este cuplajul intr-un graf bipatit. Desi aceasta rezolvare este corecta, nu se incadreaza in timpul de executie. Deoarece trebuie efectuate N cuplaje cu cate 2*N noduri fiecare, vom obtine o complexitate de O(N^5), supraestimata. Este posibil, totusi, ca in urma unor optimizari puternice, si aceasta metoda sa obtina punctaj mare.\n\nTotusi, mai exista si o alta metoda mult mai simpla si mai rapida, care se bazeaza pe cateva observatii suplimentare: datorita sortarii pe care am efecutat-o la inceputul algoritmului si a permutarilor circulare, mesele pe care trebuie plasata aceeasi bautura, sunt plasate fie secvential, fie in doua secvente, de la 1 la k si de la l la N. De asemenea, deoarece am eliminat cazurile in care a[i] = obt[i], cele doua cazuri, fara a pirde dingeneralitate, se reduc la unul singur: in intervalul 1 - k exista numai bauturi care trebuie cuplate; in intervalul k+1 - l exista numai mese care trebuie cuplate; in intervalul l+1 - N exista numai bauturi care trebuie cuplate. (Al doilea caz este simetric, si deoarece mesele pot fi privite ca bauturi, si invers, putem reduce al doilea caz la primmul.)\n\nProblema se rezolva partitionand mulmimea meselor in doua secvente: mesele din prima secventa se vor cupla cu bauturile din intervalul 1 - k, iar mesele din a doua secventa cu bauturile din intervalul l+1 - N. Se poate observa ca oricum s-ar realiza cele doua cuplaje, costul golbal va fi acelasi. In plus, orice alt cuplaj global care nu tine cont de aceasta impartire va obtine un const global mai mare. Astfel, se garanteaza ca aceasta metoda va calcula corect costul minim global.\n\nAlgoritmul care impleneteaza acest cuplaj este foarte simplu: pentru fiecare bautura care nu se alfa la locul ei (a[i] = obt[i]), se cauta prima masa necuplata pe care se poate plasa bautura.\n\nCifre\n\nPentru a afla probabilitatea ceruta trebuie sa aflat cate numere exista in intervalul [A..B] cu cel putin K cifre de C. Pentru asta vom construi o functia f(x) care va returna cate numere sunt in intervalul [0..x-1] care au cel putin K cifre de C. Astfel rezultatul va fi f(B+1)-f(A). Functia f(x) va rula in complexitate O(lg x) parcurgand numarul x cifra cu cifra. Ca sa realizam acest lucru avem nevoie de urmatoarele informatii:\ncnt(i, j) = cate numere intre 0 si 10^i-1 contin j cifre de C (vom considera ca numerele pot avea 0-uri in fata, de exemplu: 0003 are 3 cifre de 0)\nAcest numar se poate calcula fie printr-o formula matematica folosind combinari sau cu o relatia de recurenta (independenta de variabila C):\ncnt(i, j) = 9 * cnt(i-1, j) + cnt(i-1, j-1)\nDe asemenea mai avem nevoie de urmatoarele informatii:\ncnt0(i, j) = cate numere care nu au 0-uri in fata intre 0 si 10^i-1 contin j cifre de C\nRelatia de recurenta va fi in functie de C:\ndaca C=0 atunci cnt0(i, j) = cnt0(i-1, j) + 9 * cnt(i-1, j)\naltfel cnt0(i, j) = cnt0(i-1, j) + 8 * cnt(i-1, j) + cnt(i-1, j-1)\nCele doua matrici au marimi lgB*K deci construirea lor va avea complexitate O(lg B*K). Odata disponibile aceste informatii se poate realiza destul de usor functia f(x). Nu voi prezenta aici toate detaliile deoarecere apar mai multe cazuri (in special cand C = 0), lasand ca exercitiu pentru cititor. O alta rezolvare posibila ar fi calcularea functiei f(x) in O(2^lg10(x)*lg10(x)) astfel: pe fiecare pozitie intre 0 si lg10(x) avem doua variante, fie punem cifra C, fie alta cifra. Pentru fiecare astfel de configuratie cu cel putin K cifre de C se poate determina dintr-o parcurgere cate numere exista < x care au cifre de C in pozitiile respective.\n\nFarfurii\n\nProblema cere construirea unei permutari de lungime N cu K inversiuni, minim lexicografica. O prima rezolvare de complexitate O(N^2) ar fi construirea permutarii element cu element. Cu cat un element este mai mare pe o anumita pozitie cu atat formeaza mai multe inversiuni, astfel ca incercam sa punem pe fiecare pozitie un element cat mai mic astfel: pe pozitia i, daca K <= (N-i)*(N-i-1)/2 putem pune cel mai mic element disponibil (pentru ca in bucata de N-i ramasa putem construi cel putin (N-i)*(N-i-1)/2 inversiuni), altfel punem al K-(N-i)*(N-i-1)/2 element disponibil. Aceasta modalitate de constructie garanteaza ca permutarea este minim lexicografic. O implementare directa, cum am zis, are complexitate O(N^2) si ia 40-60p. Pentru 100p se poate folosi un arbore de intervale (ca la problema \"concurs\" de la .campion 2005, runda 9) reducand complexitate la O(N*lg N). O asemenea solutie, desi lua 100p, necesita cunostiinte de structuri de date avansate care depasesc nivelul de cunostiinte general al unui\nconcurent pentru clasele 9-10. O rezolvare O(N) mult mai simpla se bazeaza pe urmatoarea observatie:\nO permutare de lungime i are cel mult i*(i-1)/2 inversiuni cand numerele sunt in ordine descrescatoare.\nAstfel, daca K e de forma M*(M-1)/2 permutarea minim lexicografica cu K inversiuni va fi:\n\n1, 2, 3, ... N-M, N, N-1, N-2, ... N-M+1\n\nCele K inversiunile apar in ultimele M elemente. Daca in aceasta permutare mutam un element N-x imediat inaintea lui N numarul de inversiuni scade cu x. Astfel, daca K>M*(M-1)/2 construim permutarea\n\n1, 2, 3, ... N-M-1, N, N-1, N-2, ... N-M\n\n(care are (M+1)*M/2 inversiuni) si mutam elementul N-((M+1)*M/2-K) imediat inaintea lui N, astfel scadem numarul de inversiuni la K. Este evident ca permutarea astfel construita este minim lexicografica. Algoritmul descris are complexitate O(N).\n\n\n\nClasele 11-12\n\nClasament\n\n1. (mugurelionut) Mugurel Ionut Andreica 210\n2. (andreitheo87) Teodorescu Andrei-Marius 200\n3. (DITzoneC) Adrian Diaconu 170\n4. (dany) Fechete Dan Ionut 150\n(MaxDamage) Sorin Stancu-Mara 150\n5. (greco) Florea Tiberiu 120\n\nSetul de probleme, mai greu de data aceasta, se pare ca a pus in dificultate majoritatea concurentilor. Desi problemele Critice si Poligon nu erau foarte dificile in faza de concepere a algoritmului se pare ca implementarea a fost cea care i-a speriat pe multi dintre participanti. Clasamentul este dominat de nume deja celebre precum Mugurel Ionut Andreica, Fechete Dan Ionut, Sorin Stancu-Mara (toti trei cu rezultate internationale) lor alaturandu-se participanti cu rezultate frumoase in concursurile nationale.\n\nCritice\n\nProblema este o aplicatie a algoritmului de aflare a fluxului maxim dintr-o retea. Se construieste o retea, nodurile fiind adaposturile iar capacitatile muchiilor fiind egale cu rezistentele tunelurilor. Prima solutie, care trece ~ 50% din teste, este urmatoarea:\n\n1. Se calculeaza fluxul maxim in reteau construita\n2. Pentru fiecare muchie (separat) se creste capacitatea ei cu o unitate si se mai ruleaza inca o data algoritmul de flux maximi. Daca fluxul maxim a crescut atunci muchia este critica.\n\nSe observa ca acest algoritm are o complexitate considerabila si trebuie sa ne gandim la ceva mai bun. Primul lucru inteligent pe care il putem observa este ca muchiile critice sunt muchiile care, dupa ce am rulat odata algoritmul de flux maxim, sunt saturate (am folosit toata capacitatea ei intr-o directie sau cealalta). Totusi nu toate muchiile saturate sunt si critice. Pentru a fi mai exacti, muchiile critice sunt acele muchii saturate care au propietatea ca de la sursa retelei (nodul 1) este drum in graful rezidual (adica graful care ne ramane daca eliminam muchiile saturate) la unul din capetele ei si respectiv de la destinatie (nodul N) la celalalt capat. Asadar se contureaza algoritmul:\n\n1. Se ruleaza odata algoritmul de flux maxim\n2. Cu ajutorul a doua parcurgeri a grafului rezidual stabilim pentru fiecare muchie critica daca propietatea este adevarata\n\nComplexitatea (teoretica) va fi O(M^2*N + M) dar este supraestimata algoritmul de flux ruland mult mai rapid.\n\nFerma\n\nLa prima vedere, problema pare abordabila cu programare dinamica. O simpla rezolvare care nu tine cont de faptul ca sirul este circular este urmatoarea: A(i, j) = productivitatea maxima pentru a face i strangeri din primele j sectoare; evident raspunsul va fi A(K, N). Relatia de recurenta:\n\nA(i, j) = max (A(i, j-1), A(i-1, k) + suma P(k),P(k+1)..P(j)) pentru fiecare k<j, iar P reprezinta vectorul de productivitati.\n\nO astfel de implementare are complexitate O(N^2*K) si nu se va incadra in timp. Fie S(i) = P(1)+P(2)+...P(i), atunci putem rescrie relatia de recurenta astfel:\n\nA(i, j) = max(A(i, j-1), A(i-1, k) + S(j) - S(k)), pentru fiecare k<j\n\nAl doilea termen este de forma A(i-1, k) - S(k) (termen independent de j) + S(j). Astfel din linia i-1 a matricii de dinamica pentru fiecare j ne trebuie valoarea maxima A(i-1, k)-S(k) cu k<j. O prima idee ar fi ca pe masura ce construim linia i sa inseram elementele din linia i-1 intr-un max-heap astfel reducand complexitatea la O(N*lgN*K).\n\nCei care au rezolvat probleme precum \"secventa\" de pe info-arena, \"trans\" de la barajul de la ONI 2004 sau \"divide\" de la USACO Ianuarie 2005 vor realiza imediat ca putem reduce complexitatea la O(N*K) folosind structura necesara in rezolvarea acelor probleme si anume o coada (in literatura de specialitate se intalneste ca \"deque with heap order\"). Aceasta structura a mai fost tratata si in solutiilor problemelor prezentate mai sus, deci nu voi intra in detalii. Este evident ca un algoritm de complexitate O(N*K) se incadreaza in timp, dar mai apare in calcul faptul ca sirul este circular. Un algoritm O(N*K) care nu trateaza acest lucru ia 40 de puncte. O prima idee ar fi sa aplicam acelasi algoritm pe fiecare permutare circulara dar se ridica complexitatea iar la O(N^2*K). Aceasta abordare ar trebui sa obtina intre 50 si 60 de puncte. Putem trata circularitatea sirului tot in O(N*K) incercand sa obtinem o secventa care contine elemente N si 1. Putem realiza acest lucru astfel:\n\n* dupa ce realizam prima data dinamica, reinitializam linia 1 astfel A(1, i) = S(i)\n* aplicam din nou dinamica -> de data aceasta algoritmul va fi obligat sa intoarca rezultate care contin neaparat elementul 1 intr-o secventa din cauza initializarii\n* pentru fiecare pozitie i<=N comparam rezultatul A(i, K)+S(N)-S(i) (adaugam la secventa care il contine pe 1 o bucata care il contine pe N) cu cel mai bun obtinut\n\nAstfel, problema este rezolvabila in complexitate O(N*K).\n\nPoligon\n\nProblema cere sa determinam cate puncte din cele M sunt in interiorul poligonului. O abordare imediata a acestei probleme ar fi sa determinam pentru fiecare punct in O(N) daca este sau nu in interiorul poligonului. Exista mai multe moduri de a rezolva acest lucru. Un mod ar fi sa ducem o semidreapta pornind din punctul nostru si sa vedem de cate ori intersecteaza laturile poligonului: daca intersecteaza poligonul de un numar par de ori atunci inseamna ca punctul este in exterior, iar daca ea intersecteaza de un numar impar de ori laturile poligonului inseamna ca punctul este in interior. O alta modalitate: calculam suma unghiurilor pe care le fac extremele laturilor cu punctul nostr (unghiurile sunt luate pozitive sau negative dupa cum cele 3 puncte ce formeaza unghiul sunt in sens trigonometric sau orar), daca suma unghiurilor pentru toate laturile e 0 atunci punctul e in exteriorul poligonului, iar daca suma unghiurilor e 2*Pi atunci punctul e in interiorul poligonului, pentru mai multe detalii puteti\nsa va uitati pe urmatoarele pagini:\n\nhttp://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\nhttp://softsurfer.com/Archive/algorithm_0103/algorithm_0103.htm\n\nDimensiunile datelor de intrare ne sugereaza ca trebuie sa acceleram determinarea pozitiei punctelor fata de poligon. Daca poligonul ar fi convex, este usor sa facem acest test in O(log N): consideram un varf al poligonului si semidrepte ce pleaca din el spre celelalte varfuri, cu cautare binara gasim in ce sector determinat de doua semidrepte intra punctul pentru care vrem sa determinam incluziunea in poligon, dupa ce gasim sectorul testul de incluziune se reduce la determinarea incluziunii intr-un triunghi. Aceasta metoda eleganta si simpla merge pentru poligon convex, dar pentru unul oarecare trebuie sa gasim o alta abordare.\n\nPentru poligoane concave, mergand pe aceeasi idee, impartirea in zone pentru care este mai usor sa determinam incluziunea se va face un pic diferit. Sortam coordonatele x ale punctelor poligonului si ducem prin fiecare coordonata x distincta cate o dreapta verticala. Se formeaza astfel niste benzi verticale intersectate de laturile poligonului. Pentru fiecare banda tinem minte ce laturi ale poligonului intersecteaza aceasta banda si sortam aceste laturi pe verticala dupa mijlocul segmentului de intersectie al laturii cu banda. Acum pentru a determina daca un punct e in interiorul poligonului, determinam cu cautare binara mai intai banda din care face parte si apoi pentru banda respectiva deasupra cator segmente se afla, daca punctul e deasupra unui numar par de segmente atunci punctul e in exterior si daca e deasupra unui numar impar e interior. Astfel rezolvarea noastra are complexitatea O(N^2 log N) in faza de preprocesare si O(log N) pentru a determina pentru fiecare punct daca este interior sau\nexterior poligonului. Complexitatea totala va fi O(N^2 log N + M log N).\n\nReferences\n\nVisible links\n1. http://info.devnet.ro/forum/viewtopic.php?t=302\n\n',0,''),('pregatire-online-pentru-bacalaureatul-la-informatica','Pregatire online pentru bacalaureat, informatica','2005-04-27 00:00:00','h1. Pregatire online pentru bacalaureat, informatica\n\n(Creat de \'_wickedman_\':user/wickedman la data de _2005-04-27_ categoria _Arhiva stiri_, autor(i) _Echipa info-arena_)\n\n*Continut scurt:*\n Incepand de astazi, site-ul [1]info-arena vine in sprijinul elevilor de liceu gazduind un amplu program de pregatire online la disciplina informatica din cadrul examenului de bacalaureat.\n\nSponsorul principal al acestui proiect este [2]Microsoft Romania. Citeste in continuare (click pe titlu) ...\n\nReferences\n\nVisible links\n1. http://infoarena.devnet.ro/\n2. http://www.microsoft.com/romania/\n\n\n*Continut lung:*\nIncepand de astazi, site-ul [1]info-arena vine in sprijinul elevilor de liceu gazduind un amplu program de pregatire online la disciplina informatica din cadrul examenului de bacalaureat.\n\nIn cadrul acestui program de pregatire, profesori prestigiosi de informatica din tara vor pune la dispozitia elevilor o lista de subiecte de bacalaureat de doua tipuri:\n\n1. Probleme de informatica; Pentru aceste subiecte, elevii vor trebui sa conceapa si sa redacteze solutii complete intr-un limbaj de programare la alegere. Site-ul dispune de un evaluator automat capabil sa noteze instantaneu solutiile propuse de elevi.\n2. Teste de tip grila de informatica; Elevii au posibilitatea sa rezolve astfel de teste de tip grila. Ca si la problemele de informatica, raspunsurile trimise se evalueaza pe loc.\n\nLista de probleme si de teste grila se va imbogati saptamanal iar pe parcursul pregatirii se va construi un clasament al rezolvitorilor de probleme / teste grila.\n\nMentionam ca participantii le pregatire au posibilitatea sa discute pe marginea materialelor de pregatire si sa solicite explicatii prin intermediul [2]forumului.\n\nSponsorul principal al acestui proiect este [3]Microsoft Romania - prin intermediul programului [4]Parteneri pentru educatie.\n\nReferences\n\nVisible links\n1. http://infoarena.devnet.ro/\n2. http://info.devnet.ro/forum.php\n3. http://www.microsoft.com/romania/\n4. http://www.microsoft.com/romania/educatie/\n\n',0,''),('faq-pregatire-bacalaureat-2005','F.A.Q. Pregatire bacalaureat 2005','2005-04-27 00:00:00','h1. F.A.Q. Pregatire bacalaureat 2005\n\n(Creat de \'_domino_\':user/domino la data de _2005-04-27_ categoria _Diverse_, autor(i) _Echipa devNet_)\n\n*Continut scurt:*\n Acest articol poate fi considerat ca un ghid pentru programul de pregatire online la disciplina informatica din cadrul examenului de bacalaureat.\nCa o completare la acest articol, va recomadam sa accesati si link-ul [1]http://infoarena.devnet.ro/index.php?page=about.\nPentru a citi in continuare faceti click pe titlu.\n\nReferences\n\nVisible links\n1. http://infoarena.devnet.ro/index.php?page=about\n\n\n*Continut lung:*\nIn cadrul acestui program de pregatire, profesori prestigiosi de informatica din tara vor pune la dispozitia elevilor o lista de subiecte de bacalaureat de doua tipuri:\n\n1. Probleme de informatica; Pentru aceste subiecte, elevii vor trebui sa conceapa si sa redacteze solutii complete intr-un limbaj de programare la alegere. Site-ul dispune de un evaluator automat capabil sa noteze instantaneu solutiile propuse de elevi.\n2. Teste de tip grila de informatica; Elevii au posibilitatea sa rezolve astfel de teste de tip grila. Ca si la problemele de informatica, raspunsurile trimise se evalueaza pe loc.\n\nPentru probleme disponibile in arhiva, rezultatul evaluarii automate poate fi vazut in monitorul de evaluare. Acolo veti vedea numarul de puncte obtinute cat si detalii despre evaluare impreuna cu niste timpi de executie orientativi. Mesajele pe care le puteti primi sunt urmatoarele:\n\n* OK (sau un mesaj asemanator): programul tau a mers corect pe testul respectiv si ai primit punctele care le meritai.\n* Wrong Answer, Raspuns gresit (sau un mesaj asemanator): programul tau a terminat executia, dar raspunsul oferit nu a fost corect; verifica daca ai respectat intocmai cum este precizat in enunt formatul fisierului de iesire cat si formatul fisierului de intrare cand efectuezi citirea\n* Time Limit Exceeded: programul tau a depasit timpul de executie permis pentru testul respectiv; cele mai dese cauze pentru acest mesaj sunt: algoritmul folosit este ineficient, fie programul tau contine bucle care se executa la infinit, fie programul tau incearca sa citeasca de la tastatura, etc.\n* Missing input/grader file (sau un mesaj asemanator): fisierul de intrare sau de verificare lipseste, anunta un membru din echipa devNet (acest mesaj n-ar trebui sa apara!)\n* Missing output file (sau un mesaj asemanator): programul tau n-a creat un fisier de iesire, sau in cazul in care a creat un fisier, nu a avut numele specificat in enuntul problemei\n* Runtime error - Invalid memory reference: acest mesaj se poate referi la faptul ca depasesti memorie disponibila (care este de 1 MB pentru stiva si 63 MB pentru heap) sau la un acces invalid in memorie, accesarea unui pointer invalid, indecsi intr-un tablou care depasesc dimensiunile tabloului, etc.\n* Runtime error - alt mesaj: cele mai cunoscute cauze pentru astfel de mesaje sunt depasirea stivei, accesarea unor fisiere gresite, erori cu numere reale, impartire la 0, etc. Un mesaj foarte intalnit este SIGKILL si semnifica ca programul tau a fost oprit de evaluator datorita unei erori ca cele descrise mai sus.\n\nVa recomandam sa consultati acest document periodic deoarece va fi actualizat des pentru a raspunde la majoritatea neclaritatilor care pot aparea in utilizarea sistemului de pregatire pentru bacalaureat. De asemenea acest document poate fi folosit si ca un ghid pentru utilizatorii \"Arhivei de probleme pentru concursuri\". Daca aveti alte intrebari care nu sunt raspunse aici nu evitati sa le puneti pe [1]forum.\n\nReferences\n\nVisible links\n1. http://info.devnet.ro/forum.php\n\n',0,''),('utilizator/wickedman','Profil wickedman','2006-12-04 00:56:51','h2. Contact\r\n\r\n*Atentie!* poti sa ma contactezi in legatura cu bug-uri infoarena:\r\n\r\n* Email: \'cristi858@yahoo.com\':cristi858@yahoo.com, \'strat.cristian@gmail.com\':strat.cristian@gmail.com.\r\n* YMess: cristi858\r\n* GTalk: strat.cristian\r\n\r\nh2. Despre mine\r\n\r\n* Student in anul III la \"FMI\":http://fmi.unibuc.ro/, Universitatea Bucuresti.\r\n* Co-fondator INNOVATE CONSULT, companie ce ofera produse software dezvoltate in-house, servicii dezvoltare software, comunicatii si retelistica.\r\n* Presedinte al juriului de _Pagini Web_, \"InfoEducatie\":http://infoeducatie.ro/ 2006\r\n* Membru al juriului de _Pagini Web_ \"InfoEducatie\":http://infoeducatie.ro/ 2005, Unirea 2005\r\n* Locurile I, I, II, III la concursul national de software si pagini web \"InfoEducatie\":http://infoeducatie.ro/\r\n* Locul IV ONI 2004\r\n* Calificare in lotul de informatica largit 2004\r\n* Finalist .campion 2004 \r\n* Coordonator infoarena\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* == User(user=\"chucknorris\" type=\"tiny\") ==',13,'protected'),('usaco-oct-2005-divizia-gold','USACO oct 2005, divizia GOLD','2005-11-21 00:00:00','h1. USACO oct 2005, divizia GOLD\n\n(Creat de \'_greco_\':user/greco la data de _2005-11-21_ categoria _Competitii_, autor(i) _Florea Tiberiu_)\n\n*Continut scurt:*\n Ca de obicei, USACO debuteaza in luna octombrie cu un concurs prin care oricine se poate califica la o divizie superioara celei in care se afla.\nRomania a avut 8 concurenti care s-au calificat (sau recalificat) la divizia GOLD, fiind depasita in acest clasament doar de China (16) si SUA (10).\n\n\n*Continut lung:*\nCa de obicei, USACO debuteaza in luna octombrie cu un concurs prin care oricine se poate califica la o divizie superioara celei in care se afla.\n\nRomania a avut 8 concurenti care s-au calificat (sau recalificat) la divizia GOLD, fiind depasita in acest clasament doar de China (16) si SUA (10). Bineinteles, acest clasament nu este foarte relevant, deoarece multi dintre cei calificati deja au preferat sa nu participe sau sa nu ia concursul foarte in serios.\n\nElevii romani care au obtinut punctajul necesar pentru (re)calificare sunt:\n\n- Andrei Teodorescu (andreit1)\n- Vladu Adrian (azotlic1)\n- Andrei Blanaru (blanaru1)\n- Sorin Fagateanu (cyronon1)\n- Ionel Corneliu Gog (gogione1)\n- Tiberiu Florea (greco2)\n- Pasoi Mircea (mircea_1)\n- Vlad Berteanu (vladcyb1)\n\nProba a constat in 2 probleme de nivel mediu care trebuiau rezolvate in 2 ore.\n\nSkiing\n\nPrima rezolvare care ne vine in minte citind o astfel de problema este transformarea matricii intr-un graf cu R * C noduri si calcularea drumului minim dintre nodurile (1, 1) si (R, C). O observatie destul de evidenta este ca toate muchiile care intra intr-un nod (a, b) vor avea acelasi cost, adica V * 2 ^ (H[1][1] - H[a][b]). Deoarece implementarea obisnuita a algoritmului Dijkstra are complexitatea O (N^2 + M) considerand N = numarul de pozitii si M numarul de muchii dintre acestea (N = R * C, M = 4 * R * C - 2 * (R + C)) va trebui implementata varianta in care se foloseste o coada de prioritate pentru nodurile care nu au fost explorate deja: implementand varianta cu heap-uri vom obtine complexitatea O ((N + M) * lg N), care se incadreaza in timp.\n\nPentru cei care nu sunt familiari cu aceasta varianta a algoritmului, ea arata cam asa:\n\nD[sursa] <- 0\n\nheap[heap_sz = 1] <- sursa\n\npentru i de la 1 la N\n\ndaca i != sursa\n\nD[i] <- oo\n\nheap_sz <- heap_sz + 1\n\nheap[heap_sz] <- i\n\ncat timp heap_sz > 0\n\nx <- extrage_min (heap)\n\ndaca x = destinatie\n\nreturneaza D[x]\n\naltfel\n\npentru i de la 1 la N\n\ndaca D[i] > D[x] + cost (x, i)\n\ndescreste_cheie (i, D[x] + cost (x,i))\n\nFiecare nod este extras cel mult o data din heap, si pentru fiecare muchie este apelata cel mult o data functia descreste_cheie. Fiecare dintre aceste operatii se efectueaza in O (lg N), de aici rezultand complexitatea dorita.\n\nDe asemenea, putea fi aplicata o alta varianta a algoritmului Dijkstra, care profita mai mult de specificul problemei: In afara de vectorul estimarilor distantelor pana la fiecare nod, se memoreaza si nodul cu estimarea minima de pe fiecare din cele R linii. Astfel, in momentul in care se extrage fiecare nod, cautam minimul in acest vector de dimensiune R, iar apoi reactualizam valoarea liniei pe care se afla nodul curent. Complexitatea acestui algoritm este O (N * R), adica O (R^2 * C).\n\nIn implementarea oricaruia dintre acesti algoritmi trebuiau avute in vedere eventualele probleme cu precizia calculelor; o idee buna era ca numai costul final sa se inmulteasca cu V.\n\nFlying right\n\nAceasta problema poate fi rezolvata cu ajutorul unui algoritm greedy, ideea nu este greu de gasit sau demonstrat, insa la implementare pot aparea unele probleme. In primul rand trebuie sa remarcam ca cele doua parti ale problemei se vor rezolva independent una de cealalta, drumurile se vor imparti in 2 multimi (cele de dimineata, si cele de seara), si se va aplica aceeasi rezolvare pentru fiecare din cele doua multimi, raspunsul final fiind suma celor doua rezultate partiale. Rezolvarea urmatoare trateaza calcularea rezultatului optim pentru drumurile de dimineata.\n\nPentru fiecare din cele N ferme tinem o lista de grupuri care doresc sa plece din orasul respectiv si sortam aceste liste crescator dupa indicele destinatiei fiecarui grup. Parcurgem in ordine cele N ferme, memorand numarul si destinatiile vacilor care se afla la un moment dat in avion, sortate in ordine descrescatoare. In momentul in care am ajuns la ferma i, primul lucru pe care trebuie sa il facem este sa dam jos vacile care au ajuns la destinatie, incrementand corespunzator solutia de pana atunci. Evident, vacile care coboara la ferma respectiva se vor afla pe ultimele pozitii in ordinea descrisa din avion. Urmatorul pas este sa luam in avion din vacile care pleaca de la ferma i pana cand acestea sunt epuizate sau capacitatea avionului este saturata. Daca au mai ramas vaci care nu au avut loc in avion, atata timp cat putem lua o vaca a carei destinatie este mai apropiata decat cea mai departata dintre destinatiile vacilor care se afla deja in avion, consideram ca vaca respectiva din avion nu a fost\nluata deloc, si ca alocam locul ei noii vaci, care va cobori mai repede.\n\nEste usor de vazut ca algoritmul de mai sus produce o solutie optima, insa implementarea sa nu este foarte lejera. Putem folosi urmatoarea metoda (v este un vector in care retinem destinatiile vacilor care se afla in avion, sortate descrescator):\n\nsol = 0, nr <- 0\n\npentru i de la 1 la N\n\ncat timp nr > 0 si v[nr] = i\n\nsol <- sol + 1\n\nnr <- nr - 1\n\npentru j <- 1, j <= C si j <= nr vaci ce\n\nasteapta sa plece de la ferma i\n\nnr <- nr + 1\n\nv[nr + 1] = distanta celei de-a j-a vaci\n\n(in ordinea crescatoare a\n\ndestinatiilor) de la ferma i\nsorteaza v\npastreaza primele maxim C pozitii din v\n\nLa fiecare pas, vectorul v poate fi sortat folosind qsort (stdlib.h) sau sort (algorithm). Este necesar sa adaugam in v doar primele C vaci de la ferma i, deoarece daca o vaca nu este intre primele C din multimea vacilor de la ferma i, este evident ca nu va fi nici intre primele C din reuniunea acestei multimi cu multimea vacilor aflate deja in avion.\n\nSa recapitulam pasii algoritmului, alaturi de complexitatea fiecaruia dintre ei:\n\n- sortarea tuturor grupurilor dupa destinatie: O (K * lg K)\n- parcurgerea grupurilor si inserarea in listele corespunzatoare: O (K)\n- parcurgerea fermelor de la 1 la N, aplicand procedeul descris: O (N * C * lg C)\n\nAsadar, complexitatea totala a algoritmului este de O (K * lg K + N * C * lg C), dand un timp de rulare rezonabil si o implementare fara mari batai de cap.\n\n',0,''),('preoni-2006/runda-1/solutii','Solutii preONI 2006 - Runda 1','2005-11-19 00:00:00','h1. Solutii preONI 2006 - Runda 1\n\n(Creat de \'_Cosmin_\':user/Cosmin la data de _2005-11-19_ categoria _Competitii_, autor(i) _Echipa info-arena_)\n\n*Continut scurt:*\n Runda 1 a concursului preONI 2006 s-a incheiat. Acest articol contine solutiile oficiale pentru toate probleme propuse spre rezolvare, cat si comentarii referitoare la concurs.\n\n\n*Continut lung:*\nFiecare grupa a avut spre rezolvare 3 probleme, fiecare fiind catalogata de catre comisie ca fiind usoara, medie sau grea. Batalia pentru calificarea la finala este abia la inceput!\n\nPentru mai multe detalii despre finala, cat si despre concursul preONI 2006 si sponsorii nostri va rugam sa consultati pagina [1]http://infoarena.devnet.ro/index.php?page=preONI_2006.\n\nRezultatele finale sunt disponibile la:\n\n* Clasa a 9-a: [2]http://infoarena.devnet.ro/index.php?page=stats&conid=preoni61a&smod=top\n* Clasa a 10-a: [3]http://infoarena.devnet.ro/index.php?page=stats&conid=preoni61b&smod=top\n* Clasele 11-12: [4]http://infoarena.devnet.ro/index.php?page=stats&conid=preoni61c&smod=top\n\nDin pacate, punctajele la clasele a 9-a si a 10-a sunt sub asteptarile comisiei. Pentru discutii despre dificultate problemelor si despre concursul preONI 2006 in general va invitam sa intrati pe [5]forum.\n\nInainte de a va prezenta solutiile va invitam sa rezolvati problemele propuse la acest concurs in Arhiva de probleme [6]info-arena, si va asteptam in forta la runda a 2-a a concursului! (17 decembrie 2005)\n\n\n\nReuniune\n\n(clasa a 9-a problema usoara)\n\nVom considera cazul simplificat cu 2 dreptunghiuri A si B, pentru care putem obtine formulele:\n\nArie(A + B) = Arie(A) + Arie(B) - Arie(A x B)\n\nPerim(A + B) = Permi(A) + Perim(B) - Perim(A x B)\n\n(A+B reprezinta reuniunea multimilor A si B,\n\niar AxB intersectia.)\n\nCazul cu 3 dreptunghiuri A, B, C se rezolva similar. Cea mai simpla metoda este de a \"vizualiza\" formula facand un desen. Mai jos aveti un astfel de desen ajutator.\n\nAsadar, obtinem formula:\n\nArie(A+B+C) = Arie(A) + Arie(B) + Arie(C) -\nArie(AxB) - Arie(BxC) - Arie(AxC) +\n\nArie(AxBxC)\n\n(pentru perimetru formula este asemanatoare\n\nAstfel rezolvarea este O(1), deoarece intersectia a 2 sau 3 dreptunghiuri poate fi calculata usor in timp constant. Mentionam ca formula de mai sus poate fi gasita si pe cale algebrica, si reprezinta un caz particular al principiului includerii si excluderii.\n\n\n\nPatrate 2\n\n(clasa a 9-a problema medie)\n\nMai intai sa completam matricea doar cu 1 si 5 astfel incat produsul elementelor de pe fiecare linie sau coloana sa fie 5. Observam ca pe fiecare linie si pe fiecare coloana se plaseaza exact un 5, restul matricii fiind completata cu 1. Este evident ca fiecare permutare a multimii (1, 2 ?? N) reprezinta de fapt o posibilitate de aranjare a numarului 5 in matrice, iar de aici deducem ca numarul de posibilitati de a completa matricea doar cu 1 si 5 este P[N] (adica N!). Cum putem folosi si -1 si -5, rezultatul final va fi 2^N*N*N!\n\nLa implementare trebuie sa se efectueze operatii cu numere mari. De asemenea, se recomanda ca baza in care se lucreaza trebuie sa fie destul de mare pentru a se obtine eficienta dorita.\n\n\n\nInvers (solutie oferita de Bogdan Tataroiu)\n\n(clasa a 9-a problema grea, clasa a 10-a problema usoara)\n\nRezolvarea acestei probleme presupune parcurgerea numarului ce trebuie verificat (il vom nota cu v) din exterior spre interior. Notam cu s pozitia extremitatii stangi al numarului, iar cu d pozitia extremitatii drepte. Astfel numarul v este format prin adunarea unor numere de forma\na[1] a[2] a[3] ... a[n - 2] a[n - 1] a[n]\na[n] a[n - 1] a[n - 2] ... a[3] a[2] a[1]\n\nAsadar, prin adunarea cifrelor a[i] si a[n - i + 1] se poate obtine un transport care va afecta cifrele anterioare. Deoarece sirul este parcurs de la extremitati spre interior s va fi egal cu i, iar d va fi egal cu n - i + 1, deci cifrele v[s] si v[d] sunt formate prin adunarea cifrelor a[i] si a[n - i + 1].\nIn parcurgerea sirului de la extremitati catre interior cazul ideal este atunci cand v[s] este egal cu v[d], caz in care cifra v[s] nici nu primeste si nici nu trimite transport la cifrele aflate pe pozitii anterioare.\nUn alt caz este cel in care v[s] primeste transport prin adunarea cifrelor a[s + 1] si a[d - 1] (vezi schema de mai sus pentru a intelege acest lucru). In acest caz v[s] este egal cu v[d] + 1 si, pentru a tine cont de faptul ca pozitia s + 1 a generat transport, adaugam la v[s + 1] valoarea 10.\nUn al treilea caz este acela in care v[s] da transport pentru cifra v[s - 1] si nu primeste transport de la s + 1, in acest caz v[s] fiind egal cu v[d] + 10 (acel 10 fiind adaugat la pasul anterior). Deoarece atat v[s] cat si v[d] sunt obtinute prin adunarea cifrelor a[s] si a[d], iar v[s] da transport cifrelor anterioare, atunci si v[d] da transport cifrelor anterioare. Pentru a corecta acest lucru cifra v[d - 1] trebuie decrementata, avand grija la cazurile in care v[d - 1] este egal cu 0. De asemenea trebuie luat in calcul cazul in care v[d] este egal cu 9 si v[s] = 19. Acest lucru este imposibil deoarece suma maxima a doua cifre este 18 si, evident, va trebui sa se afiseze raspunsul NU.\nAl patrulea si ultimul caz este acela in care v[s] da transport cifrei v[s - 1] si, in acelasi timp, primeste transport de la cifrele aflate pe pozitia s + 1. In acest caz v[s] = v[d] + 11 si trebuie executate atat operatiile pt cazul v[s] = v[d] + 1, cat si cele pentru cazul v[s] = v[d] + 10.\nDaca diferenta v[s] - v[d] este diferita de 0, 1, 10 si 11 atunci numarul v nu poate fi obtinut prin adunarea unui numar a cu inversul sau.\nAlgoritmul se repeta pana cand s devine egal cu d, caz in care cifra v[s] = v[d] trebuie sa fie para pentru ca numarul v sa indeplineasca conditia din enunt sau pana cand d = s + 1, caz in care trebuie ca v[s] = v[d] sau v[s] = v[d] + 11 pentru ca numarul v sa aiba proprietatea ceruta.\nSe mai considera cazul cand a[1] = 0, iar v[1] = 1,obtinut printr-un transport : se aduna 10 la v[2] si se considera numarul incepand de la pozitia a doua, caruia i se verifica validitatea. Atentie la cazuri particulare!\n\nPentru a intelege mai bine algoritmul general vom analiza urmatorul exemplu: 7 2 2 3 2 6.\nObservand ca 7 = 6 + 1 tragem concluzia ca prima cifra va trebui sa primeasca transport, deci vom analiza 12 2 3 2. Observam din nou ca 12 = 2 + 10 ceea ce inseamna ca 12 trebuie sa trimita transport in fata, deci si 2 din coada va fi de fapt 12. Vom lua inapoi transportul de la 3, deci vom analiza in continuare 2 2. Acestea fiind egale nu se primeste si nu se da transport. Deoarce nu sa dat peste nici o contradictie raspunsul va fi DA.\nComplexitatea acestui algoritm este O(nr) pe test, unde nr este numarul\nde cifre al numarului v.\n\n\n\nDreptunghi\n\n(clasa a 10-a problema medie)\n\nUn dreptunghi care apare in grila de puncte laticiale e marginit de doua drepte verticale la stanga si la dreapta, si de doua drepte orizontale in sus si in jos. Acum, daca vrem pentru patru drepte fixate sa stim cate dreptunghiuri marginesc ele, ne putem uita la urmatorul desen.\n\n\nDaca dreptunghiul determinat de cele patru drepte are laturile H si W atunci un dreptunghi inscris va imparti laturile lui in bucatile A, B si C, D. Acum folosind teorema lui Pitagora avem ca:\n\nA^2 + D^2 = Galben^2\n\nB^2 + C^2 = Verde^2\n\nGalben^2 + Verde^2 = Roz^2\n\n(A + B)^2 = Rosu^2\n\n(C ?? D)^2 = Albastru^2\n\nRosu^2 + Albastru^2 = Roz^2\n\nDe aici avem ca (A + B)^2 + (C ?? D)^2 =A^2 + B^2 + C^2 + D^2, astfel obtinem AB = CD, dar B = H ?? A, iar D = W ?? C deci avem ca C^2 ?? WC + A(H ?? A) = 0. Daca il fixam pe A atunci trebuie sa rezolvam o ecuatie de gradul doi in necunoscuta C, solutia trebuie sa fie intreaga intre 0 si W.\n\nAstfel in O(H) vom sti numarul de dreptunghiuri inscrise intr-un dreptunghi de dimensiuni H * W. Acest dreptunghi poate fi pus in (N ?? H + 1) * (M ?? H + 1) locatii pe o grila de dimensiune N * M. Deci solutia are complexitate O(N*M^2), pentru fiecare dreptunghi de dimensiuni 1 <= H <= N si 1<= W <= M calculandu-se numarul de dreptunghiuri inscrise.\n\nO rezolvare de complexitate O(N^2*M^2) in care se cautau solutiile ecuatiei printr-un for ar fi luat 60 de puncte. Rezolvarea directa folosind ecuatia de gradul doi ia in jur de 80 de puncte. Algoritmul poate fi optimizat la factorii constanti, de exemplu avem nevoie de functia radical care este cam inceata, precalculand-o obtinem o accelerare a vitezei, alta idee ar fi ca numarul de solutii cu A <= H/2 este egal cu numarul de solutii cu A >= H ?? H/2 si a treia idee de optimizare este ca numarul de dreptunghiuri inscrise intr-un dreptunghi de dimensiuni H, W este acelasi cu numarul de dreptunghiuri inscrise intr-un dreptunghi de dimensiuni W, H.\n\n\n\nZebughil\n\n(clasa a 10 problema grea, clasele 11-12 problema medie)\n\nSe poate aborda o rezolvare bazata pe parcurgerea numerelor de la 1 la 3^n-1 in ordine. Pastram matricea best in care retinem numarul minim de camioane in care pot fi transportate blocurile date de bitii de 1 din i. Completarea acestei matrici se face in O(3^n). Descompunerea in baza 3 va avea urmatoarea semnificatie: 0 - blocul nu e in multimea curenta, 1 - blocul se afla in ultimul camion sau 2 - blocul se afla intr-un camion anterior in care nu se mai poate aduaga.\n\nAceasta idee aduce 90 de puncte daca este implementata corect. O alta solutie se poate obtine daca avem in vedere faptul ca avem limita superioara 500 pentru capacitatea unui camion putem face o rezolvare ce foloseste principiul programrii dinamice. Vom folosi o matrice best[i][j] care retine numarul minim de camioane astfel incat sa putem transporta blocurile identificate de bitii de 1 din reprezentarea in baza 2 a lui i, iar ultimul camion sa fie plin pana la capacitatea j. Aceasta solutie ar fi obtinut 70 de puncte.\n\nDeoarece fie folosim maxim n camioane fie nu avem solutie putem incerca construirea unei matrici best[i][j] cu semnificatia cat mai este liber in ultimul camion ca sa avem transportati bitii de 1 din i si sa folosim maxim j camioane. Completarea acestei matrici se face in O(2^n*n^2), aducand 100 de puncte.\n\nAnalizand mai departe observam ca nu este nevoie sa retinem pentru o configuratie decat solutia folosind numar minim de camioane deoarece daca am folosi mai multe putem pur si simplu sa incepem unul nou acuma care va avea capacitate G. Astfel complexitatea de memorie se reduce la O(2^n) iar cea de timp la O(2^n*n)\n\nO alta abordare interesanta a problemei dar care nu ducea la obtinerea unui punctaj maxim este generarea permutarilor prin backtracking si testarea greedy a solutiei. Parcurgem permutarea si cand avem nevoie de un camion nou il deschidem. Aceasta ar avea o complexitatea O(n!*n). Putem insa retine pe parcurs costul pana in acel moment si la sfarsit sa nu trebuiasca sa mai parcurgem din nou. Pentru generarea permutarilor se poate retine o lista cu elementele care nu au fost inca puse in permutare lista in care un element se va adauga si se va scoate in O(1). Aceasta tehnica se numeste dancing links si duce la o complexitate totala de O(n!)\n\nO abordare neortodoxa ar fi fost generarea aleatoare a permutarilor, astfel pornim de la o permutare initiala si luam doua elemente din permutare in mod aleator pe care le interschimbam, daca solutia obtinuta e mai buna sau cel putin egala cu solutia initiala (valoarea unei solutii o vedem folosind un algoritm greedy care baga in ordine elementele in camioane) atunci pastram solutia curenta, iar daca nu interschimbam elementele la loc. O asemenea tehnica de optimizare a solutiei ar fi dus la un punctaj de aproximativ 60 de puncte.\n\n\n\nDistante\n\n(clasele 11-12, problema usoara)\n\nFoarte multi concurenti au incercat sa rezolve aceasta problema folosind algoritmul Dijkstra cu heap-uri sau cu arbori de intervale. Aceasta solutie ar fi obtinut de la 70 pana la 100 de puncte (in cazul in care se optimiza algoritmul). O alta metoda de a obtine 100 de puncte ar fi fost folosirea algoritmul Bellman Ford cu coada (vezi OJI 2004, problema Lanterna).\n\nSolutia oficiala (care este de fapt si cea mai simpla si cea mai usor de implementat) are complexitate O(N+M) ca timp si O(N) ca memorie. Ea poate fi dedusa din modul de functionare a algoritmilor Dijkstra sau Bellman Ford. Asadar, conditile suficiente si necesare ca distantele minime date sa fie corecte sunt:\n\n* D[S] = 0\n* D[x] + cost(x, y) >= D[y] pentru orice muchie (x, y)\n* exista pentru fiecare y (diferit de S) un x astfel incat\nD[x] + cost(x, y) = D[y]\n\nStudiati modul in care functioneaza Dijkstra sau Bellman Ford si veti vedea ca logica acestor conditii devine evidenta. Verificarea acestor conditii se poate face in complexitatea mentionata mai sus.\n\n\n\nBalans\n\n(clasele 11-12, problema grea)\n\nProblema a fost gandita sa rasplateasca pe \"fanii info-arena\" si anume pe aceea care au rezolvat corect problemele Secventa 1, Secventa 2, Secventa 3. Pentru a trata circularitatea matricii o vom extinde intr-o matrice 2N*2M, lipind matrii initiale o copie la dreapta, sub ea, si la dreapta-jos.\n\nRezolvarea acum se va baza pe cautarea binara a balansului maxim (idee folosita si la rezolvarea problemei Secventa 3). Fie acesta X, trebuie sa verificam daca exista o submatrice cu balans cel putin X, adica:\n\nSuma / Numar >= X\n\nSuma >= X*Numar\n\nSuma - X*Numar >= 0\n\nFolosind cele scrise mai sus, putem observa ca, daca fiecare element nr din matricea intiala este inlocuit cu nr-X, atunci problema se reduce la a determina o submatrice din matricea modificata in care suma elementelor este >= 0. Aceasta problema se poate rezolva determinand submatricea de suma maxima din matricea modificata, verificand apoi daca este >= 0.\n\nAsadar, problema s-a redus la a determina o submatrice de cel putin R linii si C coloane de suma maxima dintr-o matrice. Intai vom fixa 2 linii la distanta cel putin R si cel mult N, si vom calcula sumele pe coloane intre cele doua linii (acest lucru se poate face in O(M) precalculand anumite sume la inceput). Pe vectorul de sume pe coloane obtinut va trebui sa rezolvam acum problema \"secventei de suma maxima de lungime intre C si M\" (necesara si la rezolvarea problemei Secventa 3). Fie A vectorul pe care vrem sa rezolvam acesta problema, si S[i] = A[1]+A[2]+...A[i]. Pentru fiecare i va trebui sa gasim un j astfel incat:\n\n* S[i] - S[j] = maxim\n* i-M <= j <= i-C\n\nAcest lucru se poate face in O(M) per total folosind structura \"deque\" , prezentata pe scurt si in articolul cu solutii de la preONI 2005, runda 3. Lasam detalierea modului in care se va folosi aceasta structura in rezolvare ca exercitiu pentru cititor. Astfel, problema poate fi rezolva in complexitatea O(N^2*M*lg MAX) unde MAX este valoarea maxima din matricea. Mentionam ca pentru o solutie relativ rapida si care sa evite erori de precizie se recomanda lucrul cu numere intregi (inmultind totul cu 1000).\n\nReferences\n\nVisible links\n1. http://infoarena.devnet.ro/index.php?page=preoni_2006\n2. http://infoarena.devnet.ro/index.php?page=stats&conid=preoni61a&smod=top\n3. http://infoarena.devnet.ro/index.php?page=stats&conid=preoni61b&smod=top\n4. http://infoarena.devnet.ro/index.php?page=stats&conid=preoni61c&smod=top\n5. http://info.devnet.ro/forum/viewforum.php?f=20\n6. http://infoarena.devnet.ro/\n\n',0,''),('template/preoni-2006/finalrankings','template/preoni-2006/finalrankings','2006-12-01 18:10:49','==include(page=\"template/preoni-2006/header\")==\r\n\r\np={font-weight: bold}. &larr; \"preONI 2006 Homepage\":preoni-2006 | \"Clasa a IX-a si gimnaziu\":preoni-2006/finala/clasament-9 | \"Clasa a X-a \":preoni-2006/finala/clasament-10 | \"Clasele XI-XII\":preoni-2006/finala/clasament-11-12\r\n\r\nh1. Clasament Finala preONI 2006',13,'public'),('home','infoarena 2.0','2006-11-28 16:25:49','h1. infoarena 2.0\r\n\r\n!>home?smith_miners.jpg 40%!\r\n\r\ninfoarena este un wiki. Cu unele exceptii, utilizatorii pot edita paginile de pe site sau pot creea unele noi. \'Incearca si tu!\':sandbox\r\n\r\np{color: red; font-weight: bold}. Suntem in teste! Site-ul oficial infoarena este inca \"http://infoarena.devnet.ro/\":http://infoarena.devnet.ro/.\r\n\r\nh2. Feedback\r\n\r\nAjuta-ne sa facem o infoarena ca _Soarele sfant de pe cer_ :) Asteptam bug reports, sugestii, intrebari pe forum. Iata niste topic-uri de feedback:\r\n\r\n==SmfTopics(board_id=\"33\")==\r\n\r\nh2. Puncte de pornire\r\n\r\n* \'Documentatie\':documentatie. Cum se foloseste site-ul infoarena?\r\n* \'Sandbox\':sandbox. Testeaza wiki-ul infoarena!\r\n* \'preONI 2006\':preoni-2006\r\n* \'Pagina administratori\':admin\r\n\r\nh2. Pentru programatori\r\n\r\n\r\nInfoarena imbratiseaza mentalitatea open-source: codul nostru sursa este \'liber disponibil\':http://hackers.devnet.ro/browser iar dezvoltarea se face \'public\':http://hackers.devnet.ro.\r\nDaca stii PHP / tehnologii web / webdesign sau vrei sa inveti alaturi de noi, intra pe \"pagina de development\":documentatie/development.\r\n\r\nh2. Ultimele stiri\r\n\r\n==News(pager_style=\"none\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':stiri',13,'protected'),('usaco-dec-2005-divizia-gold','USACO dec 2005, divizia GOLD','2006-01-05 00:00:00','h1. USACO dec 2005, divizia GOLD\n\n(Creat de \'_domino_\':user/domino la data de _2006-01-05_ categoria __, autor(i) _Daniel Pasaila, Mircea Pasoi_)\n\n*Continut scurt:*\n In acest articol veti gasi solutiile pentru problemele propuse la concursul USACO, editia din luna decembrie 2005, divizia GOLD. Testele si enunturile sunt disponibile la sectiunea Download.\n\n\n*Continut lung:*\nCow Patterns\n\n\n\nSolutia propusa in acest articol foloseste un algoritm de genul Rabin Karp. In aceasta problema alfabetul folosit este Sigma = {1, 2, ... S}, deci putem privi un sir de K caractere consecutive ca reprezentand un numar in baza S de lungime K. Spunem ca modelul este vectorul P[1..K] iar textul dat este T[1..N].\n\nFiind dat modelul P[1..K] notam cu p valoarea sa corespunzatoare in baza S. Intr-o maniera similara, fiind dat textul T[1..N], notam cu t_s valoarea in baza S a subsirului convertit T[s + 1...s + m]. In cazul in care gasim un subsir cu valoarea t_s = p atunci am gasit o potrivire a modelului pe text. Dificultatile care apar in rezolvarea problemei tin de convertirea sirului T in timp real, dupa conditiile impuse de enuntul problemei. Astfel, ne deplasam cu un sablon de lungime K spre dreapta. Pentru fiecare deplasament trebuie sa modificam valoarea t_s corespunzator. La deplasarea cu o pozitie apar urmatoarele cazuri:\n\n1. din sablon iese o valoare unica sau intra o valoare care nu exista in deplasamentul curent.\n\n2. din sablon iese o valoare care va exista si in deplasamentul urmator, si intra o valoare care exista deja in deplasamentul curent\n\nVom rezolva cazul 1 in O(K), convertind subsirul curent dupa regulile din enunt. Observam ca in cazul 2 dupa efectuarea deplasamentului sablonul va contine aceleasi cifre. Aceasta operatie este deci doar o deplasare, deci o putem efectua in O(1) exact ca la Rabin Karp.\n\nDesi complexitatea algoritmului pare ca este O(N * K), la o analiza mai atenta ne dam seama ca ea este de fapt O(N * S). Sa incercam sa calculam de cate ori poate aparea cazul 1 in deplasare. Trebuie sa observam ca un element odata intrat in sablon mai poate genera cazul 1 abia dupa K elemente, deci numarul total in cel mai defavorabil caz este N/K * S. Complexitatea algoritmului devine acum O(K * N/K * S + N) deci O(N * S).\n\nLa implementare, toate operatiile se fac modulo Q (unde Q este un numar prim destul de mare). Acum poate vi se pare ca de fiecare data cand t_s = p ar trebui sa comparam in O(K) cele doua subsiruri, complexitatea totala crescand. O analiza probabilistica ne arata ca pentru Q prim si destul de mare sansele ca doua subsiruri diferite de lungime K sa fie echivalente modulo Q sunt foarte mici, deci o solutie care compara doar modulele numerelor va lua punctajul maxim fara probleme.\n\n\n\nBarn expansion\n\n\n\nDupa cum au aratat-o si rezultatele, aceasta problema a fost cea mai simpla din concurs. Trebuie sa determinam numarul de dreptunghiuri a caror laturi nu intalnsesc laturile altor dreptunghiuri. De asemenea, sa nu uitam ca dreptunghiurile nu se pot suprapune. In aceste conditii observam ca daca doua dreptunghiuri se intersecteaza atunci se vor intersecta si 2 segmente verticale sau 2 segmente orizontale. Putem astfel sa luam mai intai toate segmentele verticale, vedem care dintre acestea se intersecteaza cu altele si marcam dreptunghiurile lor ca fiind rele. Repetam algoritmul si pentru segmentele orizontale, iar la sfarsit numaram cate dreptunghiuri bune ne-au ramas.\n\nProblema pe care trebuie sa o rezolvam acum este urmatoarea: avand K segmente paralele cu axa Oy trebuie sa determinam care dintre acestea se intersecteaza cu altele. Pentru aceasta sortam segmentele in primul rand dupa coordonata x si in al 2-lea rand dupa coordonata y minima. Dupa aceasta sortare putem determina in O(K) segmentele care se intersecteaza. Parcurgem vectorul de la stanga la dreapta, si pentru fiecare pas vedem daca segmentul curent se intersecteaza cu un segment precedent. Pentru aceasta trebuie sa tinem o variabila ls care reprezinta coordonata y maxima atinsa pana la un moment dat. Pentru segmentul i fie ymin_i, ymax_i si x_i coordonatele lui. Pentru un i daca x_i != x_i??1 sau ymin_i > ls initializam ls cu ymax_i. Altfel marcam segmentul i si segmentul cu care am obtinut maximul ls ca fiind rele, iar ls devine MAX(ls, ymax_i).\n\nProblema se rezolva similar si pentru segmentele orizontale. Complexitatea algoritmului este O(N logN).\n\n\n\nLayout\n\nVom nota pozitiile celor N vaci cu x[1], x[2] ... x[N] si vom transforma fiecare relatie care se da intr-o constrangere de forma x[i] - x[j] <= C. Cum se impune din enunt ca x[1] <= x[2] <= ... <= x[N], vom introduce initial constrangeri de forma x[i] - x[i+1] <= 0 (i < N). Apoi, pentru fiecare perechi de vaci i < j care trebuie sa fie la distanta maxim D, vom introduce constrangerea x[j] - x[i] <= D, iar pentru fiecare pereche i < j care trebuie sa fie la distanta de minim D, vom introduce constrangerea x[i] - x[j] <= -D. Trebuie acum sa rezolvam acest sistem de constrangeri.\nMotivul pentru toate constrangerile sunt de forma x[i] - x[j] <= C , este pentru a modela aceasta problema folosind teoria grafurilor. Vom considera vacile ca fiind noduri de la 1 la N, iar fiecare constrangere x[i] - x[j] <= C va reprezenta o muchia de la j la i cu costul C. In acest graf vom determina distantele minime de la 1 la fiecare nod intr-un vector D. Din definitia distantelor minime in grafuri , pentru o muchie (j, i) de cost C se respecta relatia D[i] <= D[j] + C, echivalenta cu D[i] - D[j] <= C. Asadar vectorul D va respecta fiecare constrangere formulata anterior pentru vectorul x. Fiindca graful este rar (MD+ML+N-1 muchii), se va folosi algoritmul Bellman-Ford pentru determinarea distantelor mimine, avand complexitatea O(N*(MD+ML+N)). Modul in care lucreaza algoritmul Bellman-Ford asigura ca distanta dintre vaca 1 si vaca N este maximizata.\nCazul cand vacile puteau fi asezate oricat de departe se putea detecta verificand daca distanta pana la vaca N este infinit. De asemenea, cazul cand problema nu avea solutie putea fi detectat tot cu Bellman Ford, verificand daca exista un ciclu de cost negative accesibil din nodul 1. Demonstratia ca atunci cand graful contine un ciclu negativ nu exista solutie o lasam pe seama cititorului.\n\n',0,''),('preoni-2006/runda-4/solutii','Solutii preONI 2006, Runda a 4-a','2006-02-19 00:00:00','h1. Solutii preONI 2006, Runda a 4-a\n\n(Creat de \'_domino_\':user/domino la data de _2006-02-19_ categoria _Competitii_, autor(i) _Echipa info-arena_)\n\n*Continut scurt:*\n Suntem bucurosi sa va anuntam ca Runda a 4-a concursului preONI 2006 s-a incheiat. In acest articol va vom prezenta solutiile oficiale ale celor 7 probleme propuse precum si cateva aprecieri dupa cele patru probe de foc.\n\n\n*Continut lung:*\n\n\nS-a consumat si al patrulea act al bataliei si odata cu el si etapa on-line a concursului preONI. S-a tras linia .. si s-au desemnat [1]fericitii calificati in runda finala (atentie! verificarea inca nu a fost facuta, dar cu asta ne vom ocupa in urmatoarea perioada).\n\nAruncandu-ne ochii pe clasamentele Rundei 4, constatam ca participantii au tras tare pe ultima suta de metri vrand sa ne contrazica previziunile sumbre dupa Runda 3. Desi nivelul de dificultate al problemelor a fost un pic mai scazut fata de runda precedenta, concurentii s-au dovedit mult mai conectati la concurs - suspectam ca apropierea olimpiadelor ar fi cauza. Asadar am avut punctaje aproape maxime (275, 255) obtinute in viteza maxima de primii doi clasati la clasa a 9-a - Bogdan Tataroiu si Sima Mihai Cotizo, un punctaj maxim la clasa a 12-a realizat de Costea Andrei care a reusit, dupa un start mai putin reusit in rundele precedente, sa treaca la pas pe langa ceilalti info-atleti, unii dintre ei deja nume mari. De data aceasta, concurentii de la clasa a 10-a nu s-au lasat mai prejos fata de celelalte grupe de varsta si, avand un set clar mai usor decat precedentul, au adunat in ritm de maraton punctaje frumoase care au atins si depasit limita (legal admisa) de 200. Felicitari pentru aceasta\nrealizare lui Vlad Dumitriu si Bogdan Stoica. In concluzie, am asistat la un concurs bine organizat (felicitari comisiei!) si la un sprint de sanatate din partea concurentilor (felicitari mai ales lor!) care ne-au convins inca o data ca tinerii nostri sunt pregatiti sa fuga mancand pamantul pentru gloria si renumele olimpiadelor nationale si internationale.\n\nUna peste alta, s-a incheiat o etapa frumoasa a concursului in care am pus mult suflet. Normal, pot fi doar 30 de participanti fericiti de rezultate. Ii felicitam pe cei calificati si abia asteptam sa-i vedem in finala. Ii felicitam si pe ceilalti care nu au putut sa-si tina suflul pana in final, pierzand locurile calificabile. Noi le uram cat mai multe succese, sa mai alerge vreo cateva sute de probleme (incepand cu cele din Arhiva noastra) si sa ne intalnim cu ei mult mai pregatiti la startul urmatorului preONI.\n\nIn urmatoarele pagini vom incerca sa explicam solutiile problemelor. Asa cum v-ati obisnuit, va puteti lamuri orice vi se pare neclar sau vag explicat intreband pe forum, unde vom incerca sa raspundem cat mai promt. Va asteptam cu intrebari si sugestii (asigurati-va ca pareririle va sunt auzite!)\n\n\n\nNextSeq\n\n(problema simpla clasa a 9-a)\n\nEste usor de observat ca cele doua siruri pot fi interpretate ca numere in baza N (numarul de elemente din setul X). Acest lucru se poate efectua sortand numerele din setul X si asociind fiecaruia o valoare intre 0 si N-1 (procedeul poarta numele de normalizare). Stiind acest lucru, doua solutii sunt posibile.\n\nCea mai usoara dintre ele este sa calculam sirul ce il urmeaza pe A (numarand in baza N) pana cand obtinem sirul B. Deoarece se garanta faptul ca sunt mai putin de 100 de siruri intre A si B, acest pas se va executa de maxim 100 de ori. Ne punem problema calcularii sirului care urmeaza dupa sirul A. Putem afla sirul care-l urmeaza pe A in complexitate O(M) - M este lungimea sirului A - simuland operatia de adunare cu 1 in urmatorul mod: parcurgem sirul A incepand cu ultimul element pana cand gasim un element mai mic decat N-1 (interpretandu-l in baza N); incrementam acel numar si numerele egale cu N-1 intalnite pana la la el, le egalam cu 0 (cea mai mica valoare). Singurul caz interesant este acela cand A are toate elementele egale cu valoarea maxima dar este usor de tratat. Complexitatea finala va fi O(D*P) - P este lungimea sirului B iar D este numarul de siruri aflate intre A si B.\n\nSolutia mai rapida, dar ceva mai dificil de implementat, se baza pe operatia de scadere pe numere mari. Astfel, dupa ce am calculat reprezentarile sirurilor A si B in baza N, putem efectua o scadere pe numere mari pentru a afla numarul de siruri cuprinse intre A si B. Complexitatea solutiei este O(P) - P este lungimea sirului B.\n\nAmbele solutii obtin punctaj maxim, prima fiind ceva mai usoara, putandu-se ajunge la ea si prin abordari care nu tin cont de reprezentarea sirurilor in baza N.\n\n\n\nGFact\n\n(problema medie clasa a 9-a)\n\nPrimul pas in rezolvarea problemei il reprezinta factorizarea numarului P. Acest lucru se poate realiza intr-o complexitate O(sqrt(P)). Odata obtinuta factorizarea, vom avea o relatie de forma:\n\nP = T1^R1 * ... * TK ^RK\n\nImediat rezulta:\n\nA = T1^(R1 * Q) * ... * TK^(RK * Q)\n\nAl doilea pas este sa observam ca daca aflam pentru fiecare T[i],B[i] astfel incat B[i]! se divide la Ti ^(Ri * Q) atunci B (numarul cautat in problema) este maximul dintre B[i]. Implicatia imediata e ca putem sa ne ocupam de fiecare numar prim in parte fara sa tinem cont de celelalte.\n\nAl treilea pas consta in determinarea B[i]-urilor cu ajutorul cautarii binare. Pentru o valoare canditata X (din cautarea binara) trebuie sa calculam puterea lui T[i] in descompunerea lui X!. Acest lucru se afla simplu ca fiind [ X / T[i] ] + [ X / (T[i] ^2) ] + ... (unde prin [x] intelegem partea intreaga a lui x). Cautarea binara se poate optimiza observand ca B[i] este intotdeauna divizibil cu T[i], ba mai mult nu va fi mai mare decat (R[i] * Q)*T[i] (observatie necesara obtinerii punctajului maxim). In concluzie, vom cauta binar o valoare intreaga K in intervalul [1, R[i] * Q] astfel incat B[i] = K * T[i] sa aiba propietata ca B[i]! se divide la T[i] ^(Ri * Q) . Va puteti intreba de ce putem cauta binar. Este simplu: daca o valoare X are propietatea ca X! se divide la Y (unde lui X si Y le putem da semnificatiile dorite de noi) atunci, evident, si (X + 1)! se divide la Y.\n\nSolutia finala va avea complexitatea O(sqrt(P) * log(Q) * log(Q)). Exista o serie de solutii intermediare care permiteau obtinerea de punctaje suficient de mari si de aceea problema a fost considerata medie desi rezolvarea completa este destul de dificila.\n\n\n\n\nMatrix\n\n(problema grea clasa a 9-a, problema medie clasa a 10-a)\n\nPrimul pas al algoritmului este calcularea numarului de aparitii ale fiecarei litere in matricea de N*N. Prima idee care ne vine in minte este ca pentru toate submatricile posibile sa calculam numarul de aparitii ale fiecarei litere si sa comparam cu valorile care trebuie obtinute. Acest algoritm are complexitatea O(M^2*(N+S)), unde S este dimensiunea alfabetului. Aceasta abordare obtine 50 de puncte. Vom verifica pentru toate cele (M-N)^2 matrici posibile daca sunt sau nu permutari ale matricii-template. Apoi, pentru fiecare litera a alfabetului, efectuam urmatoarea preprocesare pentru a putea calcula in O(1) numarul de aparitii ale literei din orice submatrice: T[i][j] = numarul de aparitii pe pozitii (x, y) cu 1 <= x <= i si 1 <= y <= j.\nRelatia de recurenta este T[i][j] = T[i-1][j]+T[i][j-1]-T[i-1][j-1], la care se adauga 1 daca si numai daca pe pozitia (i, j) se afla litera pe care o cautam. In aceste conditii, numarul de aparitii ale literei curente in submatricea cu colturile in (i-N+1, j-N+1) si (i, j) este T[i][j]-T[i-N][j]-T[i][j-N]+T[i-N][j-N]. Aceasta solutie are complexitatea O(M^2*S). Daca se foloseste O(M^2*S) memorie se obtin 70-80 de puncte, iar pentru punctaj maxim este necesara reducerea la O(M^2). Acest lucru poate fi realizat folosind doua matrici, una in care tinem minte daca pentru o anumita pozitie s-a gasit vreo litera pentru care numarul de aparitii nu coincide cu cel dorit, si una in care se efectueaza preprocesarea pentru litera curenta. O alta optimizare, mult mai nesimnificativa, si care nu este necesara pentru 100 de puncte, este renuntarea la verificarea pentru ultima litera, deoarece daca primele 25 de litere s-au potrivit, iar numarul de litere este constant, e clar ca si cea de-a 26-a litera se va\npotrivi.\n\n\n\nLista lui Andrei\n\n(problema usoara clasa a 10-a)\n\nProblema se rezolva folosind programare dinamica. Putem tine o matrice V[1..N][1..26] unde V[i][j] reprezinta numarul de siruri de lungime i ce contin ultima litera j. Incepem completarea matricii in ordine crescatoare a lungimii sirurilor, iar V[i][j] se obtine prin insumarea valorilor V[i-1][k], pentru orice k a.i perechea (k, j) sau (j, k) sa nu se regaseasca in lista. Acest rationament conduce la un algoritm in O(N * Sigma^2), unde Sigma reprezinta marimea alfabetului (in cazul nostru 26).\n\n\n\nCalcul\n\n(problema grea clasa a 10-a, problema medie clasele 11-12)\n\nDeoarece se cer doar ultimele C cifre se va lucra modulo 10^C. Asadar, la primul pas se va calcula A modulo 10^C, adica ne intereseaza doar ultimele C cifre din A.\nO prima solutie pentru a calcula A^1 + A^2 + ... + A^B este de calcula A^i in O(lg i) pentru fiecare i folosind algoritmul clasic de ridicare la o putere in numar logaritmic de pasi (Cormen, capitolul 33). Aceasta solutie ar fi adus doar 20p.\nSuma prezentata este o progresie geometrica clasica, si se poate calcula folosind formula (A^(B+1)-A) / (A-1). Calculul lui A^(B+1) se face folosind acelasi algoritm mentionat mai sus in O(lg B) (lg = logaritm in baza 2). Pentru a efectua impartirea modulo 10^C, trebuie sa existe un invers multiplicativ pentru A-1 , modulo 10^C, lucru garantat doar pentru 50% din teste (cmmdc(A-1, 10^C) = 1). Inversul multiplicativ poate fi calculat folosind algoritmul [2]Euclid extins sau teorema lui Fermat: X^phi(N) = 1 (mod N) pentru cmmdc(X, N) = 1 si phi(N) = indicatorul lui Euler, cate numere < N sunt prime cu N. Din teorema reiese ca X^(phi(N)-1) = X^(-1) (mod N), asadar inversul poate fi calculat algoritmul de ridicare la o putere mentionat mai sus (phi(10^C) poate fi calculat usor). Un caz special la aceasta solutie apare atunci cand A = 1. Aceasta solutie n-ar fi adus decat 50p si necesita cunostiinte de matematica de clasa a 12-a. Exista o solutie mult mai accesibila pentru clasele a 10-a si a 11-a, folosind\nrelatiile:\nS(A,2*B) = S(A,B) * (1+A^B)\nS(A,2*B+1) = A * (1+S(A,2*B))\nCum numarul B este dat in baza 16, parcurgerea bitilor acestuia se face usor, simuland algoritmul de mai sus. Daca A^B se calculeaza la fiecare pas, complexitatea va fi O(lg^2 B), obtinand 60p. O solutie O(lg B) de 100 de puncte se poate obtine calculand in paralel si valorile S(A,B) si A^B. O ultima \"problema\" care ar fi putut exista este faptul ca se cer ultimele C cifre, nu rezultatul modulo 10^C; spre exemplu, daca C = 4 si rezultatul modulo 10^4 ar fi fost \"123\", in fisierul de iesire trebuia afisat \"0123\".\n\n\n\nDistante minime\n\n(problema usoara clasele 11-12)\n\nProblema se rezolva folosind algoritmul lui Dijkstra pornind din nodul 1. Astfel pe langa vectorul D[1..N] in care tinem distantele minime vom mai folosi un vector P[1..N] in care tinem pentru fiecare nod i numarul de drumuri de lungime D[i]. Cand relaxam o muchie vom face update, daca este cazul, atat in vectorul D cat si in vectorul P.\n\nDeoarece costul drumurilor a fost definit ca produs de muchii, in vectorul D putem ajunge sa avem numere cu mii de cifre. O implementare cu numere mari a algoritmului descris mai sus nu este destul de eficienta, ea obtinand aproximativ 75 de puncte. Pentru a obtine punctajul maxim este necesara logaritmarea costului fiecarei muchii intr-o baza oarecare. Astfel putem transforma produsul in suma, folosind o proprietate a logaritmilor, fapt ce duce la o implementare simpla si rapida, folosind doar date de tip double.\n\n\n\nPopandai\n\n(problema grea clasele 11-12)\n\nMai intai vom calcula, pentru fiecare pereche de puncte A si B din punctele ce reprezinta vizuinele, in sirul sub[AB] cate puncte din restul de n se afla sub segmentul de dreapta determinat de A si B. Aceasta preprocesare poate fi efectuata in O(n^2 log n) cu un algoritm inteligent sau poate fi efectuata in O(n^3) cu metoda naiva care verifica pentru fiecare punct daca este situat pe intervalul [A.x, B.x] si este sub dreapta determinata de cele doua puncte. Preprocesare vom putea pentru fiecare triunghi ABC sa aflam in timp O(1) cate puncte are in interior: presupunem fara a restrange generalitatea ca A.x <= B.x <= C.x, daca punctul B e deasupra dreptei AC atunci numarul de puncte din interiorul lui ABC este sub[AB] + sub[BC] - sub[AC], iar daca B este sub dreapta AC atunci numarul de puncte este sub[AC] - sub[AB] - sub[BC] - 1.\n\nOrice patrulater, fie el concav sau convex, are o diagonala interna. Daca fixam un segment PQ ca fiind diagonala interna putem sa incercam sa gasim pentru fiecare x triunghiul PQR de arie minima pentru care punctul R este deasupra dreptei PQ si care contine in interior cel putin x puncte, iar apoi sa gasim un triunghi PQS de arie minima cu varful S sub dreapta PQ ce contine in interior cel putin k-x puncte. Ariile minime ale acestor triunghiuri se pastreaza in doua siruri over si under iar aria minima a unui patrulater cu o diagonala PQ va fi min(over[x] + under[k-x] | unde x ia toate valorile de la 0 la k). Folosind artificiul explicat mai sus putem determina in O(1) numarul de puncte ce se afla in interiorul unui triunghi, si astfel sirurile over si under pot fi calculate in O(n). Complexitatea totala a algoritmului este O(n^3) pentru ca avem O(n^3) calcule in faza de preprocesare si pentru fiecare n(n-1)/2 diagonale vom efectua O(n) calcule.\n\nReferences\n\nVisible links\n1. http://infoarena.devnet.ro/clasament/preoni2006.php\n2. http://info.devnet.ro/articole.php?page=art&art=26\n\n',0,''),('summer-challenge-unu/solutii','Solutii - Summer Challenge Unu','2006-08-03 00:00:00','h1. Solutii - Summer Challenge Unu\n\n(Creat de \'_Cosmin_\':user/Cosmin la data de _2006-08-03_ categoria __, autor(i) _Cosmin_)\n\n*Continut scurt:*\n Concursul a fost unul reusit, adunand un numar respectabil de concurenti.\n\nVa multumim pentru participare!\n\nVa invitam mai departe sa va uitati peste schitele solutiilor problemelor propuse.\n\n\n*Continut lung:*\nConcursul a fost unul reusit, adunand un numar respectabil de participanti.\n\nConcurentii ce vor participa la IOI au fost in forma azi ocupand primele trei pozitii ale clasamentului. greco a impresionat placut fiind singurul ce a rezolvat perfect problema de idee a concursului. Il remarcam pozitiv si pe wefgef care se tine aproape de ei, de asemenea o remarca negativa ar fi la adresa lui Adrian Vladu care nu a participat la aceasta pregatire ,desi ea a fost adresata direct lotului olimpic.\n\nUrmeaza primii 10 clasati:\n\n\n|1 |greco |Florea Tiberiu |300p |\n\n|2 |domino |Mircea Pasoi |240p |\n\n|3 |Ragnar_Lodbrok |Grosu Codrut |234p |\n\n|4 |wefgef |Andrei Grigorean |220p |\n\n|5 |PaulDB |Paul-Dan Baltescu |200p |\n\n|6 |CommanderK |Andrei Homescu |180p |\n\n|7 |andrei_blanaru |Blanaru Andrei |150p |\n\n|8 |adal |Lica Adela |140p |\n\n|9 |Marius |Marius Stroe |130p |\n\n|10 |Bogdan2412 |Bogdan Tataroiu |130p |\n\n\nVa invitam mai departe sa va uitati peste schitele solutiilor problemelor propuse.\n\nFree\n\nAceasta problema a fost considerata cea mai simpla din concurs, in special pentru ca realizarea unui program experimental care simula pasii din problema ne arata ca usile ce raman inchise au ca index un patrat perfect.\n\nPentru a demonstra aceasta afirmatie avem nevie de cateva cunostinte minore de teoria numerelor.\n\nLa fiecare pas i directorul va vizita toti multiplii lui i, ceea ce inseamna ca un anumit numar X va fi vizitat la pasii ai caror indecsi il divid pe X. Deci pentru a afla cate usi vor fi deschise in final va trebui sa numaram cate numere au un numar par de divizori. Pentru acest lucru ne va si mai usor sa numaram cate au un numar impar de divizori urmand sa le scadem din N. Stim ca daca descompunem un numar X in factori primi: X=F[1]^P[1]*F[2]^P[2]*..*F[t]^P[t] numarul de divizori ai sai va fi D=(P[1]+1)*(P[2]+1)*..*(P[t]+1). Pentru ca D sa fie impar trebuie ca fiecare factor al produsului sa fie deci P[i]+1 impar ceea ce inseamna ca exponentii factorilor primi din descompunere vor fi pari.X=F[1]^2*P\'[1]*F[2]^2*P\'[2]*..F[t]^2*P\'[t] = (F[1]^P\'[1]*F[2]^P\'[2]*..*F[t]^P\'[t])^2. Inseamna ca X va fi patrat pefrect.\n\nAlta demonstratie mai intuitiva ar fi ca pentru usa X putem imperechea actiunea i cu actiunea X/i daca i este divizor al lui X si astfel cele doua isi anuleaza efectul. Daca X este patrat perfect atunci actiunea [sqrt(X)] ramane neimperecheata, deci usa ramane deschisa.\n\nAstfel solutia problemei va fi N-[sqrt(N)].\n\nOperatiile trebuie implementate pe numere mari. Operatia radical se poate implementa folosind o cautare binara.\n\nPatrol\n\nAceasta problema a fost considerata una medie, pentru ca algoritmii de drum minim in grafuri sunt foarte frecvent folositi la concursurile de programare.\n\nObsevam ca fiecare paznic va fi la orasul de unde a pornit la timpii multipli de 2*(l[i]-1) (din cauza miscarii dute-vino). Astfel toti paznicii vor fi in acelasi timp la orasul initial al fiecaruia la toti timpii multipli de cmmmc(2*(l[1]-1), 2*(l[2]-1), ..., 2*(l[n]-1)). Din cauza ca l[i] < 8 cel mai mic multiplu comun maxim posibil al numerelor din problema poate fi cmmmc(2*4, 2*3, 2*5) = 120, astfel pozitiile paznicilor pe reteaua noastra de orase cicleaza si perioada ciclului este 120 sau un divizor al sau. Vom crea un graf in care nodurile sunt stari ale problemei (oras, timp % 120). Acum am redus problema la determinarea drumului de cost minim de la (1, 0) la (N, timp % 120), putem folosi un algoritm de drum minim la alegere Dijkstra cu heapuri sau bellman ford.\n\nPscpld\n\nAceasta problema se vroia a fi cea mai grea din concurs. O solutie bazata pe siruri de sufixe poate fi gasita in articolul \"Siruri de sufixe\" Adrian Vladu, Negruseri Cosmin, GInfo. Aceasta rezolvare nu ar fi luat punctaj maxim, o solutie similara in O(n) foloseste arbori de sufixe. Denumirea problemei a fost aleasa pentru a sugera ca rezolvarea greoaie cu arbori de sufixe nu este cea cautata. Problema are o solutie simpla in O(n) care urmeaza ideea rezolvarii in O(n^2).\n\nIn rezolvarea brute force fixam un centru pentru un palindrom si incercam sa marim palindromul cat mai mult. Solutia va pastra un sir LUNG unde LUNG[2i - 1] reprezinta lungimea palindromului maxim centrat in caracterul i al sirului si LUNG[2i] lungimea palindromului centrat intre caracterul i si i + 1 al sirului. Vom parcurge sirul de caractere de la stanga la dreapta si vom afla in ordine valorile din sirul LUNG.\nSa luam un exemplu:\n\nsirul: a b a a b a c\n\nLUNG: 1 0 3 0 1 6 1 0 x\n\nindice: 1 2 3 4 5 6 7 8 9 10 11 12 13\n\nAcum daca vrem sa calculam LUNG[9] ar trebui sa ne extindem cat putem in lateral fata de b, dar observam ca centrul palindromului curent este continut in palindromul centrat la 6. Din faptul ca palindromul contine doua subsecvente oglindite, noi nu trebuie sa mai iteram prin literele palindromului nostru pentru ca avem deja rezolvata problema oglindita, si continuam comparatiile cu caractere noi (in cazul nostru avem deja rezolvata problema a b a in secventa [1..5] si nu mai trebuie sa o rezolvam inca o data). Am obtinut astfel o rezolvare simpla de complexitate O(N). Mentionam ca sursa oficiala nu are mai mult de 50 de linii.\n\nExista si alte rezolvari optime posibile si ii rugam pe cei care au luat 100 de puncte sa le explice in cadrul forumului.\n\n',0,''),('warm-up-2006/solutii','Solutii Autumn WarmUp 2006','2006-09-07 00:00:00','h1. Solutii Autumn WarmUp 2006\n\n(Creat de \'_filipb_\':user/filipb la data de _2006-09-07_ categoria _Competitii_, autor(i) _Echipa Info-arena_)\n\n*Continut scurt:*\n Articolul contine ideile de rezolvare a celor 5 probleme propuse spre rezolvare in concursul Autumn WarmUp 2006, concurs organizat in intregime de 5 dintre utilizatorii info-arena.\n\n\n*Continut lung:*\nAici puteti gasi solutiile oficiale la cele 5 probleme propuse in concurs. De precizat si ca aceasta initiativa info-arena a fost un succes, adunand un numar respectabil de participanti. Punctajele au fost mai mici decat cele asteptate, fapt ce a confirmat ca setul de probleme a fost unul capabil sa puna in dificultate nume cunoscute la olimpiadele de informatica. Iata si solutiile:\n\n\npoly\n\nProblema este una de programare dinamica si are complexitatea O(N), de constanta 2^7 = 128. Sa notam cu M[i][j] lungimea celui mai lung subsir utilizand primele i numere din vector astfel incat ultimul element din subsirul optim sa aiba ca divizori numerele din multimea data corespunzatoare bitilor de 1 din j. Mai intai M[i][j] = M[i-1][j] ( nu folosim numarul al i-lea ). Daca dorim sa folosim si numarul al i-lea, atunci M[i][config] = maxim(M[i][config], M[i-1][k] + 1), cu k and config = 0, unde config are bitii de 1 corespunzatori numerelor din multimea data cu care se divide acest al i-lea numar din sirul initial. Conditia k and config ne asigura ca penultimul si ultimul numar din subsir nu au amandoua vreun divizor comun din multimea data ( operatia and in acest context este o operatie pe biti ). Rezultatul va fi max(M[n][0], M[n][1]... M[n][127]). Memoria folosita poate fi O(1), retinand doar ultimele doua linii ale matricii.\n\nUn algoritm de complexitate patratica in N folosind tot programarea dinamica ar fi obtinut 30-40 de puncte.\n\nbridge\n\nUn algoritm de complexitate O(M + N * K) folosind programarea dinamica nu este foarte greu de gasit. Daca notam cu M[i][j] numarul de moduri ( modulo 666013 ) de a ajunge in i pasi pe scandura j din pozitia initiala, atunci mai trebuie avut grija doar la relatiile de recurenta. In cazul de fata vom utiliza metoda inainte si vom trata cazurile: daca scandura j este lipsa atunci M[i][j] = 0, daca scandura j este teleportoare incrementam M[i+1][unde[j]] cu M[i][j] daca si numai daca unde[j] nu este lipsa sau subreda ( unde[j] este destinatia teleportarii de pe scandura j ),daca j este scandura buna, incrementam M[i+1][j+1] cu M[i][j] si M[i+1][j+2] cu M[i][j] doar daca j+2 nu e lipsa sau subreda, etc.\n\nAvand construita matricea M, pentru fiecare query putem raspunde acum in O(1). Exista diferite optimizari care pot fi facute si care sporesc substantial timpul de executie.\n\n\nsecv4\n\nDeoarece logaritmul unui produs de numere este egal cu suma logaritmilor fiecarui numar din produs, si in ipoteza ca toate numerele din sir sunt pozitive, logaritmam fiecare numar si notam cu S[i] suma primilor i logaritmi. Astfel, pentru a afla secventa de produs maxim care se termina pe pozitia i, este suficient sa determinam, pentru k intre i-y si i-x care este S[k] minim ( astfel, S[i] - S[k] va fi maxim, deci si produsul maxim, iar secventa va incepe pe pozitia k+1). Putem folosi un arbore de intervale si obtinem un algoritm O(NlogN), sau o coada prin care scoatem elementele prin ambele parti ( structura de date numita deque - double ended queue ), obtinand complexitatea O(N). Daca exista si numere negative, in momentul logaritmarii numerelor negative logaritmam opusul lor. Aplicand procedeul descris mai sus, stim sigur la final ca produsul obtinut are modulul maxim. Pentru a fi cu adevarat maxim ( deci pozitiv ), notam cu semn[i] semnul produsului primelor i numere. Ca secventa <j+1, i> sa aiba\nprodus maxim trebuie in plus semn[i] = semn[j]. Vom retine doua deque-uri, una pentru + si una pt -, conform vectorului semn. Astfel, in final, suntem siguri ca produsul are semnul + si, cum are si modulul maxim, are valoarea maxima ceruta.\n\n\n\nparcare\n\nProblema este exponentiala in dimensiunea matricii, dar polinomiala in numarul total de posibilitati de pozitionare al masinilor. Astfel, vom folosi un algoritm de tip BFS care garanteaza ca se ajunge la solutie intr-un numar minim de miscari. Plecam de la matricea initiala, si expandam pe rand toate starile posibile, miscand din starea curenta cate o masina pana cand nu mai exista nici o varianta noua de pozitionare a masinilor sau pana cand am scos masina A din parcare. Starile problemei le putem codifica intr-un intreg de 64 de biti. Singurele variabile sunt pozitiile masinilor. Dupa ce eliminam zidurile inconjuratoare, coordonatele nu sunt mai mari decat 7 ( 3 biti ), deci pentru pozitia unei masini vom folosi 6 biti. Concatenam pozitiile masinilor si, cum sunt maxim 10 masini, codificarea nu va avea mai mult de 60 de biti.\n\nPentru a memora starile explorate vom folosi o tabela de hash. De precizat si ca numarul total de posibilitati pornind de la starea initiala este destul de redus, deci problema va rula aproape instantaneu.\n\n\n\neasy query\n\nUn algoritm simplu de complexitate O(N*M) obtine 30-50 de puncte. Algoritmul de 100 de puncte are complexitatea O(MlogN) si foloseste arbori de intervale. Considerand o secventa x[i] x[i+1]... x[j] este evident ca pentru ca elementele sirurilor y si z sa fie maxime, respectiv minime, ele trebuiesc construite astfel:\n\ny[t] = x[t] - min(x[k]) + max(x[p]), i <= t <= j, t <= k, p <= j\n\nz[t] = x[t] - max(x[k]) + min(x[p]), i <= t <= j, t <= k, p <= j.\n\nPentru a calcula in timp optim valoarea P = max(y) + min(z) ne vom folosi de un arbore de intervale in urmatorul mod: fiecare nod al acestuia va constitui o secventa x[st], x[st+1]... x[dr] ( unde st si dr sunt marginile intervalului din nodul arborelui ) pe care o vom rezolva prin metoda brute force de la inceput, avand grija sa precalculam si alte valori necesare mai tarziu, cum ar fi :\n\nmin = minim(x[st], x[st+1]... x[dr])\n\nmax = maxim(x[st], x[st+1]... x[dr])\n\nx_max_max = maxim(x[t] + maxim(x[p]) ),\n\nst <= t <= dr si t <= p <= dr\n\nx_max_min = minim(x[t] - maxim(x[p]) ),\n\nst <= t <= dr si t <= p <= dr\n\nx_min_max = maxim(x[t] - minim(x[p]) ),\n\nst <= t <= dr si t <= p <= dr\n\nx_min_min = minim(x[t] + minim(x[p]) ),\n\nst <= t <= dr si t <= p <= dr\n\ny_max = maximul din sirul y corespunzator secventei x[st], x[st+1]... x[dr]\n\nz_min = minimul din sirul z corespunzator secventei x[st], x[st+1]... x[dr]\n\nAvand precalculate valorile de mai sus pentru fiecare nod al arborelui in parte vom putea raspunde in timp O(logN) pentru fiecare din cele M intrebari. Fiecare subsecventa data x[i], x[i+1]... x[j] va putea fi compusa din reuniunea mai multor noduri din arborele de intervale. Acum parcurgem nodurile ce compun subsecventa data de la dreapta la stanga si vom gasi rapid valorile maxim(y) si minim(z). Presupunand ca am ajuns la nodul Q valoarea maxim(y) pana aici se calculeaza astfel:\n\nMAX(Y) = y_max(Q) = y_max_max(Q) - min(W) = x_min_max(Q)+max(W) = max(Q)+max(W)-min(W).\n\nAnalog se calculeaza si minim(z).\n\n',0,''),('articole','Articole','2006-11-05 23:22:34','h1. Articole\n\n* \'12 ponturi pentru programatorii C/C++\':12_ponturi_pentru_programatorii_CC\n* \'LCA: Lowest common ancestor\':LCA_Lowest_common_ancestor\n* \'Ciclu hamiltonian in graf dens\':Ciclu_hamiltonian_in_graf_dens\n* \'Multe &quot;smenuri&quot; de programare in C/C++... si nu numai!\':Multe_smenuri_de_programare_in_CC_si_nu_numai\n* \'Aplicatii ale cautarii binare\':Aplicatii_ale_cautarii_binare\n* \'Solutiile oficiale pentru Concursul &quot;de incalzire&quot;\':Solutiile_oficiale_pentru_Concursul_de_incalzire\n* \'Algoritmul lui Euclid\':Algoritmul_lui_Euclid\n* \'Hashing\':Hashing\n* \'The Monty Hall Problem\':The_Monty_Hall_Problem\n* \'Automate finite si KMP\':Automate_finite_si_KMP\n* \'Ciurul lui Erathostene\':Ciurul_lui_Erathostene\n* \'Concursul Agora - Etapa Finala - Solutii\':Concursul_Agora_Etapa_Finala_Solutii\n* \'Al K-lea drum minim\':Al_K_lea_drum_minim\n* \'STL\':STL\n* \'USACO decembrie 2004, divizia GOLD - idei de solutii\':USACO_decembrie_2004_divizia_GOLD_idei_de_solutii\n* \'Doua probleme de la runda 6 a concursului Algoritmus\':Doua_probleme_de_la_runda_6_a_concursului_Algoritmus\n* \'preONI 2005 runda #1 - solutii\':preONI_2005_runda_1_solutii\n* \'Usaco ianuarie 2005, divizia GOLD\':Usaco_ianuarie_2005_divizia_GOLD\n* \'Skiplists\':Skiplists\n* \'preONI 2005 runda #2 - solutii\':preONI_2005_runda_2_solutii\n* \'preONI 2005 runda #3 - solutii\':preONI_2005_runda_3_solutii\n* \'F.A.Q. Pregatire bacalaureat 2005\':FAQ_Pregatire_bacalaureat_2005\n* \'Introducere in asamblare\':Introducere_in_asamblare\n* \'USACO oct 2005, divizia GOLD\':USACO_oct_2005_divizia_GOLD\n* \'Solutii preONI 2006 - Runda 1\':Solutii_preONI_2006_Runda_1\n* \'USACO nov 2005, divizia GOLD\':USACO_nov_2005_divizia_GOLD\n* \'Solutii preONI 2006 - Runda a 2-a\':Solutii_preONI_2006_Runda_a_2_a\n* \'USACO dec 2005, divizia GOLD\':USACO_dec_2005_divizia_GOLD\n* \'Solutii preONI 2006 - Runda a 3-a\':Solutii_preONI_2006_Runda_a_3_a\n* \'Solutii preONI 2006, Runda a 4-a\':Solutii_preONI_2006_Runda_a_4_a\n* \'DJGPP - instalarea de la A la Z\':DJGPP_instalarea_de_la_A_la_Z\n* \'Solutii preONI 2006, Runda finala\':Solutii_preONI_2006_Runda_finala\n* \'Solutii - Summer Challenge Unu\':Solutii_Summer_Challenge_Unu\n* \'Solutii - Summer Challenge Doi\':Solutii_Summer_Challenge_Doi\n* \'Solutii - Summer Challenge Trei\':Solutii_Summer_Challenge_Trei\n* \'Solutii Autumn WarmUp 2006\':Solutii_Autumn_WarmUp_2006\n',0,''),('problema/itree','itree','2006-11-11 11:23:59','== include(page=\"template/taskheader\" task_id=\"itree\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| itree.in | itree.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"itree\") ==\r\n',0,''),('problema/rf','rf','2006-11-11 11:23:59','== include(page=\"template/taskheader\" task_id=\"rf\") ==\r\n\r\nPoveste ...\r\n\r\nh2. Cerinta\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Exemplu\r\n\r\n| rf.in | rf.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"rf\") ==\r\n',0,''),('12-ponturi-pentru-programatorii-cc','12 ponturi pentru programatorii C/C++','2004-11-08 00:00:00','h1. 12 ponturi pentru programatorii C/C++\n\n(Creat de \'_domino_\':user/domino la data de _2004-11-08_ categoria _Limbaje_, autor(i) _Alexandru Mosoi_)\n\n*Continut scurt:*\n In urmatoarele cateva randuri am sa incerc sa va arat cateva metode de a scrie.... mai bine. Cea mai mare parte este pentru programatorii C.\n\nInainte ati putea citi si \"Documentation/CodingStyle\" aflat in sursa de kernel a Linux-ului. Scuzati-ma daca ma inspir putin. Manualul gcc este si el binevenit.\n==Include(page=\"template/raw\")==\n\nIn urmatoarele cateva randuri am sa incerc sa va arat cateva metode de a scrie.... mai bine. Cea mai mare parte este pentru programatorii C.\n\nInainte ati putea citi si \"Documentation/CodingStyle\" aflat in sursa de kernel a Linux-ului. Scuzati-ma daca ma inspir putin. Manualul gcc este si el binevenit.\n\n\n*Continut lung:*\nIn urmatoarele cateva randuri am sa incerc sa va arat cateva metode de a scrie.... mai bine. Cea mai mare parte este pentru programatorii C.\n\nInainte ati putea citi si \"Documentation/CodingStyle\" aflat in sursa de kernel a Linux-ului. Scuzati-ma daca ma inspir putin. Manualul gcc este si el binevenit.\n\n0\n\nPrefer C in loc de C++: e mai robust putin ceea ce ma fereste cateodata de greseli. Incercati sa nu folositi un IDE cu debugging inclus (cum ar fi RHIDE sau Borland C++ 3.1). La inceput o sa va vina greu, dar va obisnuiti... si deveniti mai atenti cand scrieti surse. Puteti sa folositi Kate, un editor de text asemanator lui EditPlus de sub Windows. Vim este deasemenea un editor foarte puternic, dar pentru cine stie sa-l foloseasca.\n\n1\n\nImpartiti programul dumneavoastra in functii, fiecare sa nu depaseasca mai mult de 30-50 de linii (aproximativ 2 ecrane ANSI 80x25). Este important sa aveti mereu o viziune asupra intregii functii. Regula este: complexitatea unei functii trebuie sa fie invers proportionala cu lungimea ei. Puteti sa declarati functiile \"inline\" (nu pe toate !) pentru a nu pierde din viteza.\n\n2\n\nMacro-urile nu le recomand. Daca le folositi ca functii aveti grija. Unul dintre colegii mei de la lot a pierdut multe puncte pentru ceva asemanator.\n\n#define MAX(a, b) ((a) < (b) ? (b) : (a))\n\n\n\nint query(int a, int b)\n{\nint k, l, r;\n\n....\nres = MAX(k, query(l, r));\n....\n\nreturn res;\n}\n\nDaca observati, exista cazuri cand query(l, r) era apelata de 2 ori, ceea ce nu se doreste. In schimb, putea sa declare MAX ca o functie inline.\n\ninline int MAX(int a, int b)\n{\nif(a > b) return a;\nreturn b;\n}\n\n3\n\nCand accesati un element din memorie, procesorul citeste de fapt 32 bytes (sau cat de mare e linia de cache, dar o putere a lui 2). Recomand ca structurile voastre sa aiba de asemenea ca dimensiune o putere a lui 2 pentru a nu forta procesorul sa citeasca de 2 ori. O extensie GNU a standardului ANSI C sunt atributele. Pentru structuri, una din cele mai folosite (de mine) este packed ce instruieste compilatorul se nu mai adauge \"padding bytes\".\n\nstruct foo { int a; char b; int c; };\n/* sizeof(struct foo) == 12 */\nstruct bla { int a; char b; int c; }\n\n__attribute__((packed));\n/* sizeof(struct bla) == 9 */\n\nPentru mai multe informatii executati consultati manualul gcc. (\"info gcc\").\n\na\n\nDe asemenea, e bine sa nu spargeti aceasta line de cache prea des. Uitati un exemplu:\n\n#define maxN 1000\n#define maxM 1000\n\n\n\nint t[maxN][maxM];\n\nint f(void)\n{\nint i, j;\nint s = 0;\nfor(i = 0; i < maxM; ++ i)\nfor(j = 0; j < maxN; ++ j)\ns += t[j][i];\nreturn s;\n}\n\nPentru 1024 de apelari, pe calculatorul meu, acesta functie consuma cam 18.85s. In schimb, daca as fi scris\n\nfor(i = 0; i < maxN; ++ i)\nfor(j = 0; j < maxM; ++ j)\ns += t[i][j];\n\n... functia s-ar fi executat de ~3 ori mai repede (doar 6.05s) iar rezultatul era acelasi. De ce? pentru ca in primul caz la fiecare accesare a t[j][i] procesorul era nevoit sa acceseze memoria, iar in cazul al doilea cand citea t[i][j], erau citite de fapt si t[i][j+1], t[i][j+2], t[i][j+3]. Si sa nu uitam viteza memoriei este mult mai mica decat cea a procesorului.\n\n\n\n4\n\nVariabilele globale sa nu fie folosite in scop local. Daca as modifica functia astfel\n\nint i, j;\n\nint f(void)\n{\nint s = 0;\nfor(i = 0; i < maxM; ++ i)\nfor(j = 0; j < maxN; ++ j)\ns += t[i][j];\n}\n\n... timpul de executie s-ar fi marit la 6.44s. Nu e prea mult... dar se aduna.\n\n5\n\nStack-ul (locul unde se pastreaza toate variabilele locale) este foarte rapid. Modificam acelasi program astfel:\n\n#define maxN 1000\n#define maxM 1000\n\nint main(void)\n{\nint i, j, k;\nint N, M, t[maxN][maxM];\n\nN = maxN; M = maxM;\n\n\n\nfor(k = 0; k < 1024; ++ k) {\nint s;\nfor(i = 0; i < N; ++ i)\nfor(j = 0; j < M; ++ j)\ns += t[i][j];\n}\n\n\n\nreturn 0;\n}\n\nIgnorand faptul ca t nu este initializat (e doar un program de test, nici inainte nu era :D) timpul de executie scade la 1.2s, Wow! Insa aveti grija sa nu o luati pe urmele lui Silviu: sizeof(t) ~= 4Mb care e mult peste limita de 1Mb ce se impune de obicei in concursuri (si asta daca folositi gcc). Cel mai probabil veti primi \"Killed by signal 11\".\n\na\n\n++ i e preferabil i ++ (unde nu complica lucrurile).\n\nb\n\nNu va feriti sa folositi \"const\" si \"static\". \"Const\" chiar poate sa faca diferenta ca timp si vizibilitate.\n\nc\n\nUtilizati si literele mari pentru anumite variabile mai importante (poate si macro-uri).\n\n\n\n7\n\nO alta extensie GNU sunt \"zero-length arrays\". Se folosesc in general la skiplist-uri pentru a declara un array de dimensiune variabila intr-o structura.\n\ntypedef struct bla bla;\n\nstruct bla {\nint levels;\nbla *next[0];\n};\n\n...\n\nbla *temp = (bla *)malloc(sizeof(bla)\n\n+ no_levels*sizeof(bla *));\n\n8\n\na\n\nFolositi-va de utilitarele puse la dispozitie de sistemul de operare (linux in cazul meu). RTFM :)\n\n* bc - pentru calcule cu numere cu precizie multipla (eg. 2^1024).\n* octave - pentru calcule matematice mai complicate.\n* gprof - determina cat timp a necesitat executia fiecarei functii sau linii.\n* gcov - determina de cateori a fost apelata o anumita linie.\n* time - pentru aflarea timpului executiei unui program.\n* factor - descompune in factori un numar (eg. factor 666).\n* splint - o versiune free a programului lint: va da foarte multe warning-uri.\n* bash - putin scripting\n\nb\n\nCompilati-va sursele cu -W -Wall (tot pentru warning-uri)\n\nc\n\nGeneratorul de teste si sursa dumneavoastra trebuie sa fie doua programe diferite !\n\nd\n\nPentru debugging folositi fprintf(stderr, ...). Daca se intampla sa uitati, macar nu primiti \"wrong answer\" din cauza unui printf.\n\n9\n\na\n\nint t[666];\n\n\n\n/* toate elementele lui t vor fi -1 */\n\nmemset(t, 0xff, sizeof(t));\n\nb\n\nPentru valoarea infinit folosesc o constanta\n\n#define INFI 0x3f3f3f3f\n\ndin mai multe motive:\n\n* INFI + INFI ramane pozitiv\n* in general e destul de mare\n\n/* toate elementele lui t devin INFI */\n\nmemset(t, 0x3f, sizeof(t));\n\nc\n\nDaca avem de comparat doua siruri (s1, s2) a caror lungime o stim (len_s1, respectiv len_s2) este mai rapid\n\nmemcmp(s1, s2, MIN(len_s1, len_s2)+1)\n\ndecat\n\nstrcmp(s1, s2);\n\nd\n\nscanf(\" %c\", &ch) citeste primul caracter dupa spatiile albe (daca exista).\n\n\n\n10\n\nDaca programati in C++ fara sa folositi STL incercati sa renuntati la C++. Unul dintre motive: clasele (implicit iostream: cin, cout, cerr) incetinesc mult executia programului.\n\n11\n\nIn final, o intrebare pentru cei ce folosesc C++ (asta e un hint). Cum se calculeaza factorial la compilare? (fara a scrie efectiv 1*2*3...*n)\n\nRaspuns\n\nUtilizand templaturi. Avem nevoie doar de o constanta N.\n\n#include <stdio.h>\n\n\n\ntemplate<int N>\n\nstruct Factorial {\nenum {\n\nvalue = Factorial<N-1>::value * N\n\n};\n};\n\n\n\ntemplate<>\nstruct Factorial<0> {\nenum { value = 1 };\n};\n\n\n\nint main(void)\n{\nint i = Factorial<4>::value;\nchar c[Factorial<5>::value];\n\nprintf(\"%d \",i);\nprintf(\"%d \",sizeof(c));\n}\n\nPS: nu dau $2.56 pentru fiecare greseala descoperita in acest articol.\n==Include(page=\"template/raw\")==\n\nIn urmatoarele cateva randuri am sa incerc sa va arat cateva metode de a scrie.... mai bine. Cea mai mare parte este pentru programatorii C.\n\nInainte ati putea citi si \"Documentation/CodingStyle\" aflat in sursa de kernel a Linux-ului. Scuzati-ma daca ma inspir putin. Manualul gcc este si el binevenit.\n\n0\n\nPrefer C in loc de C++: e mai robust putin ceea ce ma fereste cateodata de greseli. Incercati sa nu folositi un IDE cu debugging inclus (cum ar fi RHIDE sau Borland C++ 3.1). La inceput o sa va vina greu, dar va obisnuiti... si deveniti mai atenti cand scrieti surse. Puteti sa folositi Kate, un editor de text asemanator lui EditPlus de sub Windows. Vim este deasemenea un editor foarte puternic, dar pentru cine stie sa-l foloseasca.\n\n1\n\nImpartiti programul dumneavoastra in functii, fiecare sa nu depaseasca mai mult de 30-50 de linii (aproximativ 2 ecrane ANSI 80x25). Este important sa aveti mereu o viziune asupra intregii functii. Regula este: complexitatea unei functii trebuie sa fie invers proportionala cu lungimea ei. Puteti sa declarati functiile \"inline\" (nu pe toate !) pentru a nu pierde din viteza.\n\n2\n\nMacro-urile nu le recomand. Daca le folositi ca functii aveti grija. Unul dintre colegii mei de la lot a pierdut multe puncte pentru ceva asemanator.\n\n#define MAX(a, b) ((a) < (b) ? (b) : (a))\n\n\n\nint query(int a, int b)\n{\nint k, l, r;\n\n....\nres = MAX(k, query(l, r));\n....\n\nreturn res;\n}\n\nDaca observati, exista cazuri cand query(l, r) era apelata de 2 ori, ceea ce nu se doreste. In schimb, putea sa declare MAX ca o functie inline.\n\ninline int MAX(int a, int b)\n{\nif(a > b) return a;\nreturn b;\n}\n\n3\n\nCand accesati un element din memorie, procesorul citeste de fapt 32 bytes (sau cat de mare e linia de cache, dar o putere a lui 2). Recomand ca structurile voastre sa aiba de asemenea ca dimensiune o putere a lui 2 pentru a nu forta procesorul sa citeasca de 2 ori. O extensie GNU a standardului ANSI C sunt atributele. Pentru structuri, una din cele mai folosite (de mine) este packed ce instruieste compilatorul se nu mai adauge \"padding bytes\".\n\nstruct foo { int a; char b; int c; };\n/* sizeof(struct foo) == 12 */\nstruct bla { int a; char b; int c; }\n\n__attribute__((packed));\n/* sizeof(struct bla) == 9 */\n\nPentru mai multe informatii executati consultati manualul gcc. (\"info gcc\").\n\na\n\nDe asemenea, e bine sa nu spargeti aceasta line de cache prea des. Uitati un exemplu:\n\n#define maxN 1000\n#define maxM 1000\n\n\n\nint t[maxN][maxM];\n\nint f(void)\n{\nint i, j;\nint s = 0;\nfor(i = 0; i < maxM; ++ i)\nfor(j = 0; j < maxN; ++ j)\ns += t[j][i];\nreturn s;\n}\n\nPentru 1024 de apelari, pe calculatorul meu, acesta functie consuma cam 18.85s. In schimb, daca as fi scris\n\nfor(i = 0; i < maxN; ++ i)\nfor(j = 0; j < maxM; ++ j)\ns += t[i][j];\n\n... functia s-ar fi executat de ~3 ori mai repede (doar 6.05s) iar rezultatul era acelasi. De ce? pentru ca in primul caz la fiecare accesare a t[j][i] procesorul era nevoit sa acceseze memoria, iar in cazul al doilea cand citea t[i][j], erau citite de fapt si t[i][j+1], t[i][j+2], t[i][j+3]. Si sa nu uitam viteza memoriei este mult mai mica decat cea a procesorului.\n\n\n\n4\n\nVariabilele globale sa nu fie folosite in scop local. Daca as modifica functia astfel\n\nint i, j;\n\nint f(void)\n{\nint s = 0;\nfor(i = 0; i < maxM; ++ i)\nfor(j = 0; j < maxN; ++ j)\ns += t[i][j];\n}\n\n... timpul de executie s-ar fi marit la 6.44s. Nu e prea mult... dar se aduna.\n\n5\n\nStack-ul (locul unde se pastreaza toate variabilele locale) este foarte rapid. Modificam acelasi program astfel:\n\n#define maxN 1000\n#define maxM 1000\n\nint main(void)\n{\nint i, j, k;\nint N, M, t[maxN][maxM];\n\nN = maxN; M = maxM;\n\n\n\nfor(k = 0; k < 1024; ++ k) {\nint s;\nfor(i = 0; i < N; ++ i)\nfor(j = 0; j < M; ++ j)\ns += t[i][j];\n}\n\n\n\nreturn 0;\n}\n\nIgnorand faptul ca t nu este initializat (e doar un program de test, nici inainte nu era :D) timpul de executie scade la 1.2s, Wow! Insa aveti grija sa nu o luati pe urmele lui Silviu: sizeof(t) ~= 4Mb care e mult peste limita de 1Mb ce se impune de obicei in concursuri (si asta daca folositi gcc). Cel mai probabil veti primi \"Killed by signal 11\".\n\na\n\n++ i e preferabil i ++ (unde nu complica lucrurile).\n\nb\n\nNu va feriti sa folositi \"const\" si \"static\". \"Const\" chiar poate sa faca diferenta ca timp si vizibilitate.\n\nc\n\nUtilizati si literele mari pentru anumite variabile mai importante (poate si macro-uri).\n\n\n\n7\n\nO alta extensie GNU sunt \"zero-length arrays\". Se folosesc in general la skiplist-uri pentru a declara un array de dimensiune variabila intr-o structura.\n\ntypedef struct bla bla;\n\nstruct bla {\nint levels;\nbla *next[0];\n};\n\n...\n\nbla *temp = (bla *)malloc(sizeof(bla)\n\n+ no_levels*sizeof(bla *));\n\n8\n\na\n\nFolositi-va de utilitarele puse la dispozitie de sistemul de operare (linux in cazul meu). RTFM :)\n\n* bc - pentru calcule cu numere cu precizie multipla (eg. 2^1024).\n* octave - pentru calcule matematice mai complicate.\n* gprof - determina cat timp a necesitat executia fiecarei functii sau linii.\n* gcov - determina de cateori a fost apelata o anumita linie.\n* time - pentru aflarea timpului executiei unui program.\n* factor - descompune in factori un numar (eg. factor 666).\n* splint - o versiune free a programului lint: va da foarte multe warning-uri.\n* bash - putin scripting\n\nb\n\nCompilati-va sursele cu -W -Wall (tot pentru warning-uri)\n\nc\n\nGeneratorul de teste si sursa dumneavoastra trebuie sa fie doua programe diferite !\n\nd\n\nPentru debugging folositi fprintf(stderr, ...). Daca se intampla sa uitati, macar nu primiti \"wrong answer\" din cauza unui printf.\n\n9\n\na\n\nint t[666];\n\n\n\n/* toate elementele lui t vor fi -1 */\n\nmemset(t, 0xff, sizeof(t));\n\nb\n\nPentru valoarea infinit folosesc o constanta\n\n#define INFI 0x3f3f3f3f\n\ndin mai multe motive:\n\n* INFI + INFI ramane pozitiv\n* in general e destul de mare\n\n/* toate elementele lui t devin INFI */\n\nmemset(t, 0x3f, sizeof(t));\n\nc\n\nDaca avem de comparat doua siruri (s1, s2) a caror lungime o stim (len_s1, respectiv len_s2) este mai rapid\n\nmemcmp(s1, s2, MIN(len_s1, len_s2)+1)\n\ndecat\n\nstrcmp(s1, s2);\n\nd\n\nscanf(\" %c\", &ch) citeste primul caracter dupa spatiile albe (daca exista).\n\n\n\n10\n\nDaca programati in C++ fara sa folositi STL incercati sa renuntati la C++. Unul dintre motive: clasele (implicit iostream: cin, cout, cerr) incetinesc mult executia programului.\n\n11\n\nIn final, o intrebare pentru cei ce folosesc C++ (asta e un hint). Cum se calculeaza factorial la compilare? (fara a scrie efectiv 1*2*3...*n)\n\nRaspuns\n\nUtilizand templaturi. Avem nevoie doar de o constanta N.\n\n#include <stdio.h>\n\n\n\ntemplate<int N>\n\nstruct Factorial {\nenum {\n\nvalue = Factorial<N-1>::value * N\n\n};\n};\n\n\n\ntemplate<>\nstruct Factorial<0> {\nenum { value = 1 };\n};\n\n\n\nint main(void)\n{\nint i = Factorial<4>::value;\nchar c[Factorial<5>::value];\n\nprintf(\"%d \",i);\nprintf(\"%d \",sizeof(c));\n}\n\nPS: nu dau $2.56 pentru fiecare greseala descoperita in acest articol.\n\n',0,''),('automate-finite-si-kmp','Automate finite si KMP','2005-01-12 00:00:00','h1. Automate finite si KMP\n\n(Creat de \'_azotlichid_\':user/azotlichid la data de _2005-01-12_ categoria _Automate_, autor(i) _Vladu Adrian_)\n\n*Continut scurt:*\n In acest articol vom aborda cele mai comune probleme legate de pattern matching si vom oferi suportul teoretic necesar intelegerii algoritmului Knuth-Morris-Pratt, pornind de la potrivirea standard cu automate finite si rafinand-o treptat pana la un algoritm de complexitate O(n + m). Toate acestea intr-o maniera usor de inteles ;)\n==Include(page=\"template/raw\")==\n\nIn acest articol vom aborda cele mai comune probleme legate de pattern matching si vom oferi suportul teoretic necesar intelegerii algoritmului Knuth-Morris-Pratt, pornind de la potrivirea standard cu automate finite si rafinand-o treptat pana la un algoritm de complexitate O(n + m). Toate acestea intr-o maniera usor de inteles ;)\n\n\n*Continut lung:*\nAutomate finite\n\nCe sunt automatele finite ?\n\nUn automat finit este definit ca un cvintuplu <Q, q0, A, S, d> unde Q este o multime finita de stari Q = {q0, q1, ... qn}, q0 apartine Q (q0 = stare initiala), A inclus in Q (A = multimea starilor de acceptare), S este un alfabet, iar functia d : Q x S -> Q.\n\nAceasta este definitia matematica si foarte abstractizata a automatelor. Pentru a le intelege mai usor, sa luam un exemplu concret\n\nQ = {q0, q1, q2, q3}\nA = {q3}\nS = {a, b}\nd =\n\n\n\n\n| | a | b |\n\n| 0 | 1 | 2 |\n\n| 1 | 3 | 1 |\n\n| 2 | 3 | 0 |\n\n| 3 | 3 | 3 |\n\n\nCe inseamna asta? Sa spunem ca automatul primeste un string s = \'bbaba\'\nInitial ne aflam in q0. Pentru fiecare element al stringului s_i facem tranzitia d(qk, s_i).\n\nPornim din k = 0. Vom avea :\n\nk = 0; d(0, b) = 2;\nk = 2; d(2, b) = 0;\nk = 0; d(0, a) = 1;\nk = 1; d(1, b) = 1;\nk = 2; d(1, a) = 3;\n\nDaca ultima stare obtinuta qk apartine A, atunci spunem ca automatul accepta stringul. Altfel spus, daca avem stringul s, lungime(s) = n, automatul accepta stringul daca si numai daca d ( ... d( d(0, s(1)), s(2) ) ..., s(n) ) apartine A.\n\nStringurile \'aa\', \'aaaaaaa\', \'aabababab\', \'aaaba\', \'ba\', \'aba\' sunt acceptate de automat, dar \'ba\', \'abbbbbb\', \'bba\' nu.\n\nLa ce folosesc ?\n\n1. Inteligenta artificiala (prima si cea mai involuata stare a inteligentei artificiale)\n2. Aplicatii teoretice si probleme de matematica :)\n3. Pattern matching\n\nSe dau stringurile M si N. Se cere sa gasim toate aparitiile lui N in M.\nVom numi Mi prefixul lui M de lungime i. Presupunand ca avem construit automatul care accepta stringul N, vom cauta toate prefixele lui M acceptate de automat, deci toate numerele 1 <= i <= lungime(M) cu proprietatea ca automatul accepta stringul Mi.\n\n\n\nAlgoritm_potrivire_cu_automat_finit\n\n1: n = lungime(N)\n2: q = 0;\n3: pt i <- 1, n\n4: q = d(q, M[i])\n5: daca q apartine A\n6: scrie \"potrivire la pozitia \" i - n + 1\n\ncomplexitate : O(n)\n\nSa vedem cum se construieste automatul de potrivire pentru un string N. Fie m = lungime(M). Construim un automat cu m + 1 stari {q0, q1, ... qm}, A = {qm} . Faptul ca ne aflam in starea x inseamna ca au fost acceptate primele x caractere din sirul de intrare.\nDin fiecare stare qx apartine Q si pt fiecare c apartine S construim d(x, c) = y cu proprietatea ca My este cel mai lung prefix al lui M care este sufix al lui Mxc (prefixul de lungime x al lui M, concatenat cu caracterul c).\n\n\n\nAlgoritm_constructie_automat_finit\n\n1: m <- lungime(M)\n2: pt q <- 0, m\n3: pt c apartine S\n4: gaseste Mi = cel mai lung prefix al lui M cu Mi sufix al lui Mqc\n5: d(q, c) = i\n\ncomplexitate : linia 4 are complexitatea O(m^2) (implementata in maniera bruta) si se executa de (m + 1) * |S| ori => complexitate totala O(m^3 * |S|)\n\nPractic, algoritmul calculeaza pentru toate 0 =< i =< m, c apartine S cat de mult putem lua de la sfarsitul lui Mic astfel incat acesta sa fie un \"inceput\" de N.\n\nAcesta se poate rafina, eliminand operatii redundante, dupa cum vom vedea in cele ce urmeaza.\n\n\n\nAlgoritmul KMP\n\nGaseste toate aparitiile un string N in M in timp O(n + m), unde n = lungime(N), m = lungime(M). O parte esentiala a sa este functia prefix p : {1..n} -> {0..n-1} unde p[i] = cel mai lung prefix al lui M care este sufix al lui Mi. Evident, Mp[i] (prefixul de lungime p[i] al lui M) prefix al lui Mi, deci p[i] < i.\n\nAlgoritm_calcul_functie_prefix\n\n1: n <- lungime(N)\n2: k <- 0\n3: p[1] <- 0\n4: pt i <- 2, n\n5: cat timp (k > 0) si (N[k + 1] ** N[i])\n6: k <- p[k]\n7: daca N[k + 1] = N[i]\n8: k <- k + 1\n9: p[i] <- k\n\nAnaliza complexitatii :\n- la fiecare pas (i = 2, n) k se incrementeaza cel mult o data, deci pe parcursul algoritmului k se va incrementa de cel mult n - 1 ori (linia 8)\n- in linia 5, k se decrementeaza cel mult pana devine 0, deci se va decrementa de cel\nmult n - 1 ori pe parcursul algoritmului\n\n=> Complexitate : O(n)\n\nAlgoritmul este similar cu constructia automatului de acceptare. Din fiecare stare i in care s-a acceptat Ni, vedem cat de mult putem lua de la sfarsitul lui Ni astfel incat sufixul respectiv sa fie prefix pentru N. De remarcat ca in cazul in care starea candidata k nu este buna, nu mergem in k - 1, ci in p[k]. Aceasta este de fapt \"magia\" care ofera complexitate liniara.\n\nAlgoritmul de potrivire este similar celui al calculului functiei prefix, numai ca aici la fiecare pas i cautam cel mai lung prefix al lui N care este sufix al lui Mi.\n\n\n\nAlgoritm_potrivire_KMP\n\n1: m <- lungime(M), n <- lungime(N)\n2: q <- 0\n3: pt i <- 1, m\n4: cat timp (q > 0) si (N[q + 1] ** M[i])\n5: q <- pi[q]\n6: daca N[q + 1] = M[i]\n7: q <- q + 1\n8: daca q = n\n9: scrie \"potrivire la pozitia \" i - n + 1\n\n\n\nAnalog Algoritm_Calcul_Functie_Prefix, complexitatea algoritmului efectiv de potrivire este O(m). Astfel rezulta complexitatea liniara a algoritmului KMP O(n + m)\n\nTeme pentru acasa:\n\n- folosind functia prefix, rafinati constructia automatului finit de acceptare pt un string, aducand-o la complexitatea O(m^2 * |S|)\n- problema \"[1]Microvirus\" (hint : construiti automatul de potrivire pentru stringul dat)\n- Timus 1158\n\n\n\nReferences\n\nVisible links\n1. http://www.liis.ro/%7ecampion/problems/2/64/microvirus.htm\n==Include(page=\"template/raw\")==\n\nAutomate finite\n\nCe sunt automatele finite ?\n\nUn automat finit este definit ca un cvintuplu <Q, q0, A, S, d> unde Q este o multime finita de stari Q = {q0, q1, ... qn}, q0 apartine Q (q0 = stare initiala), A inclus in Q (A = multimea starilor de acceptare), S este un alfabet, iar functia d : Q x S -> Q.\n\nAceasta este definitia matematica si foarte abstractizata a automatelor. Pentru a le intelege mai usor, sa luam un exemplu concret\n\nQ = {q0, q1, q2, q3}\nA = {q3}\nS = {a, b}\nd =\n\n\n\n\n| | a | b |\n\n| 0 | 1 | 2 |\n\n| 1 | 3 | 1 |\n\n| 2 | 3 | 0 |\n\n| 3 | 3 | 3 |\n\n\nCe inseamna asta? Sa spunem ca automatul primeste un string s = \'bbaba\'\nInitial ne aflam in q0. Pentru fiecare element al stringului s_i facem tranzitia d(qk, s_i).\n\nPornim din k = 0. Vom avea :\n\nk = 0; d(0, b) = 2;\nk = 2; d(2, b) = 0;\nk = 0; d(0, a) = 1;\nk = 1; d(1, b) = 1;\nk = 2; d(1, a) = 3;\n\nDaca ultima stare obtinuta qk apartine A, atunci spunem ca automatul accepta stringul. Altfel spus, daca avem stringul s, lungime(s) = n, automatul accepta stringul daca si numai daca d ( ... d( d(0, s(1)), s(2) ) ..., s(n) ) apartine A.\n\nStringurile \'aa\', \'aaaaaaa\', \'aabababab\', \'aaaba\', \'ba\', \'aba\' sunt acceptate de automat, dar \'ba\', \'abbbbbb\', \'bba\' nu.\n\nLa ce folosesc ?\n\n1. Inteligenta artificiala (prima si cea mai involuata stare a inteligentei artificiale)\n2. Aplicatii teoretice si probleme de matematica :)\n3. Pattern matching\n\nSe dau stringurile M si N. Se cere sa gasim toate aparitiile lui N in M.\nVom numi Mi prefixul lui M de lungime i. Presupunand ca avem construit automatul care accepta stringul N, vom cauta toate prefixele lui M acceptate de automat, deci toate numerele 1 <= i <= lungime(M) cu proprietatea ca automatul accepta stringul Mi.\n\n\n\nAlgoritm_potrivire_cu_automat_finit\n\n1: n = lungime(N)\n2: q = 0;\n3: pt i <- 1, n\n4: q = d(q, M[i])\n5: daca q apartine A\n6: scrie \"potrivire la pozitia \" i - n + 1\n\ncomplexitate : O(n)\n\nSa vedem cum se construieste automatul de potrivire pentru un string N. Fie m = lungime(M). Construim un automat cu m + 1 stari {q0, q1, ... qm}, A = {qm} . Faptul ca ne aflam in starea x inseamna ca au fost acceptate primele x caractere din sirul de intrare.\nDin fiecare stare qx apartine Q si pt fiecare c apartine S construim d(x, c) = y cu proprietatea ca My este cel mai lung prefix al lui M care este sufix al lui Mxc (prefixul de lungime x al lui M, concatenat cu caracterul c).\n\n\n\nAlgoritm_constructie_automat_finit\n\n1: m <- lungime(M)\n2: pt q <- 0, m\n3: pt c apartine S\n4: gaseste Mi = cel mai lung prefix al lui M cu Mi sufix al lui Mqc\n5: d(q, c) = i\n\ncomplexitate : linia 4 are complexitatea O(m^2) (implementata in maniera bruta) si se executa de (m + 1) * |S| ori => complexitate totala O(m^3 * |S|)\n\nPractic, algoritmul calculeaza pentru toate 0 =< i =< m, c apartine S cat de mult putem lua de la sfarsitul lui Mic astfel incat acesta sa fie un \"inceput\" de N.\n\nAcesta se poate rafina, eliminand operatii redundante, dupa cum vom vedea in cele ce urmeaza.\n\n\n\nAlgoritmul KMP\n\nGaseste toate aparitiile un string N in M in timp O(n + m), unde n = lungime(N), m = lungime(M). O parte esentiala a sa este functia prefix p : {1..n} -> {0..n-1} unde p[i] = cel mai lung prefix al lui M care este sufix al lui Mi. Evident, Mp[i] (prefixul de lungime p[i] al lui M) prefix al lui Mi, deci p[i] < i.\n\nAlgoritm_calcul_functie_prefix\n\n1: n <- lungime(N)\n2: k <- 0\n3: p[1] <- 0\n4: pt i <- 2, n\n5: cat timp (k > 0) si (N[k + 1] ** N[i])\n6: k <- p[k]\n7: daca N[k + 1] = N[i]\n8: k <- k + 1\n9: p[i] <- k\n\nAnaliza complexitatii :\n- la fiecare pas (i = 2, n) k se incrementeaza cel mult o data, deci pe parcursul algoritmului k se va incrementa de cel mult n - 1 ori (linia 8)\n- in linia 5, k se decrementeaza cel mult pana devine 0, deci se va decrementa de cel\nmult n - 1 ori pe parcursul algoritmului\n\n=> Complexitate : O(n)\n\nAlgoritmul este similar cu constructia automatului de acceptare. Din fiecare stare i in care s-a acceptat Ni, vedem cat de mult putem lua de la sfarsitul lui Ni astfel incat sufixul respectiv sa fie prefix pentru N. De remarcat ca in cazul in care starea candidata k nu este buna, nu mergem in k - 1, ci in p[k]. Aceasta este de fapt \"magia\" care ofera complexitate liniara.\n\nAlgoritmul de potrivire este similar celui al calculului functiei prefix, numai ca aici la fiecare pas i cautam cel mai lung prefix al lui N care este sufix al lui Mi.\n\n\n\nAlgoritm_potrivire_KMP\n\n1: m <- lungime(M), n <- lungime(N)\n2: q <- 0\n3: pt i <- 1, m\n4: cat timp (q > 0) si (N[q + 1] ** M[i])\n5: q <- pi[q]\n6: daca N[q + 1] = M[i]\n7: q <- q + 1\n8: daca q = n\n9: scrie \"potrivire la pozitia \" i - n + 1\n\n\n\nAnalog Algoritm_Calcul_Functie_Prefix, complexitatea algoritmului efectiv de potrivire este O(m). Astfel rezulta complexitatea liniara a algoritmului KMP O(n + m)\n\nTeme pentru acasa:\n\n- folosind functia prefix, rafinati constructia automatului finit de acceptare pt un string, aducand-o la complexitatea O(m^2 * |S|)\n- problema \"[1]Microvirus\" (hint : construiti automatul de potrivire pentru stringul dat)\n- Timus 1158\n\n\n\nReferences\n\nVisible links\n1. http://www.liis.ro/%7ecampion/problems/2/64/microvirus.htm\n\n',0,''),('ciurul-lui-erathostene','Ciurul lui Erathostene','2004-11-24 00:00:00','h1. Ciurul lui Erathostene\n\n(Creat de \'_Cosmin_\':user/Cosmin la data de _2004-11-24_ categoria _Teoria numerelor_, autor(i) _Cosmin_)\n\n*Continut scurt:*\n Articolul de fata incearca o implementarea mai eficienta a acestui algoritm clasic. Se poate optimiza pentru a folosi doar O(sqrt(n)) memorie, varianta prezentata aici folosind O(n / log n) memorie, unde log n e numarul de biti al unui cuvant.\n==Include(page=\"template/raw\")==\n\nArticolul de fata incearca o implementarea mai eficienta a acestui algoritm clasic. Se poate optimiza pentru a folosi doar O(sqrt(n)) memorie, varianta prezentata aici folosind O(n / log n) memorie, unde log n e numarul de biti al unui cuvant.\n\n\n*Continut lung:*\nCiurul lui Erathostene e un algoritm clasic care se invata la scoala impreuna cu conceptul de numere prime inca din clasa a 6. Acest algoritm determina toate numerele prime mai mici decat un numar dat ca parametru. Ideea lui de abordare a acestei probleme poate fi modificata pentru a rezolva si alte probleme precum problema Fractii din arhiva infoarena, problema Riemann vs Mertens din arhiva uva ([1]http://acm.uva.es/p/v107/10738.html), problema Divizibilitate a rundei 4 a concursului algoritmus ([2]http://algoritmus.org/probleme/Probleme_Runda04.php), sau problema Square Free a SRM-ului 190 de pe TOPCODER ([3]http://www.topcoder.com/stat?c=problem_statement&pm=2342&rd=4770, rezolvarea ei o gasiti aici : [4]http://www.topcoder.com/index?t=statistics&c=srm190_prob) . (linkurile ce contin litere mari nu merg pentru ca editorul le trasforma automat in litere mici si nu mai pot fi modificate, daca vreti sa urmati un link faceti un copy paste cu adresa in browserul vostru)\n\nIn articolul acesta nu ne vom concentra asupra acestor probleme ci asupra implementarii optimizate ale algoritmului original.\n\nAm mai scris despre aceste optimizari intr-un articol din ginfo, dar codul de acolo nu era testat si nu merge :).\n\nIdeea la acest algoritm e ca marcam intr-un sir fiecare multiplu al unui numar prim si numerele ramase nemarcate sunt numere prime, o descriere mai grafica gasiti la adresa: [5]http://mathworld.wolfram.com/SieveofEratosthenes.html.\n\nSa incercam o prima implementare a acestui algoritm (implementarile vor folosi limbajul java, dar sunt foarte usor transformabile in C/C++).\n\n\n\n//class PrimeNumbersSieve1\nfinal int MAXSIZE = 1000001;\nchar[] p = new char[MAXSIZE];\n\n//p[i] == 0 if i is prime\n\npublic int getTheNumber(int n) {\nint i, j, nr = 0;\nfor (i = 2; i <= n; ++i) {\nif (p[i] == 0) {\nnr++;\nfor (j = i + i; j <= n; j += i) {\np[j] = 1;\n}\n}\n}\nreturn nr;\n}\n\n\n\n\nO prima idee de optimizare ar fi sa nu mai luam in calcul numerele pare pentru ca stim ca singurul numar prim par e 2. Deci sa vedem noua varianta a programului:\n\n//class PrimeNumbersSieve2\nfinal int MAXSIZE = 1000001;\nchar[] p = new char[MAXSIZE];\n\n//p[i] == 0 if i is prime\n\npublic int getTheNumber(int n) {\nint i, j, nr = 1;\nfor (i = 3; i <= n; i += 2) {\nif (p[i] == 0) {\nnr++;\nfor (j = i + i + i; j <= n; j += i << 1) {\np[j] = 1;\n}\n}\n}\nreturn nr;\n}\n\n\n\nPutem incerca o optimizare de memorie, pentru ca nu mai avem nevoie de elementele cu index par din sirul p. Acum semnificatia lui p[i] s-a schimbat p[i] fiind 0 daca 2*i+1 e numar prim si 1 daca nu.\n\n// class PrimeNumbersSieve3\nfinal int MAXSIZE = 1000000/2+1;\nchar[] p = new char[MAXSIZE];\n\n//p[i] == 0 if 2*i + 1 is prime\n\npublic int getTheNumber(int n) {\nint i, j, nr = 1;\nfor (i = 1; (i << 1) + 1 <= n; i += 1) {\nif (p[i] == 0) {\nnr++;\nfor (j = i + i + i + 1;\n\n(j << 1) + 1 <= n;\n\nj += (i << 1) + 1) {\np[j] = 1;\n}\n}\n}\nreturn nr;\n}\n\n\n\n\n\n\nUrmatoarea optimizare va fi marcarea multiplilor numarului prim i de la i*i nu de la 2*i cum am facut in prima varianta sau de la 3*i cum am facut in a 2-a. Aceasta optimizare este evidenta: orice numar prim compus multiplu de i mai mic decat i*i are un factor prim mai mic decat i, si acel factor l-a marcat mai devreme, deci nu are rost sa il marcam si la pasul i. Ideea aceasta este exact ideea ce se foloseste la rezolvarea problemei Numere Prime din arhiva infoarena. Sa vedem acum codul sursa:\n\n//class PrimeNumbersSieve4\nfinal int MAXSIZE = 1000000/2+1;\nchar[] p = new char[MAXSIZE];\n\n//p[i] == 0 if 2*i + 1 is prime\n\npublic int getTheNumber(int n) {\nint i, j, nr = 1;\nfor (i = 1;\n\n((i * i) << 1) + (i << 1) <= n;\n\ni += 1) {\nif (p[i] == 0) {\nfor (j = ((i * i) << 1) + (i << 1);\n\n(j << 1) + 1 <= n;\n\nj += (i << 1) + 1) {\np[j] = 1;\n}\n}\n}\nfor (i=1; 2 * i + 1 <= n; ++i)\n\nif (p[i] == 0) nr++;\nreturn nr;\n}\n\n\n\n\n\nCodul sursa arata putin urat pentru ca nu lucram direct cu i ci cu 2*i+1, am mai facut optimizarea ce apare si in mathworld, nu parcurgem numerele pana la n pentru marcarea multiplilor ci pana la sqrt(n) lucru care e evident dupa cele explicate mai sus.\n\nUltima imbunatatire care o vom aduce este aceea de a folosi mai putina memorie. Cum pentru fiecare numar e necesara doar o informatie booleana, aceasta o putem tine intr-un bit, nu este necesar un char intreg. Sa vedem cum arata codul:\n\n//class PrimeNumbersSieve5\nfinal int MAXSIZE = 100000000/2/8+1;\nchar[] p = new char[MAXSIZE];\n\n//p[i] == 0 if 2*i + 1 is prime\n\npublic int getTheNumber(int n) {\nint i, j, nr = 1;\nfor (i = 1;\n\n((i * i) << 1) + (i << 1) <= n;\n\ni += 1) {\nif ((p[i >> 3] & (1 << (i & 7))) == 0) {\nfor (j = ((i * i) << 1) + (i << 1);\n\n(j << 1) + 1 <= n;\n\nj += (i << 1) + 1) {\np[j >> 3] |= (1 << (j & 7));\n}\n}\n}\nfor (i = 1; 2 * i + 1 <= n; ++i)\n\nif ((p[i >> 3] & (1 << (i & 7))) == 0)\n\nnr++;\nreturn nr;\n}\n\n\n\nCodul p[i >> 3] & (1 << (i & 7)) == 0 testeaza daca al i-lea bit din sirul de biti e 0 (deci daca 2*i+1 e prim). i >> 3 e echivalent cu i / 8 deci se gaseste pt bitul al i-lea in ce char e el stocat din sirul nostru de charuri. i & 7 e echivalent cu i % 8 ca sa aflam pe ce bit al charului e stocat numarul prim i.\n\nCodul p[j >> 3] |= (1 << (j & 7)) seteaza bitul j % 8 al charului j / 8 in 1, pt ca sa stim ca numarul 2 * j + 1 nu e prim.\n\n\n\nUltima varianta arata destul de urat fata de prima, sa vedem daca s-a meritat efortul. Urmatoarele date sunt obtinute pe un procesor Athlon XP la 1.8 Ghz:\n\n10 runs of BruteForcePrimes().method1(1000000) lasted: 24.956 seconds\n\n10 runs of PrimeNumbersSieve1().getTheNumber(1000000) lasted: 3.024 seconds\n\n10 runs of PrimeNumbersSieve2().getTheNumber(1000000) lasted: 1.842 seconds\n\n10 runs of PrimeNumbersSieve3().getTheNumber(1000000) lasted: 1.422 seconds\n\n10 runs of PrimeNumbersSieve4().getTheNumber(1000000) lasted: 0.971 seconds\n\n10 runs of PrimeNumbersSieve5().getTheNumber(1000000) lasted: 0.22 seconds\n\nCodul folosit pentru testare e:\n\npublic static void main(String[] arg) {\ndouble tick = System.currentTimeMillis();\nfor (int i = 0; i < 10; ++i) {\nSystem.out.println(\"Run \" + i\n+ \" result: \"+\nnew PrimeNumbersSieve1().\ngetTheNumber(1000000));\n}\nSystem.out.println(\" 10 runs of \"\n+ \"PrimeNumbersSieve1().\"\n+ \"getTheNumber(1000000) \"\n+ \"lasted: \"\n+ (System.currentTimeMillis()\n- tick)\n* 1e-3 + \" seconds\");\n}\n\n\n\nS-a rulat fiecare cod de 10 ori pentru a da ocazia optimizarilor Just In Time din java sa isi faca treaba.\n\nSe pare ca optimizarile codului initial au dus la o imbunatatire a vitezei cu un factor de 10.\n\nProblemele sugerate la inceputul articolului sunt destul de frumoase si ar trebui rezolvate. Pt fiecare dintre ele puteti sa va testati rezolvarea: la algoritmus sunt disponibile fisierele de intrare si iesire, infoarena si uva au evaluatoare automate si pentru problema de pe TOPCODER puteti intra in applet-ul lor si sa incercati sa o rezolvati in practice roomul asociat SRM-ului 190 dupa ce o rezolvati folositi optiunea Run System Test din Practice Room Options.\n\nReferences\n\nVisible links\n1. http://acm.uva.es/p/v107/10738.html\n2. http://algoritmus.org/probleme/probleme_runda04.php\n3. http://www.topcoder.com/stat?c=problem_statement&pm=2342&rd=4770\n4. http://www.topcoder.com/index?t=statistics&c=srm190_prob\n5. http://mathworld.wolfram.com/sieveoferatosthenes.html\n==Include(page=\"template/raw\")==\n\nCiurul lui Erathostene e un algoritm clasic care se invata la scoala impreuna cu conceptul de numere prime inca din clasa a 6. Acest algoritm determina toate numerele prime mai mici decat un numar dat ca parametru. Ideea lui de abordare a acestei probleme poate fi modificata pentru a rezolva si alte probleme precum problema Fractii din arhiva infoarena, problema Riemann vs Mertens din arhiva uva ([1]http://acm.uva.es/p/v107/10738.html), problema Divizibilitate a rundei 4 a concursului algoritmus ([2]http://algoritmus.org/probleme/Probleme_Runda04.php), sau problema Square Free a SRM-ului 190 de pe TOPCODER ([3]http://www.topcoder.com/stat?c=problem_statement&pm=2342&rd=4770, rezolvarea ei o gasiti aici : [4]http://www.topcoder.com/index?t=statistics&c=srm190_prob) . (linkurile ce contin litere mari nu merg pentru ca editorul le trasforma automat in litere mici si nu mai pot fi modificate, daca vreti sa urmati un link faceti un copy paste cu adresa in browserul vostru)\n\nIn articolul acesta nu ne vom concentra asupra acestor probleme ci asupra implementarii optimizate ale algoritmului original.\n\nAm mai scris despre aceste optimizari intr-un articol din ginfo, dar codul de acolo nu era testat si nu merge :).\n\nIdeea la acest algoritm e ca marcam intr-un sir fiecare multiplu al unui numar prim si numerele ramase nemarcate sunt numere prime, o descriere mai grafica gasiti la adresa: [5]http://mathworld.wolfram.com/SieveofEratosthenes.html.\n\nSa incercam o prima implementare a acestui algoritm (implementarile vor folosi limbajul java, dar sunt foarte usor transformabile in C/C++).\n\n\n\n//class PrimeNumbersSieve1\nfinal int MAXSIZE = 1000001;\nchar[] p = new char[MAXSIZE];\n\n//p[i] == 0 if i is prime\n\npublic int getTheNumber(int n) {\nint i, j, nr = 0;\nfor (i = 2; i <= n; ++i) {\nif (p[i] == 0) {\nnr++;\nfor (j = i + i; j <= n; j += i) {\np[j] = 1;\n}\n}\n}\nreturn nr;\n}\n\n\n\n\nO prima idee de optimizare ar fi sa nu mai luam in calcul numerele pare pentru ca stim ca singurul numar prim par e 2. Deci sa vedem noua varianta a programului:\n\n//class PrimeNumbersSieve2\nfinal int MAXSIZE = 1000001;\nchar[] p = new char[MAXSIZE];\n\n//p[i] == 0 if i is prime\n\npublic int getTheNumber(int n) {\nint i, j, nr = 1;\nfor (i = 3; i <= n; i += 2) {\nif (p[i] == 0) {\nnr++;\nfor (j = i + i + i; j <= n; j += i << 1) {\np[j] = 1;\n}\n}\n}\nreturn nr;\n}\n\n\n\nPutem incerca o optimizare de memorie, pentru ca nu mai avem nevoie de elementele cu index par din sirul p. Acum semnificatia lui p[i] s-a schimbat p[i] fiind 0 daca 2*i+1 e numar prim si 1 daca nu.\n\n// class PrimeNumbersSieve3\nfinal int MAXSIZE = 1000000/2+1;\nchar[] p = new char[MAXSIZE];\n\n//p[i] == 0 if 2*i + 1 is prime\n\npublic int getTheNumber(int n) {\nint i, j, nr = 1;\nfor (i = 1; (i << 1) + 1 <= n; i += 1) {\nif (p[i] == 0) {\nnr++;\nfor (j = i + i + i + 1;\n\n(j << 1) + 1 <= n;\n\nj += (i << 1) + 1) {\np[j] = 1;\n}\n}\n}\nreturn nr;\n}\n\n\n\n\n\n\nUrmatoarea optimizare va fi marcarea multiplilor numarului prim i de la i*i nu de la 2*i cum am facut in prima varianta sau de la 3*i cum am facut in a 2-a. Aceasta optimizare este evidenta: orice numar prim compus multiplu de i mai mic decat i*i are un factor prim mai mic decat i, si acel factor l-a marcat mai devreme, deci nu are rost sa il marcam si la pasul i. Ideea aceasta este exact ideea ce se foloseste la rezolvarea problemei Numere Prime din arhiva infoarena. Sa vedem acum codul sursa:\n\n//class PrimeNumbersSieve4\nfinal int MAXSIZE = 1000000/2+1;\nchar[] p = new char[MAXSIZE];\n\n//p[i] == 0 if 2*i + 1 is prime\n\npublic int getTheNumber(int n) {\nint i, j, nr = 1;\nfor (i = 1;\n\n((i * i) << 1) + (i << 1) <= n;\n\ni += 1) {\nif (p[i] == 0) {\nfor (j = ((i * i) << 1) + (i << 1);\n\n(j << 1) + 1 <= n;\n\nj += (i << 1) + 1) {\np[j] = 1;\n}\n}\n}\nfor (i=1; 2 * i + 1 <= n; ++i)\n\nif (p[i] == 0) nr++;\nreturn nr;\n}\n\n\n\n\n\nCodul sursa arata putin urat pentru ca nu lucram direct cu i ci cu 2*i+1, am mai facut optimizarea ce apare si in mathworld, nu parcurgem numerele pana la n pentru marcarea multiplilor ci pana la sqrt(n) lucru care e evident dupa cele explicate mai sus.\n\nUltima imbunatatire care o vom aduce este aceea de a folosi mai putina memorie. Cum pentru fiecare numar e necesara doar o informatie booleana, aceasta o putem tine intr-un bit, nu este necesar un char intreg. Sa vedem cum arata codul:\n\n//class PrimeNumbersSieve5\nfinal int MAXSIZE = 100000000/2/8+1;\nchar[] p = new char[MAXSIZE];\n\n//p[i] == 0 if 2*i + 1 is prime\n\npublic int getTheNumber(int n) {\nint i, j, nr = 1;\nfor (i = 1;\n\n((i * i) << 1) + (i << 1) <= n;\n\ni += 1) {\nif ((p[i >> 3] & (1 << (i & 7))) == 0) {\nfor (j = ((i * i) << 1) + (i << 1);\n\n(j << 1) + 1 <= n;\n\nj += (i << 1) + 1) {\np[j >> 3] |= (1 << (j & 7));\n}\n}\n}\nfor (i = 1; 2 * i + 1 <= n; ++i)\n\nif ((p[i >> 3] & (1 << (i & 7))) == 0)\n\nnr++;\nreturn nr;\n}\n\n\n\nCodul p[i >> 3] & (1 << (i & 7)) == 0 testeaza daca al i-lea bit din sirul de biti e 0 (deci daca 2*i+1 e prim). i >> 3 e echivalent cu i / 8 deci se gaseste pt bitul al i-lea in ce char e el stocat din sirul nostru de charuri. i & 7 e echivalent cu i % 8 ca sa aflam pe ce bit al charului e stocat numarul prim i.\n\nCodul p[j >> 3] |= (1 << (j & 7)) seteaza bitul j % 8 al charului j / 8 in 1, pt ca sa stim ca numarul 2 * j + 1 nu e prim.\n\n\n\nUltima varianta arata destul de urat fata de prima, sa vedem daca s-a meritat efortul. Urmatoarele date sunt obtinute pe un procesor Athlon XP la 1.8 Ghz:\n\n10 runs of BruteForcePrimes().method1(1000000) lasted: 24.956 seconds\n\n10 runs of PrimeNumbersSieve1().getTheNumber(1000000) lasted: 3.024 seconds\n\n10 runs of PrimeNumbersSieve2().getTheNumber(1000000) lasted: 1.842 seconds\n\n10 runs of PrimeNumbersSieve3().getTheNumber(1000000) lasted: 1.422 seconds\n\n10 runs of PrimeNumbersSieve4().getTheNumber(1000000) lasted: 0.971 seconds\n\n10 runs of PrimeNumbersSieve5().getTheNumber(1000000) lasted: 0.22 seconds\n\nCodul folosit pentru testare e:\n\npublic static void main(String[] arg) {\ndouble tick = System.currentTimeMillis();\nfor (int i = 0; i < 10; ++i) {\nSystem.out.println(\"Run \" + i\n+ \" result: \"+\nnew PrimeNumbersSieve1().\ngetTheNumber(1000000));\n}\nSystem.out.println(\" 10 runs of \"\n+ \"PrimeNumbersSieve1().\"\n+ \"getTheNumber(1000000) \"\n+ \"lasted: \"\n+ (System.currentTimeMillis()\n- tick)\n* 1e-3 + \" seconds\");\n}\n\n\n\nS-a rulat fiecare cod de 10 ori pentru a da ocazia optimizarilor Just In Time din java sa isi faca treaba.\n\nSe pare ca optimizarile codului initial au dus la o imbunatatire a vitezei cu un factor de 10.\n\nProblemele sugerate la inceputul articolului sunt destul de frumoase si ar trebui rezolvate. Pt fiecare dintre ele puteti sa va testati rezolvarea: la algoritmus sunt disponibile fisierele de intrare si iesire, infoarena si uva au evaluatoare automate si pentru problema de pe TOPCODER puteti intra in applet-ul lor si sa incercati sa o rezolvati in practice roomul asociat SRM-ului 190 dupa ce o rezolvati folositi optiunea Run System Test din Practice Room Options.\n\nReferences\n\nVisible links\n1. http://acm.uva.es/p/v107/10738.html\n2. http://algoritmus.org/probleme/probleme_runda04.php\n3. http://www.topcoder.com/stat?c=problem_statement&pm=2342&rd=4770\n4. http://www.topcoder.com/index?t=statistics&c=srm190_prob\n5. http://mathworld.wolfram.com/sieveoferatosthenes.html\n\n',0,''),('preoni-2005/runda-1/solutii','preONI 2005 runda #1 - solutii','2005-01-24 00:00:00','h1. preONI 2005 runda #1 - solutii\n\n(Creat de \'_domino_\':user/domino la data de _2005-01-24_ categoria _Competitii_, autor(i) _Mircea Pasoi_)\n\n*Continut scurt:*\n Articolul contine ideile de rezolvare ale problemelor propuse la prima runda a concursului preONI ce s-a desfasurat pe data de 23 ianuarie 2005, cat si comentarii legate de concurs.\n==Include(page=\"template/raw\")==\n\nArticolul contine ideile de rezolvare ale problemelor propuse la prima runda a concursului preONI ce s-a desfasurat pe data de 23 ianuarie 2005, cat si comentarii legate de concurs.\n\n\n*Continut lung:*\nCum s-a si promis, setul de probleme de data aceasta n-a fost dur, problemele fiind mult mai accesibile, fapt care se vede imediat din punctaje. Spre deosebire de concursurile anterioare in care problemele erau toate de acelasi nivel, de data aceasta a existat o problema usoara, una medie si una grea la fiecare grupa (gen TopCoder).\n\nToti care am participat la compunerea problemelor suntem de parere ca probleme au fost de nivelul ONI, chiar un pic mai usoare. De asemenea, testele au fost create astfel incat sa se poata obtine 190-200p in mod usor de un concurent cu cunostiinte medii care implementeaza solutii corecte dar care nu se incadreaza complet in limita de timp. Din pacate rezultatele sunt un pic sub nivelul asteptarilor, dar speram ca se vor inbunatati in rundele urmatoare! ;)\n\nClasele 9-10\n\nPrimele 5 locuri din clasamentul de la 9-10 arata astfel:\n1. Macarie & Petronela - 270p\n2. Tataroiu Bogdan - 210p\n3. Stefan Andrei - 190p\n4. Ghilea Daniel - 180p\n5. Saveluc Vlad - 170p\n6. Stanescu Lucian - 170p\n\nEste de mentionat faptul ca sub pseudonimul \"Macarie & Petronela\" se \"ascunde\" echipa care va reprezenta Romania la finala ACM, formata din Mugurel Andreica, Marius Andrei si Ghinea Dan. Ei au concurat pe un singur calculator si au rezolvat toate cele 6 probleme propuse pentu a simula un concurs ACM. De asemenea, un lucru remarcabil, concurentul clasat pe locul 2, Tataroiu Bogdan este abia clasa a 7-a! Probabil ca va reprezenta Romania la multe IOI-uri :)\n\nText\n\nProblema a fost cea mai usoara din cele 3 probleme din grupa si rezolvarea nu ar trebui sa ridice mari dificultati nici macar unui elev de a 9-a incepator. Fie N numarul de caractere din fisierul de intrare - voi prezenta o solutie O(N). Se parcurge fisierul caracter cu caracter (nu este necesara stocarea datelor de intrare intr-un vector) si se mentin doua variabile care indica pozitia de inceput si sfarsit a ultimului cuvant detectat pana in prezent, daca s-a gasit vreunul. De asemenea se pastreaza si doua variabile pentru suma lungimilor cuvintelor si numarul de cuvinte pentru a calcula rezultatul. Atentie insa ca la sfarsitul parcurgerii fisierului de iesire, daca ultimul caracter citit a fost o litera mare sau mica, sa se actualizeze numarul de cuvinte si suma lungimilor.\n\nTrapez\n\nProblema a fost cea de nivel mediu din cele 3 si face apel la cunostiinte minime de geometrie. Conditia ca oricare trei puncte nu sunt coliniare simplifica mult rezolvarea. Din definitie, un trapez are cel putin doua laturi paralele deci se poate construi urmatorul algoritm: se iau toate perechile de puncte - acestea determina cate un segment - si sorteaza in functie de unghiul cu axa OX (panta dreptei). Pentru fiecare k segmente cu acelasi unghi se pot forma Comb(k,2) trapeze. Pentru a evita calculele cu reale (care pot cauza erori de precizie), se tin pantele ca perechi de numere intregi (y, x), fara a efectua efectiv impartirea y/x. Pentru compararea a doua astfel de perechi sunt necesare tipuri de date pe 64 de biti. Algoritmul descris are complexitate O(N^2*lg N). Las ca exercitiu rezolvarea acestei probleme folosind un algoritm O(N^2) care foloseste hashing (vezi articolul de pe site). Se puteau obtine 40-50p cu un algoritm brut O(N^4).\n\nSubsir\n\nAceasta problema, care a fost si cea mai grea, a fost prezenta si la CEOI 2003, dar intr-o forma mai simpla. Acolo se cerea generarea efectiva a tuturor subsirurilor , nu numararea lor, si se garanta ca numarul lor este sub 1000. Orice solutie care ar fi luat 100p la problema de la CEOI ar fi obtinut 50p la aceasta (primele 5 teste fiind de fapt preluate de la CEOI 2003). Cum multi probabil au intuit, rezolvarea se bazeaza pe programare dinamica. Voi numi cele doua siruri A si B, de lungime N, respectiv M si voi construi initial matricea C[i][j] = lungimea celui mai lung subsir comun al sirurilor A[1..i] si B[1..j]. Acest lucru se poate face in O(N*M) si este o aplicatie clasica a programarii dinamice (se gaseste in foarte multe carti explicata ideea). In continuare voi numara sirurile folosind un algoritm O(N*M*Sigma) unde Sigma este numarul litere din care pot fi formate sirurile, adica 26. Se va calcula o matrice Nr[i][j] = cate subsiruri comune de lungime maxima existe pentru sirurile A[1..i] si\nB[1..j] (evident modulo 666013). Se calculeaza Nr[i][j] doar atunci cand A[i] = B[j], astfel: pentru fiecare caracter c intre \'a\' si \'z\' se cauta ultima sa aparitie in sirul A[1..i-1] (fie aceasta pozitia ii) si ultima sa aparitie in sirul B[1..j-1] (fie aceasta pozitia jj). Acest lucru se poate face in O(1) daca se preproceseaza inainte aceste informatii in O((N+M)*Sigma). Daca C[i][j] = C[ii][jj]+1 se va aduna Nr[ii][jj] la Nr[i][j] - aceasta conditie ne garanteaza ca subsirurile adaugate au lungime maxima, iar faptul ca ii si jj reprezinta ultima aparitie a caracterului garanteaza ca nu se vor numara subsiruri identice. Pentru a gasi rezultatul final se aduna toate valorile Nr[i][j] calculate, cu urmatoarea exceptie: daca exista pozitiile x si y astfel incat A[x] = A[i] = B[y] = B[j], se aduna Nr[i][j] doar daca x < i si y < j (pentru a asigura ca nu se numara subsiruri identice de mai multe ori).\n\n\n\nClasele 11-12\n\nPrimele 5 locuri din clasamentul de la 11-12 arata astfel:\n1. Simion Filip - 200p\n2. Macarie & Petronela - 190p\n2. Fechete Dan Ionut - 190p\n2. Crestez Leonard - 190p\n3. Bindea Calin - 170p\n4. Grosu Codrut - 140p\n5. Gordon Freeman - 130p\n5. Giurgea Mihnea - 130p\n\nIepuri\n\nProblema a fost cea mai usoara din cel 3 si necesita cunostiine elementare de matematica de clasa a 11-a. Daca se noteaza cu I(n) cati iepuri sunt in ziua n se deduc urmatoarele relatii din enunt:\nI(0)=X, I(1)=Y, I(2)=Z\nI(n)=A*I(n-1) + B*I(n-2) + C*I(n-3) pt n>=3\nRezultatul cerut este I(N) modulo 666013 pentru fiecare test.\nO prima rezolvare, si cea mai simpla, este implementarea directa a relatiei de recurenta si conduce la o complexitate O(N) pe set de date. Aceasta abordare ar fi obtinut 50p.In continuare voi descrie o rezolvare O(lg N) care foloseste matrici. Se construieste matricea:\n\n[0 1 0]\nM = [0 0 1]\n[C B A]\n\ncare sta la baza relatiei:\n\n[I(n) ] [I(n+1)]\nM * [I(n+1)] = [I(n+2)]\n[I(n+2)] [I(n+3)]\n\nDin asta se deduce:\n\n[I(0)] [I(N) ]\nM^N * [I(1)] = [I(N+1)]\n[I(2)] [I(N+2)]\n\nastfel problema se reduce la a calcula M^N in O(lg N). Algoritmul de ridicare la putere in timp logaritmic este clasic si nu-l mai mentionez aici.\n\nBarbar\n\nProblema este de nivel mediu si necesita cunostiinte elementare de teoria grafurilor. Se considera matricea initiala un graf cu R*C noduri, mai putin zidurile. Se face o parcurgere BF pentru a determina pentru fiecare casuta din matrice distanta pana la cel mai apropiat dragon. Astfel, se incepe BF-ul cu toate nodurile care corespund dragonilor inserate in coada (deci nu va fi doar un nod in coada la inceput). Complexitatea acestui pas este O(R*C). Se observa daca exista un traseu valid care trece prin casute situate la distanta >=x fata de cel mai apropiat dragon, atunci exista in mod evident un traseu valid care trece prin casute situate la distanta >=x-1 fata de cel mai apropiat dragon. Aceasta observatie duce la folosirea cautarii binare a rezultatului (vezi articolul de pe site pentru alte aplicatii). Pentru a verifica daca exista un traseu valid care trece doar prin casute situate la o anumita distanta fata de cel mai apropiat dragon se foloseste tot o parcurgere BF, astfel rezolvarea fiind\nO(R*C*lg(R*C)).\n\nADN\n\nLa primul pas se elimina toate cuvintele incluse in alte cuvinte mai mari (pentru a cauta daca exista un cuvant in alt cuvant se foloseste algoritmul KMP pentru incadrarea in timp - vezi articolul de pe site). Apoi, se construieste un graf cu noduri cuvintele si muchii intre oricare doua cuvinte. Costul unei muchii (i, j) va fi cel mai lung sufix al cuvantului i care este prefix al cuvantului j (informatie care se poate determina cu KMP), adica cate litere sunt \"inutile\" daca lipim cuvantul i cu cuvantul j. Aceasta prima etapa are complexitate O(N^2*L), unde L e lungimea maxima a unui cuvant. Deoarece trebuie sa existe fiecar cuvant in sirul rezultat, iar sirul sa fie de lungime minima problema se reduce la determinarea unui lant hamiltonian de cost maxim, problema care este binecunoscuta ca fiind NP. Un algoritm care incearca toate cele n! permutari are complexitate O(n!) si va obtine 50p. Pentru punctaj maxim vom folosi programare dinamica astfel: fie A[i][(n1, n2.. nk)] = costul unui lant hamiltonian\nde cost maxim care incepe din nodul i si trece prin nodurile n1, n2 .. nk. Relatia de recurenta este: A[i][(n1,n2..nk)] = max cost(i, nj) + A[nj][(n1,n2,nj-1,nj+1..nk)] pentru fiecare j. Dinamica se initializeaza cu A[i][(i)] = 0 pentru fiecare i. Reprezentarea multimilor de noduri se face folosind un numar binar cu N biti, astfel complexitatea acestei etape fiind O(N^2*2^N). Mentionez ca aceasta rezolvare nu produce solutia minim lexicografic, fapt observat in timpul concursului si astfel s-a reevaluat problema dandu-se puncte pentru orice solutie valida, nu neaparat minim lexicografic. Rezolvarea problemei cu cerinta de minim lexicografic este posibila, dar pentru realizarea ei trebuie folosite structuri de date avansate ca Suffix Arrays sau Suffix Trees si nivelul de dificultate ar fi mult mai mare. Alta observarie este ca matricea cost ar putea fi calculata mai repede daca am folosi structurile mentionate mai devreme. Folosind prima structura am avea complexitatea O( N*L log (N*L)) iar a folosind a\ndoua structura am avea complexitatea O(N*L) . De asemenea mentionam posibilitatea folositii algoritmului randomizat de potrivire a sirurilor de caractere numit Rabin Karp pentru calcularea matricii cost ceea ce ar fi dus la o solutie mai scurta si la un cod mai clar. Ne cerem scuze pentru eventualele neplaceri cauzate de aceasta situatie.\n\n\n\nBafta la urmatorul concurs! (undeva prin februarie...)\n\n\n==Include(page=\"template/raw\")==\n\nCum s-a si promis, setul de probleme de data aceasta n-a fost dur, problemele fiind mult mai accesibile, fapt care se vede imediat din punctaje. Spre deosebire de concursurile anterioare in care problemele erau toate de acelasi nivel, de data aceasta a existat o problema usoara, una medie si una grea la fiecare grupa (gen TopCoder).\n\nToti care am participat la compunerea problemelor suntem de parere ca probleme au fost de nivelul ONI, chiar un pic mai usoare. De asemenea, testele au fost create astfel incat sa se poata obtine 190-200p in mod usor de un concurent cu cunostiinte medii care implementeaza solutii corecte dar care nu se incadreaza complet in limita de timp. Din pacate rezultatele sunt un pic sub nivelul asteptarilor, dar speram ca se vor inbunatati in rundele urmatoare! ;)\n\nClasele 9-10\n\nPrimele 5 locuri din clasamentul de la 9-10 arata astfel:\n1. Macarie & Petronela - 270p\n2. Tataroiu Bogdan - 210p\n3. Stefan Andrei - 190p\n4. Ghilea Daniel - 180p\n5. Saveluc Vlad - 170p\n6. Stanescu Lucian - 170p\n\nEste de mentionat faptul ca sub pseudonimul \"Macarie & Petronela\" se \"ascunde\" echipa care va reprezenta Romania la finala ACM, formata din Mugurel Andreica, Marius Andrei si Ghinea Dan. Ei au concurat pe un singur calculator si au rezolvat toate cele 6 probleme propuse pentu a simula un concurs ACM. De asemenea, un lucru remarcabil, concurentul clasat pe locul 2, Tataroiu Bogdan este abia clasa a 7-a! Probabil ca va reprezenta Romania la multe IOI-uri :)\n\nText\n\nProblema a fost cea mai usoara din cele 3 probleme din grupa si rezolvarea nu ar trebui sa ridice mari dificultati nici macar unui elev de a 9-a incepator. Fie N numarul de caractere din fisierul de intrare - voi prezenta o solutie O(N). Se parcurge fisierul caracter cu caracter (nu este necesara stocarea datelor de intrare intr-un vector) si se mentin doua variabile care indica pozitia de inceput si sfarsit a ultimului cuvant detectat pana in prezent, daca s-a gasit vreunul. De asemenea se pastreaza si doua variabile pentru suma lungimilor cuvintelor si numarul de cuvinte pentru a calcula rezultatul. Atentie insa ca la sfarsitul parcurgerii fisierului de iesire, daca ultimul caracter citit a fost o litera mare sau mica, sa se actualizeze numarul de cuvinte si suma lungimilor.\n\nTrapez\n\nProblema a fost cea de nivel mediu din cele 3 si face apel la cunostiinte minime de geometrie. Conditia ca oricare trei puncte nu sunt coliniare simplifica mult rezolvarea. Din definitie, un trapez are cel putin doua laturi paralele deci se poate construi urmatorul algoritm: se iau toate perechile de puncte - acestea determina cate un segment - si sorteaza in functie de unghiul cu axa OX (panta dreptei). Pentru fiecare k segmente cu acelasi unghi se pot forma Comb(k,2) trapeze. Pentru a evita calculele cu reale (care pot cauza erori de precizie), se tin pantele ca perechi de numere intregi (y, x), fara a efectua efectiv impartirea y/x. Pentru compararea a doua astfel de perechi sunt necesare tipuri de date pe 64 de biti. Algoritmul descris are complexitate O(N^2*lg N). Las ca exercitiu rezolvarea acestei probleme folosind un algoritm O(N^2) care foloseste hashing (vezi articolul de pe site). Se puteau obtine 40-50p cu un algoritm brut O(N^4).\n\nSubsir\n\nAceasta problema, care a fost si cea mai grea, a fost prezenta si la CEOI 2003, dar intr-o forma mai simpla. Acolo se cerea generarea efectiva a tuturor subsirurilor , nu numararea lor, si se garanta ca numarul lor este sub 1000. Orice solutie care ar fi luat 100p la problema de la CEOI ar fi obtinut 50p la aceasta (primele 5 teste fiind de fapt preluate de la CEOI 2003). Cum multi probabil au intuit, rezolvarea se bazeaza pe programare dinamica. Voi numi cele doua siruri A si B, de lungime N, respectiv M si voi construi initial matricea C[i][j] = lungimea celui mai lung subsir comun al sirurilor A[1..i] si B[1..j]. Acest lucru se poate face in O(N*M) si este o aplicatie clasica a programarii dinamice (se gaseste in foarte multe carti explicata ideea). In continuare voi numara sirurile folosind un algoritm O(N*M*Sigma) unde Sigma este numarul litere din care pot fi formate sirurile, adica 26. Se va calcula o matrice Nr[i][j] = cate subsiruri comune de lungime maxima existe pentru sirurile A[1..i] si\nB[1..j] (evident modulo 666013). Se calculeaza Nr[i][j] doar atunci cand A[i] = B[j], astfel: pentru fiecare caracter c intre \'a\' si \'z\' se cauta ultima sa aparitie in sirul A[1..i-1] (fie aceasta pozitia ii) si ultima sa aparitie in sirul B[1..j-1] (fie aceasta pozitia jj). Acest lucru se poate face in O(1) daca se preproceseaza inainte aceste informatii in O((N+M)*Sigma). Daca C[i][j] = C[ii][jj]+1 se va aduna Nr[ii][jj] la Nr[i][j] - aceasta conditie ne garanteaza ca subsirurile adaugate au lungime maxima, iar faptul ca ii si jj reprezinta ultima aparitie a caracterului garanteaza ca nu se vor numara subsiruri identice. Pentru a gasi rezultatul final se aduna toate valorile Nr[i][j] calculate, cu urmatoarea exceptie: daca exista pozitiile x si y astfel incat A[x] = A[i] = B[y] = B[j], se aduna Nr[i][j] doar daca x < i si y < j (pentru a asigura ca nu se numara subsiruri identice de mai multe ori).\n\n\n\nClasele 11-12\n\nPrimele 5 locuri din clasamentul de la 11-12 arata astfel:\n1. Simion Filip - 200p\n2. Macarie & Petronela - 190p\n2. Fechete Dan Ionut - 190p\n2. Crestez Leonard - 190p\n3. Bindea Calin - 170p\n4. Grosu Codrut - 140p\n5. Gordon Freeman - 130p\n5. Giurgea Mihnea - 130p\n\nIepuri\n\nProblema a fost cea mai usoara din cel 3 si necesita cunostiine elementare de matematica de clasa a 11-a. Daca se noteaza cu I(n) cati iepuri sunt in ziua n se deduc urmatoarele relatii din enunt:\nI(0)=X, I(1)=Y, I(2)=Z\nI(n)=A*I(n-1) + B*I(n-2) + C*I(n-3) pt n>=3\nRezultatul cerut este I(N) modulo 666013 pentru fiecare test.\nO prima rezolvare, si cea mai simpla, este implementarea directa a relatiei de recurenta si conduce la o complexitate O(N) pe set de date. Aceasta abordare ar fi obtinut 50p.In continuare voi descrie o rezolvare O(lg N) care foloseste matrici. Se construieste matricea:\n\n[0 1 0]\nM = [0 0 1]\n[C B A]\n\ncare sta la baza relatiei:\n\n[I(n) ] [I(n+1)]\nM * [I(n+1)] = [I(n+2)]\n[I(n+2)] [I(n+3)]\n\nDin asta se deduce:\n\n[I(0)] [I(N) ]\nM^N * [I(1)] = [I(N+1)]\n[I(2)] [I(N+2)]\n\nastfel problema se reduce la a calcula M^N in O(lg N). Algoritmul de ridicare la putere in timp logaritmic este clasic si nu-l mai mentionez aici.\n\nBarbar\n\nProblema este de nivel mediu si necesita cunostiinte elementare de teoria grafurilor. Se considera matricea initiala un graf cu R*C noduri, mai putin zidurile. Se face o parcurgere BF pentru a determina pentru fiecare casuta din matrice distanta pana la cel mai apropiat dragon. Astfel, se incepe BF-ul cu toate nodurile care corespund dragonilor inserate in coada (deci nu va fi doar un nod in coada la inceput). Complexitatea acestui pas este O(R*C). Se observa daca exista un traseu valid care trece prin casute situate la distanta >=x fata de cel mai apropiat dragon, atunci exista in mod evident un traseu valid care trece prin casute situate la distanta >=x-1 fata de cel mai apropiat dragon. Aceasta observatie duce la folosirea cautarii binare a rezultatului (vezi articolul de pe site pentru alte aplicatii). Pentru a verifica daca exista un traseu valid care trece doar prin casute situate la o anumita distanta fata de cel mai apropiat dragon se foloseste tot o parcurgere BF, astfel rezolvarea fiind\nO(R*C*lg(R*C)).\n\nADN\n\nLa primul pas se elimina toate cuvintele incluse in alte cuvinte mai mari (pentru a cauta daca exista un cuvant in alt cuvant se foloseste algoritmul KMP pentru incadrarea in timp - vezi articolul de pe site). Apoi, se construieste un graf cu noduri cuvintele si muchii intre oricare doua cuvinte. Costul unei muchii (i, j) va fi cel mai lung sufix al cuvantului i care este prefix al cuvantului j (informatie care se poate determina cu KMP), adica cate litere sunt \"inutile\" daca lipim cuvantul i cu cuvantul j. Aceasta prima etapa are complexitate O(N^2*L), unde L e lungimea maxima a unui cuvant. Deoarece trebuie sa existe fiecar cuvant in sirul rezultat, iar sirul sa fie de lungime minima problema se reduce la determinarea unui lant hamiltonian de cost maxim, problema care este binecunoscuta ca fiind NP. Un algoritm care incearca toate cele n! permutari are complexitate O(n!) si va obtine 50p. Pentru punctaj maxim vom folosi programare dinamica astfel: fie A[i][(n1, n2.. nk)] = costul unui lant hamiltonian\nde cost maxim care incepe din nodul i si trece prin nodurile n1, n2 .. nk. Relatia de recurenta este: A[i][(n1,n2..nk)] = max cost(i, nj) + A[nj][(n1,n2,nj-1,nj+1..nk)] pentru fiecare j. Dinamica se initializeaza cu A[i][(i)] = 0 pentru fiecare i. Reprezentarea multimilor de noduri se face folosind un numar binar cu N biti, astfel complexitatea acestei etape fiind O(N^2*2^N). Mentionez ca aceasta rezolvare nu produce solutia minim lexicografic, fapt observat in timpul concursului si astfel s-a reevaluat problema dandu-se puncte pentru orice solutie valida, nu neaparat minim lexicografic. Rezolvarea problemei cu cerinta de minim lexicografic este posibila, dar pentru realizarea ei trebuie folosite structuri de date avansate ca Suffix Arrays sau Suffix Trees si nivelul de dificultate ar fi mult mai mare. Alta observarie este ca matricea cost ar putea fi calculata mai repede daca am folosi structurile mentionate mai devreme. Folosind prima structura am avea complexitatea O( N*L log (N*L)) iar a folosind a\ndoua structura am avea complexitatea O(N*L) . De asemenea mentionam posibilitatea folositii algoritmului randomizat de potrivire a sirurilor de caractere numit Rabin Karp pentru calcularea matricii cost ceea ce ar fi dus la o solutie mai scurta si la un cod mai clar. Ne cerem scuze pentru eventualele neplaceri cauzate de aceasta situatie.\n\n\n\nBafta la urmatorul concurs! (undeva prin februarie...)\n\n\n\n',0,''),('sandbox','Sandbox','2006-12-04 12:54:57','h1. Sandbox\r\n\r\nFeel free to play around.\r\n\r\nCapsuni.\r\n\r\n\'codetest\':sandbox/code-test\r\n\r\nWhat does \'this\':sandbox?action=edit button do?\r\n\r\nlalallaa\r\n',1142,'public'),('sandbox','Sandbox','2006-11-30 13:45:54','h1. Sandbox\r\n\r\nFeel free to play around.\r\n\r\n\'codetest\':sandbox/code-test\r\n\r\nUuuuu, what does \'this\':sandbox?action=edit button do?\r\n',2145,'public'),('problema/nrtri','Numarare triunghiuri','2006-11-22 02:53:51','==Include(page=\"template/taskheader\" task_id=\"nrtri\")==\r\n\r\nAndrei are $N$ betisoare de lungimi nu neaparat diferite. El vrea sa afle in cate moduri poate alege trei betisoare astfel incat sa poata forma cu ele un triunghi.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se lungimile betisoarelor aflati in cate moduri se pot alege trei dintre ele astfel incat sa se poata forma un triunghi cu ele.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $nrtri.in$ se afla $N$, numarul de betisoare. Pe urmatoarea linie se afla $N$ numere separate prin spatii ce reprezinta lungimile betisoarelor.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $nrtri.out$ contine un singur numar ce reprezinta numarul cerut de problema.\r\n\r\nh2. Restrictii si precizari\r\n\r\n- $1 &le; N &le; 800$\r\n- $1 &le; lungimea unui betisor &le; 30000$\r\n- se considera triunghiuri si cele care au un unghi de $180$ de grade si celelalte doua de $0$ grade ({$2$} segmente coliniare se confunda cu al $3-lea$)\r\n- pentru $75$ de puncte se garanteaza $1 &le; N &le; 150$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. nrtri.in |_. nrtri.out |\r\n| 4\r\n  2 3 6 2\r\n| 2 |\r\n\r\nh3. Explicatii\r\n\r\nSingurele triunghiuri care se pot forma sunt alcatuite din urmatoarele betisoare (date prin numarul de ordine): \r\n1, 2, 4\r\n2, 3, 4 \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"nrtri\")==',1,'task: nrtri'),('usaco-oct-2005-divizia-gold','USACO oct 2005, divizia GOLD','2005-11-21 00:00:00','h1. USACO oct 2005, divizia GOLD\n\n(Creat de \'_greco_\':user/greco la data de _2005-11-21_ categoria _Competitii_, autor(i) _Florea Tiberiu_)\n\n*Continut scurt:*\n Ca de obicei, USACO debuteaza in luna octombrie cu un concurs prin care oricine se poate califica la o divizie superioara celei in care se afla.\nRomania a avut 8 concurenti care s-au calificat (sau recalificat) la divizia GOLD, fiind depasita in acest clasament doar de China (16) si SUA (10).\n==Include(page=\"template/raw\")==\n\nCa de obicei, USACO debuteaza in luna octombrie cu un concurs prin care oricine se poate califica la o divizie superioara celei in care se afla.\nRomania a avut 8 concurenti care s-au calificat (sau recalificat) la divizia GOLD, fiind depasita in acest clasament doar de China (16) si SUA (10).\n\n\n*Continut lung:*\nCa de obicei, USACO debuteaza in luna octombrie cu un concurs prin care oricine se poate califica la o divizie superioara celei in care se afla.\n\nRomania a avut 8 concurenti care s-au calificat (sau recalificat) la divizia GOLD, fiind depasita in acest clasament doar de China (16) si SUA (10). Bineinteles, acest clasament nu este foarte relevant, deoarece multi dintre cei calificati deja au preferat sa nu participe sau sa nu ia concursul foarte in serios.\n\nElevii romani care au obtinut punctajul necesar pentru (re)calificare sunt:\n\n- Andrei Teodorescu (andreit1)\n- Vladu Adrian (azotlic1)\n- Andrei Blanaru (blanaru1)\n- Sorin Fagateanu (cyronon1)\n- Ionel Corneliu Gog (gogione1)\n- Tiberiu Florea (greco2)\n- Pasoi Mircea (mircea_1)\n- Vlad Berteanu (vladcyb1)\n\nProba a constat in 2 probleme de nivel mediu care trebuiau rezolvate in 2 ore.\n\nSkiing\n\nPrima rezolvare care ne vine in minte citind o astfel de problema este transformarea matricii intr-un graf cu R * C noduri si calcularea drumului minim dintre nodurile (1, 1) si (R, C). O observatie destul de evidenta este ca toate muchiile care intra intr-un nod (a, b) vor avea acelasi cost, adica V * 2 ^ (H[1][1] - H[a][b]). Deoarece implementarea obisnuita a algoritmului Dijkstra are complexitatea O (N^2 + M) considerand N = numarul de pozitii si M numarul de muchii dintre acestea (N = R * C, M = 4 * R * C - 2 * (R + C)) va trebui implementata varianta in care se foloseste o coada de prioritate pentru nodurile care nu au fost explorate deja: implementand varianta cu heap-uri vom obtine complexitatea O ((N + M) * lg N), care se incadreaza in timp.\n\nPentru cei care nu sunt familiari cu aceasta varianta a algoritmului, ea arata cam asa:\n\nD[sursa] <- 0\n\nheap[heap_sz = 1] <- sursa\n\npentru i de la 1 la N\n\ndaca i != sursa\n\nD[i] <- oo\n\nheap_sz <- heap_sz + 1\n\nheap[heap_sz] <- i\n\ncat timp heap_sz > 0\n\nx <- extrage_min (heap)\n\ndaca x = destinatie\n\nreturneaza D[x]\n\naltfel\n\npentru i de la 1 la N\n\ndaca D[i] > D[x] + cost (x, i)\n\ndescreste_cheie (i, D[x] + cost (x,i))\n\nFiecare nod este extras cel mult o data din heap, si pentru fiecare muchie este apelata cel mult o data functia descreste_cheie. Fiecare dintre aceste operatii se efectueaza in O (lg N), de aici rezultand complexitatea dorita.\n\nDe asemenea, putea fi aplicata o alta varianta a algoritmului Dijkstra, care profita mai mult de specificul problemei: In afara de vectorul estimarilor distantelor pana la fiecare nod, se memoreaza si nodul cu estimarea minima de pe fiecare din cele R linii. Astfel, in momentul in care se extrage fiecare nod, cautam minimul in acest vector de dimensiune R, iar apoi reactualizam valoarea liniei pe care se afla nodul curent. Complexitatea acestui algoritm este O (N * R), adica O (R^2 * C).\n\nIn implementarea oricaruia dintre acesti algoritmi trebuiau avute in vedere eventualele probleme cu precizia calculelor; o idee buna era ca numai costul final sa se inmulteasca cu V.\n\nFlying right\n\nAceasta problema poate fi rezolvata cu ajutorul unui algoritm greedy, ideea nu este greu de gasit sau demonstrat, insa la implementare pot aparea unele probleme. In primul rand trebuie sa remarcam ca cele doua parti ale problemei se vor rezolva independent una de cealalta, drumurile se vor imparti in 2 multimi (cele de dimineata, si cele de seara), si se va aplica aceeasi rezolvare pentru fiecare din cele doua multimi, raspunsul final fiind suma celor doua rezultate partiale. Rezolvarea urmatoare trateaza calcularea rezultatului optim pentru drumurile de dimineata.\n\nPentru fiecare din cele N ferme tinem o lista de grupuri care doresc sa plece din orasul respectiv si sortam aceste liste crescator dupa indicele destinatiei fiecarui grup. Parcurgem in ordine cele N ferme, memorand numarul si destinatiile vacilor care se afla la un moment dat in avion, sortate in ordine descrescatoare. In momentul in care am ajuns la ferma i, primul lucru pe care trebuie sa il facem este sa dam jos vacile care au ajuns la destinatie, incrementand corespunzator solutia de pana atunci. Evident, vacile care coboara la ferma respectiva se vor afla pe ultimele pozitii in ordinea descrisa din avion. Urmatorul pas este sa luam in avion din vacile care pleaca de la ferma i pana cand acestea sunt epuizate sau capacitatea avionului este saturata. Daca au mai ramas vaci care nu au avut loc in avion, atata timp cat putem lua o vaca a carei destinatie este mai apropiata decat cea mai departata dintre destinatiile vacilor care se afla deja in avion, consideram ca vaca respectiva din avion nu a fost\nluata deloc, si ca alocam locul ei noii vaci, care va cobori mai repede.\n\nEste usor de vazut ca algoritmul de mai sus produce o solutie optima, insa implementarea sa nu este foarte lejera. Putem folosi urmatoarea metoda (v este un vector in care retinem destinatiile vacilor care se afla in avion, sortate descrescator):\n\nsol = 0, nr <- 0\n\npentru i de la 1 la N\n\ncat timp nr > 0 si v[nr] = i\n\nsol <- sol + 1\n\nnr <- nr - 1\n\npentru j <- 1, j <= C si j <= nr vaci ce\n\nasteapta sa plece de la ferma i\n\nnr <- nr + 1\n\nv[nr + 1] = distanta celei de-a j-a vaci\n\n(in ordinea crescatoare a\n\ndestinatiilor) de la ferma i\nsorteaza v\npastreaza primele maxim C pozitii din v\n\nLa fiecare pas, vectorul v poate fi sortat folosind qsort (stdlib.h) sau sort (algorithm). Este necesar sa adaugam in v doar primele C vaci de la ferma i, deoarece daca o vaca nu este intre primele C din multimea vacilor de la ferma i, este evident ca nu va fi nici intre primele C din reuniunea acestei multimi cu multimea vacilor aflate deja in avion.\n\nSa recapitulam pasii algoritmului, alaturi de complexitatea fiecaruia dintre ei:\n\n- sortarea tuturor grupurilor dupa destinatie: O (K * lg K)\n- parcurgerea grupurilor si inserarea in listele corespunzatoare: O (K)\n- parcurgerea fermelor de la 1 la N, aplicand procedeul descris: O (N * C * lg C)\n\nAsadar, complexitatea totala a algoritmului este de O (K * lg K + N * C * lg C), dand un timp de rulare rezonabil si o implementare fara mari batai de cap.\n==Include(page=\"template/raw\")==\n\nCa de obicei, USACO debuteaza in luna octombrie cu un concurs prin care oricine se poate califica la o divizie superioara celei in care se afla.\n\nRomania a avut 8 concurenti care s-au calificat (sau recalificat) la divizia GOLD, fiind depasita in acest clasament doar de China (16) si SUA (10). Bineinteles, acest clasament nu este foarte relevant, deoarece multi dintre cei calificati deja au preferat sa nu participe sau sa nu ia concursul foarte in serios.\n\nElevii romani care au obtinut punctajul necesar pentru (re)calificare sunt:\n\n- Andrei Teodorescu (andreit1)\n- Vladu Adrian (azotlic1)\n- Andrei Blanaru (blanaru1)\n- Sorin Fagateanu (cyronon1)\n- Ionel Corneliu Gog (gogione1)\n- Tiberiu Florea (greco2)\n- Pasoi Mircea (mircea_1)\n- Vlad Berteanu (vladcyb1)\n\nProba a constat in 2 probleme de nivel mediu care trebuiau rezolvate in 2 ore.\n\nSkiing\n\nPrima rezolvare care ne vine in minte citind o astfel de problema este transformarea matricii intr-un graf cu R * C noduri si calcularea drumului minim dintre nodurile (1, 1) si (R, C). O observatie destul de evidenta este ca toate muchiile care intra intr-un nod (a, b) vor avea acelasi cost, adica V * 2 ^ (H[1][1] - H[a][b]). Deoarece implementarea obisnuita a algoritmului Dijkstra are complexitatea O (N^2 + M) considerand N = numarul de pozitii si M numarul de muchii dintre acestea (N = R * C, M = 4 * R * C - 2 * (R + C)) va trebui implementata varianta in care se foloseste o coada de prioritate pentru nodurile care nu au fost explorate deja: implementand varianta cu heap-uri vom obtine complexitatea O ((N + M) * lg N), care se incadreaza in timp.\n\nPentru cei care nu sunt familiari cu aceasta varianta a algoritmului, ea arata cam asa:\n\nD[sursa] <- 0\n\nheap[heap_sz = 1] <- sursa\n\npentru i de la 1 la N\n\ndaca i != sursa\n\nD[i] <- oo\n\nheap_sz <- heap_sz + 1\n\nheap[heap_sz] <- i\n\ncat timp heap_sz > 0\n\nx <- extrage_min (heap)\n\ndaca x = destinatie\n\nreturneaza D[x]\n\naltfel\n\npentru i de la 1 la N\n\ndaca D[i] > D[x] + cost (x, i)\n\ndescreste_cheie (i, D[x] + cost (x,i))\n\nFiecare nod este extras cel mult o data din heap, si pentru fiecare muchie este apelata cel mult o data functia descreste_cheie. Fiecare dintre aceste operatii se efectueaza in O (lg N), de aici rezultand complexitatea dorita.\n\nDe asemenea, putea fi aplicata o alta varianta a algoritmului Dijkstra, care profita mai mult de specificul problemei: In afara de vectorul estimarilor distantelor pana la fiecare nod, se memoreaza si nodul cu estimarea minima de pe fiecare din cele R linii. Astfel, in momentul in care se extrage fiecare nod, cautam minimul in acest vector de dimensiune R, iar apoi reactualizam valoarea liniei pe care se afla nodul curent. Complexitatea acestui algoritm este O (N * R), adica O (R^2 * C).\n\nIn implementarea oricaruia dintre acesti algoritmi trebuiau avute in vedere eventualele probleme cu precizia calculelor; o idee buna era ca numai costul final sa se inmulteasca cu V.\n\nFlying right\n\nAceasta problema poate fi rezolvata cu ajutorul unui algoritm greedy, ideea nu este greu de gasit sau demonstrat, insa la implementare pot aparea unele probleme. In primul rand trebuie sa remarcam ca cele doua parti ale problemei se vor rezolva independent una de cealalta, drumurile se vor imparti in 2 multimi (cele de dimineata, si cele de seara), si se va aplica aceeasi rezolvare pentru fiecare din cele doua multimi, raspunsul final fiind suma celor doua rezultate partiale. Rezolvarea urmatoare trateaza calcularea rezultatului optim pentru drumurile de dimineata.\n\nPentru fiecare din cele N ferme tinem o lista de grupuri care doresc sa plece din orasul respectiv si sortam aceste liste crescator dupa indicele destinatiei fiecarui grup. Parcurgem in ordine cele N ferme, memorand numarul si destinatiile vacilor care se afla la un moment dat in avion, sortate in ordine descrescatoare. In momentul in care am ajuns la ferma i, primul lucru pe care trebuie sa il facem este sa dam jos vacile care au ajuns la destinatie, incrementand corespunzator solutia de pana atunci. Evident, vacile care coboara la ferma respectiva se vor afla pe ultimele pozitii in ordinea descrisa din avion. Urmatorul pas este sa luam in avion din vacile care pleaca de la ferma i pana cand acestea sunt epuizate sau capacitatea avionului este saturata. Daca au mai ramas vaci care nu au avut loc in avion, atata timp cat putem lua o vaca a carei destinatie este mai apropiata decat cea mai departata dintre destinatiile vacilor care se afla deja in avion, consideram ca vaca respectiva din avion nu a fost\nluata deloc, si ca alocam locul ei noii vaci, care va cobori mai repede.\n\nEste usor de vazut ca algoritmul de mai sus produce o solutie optima, insa implementarea sa nu este foarte lejera. Putem folosi urmatoarea metoda (v este un vector in care retinem destinatiile vacilor care se afla in avion, sortate descrescator):\n\nsol = 0, nr <- 0\n\npentru i de la 1 la N\n\ncat timp nr > 0 si v[nr] = i\n\nsol <- sol + 1\n\nnr <- nr - 1\n\npentru j <- 1, j <= C si j <= nr vaci ce\n\nasteapta sa plece de la ferma i\n\nnr <- nr + 1\n\nv[nr + 1] = distanta celei de-a j-a vaci\n\n(in ordinea crescatoare a\n\ndestinatiilor) de la ferma i\nsorteaza v\npastreaza primele maxim C pozitii din v\n\nLa fiecare pas, vectorul v poate fi sortat folosind qsort (stdlib.h) sau sort (algorithm). Este necesar sa adaugam in v doar primele C vaci de la ferma i, deoarece daca o vaca nu este intre primele C din multimea vacilor de la ferma i, este evident ca nu va fi nici intre primele C din reuniunea acestei multimi cu multimea vacilor aflate deja in avion.\n\nSa recapitulam pasii algoritmului, alaturi de complexitatea fiecaruia dintre ei:\n\n- sortarea tuturor grupurilor dupa destinatie: O (K * lg K)\n- parcurgerea grupurilor si inserarea in listele corespunzatoare: O (K)\n- parcurgerea fermelor de la 1 la N, aplicand procedeul descris: O (N * C * lg C)\n\nAsadar, complexitatea totala a algoritmului este de O (K * lg K + N * C * lg C), dand un timp de rulare rezonabil si o implementare fara mari batai de cap.\n\n',0,''),('agora-finala','Bursele agora, editia 6, finala online','2006-11-24 16:48:31','h1. Bursele agora, editia 6, finala online\r\n\r\nAceasta este runda finala online a concursului \"Bursele Agora\", editia 6. Concursul a fost organizat de catre redactia revistei GInfo si Editura Agora Media. Concursul s-a desfasurat pe 9 iulie 2005. Puteti vedea \'clasamentul\':agora-finala/clasament, cat si un articol cu \'solutii\':agora-finala/solutii.\r\n\r\n!>agora-finala?logo.gif!\r\n== Tasks(round_id=\"ba6\" pager_style=\"none\")==',1,'protected'),('template/preoni-2006/finalrankings','template/preoni-2006/finalrankings','2006-12-01 18:10:32','==include(page=\"template/preoni-2006/header\")==\r\n\r\np={font-weight: bold}. &larr; \"preONI 2006 Homepage\":preoni-2006 | \"Clasa a IX-a si gimnaziu\":preoni-2006/finala/clasament-9 | \"Clasa a X-a \":preoni-2006/finala/clasament-10 | \"Clasele XI-XII\":preoni-2006/finala/clasament-11-12\r\n\r\nh1. Finala preONI 2006',13,'public'),('sandbox','Sandbox','2006-11-28 20:46:22','h1. Sandbox\r\n\r\nFeel free to play around.\r\n\r\n\'codetest\':sandbox/code-test\r\n\r\nUuuuu, what does this button do?\r\n',1142,'public'),('preoni-2006/runda-1/solutii','Solutii preONI 2006 - Runda 1','2006-11-28 14:22:56','h1. Solutii preONI 2006 - Runda 1\r\n\r\n(Categoria _Competitii_, autor(i) _Echipa infoarena_)\r\n\r\nRunda 1 a concursului preONI 2006 s-a incheiat. Acest articol contine solutiile oficiale pentru toate probleme propuse spre rezolvare, cat si comentarii referitoare la concurs.\r\n\r\nFiecare grupa a avut spre rezolvare 3 probleme, fiecare fiind catalogata de catre comisie ca fiind usoara, medie sau grea. Batalia pentru calificarea la finala este abia la inceput!\r\n\r\nPentru mai multe detalii despre finala, cat si despre concursul preONI 2006 si sponsorii nostri va rugam sa consultati \"pagina preONI-2006\":preONI-2006.\r\n\r\nRezultatele finale sunt disponibile la:\r\n\r\n* \"Clasa a 9-a\":http://infoarena.devnet.ro/index.php?page=stats&conid=preoni61a&smod=top\r\n* \"Clasa a 10-a\":http://infoarena.devnet.ro/index.php?page=stats&conid=preoni61b&smod=top\r\n* \"Clasele 11-12\":http://infoarena.devnet.ro/index.php?page=stats&conid=preoni61c&smod=top\r\n\r\nDin pacate, punctajele la clasele a 9-a si a 10-a sunt sub asteptarile comisiei. Pentru discutii despre dificultate problemelor si despre concursul preONI 2006 in general va invitam sa intrati pe \"forum\":http://forum.infoarena.ro/index.php/board,20.0.html.\r\n\r\nInainte de a va prezenta solutiile va invitam sa rezolvati problemele propuse la acest concurs in \"Arhiva de probleme infoarena\":http://infoarena.ro/arhiva-probleme, si va asteptam in forta la runda a 2-a a concursului! (17 decembrie 2005)\r\n\r\nh2. Reuniune\r\n\r\nh3. (clasa a 9-a problema usoara)\r\n\r\nVom considera cazul simplificat cu $2$ dreptunghiuri $A$ si {$B$}, pentru care putem obtine formulele:\r\n\r\n* $Arie(A + B) = Arie(A) + Arie(B) - Arie(A x B)$\r\n* $Perim(A + B) = Permi(A) + Perim(B) - Perim(A x B)$\r\n\r\n({$A+B$} reprezinta reuniunea multimilor $A$ si {$B$}, iar $AxB$ intersectia.)\r\n\r\nCazul cu $3$ dreptunghiuri {$A$}, {$B$}, $C$ se rezolva similar. Cea mai simpla metoda este de a \"vizualiza\" formula facand un desen. Mai jos aveti un astfel de desen ajutator.\r\n\r\n!preoni-2006/runda-1/solutii?reuniune.png!\r\n\r\nAsadar, obtinem formula:\r\n\r\n* $Arie(A+B+C) = Arie(A) + Arie(B) + Arie(C) - Arie(AxB) - Arie(BxC) - Arie(AxC) + Arie(AxBxC)$\r\n\r\n(pentru perimetru formula este asemanatoare)\r\n\r\nAstfel rezolvarea este {$O(1)$}, deoarece intersectia a $2$ sau $3$ dreptunghiuri poate fi calculata usor in timp constant. Mentionam ca formula de mai sus poate fi gasita si pe cale algebrica, si reprezinta un caz particular al principiului includerii si excluderii.\r\n\r\nh2. Patrate 2\r\n\r\nh3. (clasa a 9-a problema medie)\r\n\r\nMai intai sa completam matricea doar cu $1$ si $5$ astfel incat produsul elementelor de pe fiecare linie sau coloana sa fie {$5$}. Observam ca pe fiecare linie si pe fiecare coloana se plaseaza exact un {$5$}, restul matricii fiind completata cu {$1$}. Este evident ca fiecare permutare a multimii ({$1, 2 * N$}) reprezinta de fapt o posibilitate de aranjare a numarului $5$ in matrice, iar de aici deducem ca numarul de posibilitati de a completa matricea doar cu $1$ si $5$ este $P{~N~}$ (adica {$N!$}). Cum putem folosi si $-1$ si {$-5$}, rezultatul final va fi $2^N*N^*N!$\r\n\r\nLa implementare trebuie sa se efectueze operatii cu numere mari. De asemenea, se recomanda ca baza in care se lucreaza trebuie sa fie destul de mare pentru a se obtine eficienta dorita.\r\n\r\nh2. Invers (solutie oferita de Bogdan Tataroiu)\r\n\r\nh3. (clasa a 9-a problema grea, clasa a 10-a problema usoara)\r\n\r\nRezolvarea acestei probleme presupune parcurgerea numarului ce trebuie verificat (il vom nota cu {$v$}) din exterior spre interior. Notam cu s pozitia extremitatii stangi al numarului, iar cu $d$ pozitia extremitatii drepte. Astfel numarul $v$ este format prin adunarea unor numere de forma\r\n\r\n* $a{~1~} a{~2~} a{~3~} ... a{~n-2~} a{~n-1~} a{~n~}$\r\n* $a{~n~} a{~n-1~} a{~n-2~} ... a{~3~} a{~2~} a{~1~}$\r\n\r\nAsadar, prin adunarea cifrelor $a{~i~}$ si $a{~n-1+1~}$ se poate obtine un transport care va afecta cifrele anterioare. Deoarece sirul este parcurs de la extremitati spre interior $s$ va fi egal cu {$i$}, iar $d$ va fi egal cu {$n - i + 1$}, deci cifrele $v{~s~}$ si $v{~d~}$ sunt formate prin adunarea cifrelor $a{~i~}$ si {$a{~n-i+1~}$}.\r\nIn parcurgerea sirului de la extremitati catre interior cazul ideal este atunci cand $v{~s~}$ este egal cu {$v{~d~}$}, caz in care cifra $v{~s~}$ nici nu primeste si nici nu trimite transport la cifrele aflate pe pozitii anterioare.\r\n\r\nUn alt caz este cel in care $v{~s~}$ primeste transport prin adunarea cifrelor $a{~s+1~}$ si $a{~d-1~}$ (vezi schema de mai sus pentru a intelege acest lucru). In acest caz $v{~s~}$ este egal cu $v{~d~}+1$ si, pentru a tine cont de faptul ca pozitia $s+1$ a generat transport, adaugam la $v{~s+1~}$ valoarea {$10$}.\r\n\r\nUn al treilea caz este acela in care $v{~s~}$ da transport pentru cifra $v{~s-1~}$ si nu primeste transport de la {$s+1$}, in acest caz $v{~s~}$ fiind egal cu $v{~d~}+10$ (acel $10$ fiind adaugat la pasul anterior). Deoarece atat $v{~s~}$ cat si $v{~d~}$ sunt obtinute prin adunarea cifrelor $a{~s~}$ si {$a{~d~}$}, iar $v{~s~}$ da transport cifrelor anterioare, atunci si $v{~d~}$ da transport cifrelor anterioare. Pentru a corecta acest lucru cifra $v{~d-1~}$ trebuie decrementata, avand grija la cazurile in care $v{~d-1~}$ este egal cu {$0$}. De asemenea trebuie luat in calcul cazul in care $v{~d~}$ este egal cu $9$ si {$v{~s~}=19$}. Acest lucru este imposibil deoarece suma maxima a doua cifre este $18$ si, evident, va trebui sa se afiseze raspunsul {$NU$}.\r\n\r\nAl patrulea si ultimul caz este acela in care $v{~s~}$ da transport cifrei $v{~s-1~}$ si, in acelasi timp, primeste transport de la cifrele aflate pe pozitia {$s+1$}. In acest caz $v{~s~}=v{~d~}+11$ si trebuie executate atat operatiile pt cazul {$v{~s~}=v{~d~}+1$}, cat si cele pentru cazul {$v{~s~}=v{~d~}+10$}.\r\nDaca diferenta $v{~s~}-v{~d~}$ este diferita de {$0$}, {$1$}, $10$ si $11$ atunci numarul $v$ nu poate fi obtinut prin adunarea unui numar $a$ cu inversul sau.\r\nAlgoritmul se repeta pana cand $s$ devine egal cu {$d$}, caz in care cifra $v{~s~}=v{~d~}$ trebuie sa fie para pentru ca numarul $v$ sa indeplineasca conditia din enunt sau pana cand {$d=s+1$}, caz in care trebuie ca $v{~s~}=v{~d~}$ sau $v{~s~}=v{~d~}+11$ pentru ca numarul $v$ sa aiba proprietatea ceruta. \r\n\r\nSe mai considera cazul cand {$a{~1~}=0$}, iar {$v{~1~}=1$},obtinut printr-un transport : se aduna $10$ la {$v{~2~}$} si se considera numarul incepand de la pozitia a doua, caruia i se verifica validitatea. Atentie la cazuri particulare!\r\n\r\nPentru a intelege mai bine algoritmul general vom analiza urmatorul exemplu: {$7 2 2 3 2 6$}.\r\nObservand ca $7=6+1$ tragem concluzia ca prima cifra va trebui sa primeasca transport, deci vom analiza {$12 2 3 2$}. Observam din nou ca {$12=2+10$} ceea ce inseamna ca $12$ trebuie sa trimita transport in fata, deci si $2$ din coada va fi de fapt {$12$}. Vom lua inapoi transportul de la {$3$}, deci vom analiza in continuare {$2 2$}. Acestea fiind egale nu se primeste si nu se da transport. Deoarce nu sa dat peste nici o contradictie raspunsul va fi {$DA$}.\r\n\r\nComplexitatea acestui algoritm este $O(nr)$ pe test, unde $nr$ este numarul de cifre al numarului {$v$}.\r\n\r\nh2. Dreptunghi\r\n\r\nh3. (clasa a 10-a problema medie)\r\n\r\nUn dreptunghi care apare in grila de puncte laticiale e marginit de doua drepte verticale la stanga si la dreapta, si de doua drepte orizontale in sus si in jos. Acum, daca vrem pentru patru drepte fixate sa stim cate dreptunghiuri marginesc ele, ne putem uita la urmatorul desen.\r\n\r\n!preoni-2006/runda-1/solutii?drept.jpg!\r\n\r\nDaca dreptunghiul determinat de cele patru drepte are laturile $H$ si $W$ atunci un dreptunghi inscris va imparti laturile lui in bucatile {$A$}, $B$ si {$C$}, {$D$}. Acum folosind teorema lui Pitagora avem ca:\r\n\r\n* $A^2^ + D^2^ = Galben^2^$\r\n* $B^2^ + C^2^ = Verde^2^$\r\n* $Galben^2^ + Verde^2^ = Roz^2^$\r\n* $(A + B)^2^ = Rosu^2^$\r\n* $(C * D)^2^ = Albastru^2^$\r\n* $Rosu^2^ + Albastru^2^ = Roz^2^$\r\n\r\nDe aici avem ca {$(A + B)^2^ + (C * D)^2^ =A^2^ + B^2^ + C^2^ + D^2^$}, astfel obtinem {$AB = CD$}, dar {$B = H * A$}, iar {$D = W * C$} deci avem ca {$C^2^ * WC + A(H * A) = 0$}. Daca il fixam pe $A$ atunci trebuie sa rezolvam o ecuatie de gradul doi in necunoscuta {$C$}, solutia trebuie sa fie intreaga intre $0$ si {$W$}.\r\n\r\nAstfel in $O(H)$ vom sti numarul de dreptunghiuri inscrise intr-un dreptunghi de dimensiuni {$H * W$}. Acest dreptunghi poate fi pus in $(N * H + 1) * (M * H + 1)$ locatii pe o grila de dimensiune {$N * M$}. Deci solutia are complexitate {$O(N*M^2^)$}, pentru fiecare dreptunghi de dimensiuni $1$ &le; H &le; N$ si $1 &le; W &le; M$ calculandu-se numarul de dreptunghiuri inscrise.\r\n\r\nO rezolvare de complexitate $O(N^2^*M^2^)$ in care se cautau solutiile ecuatiei printr-un for ar fi luat $60$ de puncte. Rezolvarea directa folosind ecuatia de gradul doi ia in jur de $80$ de puncte. Algoritmul poate fi optimizat la factorii constanti, de exemplu avem nevoie de functia radical care este cam inceata, precalculand-o obtinem o accelerare a vitezei, alta idee ar fi ca numarul de solutii cu $A &le; H/2$ este egal cu numarul de solutii cu $A &ge; H * H/2$ si a treia idee de optimizare este ca numarul de dreptunghiuri inscrise intr-un dreptunghi de dimensiuni {$H$}, $W$ este acelasi cu numarul de dreptunghiuri inscrise intr-un dreptunghi de dimensiuni {$W$}, {$H$}.\r\n\r\nh2. Zebughil\r\n\r\nh3. (clasa a 10 problema grea, clasele 11-12 problema medie)\r\n\r\nSe poate aborda o rezolvare bazata pe parcurgerea numerelor de la $1$ la $3^n^-1$ in ordine. Pastram matricea best in care retinem numarul minim de camioane in care pot fi transportate blocurile date de bitii de $1$ din {$i$}. Completarea acestei matrici se face in {$O(3^n^)$}. Descompunerea in baza $3$ va avea urmatoarea semnificatie: $0$ - blocul nu e in multimea curenta, $1$ - blocul se afla in ultimul camion sau $2$ - blocul se afla intr-un camion anterior in care nu se mai poate aduaga.\r\n\r\nAceasta idee aduce $90$ de puncte daca este implementata corect. O alta solutie se poate obtine daca avem in vedere faptul ca avem limita superioara $500$ pentru capacitatea unui camion putem face o rezolvare ce foloseste principiul programrii dinamice. Vom folosi o matrice $best{~i,j~}$ care retine numarul minim de camioane astfel incat sa putem transporta blocurile identificate de bitii de $1$ din reprezentarea in baza $2$ a lui {$i$}, iar ultimul camion sa fie plin pana la capacitatea {$j$}. Aceasta solutie ar fi obtinut $70$ de puncte.\r\n\r\nDeoarece fie folosim maxim $n$ camioane fie nu avem solutie putem incerca construirea unei matrici {$best{~i,j~}$} cu semnificatia cat mai este liber in ultimul camion ca sa avem transportati bitii de $1$ din $i$ si sa folosim maxim $j$ camioane. Completarea acestei matrici se face in {$O(2^n^*n^2^)$}, aducand 100 de puncte.\r\n\r\nAnalizand mai departe observam ca nu este nevoie sa retinem pentru o configuratie decat solutia folosind numar minim de camioane deoarece daca am folosi mai multe putem pur si simplu sa incepem unul nou acuma care va avea capacitate {$G$}. Astfel complexitatea de memorie se reduce la {$O(2^n^)$} iar cea de timp la $O(2^n^*n)$\r\n\r\nO alta abordare interesanta a problemei dar care nu ducea la obtinerea unui punctaj maxim este generarea permutarilor prin backtracking si testarea greedy a solutiei. Parcurgem permutarea si cand avem nevoie de un camion nou il deschidem. Aceasta ar avea o complexitatea {$O(n!*n)$}. Putem insa retine pe parcurs costul pana in acel moment si la sfarsit sa nu trebuiasca sa mai parcurgem din nou. Pentru generarea permutarilor se poate retine o lista cu elementele care nu au fost inca puse in permutare lista in care un element se va adauga si se va scoate in {$O(1)$}. Aceasta tehnica se numeste dancing links si duce la o complexitate totala de $O(n!)$\r\n\r\nO abordare neortodoxa ar fi fost generarea aleatoare a permutarilor, astfel pornim de la o permutare initiala si luam doua elemente din permutare in mod aleator pe care le interschimbam, daca solutia obtinuta e mai buna sau cel putin egala cu solutia initiala (valoarea unei solutii o vedem folosind un algoritm greedy care baga in ordine elementele in camioane) atunci pastram solutia curenta, iar daca nu interschimbam elementele la loc. O asemenea tehnica de optimizare a solutiei ar fi dus la un punctaj de aproximativ $60$ de puncte.\r\n\r\nh2. Distante\r\n\r\nh3. (clasele 11-12, problema usoara)\r\n\r\nFoarte multi concurenti au incercat sa rezolve aceasta problema folosind algoritmul Dijkstra cu heap-uri sau cu arbori de intervale. Aceasta solutie ar fi obtinut de la $70$ pana la $100$ de puncte (in cazul in care se optimiza algoritmul). O alta metoda de a obtine $100$ de puncte ar fi fost folosirea algoritmul Bellman Ford cu coada (vezi OJI 2004, problema \"Lanterna\":http://infoarena.ro/task/lanterna).\r\n\r\nSolutia oficiala (care este de fapt si cea mai simpla si cea mai usor de implementat) are complexitate $O(N+M)$ ca timp si $O(N)$ ca memorie. Ea poate fi dedusa din modul de functionare a algoritmilor Dijkstra sau Bellman Ford. Asadar, conditile suficiente si necesare ca distantele minime date sa fie corecte sunt:\r\n\r\n* $D{~S~} = 0$\r\n* $D{~x~} + cost(x, y) &ge; D{~y~}$ pentru orice muchie ({$x, y$})\r\n* exista pentru fiecare $y$ (diferit de {$S$}) un $x$ astfel incat $D{~x~} + cost(x, y) = D{~y~}$\r\n\r\nStudiati modul in care functioneaza Dijkstra sau Bellman Ford si veti vedea ca logica acestor conditii devine evidenta. Verificarea acestor conditii se poate face in complexitatea mentionata mai sus.\r\n\r\nh2. Balans\r\n\r\nh3. (clasele 11-12, problema grea)\r\n\r\nProblema a fost gandita sa rasplateasca pe \"fanii infoarena\" si anume pe aceea care au rezolvat corect problemele \"Secventa 1\":http://infoarena.ro/task/secventa, \"Secventa 2\":http://infoarena.ro/task/secv2, \"Secventa 3\":http://infoarena.ro/task/secv3. Pentru a trata circularitatea matricii o vom extinde intr-o matrice 2N*2M, lipind matrii initiale o copie la dreapta, sub ea, si la dreapta-jos.\r\n\r\nRezolvarea acum se va baza pe cautarea binara a balansului maxim (idee folosita si la rezolvarea problemei \"Secventa 3\":http://infoarena.ro/task/secv3). Fie acesta {$X$}, trebuie sa verificam daca exista o submatrice cu balans cel putin {$X$}, adica:\r\n\r\n* $Suma / Numar &ge; X$\r\n* $Suma &ge; X*Numar$\r\n* $Suma - X*Numar &ge; 0$\r\n\r\nFolosind cele scrise mai sus, putem observa ca, daca fiecare element nr din matricea intiala este inlocuit cu {$nr-X$}, atunci problema se reduce la a determina o submatrice din matricea modificata in care suma elementelor este {$&ge; 0$}. Aceasta problema se poate rezolva determinand submatricea de suma maxima din matricea modificata, verificand apoi daca este {$&ge; 0$}.\r\n\r\nAsadar, problema s-a redus la a determina o submatrice de cel putin $R$ linii si $C$ coloane de suma maxima dintr-o matrice. Intai vom fixa $2$ linii la distanta cel putin $R$ si cel mult {$N$}, si vom calcula sumele pe coloane intre cele doua linii (acest lucru se poate face in $O(M)$ precalculand anumite sume la inceput). Pe vectorul de sume pe coloane obtinut va trebui sa rezolvam acum problema \"secventei de suma maxima de lungime intre {$C$} si {$M$}\" (necesara si la rezolvarea problemei \"Secventa 3\":http://infoarena.ro/task/secv3). Fie $A$ vectorul pe care vrem sa rezolvam acesta problema, si {$S{~i~} = A{~1~}&#0043;A{~2~}&#0043;...&#0043;A{~i~}$}. Pentru fiecare $i$ va trebui sa gasim un $j$ astfel incat:\r\n\r\n* $S[i] - S[j]$ = maxim\r\n* $i-M &le; j &le; i-C$\r\n\r\nAcest lucru se poate face in $O(M)$ per total folosind structura \"deque\" , prezentata pe scurt si in articolul cu solutii de la preONI 2005, runda 3. Lasam detalierea modului in care se va folosi aceasta structura in rezolvare ca exercitiu pentru cititor. Astfel, problema poate fi rezolva in complexitatea $O(N^2^*M*lg MAX)$ unde $MAX$ este valoarea maxima din matricea. Mentionam ca pentru o solutie relativ rapida si care sa evite erori de precizie se recomanda lucrul cu numere intregi (inmultind totul cu {$1000$}).\r\n\r\n',1490,'public'),('problema/12perm','12-Perm','2006-11-11 11:23:48','==Include(page=\"template/taskheader\" task_id=\"12perm\")==\n\n==Include(page=\"template/raw\")==\n\n12-Perm\n\n\n\nSe defineste 12-permutarea A[1],A[2],...,A[N] ca fiind o permutare a numerelor 1,2,...,N astfel incat |A[i]-A[i+1]| pentru i=1,2,..N-1.\n\nh2. Cerinta\n\nDandu-se un numar natural N calculati numarul de 12-permutari de lungime N .\n\nh2. Date de Intrare\n\nPrima linie a fisierului de intrare 12perm.in contine numarul natural N cu semnificatia de mai sus.\n\nh2. Date de Iesire\n\nIn fisierul 12perm.out veti afisa X numarul de 12-permutari de lungime N modulo 1048576\n\nh2. Restrictii si precizari\n\n. 1 <= N <= 15.000.000\n\n. 1048576=2^20\n\n. Pentru 70% din teste N <= 5.500.000 .\n\nh2. Exemplu\n\n\n|12perm.in |12perm.out |\n\n|4 |12 |\n\n\n\n\nExplicatii\n\nCele 12 12-permutari sunt: 1 2 3 4 , 1 2 4 3 , 1 3 2 4 , 1 3 4 2 , 2 1 3 4 , 2 4 3 1 , 3 1 2 4 , 3 4 2 1 , 4 2 1 3 , 4 2 3 1 , 4 3 1 2 , 4 3 2 1\n==Include(page=\"template/taskfooter\" task_id=\"12perm\")==',0,''),('hashing','Hashing','2006-11-11 11:50:16','*fadgagfa*\r\n\r\nI\'m %{color:red}unaware%of most soft drinks.',1,''),('hashing','Hashing','2006-11-11 11:52:47','I seriously *{color:red}blushed*when I _(big)sprouted_ thatcorn stalk from my%[es]cabeza%.',1,''),('problema/adunare','A+B','2006-11-11 11:56:22','==Include(page=\"template/taskheader\" task_id=\"adunare\")==\r\n\r\nAdunare simpla\r\n\r\nh2. Date de Intrare\r\n\r\nDatele de intrare se citesc din fisierul \"adunare.in\":\r\n\r\n* pe prima linie un numar intreg {@a@}.\r\n* pe a doua linie un numar intreg {@b@}. \r\n\r\n\r\nh2. Date de Iesire\r\n\r\nDatele de iesire se tiparesc in fisierul \"adunare.out\"\r\n\r\n* pe prima linie: suma celor doua numere {@a + b@}\r\n\r\nh2. Restrictii\r\n\r\n* suma celor doua numere nu va depasi niciodata valoarea 2.000.000.000\r\n\r\nh2. Exemplu\r\n\r\n\r\n|_. adunare.in |_. adunare.out |\r\n| 131 245 | 376 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adunare\")==',18,''),('problema/barbar','Barbar','2006-11-11 11:23:37','==Include(page=\"template/taskheader\" task_id=\"barbar\")==\n\n==Include(page=\"template/raw\")==\n\nbarbar\n\n\n\nPaftenie barbarul este un renumit aventurier. A condus razboaie, a descoperit comori, a cucerit cetati si inimile domnitelor. Insa de aceasta data a fost capturat de catre dusmanii sai cei mai temuti si aruncat intr-o temnita. Temnita este de fapt un grid de dimensiune R*C. In anumite celule exista dragoni, unele sunt ocupate de pereti, iar altele sunt libere. Paftenie trebuie sa iasa din temnita mergand numai prin celule libere (o celula are maxim 4 vecini) , si asta stand cat mai departe de fiorosii dragoni ale caror flacari ii pot deteriora vestimentatia (astfel incat minima din distantele pana la cel mai apropiat dragon din fiecare din celulele traseului sau sa fie maxim).\n\nh2. Cerinta\n\nAjutati-l pe barbarul Paftenie sa iasa din temnita, determinand un traseu astfel incat minima din distantele pana la cel mai apropiat dragon din fiecare din celulele traseului sau sa fie maxim!\n\nh2. Date de Intrare (fisier: barbar.in)\n\nPe prima linie a fisierului de intrare sunt date doua numere intregi R si C, reprezentand numarul liniilor, respectiv al coloanelor temnitei. Pe urmatoarele R linii se afla cate C caractere, neseparate prin spatii, cu urmatoarele semnificatii:\n\n. celula libera\n\n* perete\n\nD dragon\n\nI punctul de plecare al lui Paftenie\n\nO iesirea din temnita\n\nh2. Date de Iesire (fisier: barbar.out)\n\nFisierul de iesire va contine pe prima linie un singur numar, reprezentand valoarea maxima pentru minima din distantele pana la cel mai apropiat dragon din fiecare din celulele traseului. In caz ca nu exista solutie se va afisa \"-1\".\n\nh2. Restrictii si precizari\n\n* 1 <= R, C <= 1.000\n\n* Se garanteaza ca in temnita exista cel putin un dragon\n\nh2. Exemplu\n\nbarbar.in barbar.out Explicatie\n10 10 2 O solutie posibila este urmatoarea :\n.......... ..........\n.I....D... .Iooo.D...\n.......... ....o.....\n..D...D... ..D.o.D...\n.*........ .*..oo....\nD*........ D*...ooooo\n*...D..... *...D....o\n..****.... ..****...o\n...O...... ...Ooooooo\n.......... ..........\n\n\n==Include(page=\"template/taskfooter\" task_id=\"barbar\")==',0,''),('problema/adunare','A+B','2006-11-11 12:12:55','==Include(page=\"template/taskheader\" task_id=\"adunare\")==\r\n\r\nAdunare simpla\r\n\r\nh2. Date de Intrare\r\n\r\nDatele de intrare se citesc din fisierul \"adunare.in\":\r\n\r\n* pe prima linie un numar intreg *a*\r\n* pe a doua linie un numar intreg *b*\r\n\r\n\r\nh2. Date de Iesire\r\n\r\nDatele de iesire se tiparesc in fisierul \"adunare.out\"\r\n\r\n* pe prima linie: suma celor doua numere *a + b*\r\n\r\nh2. Restrictii\r\n\r\n* suma celor doua numere nu va depasi niciodata valoarea *2.000.000.000*\r\n\r\nh2. Exemplu\r\n\r\n\r\n|_. adunare.in |_. adunare.out |\r\n| {@131 @}\r\n{@245 @}\r\n| 376\r\n12 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adunare\")==',18,''),('problema/adunare','A+B','2006-11-11 12:13:30','==Include(page=\"template/taskheader\" task_id=\"adunare\")==\r\n\r\nAdunare simpla\r\n\r\nh2. Date de Intrare\r\n\r\nDatele de intrare se citesc din fisierul \"adunare.in\":\r\n\r\n* pe prima linie un numar intreg *a*\r\n* pe a doua linie un numar intreg *b*\r\n\r\n\r\nh2. Date de Iesire\r\n\r\nDatele de iesire se tiparesc in fisierul \"adunare.out\"\r\n\r\n* pe prima linie: suma celor doua numere *a + b*\r\n\r\nh2. Restrictii\r\n\r\n* suma celor doua numere nu va depasi niciodata valoarea *2.000.000.000*\r\n\r\nh2. Exemplu\r\n\r\n\r\n|_. adunare.in |_. adunare.out |\r\n| {@131@}\r\n{@245@}\r\n| {@376@}\r\n{@12@} |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adunare\")==',18,''),('problema/rf','Roy-Floyd','2006-11-11 12:21:48','==Include(page=\"template/taskheader\" task_id=\"rf\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nLink: [1]File-List\r\n\r\nRoy-Floyd\r\n\r\nh2. Cerinta\r\n\r\n\r\n\r\nMicul Floyd locuieste intr-un oras mare, in care exista N intersectii. Fiecare pereche de intersectii este conectata printr-un drum bidirectional avand o lungime pozitiva data. Micul Floyd este un baiat curios si i-ar placea sa stie care este distanta minima pe care cineva ar trebui sa o parcurga de-a lungul drumurilor existente daca ar vrea sa mearga din intersectia X in intersectia Y. Deoarece ii plac foarte mult intersectiile ar vrea de asemenea sa stie, in cazul in care exista mai multe drumuri intre X si Y de aceeasi lungime minima, care este numarul maxim de strazi pe care ar putea sa mearga cineva pentru a obtine aceasta distanta minima.\r\n\r\nh2. Date de Intrare\r\n\r\n\r\n\r\nPrima linie a fisierului rf.in contine numarul de intersectii N. Urmatoarele N linii contin cate N numere intregi. Al j-ulea numar de pe a i-a linie reprezinta lungimea drumului dintre intersectiile i si j. Matricea data este simetrica. Intersectiile sunt numerotate cu numere intregi de la 1 la N.\r\n\r\nh2. Date de Iesire\r\n\r\n\r\n\r\nAfisati doua matrici de dimensiune NxN. Fiecare matrice va fi afisata pe cate N linii, fiecare continand cate N numere intregi, separate de cate un singur spatiu (fara spatii suplimentare la inceputul sau sfarsitul liniei). Prima matrice reprezinta lungimea minima a drumurilor intre fiecare pereche de intersectii. A doua matrice reprezinta numarul maxim de strazi pe care se poate merge pentru a obtine distanta minima intre oricare pereche de noduri. Al j-ulea numar de pe a i-a linie reprezinta, pentru fiecare dintre cele doua matrici, raspunsul pentru perechea (i, j) de intersectii.\r\n\r\nh2. Restrictii si precizari\r\n\r\n\r\n\r\n- 1 <= N <= 256\r\n\r\n- lungimea unui drum de la o intersectie la ea insasi va fi mereu 0\r\n\r\n- 1 <= lungimea unui drum <= 100.000\r\n\r\n\r\n\r\ntable(example). |. rf.in| rf.out|\r\n\r\n\r\n5 0 2 3 4 3\r\n\r\n0 2 3 4 5 2 0 3 4 1\r\n\r\n2 0 4 5 1 3 3 0 1 2\r\n\r\n3 4 0 1 2 4 4 1 0 3\r\n\r\n4 5 1 0 3 3 1 2 3 0\r\n\r\n5 1 2 3 0 0 1 1 2 2\r\n\r\n1 0 2 3 1\r\n\r\n1 2 0 1 1\r\n\r\n2 3 1 0 2\r\n\r\n2 1 1 2 0\r\n\r\n\r\n\r\nrf.in rf.out\r\n\r\n\r\n3 0 9 11\r\n\r\n0 9 100000 9 0 2\r\n\r\n9 0 2 11 2 0\r\n\r\n100000 2 0 0 1 2\r\n\r\n1 0 1\r\n\r\n2 1 0\r\n\r\n\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/rf/enunt_files/filelist.xml\r\n==Include(page=\"template/taskfooter\" task_id=\"rf\")==',961,''),('problema/rf','Roy-Floyd','2006-11-11 12:28:33','==Include(page=\"template/taskheader\" task_id=\"rf\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nLink: [1]File-List\r\n\r\nRoy-Floyd\r\n\r\nh2. Cerinta\r\n\r\n\r\n\r\nMicul Floyd locuieste intr-un oras mare, in care exista N intersectii. Fiecare pereche de intersectii este conectata printr-un drum bidirectional avand o lungime pozitiva data. Micul Floyd este un baiat curios si i-ar placea sa stie care este distanta minima pe care cineva ar trebui sa o parcurga de-a lungul drumurilor existente daca ar vrea sa mearga din intersectia X in intersectia Y. Deoarece ii plac foarte mult intersectiile ar vrea de asemenea sa stie, in cazul in care exista mai multe drumuri intre X si Y de aceeasi lungime minima, care este numarul maxim de strazi pe care ar putea sa mearga cineva pentru a obtine aceasta distanta minima.\r\n\r\nh2. Date de Intrare\r\n\r\n\r\n\r\nPrima linie a fisierului rf.in contine numarul de intersectii N. Urmatoarele N linii contin cate N numere intregi. Al j-ulea numar de pe a i-a linie reprezinta lungimea drumului dintre intersectiile i si j. Matricea data este simetrica. Intersectiile sunt numerotate cu numere intregi de la 1 la N.\r\n\r\nh2. Date de Iesire\r\n\r\n\r\n\r\nAfisati doua matrici de dimensiune NxN. Fiecare matrice va fi afisata pe cate N linii, fiecare continand cate N numere intregi, separate de cate un singur spatiu (fara spatii suplimentare la inceputul sau sfarsitul liniei). Prima matrice reprezinta lungimea minima a drumurilor intre fiecare pereche de intersectii. A doua matrice reprezinta numarul maxim de strazi pe care se poate merge pentru a obtine distanta minima intre oricare pereche de noduri. Al j-ulea numar de pe a i-a linie reprezinta, pentru fiecare dintre cele doua matrici, raspunsul pentru perechea (i, j) de intersectii.\r\n\r\nh2. Restrictii si precizari\r\n\r\n\r\n\r\n- 1 <= N <= 256\r\n\r\n- lungimea unui drum de la o intersectie la ea insasi va fi mereu 0\r\n\r\n- 1 <= lungimea unui drum <= 100.000\r\n\r\ntable(example). |_. rf.in |_. rf.out|\r\n| 5 0 2 3 4 3\r\nmuiu\r\nehdjhgshgas\r\n2 0 4 5 1 3 3 0 1 2\r\n3 4 0 1 2 4 4 1 0 3\r\n4 5 1 0 3 3 1 2 3 0\r\n5 1 2 3 0 0 1 1 2 2\r\n| 1 0 2 3 1\r\n1 2 0 1 1\r\n2 3 1 0 2\r\n2 1 1 2 0 |\r\n| 3 0 9 11\r\n0 9 100000 9 0 2\r\n9 0 2 11 2 0\r\n100000 2 0 0 1 2\r\n| 1 0 1\r\n2 1 0 |\r\n\r\n\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/rf/enunt_files/filelist.xml\r\n==Include(page=\"template/taskfooter\" task_id=\"rf\")==',961,''),('problema/adunare','A+B','2006-11-11 13:06:21','==Include(page=\"template/taskheader\" task_id=\"adunare\")==\r\n\r\nAdunare simpla\r\n\r\nh2. Date de Intrare\r\n\r\nDatele de intrare se citesc din fisierul \"adunare.in\":\r\n\r\n* pe prima linie un numar intreg $a$\r\n* pe a doua linie un numar intreg $b$\r\n\r\n\r\nh2. Date de Iesire\r\n\r\nDatele de iesire se tiparesc in fisierul \"adunare.out\"\r\n\r\n* pe prima linie: suma celor doua numere *a + b*\r\n\r\nh2. Restrictii\r\n\r\n* suma celor doua numere nu va depasi niciodata valoarea *2.000.000.000*\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. adunare.in |_. adunare.out |\r\n| 131\r\n  245\r\n| 376 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adunare\")==',1,''),('problema/adunare','A+B','2006-11-11 13:07:35','==Include(page=\"template/taskheader\" task_id=\"adunare\")==\r\n\r\nAdunare simpla\r\n\r\nh2. Date de Intrare\r\n\r\nDatele de intrare se citesc din fisierul \"adunare.in\":\r\n\r\n* pe prima linie un numar intreg *a*\r\n* pe a doua linie un numar intreg $b$\r\n\r\n\r\nh2. Date de Iesire\r\n\r\nDatele de iesire se tiparesc in fisierul \"adunare.out\"\r\n\r\n* pe prima linie: suma celor doua numere *a + b*\r\n\r\nh2. Restrictii\r\n\r\n* suma celor doua numere nu va depasi niciodata valoarea *2.000.000.000*\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. adunare.in |_. adunare.out |\r\n| 131\r\n  245\r\n| 376 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adunare\")==',1,''),('problema/12perm','12-Perm','2006-11-11 13:08:14','==Include(page=\"template/taskheader\" task_id=\"12perm\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nSe defineste 12-permutarea $A{~1~},A{~2~},...,A{~N~}$ ca fiind o permutare a numerelor $1,2,...,N$ astfel incat $|A{~i~} - A{~i+1~}|$ pentru $i=1,2,...,N-1$.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un numar natural $N$ calculati numarul de 12-permutari de lungime $N$.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $12perm.in$ contine numarul natural N cu semnificatia de mai sus.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $12perm.out$ veti afisa $X$ numarul de 12-permutari de lungime $N$ modulo $1048576$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $ 1 &le; N &le; 15.000.000 $.\r\n* $1048576=2^20^$\r\n* Pentru $70%$ din teste $N &le; 5.500.000$.\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. 12perm.in |_. 12perm.out |\r\n| 4 | 12 |\r\n\r\n\r\n\r\n\r\nh2. Explicatii\r\n\r\nCele $12$ 12-permutari sunt: $1 2 3 4, 1 2 4 3, 1 3 2 4, 1 3 4 2, 2 1 3 4, 2 4 3 1, 3 1 2 4, 3 4 2 1, 4 2 1 3, 4 2 3 1, 4 3 1 2, 4 3 2 1$\r\n==Include(page=\"template/taskfooter\" task_id=\"12perm\")==',961,''),('problema/12perm','12-Perm','2006-11-11 13:08:53','==Include(page=\"template/taskheader\" task_id=\"12perm\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nSe defineste 12-permutarea $A{~1~},A{~2~},...,A{~N~}$ ca fiind o permutare a numerelor $1,2,...,N$ astfel incat $|A{~i~} - A{~i+1~}|$ pentru $i=1,2,...,N-1$.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un numar natural $N$ calculati numarul de 12-permutari de lungime $N$.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $12perm.in$ contine numarul natural N cu semnificatia de mai sus.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $12perm.out$ veti afisa $X$ numarul de 12-permutari de lungime $N$ modulo $1048576$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $ 1 &le; N &le; 15.000.000 $.\r\n* $1048576=2^20^$\r\n* Pentru {$70%$} din teste $N &le; 5.500.000$.\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. 12perm.in |_. 12perm.out |\r\n| 4 | 12 |\r\n\r\n\r\n\r\n\r\nh2. Explicatii\r\n\r\nCele $12$ 12-permutari sunt: $1 2 3 4, 1 2 4 3, 1 3 2 4, 1 3 4 2, 2 1 3 4, 2 4 3 1, 3 1 2 4, 3 4 2 1, 4 2 1 3, 4 2 3 1, 4 3 1 2, 4 3 2 1$\r\n==Include(page=\"template/taskfooter\" task_id=\"12perm\")==',961,''),('problema/1expr','1expr','2006-11-11 13:14:31','==Include(page=\"template/raw\")==\r\n\r\n==Include(page=\"template/taskheader\" task_id=\"1expr\")==\r\n\r\nGigel, student in anul II (desi a inceput facultatea acum 4 ani - ce sa-i faci, Electronica asta..), tocmai a invatat despre expresii aritmetice ce contin operatorii {\'+\'}, {\'*\'},{ \'^\'} si {\'!\'}, precum si paranteze (`(` si `)\'). Totusi, fiind abia in anul II, el se incurca cand trebuie sa lucreze cu numere prea mari, de aceea singurul numar care apare in mod direct (adica nu doar ca rezultat al unei operatii) in cadrul unei expresii este numarul 1. Vom numi o astfel de expresie 1-expresie. De exemplu, \"(1+(1*1))^(1+1+1*1)^(1+(1+1)!)\" este o 1-expresie, dar \"2+5*7+6!+3^4^3!+1*6\" nu este o 1-expresie (deoarece apar in mod direct numerele 2, 3, 4, 5, 6 si 7). O 1-expresie poate fi privita ca un sir format din caracterele `1\',`+\',\'*\',\'^\',\'!\',\'(`,\')\' si care poate fi descris cu ajutorul urmatoarelor reguli gramaticale :\r\n\r\n\r\n\r\n1-expresie = `1\' sau `(` 1-expresie `)\' sau 1-expresie `+\' 1-expresie sau\r\n\r\n1-expresie `*\' 1-expresie sau 1-expresie `^\' 1-expresie sau\r\n\r\n1-expresie `!\'\r\n\r\n\r\nDesi in cadrul expresiei apare in mod direct doar numarul 1, rezultatele evaluarii operatiilor pot fi numere mai mari decat 1, astfel ca Gigel va trebui sa invete sa foloseasca si aceste numere. Pentru a evalua o expresie aritmetica, trebuie cunoscute prioritatile operatorilor. Operatorul cu cea mai mica prioritate este `+\' si realizeaza operatia de adunare. Rezultatul 1-expresiei \"1+1+1\" este 3. Operatorul `*\' este mai prioritar decat operatorul `+\' si realizeaza operatia de inmultire. Rezultatul 1-expresiei \"1+1*(1+1)*(1+1+1)+(1+1)*(1+1)\" este 1+1*2*3+2*2=1+6+4=11. Operatorul `^\' este mai prioritar decat operatorii `+\' si `*\' si realizeaza operatia de ridicare la putere (A^B reprezinta A ridicat la puterea B). Rezultatul 1-expresiei \"(1+1)*(1+1+1)^(1+1)*(1+1+1)+(1+1)\" este 2*3^2*3+2=2*9*3+2=54+2=56. Spre deosebire de operatorii `+\' si `*\' care au proprietatea ca A+B=B+A si A*B=B*A, in cazul `^\' nu este neaparat adevarat ca A^B=B^A (decat in unele cazuri speciale). O alta particularitate a acestui\r\noperator este ordinea de aplicare in cazul absentei parantezelor : el este asociativ dreapta. De exemplu, A^B^C^D este echivalent cu A^(B^(C^D)). Rezultatul 1-expresiei \"(1+1)^(1+1)^(1+1+1)\" este 2^2^3=2^(2^3)=2^8=256 si nu (2^2)^3=4^3=64. Astfel, daca exista mai multi operatori `^\' neseparati de paranteze, ordinea de efectuare a operatiilor este de la dreapta catre stanga. Operatorul cu prioritatea cea mai mare este `!\' si realizeaza operatia \"factorial\". Rezultatul 1-expresiei \"(1+1+1)!\" este 3!=6. Factorialul unui numar X, notat X!, este definit ca fiind 1*2*..*X. Rezultatul 1-expresiei \"(1+1)*(1+1+1+1)!^(1+1+1)!!\" este 2*4!^3!!=2*(4!)^(3!!)=2*(4!)^((3!)!)=2*24^(6!)= 2*(24^720) (rezultatul este un numar prea mare pentru a fi afisat aici).\r\n\r\nLungimea unei 1-expresii este definita ca fiind egala cu numarul de caractere ale sirului ce reprezinta 1-expresia. Lungimea 1-expresiei \"(1+1)!^(1+1)*(1+1)+1\" este 20. Tema pe care a primit-o Gigel la scoala este urmatoarea: dandu-se un numar N, gasiti o 1-expresie de lungime minima al carei rezultat sa fie egal cu N. Ajutati-l pe Gigel sa isi rezolve tema.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare 1expr.in contine numarul intreg T. Pe urmatoarele T linii se afla cate un numar intreg N.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire 1expr.out veti afisa T linii. Pe a K-a linie veti afisa o 1-expresie de lugime minima al carei rezultat este egal cu al K-lea numar dintre cele T date in fisierul de intrare. Daca exista mai multe 1-expresii de lungime minima, puteti afisa oricare dintre ele.\r\n\r\nh2. Restrictii si precizari\r\n\r\no 1 &le; T <= 100\r\no 1 <= N <= 3^8\r\n\r\nh2. Exemplu\r\n\r\n|1expr.in |1expr.out |\r\n\r\n|3 |1 |\r\n| | |\r\n|1 |1+1+1 |\r\n| | |\r\n|3 |(1+1)^(1+1+1)*(1+(1+1+1+1)!) |\r\n| | |\r\n|200 | |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/1expr/enunt_files/filelist.xml\r\n==Include(page=\"template/taskfooter\" task_id=\"1expr\")==',1,''),('problema/1expr','1expr','2006-11-11 13:14:46','==Include(page=\"template/taskheader\" task_id=\"1expr\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nGigel, student in anul II (desi a inceput facultatea acum 4 ani - ce sa-i faci, Electronica asta..), tocmai a invatat despre expresii aritmetice ce contin operatorii {\'+\'}, {\'*\'},{ \'^\'} si {\'!\'}, precum si paranteze (`(` si `)\'). Totusi, fiind abia in anul II, el se incurca cand trebuie sa lucreze cu numere prea mari, de aceea singurul numar care apare in mod direct (adica nu doar ca rezultat al unei operatii) in cadrul unei expresii este numarul 1. Vom numi o astfel de expresie 1-expresie. De exemplu, \"(1+(1*1))^(1+1+1*1)^(1+(1+1)!)\" este o 1-expresie, dar \"2+5*7+6!+3^4^3!+1*6\" nu este o 1-expresie (deoarece apar in mod direct numerele 2, 3, 4, 5, 6 si 7). O 1-expresie poate fi privita ca un sir format din caracterele `1\',`+\',\'*\',\'^\',\'!\',\'(`,\')\' si care poate fi descris cu ajutorul urmatoarelor reguli gramaticale :\r\n\r\n\r\n\r\n1-expresie = `1\' sau `(` 1-expresie `)\' sau 1-expresie `+\' 1-expresie sau\r\n\r\n1-expresie `*\' 1-expresie sau 1-expresie `^\' 1-expresie sau\r\n\r\n1-expresie `!\'\r\n\r\n\r\nDesi in cadrul expresiei apare in mod direct doar numarul 1, rezultatele evaluarii operatiilor pot fi numere mai mari decat 1, astfel ca Gigel va trebui sa invete sa foloseasca si aceste numere. Pentru a evalua o expresie aritmetica, trebuie cunoscute prioritatile operatorilor. Operatorul cu cea mai mica prioritate este `+\' si realizeaza operatia de adunare. Rezultatul 1-expresiei \"1+1+1\" este 3. Operatorul `*\' este mai prioritar decat operatorul `+\' si realizeaza operatia de inmultire. Rezultatul 1-expresiei \"1+1*(1+1)*(1+1+1)+(1+1)*(1+1)\" este 1+1*2*3+2*2=1+6+4=11. Operatorul `^\' este mai prioritar decat operatorii `+\' si `*\' si realizeaza operatia de ridicare la putere (A^B reprezinta A ridicat la puterea B). Rezultatul 1-expresiei \"(1+1)*(1+1+1)^(1+1)*(1+1+1)+(1+1)\" este 2*3^2*3+2=2*9*3+2=54+2=56. Spre deosebire de operatorii `+\' si `*\' care au proprietatea ca A+B=B+A si A*B=B*A, in cazul `^\' nu este neaparat adevarat ca A^B=B^A (decat in unele cazuri speciale). O alta particularitate a acestui\r\noperator este ordinea de aplicare in cazul absentei parantezelor : el este asociativ dreapta. De exemplu, A^B^C^D este echivalent cu A^(B^(C^D)). Rezultatul 1-expresiei \"(1+1)^(1+1)^(1+1+1)\" este 2^2^3=2^(2^3)=2^8=256 si nu (2^2)^3=4^3=64. Astfel, daca exista mai multi operatori `^\' neseparati de paranteze, ordinea de efectuare a operatiilor este de la dreapta catre stanga. Operatorul cu prioritatea cea mai mare este `!\' si realizeaza operatia \"factorial\". Rezultatul 1-expresiei \"(1+1+1)!\" este 3!=6. Factorialul unui numar X, notat X!, este definit ca fiind 1*2*..*X. Rezultatul 1-expresiei \"(1+1)*(1+1+1+1)!^(1+1+1)!!\" este 2*4!^3!!=2*(4!)^(3!!)=2*(4!)^((3!)!)=2*24^(6!)= 2*(24^720) (rezultatul este un numar prea mare pentru a fi afisat aici).\r\n\r\nLungimea unei 1-expresii este definita ca fiind egala cu numarul de caractere ale sirului ce reprezinta 1-expresia. Lungimea 1-expresiei \"(1+1)!^(1+1)*(1+1)+1\" este 20. Tema pe care a primit-o Gigel la scoala este urmatoarea: dandu-se un numar N, gasiti o 1-expresie de lungime minima al carei rezultat sa fie egal cu N. Ajutati-l pe Gigel sa isi rezolve tema.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare 1expr.in contine numarul intreg T. Pe urmatoarele T linii se afla cate un numar intreg N.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire 1expr.out veti afisa T linii. Pe a K-a linie veti afisa o 1-expresie de lugime minima al carei rezultat este egal cu al K-lea numar dintre cele T date in fisierul de intrare. Daca exista mai multe 1-expresii de lungime minima, puteti afisa oricare dintre ele.\r\n\r\nh2. Restrictii si precizari\r\n\r\no 1 &le; T <= 100\r\no 1 <= N <= 3^8\r\n\r\nh2. Exemplu\r\n\r\n|1expr.in |1expr.out |\r\n\r\n|3 |1 |\r\n| | |\r\n|1 |1+1+1 |\r\n| | |\r\n|3 |(1+1)^(1+1+1)*(1+(1+1+1+1)!) |\r\n| | |\r\n|200 | |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/1expr/enunt_files/filelist.xml\r\n==Include(page=\"template/taskfooter\" task_id=\"1expr\")==',1,''),('problema/1expr','1expr','2006-11-11 13:19:08','==Include(page=\"template/taskheader\" task_id=\"1expr\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\np. Gigel, student in anul II (desi a inceput facultatea acum 4 ani - ce sa-i faci, Electronica asta..), tocmai a invatat despre expresii aritmetice ce contin operatorii  + , * , ^ si ! , precum si paranteze (`(` si `)\'). Totusi, fiind abia in anul II, el se incurca cand trebuie sa lucreze cu numere prea mari, de aceea singurul numar care apare in mod direct (adica nu doar ca rezultat al unei operatii) in cadrul unei expresii este numarul 1. Vom numi o astfel de expresie 1-expresie. De exemplu, \"(1+(1*1))^(1+1+1*1)^(1+(1+1)!)\" este o 1-expresie, dar \"2+5*7+6!+3^4^3!+1*6\" nu este o 1-expresie (deoarece apar in mod direct numerele 2, 3, 4, 5, 6 si 7). O 1-expresie poate fi privita ca un sir format din caracterele `1\',`+\',\'*\',\'^\',\'!\',\'(`,\')\' si care poate fi descris cu ajutorul urmatoarelor reguli gramaticale :\r\n\r\n\r\n\r\n1-expresie = `1\' sau `(` 1-expresie `)\' sau 1-expresie `+\' 1-expresie sau\r\n\r\n1-expresie `*\' 1-expresie sau 1-expresie `^\' 1-expresie sau\r\n\r\n1-expresie `!\'\r\n\r\n\r\nDesi in cadrul expresiei apare in mod direct doar numarul 1, rezultatele evaluarii operatiilor pot fi numere mai mari decat 1, astfel ca Gigel va trebui sa invete sa foloseasca si aceste numere. Pentru a evalua o expresie aritmetica, trebuie cunoscute prioritatile operatorilor. Operatorul cu cea mai mica prioritate este `+\' si realizeaza operatia de adunare. Rezultatul 1-expresiei \"1+1+1\" este 3. Operatorul `*\' este mai prioritar decat operatorul `+\' si realizeaza operatia de inmultire. Rezultatul 1-expresiei \"1+1*(1+1)*(1+1+1)+(1+1)*(1+1)\" este 1+1*2*3+2*2=1+6+4=11. Operatorul `^\' este mai prioritar decat operatorii `+\' si `*\' si realizeaza operatia de ridicare la putere (A^B reprezinta A ridicat la puterea B). Rezultatul 1-expresiei \"(1+1)*(1+1+1)^(1+1)*(1+1+1)+(1+1)\" este 2*3^2*3+2=2*9*3+2=54+2=56. Spre deosebire de operatorii `+\' si `*\' care au proprietatea ca A+B=B+A si A*B=B*A, in cazul `^\' nu este neaparat adevarat ca A^B=B^A (decat in unele cazuri speciale). O alta particularitate a acestui\r\noperator este ordinea de aplicare in cazul absentei parantezelor : el este asociativ dreapta. De exemplu, A^B^C^D este echivalent cu A^(B^(C^D)). Rezultatul 1-expresiei \"(1+1)^(1+1)^(1+1+1)\" este 2^2^3=2^(2^3)=2^8=256 si nu (2^2)^3=4^3=64. Astfel, daca exista mai multi operatori `^\' neseparati de paranteze, ordinea de efectuare a operatiilor este de la dreapta catre stanga. Operatorul cu prioritatea cea mai mare este `!\' si realizeaza operatia \"factorial\". Rezultatul 1-expresiei \"(1+1+1)!\" este 3!=6. Factorialul unui numar X, notat X!, este definit ca fiind 1*2*..*X. Rezultatul 1-expresiei \"(1+1)*(1+1+1+1)!^(1+1+1)!!\" este 2*4!^3!!=2*(4!)^(3!!)=2*(4!)^((3!)!)=2*24^(6!)= 2*(24^720) (rezultatul este un numar prea mare pentru a fi afisat aici).\r\n\r\nLungimea unei 1-expresii este definita ca fiind egala cu numarul de caractere ale sirului ce reprezinta 1-expresia. Lungimea 1-expresiei \"(1+1)!^(1+1)*(1+1)+1\" este 20. Tema pe care a primit-o Gigel la scoala este urmatoarea: dandu-se un numar N, gasiti o 1-expresie de lungime minima al carei rezultat sa fie egal cu N. Ajutati-l pe Gigel sa isi rezolve tema.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare 1expr.in contine numarul intreg T. Pe urmatoarele T linii se afla cate un numar intreg N.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire 1expr.out veti afisa T linii. Pe a K-a linie veti afisa o 1-expresie de lugime minima al carei rezultat este egal cu al K-lea numar dintre cele T date in fisierul de intrare. Daca exista mai multe 1-expresii de lungime minima, puteti afisa oricare dintre ele.\r\n\r\nh2. Restrictii si precizari\r\n\r\no 1 &le; T <= 100\r\no 1 <= N <= 3^8\r\n\r\nh2. Exemplu\r\n\r\n|1expr.in |1expr.out |\r\n\r\n|3 |1 |\r\n| | |\r\n|1 |1+1+1 |\r\n| | |\r\n|3 |(1+1)^(1+1+1)*(1+(1+1+1+1)!) |\r\n| | |\r\n|200 | |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/1expr/enunt_files/filelist.xml\r\n==Include(page=\"template/taskfooter\" task_id=\"1expr\")==',1,''),('problema/adapost2','Adapost 2','2006-11-11 11:23:50','==Include(page=\"template/taskheader\" task_id=\"adapost2\")==\n\n==Include(page=\"template/raw\")==\n\nAdapost 2\n\n\n\n\n\nComandantul si-a trimis inca un batalion de N soldati intr-un teritoriu inamic si acum trebuie sa ii apere. Dupa ce a primit harta cu pozitiile soldatilor, din cauza situatiei financiare foarte proaste in care se afla, a ajuns la concluzia ca nu poate construi decat un singur adapost provizoriu. Totusi, el se gandeste si la binele general al soldatilor si vrea ca suma distantelor parcurse de soldati pana la adapost la fie cat mai mica. Cum Comandantul nu e prea bun cu numerele, soarta soldatilor e in mainile tale.\n\nh2. Cerinta\n\nAflati unde ar trebui sa fie asezat adapostul astfel incat suma distantelor de la soldati la acesta sa fie minima.\n\nh2. Date de Intrare\n\nPrima linie a fisierului adapost2.in contine un numar natural N reprezentand numarul de soldati iar urmatoarele N linii contin coordonatele soldatilor.\n\nh2. Date de Iesire\n\nIn fisierul adapost2.out se vor scrie doua numere reale care reprezinta coordonatele unde ar trebui asezat adapostul.\n\nh2. Restrictii si precizari:\n\no 1 <= N <= 50.000.\no Punctele au coordonate in intervalul [0,1000] si sunt date cu 3 zecimale.\no Diferenta maxima cu care suma distantelor dintre soldati si adapostul gasit poate varia fata de cea minima este de 0,001. Daca este intre 0,001 si 0,2 se va acorda totusi 40% din valoarea unui test.\n\nh2. Exemplu:\n\n\n\nadapost2.in adapost2.out\n3 4.1442 4.2898\n\n5.223 5.591\n\n2.069 4.643\n\n5.628 0.287\n\n\n==Include(page=\"template/taskfooter\" task_id=\"adapost2\")==',0,''),('problema/acolor','Acolor','2006-11-11 13:29:45','==Include(page=\"template/taskheader\" task_id=\"acolor\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nOmida-agent Smith s-a saturat sa tot distruga arborii si acum isi dezvolta simtul artistic - ii place mult mai mult sa-i coloreze.\r\n\r\nDe fiecare data cand vrea sa creeze o noua arbo-pictura isi ia cu el cele $K$ creioane colorate, isi alege un arbore din gradina si porneste la lucru.\r\n\r\nArborele ales de Smith este alcatuit din $N$ noduri, are ca radacina nodul $R$ si o forma potrivita pentru pictura:\r\n\r\n* fiecare nod are cel mult doua crengi care duc spre doua noduri: unul la stanga si/sau unul la dreapta;\r\n\r\n* intre oricare doua noduri exista un drum unic format din crengi distincte, pe care omida se poate plimba pentru a ajunge de la un nod la celalalt;\r\n\r\n* nodurile din subarborele stang al unui nod sunt toate plasate mai la stanga decat acesta, iar cele din subarborele drept sunt toate mai la dreapta, de aceea nodurile au fost etichetate de la $1$ la $N$ de la cel mai din stanga pana la cel mai din dreapta.\r\n\r\nOmida a observat ca picturile sale sunt frumoase doar daca respecta unele reguli de baza pe care le-a citit intr-o carte:\r\n\r\n* orice nod trebuie sa fie colorat cu exact una dintre cele $K$ culori;\r\n\r\n* un nod trebuie sa fie colorat diferit fata de parintele dinspre radacina (adica fata de nodul care preceda nodul respectiv atunci cand omida se plimba pe drumul de la radacina la nod);\r\n\r\n* privit din exterior arborele trebuie sa fie colorat diferit de la stanga la dreapta: orice nod are o culoare diferita de cel mai apropiat nod la stanga de el si fata de cel mai apropiat nod la dreapta (cu alte cuvinte culoarea nodului etichetat cu $i$ trebuie sa fie diferita de culoarea nodurilor etichetate cu $i-1$, $i+1$).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine pentru un arbore dat in cate picturi frumoase (picturi care sa respecte criteriile din enunt) poate fi transformat acesta. Deoarece numarul cerut poate fi foarte mare, este suficient sa aflati restul impartirii la $10007$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $acolor.in$ va contine pe prima linie numerele intregi $N, R, K$ separate prin cate un spatiu. Pe urmatoarele $N$ linii este descrisa structura arborelui. Mai exact, pe linia $i+1$ vor exista doua numere $st ~i~, dr ~i~$ separate printr-un spatiu, reprezentand nodul fiu spre stanga si respectiv nodul fiu spre dreapta al nodului $i$. Daca un nod nu are fiu spre stanga si/sau fiu spre dreapta atunci numarul corespunzator va fi $0$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $acolor.out$ va contine o singura linie pe care va fi scris numarul de picturi frumoase care se pot obtine pentru arborele dat.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 < N &le; 100 000, 1 &le; R &le; N, 1 &le; K &le; 100$\r\n* $In 40% din teste sunt indeplinite relatiile N &le; 100 si K &le; 10$\r\n* $In 60% din teste sunt indeplinite relatiile N &le; 400 si K &le; 150$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. acolor.in |_. acolor.out |_. figura  |\r\n| 9 5 4\r\n0 0\r\n1 3\r\n0 4\r\n0 0\r\n2 6\r\n0 7\r\n0 9\r\n0 0\r\n8 0\r\n| 3601\r\n| !http://www.infoarena.ro/task/acolor?action=download&file=arbore.gif! |\r\n| 3 1 2\r\n0 3\r\n0 0\r\n2 0\r\n| 0\r\n| Not available :D|\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"acolor\")==',18,''),('problema/acolor','Acolor','2006-11-11 13:30:58','==Include(page=\"template/taskheader\" task_id=\"acolor\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nOmida-agent Smith s-a saturat sa tot distruga arborii si acum isi dezvolta simtul artistic - ii place mult mai mult sa-i coloreze.\r\n\r\nDe fiecare data cand vrea sa creeze o noua arbo-pictura isi ia cu el cele $K$ creioane colorate, isi alege un arbore din gradina si porneste la lucru.\r\n\r\nArborele ales de Smith este alcatuit din $N$ noduri, are ca radacina nodul $R$ si o forma potrivita pentru pictura:\r\n\r\n* fiecare nod are cel mult doua crengi care duc spre doua noduri: unul la stanga si/sau unul la dreapta;\r\n\r\n* intre oricare doua noduri exista un drum unic format din crengi distincte, pe care omida se poate plimba pentru a ajunge de la un nod la celalalt;\r\n\r\n* nodurile din subarborele stang al unui nod sunt toate plasate mai la stanga decat acesta, iar cele din subarborele drept sunt toate mai la dreapta, de aceea nodurile au fost etichetate de la $1$ la $N$ de la cel mai din stanga pana la cel mai din dreapta.\r\n\r\nOmida a observat ca picturile sale sunt frumoase doar daca respecta unele reguli de baza pe care le-a citit intr-o carte:\r\n\r\n* orice nod trebuie sa fie colorat cu exact una dintre cele $K$ culori;\r\n\r\n* un nod trebuie sa fie colorat diferit fata de parintele dinspre radacina (adica fata de nodul care preceda nodul respectiv atunci cand omida se plimba pe drumul de la radacina la nod);\r\n\r\n* privit din exterior arborele trebuie sa fie colorat diferit de la stanga la dreapta: orice nod are o culoare diferita de cel mai apropiat nod la stanga de el si fata de cel mai apropiat nod la dreapta (cu alte cuvinte culoarea nodului etichetat cu $i$ trebuie sa fie diferita de culoarea nodurilor etichetate cu $i-1$, $i+1$).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine pentru un arbore dat in cate picturi frumoase (picturi care sa respecte criteriile din enunt) poate fi transformat acesta. Deoarece numarul cerut poate fi foarte mare, este suficient sa aflati restul impartirii la $10007$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $acolor.in$ va contine pe prima linie numerele intregi $N, R, K$ separate prin cate un spatiu. Pe urmatoarele $N$ linii este descrisa structura arborelui. Mai exact, pe linia $i+1$ vor exista doua numere $st ~i~, dr ~i~$ separate printr-un spatiu, reprezentand nodul fiu spre stanga si respectiv nodul fiu spre dreapta al nodului $i$. Daca un nod nu are fiu spre stanga si/sau fiu spre dreapta atunci numarul corespunzator va fi $0$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $acolor.out$ va contine o singura linie pe care va fi scris numarul de picturi frumoase care se pot obtine pentru arborele dat.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 < N &le; 100 000, 1 &le; R &le; N, 1 &le; K &le; 100$\r\n* $In 40% din teste sunt indeplinite relatiile N &le; 100 si K &le; 10$\r\n* $In 60% din teste sunt indeplinite relatiile N &le; 400 si K &le; 150$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. acolor.in |_. acolor.out |_. figura  |\r\n| 9 5 4\r\n0 0\r\n1 3\r\n0 4\r\n0 0\r\n2 6\r\n0 7\r\n0 9\r\n0 0\r\n8 0\r\n| 3601\r\n| !http://www.infoarena.ro/task/acolor?action=download&file=arbore.gif! |\r\n| 3 1 2\r\n0 3\r\n0 0\r\n2 0\r\n| 0\r\n|    |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"acolor\")==',18,''),('problema/acolor','Acolor','2006-11-11 13:31:26','==Include(page=\"template/taskheader\" task_id=\"acolor\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nOmida-agent Smith s-a saturat sa tot distruga arborii si acum isi dezvolta simtul artistic - ii place mult mai mult sa-i coloreze.\r\n\r\nDe fiecare data cand vrea sa creeze o noua arbo-pictura isi ia cu el cele $K$ creioane colorate, isi alege un arbore din gradina si porneste la lucru.\r\n\r\nArborele ales de Smith este alcatuit din $N$ noduri, are ca radacina nodul $R$ si o forma potrivita pentru pictura:\r\n\r\n* fiecare nod are cel mult doua crengi care duc spre doua noduri: unul la stanga si/sau unul la dreapta;\r\n\r\n* intre oricare doua noduri exista un drum unic format din crengi distincte, pe care omida se poate plimba pentru a ajunge de la un nod la celalalt;\r\n\r\n* nodurile din subarborele stang al unui nod sunt toate plasate mai la stanga decat acesta, iar cele din subarborele drept sunt toate mai la dreapta, de aceea nodurile au fost etichetate de la $1$ la $N$ de la cel mai din stanga pana la cel mai din dreapta.\r\n\r\nOmida a observat ca picturile sale sunt frumoase doar daca respecta unele reguli de baza pe care le-a citit intr-o carte:\r\n\r\n* orice nod trebuie sa fie colorat cu exact una dintre cele $K$ culori;\r\n\r\n* un nod trebuie sa fie colorat diferit fata de parintele dinspre radacina (adica fata de nodul care preceda nodul respectiv atunci cand omida se plimba pe drumul de la radacina la nod);\r\n\r\n* privit din exterior arborele trebuie sa fie colorat diferit de la stanga la dreapta: orice nod are o culoare diferita de cel mai apropiat nod la stanga de el si fata de cel mai apropiat nod la dreapta (cu alte cuvinte culoarea nodului etichetat cu $i$ trebuie sa fie diferita de culoarea nodurilor etichetate cu $i-1$, $i+1$).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine pentru un arbore dat in cate picturi frumoase (picturi care sa respecte criteriile din enunt) poate fi transformat acesta. Deoarece numarul cerut poate fi foarte mare, este suficient sa aflati restul impartirii la $10007$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $acolor.in$ va contine pe prima linie numerele intregi $N, R, K$ separate prin cate un spatiu. Pe urmatoarele $N$ linii este descrisa structura arborelui. Mai exact, pe linia $i+1$ vor exista doua numere $st ~i~, dr ~i~$ separate printr-un spatiu, reprezentand nodul fiu spre stanga si respectiv nodul fiu spre dreapta al nodului $i$. Daca un nod nu are fiu spre stanga si/sau fiu spre dreapta atunci numarul corespunzator va fi $0$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $acolor.out$ va contine o singura linie pe care va fi scris numarul de picturi frumoase care se pot obtine pentru arborele dat.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 < N &le; 100 000, 1 &le; R &le; N, 1 &le; K &le; 100$\r\n* $In 40% din teste sunt indeplinite relatiile N &le; 100 si K &le; 10$\r\n* $In 60% din teste sunt indeplinite relatiile N &le; 400 si K &le; 150$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. acolor.in |_. acolor.out |_. figura  |\r\n| 9 5 4\r\n0 0\r\n1 3\r\n0 4\r\n0 0\r\n2 6\r\n0 7\r\n0 9\r\n0 0\r\n8 0\r\n| 3601\r\n| !http://www.infoarena.ro/task/acolor?action=download&file=arbore.gif! |\r\n| 3 1 2\r\n0 3\r\n0 0\r\n2 0\r\n| 0\r\n|                   |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"acolor\")==',18,''),('problema/adn','ADN','2006-11-11 13:32:18','==Include(page=\"template/taskheader\" task_id=\"adn\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nO problema importanta in ultimii ani in biologie a fost gasirea secventei de ADN pentru om. Un lant ADN este format din doua spirale de molecule, fiecare molecula fiind denumita pe scurt A, G, C sau T. Deci un lant ADN poate fi reprezentat ca un sir de caractere din multimea A, G, C si T. Poblema cercetatorilor este ca ei nu pot gasi intreaga secventa ADN cu metode chimice sau biologice dar pot determina sectiuni din ea. Dupa ce au determinat o serie de sectiuni, un sir de molecule care are probabilitatea cea mai mare sa fie apropiat de secventa reala este sirul cel mai scurt de caractere care contine toate sectiunile determinate ca subsecvente!\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa-i ajute pe cercetatori sa determine cel mai scurt sir de caractere care contine toate sectiunile determinate ca subsecvente.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $adn.in$ va contine pe prima linie va contine numarul $N$ de secvente ADN iar pe urmatoarele $N$ linii cate un sir de caractere ce contine numai literele A,G,C si T.\r\n\r\nh2. Date de Iesire \r\n\r\nFisierul de iesire $adn.out$ va contine o singura linie cu cel mai scurt sir ce contine secventele din intrare ca subsecvente.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 18$\r\n* Lungimea fiecarui sir este mai mica de $30.001$\r\n* Daca exista mai multe solutii de lungime minima se va afisa oricare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. adn.in |_. adn.out |\r\n| 5\r\nGGATATAAAAAC\r\nGATAACCGCGCAGTGATGAGA\r\nTGATGAGATGGGGATATAAAA\r\nAGATAGATGATAACCGCGCAGT\r\nATGGGGATATAAAAACTTTTTT\r\n| AGATAGATGATAACCGCGCAGTGATGAGATGGGGATATAAAAACTTTTTT |\r\n\r\nh2. Explicatie\r\nAGATAGATGATAACCGCGCAGT\r\n        GATAACCGCGCAGTGATGAGA\r\n{@                     TGATGAGATGGGGATATAAAA@}\r\n{@                            ATGGGGATATAAAAACTTTTTT@}\r\n{@                                GGATATAAAAAC@}\r\n\r\n\r\n\r\nReferences\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adn\")==',961,''),('problema/acolor','Acolor','2006-11-11 13:32:38','==Include(page=\"template/taskheader\" task_id=\"acolor\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nOmida-agent Smith s-a saturat sa tot distruga arborii si acum isi dezvolta simtul artistic - ii place mult mai mult sa-i coloreze.\r\n\r\nDe fiecare data cand vrea sa creeze o noua arbo-pictura isi ia cu el cele $K$ creioane colorate, isi alege un arbore din gradina si porneste la lucru.\r\n\r\nArborele ales de Smith este alcatuit din $N$ noduri, are ca radacina nodul $R$ si o forma potrivita pentru pictura:\r\n\r\n* fiecare nod are cel mult doua crengi care duc spre doua noduri: unul la stanga si/sau unul la dreapta;\r\n\r\n* intre oricare doua noduri exista un drum unic format din crengi distincte, pe care omida se poate plimba pentru a ajunge de la un nod la celalalt;\r\n\r\n* nodurile din subarborele stang al unui nod sunt toate plasate mai la stanga decat acesta, iar cele din subarborele drept sunt toate mai la dreapta, de aceea nodurile au fost etichetate de la $1$ la $N$ de la cel mai din stanga pana la cel mai din dreapta.\r\n\r\nOmida a observat ca picturile sale sunt frumoase doar daca respecta unele reguli de baza pe care le-a citit intr-o carte:\r\n\r\n* orice nod trebuie sa fie colorat cu exact una dintre cele $K$ culori;\r\n\r\n* un nod trebuie sa fie colorat diferit fata de parintele dinspre radacina (adica fata de nodul care preceda nodul respectiv atunci cand omida se plimba pe drumul de la radacina la nod);\r\n\r\n* privit din exterior arborele trebuie sa fie colorat diferit de la stanga la dreapta: orice nod are o culoare diferita de cel mai apropiat nod la stanga de el si fata de cel mai apropiat nod la dreapta (cu alte cuvinte culoarea nodului etichetat cu $i$ trebuie sa fie diferita de culoarea nodurilor etichetate cu $i-1$, $i+1$).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine pentru un arbore dat in cate picturi frumoase (picturi care sa respecte criteriile din enunt) poate fi transformat acesta. Deoarece numarul cerut poate fi foarte mare, este suficient sa aflati restul impartirii la $10007$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $acolor.in$ va contine pe prima linie numerele intregi $N, R, K$ separate prin cate un spatiu. Pe urmatoarele $N$ linii este descrisa structura arborelui. Mai exact, pe linia $i+1$ vor exista doua numere $st ~i~, dr ~i~$ separate printr-un spatiu, reprezentand nodul fiu spre stanga si respectiv nodul fiu spre dreapta al nodului $i$. Daca un nod nu are fiu spre stanga si/sau fiu spre dreapta atunci numarul corespunzator va fi $0$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $acolor.out$ va contine o singura linie pe care va fi scris numarul de picturi frumoase care se pot obtine pentru arborele dat.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 < N &le; 100 000, 1 &le; R &le; N, 1 &le; K &le; 100$\r\n* $In 40% din teste sunt indeplinite relatiile N &le; 100 si K &le; 10$\r\n* $In 60% din teste sunt indeplinite relatiile N &le; 400 si K &le; 150$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. acolor.in |_. acolor.out |_. figura  |\r\n| 9 5 4\r\n0 0\r\n1 3\r\n0 4\r\n0 0\r\n2 6\r\n0 7\r\n0 9\r\n0 0\r\n8 0\r\n| 3601\r\n| !http://www.infoarena.ro/task/acolor?action=download&file=arbore.gif! |\r\n| 3 1 2\r\n0 3\r\n0 0\r\n2 0\r\n| 0\r\n|{color:red}. ff |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"acolor\")==',18,''),('problema/acolor','Acolor','2006-11-11 13:32:52','==Include(page=\"template/taskheader\" task_id=\"acolor\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nOmida-agent Smith s-a saturat sa tot distruga arborii si acum isi dezvolta simtul artistic - ii place mult mai mult sa-i coloreze.\r\n\r\nDe fiecare data cand vrea sa creeze o noua arbo-pictura isi ia cu el cele $K$ creioane colorate, isi alege un arbore din gradina si porneste la lucru.\r\n\r\nArborele ales de Smith este alcatuit din $N$ noduri, are ca radacina nodul $R$ si o forma potrivita pentru pictura:\r\n\r\n* fiecare nod are cel mult doua crengi care duc spre doua noduri: unul la stanga si/sau unul la dreapta;\r\n\r\n* intre oricare doua noduri exista un drum unic format din crengi distincte, pe care omida se poate plimba pentru a ajunge de la un nod la celalalt;\r\n\r\n* nodurile din subarborele stang al unui nod sunt toate plasate mai la stanga decat acesta, iar cele din subarborele drept sunt toate mai la dreapta, de aceea nodurile au fost etichetate de la $1$ la $N$ de la cel mai din stanga pana la cel mai din dreapta.\r\n\r\nOmida a observat ca picturile sale sunt frumoase doar daca respecta unele reguli de baza pe care le-a citit intr-o carte:\r\n\r\n* orice nod trebuie sa fie colorat cu exact una dintre cele $K$ culori;\r\n\r\n* un nod trebuie sa fie colorat diferit fata de parintele dinspre radacina (adica fata de nodul care preceda nodul respectiv atunci cand omida se plimba pe drumul de la radacina la nod);\r\n\r\n* privit din exterior arborele trebuie sa fie colorat diferit de la stanga la dreapta: orice nod are o culoare diferita de cel mai apropiat nod la stanga de el si fata de cel mai apropiat nod la dreapta (cu alte cuvinte culoarea nodului etichetat cu $i$ trebuie sa fie diferita de culoarea nodurilor etichetate cu $i-1$, $i+1$).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine pentru un arbore dat in cate picturi frumoase (picturi care sa respecte criteriile din enunt) poate fi transformat acesta. Deoarece numarul cerut poate fi foarte mare, este suficient sa aflati restul impartirii la $10007$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $acolor.in$ va contine pe prima linie numerele intregi $N, R, K$ separate prin cate un spatiu. Pe urmatoarele $N$ linii este descrisa structura arborelui. Mai exact, pe linia $i+1$ vor exista doua numere $st ~i~, dr ~i~$ separate printr-un spatiu, reprezentand nodul fiu spre stanga si respectiv nodul fiu spre dreapta al nodului $i$. Daca un nod nu are fiu spre stanga si/sau fiu spre dreapta atunci numarul corespunzator va fi $0$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $acolor.out$ va contine o singura linie pe care va fi scris numarul de picturi frumoase care se pot obtine pentru arborele dat.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 < N &le; 100 000, 1 &le; R &le; N, 1 &le; K &le; 100$\r\n* $In 40% din teste sunt indeplinite relatiile N &le; 100 si K &le; 10$\r\n* $In 60% din teste sunt indeplinite relatiile N &le; 400 si K &le; 150$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. acolor.in |_. acolor.out |_. figura  |\r\n| 9 5 4\r\n0 0\r\n1 3\r\n0 4\r\n0 0\r\n2 6\r\n0 7\r\n0 9\r\n0 0\r\n8 0\r\n| 3601\r\n| !http://www.infoarena.ro/task/acolor?action=download&file=arbore.gif! |\r\n| 3 1 2\r\n0 3\r\n0 0\r\n2 0\r\n| 0\r\n|{color:red}.|\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"acolor\")==',18,''),('problema/adn','ADN','2006-11-11 13:33:27','==Include(page=\"template/taskheader\" task_id=\"adn\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nO problema importanta in ultimii ani in biologie a fost gasirea secventei de ADN pentru om. Un lant ADN este format din doua spirale de molecule, fiecare molecula fiind denumita pe scurt A, G, C sau T. Deci un lant ADN poate fi reprezentat ca un sir de caractere din multimea A, G, C si T. Poblema cercetatorilor este ca ei nu pot gasi intreaga secventa ADN cu metode chimice sau biologice dar pot determina sectiuni din ea. Dupa ce au determinat o serie de sectiuni, un sir de molecule care are probabilitatea cea mai mare sa fie apropiat de secventa reala este sirul cel mai scurt de caractere care contine toate sectiunile determinate ca subsecvente!\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa-i ajute pe cercetatori sa determine cel mai scurt sir de caractere care contine toate sectiunile determinate ca subsecvente.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $adn.in$ va contine pe prima linie va contine numarul $N$ de secvente ADN iar pe urmatoarele $N$ linii cate un sir de caractere ce contine numai literele A,G,C si T.\r\n\r\nh2. Date de Iesire \r\n\r\nFisierul de iesire $adn.out$ va contine o singura linie cu cel mai scurt sir ce contine secventele din intrare ca subsecvente.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 18$\r\n* Lungimea fiecarui sir este mai mica de $30.001$\r\n* Daca exista mai multe solutii de lungime minima se va afisa oricare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. adn.in |_. adn.out |\r\n| 5\r\nGGATATAAAAAC\r\nGATAACCGCGCAGTGATGAGA\r\nTGATGAGATGGGGATATAAAA\r\nAGATAGATGATAACCGCGCAGT\r\nATGGGGATATAAAAACTTTTTT\r\n| AGATAGATGATAACCGCGCAGTGATGAGATGGGGATATAAAAACTTTTTT |\r\n\r\nh2. Explicatie\r\nAGATAGATGATAACCGCGCAGT\r\n        GATAACCGCGCAGTGATGAGA\r\n{@                     TGATGAGATGGGGATATAAAA@}\r\n{@                            ATGGGGATATAAAAACTTTTTT@}\r\n{@                                GGATATAAAAAC@}\r\n\r\n\r\n\r\nReferences\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adn\")==',961,''),('problema/adn','ADN','2006-11-11 13:36:22','==Include(page=\"template/taskheader\" task_id=\"adn\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nO problema importanta in ultimii ani in biologie a fost gasirea secventei de ADN pentru om. Un lant ADN este format din doua spirale de molecule, fiecare molecula fiind denumita pe scurt A, G, C sau T. Deci un lant ADN poate fi reprezentat ca un sir de caractere din multimea A, G, C si T. Poblema cercetatorilor este ca ei nu pot gasi intreaga secventa ADN cu metode chimice sau biologice dar pot determina sectiuni din ea. Dupa ce au determinat o serie de sectiuni, un sir de molecule care are probabilitatea cea mai mare sa fie apropiat de secventa reala este sirul cel mai scurt de caractere care contine toate sectiunile determinate ca subsecvente!\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa-i ajute pe cercetatori sa determine cel mai scurt sir de caractere care contine toate sectiunile determinate ca subsecvente.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $adn.in$ va contine pe prima linie va contine numarul $N$ de secvente ADN iar pe urmatoarele $N$ linii cate un sir de caractere ce contine numai literele A,G,C si T.\r\n\r\nh2. Date de Iesire \r\n\r\nFisierul de iesire $adn.out$ va contine o singura linie cu cel mai scurt sir ce contine secventele din intrare ca subsecvente.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 18$\r\n* Lungimea fiecarui sir este mai mica de $30.001$\r\n* Daca exista mai multe solutii de lungime minima se va afisa oricare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. adn.in |_. adn.out |\r\n| 5\r\nGGATATAAAAAC\r\nGATAACCGCGCAGTGATGAGA\r\nTGATGAGATGGGGATATAAAA\r\nAGATAGATGATAACCGCGCAGT\r\nATGGGGATATAAAAACTTTTTT\r\n| AGATAGATGATAACCGCGCAGTGATGAGATGGGGATATAAAAACTTTTTT |\r\n\r\nh2. Explicatie\r\n\r\npre.. \r\nAGATAGATGATAACCGCGCAGT\r\n        GATAACCGCGCAGTGATGAGA\r\n                     TGATGAGATGGGGATATAAAA\r\n                            ATGGGGATATAAAAACTTTTTT\r\n                                GGATATAAAAAC\r\n\r\nh1. References\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adn\")==',961,''),('problema/1expr','1expr','2006-11-11 13:30:17','==Include(page=\"template/taskheader\" task_id=\"1expr\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nGigel, student in anul II (desi a inceput facultatea acum 4 ani - ce sa-i faci, Electronica asta..), tocmai a invatat despre expresii aritmetice ce contin operatorii  % +  , * , ^ si ! %, precum si paranteze (`(` si `)\'). Totusi, fiind abia in anul II, el se incurca cand trebuie sa lucreze cu numere prea mari, de aceea singurul numar care apare in mod direct (adica nu doar ca rezultat al unei operatii) in cadrul unei expresii este numarul 1. Vom numi o astfel de expresie 1-expresie. De exemplu, \"(1+(1*1))^(1+1+1*1)^(1+(1+1)!)\" este o 1-expresie, dar \"2+5*7+6!+3^4^3!+1*6\" nu este o 1-expresie (deoarece apar in mod direct numerele 2, 3, 4, 5, 6 si 7). O 1-expresie poate fi privita ca un sir format din caracterele `1\',`+\',\'*\',\'^\',\'!\',\'(`,\')\' si care poate fi descris cu ajutorul urmatoarelor reguli gramaticale :\r\n\r\n\r\n\r\n1-expresie = `1\' sau `(` 1-expresie `)\' sau 1-expresie `+\' 1-expresie sau\r\n\r\n1-expresie `*\' 1-expresie sau 1-expresie `^\' 1-expresie sau\r\n\r\n1-expresie `!\'\r\n\r\n\r\nDesi in cadrul expresiei apare in mod direct doar numarul 1, rezultatele evaluarii operatiilor pot fi numere mai mari decat 1, astfel ca Gigel va trebui sa invete sa foloseasca si aceste numere. Pentru a evalua o expresie aritmetica, trebuie cunoscute prioritatile operatorilor. Operatorul cu cea mai mica prioritate este `+\' si realizeaza operatia de adunare. Rezultatul 1-expresiei \"1+1+1\" este 3. Operatorul `*\' este mai prioritar decat operatorul `+\' si realizeaza operatia de inmultire. Rezultatul 1-expresiei \"1+1*(1+1)*(1+1+1)+(1+1)*(1+1)\" este 1+1*2*3+2*2=1+6+4=11. Operatorul `^\' este mai prioritar decat operatorii `+\' si `*\' si realizeaza operatia de ridicare la putere (A^B reprezinta A ridicat la puterea B). Rezultatul 1-expresiei \"(1+1)*(1+1+1)^(1+1)*(1+1+1)+(1+1)\" este 2*3^2*3+2=2*9*3+2=54+2=56. Spre deosebire de operatorii `+\' si `*\' care au proprietatea ca A+B=B+A si A*B=B*A, in cazul `^\' nu este neaparat adevarat ca A^B=B^A (decat in unele cazuri speciale). O alta particularitate a acestui\r\noperator este ordinea de aplicare in cazul absentei parantezelor : el este asociativ dreapta. De exemplu, A^B^C^D este echivalent cu A^(B^(C^D)). Rezultatul 1-expresiei \"(1+1)^(1+1)^(1+1+1)\" este 2^2^3=2^(2^3)=2^8=256 si nu (2^2)^3=4^3=64. Astfel, daca exista mai multi operatori `^\' neseparati de paranteze, ordinea de efectuare a operatiilor este de la dreapta catre stanga. Operatorul cu prioritatea cea mai mare este `!\' si realizeaza operatia \"factorial\". Rezultatul 1-expresiei \"(1+1+1)!\" este 3!=6. Factorialul unui numar X, notat X!, este definit ca fiind 1*2*..*X. Rezultatul 1-expresiei \"(1+1)*(1+1+1+1)!^(1+1+1)!!\" este 2*4!^3!!=2*(4!)^(3!!)=2*(4!)^((3!)!)=2*24^(6!)= 2*(24^720) (rezultatul este un numar prea mare pentru a fi afisat aici).\r\n\r\nLungimea unei 1-expresii este definita ca fiind egala cu numarul de caractere ale sirului ce reprezinta 1-expresia. Lungimea 1-expresiei \"(1+1)!^(1+1)*(1+1)+1\" este 20. Tema pe care a primit-o Gigel la scoala este urmatoarea: dandu-se un numar N, gasiti o 1-expresie de lungime minima al carei rezultat sa fie egal cu N. Ajutati-l pe Gigel sa isi rezolve tema.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare 1expr.in contine numarul intreg T. Pe urmatoarele T linii se afla cate un numar intreg N.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire 1expr.out veti afisa T linii. Pe a K-a linie veti afisa o 1-expresie de lugime minima al carei rezultat este egal cu al K-lea numar dintre cele T date in fisierul de intrare. Daca exista mai multe 1-expresii de lungime minima, puteti afisa oricare dintre ele.\r\n\r\nh2. Restrictii si precizari\r\n\r\no 1 &le; T <= 100\r\no 1 <= N <= 3^8\r\n\r\nh2. Exemplu\r\n\r\n|1expr.in |1expr.out |\r\n\r\n|3 |1 |\r\n| | |\r\n|1 |1+1+1 |\r\n| | |\r\n|3 |(1+1)^(1+1+1)*(1+(1+1+1+1)!) |\r\n| | |\r\n|200 | |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/1expr/enunt_files/filelist.xml\r\n==Include(page=\"template/taskfooter\" task_id=\"1expr\")==',1,''),('problema/adn','ADN','2006-11-11 13:37:04','==Include(page=\"template/taskheader\" task_id=\"adn\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nO problema importanta in ultimii ani in biologie a fost gasirea secventei de ADN pentru om. Un lant ADN este format din doua spirale de molecule, fiecare molecula fiind denumita pe scurt A, G, C sau T. Deci un lant ADN poate fi reprezentat ca un sir de caractere din multimea A, G, C si T. Poblema cercetatorilor este ca ei nu pot gasi intreaga secventa ADN cu metode chimice sau biologice dar pot determina sectiuni din ea. Dupa ce au determinat o serie de sectiuni, un sir de molecule care are probabilitatea cea mai mare sa fie apropiat de secventa reala este sirul cel mai scurt de caractere care contine toate sectiunile determinate ca subsecvente!\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa-i ajute pe cercetatori sa determine cel mai scurt sir de caractere care contine toate sectiunile determinate ca subsecvente.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $adn.in$ va contine pe prima linie va contine numarul $N$ de secvente ADN iar pe urmatoarele $N$ linii cate un sir de caractere ce contine numai literele A,G,C si T.\r\n\r\nh2. Date de Iesire \r\n\r\nFisierul de iesire $adn.out$ va contine o singura linie cu cel mai scurt sir ce contine secventele din intrare ca subsecvente.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 18$\r\n* Lungimea fiecarui sir este mai mica de $30.001$\r\n* Daca exista mai multe solutii de lungime minima se va afisa oricare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. adn.in |_. adn.out |\r\n| 5\r\nGGATATAAAAAC\r\nGATAACCGCGCAGTGATGAGA\r\nTGATGAGATGGGGATATAAAA\r\nAGATAGATGATAACCGCGCAGT\r\nATGGGGATATAAAAACTTTTTT\r\n| AGATAGATGATAACCGCGCAGTGATGAGATGGGGATATAAAAACTTTTTT |\r\n\r\nh2. Explicatie\r\n\r\nbc.. \r\nAGATAGATGATAACCGCGCAGT\r\n        GATAACCGCGCAGTGATGAGA\r\n                     TGATGAGATGGGGATATAAAA\r\n                            ATGGGGATATAAAAACTTTTTT\r\n                                GGATATAAAAAC\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adn\")==',961,''),('problema/acolor','Acolor','2006-11-11 13:35:57','==Include(page=\"template/taskheader\" task_id=\"acolor\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nOmida-agent Smith s-a saturat sa tot distruga arborii si acum isi dezvolta simtul artistic - ii place mult mai mult sa-i coloreze.\r\nDe fiecare data cand vrea sa creeze o noua arbo-pictura isi ia cu el cele $K$ creioane colorate, isi alege un arbore din gradina si porneste la lucru.\r\nArborele ales de Smith este alcatuit din $N$ noduri, are ca radacina nodul $R$ si o forma potrivita pentru pictura:\r\n\r\n* fiecare nod are cel mult doua crengi care duc spre doua noduri: unul la stanga si/sau unul la dreapta;\r\n* intre oricare doua noduri exista un drum unic format din crengi distincte, pe care omida se poate plimba pentru a ajunge de la un nod la celalalt;\r\n* nodurile din subarborele stang al unui nod sunt toate plasate mai la stanga decat acesta, iar cele din subarborele drept sunt toate mai la dreapta, de aceea nodurile au fost etichetate de la $1$ la $N$ de la cel mai din stanga pana la cel mai din dreapta.\r\n\r\nOmida a observat ca picturile sale sunt frumoase doar daca respecta unele reguli de baza pe care le-a citit intr-o carte:\r\n\r\n* orice nod trebuie sa fie colorat cu exact una dintre cele $K$ culori;\r\n* un nod trebuie sa fie colorat diferit fata de parintele dinspre radacina (adica fata de nodul care preceda nodul respectiv atunci cand omida se plimba pe drumul de la radacina la nod);\r\n* privit din exterior arborele trebuie sa fie colorat diferit de la stanga la dreapta: orice nod are o culoare diferita de cel mai apropiat nod la stanga de el si fata de cel mai apropiat nod la dreapta (cu alte cuvinte culoarea nodului etichetat cu $i$ trebuie sa fie diferita de culoarea nodurilor etichetate cu $i-1$, $i+1$).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine pentru un arbore dat in cate picturi frumoase (picturi care sa respecte criteriile din enunt) poate fi transformat acesta. Deoarece numarul cerut poate fi foarte mare, este suficient sa aflati restul impartirii la $10007$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $acolor.in$ va contine pe prima linie numerele intregi $N, R, K$ separate prin cate un spatiu. Pe urmatoarele $N$ linii este descrisa structura arborelui. Mai exact, pe linia $i+1$ vor exista doua numere $st ~i~, dr ~i~$ separate printr-un spatiu, reprezentand nodul fiu spre stanga si respectiv nodul fiu spre dreapta al nodului $i$. Daca un nod nu are fiu spre stanga si/sau fiu spre dreapta atunci numarul corespunzator va fi $0$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $acolor.out$ va contine o singura linie pe care va fi scris numarul de picturi frumoase care se pot obtine pentru arborele dat.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $0 < N &le; 100 000, 1 &le; R &le; N, 1 &le; K &le; 100$\r\n* In $40%$ din teste sunt indeplinite relatiile $N &le; 100$ si $K &le; 10$\r\n* In $60%$ din teste sunt indeplinite relatiile $N &le; 400 si K &le; 150$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. acolor.in |_. acolor.out |_. figura  |\r\n| 9 5 4\r\n0 0\r\n1 3\r\n0 4\r\n0 0\r\n2 6\r\n0 7\r\n0 9\r\n0 0\r\n8 0\r\n| 3601\r\n| !http://www.infoarena.ro/task/acolor?action=download&file=arbore.gif! |\r\n| 3 1 2\r\n0 3\r\n0 0\r\n2 0\r\n| 0\r\n|{color:white}. :) |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"acolor\")==',18,''),('problema/adn','ADN','2006-11-11 13:37:45','==Include(page=\"template/taskheader\" task_id=\"adn\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nO problema importanta in ultimii ani in biologie a fost gasirea secventei de ADN pentru om. Un lant ADN este format din doua spirale de molecule, fiecare molecula fiind denumita pe scurt A, G, C sau T. Deci un lant ADN poate fi reprezentat ca un sir de caractere din multimea A, G, C si T. Poblema cercetatorilor este ca ei nu pot gasi intreaga secventa ADN cu metode chimice sau biologice dar pot determina sectiuni din ea. Dupa ce au determinat o serie de sectiuni, un sir de molecule care are probabilitatea cea mai mare sa fie apropiat de secventa reala este sirul cel mai scurt de caractere care contine toate sectiunile determinate ca subsecvente!\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa-i ajute pe cercetatori sa determine cel mai scurt sir de caractere care contine toate sectiunile determinate ca subsecvente.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $adn.in$ va contine pe prima linie va contine numarul $N$ de secvente ADN iar pe urmatoarele $N$ linii cate un sir de caractere ce contine numai literele A,G,C si T.\r\n\r\nh2. Date de Iesire \r\n\r\nFisierul de iesire $adn.out$ va contine o singura linie cu cel mai scurt sir ce contine secventele din intrare ca subsecvente.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 18$\r\n* Lungimea fiecarui sir este mai mica de $30.001$\r\n* Daca exista mai multe solutii de lungime minima se va afisa oricare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. adn.in |_. adn.out |\r\n| 5\r\nGGATATAAAAAC\r\nGATAACCGCGCAGTGATGAGA\r\nTGATGAGATGGGGATATAAAA\r\nAGATAGATGATAACCGCGCAGT\r\nATGGGGATATAAAAACTTTTTT\r\n| AGATAGATGATAACCGCGCAGTGATGAGATGGGGATATAAAAACTTTTTT |\r\n\r\nh2. Explicatie\r\n\r\nbc.. \r\nAGATAGATGATAACCGCGCAGT\r\n        GATAACCGCGCAGTGATGAGA\r\n                     TGATGAGATGGGGATATAAAA\r\n                            ATGGGGATATAAAAACTTTTTT\r\n                                GGATATAAAAAC\r\n\r\np.   \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adn\")==',961,''),('problema/1expr','1expr','2006-11-11 13:41:37','==Include(page=\"template/taskheader\" task_id=\"1expr\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nGigel, student in anul II (desi a inceput facultatea acum 4 ani - ce sa-i faci, Electronica asta..), tocmai a invatat despre expresii aritmetice ce contin operatorii `+\',\'*\',\'^\' si `!\', precum si paranteze (`(` si `)\'). Totusi, fiind abia in anul II, el se incurca cand trebuie sa lucreze cu numere prea mari, de aceea singurul numar care apare in mod direct (adica nu doar ca rezultat al unei operatii) in cadrul unei expresii este numarul 1. Vom numi o astfel de expresie 1-expresie. De exemplu, \"(1+(1*1))^(1+1+1*1)^(1+(1+1)!)\" este o 1-expresie, dar \"2+5*7+6!+3^4^3!+1*6\" nu este o 1-expresie (deoarece apar in mod direct numerele 2, 3, 4, 5, 6 si 7). O 1-expresie poate fi privita ca un sir format din caracterele `1\',`+\',\'*\',\'^\',\'!\',\'(`,\')\' si care poate fi descris cu ajutorul urmatoarelor reguli gramaticale :\r\n\r\n\r\n\r\n1-expresie = `1\' sau `(` 1-expresie `)\' sau 1-expresie `+\' 1-expresie sau\r\n\r\n1-expresie `*\' 1-expresie sau 1-expresie `^\' 1-expresie sau\r\n\r\n1-expresie `!\'\r\n\r\n\r\n\r\n\r\n\r\nDesi in cadrul expresiei apare in mod direct doar numarul 1, rezultatele evaluarii operatiilor pot fi numere mai mari decat 1, astfel ca Gigel va trebui sa invete sa foloseasca si aceste numere. Pentru a evalua o expresie aritmetica, trebuie cunoscute prioritatile operatorilor. Operatorul cu cea mai mica prioritate este `+\' si realizeaza operatia de adunare. Rezultatul 1-expresiei \"1+1+1\" este 3. Operatorul `*\' este mai prioritar decat operatorul `+\' si realizeaza operatia de inmultire. Rezultatul 1-expresiei \"1+1*(1+1)*(1+1+1)+(1+1)*(1+1)\" este 1+1*2*3+2*2=1+6+4=11. Operatorul `^\' este mai prioritar decat operatorii `+\' si `*\' si realizeaza operatia de ridicare la putere (A^B reprezinta A ridicat la puterea B). Rezultatul 1-expresiei \"(1+1)*(1+1+1)^(1+1)*(1+1+1)+(1+1)\" este 2*3^2*3+2=2*9*3+2=54+2=56. Spre deosebire de operatorii `+\' si `*\' care au proprietatea ca A+B=B+A si A*B=B*A, in cazul `^\' nu este neaparat adevarat ca A^B=B^A (decat in unele cazuri speciale). O alta particularitate a acestui\r\noperator este ordinea de aplicare in cazul absentei parantezelor : el este asociativ dreapta. De exemplu, A^B^C^D este echivalent cu A^(B^(C^D)). Rezultatul 1-expresiei \"(1+1)^(1+1)^(1+1+1)\" este 2^2^3=2^(2^3)=2^8=256 si nu (2^2)^3=4^3=64. Astfel, daca exista mai multi operatori `^\' neseparati de paranteze, ordinea de efectuare a operatiilor este de la dreapta catre stanga. Operatorul cu prioritatea cea mai mare este `!\' si realizeaza operatia \"factorial\". Rezultatul 1-expresiei \"(1+1+1)!\" este 3!=6. Factorialul unui numar X, notat X!, este definit ca fiind 1*2*..*X. Rezultatul 1-expresiei \"(1+1)*(1+1+1+1)!^(1+1+1)!!\" este 2*4!^3!!=2*(4!)^(3!!)=2*(4!)^((3!)!)=2*24^(6!)= 2*(24^720) (rezultatul este un numar prea mare pentru a fi afisat aici).\r\n\r\nLungimea unei 1-expresii este definita ca fiind egala cu numarul de caractere ale sirului ce reprezinta 1-expresia. Lungimea 1-expresiei \"(1+1)!^(1+1)*(1+1)+1\" este 20. Tema pe care a primit-o Gigel la scoala este urmatoarea: dandu-se un numar N, gasiti o 1-expresie de lungime minima al carei rezultat sa fie egal cu N. Ajutati-l pe Gigel sa isi rezolve tema.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare 1expr.in contine numarul intreg T. Pe urmatoarele T linii se afla cate un numar intreg N.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire 1expr.out veti afisa T linii. Pe a K-a linie veti afisa o 1-expresie de lugime minima al carei rezultat este egal cu al K-lea numar dintre cele T date in fisierul de intrare. Daca exista mai multe 1-expresii de lungime minima, puteti afisa oricare dintre ele.\r\n\r\nh2. Restrictii si precizari:\r\n\r\no 1 &le; T <= 100\r\no 1 <= N <= 3^8\r\n\r\nh2. Exemplu:\r\n\r\n\r\n\r\n\r\n|1expr.in |1expr.out |\r\n\r\n|3 |1 |\r\n| | |\r\n|1 |1+1+1 |\r\n| | |\r\n|3 |(1+1)^(1+1+1)*(1+(1+1+1+1)!) |\r\n| | |\r\n|200 | |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/1expr/enunt_files/filelist.xml\r\n==Include(page=\"template/taskfooter\" task_id=\"1expr\")==',1,''),('problema/1expr','1expr','2006-11-11 13:50:44','==Include(page=\"template/taskheader\" task_id=\"1expr\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nGigel, student in anul II (desi a inceput facultatea acum 4 ani - ce sa-i faci, Electronica asta..), tocmai a invatat despre expresii aritmetice ce contin operatorii {@\'+\',\'*\',\'^\'@} si {@\'!\'@}, precum si paranteze ({@\'(\'@} si {@\')\'@}). Totusi, fiind abia in anul II, el se incurca cand trebuie sa lucreze cu numere prea mari, de aceea singurul numar care apare in mod direct (adica nu doar ca rezultat al unei operatii) in cadrul unei expresii este numarul 1. Vom numi o astfel de expresie 1-expresie. De exemplu, {@\"(1+(1*1))^(1+1+1*1)^(1+(1+1)!)\"@} este o 1-expresie, dar {@\"2+5*7+6!+3^4^3!+1*6\"@} nu este o 1-expresie (deoarece apar in mod direct numerele 2, 3, 4, 5, 6 si 7). O 1-expresie poate fi privita ca un sir format din caracterele {@\'1\',\'+\',\'*\',\'^\',\'!\',\'(\',\')\'@} si care poate fi descris cu ajutorul urmatoarelor reguli gramaticale:\r\n{@1-expresie = \'1\' sau \'(\' 1-expresie \')\' sau 1-expresie \'+\' 1-expresie sau@}\r\n{@1-expresie \'*\' 1-expresie sau 1-expresie \'^\' 1-expresie sau@}\r\n{@1-expresie \'!\'@}\r\nDesi in cadrul expresiei apare in mod direct doar numarul 1, rezultatele evaluarii operatiilor pot fi numere mai mari decat 1, astfel ca Gigel va trebui sa invete sa foloseasca si aceste numere. Pentru a evalua o expresie aritmetica, trebuie cunoscute prioritatile operatorilor. Operatorul cu cea mai mica prioritate este {@\'+\'@} si realizeaza operatia de adunare. Rezultatul 1-expresiei {@\"1+1+1\"@} este 3. Operatorul {@\'*\'@} este mai prioritar decat operatorul {@\'+\'@} si realizeaza operatia de inmultire. Rezultatul 1-expresiei \"1+1*(1+1)*(1+1+1)+(1+1)*(1+1)\" este {@1+1*2*3+2*2=1+6+4=11@}. Operatorul {@\'^\'@} este mai prioritar decat operatorii {@\'+\'@} si {@\'*\'@} si realizeaza operatia de ridicare la putere ($A^B$ reprezinta A ridicat la puterea B). Rezultatul 1-expresiei \"(1+1)*(1+1+1)^(1+1)*(1+1+1)+(1+1)\" este {@2*3^2*3+2=2*9*3+2=54+2=56@}. Spre deosebire de operatorii \'+\' si \'*\' care au proprietatea ca A+B=B+A si A*B=B*A, in cazul \'^\' nu este neaparat adevarat ca A^B=B^A (decat in unele cazuri speciale). O alta particularitate a acestui\r\noperator este ordinea de aplicare in cazul absentei parantezelor : el este asociativ dreapta. De exemplu, A^B^C^D este echivalent cu A^(B^(C^D)). Rezultatul 1-expresiei \"(1+1)^(1+1)^(1+1+1)\" este 2^2^3=2^(2^3)=2^8=256 si nu (2^2)^3=4^3=64. Astfel, daca exista mai multi operatori \'^\' neseparati de paranteze, ordinea de efectuare a operatiilor este de la dreapta catre stanga. Operatorul cu prioritatea cea mai mare este \'!\' si realizeaza operatia \"factorial\". Rezultatul 1-expresiei \"(1+1+1)!\" este 3!=6. Factorialul unui numar X, notat X!, este definit ca fiind 1*2*..*X. Rezultatul 1-expresiei \"(1+1)*(1+1+1+1)!^(1+1+1)!!\" este 2*4!^3!!=2*(4!)^(3!!)=2*(4!)^((3!)!)=2*24^(6!)= 2*(24^720) (rezultatul este un numar prea mare pentru a fi afisat aici).\r\n\r\nLungimea unei 1-expresii este definita ca fiind egala cu numarul de caractere ale sirului ce reprezinta 1-expresia. Lungimea 1-expresiei \"(1+1)!^(1+1)*(1+1)+1\" este 20. Tema pe care a primit-o Gigel la scoala este urmatoarea: dandu-se un numar N, gasiti o 1-expresie de lungime minima al carei rezultat sa fie egal cu N. Ajutati-l pe Gigel sa isi rezolve tema.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare 1expr.in contine numarul intreg T. Pe urmatoarele T linii se afla cate un numar intreg N.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire 1expr.out veti afisa T linii. Pe a K-a linie veti afisa o 1-expresie de lugime minima al carei rezultat este egal cu al K-lea numar dintre cele T date in fisierul de intrare. Daca exista mai multe 1-expresii de lungime minima, puteti afisa oricare dintre ele.\r\n\r\nh2. Restrictii si precizari:\r\n\r\no 1 &le; T <= 100\r\no 1 <= N <= 3^8\r\n\r\nh2. Exemplu:\r\n\r\n\r\n\r\n\r\n|1expr.in |1expr.out |\r\n\r\n|3 |1 |\r\n| | |\r\n|1 |1+1+1 |\r\n| | |\r\n|3 |(1+1)^(1+1+1)*(1+(1+1+1+1)!) |\r\n| | |\r\n|200 | |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/1expr/enunt_files/filelist.xml\r\n==Include(page=\"template/taskfooter\" task_id=\"1expr\")==',1,''),('problema/adunare','A+B','2006-11-11 13:55:16','==Include(page=\"template/taskheader\" task_id=\"adunare\")==\r\n\r\nAdunare simpla\r\n\r\nh2. Date de Intrare\r\n\r\nDatele de intrare se citesc din fisierul $adunare.in$:\r\n\r\n* pe prima linie un numar intreg $a$\r\n* pe a doua linie un numar intreg $b$\r\n\r\n\r\nh2. Date de Iesire\r\n\r\nDatele de iesire se tiparesc in fisierul $adunare.out$\r\n\r\n* pe prima linie: suma celor doua numere $a + b$\r\n\r\nh2. Restrictii\r\n\r\n* suma celor doua numere nu va depasi niciodata valoarea $2.000.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. adunare.in |_. adunare.out |\r\n| 131\r\n  245\r\n| 376 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adunare\")==',18,''),('problema/abc','ABC','2006-11-11 13:12:37','==Include(page=\"template/taskheader\" task_id=\"abc\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nHaralambie a primit ca tema la informatica urmatoarea problema: Fie un sir $A$ de $N$ numere naturale distincte, mai mici sau egale cu un numar natural $B$ dat. De asemenea, se mai da si un numar natural $C$. Se cere determinarea unui sir de $N$ numere naturale distincte $D$, mai mici sau egale cu $B$, astfel incat suma acestora sa fie egala cu $C$, iar termenul maxim al sirului $|A ~i~ - D ~i~|$ sa fie minim.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Haralambie si determinati un sir $D$ care indeplineste conditiile impuse.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $abc.in$ contine pe prima linie numerele naturale $N$, $B$ si $C$ separate prin cate un spatiu. Pe urmatoarea linie se vor afla cele $N$ numere ale sirului $A$, separate prin cate un spatiu.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $abc.out$ va contine pe prima si singura linie elementele sirului $D$, separate prin cate un spatiu. In caz ca exista mai multe solutii, puteti afisa oricare dintre ele.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 30.000$\r\n\r\n* $1 &le; B &le; 65.535$\r\n\r\n* $1 &le; C &le; 2.147.483.647$\r\n\r\n* Pentru toate testele folosite la evaluare va exista solutie.\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. abc.in |_. abc.out |\r\n| 6 10 38 \r\n  1 3 4 7 9 10\r\n| 2 4 5 8 9 10 |\r\n\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"abc\")==',18,''),('problema/alpin','Alpin','2006-11-11 13:58:48','==Include(page=\"template/taskheader\" task_id=\"alpin\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nUn alpinist se afla intr-o regiune muntoasa codificata sub forma unei matrici patratice de dimensiune N, fiecare element al matricii reprezentand altitudinea respectivei portiuni de teren. Alpinistul isi poate porni traseul din orice punct al regiunii ( deci de la oricare dintre elementele matricii ) si poate termina acest traseu oriunde. El poate merge pe oricare din directiile {N, S, E, V} cu conditia sa nu paraseasca regiunea. In plus, trebuie sa urce in permanenta, sau, altfel spus, altitudinea regiunii curente sa fie strict mai mica decat altitudinea regiunii urmatoare de pe traseu.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine cel mai lung traseu pe care il poate face alpinistul.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $alpin.in$ se va afla numarul $N$, dimensiunea regiunii. Urmatoarele $N$ linii contin cate $N$ numere naturale pozitive separate prin exact un spatiu, descriind codificarea matriceala a regiunii.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a sa, fisierul de iesire $alpin.out$ va contine $LMAX$, lungimea maxima a traseului parcurs. Urmeaza $LMAX$ linii, descriind traseul urmat prin casutele sale, in ordine, de la prima la ultima, inclusiv.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 1024$\r\n* Altitudinea maxima nu depaseste $16.384$\r\n* Daca exista mai multe solutii de lungime maxima, se va afisa oricare dintre ele\r\n* Daca determinati corect doar lungimea maxima, veti primi $50%$ din punctajul pe testul respectiv\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. alpin.in |_. alpin.out |\r\n| 6\r\n29 10 8 9 8 10\r\n22 11 7 3 7 20\r\n17 15 3 14 45 30\r\n19 5 2 41 19 17\r\n23 8 90 39 20 18\r\n27 30 32 35 70 19\r\n| 16\r\n4 3\r\n3 3\r\n2 3\r\n1 3\r\n1 2\r\n2 2\r\n3 2\r\n3 1\r\n4 1\r\n5 1\r\n6 1\r\n6 2\r\n6 3\r\n6 4\r\n5 4\r\n4 4 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"alpin\")==',961,''),('problema/1expr','1expr','2006-11-11 13:58:17','==Include(page=\"template/taskheader\" task_id=\"1expr\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nGigel, student in anul II (desi a inceput facultatea acum 4 ani - ce sa-i faci, Electronica asta..), tocmai a invatat despre expresii aritmetice ce contin operatorii {@\'+\',\'*\',\'^\'@} si {@\'!\'@}, precum si paranteze ({@\'(\'@} si {@\')\'@}). Totusi, fiind abia in anul II, el se incurca cand trebuie sa lucreze cu numere prea mari, de aceea singurul numar care apare in mod direct (adica nu doar ca rezultat al unei operatii) in cadrul unei expresii este numarul 1. Vom numi o astfel de expresie 1-expresie. De exemplu, {@\"(1+(1*1))^(1+1+1*1)^(1+(1+1)!)\"@} este o 1-expresie, dar {@\"2+5*7+6!+3^4^3!+1*6\"@} nu este o 1-expresie (deoarece apar in mod direct numerele 2, 3, 4, 5, 6 si 7). O 1-expresie poate fi privita ca un sir format din caracterele {@\'1\',\'+\',\'*\',\'^\',\'!\',\'(\',\')\'@} si care poate fi descris cu ajutorul urmatoarelor reguli gramaticale:\r\n{@1-expresie = \'1\' sau \'(\' 1-expresie \')\' sau 1-expresie \'+\' 1-expresie sau@}\r\n{@1-expresie \'*\' 1-expresie sau 1-expresie \'^\' 1-expresie sau@}\r\n{@1-expresie \'!\'@}\r\nDesi in cadrul expresiei apare in mod direct doar numarul 1, rezultatele evaluarii operatiilor pot fi numere mai mari decat 1, astfel ca Gigel va trebui sa invete sa foloseasca si aceste numere. Pentru a evalua o expresie aritmetica, trebuie cunoscute prioritatile operatorilor. Operatorul cu cea mai mica prioritate este {@\'+\'@} si realizeaza operatia de adunare. Rezultatul 1-expresiei {@\"1+1+1\"@} este 3. Operatorul {@\'*\'@} este mai prioritar decat operatorul {@\'+\'@} si realizeaza operatia de inmultire. Rezultatul 1-expresiei {@\"1+1*(1+1)*(1+1+1)+(1+1)*(1+1)\"@} este {@1+1*2*3+2*2=1+6+4=11@}. Operatorul {@\'^\'@} este mai prioritar decat operatorii {@\'+\'@} si {@\'*\'@} si realizeaza operatia de ridicare la putere ({$A^B^$} reprezinta {@A@} ridicat la puterea {@B@}). Rezultatul 1-expresiei {@\"(1+1)*(1+1+1)^(1+1)*(1+1+1)+(1+1)\"@} este {@2*3^2*3+2=2*9*3+2=54+2=56@}. Spre deosebire de operatorii {@\'+\'@} si {@\'*\'@} care au proprietatea ca {@A+B=B+A@} si {@A*B=B*A@}, in cazul {@\'^\'@} nu este neaparat adevarat ca {$A^B^=B^A^$} (decat in unele cazuri speciale). O alta particularitate a acestui operator este ordinea de aplicare in cazul absentei parantezelor: el este asociativ dreapta. De exemplu, {@A^B^C^D@} este echivalent cu A^(B^(C^D)). Rezultatul 1-expresiei {@\"(1+1)^(1+1)^(1+1+1)\"@} este {@2^2^3=2^(2^3)=2^8=256@} si nu {@(2^2)^3=4^3=64@}. Astfel, daca exista mai multi operatori {@\'^\'@} neseparati de paranteze, ordinea de efectuare a operatiilor este de la dreapta catre stanga. Operatorul cu prioritatea cea mai mare este {@\'!\'@} si realizeaza operatia \"factorial\". Rezultatul 1-expresiei {@\"(1+1+1)!\"@} este {@3!=6@}. Factorialul unui numar {@X@}, notat {@X!@}, este definit ca fiind {@1*2*..*X@}. Rezultatul 1-expresiei {@\"(1+1)*(1+1+1+1)!^(1+1+1)!!\"@} este {@2*4!^3!!=2*(4!)^(3!!)=2*(4!)^((3!)!)=2*24^(6!)=2*(24^720)@} (rezultatul este un numar prea mare pentru a fi afisat aici).\r\nLungimea unei 1-expresii este definita ca fiind egala cu numarul de caractere ale sirului ce reprezinta 1-expresia. Lungimea 1-expresiei \"(1+1)!^(1+1)*(1+1)+1\" este 20. Tema pe care a primit-o Gigel la scoala este urmatoarea: dandu-se un numar N, gasiti o 1-expresie de lungime minima al carei rezultat sa fie egal cu N. Ajutati-l pe Gigel sa isi rezolve tema.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare 1expr.in contine numarul intreg T. Pe urmatoarele T linii se afla cate un numar intreg N.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire 1expr.out veti afisa T linii. Pe a K-a linie veti afisa o 1-expresie de lugime minima al carei rezultat este egal cu al K-lea numar dintre cele T date in fisierul de intrare. Daca exista mai multe 1-expresii de lungime minima, puteti afisa oricare dintre ele.\r\n\r\nh2. Restrictii si precizari:\r\n\r\no 1 &le; T <= 100\r\no 1 <= N <= 3^8\r\n\r\nh2. Exemplu:\r\n\r\n\r\n\r\n\r\n|1expr.in |1expr.out |\r\n\r\n|3 |1 |\r\n| | |\r\n|1 |1+1+1 |\r\n| | |\r\n|3 |(1+1)^(1+1+1)*(1+(1+1+1+1)!) |\r\n| | |\r\n|200 | |\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/1expr/enunt_files/filelist.xml\r\n==Include(page=\"template/taskfooter\" task_id=\"1expr\")==',1,''),('problema/arbfind','Arbfind','2006-11-11 14:18:05','==Include(page=\"template/taskheader\" task_id=\"arbfind\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nSe numeste arbore cu radacina o structura care contine un nod special denumit radacina arborelui si $A{~1~}, A{~2~}, ..., A{~n~}$ (unde $n &ge; 0$) arbori cu radacina (denumiti subarbori ai radacinii). Nodul radacina al fiecarui arbore $A{~i~}$ este denumit fiu al radacinii arborelui si este conectat printr-o muchie de radacina arborelui.\r\n\r\nDoi arbori cu radacina sunt identici daca radacinile celor doi au acelasi numar de subarbori si acestia sunt identici (mai exact, pentru orice $i=1, 2, ..., n$ subarborele $i$ al primului este identic cu subarborele $i$ al celui de-al doilea).\r\n\r\nO termita poate \"ciopli\" un arbore actionand astfel:\r\n1. termita porneste de la radacina arborelui;\r\n2. la fiecare moment (in orice nod s-ar afla), termita poate face una dintre urmatoarele operatii:\r\n\r\n* sta in nod si mananca cea mai din dreapta muchie, eliminand astfel cel mai din dreapta fiu si subarborele corespunzator (acestea cad si vor fi mancate de alte termite lenese);\r\n* inainteaza pe muchia din dreapta, spre fiul ramas cel mai din dreapta al nodului in care se afla;\r\n* se opreste\r\n\r\nDoua termite prietene aleg doi arbori si ii cioplesc in modul descris pana cand obtin doi arbori identici. Similaritatea dintre doi arbori este egala cu numarul maxim de noduri care raman in fiecare dintre cei doi arbori identici obtinuti prin cioplire.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se doi arbori (un arbore model si un arbore de evaluat) sa se calculeze pentru fiecare nod al arborelui de evaluat similaritatea dintre subarborele cu radacina in nodul respectiv si arborele model dat.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $arbfind.in$ se gaseste un numar natural $N$ reprezentand numarul de noduri din arborele model, nodurile fiind numerotate de la $1$ la $N$. Pe liniile $2..N+1$ se va afla descrierea arborelui model. Mai exact, pe linia $i$ se va afla un numar natural $F{~i-1~}$ reprezentand numarul de fii directi ai nodului $i-1$, urmat de $F ~i-1~$ numere naturale cuprinse intre $1$ si $N$, reprezentand in ordinea de la stanga la dreapta fiii nodului $i-1$.\r\n\r\nLinia $N+2$ va contine un numar natural $M$ reprezentand numarul de noduri din arborele de evaluat. Liniile $N+3..N+M+2$ vor contine descrierea arborelui de evaluat, in mod analog cu descrierea arborelui model.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $arbfind.out$ va contine $M$ linii. Pe linia $i$ se va afla similaritatea subarborelui cu radacina in nodul $i$ fata de arborele model.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Radacina arborilor este intotdeauna nodul $1$.\r\n* $1 &le; M, N &le; 32000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |arbfind.in |arbfind.out |Arbore model Arbore de evaluat |\r\n| 4\r\n2 2 3\r\n1 4\r\n0\r\n0\r\n9\r\n2 2 3\r\n2 4 5\r\n2 6 7\r\n1 8\r\n0\r\n0\r\n1 9\r\n0\r\n0\r\n| 3\r\n4\r\n2\r\n2\r\n1\r\n1\r\n2\r\n1\r\n1\r\n| !http://www.infoarena.ro/task/arbfind?action=download&file=arbfind.jpg! &nbsp;\r\nDe exemplu, pentru nodul 1 din arborele model s-au eliminat n ordine subarborii cu radacinile 3, 5 si 8. Din arborele model se elimina subarborele cu radacina 3. |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"arbfind\")==',18,''),('problema/arbfind','Arbfind','2006-11-11 14:20:50','==Include(page=\"template/taskheader\" task_id=\"arbfind\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nSe numeste arbore cu radacina o structura care contine un nod special denumit radacina arborelui si $A{~1~}, A{~2~}, ..., A{~n~}$ (unde $n &ge; 0$) arbori cu radacina (denumiti subarbori ai radacinii). Nodul radacina al fiecarui arbore $A{~i~}$ este denumit fiu al radacinii arborelui si este conectat printr-o muchie de radacina arborelui.\r\n\r\nDoi arbori cu radacina sunt identici daca radacinile celor doi au acelasi numar de subarbori si acestia sunt identici (mai exact, pentru orice $i=1, 2, ..., n$ subarborele $i$ al primului este identic cu subarborele $i$ al celui de-al doilea).\r\n\r\nO termita poate \"ciopli\" un arbore actionand astfel:\r\n1. termita porneste de la radacina arborelui;\r\n2. la fiecare moment (in orice nod s-ar afla), termita poate face una dintre urmatoarele operatii:\r\n\r\n* sta in nod si mananca cea mai din dreapta muchie, eliminand astfel cel mai din dreapta fiu si subarborele corespunzator (acestea cad si vor fi mancate de alte termite lenese);\r\n* inainteaza pe muchia din dreapta, spre fiul ramas cel mai din dreapta al nodului in care se afla;\r\n* se opreste\r\n\r\nDoua termite prietene aleg doi arbori si ii cioplesc in modul descris pana cand obtin doi arbori identici. Similaritatea dintre doi arbori este egala cu numarul maxim de noduri care raman in fiecare dintre cei doi arbori identici obtinuti prin cioplire.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se doi arbori (un arbore model si un arbore de evaluat) sa se calculeze pentru fiecare nod al arborelui de evaluat similaritatea dintre subarborele cu radacina in nodul respectiv si arborele model dat.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $arbfind.in$ se gaseste un numar natural $N$ reprezentand numarul de noduri din arborele model, nodurile fiind numerotate de la $1$ la $N$. Pe liniile $2..N+1$ se va afla descrierea arborelui model. Mai exact, pe linia $i$ se va afla un numar natural $F{~i-1~}$ reprezentand numarul de fii directi ai nodului $i-1$, urmat de $F ~i-1~$ numere naturale cuprinse intre $1$ si $N$, reprezentand in ordinea de la stanga la dreapta fiii nodului $i-1$.\r\n\r\nLinia $N+2$ va contine un numar natural $M$ reprezentand numarul de noduri din arborele de evaluat. Liniile $N+3..N+M+2$ vor contine descrierea arborelui de evaluat, in mod analog cu descrierea arborelui model.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $arbfind.out$ va contine $M$ linii. Pe linia $i$ se va afla similaritatea subarborelui cu radacina in nodul $i$ fata de arborele model.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Radacina arborilor este intotdeauna nodul $1$.\r\n* $1 &le; M, N &le; 32000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |arbfind.in |arbfind.out |Arbore model p(pre).  Arbore de evaluat |\r\n| 4\r\n2 2 3\r\n1 4\r\n0\r\n0\r\n9\r\n2 2 3\r\n2 4 5\r\n2 6 7\r\n1 8\r\n0\r\n0\r\n1 9\r\n0\r\n0\r\n| 3\r\n4\r\n2\r\n2\r\n1\r\n1\r\n2\r\n1\r\n1\r\n| !http://www.infoarena.ro/task/arbfind?action=download&file=arbfind.jpg! &nbsp;\r\nDe exemplu, pentru nodul 1 din arborele model s-au eliminat n ordine subarborii cu radacinile 3, 5 si 8. Din arborele model se elimina subarborele cu radacina 3. |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"arbfind\")==',18,''),('problema/aladdin2','Aladdin2','2006-11-11 13:47:50','==Include(page=\"template/taskheader\" task_id=\"aladdin2\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nAladdin s-a gandit la un moment dat sa intre in afaceri cu covoare, deoarece crede ca acestea sunt foarte profitabile. El a reusit sa rezolve toate problemele tehnice si acum poate sa realizeze covoare de dimensiune $m x n$. Aceste covoare sunt impartite in $m x n$ celule de dimensiune $1 x 1$. Fiecare celula va fi colorata cu alb sau cu negru. Datorita faptului ca vrea sa obtina covoare cu anumite proprietati magice este necesar ca orice patrat, de dimensiune $2 x 2$, sa contina doua celule colorate cu alb si doua celule colorate cu negru.\r\n\r\nh2. Cerinta\r\n\r\nAladdin doreste sa stie cate covoare diferite, de dimensiune $m x n$, care sa beneficieze de proprietatile magice se pot construi.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $aladdin2.in$ contine pe prima linie doua numere intregi $m$ si $n$, separate printr-un singur spatiu, care reprezinta dimensiunile pentru un covor.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $aladdin2.out$ trebuie sa contina o singura linie pe care se va afla un singur numar care reprezinta numarul de covoare de dimensiune $m x n$ care se pot construi astfel incat acestea sa beneficieze de proprietatile magice.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; m, n &le; 10000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. aladdin2.in |_. aladdin2.out |\r\n| 4 2 | 18 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"aladdin2\")==',18,''),('problema/arie','Arie','2006-11-11 15:02:04','==Include(page=\"template/taskheader\" task_id=\"arie\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nSe dau doua poligoane convexe avand {$N$}, respectiv $M$ varfuri. Determinati aria intersectiei celor doua poligoane.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $arie.in$ se afla numarul intreg {$N$}, reprezentand numarul de varfuri al primului poligon. Pe urmatoarele $N$ linii se afla cate doua numere intregi, separate printr-un spatiu, reprezentand coordonatele $x$ si $y$ ale varfurilor primului poligon. Varfurile poligonului sunt date in ordine trigonometrica sau invers trigonometrica. Pe linia urmatoare se afla numarul intreg {$M$}, reprezentand numarul de varfuri al celui de-al doilea poligon. Pe urmatoarele $M$ linii se afla cate doua numere intregi, separate printr-un spatiu, reprezentand coordonatele $x$ si $y$ ale varfurilor celui de-al doilea poligon. Varfurile poligonului sunt date in ordine trigonometrica sau invers trigonometrica.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $arie.out$ veti afisa aria intersectiei celor doua poligoane, rotunjita la $3$ zecimale.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 $le; N &le; 20$\r\n* $3 &le; M &le; 20$\r\n* {$-50 &le; $}abscisa oricarui varf al unui poligon{$ &le; 50$}\r\n\r\n. -50 <= ordonata oricarui varf al unui poligon <= 50\r\n\r\n. Pentru cei surprinsi de limitele mici ale datelor de intrare si limita mare de timp : de multe ori (TopCoder, ACM, etc.) un program cu o complexitate neoptima, dar scris repede si clar, este de preferat unuia cu o complexitate optima, dar a carui durata de scriere este mare si in care exista sanse mari sa aveti \"bug\"-uri!\r\n\r\nh2. Exemplu\r\n\r\narie.in arie.out\r\n4 7.000\r\n\r\n-2 -2\r\n\r\n2 -2\r\n\r\n2 2\r\n\r\n-2 2\r\n\r\n3\r\n\r\n0 3\r\n\r\n3 0\r\n\r\n0 -3\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"arie\")==',961,''),('problema/z','ZParcurgere','2006-11-11 15:04:52','==Include(page=\"template/taskheader\" task_id=\"z\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nh1. Z-parcurgere\r\n\r\nPetrica are o tabla patratica de dimensiuni 2^n^*2^n^. Ar vrea sa scrie pe patratelele tablei numere naturale cuprinse intre 1 si 2^n^*2^n^ conform unei parcurgeri mai deosebite pe care o numeste Z-parcurgere. O Z-parcurgere viziteaza recursiv cele patru cadrane ale tablei in ordinea: stanga-sus, dreapta-sus, stanga-jos, dreapta-jos. De exemplu, daca n=1 , ordinea vizitarii patratelelor de pe tabla este in forma de Z, ca in figura urmatoare:\r\n\r\n\r\n|1 |2 |\r\n\r\n|3 |4 |\r\n\r\n\r\n\r\n\r\nDaca n=2 , Petrica va traversa patratelele in ordinea:\r\n\r\n\r\n|1 |2 |5 |6 |\r\n\r\n|3 |4 |7 |8 |\r\n\r\n|9 |10 |13 |14 |\r\n\r\n|11 |12 |15 |16 |\r\n\r\nh2. Cerinta\r\n\r\nLa un moment dat Petrica ar vrea sa stie ce numar de ordine trebuie sa scrie conform Z-parcurgerii pe anumite patratele date prin coordonatele lor ( x, y ). Petrica incepe umplerea tablei intotdeauna din coltul din stanga-sus.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare z.in se afla doua numere naturale N si K , unde N reprezinta faptul ca tabla are dimensiunea 2^n*2^n , iar K este numarul patratelelor pe care Petrica ar vrea sa stie ce numar va trebui sa scrie pe ele. Pe fiecare din urmatoarele K linii se afla cate doua numere naturale ( x, y ), care reprezinta linia, respectiv coloana unui patratel ales. A i+1 -a linie descrie al i -lea patratel ( i = 1, 2, ..., k ).\r\n\r\nh2. Date de Iesire\r\n\r\nPe cele k linii ale fisierului de iesire z.out se va scrie cate un numar natural, corespunzator numarului pe care Petrica il va scrie pe patratelul ales. A i -a linie descrie al i -lea patratel ( i = 1, 2, ..., k ).\r\n\r\nh2. Restrictii si precizari\r\n\r\n. 1 <= N <= 15\r\n\r\n. 1 <= K <= 1.000\r\n\r\n. 1 <= x,y <= 2^n\r\n\r\nh2. Exemplu\r\n\r\n\r\n|z.in |z.out |\r\n\r\n|2 2 |13 |\r\n|3 3 |15 |\r\n|4 3 | |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"z\")==',256,''),('template/cleanup','template/cleanup','2006-11-11 15:05:08','|_. Aceasta pagina a fost important din infoarena1 si nu a fost inca importata. Sterge @==Include(file=\"template/raw\")==@ doar cand este multumit cu continutul pagini.|',13,''),('problema/arbciclu','Arbore de cicluri','2006-11-11 15:06:57','==Include(page=\"template/taskheader\" task_id=\"arbciclu\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nUn arbore de cicluri este un graf neorientat care are una din urmatoarele proprietati:\r\n\r\n* este un ciclu de lungime $K$ ({$K &ge; 3$})\r\n* este un graf obtinut prin atasarea unui ciclu $C$ de lungime $K$ ({$K &ge; 3$}) la o muchie dintr-un arbore de cicluri $CT$\r\n\r\nAtasarea unui ciclu la o muchie dintr-un graf inseamna inlocuirea unei muchii din ciclu cu o muchie din graf (si de asemenea inlocuirea celor doua noduri ale muchiei din ciclu cu cele doua noduri ale muchiei din graf).\r\n!http://www.infoarena.ro/task/arbciclu?action=download&file=arbcic.jpg! &nbsp;\r\nDandu-se mai multe grafuri sa se determine pentru fiecare daca este un arbore de cicluri.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $arbciclu.in$ contine un numar natural $T$, reprezentand numarul de grafuri care se dau. Pentru fiecare graf dat, prima linie va contine doua numere naturale: $N$ si $M$. $N$ este numarul de noduri din graf si $M$ este numarul de muchii. Urmatoarele $M$ linii vor contine cate doua numere intregi $A$ si $B$, cu semnificatia ca exista o muchie intre nodul $A$ si nodul $B$. Nodurile din graf sunt numerotate cu numere de la $1$ la $N$.\r\n\r\nh2. Date de Iesire\r\n\r\nPentru fiecare graf, in ordinea data in fisierul de intrare, se va afisa in fisierul $arbciclu.out$ sirul $YES$ daca graful este un arbore de cicluri, sau $NO$ in caz contrar.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; T &le; 10$\r\n* $1 &le; N &le; 100.000$\r\n* $1 &le; M &le; 200.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. arbciclu.in |_. arbciclu.out |\r\n|2\r\n3 3\r\n1 2\r\n1 3\r\n3 2\r\n4 5\r\n1 2\r\n1 3\r\n3 2\r\n4 3\r\n2 4 \r\n| YES\r\nYES |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"arbciclu\")==',18,''),('problema/z','ZParcurgere','2006-11-11 15:13:11','==Include(page=\"template/taskheader\" task_id=\"z\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nh1. Z-parcurgere\r\n\r\nPetrica are o tabla patratica de dimensiuni **2^n^*2^n^**. Ar vrea sa scrie pe patratelele tablei numere naturale cuprinse intre 1 si **2^n^*2^n^** conform unei parcurgeri mai deosebite pe care o numeste Z-parcurgere. O Z-parcurgere viziteaza recursiv cele patru cadrane ale tablei in ordinea: stanga-sus, dreapta-sus, stanga-jos, dreapta-jos. De exemplu, daca *n=1*, ordinea vizitarii patratelelor de pe tabla este in forma de Z, ca in figura urmatoare:\r\n\r\n|=.1 |=.2|\r\n\r\n|=.3|=.4|\r\n\r\nDaca *n=2*, Petrica va traversa patratelele in ordinea:\r\n\r\n\r\n|=.1|=.2|=.5|=.6|\r\n\r\n|=.3|=.4|=.7|=.8|\r\n|=.9|=.10|=.13|=.14|\r\n|=.11|=.12|=.15|=.16|\r\n\r\nh2. Cerinta\r\n\r\nLa un moment dat Petrica ar vrea sa stie ce numar de ordine trebuie sa scrie conform Z-parcurgerii pe anumite patratele date prin coordonatele lor ( x, y ). Petrica incepe umplerea tablei intotdeauna din coltul din stanga-sus.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare z.in se afla doua numere naturale N si K , unde N reprezinta faptul ca tabla are dimensiunea 2^n*2^n , iar K este numarul patratelelor pe care Petrica ar vrea sa stie ce numar va trebui sa scrie pe ele. Pe fiecare din urmatoarele K linii se afla cate doua numere naturale ( x, y ), care reprezinta linia, respectiv coloana unui patratel ales. A i+1 -a linie descrie al i -lea patratel ( i = 1, 2, ..., k ).\r\n\r\nh2. Date de Iesire\r\n\r\nPe cele k linii ale fisierului de iesire z.out se va scrie cate un numar natural, corespunzator numarului pe care Petrica il va scrie pe patratelul ales. A i -a linie descrie al i -lea patratel ( i = 1, 2, ..., k ).\r\n\r\nh2. Restrictii si precizari\r\n\r\n. 1 <= N <= 15\r\n\r\n. 1 <= K <= 1.000\r\n\r\n. 1 <= x,y <= 2^n\r\n\r\nh2. Exemplu\r\n\r\n\r\n|z.in |z.out |\r\n\r\n|2 2 |13 |\r\n|3 3 |15 |\r\n|4 3 | |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"z\")==',256,''),('problema/avd','AVD','2006-11-11 15:29:17','==Include(page=\"template/taskheader\" task_id=\"avd\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nUn arbore este un graf neorientat, conex cu $N$ noduri si $N-1$ muchii. Se numeste arbore AVD un arbore care pentru fiecare partitie a lui $N  =n{~1~} + n{~2~} + ... + n{~k~}$ nodurile arborelui se pot imparti in $k$ multimi astfel incat multimea $i$ are n{~i~} noduri si fiecare multime ramane conexa, n{~i~} &le; n{~j~} pentru $i < j$. Gradul AVD al unui arbore este numarul de partitii care indeplinesc conditiile anterioare impartit la numarul total de partitii existente pentru $N$.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un arbore cu $N$ noduri, calculati gradul AVD al acestuia.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $avd.in$ contine $T$, numarul de teste din fisier apoi vor urma cele $T$ teste. Pe prima linie a fiecarui test se afla $N$ numarul de noduri, urmand apoi $N-1$ linii continand cate doua numere $x, y$ cu semnificatia exista muchie intre nodurile $x$ si $y$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $avd.out$ vor exista $T$ linii fiecare continand gradul AVD al arborelui descris la testului respectiv.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 13$\r\n* $1 &le; T &le; 50$\r\n* rezultatul se va afisa cu $5$ zecimale (prin rotunjire)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. avd.in |_. avd.out | explicatii |\r\n| 3\r\n4\r\n1 2\r\n1 3\r\n1 4\r\n5\r\n1 2\r\n2 3\r\n3 4\r\n4 5\r\n1\r\n| 0.80000\r\n1.00000\r\n1.00000 \r\n| Pentru primul test, exista in total 5  partitii pentru 4: 1+1+1+1, 1+1+2, 1+3, 2+2, 4 din care doar partitia 2+2 nu poate fi obtinuta. Deci gradul AVD al arborelui este 4/5=0.80000. |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"avd\")==',18,''),('problema/avd','AVD','2006-11-11 15:30:03','==Include(page=\"template/taskheader\" task_id=\"avd\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nUn arbore este un graf neorientat, conex cu $N$ noduri si $N-1$ muchii. Se numeste arbore AVD un arbore care pentru fiecare partitie a lui $N  = n{~1~} + n{~2~} + ... + n{~k~}$ nodurile arborelui se pot imparti in $k$ multimi astfel incat multimea $i$ are n{~i~} noduri si fiecare multime ramane conexa, $n{~i~} &le; n{~j~}$ pentru $i < j$. Gradul AVD al unui arbore este numarul de partitii care indeplinesc conditiile anterioare impartit la numarul total de partitii existente pentru $N$.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un arbore cu $N$ noduri, calculati gradul AVD al acestuia.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $avd.in$ contine $T$, numarul de teste din fisier apoi vor urma cele $T$ teste. Pe prima linie a fiecarui test se afla $N$ numarul de noduri, urmand apoi $N-1$ linii continand cate doua numere $x, y$ cu semnificatia exista muchie intre nodurile $x$ si $y$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $avd.out$ vor exista $T$ linii fiecare continand gradul AVD al arborelui descris la testului respectiv.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 13$\r\n* $1 &le; T &le; 50$\r\n* rezultatul se va afisa cu $5$ zecimale (prin rotunjire)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. avd.in |_. avd.out |_. explicatii |\r\n| 3\r\n4\r\n1 2\r\n1 3\r\n1 4\r\n5\r\n1 2\r\n2 3\r\n3 4\r\n4 5\r\n1\r\n| 0.80000\r\n1.00000\r\n1.00000 \r\n| Pentru primul test, exista in total 5  partitii pentru 4: 1+1+1+1, 1+1+2, 1+3, 2+2, 4 din care doar partitia 2+2 nu poate fi obtinuta. Deci gradul AVD al arborelui este 4/5=0.80000. |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"avd\")==',18,''),('problema/banana','Banana','2006-11-11 11:23:50','==Include(page=\"template/taskheader\" task_id=\"banana\")==\n\n==Include(page=\"template/raw\")==\n\nBanana\n\n\n\nSe considera o padure tropicala, reprezentata sub forma unui caroiaj dreptunghiular. Celula din coltul stanga sus al caroiajului are coordonatele (1, 1), iar coordonatele celorlalte celule sunt determinate de linia si coloana pe care se afla. In anumite celule ale caroiajului sunt plasati bananieri; o celula contine cel mult un bananier. Mai multi bananieri care se invecineaza pe orizontala sau verticala formeaza o zona de bananieri. Intr-o astfel de zona, CEKILI se deplaseaza usor, cu agilitatea-i cunoscuta, de la un bananier la altul.\n\nMaimuta CEKILI este lacoma si nu ii ajung bananele dintr-o singura zona. Tarzan vrea sa-si ajute prietena. Pentru aceasta, el ar putea conecta exact K zone de bananieri innodand mai multe liane si astfel CEKILI s-ar putea deplasa de la o zona la alta utilizand lianele. Evident, Tarzan trebuie sa aleaga zonele astfel incat numarul total de bananieri din cele K zone sa fie maxim.\n\nh2. Cerinta\n\nDeterminati numarul maxim de bananieri care se poate obtine prin conectarea a exact K zone.\n\nh2. Date de Intrare\n\nFisierul de intrare banana.in contine:\n\n\n\nbanana.in ]Semnificatie\nNr K Nr - numarul de bananieri\n\nx[1] y[1 K - numarul de zone ce pot fi conectate\n\n]x[2] y[2 x[i] - linia pe care se afla bananierul i\n\n]... y[i] - coloana pe care se afla bananierul i\n\nx[Nr] y[Nr\n\nh2. Date de Iesire\n\nFisierul de iesire banana.out va contine pe prima linie numarul maxim de bananieri care se poate obtine prin conectarea zonelor.\n\nh2. Restrictii\n\n&#159; 1 -L- Nr -L- 16 000\n\n&#159; 1 -L- xi, yi -L- 10 000, \"iI{1,2,...,Nr}\n\n&#159; in testele utilizate K nu va depasi numarul de zone.\n\n&#159; doua pozitii se invecineaza pe orizontala daca sunt pe aceeasi linie si pe coloane consecutive, respectiv pe verticala daca sunt pe aceeasi coloana si pe linii consecutive.\n\nh2. Exemplu\n\n\n|banana.in |banana.out |\n\n|10 3 |9 |\n| | |\n|7 10 | |\n| | |\n|1 1 | |\n| | |\n|101 1 | |\n| | |\n|2 2 | |\n| | |\n|102 1 | |\n| | |\n|7 11 | |\n| | |\n|200 202 | |\n| | |\n|2 1 | |\n| | |\n|3 2 | |\n| | |\n|103 1 | |\n| | |\n| | |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"banana\")==',0,''),('problema/avere','Avere','2006-11-11 11:23:55','==Include(page=\"template/taskheader\" task_id=\"avere\")==\n\n==Include(page=\"template/raw\")==\n\nAvere\n\nItalag a fost toata viata pasionat de speculatii bursiere reusind sa adune o avere considerabila. Fiind un tip original si pasiont de matematica a scris un testament inedit. Testamentul contine doua numere naturale: S reprezentand averea ce trebuie impartita mostenitorilor si N reprezentand alegerea sa pentru impartirea averii. Italag decide sa-si imparta toata averea, iar sumele pe care le acorda mostenitorilor sa fie in ordine strict descrescatoare.\n\nDe exemplu daca averea ar fi 7 unitati monetare, ar putea fi impartita astfel:\n\n4 (unitati primului mostenitor) 3 (unitati celui de-al doilea), sau\n\n6 (unitati primului mostenitor) 1 (unitati celui de-al doilea), sau\n\n7 (doar primului mostenitor), sau\n\n5 (unitati primului mostenitor) 2 (unitati celui de-al doilea), sau\n\n4 (unitati primului mostenitor) 2 (unitati celui de-al doilea) 1 ( unitate celui de-al treilea ).\n\nVazand ca ii este foarte greu sa verifice daca nu cumva a omis vreo varianta de impartire , Italag le-a scris in ordine lexicografica. Pentru exemplul de mai sus: 4 2 1; 4 3; 5 2; 6 1; 7.\n\nA hotarat ca banii sa fie distribuiti conform celei de a N-a posibilitati din ordinea lexicografica.\n\nh2. Cerinta\n\nScrieti un program care pentru numerele S, N date sa calculeze si sa afiseze numarul total de posibilitati de impartire a averii, precum si modul in care se face aceasta impartire conform cu a N-a posibilitate din ordinea lexicografica.\n\nh2. Date de Intrare\n\nFisierul de intrare avere.in contine o singura linie pe care se afla doua numere naturale separate printr-un singur spatiu:\n\n- primul numar (S) reprezinta suma totala\n\n- cel de-al doilea (N) reprezinta numarul de ordine al pozitiei cautate\n\nh2. Date de Iesire\n\nFisierul de iesire avere.out va contine doua linii:\n\n- pe prima linie va fi afisat numarul total de modalitati de impartire a averii;\n\n- pe cea de a doua linie va fi afisata a N-a posibilitate de impartire a lui S conform cerintei in ordine lexicografica. Elementele sale vor fi separate prin cate un spatiu.\n\nh2. Restrictii si precizari\n\no 1 < S < 701\no 0 < N < numarul total de posibilitati cu suma S\no Se acorda punctaj partial pentru fiecare test: 5 puncte pentru determinarea corecta a numarului de posibilitati de impartire a lui S si 5 puncte pentru determinarea corecta a posibilitatii N, din ordinea lexicografica\no Posibilitatile de impartire a averii sunt numerotate incepand cu 1\no Fie x = (x[1], x[2] ..., x[m]) si y = (y[1], y[2] ..., y[p]) doua siruri. Spunem ca x preceda pe y din punct de vedere lexicografic, daca exista k>=1, astfel incat x[i] = y[i], pentru orice i = 1, k-1 si x[k] < y[k].\n\nh2. Exemplu\n\n\n|avere.in |avere.out |\n\n|7 2 |5 |\n| | |\n| |4 3 |\n\n|12 5 |15 |\n| | |\n| |6 5 1 |\n\n|700 912345678912345678 |962056220379782044 |\n| | |\n| |175 68 63 58 54 45 40 36 34 32 20 18 17 14 11 9 3 2 1 |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"avere\")==',0,''),('problema/banana','Banana','2006-11-11 15:40:18','==Include(page=\"template/taskheader\" task_id=\"banana\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nSe considera o padure tropicala, reprezentata sub forma unui caroiaj dreptunghiular. Celula din coltul stanga sus al caroiajului are coordonatele $(1, 1)$, iar coordonatele celorlalte celule sunt determinate de linia si coloana pe care se afla. In anumite celule ale caroiajului sunt plasati bananieri; o celula contine cel mult un bananier. Mai multi bananieri care se invecineaza pe orizontala sau verticala formeaza o zona de bananieri. Intr-o astfel de zona, CEKILI se deplaseaza usor, cu agilitatea-i cunoscuta, de la un bananier la altul.\r\n\r\nMaimuta CEKILI este lacoma si nu ii ajung bananele dintr-o singura zona. Tarzan vrea sa-si ajute prietena. Pentru aceasta, el ar putea conecta exact $K$ zone de bananieri innodand mai multe liane si astfel CEKILI s-ar putea deplasa de la o zona la alta utilizand lianele. Evident, Tarzan trebuie sa aleaga zonele astfel incat numarul total de bananieri din cele $K$ zone sa fie maxim.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul maxim de bananieri care se poate obtine prin conectarea a exact $K$ zone.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $banana.in$ contine:\r\n\r\n\r\ntable(example). | banana.in | semnificatie |\r\n| Nr K\r\nx{~1~} y{~1~}\r\nx{~2~} y{~2~}\r\n...\r\nx{~Nr~} y{~Nr~}\r\n| Nr - numarul de bananieri \r\n  K&nbsp; - numarul de zone ce pot fi conectate\r\n  x{~i~} - linia pe care se afla bananierul i\r\n  y{~i~} - coloana pe care se afla bananierul i |\r\n\r\n\r\n\r\n \r\n\r\nbanana.in ]Semnificatie\r\nNr K Nr - numarul de bananieri\r\n\r\nx[1] y[1 K - numarul de zone ce pot fi conectate\r\n\r\n]x[2] y[2 x[i] - linia pe care se afla bananierul i\r\n\r\n]... y[i] - coloana pe care se afla bananierul i\r\n\r\nx[Nr] y[Nr\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire banana.out va contine pe prima linie numarul maxim de bananieri care se poate obtine prin conectarea zonelor.\r\n\r\nh2. Restrictii\r\n\r\n&#159; 1 -L- Nr -L- 16 000\r\n\r\n&#159; 1 -L- xi, yi -L- 10 000, \"iI{1,2,...,Nr}\r\n\r\n&#159; in testele utilizate K nu va depasi numarul de zone.\r\n\r\n&#159; doua pozitii se invecineaza pe orizontala daca sunt pe aceeasi linie si pe coloane consecutive, respectiv pe verticala daca sunt pe aceeasi coloana si pe linii consecutive.\r\n\r\nh2. Exemplu\r\n\r\n\r\n|banana.in |banana.out |\r\n\r\n|10 3 |9 |\r\n| | |\r\n|7 10 | |\r\n| | |\r\n|1 1 | |\r\n| | |\r\n|101 1 | |\r\n| | |\r\n|2 2 | |\r\n| | |\r\n|102 1 | |\r\n| | |\r\n|7 11 | |\r\n| | |\r\n|200 202 | |\r\n| | |\r\n|2 1 | |\r\n| | |\r\n|3 2 | |\r\n| | |\r\n|103 1 | |\r\n| | |\r\n| | |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"banana\")==',18,''),('problema/banana','Banana','2006-11-11 15:44:13','==Include(page=\"template/taskheader\" task_id=\"banana\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nSe considera o padure tropicala, reprezentata sub forma unui caroiaj dreptunghiular. Celula din coltul stanga sus al caroiajului are coordonatele $(1, 1)$, iar coordonatele celorlalte celule sunt determinate de linia si coloana pe care se afla. In anumite celule ale caroiajului sunt plasati bananieri; o celula contine cel mult un bananier. Mai multi bananieri care se invecineaza pe orizontala sau verticala formeaza o zona de bananieri. Intr-o astfel de zona, CEKILI se deplaseaza usor, cu agilitatea-i cunoscuta, de la un bananier la altul.\r\n\r\nMaimuta CEKILI este lacoma si nu ii ajung bananele dintr-o singura zona. Tarzan vrea sa-si ajute prietena. Pentru aceasta, el ar putea conecta exact $K$ zone de bananieri innodand mai multe liane si astfel CEKILI s-ar putea deplasa de la o zona la alta utilizand lianele. Evident, Tarzan trebuie sa aleaga zonele astfel incat numarul total de bananieri din cele $K$ zone sa fie maxim.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul maxim de bananieri care se poate obtine prin conectarea a exact $K$ zone.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $banana.in$ contine:\r\n\r\n\r\ntable(example). | banana.in | semnificatie |\r\n| Nr K\r\nx{~1~} y{~1~}\r\nx{~2~} y{~2~}\r\n...\r\nx{~Nr~} y{~Nr~}\r\n| Nr - numarul de bananieri \r\n  K&nbsp; - numarul de zone ce pot fi conectate\r\n  x{~i~} - linia pe care se afla bananierul i\r\n  y{~i~} - coloana pe care se afla bananierul i |\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $banana.out$ va contine pe prima linie numarul maxim de bananieri care se poate obtine prin conectarea zonelor.\r\n\r\nh2. Restrictii\r\n\r\n* 1 &le; Nr &le; 16 000\r\n* 1 &le; x{~i~}, y{~i~} &le; 10 000, i  _FIXME: APARTINE_ {1,2,...,Nr}\r\n* in testele utilizate $K$ nu va depasi numarul de zone\r\n* doua pozitii se invecineaza pe orizontala daca sunt pe aceeasi linie si pe coloane consecutive, respectiv pe verticala daca sunt pe aceeasi coloana si pe linii consecutive\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. banana.in |_. banana.out |\r\n| 10 3\r\n7 10\r\n1 1\r\n101 1\r\n2 2\r\n102 1\r\n7 11\r\n200 202\r\n2 1\r\n3 2\r\n103 1 \r\n| 9 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"banana\")==',18,''),('problema/barbar','Barbar','2006-11-11 12:07:22','==Include(page=\"template/taskheader\" task_id=\"barbar\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nbarbar\r\n\r\n\r\n\r\nPaftenie barbarul este un renumit aventurier. A condus razboaie, a descoperit comori, a cucerit cetati si inimile domnitelor. Insa de aceasta data a fost capturat de catre dusmanii sai cei mai temuti si aruncat intr-o temnita. Temnita este de fapt un grid de dimensiune R*C. In anumite celule exista dragoni, unele sunt ocupate de pereti, iar altele sunt libere. Paftenie trebuie sa iasa din temnita mergand numai prin celule libere (o celula are maxim 4 vecini) , si asta stand cat mai departe de fiorosii dragoni ale caror flacari ii pot deteriora vestimentatia (astfel incat minima din distantele pana la cel mai apropiat dragon din fiecare din celulele traseului sau sa fie maxim).\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe barbarul Paftenie sa iasa din temnita, determinand un traseu astfel incat minima din distantele pana la cel mai apropiat dragon din fiecare din celulele traseului sau sa fie maxim!\r\n\r\nh2. Date de Intrare (fisier: barbar.in)\r\n\r\nPe prima linie a fisierului de intrare sunt date doua numere intregi R si C, reprezentand numarul liniilor, respectiv al coloanelor temnitei. Pe urmatoarele R linii se afla cate C caractere, neseparate prin spatii, cu urmatoarele semnificatii:\r\n\r\n. celula libera\r\n\r\n* perete\r\n\r\nD dragon\r\n\r\nI punctul de plecare al lui Paftenie\r\n\r\nO iesirea din temnita\r\n\r\nh2. Date de Iesire (fisier: barbar.out)\r\n\r\nFisierul de iesire va contine pe prima linie un singur numar, reprezentand valoarea maxima pentru minima din distantele pana la cel mai apropiat dragon din fiecare din celulele traseului. In caz ca nu exista solutie se va afisa \"-1\".\r\n\r\nh2. Restrictii si precizari\r\n\r\n* 1 <= R, C <= 1.000\r\n\r\n* Se garanteaza ca in temnita exista cel putin un dragon\r\n\r\nh2. Exemplu\r\n\r\n{@ muie @}\r\n\r\nbarbar.in barbar.out Explicatie\r\n10 10 2 O solutie posibila este urmatoarea :\r\n{@ .......... .......... @}\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"barbar\")==',961,''),('problema/barman','Barman','2006-11-11 11:23:38','==Include(page=\"template/taskheader\" task_id=\"barman\")==\n\n==Include(page=\"template/raw\")==\n\nbarman\n\n\n\nPaftenie a decis sa se faca barman. Inainte de asta trebuie sa dovedeasca abilitate in manevrarea bauturilor. Barul lui Paftenie este alcatuit din N camere aliniate in cerc. In fiecare camera se afla un pahar cu bautura, fiecare bautura avand o anumita valoare (cuprinsa intre 1 si 2.000.000.000). El trebuie sa mute bauturile dintr-o camera in alta astfel incat la sfarsit, bauturile sa fie sortate dupa camere. Daca la sfarsit in camera i se afla o bautura cu valoarea a[i], sirul valorilor a[1],a[2]...a[N] se considera sortat daca exista 1 <= i <= N astfel incat a[i] <= a[i+1] <= ... <= a[N] <= a[1] <= ... <= a[i-1] (sirul este circular). In orice moment, Paftenie poate tine pe tava cel mult doua pahare. Pentru deplasarea bauturilor, poate efectua urmatoarele mutari:\n\nS poate lua un pahar din camera in care se afla si sa il aseze pe tava (il costa 10 secunde)\n\nS poate lasa un pahar intr-o camera in care nu se afla nici o bautura (il costa 10 secunde)\n\nS se poate deplasa din camera i in camera j avand pe tava c pahare (0 <= c <= 2) (il costa c*|i-j| secunde)\n\nh2. Cerinta\n\nAjutati-l pe Paftenie sa sorteze paharele intr-un timp minim !\n\nh2. Date de Intrare\n\nPe prima linie a fisierului de intrare barman.in este dat numarul N al bauturilor. Pe urmatoarea linie se afla N intregi reprezentand valorile bauturilor - al i-ulea numar reprezinta valoarea bauturii aflate initial in camera i (a[i]).\n\nh2. Date de Iesire\n\nFisierul barman.out va contine pe prima linie un singur numar reprezentand timpul minim de sortare a bauturilor.\n\nh2. Restrictii si precizari\n\nS 1 <= N <= 600\n\nS In orice moment, in afara de paharele care le are paftenie pe tava, intr-o camera poate exista maxim un pahar\n\nh2. Exemplu\n\n\n|barman.in |barman.out |Explicatii |\n\n|4 |42 |* 5 2 2 |\n| | |merge in camera 1 si pune paharul de acolo pe tava (10s) |\n|1 5 2 2 | |* 5 2 2 |\n| | |merge din camera 1 in camera 2 cu un pahar pe tava (1s) |\n| | |* * 2 2 |\n| | |pune pe tava paharul din camera 2 (10s) |\n| | |* 1 2 2 |\n| | |asaza pe masa din camera 2 paharul cu bautura de valoare 1 (10s) |\n| | |* 1 2 2 |\n| | |se intoarce in camera 1 cu un pahar pe tava (1s) |\n| | |5 1 2 2 |\n| | |asaza pe masa din camera 1 paharul cu bautura de valoare 5(10s) |\n| | |-> 42 de secunde |\n| | |sirul este sortat deoarece 1 <= 2 <= 2 <= 5 (a[2] <= a[3] <= a[4] <= |\n| | |a[1]) |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"barman\")==',0,''),('problema/bcolor','Bcolor','2006-11-11 16:02:56','==Include(page=\"template/taskheader\" task_id=\"bcolor\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nOmida Smith s-a apucat din nou de colorat. De data aceasta s-a gandit sa incerce cu grafuri neorientate cu $N$ noduri etichetate de la $1$ la $N$ si $M$ muchii numerotate de la $1$ la $M$.\r\n\r\nLa o plimbare, Smith porneste din nodul etichetat cu $1$, se plimba pe muchiile grafului, dupa care se intoarce in nodul de plecare.\r\n\r\nAstfel, drumul parcurs de Smith incepe si se termina cu nodul $1$, poate trece de mai multe prin acelasi nod si de asemenea poate trece de mai multe ori prin aceeasi muchie.\r\n\r\nMuchiile grafului sunt initial colorate in alb, iar la fiecare trecere a omizii peste o muchie aceasta isi schimba culoarea: din alba devine rosie si din rosie devine alba.\r\n\r\nFiecarui drum ii corespunde astfel o colorare finala a muchiilor, pe care vom numi configuratie posibila si o vom reprezenta ca un sir de M elemente reprezentand in ordine culorile finale ale muchiilor ($A$ pentru alb, respectiv $R$ pentru rosu).\r\n\r\nOmida a observat ca din toate configuratiile posibile, nu toate sunt frumoase. Exista unele muchii speciale care nu arata bine decat daca au o anumita culoare.\r\n\r\nSmith vrea sa dea lovitura pe piata de grafuri de arta, asa ca genereaza pentru un graf dat toate configuratiile frumoase posibile in ordine lexicografica. Va lansa pe piata cea de a $K$-a configuratie generata, configuratiile fiind numerotate incepand cu $1$.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine cea de a $K$-a configuratie frumoasa posibila, in ordine lexicografica.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $bcolor.in$ se vor afla numerele naturale $N, M, K$ separate prin cate un spatiu. Pe urmatoarele $M$ linii se vor afla descrierile muchiilor grafului.\r\n\r\nPe linia $i+1$ se va afla descrierea muchiei $i$, formata din $3$ numere naturale $x, y, z$ separate prin cate un spatiu. Numerele $x$ si $y$ reprezinta nodurile care sunt extremitatile muchiei, iar $z$ este un numar care poate lua valorile cu semnificatia de mai jos:\r\n\r\n$z=0$ &nbsp;&nbsp;&nbsp; muchia nu este speciala\r\n$z=1$ &nbsp;&nbsp;&nbsp; muchia este speciala, trebuie neaparat colorata in alb\r\n$z=2$ &nbsp;&nbsp;&nbsp; muchia este speciala, trebuie neaparat colorata in rosu.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bcolor.out$ va contine o singura linie formata din $M$ caractere din multimea ${A, R}$ reprezentand in ordine culorile muchiilor din cea de a $K$-a configuratie frumoasa posibila pentru graful din fisierul de intrare.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 200$\r\n* $1 &le; K &le; 10^8$\r\n* Exista minim $K$ configuratii frumoase posibile pentru graful dat.\r\n* Muchiile din fisierul de intrare sunt distincte.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bcolor.in |_. bcolor.out |_. explicatie |\r\n| 10 10 2\r\n1 2 0\r\n3 5 1\r\n2 3 0\r\n3 4 0\r\n4 5 0\r\n5 2 0\r\n2 4 0\r\n6 7 0\r\n7 8 0\r\n8 6 0\r\n| AAAARRRAAA\r\n| Configuratiile frumoase posibile n ordine lexicografic&#227; sunt:\r\n1: AAAAAAAAAA\r\n2: AAAARRRAAA\r\n3: AARRAARAAA\r\n4: AARRRRAAAA |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bcolor\")==',18,''),('problema/ben','Ben','2006-11-11 11:23:47','==Include(page=\"template/taskheader\" task_id=\"ben\")==\n\n==Include(page=\"template/raw\")==\n\nBen\n\n\n\nLa o benzinarie sosesc intr-o zi N masini pentru a se alimenta. Pentru fiecare masina se cunoaste momentul sosirii si momentul plecarii din benzinarie, intervalul de timp dintre sosire si plecare fiind utilizat exclusiv pentru alimentare. O pompa de benzina se poate utiliza pentru alimentarea unei singure masini la un moment dat (ea poate sa alimenteze mai multe masini dar nu in acelasi timp). Alimentarea unei masini incepe exact in momentul sosirii ei in benzinarie si se termina exact in momentul plecarii, fiind utilizata o singura pompa pe tot timpul parcarii sale in benzinarie.\n\nh2. Cerinta\n\nStiind informatiile despre sosirile si plecarile celor N clienti, aflati K reprezentand numarul minim de pompe de benzina necesare servirii tuturor clientilor. Se cere si numarul de modalitati distincte de servire a clientilor utilizand exact K pompe de alimentare.\n\nh2. Date de Intrare\n\nIn fisierul ben.in se afla pe prima linie un numar N reprezentand numarul de clienti. Urmeaza N linii fiecare continand doua numere, A si B (A<B), separate printr-un spatiu reprezentand timpul de sosire respectiv timpul de plecare al unui client.\n\nh2. Date de Iesire\n\nFisierul de iesire ben.out va contine o singura linie pe care se vor afla doua numere intregi K si S reprezentand numarul minim de pompe de alimentare si numarul de modalitati de servire a clientilor folosind exact K pompe de alimentare. Numarul S va fi afisat modulo 32173.\n\nh2. Restrictii\n\n. 0 < N <= 30 000, dar pentru 70% din teste N <= 300\n\no Timpii de sosire si plecare vor fi numere intregi din intervalul [1, 30 000]\no Nu va exista o masina care soseste in momentul pleacarii altei masini\no Daca primul numar din fisierul de iesire este corect veti primi 6 puncte pe acel test iar daca sunt corecte ambele numere veti primi 10 puncte. Nu se vor acorda puncte daca este corect numai cel de-al doilea numar.\n\no Doua modalitati de servire a clientilor se considera diferite daca exista cel putin un client care nu a fost servit la aceeasi pompa in cele doua modalitati\no Clientilor nu le place sa astepte asa ca trebuie sa va asigurati ca exista cel putin o pompa libera la sosirea fiecaruia in benzinarie\no Atentie! Numarul Sse va afisa modulo 32173\n\nExemple\n\n\n|ben.in|ben.out|Explicatii |\n\n|4 |2 4 |Numarul minim de pompe de alimentare este 2. |\n| | | |\n|1 4 | |Cele 4 modalitati de servire ale clientilor sunt: |\n| | | |\n|5 7 | |1, 1, 1, 2 (prima modalitate) |\n| | | |\n|8 10 | |1, 1, 2, 2 (a doua) |\n| | | |\n|2 7 | |2, 2, 1, 1 (a treia) |\n| | | |\n| | |2, 2, 2, 1 (a patra) |\n| | | |\n| | |Fiecare numar reprezinta indicele pompei la care s-a alimentat fiecare|\n| | |client, pastrand ordinea acestora din fisierul de intrare. |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"ben\")==',0,''),('problema/bcolor','Bcolor','2006-11-11 16:05:32','==Include(page=\"template/taskheader\" task_id=\"bcolor\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nOmida Smith s-a apucat din nou de colorat. De data aceasta s-a gandit sa incerce cu grafuri neorientate cu $N$ noduri etichetate de la $1$ la $N$ si $M$ muchii numerotate de la $1$ la $M$.\r\n\r\nLa o plimbare, Smith porneste din nodul etichetat cu $1$, se plimba pe muchiile grafului, dupa care se intoarce in nodul de plecare. Astfel, drumul parcurs de Smith incepe si se termina cu nodul $1$, poate trece de mai multe prin acelasi nod si de asemenea poate trece de mai multe ori prin aceeasi muchie. Muchiile grafului sunt initial colorate in alb, iar la fiecare trecere a omizii peste o muchie aceasta isi schimba culoarea: din alba devine rosie si din rosie devine alba.\r\n\r\nFiecarui drum ii corespunde astfel o colorare finala a muchiilor, pe care vom numi configuratie posibila si o vom reprezenta ca un sir de M elemente reprezentand in ordine culorile finale ale muchiilor ({$A$} pentru alb, respectiv $R$ pentru rosu). Omida a observat ca din toate configuratiile posibile, nu toate sunt frumoase. Exista unele muchii speciale care nu arata bine decat daca au o anumita culoare.\r\n\r\nSmith vrea sa dea lovitura pe piata de grafuri de arta, asa ca genereaza pentru un graf dat toate configuratiile frumoase posibile in ordine lexicografica. Va lansa pe piata cea de a $K$-a configuratie generata, configuratiile fiind numerotate incepand cu $1$.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine cea de a $K$-a configuratie frumoasa posibila, in ordine lexicografica.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $bcolor.in$ se vor afla numerele naturale $N, M, K$ separate prin cate un spatiu. Pe urmatoarele $M$ linii se vor afla descrierile muchiilor grafului.\r\n\r\nPe linia $i+1$ se va afla descrierea muchiei $i$, formata din $3$ numere naturale $x, y, z$ separate prin cate un spatiu. Numerele $x$ si $y$ reprezinta nodurile care sunt extremitatile muchiei, iar $z$ este un numar care poate lua valorile cu semnificatia de mai jos:\r\n\r\n$z=0$ &nbsp;&nbsp;&nbsp; muchia nu este speciala\r\n$z=1$ &nbsp;&nbsp;&nbsp; muchia este speciala, trebuie neaparat colorata in alb\r\n$z=2$ &nbsp;&nbsp;&nbsp; muchia este speciala, trebuie neaparat colorata in rosu.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bcolor.out$ va contine o singura linie formata din $M$ caractere din multimea ${A, R}$ reprezentand in ordine culorile muchiilor din cea de a $K$-a configuratie frumoasa posibila pentru graful din fisierul de intrare.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 200$\r\n* $1 &le; K &le; 10^8$\r\n* Exista minim $K$ configuratii frumoase posibile pentru graful dat.\r\n* Muchiile din fisierul de intrare sunt distincte.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bcolor.in |_. bcolor.out |_. explicatie |\r\n| 10 10 2\r\n1 2 0\r\n3 5 1\r\n2 3 0\r\n3 4 0\r\n4 5 0\r\n5 2 0\r\n2 4 0\r\n6 7 0\r\n7 8 0\r\n8 6 0\r\n| AAAARRRAAA\r\n| Configuratiile frumoase posibile n ordine lexicografic&#227; sunt:\r\n1: AAAAAAAAAA\r\n2: AAAARRRAAA\r\n3: AARRAARAAA\r\n4: AARRRRAAAA |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bcolor\")==',18,''),('problema/zc','Zota & Chidil','2006-11-11 15:55:31','==Include(page=\"template/taskheader\" task_id=\"zc\")==\r\n\r\nZota si Chidil s-au certat. De aceasta data, Zota, dorind sa se razbune, planuieste sa insire o serie de capcane in padurea prin care Chidil obisnuieste sa se plimbe. Astfel, folosind o formula magica, el asterne o capcana in mai multe celule ale padurii. Toate celulele care se afla la o distanta Manhattan mai mica sau egala cu _2_ de capcana sunt si ele afectatate.\r\nIn imaginea de mai jos capcana este reprezentata prin **O** iar celelalte celule afectate sunt marcate cu **X**.\r\n\r\n     $.......$\r\n     $...X...$\r\n     $..XXX..$\r\n     $.XXOXX.$\r\n     $..XXX..$\r\n     $...X...$\r\n     $.......$\r\n\r\nChidil isi planifica intotdeauna traseul. El porneste intotdeauna din celula cu coordonate (0, 0). Drumul lui este descris printr-o pereche ({$D$}, {$x$}) unde D apartine multimii {**N**, **E**, **S**, **V**}, iar $x$ este un numar natural nenul. Aceasta inseamna ca din pozitia in care se afla, va face $x$ pasi in directia $D$.\r\nDesi afla de planul malefic al lui Zota, Chidil nu vrea sa isi schimbe traseul cu nici un chip. Prefera sa afle cate celule din traseul lui contin capcane sau sunt afectate de capcane, pentru a sti exact cat praf magic pentru neutralizarea celulelor sa ia la el.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Chidil sa afle raspunsul!\r\n\r\nh2. Date de intrare\r\n\r\nLinia 1 a fisierului de intrare se afla doua numere naturale $N$ si $M$, reprezentand numarul de capcane intinse de Zota, respectiv numarul de perechi ({$D$}, $x$) conform carora Chidil urmeaza sa se deplaseze.\r\n\r\nLiniile $2 .. N+1$ contin cate o pereche de numere ({$x$} {$y$}), ce reprezinta coordonatele capcanelor.\r\n\r\nLiniile $N+2 .. N+M+1$ contin cate o pereche de forma $D$, $x$, cu semnificatia ca Chidil face $x$ pasi in directia $D$.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire va contine pe prima linie numarul de celule periculoase care trebuie neutralizate de Chidil in drumul sau.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 100 000$\r\n* Coordonatele lui Chidil nu vor iesi niciodata din intervalul [$-2 000 000 000$, $2 000 000 000$]\r\n* Chiar daca celula de pornire a lui Chidil contine sau este afectata de o capcana, nu este nevoie de praf magic pentru a o neutraliza\r\n* Desi o celula poate fi afectata de mai multe capcane, este nevoie de o singura unitate de praf magic pentru a o neutraliza\r\n* Efectul prafului magic este temporar; de fiecare data cand Chidil trece printr-o celula afectata, are nevoie de praf magic pt a o neutraliza\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. zc.in |_. zc.out |_. Explicatii |\r\n| 2 8 \r\n5 6 \r\n12 10 \r\nN 3 \r\nE 6 \r\nN 7 \r\nE 2 \r\nS 3 \r\nE 6 \r\nN 6 \r\nV 3\r\n| 4\r\n| ...........####............ \r\n............X.#............ \r\n...........XXX#............ \r\n......###.XXOX#............ \r\n......#.#..XXX#............ \r\n.....X#.#...X.#............ \r\n....XX#.#######............. \r\n...XXO#X................... \r\n....XX#.................... \r\n.....X#.................... \r\n#######.................... \r\n#.......................... \r\n#.......................... \r\n#.......................... |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"zc\")==',256,''),('problema/bile','Bile','2006-11-11 11:23:43','==Include(page=\"template/taskheader\" task_id=\"bile\")==\n\n==Include(page=\"template/raw\")==\n\nBile\n\n\n\nPe o tabla patratica impartita in N*N patratele (N linii si N coloane), se afla asezate N*N bile (cate una in fiecare patratica a tablei). Lui Gigel ii plac bilele foarte mult, astfel ca el ia, pe rand, cate o bila de pe tabla, pana cand nu mai ramane pe tabla nici o bila. Gigel este, de asemenea, un baiat foarte curios. El a constatat ca bilele pot fi impartite in componente conexe, astfel:\n\n. fiecare bila face parte din exact o componenta conexa\n\n. daca 2 bile sunt invecinate pe orizontala sau verticala, atunci ele fac parte din aceeasi componenta conexa (adica daca una se afla imediat deasupra, dedesubtul, la dreapta sau la stanga celeilalte)\n\nDimensiunea unei componente conexe este egala cu numarul de bile care fac parte din componenta conexa respectiva. Dupa fiecare bila luata, Gigel vrea sa stie care este valoarea maxima dintre dimensiunile componentelor conexe din care fac parte bilele ramase.\n\nh2. Date de Intrare\n\nPrima linie a fisierului bile.in contine numarul intreg N, reprezentand numarul de linii si de coloane ale tablei. Pe urmatoarele N^2 linii se afla cate 2 numere intregi L si C, separate printr-un spatiu, reprezentand linia si coloana pe care se afla bila pe care o ia Gigel. Coordonatele bilelor sunt date in ordinea in care bilele sunt luate de pe tabla.\n\nh2. Date de Iesire\n\nIn fisierul bile.out veti afisa N^2 linii. Pe fiecare linie veti afisa dimensiunea maxima ceruta dupa fiecare bila luata de pe tabla.\n\nh2. Restrictii si precizari\n\n. 1 <= N <= 250\n\nh2. Exemplu\n\nbile.in bile.out\n3 8\n\n2 1 7\n\n2 2 4\n\n3 3 2\n\n1 3 2\n\n1 2 2\n\n2 3 1\n\n3 1 1\n\n1 1 0\n\n3 2\n\n\n==Include(page=\"template/taskfooter\" task_id=\"bile\")==',0,''),('problema/map','Map','2006-11-11 16:19:32','==Include(page=\"template/taskheader\" task_id=\"map\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nMax Damage, pentru a nu se pierde in calatoriile sale doreste sa isi faca o harta. Pentru a nu fi citita de oricine, el o codifica sub forma unei matrice cu $N$ linii si $M$ coloane. Pentru ca scrie urat, se duce la un prieten care are un tipar si il roaga sa ii tipareasca harta. Tiparul, fiind mai vechi, este stricat si tipareste harta de doua ori pe aceeasi foaie, dar cu o deplasare (spre dreapta).\r\nApare politia si Max fuge cu foaia prost tiparita. Ajuns la ascunzatoare el vede catastrofa: portiunea unde cele doua imprimari s-au suprapus se intampla sa coincida, astfel ca nu isi poate da seama unde se termina una si unde incepe cealalta. El vrea acum un program care, primind o astfel de matrice, sa returneze cea mai mica dimensiune a matricei originale astfel incat, suprapusa de doua ori cu o deplasare corecta spre dreapta, sa se obtina cea finala\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Max sa rezolve si aceasta problema zdrobitoare.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie din fisierul $map.in$ va contine numerele $M$ si $N$, reprezetand dimensiunea matricei. Urmatoarele M linii vor contine cate $N$ litere mici ale alfabetului englez (matricea prost tiparita).\r\n\r\nh2. Date de Iesire\r\n\r\nFiserul $map.out$ va contine pe prima linie o singura valoare, reprezentand dimensiunea orizontala minima a matricei originale.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $1 <= N, M <= 2000$\r\n\r\n\r\n\r\nh2. Exemple\r\n\r\ntable(exemple). |_. map.in |_. map.out |_. Explicatii |\r\n| 3 5\r\n  anana\r\n  arara\r\n  mamam\r\n| 3\r\n| Pornind de la matricea de lungime 3\r\n\r\n  ana\r\n  ara \r\n  mam\r\n\r\n  suprapusa de doua ori se obtine:\r\n  anana\r\n  arara\r\n  mamam\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"map\")==',48,''),('problema/biomech','Biomech','2006-11-11 11:24:00','==Include(page=\"template/taskheader\" task_id=\"biomech\")==\n\n==Include(page=\"template/raw\")==\n\nLink: [1]File-List\n\nBiomech\n\nh2. Cerinta\n\n\n\nIn anul 2006, oamenii au construit primul robot biomecanic cu inteligenta artificiala. In orice caz, inca nu se stie prea bine cat de avansata este inteligenta sa. Tocmai de aceea, robotul va fi supus unui test. El va fi plasat intr-o zona rectangulara, impartita in patrate amplasate pe 5 linii si un numar infinit de coloane. Coloanele sunt numerotate de la -infinit la +infinit si robotul este plasat initial in coloana cu numarul 0. Liniile zonei rectangulare sunt numerotate de la 1 la 5 si robotul va fi plasat la inceput in linia 3 (cea din mijloc). Robotul va fi orientat in una din cele 8 directii posibile: Nord, Nord-Est, Est, Sud-Est, Est, Sud, Sud-Vest, Vest, Nord-Vest.\n\n\n\nMutarile pe care robotul le poate face sunt:\n\n\n\no Rotatie cu un unghi multiplu de 45 de grade\n\n\n\nDin directia spre care este indreptat, robotul se poate intoarce astfel spre oricare alta directie. O rotatie de la o directie initiala la o directie finala consuma o anumita cantitate de timp. Din cauza structurii interne a robotului, se poate ca o rotatie cu un unghi mai mare sa dureze mai putin decat o rotatie cu un unghi mic. De asemenea, o rotatie din directia X in directia Y s-ar putea sa nu dureze la fel de mult ca o rotatie din directia Y in directia X.\n\n\n\no Miscare in directia spre care este orientat, din patratul curent in urmatorul patrat (avand o muchie comuna sau un varf comun cu acesta)\n\n\n\nDe exemplu, daca robotelul este la linia 3, coloana X, orientat spre Nord-Est, s-ar putea deplasa in patratelul de pe linia 2, coloana X+1. Dupa mutare, robotul nu-si schimba directia in care este orientat. De asemenea, nu ii este permis sa mute in afara zonei rectangulare (asadar, anumite miscari sunt interzise din anumite patrate).\n\n\n\nCantitatea de timp necesara pentru o mutare depinde atat de directia in care se muta (din cauza campului magnetic al Pamantului) cat si de linia pe care robotul se afla in momentul curent (deoarece fiecare dintre cele 5 randuri are o structura electromagnetica diferita). Totusi, costurile mutarilor nu depind de coloana in care se afla robotul.\n\n\n\nRobotul va fi supus unui test, dupa cum urmeaza: i se vor acorda TMAX unitati de timp. Folosindu-le, va trebui sa mute cat mai departe posibil de pozitia curenta. Distanta nu este masurata in termeni de patrate, ci in termeni de coloane. Daca dupa TMAX unitati temporale robotul se afla pe coloana X, distanta este considerata |X| (valoarea absoluta a lui X). Nu\n\neste importanta linia pe care ajunge.\n\n\n\nRobotul va alege directia in care va fi orientat initial si cantitatea de timp va incepe sa scada dupa ce face aceasta decizie. Aflati care este distanta maxima pe care robotul o poate parcurge in TMAX unitati de timp.\n\nh2. Date de Intrare\n\n\n\nPrima linie a fisierului de intrare biomech.in contine cantitatea de timp TMAX. Urmatoarele 8 linii contin cate 8 numere intregi fiecare. Al j-ulea numar de pe a i-a dintre aceste linii reprezinta timpul necesar pt. a schimba directia i in directia j. Urmatoarele 5 linii contin cate 8 numere intregi fiecare. Al j-ulea numar de pe a i-a dintre aceste linii reprezinta timpul necesar pentru a muta in directia j dintr-un patrat de pe linia i. Sunt date valori si pentru mutarile interzise. Acestea trebuie ignorate.\n\n\n\nOrdinea directiilor (de la 1 la 8) este urmatoarea: N, NE, E, SE, S, SV, V, NV.\n\nh2. Date de Iesire\n\n\n\nAfisati pe singura linie a fisierului biomech.out distanta maxima pe care robotul o poate parcurge fara sa depaseasca durata de timp TMAX.\n\nh2. Restrictii si precizari\n\n\n\n- 1 <= TMAX <= 10^15, TMAX este intreg\n\n- 1 <= timpul necesar pentru orice rotatie sau miscare <= 1.000\n\n\n\n\n\nExemple\n\n\n\nbiomech.in biomech.out\n\n\n4 2\n\n0 10 10 10 10 10 10 10\n\n10 0 10 10 10 10 10 1\n\n10 10 0 10 10 10 10 10\n\n10 10 10 0 10 10 10 10\n\n10 10 10 10 0 10 10 10\n\n10 10 10 10 10 0 10 10\n\n10 10 10 10 10 10 0 10\n\n10 10 10 1 10 10 10 0\n\n1000 1000 1000 1000 1000 1000 1000 1000\n\n1000 1000 1000 1 1000 1000 1000 1000\n\n1000 1 1000 1000 1000 1000 1000 1000\n\n1000 1000 1000 1000 1000 1000 1000 1000\n\n1000 1000 1000 1000 1000 1000 1000 1000\n\n\n\n\n\nbiomech.in biomech.out\n\n\n100000 14285\n\n0 1000 1000 1000 1000 1000 1000 1000\n\n1000 0 1000 1000 1000 1000 1000 1000\n\n1000 1000 0 1000 1000 1000 1000 1000\n\n1000 1000 1000 0 1000 1000 1000 1000\n\n1000 1000 1000 1000 0 1000 1000 1000\n\n1000 1000 1000 1000 1000 0 1000 1000\n\n1000 1000 1000 1000 1000 1000 0 1000\n\n1000 1000 1000 1000 1000 1000 1000 0\n\n1000 1000 1000 1000 1000 1000 1000 1000\n\n1000 1000 1000 1000 1000 1000 1000 1000\n\n1000 1000 1000 1000 1000 1000 7 1000\n\n1000 1000 1000 1000 1000 1000 1000 1000\n\n1000 1000 1000 1000 1000 1000 1000 1000\n\n\n\n\n\n\n\nbiomech.in biomech.out\n\n\n50 2\n\n12 8 43 20 45 13 28 18\n\n34 28 17 18 19 49 43 46\n\n22 32 11 48 29 46 15 22\n\n42 20 5 5 25 13 4 39\n\n31 31 1 34 26 31 40 40\n\n29 5 19 25 47 37 3 45\n\n32 43 25 18 42 33 47 34\n\n35 35 6 49 32 15 23 40\n\n22 4 1 12 24 16 46 40\n\n23 27 39 21 19 16 20 39\n\n42 26 42 45 50 46 39 6\n\n23 8 45 16 36 26 31 18\n\n40 47 48 26 10 7 3 13\n\n\n\n\n\n\n\nReferences\n\nVisible links\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/biomech/enunt_files/filelist.xml\n==Include(page=\"template/taskfooter\" task_id=\"biomech\")==',0,''),('problema/biomech','Biomech','2006-11-11 16:27:05','==Include(page=\"template/taskheader\" task_id=\"biomech\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nIn anul 2006, oamenii au construit primul robot biomecanic cu inteligenta artificiala. In orice caz, inca nu se stie prea bine cat de avansata este inteligenta sa. Tocmai de aceea, robotul va fi supus unui test. El va fi plasat intr-o zona rectangulara, impartita in patrate amplasate pe $5$ linii si un numar infinit de coloane. Coloanele sunt numerotate de la $-infinit$ la $+infinit$ si robotul este plasat initial in coloana cu numarul $0$. Liniile zonei rectangulare sunt numerotate de la $1$ la $5$ si robotul va fi plasat la inceput in linia $3$ (cea din mijloc). Robotul va fi orientat in una din cele $8$ directii posibile: Nord, Nord-Est, Est, Sud-Est, Est, Sud, Sud-Vest, Vest, Nord-Vest.\r\n\r\nMutarile pe care robotul le poate face sunt:\r\n\r\n* Rotatie cu un unghi multiplu de 45 de grade\r\nDin directia spre care este indreptat, robotul se poate intoarce astfel spre oricare alta directie. O rotatie de la o directie initiala la o directie finala consuma o anumita cantitate de timp. Din cauza structurii interne a robotului, se poate ca o rotatie cu un unghi mai mare sa dureze mai putin decat o rotatie cu un unghi mic. De asemenea, o rotatie din directia $X$ in directia $Y$ s-ar putea sa nu dureze la fel de mult ca o rotatie din directia $Y$ in directia $X$.\r\n* Miscare in directia spre care este orientat, din patratul curent in urmatorul patrat (avand o muchie comuna sau un varf comun cu acesta)\r\nDe exemplu, daca robotelul este la linia $3$, coloana $X$, orientat spre Nord-Est, s-ar putea deplasa in patratelul de pe linia $2$, coloana $X+1$. Dupa mutare, robotul nu-si schimba directia in care este orientat. De asemenea, nu ii este permis sa mute in afara zonei rectangulare (asadar, anumite miscari sunt interzise din anumite patrate).\r\n\r\nCantitatea de timp necesara pentru o mutare depinde atat de directia in care se muta (din cauza campului magnetic al Pamantului) cat si de linia pe care robotul se afla in momentul curent (deoarece fiecare dintre cele 5 randuri are o structura electromagnetica diferita). Totusi, costurile mutarilor nu depind de coloana in care se afla robotul.\r\n\r\nRobotul va fi supus unui test, dupa cum urmeaza: i se vor acorda $TMAX$ unitati de timp. Folosindu-le, va trebui sa mute cat mai departe posibil de pozitia curenta. Distanta nu este masurata in termeni de patrate, ci in termeni de coloane. Daca dupa $TMAX$ unitati temporale robotul se afla pe coloana $X$, distanta este considerata |{$X$}| (valoarea absoluta a lui $X$). Nu este importanta linia pe care ajunge.\r\n\r\nRobotul va alege directia in care va fi orientat initial si cantitatea de timp va incepe sa scada dupa ce face aceasta decizie. Aflati care este distanta maxima pe care robotul o poate parcurge in $TMAX$ unitati de timp.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $biomech.in$ contine cantitatea de timp $TMAX$. Urmatoarele $8$ linii contin cate $8$ numere intregi fiecare. Al $j$-lea numar de pe a $i$-a dintre aceste linii reprezinta timpul necesar pentru a schimba directia $i$ in directia $j$. Urmatoarele $5$ linii contin cate $8$ numere intregi fiecare. Al $j$-lea numar de pe a $i$-a dintre aceste linii reprezinta timpul necesar pentru a muta in directia $j$ dintr-un patrat de pe linia $i$. Sunt date valori si pentru mutarile interzise. Acestea trebuie ignorate.\r\n\r\nOrdinea directiilor (de la $1$ la $8$) este urmatoarea: $N, NE, E, SE, S, SV, V, NV$.\r\n\r\nh2. Date de Iesire\r\n\r\nAfisati pe singura linie a fisierului $biomech.out$ distanta maxima pe care robotul o poate parcurge fara sa depaseasca durata de timp $TMAX$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* {$1 &le; TMAX &le; 10^15^$}, $TMAX$ este intreg\r\n* $1$ &le; timpul necesar pentru orice rotatie sau miscare &le; $1.000$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. biomech.in |_. biomech.out |\r\n| 4\r\n0 10 10 10 10 10 10 10\r\n10 0 10 10 10 10 10 1\r\n10 10 0 10 10 10 10 10\r\n10 10 10 0 10 10 10 10\r\n10 10 10 10 0 10 10 10\r\n10 10 10 10 10 0 10 10\r\n10 10 10 10 10 10 0 10\r\n10 10 10 1 10 10 10 0\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n1000 1000 1000 1 1000 1000 1000 1000\r\n1000 1 1000 1000 1000 1000 1000 1000\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n| 2 |\r\n| 100000\r\n0 1000 1000 1000 1000 1000 1000 1000\r\n1000 0 1000 1000 1000 1000 1000 1000\r\n1000 1000 0 1000 1000 1000 1000 1000\r\n1000 1000 1000 0 1000 1000 1000 1000\r\n1000 1000 1000 1000 0 1000 1000 1000\r\n1000 1000 1000 1000 1000 0 1000 1000\r\n1000 1000 1000 1000 1000 1000 0 1000\r\n1000 1000 1000 1000 1000 1000 1000 0\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n1000 1000 1000 1000 1000 1000 7 1000\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n1000 1000 1000 1000 1000 1000 1000 1000\r\n| 14285 |\r\n| 50\r\n12 8 43 20 45 13 28 18\r\n34 28 17 18 19 49 43 46\r\n22 32 11 48 29 46 15 22\r\n42 20 5 5 25 13 4 39\r\n31 31 1 34 26 31 40 40\r\n29 5 19 25 47 37 3 45\r\n32 43 25 18 42 33 47 34\r\n35 35 6 49 32 15 23 40\r\n22 4 1 12 24 16 46 40\r\n23 27 39 21 19 16 20 39\r\n42 26 42 45 50 46 39 6\r\n23 8 45 16 36 26 31 18\r\n40 47 48 26 10 7 3 13\r\n| 2 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"biomech\")==',18,''),('problema/matrix','Matrix','2006-11-11 11:23:49','==Include(page=\"template/taskheader\" task_id=\"matrix\")==\n\n==Include(page=\"template/raw\")==\n\nmatrix\n\n\n\nCercetatorii din tara lui Papura-Voda au descoperit harta genomului uman si au reprezantat-o ca matrice de dimensiuni MxM ce contine litere mici ale alfabetului englez. O specie extrateresta a atacat umanitatea, utilizand un virus a carui definitie a fost identificata, de aceeasi bravi cercetatori, sub forma unei matrici de dimensiuni NxN care contine tot litere mici ale alfabetului englez. Cercetatorii vor sa afle gradul de infestare a genomului uman, care se masoara in numarul de aparitii a definitiei virusului in harta acestuia. Problema este insa ceva mai complicata, deoarece virusul se poate deghiza interschimband de oricate ori, oricare doua pozitii din matricea care il defineste.\n\nh2. Cerinta\n\n\n\nDeterminati numarul de aparitii (incluzandu-le si pe cele deghizate) ale definitiei virusului in harta genomului uman.\n\nh2. Date de Intrare\n\n\n\nPrima linie contine doua numere, M si N, cu semnificatia de mai sus. Urmeaza M linii continand cate M caractere (fara spatii) reprezentand harta genomului uman. Urmatoarele N linii contin N caractere (fara spatii) reprezentand definitia virusului\n\nh2. Date de Iesire\n\n\n\nFisierul de iesire va contine pe prima linie numarul de aparitii ale virusului (eventual deghizat) in harta genomului uman.\n\nh2. Restrictii si precizari\n\n\n\no 1 <= N <= M <= 1000\no Ambele matrici contin litere mici ale alfabetului englez\no Doua aparitii diferite ale virusului se pot suprapune partial (vezi exemplul)\no Pentru 50% din teste M <= 200\no Nu stiu daca se poate identifica un virus analizand harta genomului uman. Povestea e pura fictiune. Orice asemanare cu realitatea este intamplatoare si neintentionata.\n\nh2. Exemplu\n\n\n\n\n|matrix.in |matrix.out |\n\n|3 2 |4 |\n| | |\n|acb | |\n| | |\n|bda | |\n| | |\n|acb | |\n| | |\n|ab | |\n| | |\n|cd | |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"matrix\")==',0,''),('problema/bool','Bool','2006-11-11 16:40:55','==Include(page=\"template/taskheader\" task_id=\"bool\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nHaralambie a primit la scoala o tema destul de dificila. El trebuie sa evalueze o expresie logica. Aceasta expresie contine variabile(litere mari ale alfabetului englez de la $A$ la $Z$), constante({$TRUE$} si {$FALSE$}), paranteze rotunde ({$($} si {$)$}) si operatorii logici $NOT$, $AND$ si $OR$. $NOT$ are prioritatea cea mai mare, $OR$ are prioritatea cea mai mica. Initial toate variabilele au valoarea $FALSE$. Lui Haralambie ii place sa evalueze expresii, dar variabilele isi mai schimba uneori valoarea si expresia trebuie reevaluata. Speriat din aceasta cauza, a decis sa apeleze la ajutorul vostru! Dupa cum este mentionat mai sus o expresie logica este definita in unul din modurile urmatoare:\r\n\r\n\r\ntable(example). |_. expresie |_. explicatie |\r\n| TRUE | &nbsp; |\r\n| FALSE | &nbsp; |\r\n| c     |  c litera mare a alfabetului englez |\r\n| (e)   |  e expresie logica |\r\n| NOT e |  e expresie logica |\r\n| e1 AND e2 | e1 si e2 expresii logice |\r\n| e1 OR e2 | e1 si e2 expresii logice |\r\n\r\nh2. Cerinta\r\nSe da expresia ce trebuie evaluata si modificarile ce apar la valorile variabilelor. Pentru fiecare modificare de variabila trebuie reevaluata expresia si afisat rezultatul ($1$ pentru adevarat si $0$ pentru fals).\r\n\r\nh2. Date de Intrare\r\nPe prima linie a fisierului de intrare $bool.in$ este scrisa expresia logica definita ca mai sus. Pe a doua linie este dat numarul $N$ de modificari ale variabilelor. Pe linia a treia sunt date $N$ caractere intre $A$ si $Z$, reprezentand variabilele a caror valoare este modificata.\r\n\r\nh2. Date de Iesire\r\nFisierul $bool.out$ va contine o singura linie de lungime $N$. Pentru fiecare modificare de variabila se va afisa un caracter reprezentand valoarea logica a expresiei: $1$ pentru adevarat si $0$ pentru fals.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100$\r\n* $1 &le; Lungime expresiei &le; 1.000$\r\n* Toate literele care apar in expresie vor fi majuscule\r\n* Nu va exista mai mult de un spatiu intre doua caractere din expresie\r\n* O variabila care are valoarea $TRUE$ isi schimba valoarea in $FALSE$, iar o variabila $FALSE$ se schimba in $TRUE$\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. bool.in |_. bool.out |\r\n| A AND ((B OR NOT C) OR ((TRUE)))\r\n4\r\nABCA\r\n| 1110 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bool\")==',18,''),('problema/bool','Bool','2006-11-11 16:41:32','==Include(page=\"template/taskheader\" task_id=\"bool\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nHaralambie a primit la scoala o tema destul de dificila. El trebuie sa evalueze o expresie logica. Aceasta expresie contine variabile(litere mari ale alfabetului englez de la $A$ la $Z$), constante({$TRUE$} si {$FALSE$}), paranteze rotunde ({$($} si {$)$}) si operatorii logici $NOT$, $AND$ si $OR$. $NOT$ are prioritatea cea mai mare, $OR$ are prioritatea cea mai mica. Initial toate variabilele au valoarea $FALSE$. Lui Haralambie ii place sa evalueze expresii, dar variabilele isi mai schimba uneori valoarea si expresia trebuie reevaluata. Speriat din aceasta cauza, a decis sa apeleze la ajutorul vostru! Dupa cum este mentionat mai sus o expresie logica este definita in unul din modurile urmatoare:\r\n\r\n\r\ntable(example). |_. expresie |_. explicatie |\r\n| TRUE | &nbsp; |\r\n| FALSE | &nbsp; |\r\n| c     |  c litera mare a alfabetului englez |\r\n| (e)   |  e expresie logica |\r\n| NOT e |  e expresie logica |\r\n| e1 AND e2 | e1 si e2 expresii logice |\r\n| e1 OR e2 | e1 si e2 expresii logice |\r\n\r\nh2. Cerinta\r\n\r\nSe da expresia ce trebuie evaluata si modificarile ce apar la valorile variabilelor. Pentru fiecare modificare de variabila trebuie reevaluata expresia si afisat rezultatul ($1$ pentru adevarat si $0$ pentru fals).\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $bool.in$ este scrisa expresia logica definita ca mai sus. Pe a doua linie este dat numarul $N$ de modificari ale variabilelor. Pe linia a treia sunt date $N$ caractere intre $A$ si $Z$, reprezentand variabilele a caror valoare este modificata.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $bool.out$ va contine o singura linie de lungime $N$. Pentru fiecare modificare de variabila se va afisa un caracter reprezentand valoarea logica a expresiei: $1$ pentru adevarat si $0$ pentru fals.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100$\r\n* $1 &le; Lungime expresiei &le; 1.000$\r\n* Toate literele care apar in expresie vor fi majuscule\r\n* Nu va exista mai mult de un spatiu intre doua caractere din expresie\r\n* O variabila care are valoarea $TRUE$ isi schimba valoarea in $FALSE$, iar o variabila $FALSE$ se schimba in $TRUE$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bool.in |_. bool.out |\r\n| A AND ((B OR NOT C) OR ((TRUE)))\r\n4\r\nABCA\r\n| 1110 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bool\")==',18,''),('problema/bridge','Bridge','2006-11-11 16:46:42','==Include(page=\"template/taskheader\" task_id=\"bridge\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nFat-Frumos a plecat in cautarea iubirii sale, fiica imparatului, Simona, care a fost rapita de balaurul cel rau si dusa in pestera acestuia. Acesta s-a pregatit intens de lupta insa el nu a stiut ca balaurul ii pregatise o surpriza, si astfel l-a atras pe acesta pe un pod. Pe pod Fat-Frumos se poate deplasa pasind (se va deplasa o scandura la dreapta), sarind (se va deplasa $2$ scanduri la dreapta), stationand (va ramane pe aceeasi scandura) sau teleportandu-se (vezi scandura teleportoare). Insa podul este putin mai ciudat fiind format din $4$ tipuri de scanduri astfel:\r\n\r\n* $0$ - scandura buna (pe o astfel de scandura se poate stationa, pasi, sari sau teleporta, si se poate ajunge oricum pe ea)\r\n* $1$ - scandura subreda (la fel ca la o scandura buna, numai ca pe acest tip de scandura nu se poate ajunge decat prin pasire)\r\n* $2$ - scandura lipsa (Daca Fat-Frumos va ajunge pe o astfel de scandura el va ajunge felul principal al crocodililor de sub pod)\r\n* $3$ - scandura teleportoare (pe astfel de scandura se poate ajunge oricum, iar o astfel de scandura il va teleporta pe eroul nostru pe o alta scandura numita scandura destinatie)\r\n\r\nh2. Cerinta\r\n\r\nFat-Frumos va trebui sa isi coordoneze miscarile cat mai bine pe pod de aceea va roaga pe voi sa ii raspunde-ti la $M$ intrebari de forma \"In cate moduri pot ajunge pe scandura $X$ in $K$ pasi?\"\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului bridge.in vor fi scrise $2$ numere $N$ si $M$ reprezentand numarul de scanduri respective numarul de intrebari. Pe urmatoarea linie vor fi scrise N numere cuprinse intre $0$ si $3$ reprezentand configuratia podului, corespondenta fiind cea de mai sus. Pe urmatoarele linii vor fi scrise scandurile destinatie pentru fiecare scandura teleportoare in ordinea aparitiei acestora pe pod, si, in final, pe urmatoarele $M$ linii vor fi scrise cate $2$ numere $X$ si $K$ care definesc o intrebare de genul \"In cate moduri se poate ajunge pe scandura $X$ in $K$ pasi?\".\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bridge.out$ va contine $M$ linii reprezentand raspunsul pentru fiecare intrebare din fisierul de intrare in ordine.\r\n\r\nh2. Restrictii si Precizari\r\n\r\n* $1 < N < 4001$\r\n* $1 < M < 30001$\r\n* Numarul maxim de pasi dintr-o intrebare nu va depasi valoarea $4000$\r\n* Daca scandura $x$ este teleportoare si are ca destinatie scandura $y$ atunci vom avea urmatoarea relatie $x < y$\r\n* Mai multe scanduri teleportoare pot avea ca destinatie aceeasi scandura\r\n In momentul in care Fat-Frumos ajunge pe o scandura teleportoare el va fi teleportat pe scandura destinatie indiferent daca el vrea sau nu (nu poate stationa, sari sau pasi de pe ea)\r\n* Teleportarea se considera pas\r\n* Raspunsurile se vor afisa modulo $666013$\r\n* Numarul de moduri de a ajunge pe o scandura lipsa sau pe o scandura teleportoare care are ca destinatie o scandura lipsa sau subreda este 0\r\n* Fat-Frumos nu se poate deplasa inapoi (el la un pas se va deplasa {$0$},{$1$} sau $2$ scanduri la dreapta sau va fi teleportat in cazul in care scandura respective are aceasta propietate)\r\n* Initial Fat-Frumos se afla in afara podului pozitie pe care nu poate stationa, la primul pas el ori va pasi pe prima scandura ori va sari pe cea de-a doua daca acest lucru este posibil\r\n* Prima scandura nu este niciodata lipsa\r\n* Pe o scandura teleportoare se poate ajunge ca si pe o scandura buna\r\n* Daca o scandura teleportoare nu are ca scandura destinatie o scandura lipsa sau subreda atunci numarul de moduri de a ajunge pe aceasta in K pasi nu este neaparat $0$ (vezi exemplu)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bridge.in |_. bridge.out |\r\n| 5 3\r\n0 0 3 1 2\r\n4\r\n4 4\r\n2 3\r\n3 2\r\n| 0\r\n3\r\n0 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bridge\")==',961,''),('problema/camera','Camera','2006-11-11 16:57:19','==Include(page=\"template/taskheader\" task_id=\"camera\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nZebu si-a cumparat recent o noua parcela de pamant pe care vrea sa isi extinda afacerea cu gaini, dar el este foarte ingrijorat de hotii care pot afecta bunastarea afacerii. Un prieten care a fost recent in State i-a facut cadou o camera de filmat foarte performanta care are capacitatea de a filma dupa un unghi de $360$ de grade. Zebu este foarte bucuros de aceasta achizitie pe care o poate folosi imediat pentru a supraveghea parcela nou cumparata. Dar camera nu poate supraveghea intreaga parcela daca este dispusa in orice punct al acesteia, si Zebu este curios care e suprafata pe care camera poate fi pozitionata astfel ca toate punctele parcelei sa poata fi supravegheate. Parcela o putem modela ca un poligon cu $N$ varfuri, iar camera ca un punct in interiorul acestui poligon.\r\n\r\nh2. Cerinta:\r\n\r\nDeterminati aria zonei unde poate fi amplasata camera!\r\n\r\nh2. Date de Intrare:\r\n\r\nFisierul $camera.in$ va contine pe prima linie un numar intreg ce reprezinta valoarea lui $N$. Pe urmatoarele $N$ linii se vor afla cate doua numere intregi separate prin un singur spatiu, pe a $i+1$-a linie se vor afla coordonatele celui de al $i$-lea varf.\r\n\r\nh2. Date de Iesire:\r\n\r\nFisierul $camera.out$ va contine un singur numar real cu doua zecimale care reprezinta aria zonei in care poate fi plasata camera.\r\n\r\nh2. Restrictii:\r\n\r\n* $3 &le; N &le; 2000$\r\n* $-100000 &le; x{~i~}, y{~i~} &le; 100000, (x{~i~}, y{~i~})$ sunt coordonatele varfurilor poligonului\r\n* Pentru $20%$ din teste marginile parcelei vor fi paralele cu axele de coordonate.\r\n* Doua numere reale se considera egale daca diferenta intre ele e cel mult $10^-6^$\r\n* Un rezultat va fi considerat corect daca diferenta intre el si solutia rezultatul returnat de solutia oficiala este $&le; 0.01$.\r\n\r\nh2. Exemplu:\r\n\r\ntable(example). |_. camera.in |_. camera.out |_. explicatie |\r\n| 9\r\n5 1\r\n5 2\r\n1 3\r\n3 4\r\n2 8\r\n5 5\r\n9 6\r\n7 3\r\n9 2\r\n| 2.86 | !http://www.infoarena.ro/task/camera?action=download&file=camera.gif! |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"camera\")==',18,''),('problema/car','Car','2006-11-11 17:04:43','==Include(page=\"template/taskheader\" task_id=\"car\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nIonel a implinit 18 ani si a luat permisul de conducere, azi vrea sa mearga de la el acasa pana la scoala cu masina si singura conditie pe care i-a impus-o tatal sau e aceea de a nu lua foarte multe curbe! Pentru a primi masina si alta data, Ionel vrea sa il impresioneze pe tatal sau si sa mearga pe drumul cel mai putin costisitor din punct de vedere al curbelor. Orasul e reprezentat de o matrice de $N$ linii si $M$ coloane, un element al matricii fiind $0$ daca pe acolo poate trece masina si $1$ daca nu. Masina se poate misca dintr-o celula a matricii in toate cele $8$ celule adiacente, daca ele sunt libere. Costul unui drum de la pozitia initiala la pozitia finala este data de suma costurilor miscarilor. O miscare in directia de mers are costul {$0$}, o miscare la $45$ de grade fata de directia de mers are costul {$1$}, o miscare la $90$ de grade are costul {$2$}, una la $135$ de grade are costul $3$ iar una la $180$ de grade are costul {$4$}. La momentul initial masina poate porni in oricare dintre cele $8$ directii, daca celula din\r\ndirectia respectiva este marcata cu {$0$}.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati pentru Ionel costul minim din punct de vedere al curbelor de la o pozitie initiala la o pozitie finala.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $car.in$ se gasesec doua numere naturale: $N$ (numarul de linii al matricii) si $M$ (numarul de coloane al matricii). Pe urmatoarea linie sunt numerele $Si$ - linia pozitiei initiale a masinii lui Ionel, $Sj$ - coloana pozitiei initiale ale masinii lui Ionel, $Fi$ - linia pozitiei finale, $Fj$ - coloana pozitiei finale. Pe urmatoarele $N$ linii sunt cate $M$ numere de $0$ sau {$1$}.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului de iesire $car.out$ se va gasi costul minim al unui drum de la pozitia initiala la pozitia finala. Daca nu exista nici un drum se va afisa {$-1$}.\r\n\r\nh2. Restrictii\r\n\r\n* $0 &le; N, M &le; 500\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. car.in |_. car.out |\r\n| 5 5\r\n1 1 1 4\r\n0 1 1 0 1\r\n1 0 1 0 1\r\n0 1 1 1 0\r\n1 0 1 0 1\r\n1 1 0 1 1\r\n| 9 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"car\")==',961,''),('problema/munte','Munte','2006-11-11 11:23:35','==Include(page=\"template/taskheader\" task_id=\"munte\")==\n\n==Include(page=\"template/raw\")==\n\nLink: [1]File-List\nLink: [2]Edit-Time-Data\n\nMunte\n\n\n\nGheorghe vrea sa cucereasca un munte. El are anumite informatii despre munte. Stie cat de inalt este muntele si care e distanta pana la celaltalta parte a muntelui. El mai are si o lista cu puncte speciale prin care trebuie sa treaca, despre acest puncte stie inaltimea lor si ordinea in care apar, nu stie distanta dintre aceste puncte. Muntele este format din 3 tipuri de teren.\n\nS Tipul 1: teren crescator, unde muntele creste un metru pe verticala pentru fiecare metru pe orizontala.\n\nS Tipul 2: teren drept. Pe acesta portiune terenul nici nu urca nici nu coboara.\n\nS Tipul 3: teren descrescator , unde muntele scade un metru pe verticala pentru fiecare metru pe orizontala.\n\nh2. Cerinta\nGheorghe avand toate aceste informati, N (inaltimea maxima a munteleui, presupunand ca muntele incepe la nivelul 0 si se termina la nivelul 0), D - distanta pe orizontala a muntelui si inaltimea la fiecare punct special, vrea sa stie cate posibilitati are de a parcurge muntele.\n\nh2. Date de Intrare\nPe prima linie din fisierul munte.in se va afla numarul N - inaltimea maxima a muntelui, D - distanta pe orizontala a muntelui si K - numarul de puncte speciale.\nPe urmatoarele K linii sunt scrise inaltimile punctelor speciale\n\nh2. Date de Iesire\n\nPe prima linie a fisierului munte.out se va gasi P - numarul de posibilitati de a traversa muntele.\n\n\n\nObservatii\n\nS Gheoghe incepe la nivelul 0 si trebuie sa termine la nivelul 0\n\nS Doar incepul si sfasitul au nivelul 0!\n\nh2. Restrictii\n\nS 1 <= N <= 50\n\nS 1 <= D <= 100\n\nS 0 <= K <= 50\n\nS 0 <= P <= 2^63-1\n\n\n\nExemple\n\nmunte.in munte.out Explicatie\n2 5 0 3 Cele 3 posibilatati diferite sunt :\n\n\n\nnu este o parcurgere valida pentru ca inaltimea muntelui nu este 2, ci 1\n\n\n\nmunte.in munte.out Explicatie\n2 5 2 1 Singura parcurgere posibila este cea de sus\n2\n2\n\n\n\nmunte.in munte.out\n3 8 4 7\n2\n2\n3\n1\n\n\n\n\n\nReferences\n\nVisible links\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/munte/enunt.files/filelist.xml\n2. file:///home/eval/eval/www/infoarena/docs/arhiva/munte/enunt.files/editdata.mso\n==Include(page=\"template/taskfooter\" task_id=\"munte\")==',0,''),('template/raw','template/raw','2006-11-11 12:42:24','{color:red}|_. Aceasta pagina a fost important din infoarena1 si nu a fost inca importata. Sterge @==Include(file=\"template/raw\")==@ doar cand este multumit cu continutul pagini.|',1,''),('problema/muzeu','Muzeu','2006-11-11 17:21:32','==Include(page=\"template/taskheader\" task_id=\"muzeu\")==\r\n\r\nUn muzeu are forma patratica si contine $N*N$ camere ce pot fi vizitate. Unele camere sunt deschise si contin opere de arta, altele sunt inchise (sunt folosite pentru alte scopuri). In unele din camerele libere, se afla paznici. Directorul muzeului se teme de eventualitatea unei spargeri si de aceea doreste sa evalueze cat de bine au fost asezati paznicii in camerele libere. Mai precis, el doreste sa afle, pentru fiecare camera libera, care este distanta minima pana la cel mai apropiat paznic (numarul minim de camere prin care trebuie sa intre un paznic pentru a ajunge la camera respectiva). Paznicii se pot deplasa numai in camerele libere din Nord, Est, Sud sau Vest (cu conditia sa nu paraseasca muzeul).\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $muzeu.in$ se afla numarul intreg $N$, reprezentand numarul de linii (si de coloane) ale muzeului (muzeul avand $N*N$ camere). Urmatoarele $N$ linii contin cate $N$ caractere fiecare:\r\n\r\n* `.\' pentru camera libera in care nu se afla paznic\r\n* `P\' pentru camera libera in care se afla paznic\r\n* `#\' pentru camera inchisa (prin care nu pot trece nici paznicii, dar in care nu pot intra nici hotii)\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $muzeu.out$ veti afisa $N$ linii, fiecare din ele continand $N$ numere intregi (separate prin spatii). Fiecare numar afisat corespunde camerei de pe linia si coloana corespunzatoare din fisierul de intrare. Pentru fiecare camera libera veti afisa distanta minima pana la cel mai apropiat paznic (sau $-1$ daca nici un paznic nu poate ajunge in aceasta camera). Pentru camerele inchise, veti afisa $-2$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* 1 &le; N &le; 250\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. muzeu.in |_. muzeu.out |\r\n| 8\r\n  ...#....\r\n  #..#..#.\r\n  .##.P..#\r\n  ..#.#.#.\r\n  ........\r\n  ........\r\n  ###...##\r\n  ..P.....\r\n| -1 -1 -1 -2  2 3  4  5\r\n  -2 -1 -1 -2  1 2 -2  6\r\n  8  -2 -2  1  0 1  2 -2\r\n  7   6 -2  2 -2 2 -2  6\r\n  6   5  4  3  4 3  4  5\r\n  6   5  4  3  4 4  5  6\r\n -2  -2 -2  2  3 4 -2 -2\r\n  2   1  0  1  2 3  4  5 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"muzeu\")==',48,''),('problema/cercuri','Cercuri','2006-11-11 11:23:45','==Include(page=\"template/taskheader\" task_id=\"cercuri\")==\n\n==Include(page=\"template/raw\")==\n\nCercuri\n\n\n\nSe dau doua cercuri. Acestea se pot intersecta in 0, 1, 2 sau o infinitate de puncte (daca sunt identice).\n\nh2. Cerinta\n\nGasiti distanta dintre cele doua puncte de intersectie, in cazul in care se intersecteaza in exact 2 puncte, sau tratati celelalte cazuri corespunzator (vezi \"Date de iesire\").\n\nh2. Date de Intrare\n\nPrima linie a fisierului de intrare cercuri.in contine T, numarul de teste. Pe fiecare din urmatoarele T linii se afla cate un test: un test contine 6 numere intregi: x1, y1, R1, x2, y2, R2. (x1, y1) sunt coordonatele centrului primului cerc, iar R1 este raza primului cerc. (x2, y2) sunt coordonatele celui de-al doilea cerc, iar R2 este raza celui de-al doilea cerc.\n\nh2. Date de Iesire\n\nPentru fiecare test, afisati o linie pe care scrie:\n\no \"-1\", daca cele doua cercuri sunt identice\n\no \"-2\", daca cele doua cercuri nu se intersecteaza in nici un punct\n\no \"-3\", daca cele doua cercuri se intersecteaza in exact un punct\n\no distanta dintre cele doua puncte de intersectie, daca cele doua cercuri se intersecteaza in exact 2 puncte\n\nh2. Restrictii si precizari\n\no 0 <= x1, y1, x2, y2, R1, R2<=1.000\n\no Rezultatul va fi afisat cu o precizie de 3 zecimale\n\nh2. Exemplu\n\ncercuri.in cercuri.out\n5 7.714\n\n5 5 5 6 6 6 7.714\n\n5 5 5 6 6 6 18.708\n\n0 0 10 5 5 10 -1\n\n0 0 10 0 0 10 -2\n\n0 0 1 1000 1000 1\n\n\n==Include(page=\"template/taskfooter\" task_id=\"cercuri\")==',0,''),('problema/tvshow','TVShow','2006-11-11 11:23:40','==Include(page=\"template/taskheader\" task_id=\"tvshow\")==\n\n==Include(page=\"template/raw\")==\n\ntvshow\n\nIntr-un show de televiziune N concurenti participa intr-o competie pe viata si pe moarte din care doar unul dintre ei poate iesi castigator. Fiecare concurent a adunat pe parcursul emisiunii un numar de puncte, S[i], si acum urmeaza proba finala. Fiecare dintre ei trebuie sa aleaga una dintre cele doua porti din fata lor. Doar una dintre ele ascunde in spatele ei marele premiu. De asemenea fiecare concurent parieza un numar de puncte P[i](0<=P[i]<=S[i]). Daca poarta pe care a ales-o el este cea care ascunde premiul atunci punctajul sau va fi S[i]+P[i] iar daca nu a ghicit-o S[i]-P[i]. Concurentul cu punctajul maxim in urma acestei probe va castiga marele premiu. Daca exista mai multe punctaje maxime nu va castiga nimeni. Ultimul concurent, cine altul decat Petrica, se afla in fata unei decizii foarte dificile: el stie punctajele celorlalti concurenti si ce numar de puncte au pariat fiecare dar nu stie ce porti au ales acestia, in schimb stie ca fiecare concurent - chiar si el - are 50% sanse sa\nghiceasca poarta castigatoare si 50% sanse sa nu o ghiceasca. Trebuie sa decida ce numar de puncte va paria pentru ca probabilitatea sa de castig sa fie cat mai mare (chiar daca pentru doua moduri de a paria probabilitatile sunt foarte apropiate, diferenta fiind practic nula, Petrica va alege modul pentru care probabilitatea sa de castig este mai mare).\n\nh2. Cerinta\n\nCalculati numarul de puncte pe care trebuie sa-l parieze Petrica pentru a avea sanse de castig cat mai mari. Daca exista mai multe solutii alegeti-o pe cea mai mica. De asemenea aflati si probabilitea maxima de castig pe care o poate avea Petrica.\n\nh2. Date de Intrare\n\nFisierul tvshow.in va contine pe prima linie numarul intreg N reprezentand numarul de concurenti din concurs. Fiecare din urmatoarele N - 1 linii va contine doi intregi separati printr-un spatiu reprezentand scorul si numarul de puncte pariate pentru fiecare din primii N - 1 concurenti. Ultima linie contine un singur numar intreg reprezentand scorul lui Petrica.\n\nh2. Date de Iesire\n\nPe prima linie a fisierului tvshow.out se va afla numarul de puncte pariat de Petrica. Pe urmatoarele doua linii se vor afla doua numere intregi A si B care reprezinta probabilitatea maxima de castig a lui Petrica sub forma de fractie ireductibila (probabilitatea este egala cu A/B).\n\nh2. Restrictii\n\no 1 < N < 301\no Valorile scorurilor sunt numere intregi din intervalul [0, 30000]\no Pentru 40% din teste N <= 17\n\nExemple\n\n\n|tvshow.in |tvshow.out |\n\n|3 |76 |\n|100 25 |1 |\n|100 75 |2 |\n|100 | |\n\n|Probabilitatea ca Petrica sa castige este de 50% daca alege sa parieze 76 de puncte, indiferent daca |\n|primii doi concurenti au ghicit sau nu poarta castigatoare. Daca Petrica a ghicit poarta castigatoare el |\n|castiga concursul (acumuland 176 de puncte) iar daca nu a ghicit-o atunci sigur pierde (acumuland 24 de |\n|puncte). Daca va paria mai putin de 76 de puncte probabilitatea de a castiga va fi mai mica, iar daca |\n|pariaza mai mult probabilitatea va ramane aceeasi. |\n\n\n\n\n\n|tvshow.in |tvshow.out |\n\n|2 |0 |\n|10 3 |0 |\n|2 |1 |\n\n|Petrica pierde orice suma ar paria. |\n\n\n\n\n\n|tvshow.in |tvshow.out |\n\n|3 |10 |\n|50 31 |1 |\n|60 41 |8 |\n|10 | |\n\n|Pariind 10 puncte Petrica are 12.5% sanse sa castige (el castiga doar in cazul in care primii doi |\n|concurenti nu ghicesc poarta si el o ghiceste; in oricare din celelalte cazuri Petrica va pierde). Daca |\n|pariaza mai putin Petrica va avea 0% sanse de castig. |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"tvshow\")==',0,''),('problema/bombar','Bombar','2006-11-11 16:42:06','==Include(page=\"template/taskheader\" task_id=\"bombar\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nIn timpul bombardamentelor, Paftenie a devenit genist. Trebuie sa dezamorseze niste bombe aflate adanc in pamant si asta repede. Sunt exact $2*N$ bombe, asezate in doua randuri paralele, ca in figura urmatoare:\r\n{@*--*--*..*@}\r\n{@| | | |   @}\r\n{@*--*--*..*@}\r\nIntre oricare doua bombe consecutive din acelasi rand sau o bomba si corespunzatoarea sa din celalalt rand se poate sapa un tunel (bombele intre care se pot sapa tuneluri apar legate in figura). Trebuie sa le dezamorseze pe toate, una care una, sapand exact $2*N-1$ tuneluri si trebuie sa poata circula intre oricare doua bombe numai prin tunelurile sapate. Inainte de a trece la treaba, Paftenie se intreaba in cate moduri se pot sapa tunelurile.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l sa afle pana nu e prea tarziu!\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $bombar.in$ este dat numarul $N$ al bombelor de pe un sir.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bombar.out$ va contine pe prima linie un singur numar, reprezentand numarul de posibilitati in care se pot sapa tunelurile.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 20.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bombar.in |_. bombar.out |_. Explicatie |\r\n| 2 | 4 |Bombele sunt plasate astfel: \r\n{@*--*@}\r\n{@|  |@}\r\n{@*--*@} |\r\n\r\nEl poate sapa tunelurile in 4 feluri: \r\n*--* *--* *--* *--* \r\n|  | |  | |  | |  |\r\n*--* *--* *--* *--* |\r\n\r\n|3 |15 | |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bombar\")==',1,''),('problema/caraibe','Caraibe','2006-11-11 17:17:23','==Include(page=\"template/taskheader\" task_id=\"caraibe\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nCei $N$ pirati de pe Perla Neagra au facut recent o captura foarte importanta: un cufar cu $10.000.000.000$ (zece miliarde) de banuti. Acum piratii au de rezolvat o problema si mai dificila: cum sa imparta banii.\r\nPentru impartire, piratii se aseaza in linie. Primul pirat va propune o schema de impartire a banilor. Daca un anumit numar de pirati nu sunt de acord cu aceasta schema, piratul va fi aruncat peste bord, si apoi urmatorul pirat va propune o schema de impartire, si tot asa. Piratii sunt foarte inteligenti: un pirat este de acord cu o schema de impartire doar daca aceasta ii aduce un avantaj strict (cel putin un banut) fata de ce ar obtine votand impotriva schemei. Pentru ca actioneaza numai pe baze rationale, piratii sunt si foarte predictibili. Cu alte cuvinte, un pirat poate anticipa decizia altor pirati pentru a lua o decizie proprie (aceasta inseamna si ca daca un pirat are mai multe posibilitati de a alege o schema de impartire, ceilalti pirati stiu ce varianta ar alege).\r\nDepinzand de caracteristicile fiecarui pirat (forta, popularitate), numarul de pirati care trebuie sa fie de acord cu schema lui pentru a nu fi aruncat peste bord variaza. Sa zicem ca pentru piratul $i (1 &le; i < N)$ acest numar este {$A{~i~}$}. Daca piratul $i$ propune o schema, stim ca toti piratii pana la $i-1$ au fost aruncati deja peste bord. In afara de piratul {$i$}, mai exista $N-i$ pirati. Daca cel putin $A{~i~}$ dintre acestia sunt de acord cu schema piratului {$i$}, comoara va fi impartita dupa aceasta schema. Altfel, piratul $i$ va fi aruncat peste bord, si piratul $i+1$ va propune o schema. Pentru orice {$i$}, avem {$0 &le; A{~i~} < N-i$}. Datorita acestei conditii {$A{~N-1~}=0$}, iar $A{~N~}$ nu este definit (pentru ca piratul $N$ este ultimul).\r\n\r\nh2. Cerinta\r\n\r\nPrimul pirat din linie doreste sa propuna o schema de impartire a banilor astfel incat sa nu fie aruncat peste bord, si el sa primeasca cat mai multi banuti. Determinati suma maxima pe care o poate primi. Se garanteaza ca exista o schema pe care o poate propune primul pirat, astfel incat el sa nu fie aruncat peste bord.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $caraibe.in$ contine pe prima linie numarul $N$ de pirati. Pe urmatoarele linii se gasesc valorile {$A{~1~}$}, {$A{~2~}$}, ..., {$A{~N-2~}$}, cate o valoare pe o linie. Asa cum se mentioneaza mai sus, $A{~N-1~}$ este intotdeauna zero, si nu apare in fisier.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $caraibe.out$ va contine numarul maxim de banuti pe care ii poate primi primul pirat.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 65 000$\r\n* $0 &le; A{~i~} < N-i$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. caraibe.in |_. caraibe.out |_. Explicatie |\r\n| 4\r\n1\r\n1\r\n| 9999999999\r\n| Schema propusa de primul pirat este: *9999999999* de banuti pentru el insusi, *1* banut pentru al treilea pirat si *0* (zero) pentru ceilalti. Asta il face pe piratul al treilea sa fie de acord cu schema. El rationeaza astfel: \"piratii *2* si *4* nu sunt de acord; daca si eu sunt impotriva, piratul *1* va fi aruncat peste bord ({*A{~1~}=1*}); apoi piratul *2* va propune schema: *9999999999* de banuti pentru el insusi, *1* banut pentru piratul *4* si nimic pentru mine; piratul *4* va fi de acord, deci schema va fi acceptata ({*A{~2~}=1*}); motivul pentru care piratul *4* va fi de acord este ca in cazul in care piratul *2* e aruncat peste bord, eu imi voi acorda toti banii mie si el nu primeste nimic ({*A{~3~}=0*})\" |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"caraibe\")==',961,''),('problema/nextseq','NextSeq','2006-11-11 11:23:49','==Include(page=\"template/taskheader\" task_id=\"nextseq\")==\n\n==Include(page=\"template/raw\")==\n\nLink: [1]File-List\n\nnextseq\n\nh2. Cerinta\n\nSe da un set de numere de numere distincte, X, si doua siruri, A si B, cu elemente din setul X astfel incat B este mai mare decat A.. Sa se determine cate siruri sunt mai mari decat A dar mai mici decat B.\n\nh2. Date de Intrare\n\n\n\nFisierul de intrare contine pe prima linie doua numere N, M si P reprezentand numarul de elemente din setul X, numarul de elemente al sirului A si, respectiv, numarul de elemente ale sirului B. Linia a doua contine N numere naturale reprezentand setul X. Linia a treia contine M numere naturale separate prin spatii din setul X reprezentand elementele sirului A. Linia a patra contine P numere naturale separate prin spatii din setul X reprezentand elementele sirului B.\n\nh2. Date de Iesire\n\n\n\nPe prima linia a fisierului se va afla numarul cautat. Acest numar nu va fi mai mare decat 100.\n\nh2. Restrictii si precizari\n\n\n\no 1 <= N, M, P <= 10.000\no Un sir A este mai mare decat un sir B daca are mai multe elemente decat acesta sau daca sirurile au acelasi numar de elemente si exista o pozitie i astfel incat A[i] >= B[i] iar A[k] = B[k] pentru orice k >= i (vezi exemplul)\no Numarul de siruri dintre cuprinse intre A si B nu va depasi 100\no Numerele din setul X sunt numere intregi in intervalul [0 .. 10.000]\no Pentru 70% din teste N, M, P <= 100\n\nh2. Exemplu\n\n\n\n\n|nextseq.in|nextseq.out|Explicatii |\n\n|4 2 3 |8 |Sirurile care respecta conditiile din enunt (in ordine lexicografica)|\n| | |sunt: |\n|8 3 9 1 | | |\n| | |{9, 8}, {9 9}, {1 1 1}, {1 1 3}, |\n|9 3 | | |\n| | |{1 1 8}, {1 1 9}, {1 3 1}, {1, 3, 3} |\n|1 3 8 | | |\n\n\n\n\nReferences\n\nVisible links\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/nextseq/enunt.files/filelist.xml\n==Include(page=\"template/taskfooter\" task_id=\"nextseq\")==',0,''),('problema/bombar','Bombar','2006-11-11 17:44:06','==Include(page=\"template/taskheader\" task_id=\"bombar\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nIn timpul bombardamentelor, Paftenie a devenit genist. Trebuie sa dezamorseze niste bombe aflate adanc in pamant si asta repede. Sunt exact $2*N$ bombe, asezate in doua randuri paralele, ca in figura urmatoare:\r\n\r\n==html|<pre>O--O--O..O<br>I&nbsp; I&nbsp; I&nbsp; I<br>O--O--O..O</pre>==\r\n\r\nIntre oricare doua bombe consecutive din acelasi rand sau o bomba si corespunzatoarea sa din celalalt rand se poate sapa un tunel (bombele intre care se pot sapa tuneluri apar legate in figura). Trebuie sa le dezamorseze pe toate, una care una, sapand exact $2*N-1$ tuneluri si trebuie sa poata circula intre oricare doua bombe numai prin tunelurile sapate. Inainte de a trece la treaba, Paftenie se intreaba in cate moduri se pot sapa tunelurile.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l sa afle pana nu e prea tarziu!\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $bombar.in$ este dat numarul $N$ al bombelor de pe un sir.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bombar.out$ va contine pe prima linie un singur numar, reprezentand numarul de posibilitati in care se pot sapa tunelurile.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 20.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bombar.in |_. bombar.out |_. explicatie |\r\n| 2 | 4 | Bombele sunt plasate astfel: \r\no--o\r\nI  I\r\no--o \r\nEl poate sapa tunelurile in 4 feluri:\r\no--o o--o o--o o--o\r\nI  I I  I I  I I  I\r\no--o o--o o--o o--o |\r\n|3 |15 | blah |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bombar\")==',18,''),('problema/bombar','Bombar','2006-11-11 17:44:42','==Include(page=\"template/taskheader\" task_id=\"bombar\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nIn timpul bombardamentelor, Paftenie a devenit genist. Trebuie sa dezamorseze niste bombe aflate adanc in pamant si asta repede. Sunt exact $2*N$ bombe, asezate in doua randuri paralele, ca in figura urmatoare:\r\n\r\n==html|<pre>O--O--O..O<br>I&nbsp; I&nbsp; I&nbsp; I<br>O--O--O..O</pre>==\r\n\r\nIntre oricare doua bombe consecutive din acelasi rand sau o bomba si corespunzatoarea sa din celalalt rand se poate sapa un tunel (bombele intre care se pot sapa tuneluri apar legate in figura). Trebuie sa le dezamorseze pe toate, una care una, sapand exact $2*N-1$ tuneluri si trebuie sa poata circula intre oricare doua bombe numai prin tunelurile sapate. Inainte de a trece la treaba, Paftenie se intreaba in cate moduri se pot sapa tunelurile.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l sa afle pana nu e prea tarziu!\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $bombar.in$ este dat numarul $N$ al bombelor de pe un sir.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bombar.out$ va contine pe prima linie un singur numar, reprezentand numarul de posibilitati in care se pot sapa tunelurile.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 20.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bombar.in |_. bombar.out |_. explicatie |\r\n| 2 | 4 | Bombele sunt plasate astfel: \r\no--o\r\nI&nbsp;&nbsp;&nbsp;I\r\no--o \r\nPaftenie poate sapa tunelurile in 4 feluri:\r\no--o o--o o--o o--o\r\nI  I I  I I  I I  I\r\no--o o--o o--o o--o |\r\n|3 |15 | blah |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bombar\")==',18,''),('problema/tri2','Tri2','2006-11-11 11:23:42','==Include(page=\"template/taskheader\" task_id=\"tri2\")==\n\n==Include(page=\"template/raw\")==\n\nTri 2\n\n\n\nMicutul Gigel a marcat pe hartie N puncte, avand coordonate intregi. Apoi a inceput sa deseneze triunghiuri, avand varfurile in trei puncte diferite dintre cele N. Pentru fiecare triunghi desenat, Gigel ar dori sa stie cate dintre cele N-3 puncte ramase se afla strict in interiorul triughiului.\n\nh2. Cerinta\n\nPentru fiecare triunghi dat (prin indicii celor 3 puncte care sunt varfurile sale), determinati cate dintre celelalte puncte se afla strict in interiorul triunghiului.\n\nh2. Date de Intrare\n\nPe prima linie a fisierului de intrare tri2.in se afla numarul intreg N, reprezentand numarul de puncte marcate de Gigel pe hartie. Pe fiecare dintre urmatoarele N linii se afla coordonatele fiecarui punct, in ordine, de la cel numerotat cu 1, la cel numerotat cu N. Coordonatele sunt descrise prin doi intregi x si y, separati printr-un spatiu. Urmatoarea linie contine numarul intreg M de triunghiuri pe care le-a desenat Gigel. Pe urmatoarele M linii se afla cate trei numere intregi, a, b si c, separate prin spatii, reprezentand indicii a trei puncte diferite dintre cele N.\n\nh2. Date de Iesire\n\nIn fisierul de iesire tri2.out veti afisa M linii. Pe fiecare linie se va afla un numar intreg, reprezentand numarul de puncte dintre cele N-3 ramase, care se afla strict in interiorul triunghiului corespunzator liniei (prima linie va contine raspunsul corespunzator primului triunghi descris in fisierul de intrare, a doua linie raspunsul corespunzator celui de-al doilea triunghi s.a.m.d).\n\nh2. Restrictii si precizari\n\n. 3 -L- N -L- 1.000\n\n. 1 -L- M -L- 500.000\n\n. Coordonatele x, y sunt numere intregi din intervalul [0,2.000.000.000]\n\n. Oricare doua puncte au coordonatele x, respectiv y, distincte\n\n. Oricare trei puncte sunt necoliniare\n\n. Daca doriti sa folositi numere reale in programul vostru, se recomanda folosirea tipurilor long double pt. C/C++, respectiv extended pt. Pascal. Pentru testarea egalitatii a doua numere reale se recomanda folosirea unei precizii de 10^-14\n\nh2. Exemplu\n\ntri2.in tri2.out\n5 0\n\n0 0 2\n\n1 10 1\n\n2 4\n\n3 7\n\n10 1\n\n3\n\n1 2 3\n\n5 1 2\n\n5 3 2\n\n\n==Include(page=\"template/taskfooter\" task_id=\"tri2\")==',0,''),('problema/note','Note','2006-11-11 11:23:57','==Include(page=\"template/taskheader\" task_id=\"note\")==\n\n==Include(page=\"template/raw\")==\n\nnote\n\nO partitura muzicala este scrisa pe V voci, fiecare voce avand cate N note. Spunem ca un solfegiu se brodeste peste aceasta partitura daca solfegiul are tot lungimea de N note si fiecare din notele solfegiului coincide cu nota de pe pozitia corespunzatoare a partiturii, pe cel putin una dintre voci.\n\nDe exemplu, solfegiul\n\nmi re la do si fa sol la\n\nse brodeste partiturii pe 2 voci cu 8 note\n\nmi re do do si fa fa si\n\nsol si la do sol mi sol la\n\n, pentru ca notele 1, 2, 5 si 6 din solfegiu sunt cantate conform vocii I, iar notele 3, 7 si 8 sunt cantate dupa vocea a doua. Se observa ca nota a patra (do) este cantata conform ambelor voci.\n\nSpunem ca un solfegiu de o lungime oarecare falseaza in K locuri daca este nevoie de exact K modificari asupra lui pentru a-l face sa se brodeasca peste partitura. O modificare poate fi:\n\n1) Stergerea unei note din solfegiu\n\n2) Adaugarea unei note in solfegiu\n\n3) Inlocuirea unei note in solfegiu.\n\nDe exemplu, solfegiul\n\nmi re sol do si fa si\n\nfalseaza in doua locuri, pentru ca trebuie sa modificam nota sol in la si sa inseram inca un fa intre si si fa pentru a-l aduce la forma:\n\nmi re la do si fa fa si\n\ncare se brodeste peste partitura.\n\nh2. Cerinta\n\nSa se determine daca un solfegiu dat se brodeste peste o partitura data, sau, in caz contrar, care este numarul minim de locuri in care falseaza. Notele vor fi reprezentate prin numere de la 1 la 100.\n\nh2. Date de Intrare\n\nFisierul de intrare note.in va avea urmatoarea structura: pe prima linie se vor afla V si N, separate de exact un spatiu, numarul de voci si numarul de note. Urmatoarele V linii contin cate N numere, simbolizand partitura cu V voci si N note pe fiecare voce. Numerele vor fi naturale si intre 1 si 100. Linia V+2 va contine numarul M de note ale solfegiului. Linia V+3 va contine M numere naturale cuprinse in intervalul [1, 100], reprezentand notele solfegiului.\n\nh2. Date de Iesire\n\nFisierul de iesire note.out va contine numarul minim de locuri in care solfegiul falseaza, in functie de partitura data. Daca solfegiul se brodeste peste partitura numarul afisat va fi 0.\n\nh2. Restrictii\n\no 1 <= V <= 512\no 1 <= M, N <= 1024\n\nh2. Exemplu\n\n\n\nnote.in note.out\n2 8 2\n\n3 2 1 1 7 4 4 7\n\n5 7 6 1 5 3 5 6\n\n7\n\n3 2 5 1 7 4 7\n\n\n\n\n\nExplicatie: Nota a 3a din solfegiu se va inlocui cu 1 sau cu 6, iar intre ultimele doua note se va adauga una din notele 4 sau 5.\n==Include(page=\"template/taskfooter\" task_id=\"note\")==',0,''),('problema/numere','Numere','2006-11-11 11:23:44','==Include(page=\"template/taskheader\" task_id=\"numere\")==\n\n==Include(page=\"template/raw\")==\n\nNumere\n\n\n\nCand erau ei mai tineri, lui Mars si lui Mugurel le placea sa se joace cu numerele. Astfel, ei au inventat urmatorul joc: Doi jucatori se joaca cu doua numere pozitive. Jucatorii efectueaza mutari alternativ, iar jucatorul care a efectuat ultima mutare castiga. O mutare consta in scaderea din numarul mai mare a unui multiplu strict pozitiv al numarului mai mic, cu conditia ca acest multiplu sa fie mai mic decat sau egal cu numarul mai mare. Altfel spus, presupunand ca cele doua numere sunt X si Y si ca X>=Y, o mutare consta in scaderea din numarul X a oricarui numar de forma K*Y (K>=1), cu conditia K*Y<=X. Jocul se termina cand unul din numere devine egal cu 0. Scrieti un program care decide care din cei doi jucatori va castiga jocul, considerand ca ambii jucatori joaca optim.\n\nh2. Date de Intrare\n\nPrima linie a fisierului numere.in contine numarul T de jocuri descrise in continuare. Fiecare din urmatoarele T linii contine 2 numere intregi X si Y, separate printr-un spatiu, reprezentand valorile initiale ale celor doua numere.\n\nh2. Date de Iesire\n\nIn fisierul numere.out veti afisa T linii. Pe fiecare linie veti afisa castigatorul jocului corespunzator din fisierul de intrare. Veti afisa 1, daca primul jucator (cel care efectueaza prima mutare) va castiga, respectiv 2, daca al doilea jucator va castiga.\n\nh2. Restrictii si precizari\n\n. 1 <= T <= 20\n\n. 1 <= X,Y <= 10^9\n\nh2. Exemplu\n\nnumere.in numere.out\n5 1\n\n1 19 1\n\n19 1 2\n\n27 33 2\n\n333333333 273333333 1\n\n9997 19999\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"numere\")==',0,''),('problema/traseu','Traseu','2006-11-11 18:07:17','==Include(page=\"template/taskheader\" task_id=\"traseu\")==\r\n\r\nGigel s-a mutat intr-un oras nou! Pentru a se familiariza cu noile imprejurimi a cumparat harta orasului si a observat ca este alcatuita din $M$ strazi de diferite lungimi, cu sens unic si $N$ intersectii de strazi. Gigel a luat harta si a inceput sa alcauiasca un traseu care porneste dintr-o intersectie anume, trece prin fiecare strada cel putin o data, si revine in intersectia de unde a pornit. Desi dorinta lui de explorare este mare, conditia lui fizica nu este tocmai buna, astfel ca vrea sa gasesasca un traseu in care suma lungimilor strazilor parcurse este minima.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care gaseste un traseu de lungime minima in orasul lui Gigel.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie din fisierul traseu.in se gasesc numerele N si M separate prin cate un spatiu. Pe urmatoarele M linii se vor gasi triplete de numere i j k cu semnificatia ca exista o strada de la intersectia cu numar i la intersectia cu numar j de lungime k.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie din fisierul traseu.out se va afisa un singur numar natural reprezentand lungimea minima a traseului lui Gigel.\r\n\r\nh2. Restrictii si precizari\r\n\r\nS 1 <= N <= 60\r\n\r\nS Lungimile strazilor sunt numere naturale din intervalul [1, 10.000]\r\n\r\nS Daca intre doua intersectii i si j exista o strada, atunci cu singuranta nu va exista o strada intre intersectiile j si i\r\n\r\nS Se garanteaza ca exista cel putin un traseu in oras care trece prin fiecare strada cel putin o data si incepe si se termina in aceeasi intersectie\r\n\r\nh2. Exemplu\r\n\r\ntraseu.in traseu.out Explicatie\r\n6 8 28 Traseul ales este:\r\n\r\n1 2 3 (1,2,3,1,4,6,1,4,5,1)\r\n\r\n2 3 1\r\n\r\n3 1 2\r\n\r\n1 4 4\r\n\r\n4 6 2\r\n\r\n6 1 5\r\n\r\n4 5 1\r\n\r\n5 1 6\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/traseu/enunt.files/filelist.xml\r\n==Include(page=\"template/taskfooter\" task_id=\"traseu\")==',256,''),('problema/transport','Transport','2006-11-11 11:23:44','==Include(page=\"template/taskheader\" task_id=\"transport\")==\n\n==Include(page=\"template/raw\")==\n\nTransport\n\n\n\nO firma ce produce saltele cu apa are N astfel de saltele intr-un depozit, asezate una peste alta (intr-o stiva). Fiecare saltea este caracterizata prin volumul sau (un numar intreg, exprimat in decimetri cubi). Pentru a le transporta la magazin, in vederea comercializarii, firma va inchiria un camion care va avea o capacitate egala cu C decimetri cubi. Acest camion va trebuie sa efectueze cel mult K transporturi (s-a estimat durata fiecarui transport si s-a ajuns la concluzia ca daca s-ar efectua mai mult de K transporturi, camionul ar ajunge la magazin in afara orelor de aprovizionare, astfel ca saltelele nu ar putea fi comercializate). La fiecare transport, camionul poate fi incarcat cu saltele, cu conditia ca suma volumelor saltelelor incarcate in camion sa nu depaseasca capacitatea camionului. Intrucat saltele sunt asezate intr-o stiva, nu este posibil sa se incarce in camion o saltea decat dupa ce au fost incarcate (si, eventual, transportate) toate saltelele de deasupra ei. Intrucat costul\ninchirierii camionului depinde de capacitatea acestuia, firma doreste sa inchirieze un camion cu capacitatea cat mai mica care sa poata transporta toate cele N saltele, efectuand maxim K transporturi.\n\nh2. Date de Intrare\n\nPe prima linie a fisierului transport.in se afla numerele intregi N si K (separate printr-un spatiu). Pe fiecare din urmatoarele N linii se afla un numar intreg, reprezentand volumul unei saltele. Prima din aceste N linii contine volumul saltelei din varful stivei, a doua linie contine volumul celei de-a doua saltele s.a.m.d.\n\nh2. Date de Iesire\n\nIn fisierul transport.out veti afisa un singur numar intreg, reprezentand capacitatea minima pe care trebuie sa o aiba camionul pentru a putea transporta cele N saltele efectuand maxim K transporturi.\n\nh2. Restrictii si precizari\n\n. 1 <= N <= 16.000\n\n. 1 <= K <= 16.000\n\n. 1 <= volumul oricarei saltele <= 16.000\n\nh2. Exemplu\n\ntransport.in transport.out Explicatie\n6 3 8 La primul transport este incarcata prima saltea (care are volumul 7). La\ncel de-al doilea transport sunt incarcate saltele 2 si 3 (volumul total\n7 este 3 + 2 = 5). La cel de-al treilea transport sunt incarcate saltele\n4, 5 si 6 (volumul total este 3 + 1 + 4 = 8).\n3\n\n2\n\n3\n\n1\n\n4\n\n\n==Include(page=\"template/taskfooter\" task_id=\"transport\")==',0,''),('problema/overlap','Overlap','2006-11-11 11:23:51','==Include(page=\"template/taskheader\" task_id=\"overlap\")==\n\n==Include(page=\"template/raw\")==\n\nLink: [1]File-List\n\nOverlap\n\n\n\n\n\nFie N puncte in plan cu coordonate intregi x_i , y_i. Acestea sunt rotite cu k*90 grade ( k = 0 , 1 , 2 sau 3 ) si/sau translatate, astfel incat se obtin alte N puncte, diferite doua cate doua de primele.\n\nh2. Cerinta\n\nDandu-se N(numar par) puncte, determinati o impartire a lor in doua submultimi de cardinal N/2 astfel incat a doua sa poata fi obtinuta din prima prin operatiile descrise.\n\nh2. Date de Intrare\n\nPe prima linie a fisierului de intrare overlap.in se afla N , numarul de puncte, iar pe urmatoarele N linii se afla cate o pereche x_i , y_i - pe cea de-a i -a linie se afla coordonatele punctului i\n\nh2. Date de Iesire\n\nFisierul de iesire overlap.out va contine N linii, iar pe fiecare linie va exista un singur caracter 1 sau 2 cu semnificatia ca punctele etichetate cu 1 fac parte din prima multime, iar punctele etichetate cu 2 fac parte din cea de-a doua multime. Daca exista mai multe solutii se cere oricare dintre acestea; se garanteaza existenta cel putin a unei solutii.\n\nh2. Restrictii si precizari\n\n. 1 <= N <= 800\n\n. 0 <= x_i, y_i <= 100.000\n\n. Prin \"rotatie\" se intelege fixarea unui punct oarecare in plan si rotirea tuturor punctelor initiale fata de acesta.\n\n. Prin \"translatie\" se intelege alegerea numerelor constante shift_x si shift_y, si transformarea coordonatelor (P_i_x, P_i_y) in (P_i_x+shift_x, P_i_y+shift_y) pentru orice punct i.\n\nh2. Exemplu\n\noverlap.in overlap.out\n6 1\n2\n5 5 2\n1\n9 1 2\n1\n6 1\n\n3 2\n\n6 3\n\n3 5\n\n\n\nReferences\n\nVisible links\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/overlap/enunt.files/filelist.xml\n==Include(page=\"template/taskfooter\" task_id=\"overlap\")==',0,''),('template/taskheader','template/taskheader','2006-11-11 18:43:18','| Fisierul intrare/iesire: | ==TaskParam(param=\"id\" task_id=\"%task_id%\")==.in, ==TaskParam(param=\"id\" task_id=\"%task_id%\")==.out |||\r\n| Autor | ==TaskParam(param=\"author\" task_id=\"%task_id%\")== | Sursa | ==TaskParam(param=\"source\" task_id=\"%task_id%\")== |\r\n| Timp executie pe test | ==TaskParam(param=\"timelimit\" task_id=\"%task_id%\")== sec | Numar teste | ==TaskParam(param=\"tests\" task_id=\"%task_id%\")== |\r\n\r\nh1. ==TaskParam(param=\"title\" task_id=\"%task_id%\")==\r\n\r\n',15,''),('template/newtask','Template folosit atunci cand se creaza un task nou','2006-11-11 13:06:05','== include(page=\"template/taskheader\" task_id=\"%task_id%\") ==\r\n\r\nPoveste si cerinta...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n... &le; ...\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. %task_id%.in |_. %task_id%.out |\r\n| linia1\r\nlinia2\r\nlinia3\r\n| linia1\r\nlinia2\r\n|\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"%task_id%\") ==\r\n',1,''),('problema/parcare','Parcare','2006-11-11 11:23:58','==Include(page=\"template/taskheader\" task_id=\"parcare\")==\n\n==Include(page=\"template/raw\")==\n\nParcare\n\n\n\nPentru a face rost de bani, Cezar s-a angajat, pe perioada verii ca administrator al unei parcari. Parcarea este un patrat format din blocuri de beton, de asemenea patrate, cu latura de un metru. Parcarea are o singura iesire pe latura dinspre nord, in rest este inconjurata de ziduri pe care masinile nu le pot depasi. Masinile din parcare sunt dreptunghiuri cu latimea de 1 m si lungimea mai mare sau egala cu 2 m. Ele sunt orientate nord-sud sau est-vest. Atunci cand s-a angajat, Cezar nu credea ca aceasta slujba ii va crea probleme, dar astazi este intr-o situatie delicata : un client i-a cerut sa-i scoata masina din parcare. Cezar are cheile de la toate masinile, dar nu este un sofer foarte bun : el nu poate lua viraje, poate merge doar inainte si in marsarier. A incercat timp de o ora sa scoata masina din parcare, dar nu a reusit si s-a gandit sa apeleze la ajutorul vostru. El a facut o harta a parcarii : a reprezentat cu `.\' portiunile de asfalt, cu `#\' zidurile parcarii si cu litere mari consecutive\nale alfabetului latin masinile. Masina care trebuie scoasa din parcare a reprezentat-o cu `A\'.\n\nh2. Cerinta\n\nEl va roaga sa-i scrieti un program care sa scoata masina din parcare in mai putin de 100 miscari. El considera o miscare mutarea unei masini, intr-o anumita directie, cu un numar intreg de metri.\n\nh2. Date de Intrare\n\nPe prima linie a fisierului parcare.in se afla un numar intreg (N) reprezentand dimensiunea hartii. Pe urmatoarele N linii se afla cate N caractere reprezentand codificarea hartii.\n\nh2. Date de Iesire\n\nPe prima linie a fisierului parcare.out se va afla numarul de miscari (M) prin care a fost rezolvata problema. Pe urmatoarele M linii se vor afla 3 caractere ce reprezinta o mutare. Primul reprezinta litera asociata masinii ce va fi mutata, al doilea directia in care va fi mutata (N- nord, S-sud, E-est, V-vest), iar al treilea numarul de blocuri cu care va fi mutata. In locul miscarii prin care masina `A\' paraseste parcarea se va afisa `Exit\'.\n\nh2. Restrictii si precizari\n\n- 7 <= N <= 9\n\n- Sunt maxim 10 masini in parcare.\n\n- Pe a doua linie a fisierului de intrare se va gasi un caracter `.\' (iesirea)\n\n- Daca o masina are o anumita litera a alfabetului atunci exista exact o masina atribuita fiecarei litere mai mici decat litera respectiva.\n\n- Nu exista doua masini cu aceeasi litera.\n\n- Este imposibil ca alta masina sa poata parasi parcarea inaintea masinii `A\'\n\n- Se garanteaza existenta unei solutii.\n\n- Orice solutie cu mai putin 100 miscari va primi punctajul maxim.\n\n\n\nExemple\n\n\n|parcare.in |parcare.out |parcare.in |parcare.out |\n\n|8 |3 |8 |8 |\n| | | | |\n|###.#### |CS1 |###.#### |BN1 |\n| | | | |\n|#..BBBC# |BE1 |#HHH.G.# |CV1 |\n| | | | |\n|#..A..C# |Exit |#....GF# |DV1 |\n| | | | |\n|#..A..C# | |#.EEE.F# |FS2 |\n| | | | |\n|#.....C# | |#..A..F# |GS3 |\n| | | | |\n|#.....C# | |#B.A...# |EE2 |\n| | | | |\n|#......# | |#BCCCDD# |HE3 |\n| | | | |\n|######## | |######## |Exit |\n| | | | |\n| | | | |\n\n\n\n\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"parcare\")==',0,''),('documentatie/textile','Formatare Textile','2006-11-11 19:28:55','h1. Tutorial de Textile\r\n\r\nh2. Limbajul Textile\r\n\r\nPentru reguli generale despre regulile de formatare ale limbajului Textile accesati acest link: \"http://hobix.com/textile/\":http://hobix.com/textile/\r\n*ATENTIE!* Evitati folosirea codului HTML in cadrul Textile.\r\n\r\nh2. Formatarea task-urilor\r\n\r\nStructura unui task este urmatoarea:\r\n\r\n* *Template de header*\r\nSe include linia $==Include(page=\"template/taskheader\" task_id=\"*nume_task*\")==$ la inceput unde $nume_task$ reprezinta numele task-ului la care lucrezi\r\n\r\n* *Alte template-uri*\r\nIn cazul ca problema a fost importata de pe _infoarena 1.0_ veti vedea urmatoarea linie $==Include(page=\"template/raw\")==$. Daca nu sunteti multumit de rezultatul final, dar nu mai aveti chef sa editati in continuare, puteti include linia $==Include(page=\"template/cleanup\")==$ \r\n\r\n* *Poveste*\r\nIn editarea enunturilor se vor respecta urmatoarele reguli: toate variabilele, constantele sau nume de fisiere se va folosi fie modificatorul *{@ $...$ @}* (in caz ca nu merge se foloseste *{@ {$...$} @}*). Daca doriti ca textul dintre modificatori sa nu fie interpretat ca Textile puteti folosi in schimb modificatorul *{@ @...@ @}*, respectiv *&#0123;{@@...@@} &#0125;* in cazul ca nu merge prima varianta.\r\nIn general, nu se foloseste bold sau alti modificatori. Daca aveti probleme cu inserarea unui anumit caracter puteti consulta aceasta \"lista\":http://en.wikipedia.org/wiki/List_of_HTML_decimal_character_references si sa folosit direct codul HTML de acolo.\r\n\r\n* *Date de intrare*\r\nTitlurile de tipul \"Date de intrare\", \"Date de iesire\", etc. se scriu astfel: {@ h2. Titlu @} urmat de o linie noua. Pe linia urmatoare se mentioneaza numele fisierului de intrare, si formatul acestuia folosind conventiile de formatare de mai sus.\r\n\r\n* *Date de iesire*\r\nLa fel ca mai sus.\r\n\r\n* *Restrictii*\r\nRestrictiile se pun intr-o lista nenumerotata folosind caracterul *{@*@}* la inceputul fiecarui rand. Oriunde se intalnesc variabile si constante se folosesc modificatorii mentionati (eventual pentru intregul rand). Pentru a insera &le; sau &ge; folositi codurile HTML corespunzatoare ({@&le;@} pentru &le; si {@&ge;@} pentru &ge;). O lista completa de caractere speciale gasiti \"aici\":http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references.\r\n\r\n* *Exemplu*\r\nExemplul il veti pune intr-un tabel formatat similar celui din \"template\":http://www.infoarena.ro/template/newtask\r\nPrima coloana a tabelului va fi formatata in felul urmator:\r\n@table(example). |_. %task_id%.in |_. %task_id%.out |@\r\nunde $task_id$ reprezinta id-ul taskului editat.\r\nPentru coloane aditionale veti adauga in continuare @_. nume_coloana |@ de cate ori este necesar.\r\nFiecare din liniile de tabel ce urmeaza se va reprezenta pe coloane, fiecare celula fiind separata prin pipe {$|$}: {$| coloana 1 | coloana 2| coloana 3 | coloana 4 | $}\r\nSe pot introduce mai multe linii intr-o singura celula a tabelului folosind, evident, new line.\r\n\r\n* *Poza*\r\n* *Template de footer*\r\n\r\n',1,''),('problema/pascal','Pascal','2006-11-11 11:23:38','==Include(page=\"template/taskheader\" task_id=\"pascal\")==\n\n==Include(page=\"template/raw\")==\n\nLink: [1]File-List\nLink: [2]Edit-Time-Data\n\npascal\n\n\n\nIon a invatat la ora de matematica despre triunghiul lui Pascal. Fiecare rand din acest triunghi are primul si ultimul element egal cu 0. Un element din triunghi se calculeaza ca fiind suma celor 2 elemente exact deasupra acestuia. Randurile sunt numerotate de la 0, deci, spre exemplu, randul 2 contine: 1 2 1 . Este un fapt binecunoscut ca valoarea elementului j (cu indexarea elementelor de la 0) de pe linia i se poate calcula si cu ajutorul formulei: i!/((i-j)!*j!) . (Prin i! se intelege produsul 1*2*...*i)\n\nh2. Cerinta\n\nAjutati-l pe Ion sa calculeze cate numere de pe randul R sunt divizibile la D.\n\nh2. Date de Intrare (fisier: pascal.in)\n\nPe prima linie a fisierului de intrare se gasesc numerele R si D.\n\nh2. Date de Iesire (fisier: pascal.out)\n\nPe prima linie a fisierului de iesire se va gasi numarul cerut.\n\nh2. Restrictii\n\nS 0 <= R <= 5.000.000\n\nS 2 <= D <= 6\n\nS Observatie: 0! = 1\n\nh2. Exemplu\n\npascal.in pascal.out Explicatie\n4 2 3 [3]Pascal\n\nRandul 4 contine elementele :\n\n1 4 6 4 1\n\ndintre care 4, 6 si 4 sunt divizible la 2\n\n\n\nReferences\n\nVisible links\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/pascal/enunt.files/filelist.xml\n2. file:///home/eval/eval/www/infoarena/docs/arhiva/pascal/enunt.files/editdata.mso\n==Include(page=\"template/taskfooter\" task_id=\"pascal\")==',0,''),('problema/sume','Sume','2006-11-11 19:34:32','==Include(page=\"template/taskheader\" task_id=\"sume\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nHaralambie este un elev silitor, asa ca a decis sa-si faca urmatoarea tema la mate: a primit pe o foaie de hartie un sir de N numere naturale nenule nu neaparat distincte. El a luat toate perechile de numere din acest sir si le-a adunat, le-a scris pe o alta foaie, obtinand astfel un nou sir de numere. Numai ca a pierdut prima foaie si acum vrea sa gaseasca sirul initial de numere.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Haralambie sa reconstituie sirul initial de numere.\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul $sume.in$ se afla pe prima linie $P$, iar pe urmatoarea linie sunt scrise $P$ numere naturale mai mici sau egale cu $1000$.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul sume.out se va afisa pe prima linie $N$ iar pe a doua linie cele N numere din sirul initial despartite printr-un un spatiu.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; P &le; 25000$\r\n* In cazul in care exista mai multe solutii, se va afisa in fiser numai una\r\n* In cazul in care nu exista solutie se va afisa in fisier $-1$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_.sume.in |_.sume.out|\r\n|3\r\n4 5 3\r\n|3\r\n3 1 2|\r\n|15\r\n5 7 15 10 8 8 16 11 9 18 13 11 21 19 14\r\n|6\r\n2 3 5 13 8 6|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sume\")==',4895,''),('problema/cobai','Cobai','2006-11-11 11:23:39','==Include(page=\"template/taskheader\" task_id=\"cobai\")==\n\n==Include(page=\"template/raw\")==\n\nLink: [1]File-List\n\ncobaiul\n\n\n\nDiorde, cel mai tare biolog din Tritenii de Jos, lucreaza la crearea unui elixir care sa-i faca pe consatenii sai mai inteligenti. El testeaza acest elixir pe Miki, singurul om din sat care s-a oferit voluntar. Pentru a vedea cat de inteligent este acesta, Diorde a construit un caroiaj dreptunghiular, caroiaj de M*N camere. Din fiecare camera sunt cel mult 4 usi, orientate inspre Nord, Sud, Est si Vest. In unele camere nu se poate intra, ele fiind inchise. Diorde are un cobai mult mai istet decat multi dintre sateni, cobai caruia ii da drumul dintr-o camera pe care o va inchide dupa aceea, si-l va lasa sa se miste in voie o perioada de timp. Cobaiul este dotat cu un dispozitiv care transmite tot timpul un semnal, care ne spune directia in care se deplaseaza cobaiul. Acest aparat detecteaza doar schimbarile de directie ale cobaiului. Dupa schimbarea unei directii cobaiul se deplaseaza cu cel putin o pozitie in acea directie, si modificarile de directie au loc intotdeauna cu 90DEG.\n\nCe trebuie sa faca Miki pentru a dovedi ca este mai inteligent ? Avand in mana harta caroiajului (cu \'.\' vor fi marcate camerele deschise iar cu \'+\' camerele inchise) , si stiind pozitia din care a plecat cobaiul (marcata cu \'*\'), precum si directiile in care s-a deplasat acesta, trebuie sa determine o pozitie posibila in care se poate afla cobaiul la sfarsitul acelui interval de timp.\n\nVoi trebuie sa calculati probabilitatea ca Miki sa ghiceasca o pozitie, in care cobaiul poate fi.\n\nh2. Date de Intrare (fisier: cobai.in)\n\nPrima linie a fisierului de intrare contine numerele M si N, separate printr-un singur spatiu. Urmatoarele M linii contin cate N caractere care descriu suprafata planetei (caracterele admise sunt \'.\', \'+\' si \'*\' ; ele au semnificatia prezentata anterior). Urmatoarea linie va descrie informatiile furnizate de dispozitivul de urmarire, neseparate prin spatii. Litera \'N\' indica o deplasare spre nord (spre prima linie a matricei), litera \'V\' o deplasare spre vest (spre prima coloana), litera \'S\' o deplasare spre sud (spre ultima linie), iar litera \'E\' o deplasare spre est (spre ultima coloana).\n\nh2. Date de Iesire (fisier: cobai.out)\n\nFisierul de iesire va contine un singur numar care va indica procentul cautat. Numarul va fi real cu 2 zecimale, nerotunjit.\n\nh2. Restrictii\n\nS 1 <= N,M <= 50\n\nS Numarul schimbarilor de directie este cel mult 1.000\n\nS Cobaiul nu poate parasi caroiajul\n\nh2. Exemplu\n\ncobai.in cobai.out\n4 5 28.57\n\n.....\n\n.+.+.\n\n+....\n\n.++.*\n\nNVS\n\n\n\nExplicatie\n\nCaroiajul contine 14 camere in care se poate intra ( cele notate cu `.\' ). Deplasandu-se in directiile N, urmat de V, apoi de S el nu se mai poate afla decat in alte 4 camere. Rezulta un procent de 28,57 %.\n\nReferences\n\nVisible links\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/cobai/enunt.files/filelist.xml\n==Include(page=\"template/taskfooter\" task_id=\"cobai\")==',0,''),('documentatie/textile','Formatare Textile','2006-11-11 19:42:52','h1. Tutorial de Textile\r\n\r\nh2. Limbajul Textile\r\n\r\nPentru reguli generale despre regulile de formatare ale limbajului Textile accesati acest link: \"http://hobix.com/textile/\":http://hobix.com/textile/\r\n*ATENTIE!* Evitati folosirea codului HTML in cadrul Textile.\r\n\r\nh2. Formatarea task-urilor\r\n\r\nStructura unui task este urmatoarea:\r\n\r\n* *Template de header*\r\nSe include linia $==Include(page=\"template/taskheader\" task_id=\"*nume_task*\")==$ la inceput unde $nume_task$ reprezinta numele task-ului la care lucrezi\r\n\r\n* *Alte template-uri*\r\nIn cazul ca problema a fost importata de pe _infoarena 1.0_ veti vedea urmatoarea linie $==Include(page=\"template/raw\")==$. Daca nu sunteti multumit de rezultatul final, dar nu mai aveti chef sa editati in continuare, puteti include linia $==Include(page=\"template/cleanup\")==$ \r\n\r\n* *Poveste*\r\nIn editarea enunturilor se vor respecta urmatoarele reguli: toate variabilele, constantele sau nume de fisiere se va folosi fie modificatorul *{@ $...$ @}* (in caz ca nu merge se foloseste *{@ {$...$} @}*). Daca doriti ca textul dintre modificatori sa nu fie interpretat ca Textile puteti folosi in schimb modificatorul *{@ @...@ @}*, respectiv *&#0123;{@@...@@} &#0125;* in cazul ca nu merge prima varianta.\r\nIn general, nu se foloseste bold sau alti modificatori. Daca aveti probleme cu inserarea unui anumit caracter puteti consulta aceasta \"lista\":http://en.wikipedia.org/wiki/List_of_HTML_decimal_character_references si sa folosit direct codul HTML de acolo.\r\n\r\n* *Date de intrare*\r\nTitlurile de tipul \"Date de intrare\", \"Date de iesire\", etc. se scriu astfel: {@ h2. Titlu @} urmat de o linie noua. Pe linia urmatoare se mentioneaza numele fisierului de intrare, si formatul acestuia folosind conventiile de formatare de mai sus.\r\n\r\n* *Date de iesire*\r\nLa fel ca mai sus.\r\n\r\n* *Restrictii*\r\nRestrictiile se pun intr-o lista nenumerotata folosind caracterul *{@*@}* la inceputul fiecarui rand. Oriunde se intalnesc variabile si constante se folosesc modificatorii mentionati (eventual pentru intregul rand). Pentru a insera &le; sau &ge; folositi codurile HTML corespunzatoare ({@&le;@} pentru &le; si {@&ge;@} pentru &ge;). O lista completa de caractere speciale gasiti \"aici\":http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references.\r\n\r\n* *Exemplu*\r\nExemplul il veti pune intr-un tabel formatat similar celui din \"template\":http://www.infoarena.ro/template/newtask/.\r\nPrima coloana a tabelului va fi formatata in felul urmator:\r\n@table(example). |_. %task_id%.in |_. %task_id%.out |@\r\nunde $task_id$ reprezinta id-ul taskului editat.\r\nPentru coloane aditionale veti adauga in continuare @_. nume_coloana |@ de cate ori este necesar.\r\nFiecare din liniile de tabel ce urmeaza se va reprezenta pe coloane, fiecare celula fiind separata prin pipe  &#0124;: \r\n{@ | coloana 1 | coloana 2 | coloana 3 | coloana 4 | @}\r\nSe pot introduce mai multe linii intr-o singura celula a tabelului folosind, evident, new line. Daca doriti sa introduceti linii goale in tabel folositi @&nbsp;@.\r\n\r\n* *Poza*\r\nPentru a introduce poze intr-un task intai este necesara atasarea lor (se foloseste link-ul \"Atasare\" care se gaseste in coltul dreapta-sus langa \"Editeaza\").\r\n\r\n* *Template de footer*\r\n\r\n',1,''),('problema/apdm','APDM','2006-11-11 14:10:12','==Include(page=\"template/taskheader\" task_id=\"apdm\")==\r\n\r\nVom considera un graf conex, neorientat, cu $N$ varfuri si $M$ muchii. Fie $D(i, j)$ distanta minima dintre varfurile $i$ si $j$. Prin diametrul grafului vom defini valoarea $Max { D(i,j) (1 &le; i < j &le; N) }$.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine arborele partial de diametru minim al grafului dat!\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $apdm.in$ se afla $N$ si $M$. Pe fiecare din urmatoarele $M$ linii se afla cate doua numere intregi sub forma $x y$, indicand prezenta unei muchii intre varfurile $x$ si $y$.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului $apdm.out$ se va afisa diametrul arborelui obtinut.\r\n\r\nh2. Restrictii\r\n\r\n* $3 &le; N &le; 150$\r\n* $N &le; M &le; 5000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. apdm.in |_. apdm.out |_. Explicatie |\r\n| 8 13\r\n1 2\r\n1 5\r\n2 4\r\n1 7\r\n2 3\r\n3 4\r\n3 8\r\n4 5\r\n4 6\r\n5 6\r\n5 7\r\n6 7\r\n6 8\r\n| 4 \r\n| In desen observam colorate cu verde muchiile unui arbore partial de diametru 4, acestea sunt: (1, 5), (2, 4), (3, 4), (4, 5), (4, 6), (5, 7), (6, 8) \r\n!http://infoarena.ro/task/12perm?action=download&file=apdm.gif! |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"apdm\")==',961,''),('documentatie/textile','Formatare Textile','2006-11-11 20:02:40','h1. Tutorial de Textile\r\n\r\nh2. Limbajul Textile\r\n\r\nPentru reguli generale despre regulile de formatare ale limbajului Textile accesati acest link: \"http://hobix.com/textile/\":http://hobix.com/textile/\r\n*ATENTIE!* Evitati folosirea codului HTML in cadrul Textile.\r\n\r\nh2. Formatarea task-urilor\r\n\r\nStructura unui task este urmatoarea:\r\n\r\n* *Template de header*\r\nSe include linia $==Include(page=\"template/taskheader\" task_id=\"*nume_task*\")==$ la inceput unde $nume_task$ reprezinta numele task-ului la care lucrezi\r\n\r\n* *Alte template-uri*\r\nIn cazul ca problema a fost importata de pe _infoarena 1.0_ veti vedea urmatoarea linie $==Include(page=\"template/raw\")==$. Daca nu sunteti multumit de rezultatul final, dar nu mai aveti chef sa editati in continuare, puteti include linia $==Include(page=\"template/cleanup\")==$ \r\n\r\n* *Poveste*\r\nIn editarea enunturilor se vor respecta urmatoarele reguli: toate variabilele, constantele sau nume de fisiere se va folosi fie modificatorul *{@ $...$ @}* (in caz ca nu merge se foloseste *{@ {$...$} @}*). Daca doriti ca textul dintre modificatori sa nu fie interpretat ca Textile puteti folosi in schimb modificatorul *{@ @...@ @}*, respectiv *&#0123;{@@...@@} &#0125;* in cazul ca nu merge prima varianta.\r\nIn general, nu se foloseste bold sau alti modificatori. Daca aveti probleme cu inserarea unui anumit caracter puteti consulta aceasta \"lista\":http://en.wikipedia.org/wiki/List_of_HTML_decimal_character_references si sa folosit direct codul HTML de acolo.\r\n\r\n* *Date de intrare*\r\nTitlurile de tipul \"Date de intrare\", \"Date de iesire\", etc. se scriu astfel: {@ h2. Titlu @} urmat de o linie noua. Pe linia urmatoare se mentioneaza numele fisierului de intrare, si formatul acestuia folosind conventiile de formatare de mai sus.\r\n\r\n* *Date de iesire*\r\nLa fel ca mai sus.\r\n\r\n* *Restrictii*\r\nRestrictiile se pun intr-o lista nenumerotata folosind caracterul *{@*@}* la inceputul fiecarui rand. Oriunde se intalnesc variabile si constante se folosesc modificatorii mentionati (eventual pentru intregul rand). Pentru a insera &le; sau &ge; folositi codurile HTML corespunzatoare ({@&le;@} pentru &le; si {@&ge;@} pentru &ge;). O lista completa de caractere speciale gasiti \"aici\":http://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references.\r\n\r\n* *Exemplu*\r\nExemplul il veti pune intr-un tabel formatat similar celui din \"template\":http://www.infoarena.ro/template/newtask/.\r\nPrima coloana a tabelului va fi formatata in felul urmator:\r\n@table(example). |_. %task_id%.in |_. %task_id%.out |@\r\nunde $task_id$ reprezinta id-ul taskului editat.\r\nPentru coloane aditionale veti adauga in continuare @_. nume_coloana |@ de cate ori este necesar.\r\nFiecare din liniile de tabel ce urmeaza se va reprezenta pe coloane, fiecare celula fiind separata prin pipe  &#0124;: \r\n{@ | coloana 1 | coloana 2 | coloana 3 | coloana 4 | @}\r\nSe pot introduce mai multe linii intr-o singura celula a tabelului folosind, evident, new line. Daca doriti sa introduceti linii goale in tabel folositi @&nbsp;@.\r\nDaca aveti probleme cu latimile coloanelor in tabel din cauza explicatiilor, aceste pot fi incluse separat sub un titlu {@h3@}.\r\n\r\n* *Poza*\r\nPentru a introduce poze intr-un task intai este necesara atasarea lor (se foloseste link-ul _Ataseaza_ care se gaseste in coltul dreapta-sus langa _Editeaza_). Dupa ce ati atasat poza aceasta se include in cod astfel: @!nume_pagina?nume_poza.extensie!@ unde @nume_pagina@ reprezinta numele paginii (spre exemplu numele acestei pagini este _textile_) si @nume_poza.extensie@ este numele sub care a fost incarcat fisierul.\r\n\r\n* *Template de footer*\r\n\r\n',1,''),('problema/count','Count','2006-11-11 18:39:28','==Include(page=\"template/taskheader\" task_id=\"count\")==\r\n\r\nFiind dat un graf planar cu $N$ noduri si $M$ muchii aflati numarul maxim de noduri pe care il poate avea un subgraf complet al sau (un graf neorientat se numeste complet daca exista muchie intre oricare doua noduri ale sale). De asemenea se cere si numarul de subgrafuri complete cu numar maxim de noduri care se gasesc in graful planar dat.\r\n\r\nh2. Cerinta\r\n\r\nFiind dat un graf planar aflati cele doua numere cautate.\r\n\r\nh2. Date de Intrare\r\n\r\nLinia 1 a fisierului de intrare contine doua numere naturale separate prin spatii $N$ si $M$ (numarul de noduri, respectiv numarul de muchii ale grafului planar).\r\nLiniile $2 .. M + 1$ contin cate doua numere $A$ si $B$ cu semnificatia: exista o muchie bidirectionala intre nodurile $A$ si $B$ (nodurile grafului sunt numerotate de la $1$ la $N$).\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire va contine pe prima linie doua numere $X$ si $Y$ reprezentand numarul maxim de noduri pe care il poate avea un subgraf complet si, respectiv, numarul de subgrafuri complete cu $X$ noduri din graful planar dat.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 30 000$\r\n* $1 &le; M &le; 60 000$\r\n* $Y &le; 2^30$\r\n* Pentru $70%$ din teste $N &le; 2000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. count.in |_. count.out |_. Explicatii |\r\n| 5 8\r\n1 2\r\n1 3\r\n1 5\r\n2 4\r\n2 5\r\n3 4\r\n3 5\r\n4 5\r\n| 3 4\r\n| Se pot forma 4 subgrafuri  complete cu 3 noduri. Acestea  sunt:\r\n(1 2 5), (2 4 5), (3 4 5), (1 3 5) |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"count\")==',15,''),('problema/patrol','Patrol','2006-11-11 20:18:27','==Include(page=\"template/taskheader\" task_id=\"patrol\")==\r\n\r\nO tara are $N$ orase si $M$ legaturi directe, bidirectionale, intre aceste orase. Fiecare oras percepe o taxa de sedere cunoscuta. Un infractor porneste din orasul numerotat cu $1$ si doreste sa ajunga in orasul numerotat cu $N$, folosind legaturile existente. Cum lucrurile nu sunt niciodata asa de simple, exista si $P$ politisti care il cauta. Un politist are un traseu de patrulare bine definit. Traseul sau este de fapt un drum simplu ( in care toate orasele sunt distincte ). El va parcurge un drum du-te vino, adica pleaca pe drumul stabilit, dupa care se intoarce pe acelasi drum, etc. De exemplu, daca traseul de patrulare al unui politist este $4 7 5$, el va merge intotdeuna pe $4 7 5 7 4 7 5 7 4...$. Parcurgerea unei legaturi intre oricare doua orase legate direct se realizeaza intr-o unitate de timp, pentru infractor si pentru oricare dintre politisti. Stationarea intr-un oras nu necesita timp suplimentar.\r\nInfractorul porneste din orasul numerotat cu $1$ si doreste sa ajunga in orasul numerotat cu $N$, platind o taxa de sedere minima prin orasele prin care trece, evitand intalnirea cu vreun politist. O intalnire se poate realiza atunci cand infractorul si unul din politisti se afla in acelasi timp in acelasi oras, sau in acelasi timp pe o legatura intre orase. Plecarea din orasul $1$ se realizeaza la momentul $1$, cand toti politistii isi incep patrularea.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine costul total minim de sedere in orase astfel incat sa se indeplineasca conditiile precizate.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $patrol.in$ are urmatoarea structura:\r\n$N M P$ ]numarul de orase, numarul de legaturi si numarul de politisti\r\n$C[1] C[2] ... C[n]$  &nbsp;&nbsp; &nbsp; &nbsp;cele $N$ costuri de sedere, pentru fiecare oras in parte\r\n$A[1] B[1]$\r\n$A[2] B[2]$ &nbsp;&nbsp; &nbsp; &nbsp;linia $A[i] B[i]$ semnifica faptul ca exista o legatura directa intre orasele $A[i]$ si $B[i]$\r\n$.......$     \r\n$A[M] B[M]$\r\n$L[1] T[1,1]... T[1,L[1]]$\r\n$L[2] T[2,1]... T[2,L[2]]$ &nbsp;&nbsp; &nbsp; &nbsp;primul numar de pe linie indica lungimea traseului de patrulare, dupa care urmeaza descrierea traseului propriu-zis\r\n$.......$ \r\n$L[P] T[P,1]... T[P,L[P]]$\r\nIn total, fisierul de intrare contine M+P+2 linii.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului de iesire $patrol.out$ contine costul minim platit. Se garanteaza ca intotdeauna exista solutie.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 < N &le; 1 024$\r\n* $4 < M &le; 16 000$\r\n* $P &le; 512$\r\n* $2 &le; L[i] < 8$\r\n* Costurile de sedere sunt numere naturale din $[1, 1 600]$\r\n* In orice moment infractorul trebuie sa se deplaseze ( nu poate sta pe loc )\r\n* La costul total se vor calcula si taxele percepute in orasul de plecare si cel de sosire\r\n* Este posibil ca intr-un oras, in acelasi timp, sa fie mai mult de un politist\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. patrol.in |_. patrol.out |_. Explicatii |\r\n| 7 6 1\r\n10 4 9 1 2 5 2\r\n1 2\r\n2 3\r\n2 4\r\n2 6\r\n4 5\r\n6 7\r\n5 7 6 2 4 5\r\n| 34\r\n| Drumul infractorului este 1 2 3 2 6 7. Se observa ca, de exemplu, la timpul 2, infractorul nu poate pleca spre orasul cu numarul 6 pentru ca s-ar intalni pe legatura dintre orasele 2 si 6 cu politistul. In plus, daca ar pleca spre orasul cu numarul 4, el ar fi prins in final de catre politist. |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"patrol\")==',48,''),('problema/patrol','Patrol','2006-11-11 20:28:38','==Include(page=\"template/taskheader\" task_id=\"patrol\")==\r\n\r\nO tara are $N$ orase si $M$ legaturi directe, bidirectionale, intre aceste orase. Fiecare oras percepe o taxa de sedere cunoscuta. Un infractor porneste din orasul numerotat cu $1$ si doreste sa ajunga in orasul numerotat cu $N$, folosind legaturile existente. Cum lucrurile nu sunt niciodata asa de simple, exista si $P$ politisti care il cauta. Un politist are un traseu de patrulare bine definit. Traseul sau este de fapt un drum simplu ( in care toate orasele sunt distincte ). El va parcurge un drum du-te vino, adica pleaca pe drumul stabilit, dupa care se intoarce pe acelasi drum, etc. De exemplu, daca traseul de patrulare al unui politist este $4 7 5$, el va merge intotdeuna pe $4 7 5 7 4 7 5 7 4...$. Parcurgerea unei legaturi intre oricare doua orase legate direct se realizeaza intr-o unitate de timp, pentru infractor si pentru oricare dintre politisti. Stationarea intr-un oras nu necesita timp suplimentar.\r\nInfractorul porneste din orasul numerotat cu $1$ si doreste sa ajunga in orasul numerotat cu $N$, platind o taxa de sedere minima prin orasele prin care trece, evitand intalnirea cu vreun politist. O intalnire se poate realiza atunci cand infractorul si unul din politisti se afla in acelasi timp in acelasi oras, sau in acelasi timp pe o legatura intre orase. Plecarea din orasul $1$ se realizeaza la momentul $1$, cand toti politistii isi incep patrularea.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine costul total minim de sedere in orase astfel incat sa se indeplineasca conditiile precizate.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $patrol.in$ are urmatoarea structura:\r\n\r\ntable(Date de Intrare) |_. acolor.in |_. acolor.out |\r\n| $N M P$ \r\n${@C[1] C[2] ... C[n]@}$ \r\n${@A[1] B[1]@}$\r\n${@A[2] B[2]@}$ \r\n$.......$     \r\n${@A[M] B[M]@}$\r\n${@L[1] T[1,1]... T[1,L[1]]@}$\r\n${@L[2] T[2,1]... T[2,L[2]]@}$ \r\n$.......$ \r\n${@L[P] T[P,1]... T[P,L[P]]@}$\r\n| numarul de orase, numarul de legaturi si numarul de politisti\r\ncele $N$ costuri de sedere, pentru fiecare oras in parte\r\nlinia ${@A[i] B[i]@}$ semnifica faptul ca exista o legatura directa intre orasele ${@A[i]@}$ si ${@B[i]@}$\r\n&nbsp;&nbsp; &nbsp; &nbsp;primul numar de pe linie indica lungimea traseului de patrulare, dupa care urmeaza descrierea traseului propriu-zis |\r\n\r\n\r\nIn total, fisierul de intrare contine M+P+2 linii.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului de iesire $patrol.out$ contine costul minim platit. Se garanteaza ca intotdeauna exista solutie.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 < N &le; 1 024$\r\n* $4 < M &le; 16 000$\r\n* $P &le; 512$\r\n* $2 &le; L[i] < 8$\r\n* Costurile de sedere sunt numere naturale din $[1, 1 600]$\r\n* In orice moment infractorul trebuie sa se deplaseze ( nu poate sta pe loc )\r\n* La costul total se vor calcula si taxele percepute in orasul de plecare si cel de sosire\r\n* Este posibil ca intr-un oras, in acelasi timp, sa fie mai mult de un politist\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. patrol.in |_. patrol.out |_. Explicatii |\r\n| 7 6 1\r\n10 4 9 1 2 5 2\r\n1 2\r\n2 3\r\n2 4\r\n2 6\r\n4 5\r\n6 7\r\n5 7 6 2 4 5\r\n| 34\r\n| Drumul infractorului este 1 2 3 2 6 7. Se observa ca, de exemplu, la timpul 2, infractorul nu poate pleca spre orasul cu numarul 6 pentru ca s-ar intalni pe legatura dintre orasele 2 si 6 cu politistul. In plus, daca ar pleca spre orasul cu numarul 4, el ar fi prins in final de catre politist. |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"patrol\")==',48,''),('problema/patrol','Patrol','2006-11-11 20:29:04','==Include(page=\"template/taskheader\" task_id=\"patrol\")==\r\n\r\nO tara are $N$ orase si $M$ legaturi directe, bidirectionale, intre aceste orase. Fiecare oras percepe o taxa de sedere cunoscuta. Un infractor porneste din orasul numerotat cu $1$ si doreste sa ajunga in orasul numerotat cu $N$, folosind legaturile existente. Cum lucrurile nu sunt niciodata asa de simple, exista si $P$ politisti care il cauta. Un politist are un traseu de patrulare bine definit. Traseul sau este de fapt un drum simplu ( in care toate orasele sunt distincte ). El va parcurge un drum du-te vino, adica pleaca pe drumul stabilit, dupa care se intoarce pe acelasi drum, etc. De exemplu, daca traseul de patrulare al unui politist este $4 7 5$, el va merge intotdeuna pe $4 7 5 7 4 7 5 7 4...$. Parcurgerea unei legaturi intre oricare doua orase legate direct se realizeaza intr-o unitate de timp, pentru infractor si pentru oricare dintre politisti. Stationarea intr-un oras nu necesita timp suplimentar.\r\nInfractorul porneste din orasul numerotat cu $1$ si doreste sa ajunga in orasul numerotat cu $N$, platind o taxa de sedere minima prin orasele prin care trece, evitand intalnirea cu vreun politist. O intalnire se poate realiza atunci cand infractorul si unul din politisti se afla in acelasi timp in acelasi oras, sau in acelasi timp pe o legatura intre orase. Plecarea din orasul $1$ se realizeaza la momentul $1$, cand toti politistii isi incep patrularea.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine costul total minim de sedere in orase astfel incat sa se indeplineasca conditiile precizate.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $patrol.in$ are urmatoarea structura:\r\n\r\n|- | $N M P$ \r\n${@C[1] C[2] ... C[n]@}$ \r\n${@A[1] B[1]@}$\r\n${@A[2] B[2]@}$ \r\n$.......$     \r\n${@A[M] B[M]@}$\r\n${@L[1] T[1,1]... T[1,L[1]]@}$\r\n${@L[2] T[2,1]... T[2,L[2]]@}$ \r\n$.......$ \r\n${@L[P] T[P,1]... T[P,L[P]]@}$\r\n| numarul de orase, numarul de legaturi si numarul de politisti\r\ncele $N$ costuri de sedere, pentru fiecare oras in parte\r\nlinia ${@A[i] B[i]@}$ semnifica faptul ca exista o legatura directa intre orasele ${@A[i]@}$ si ${@B[i]@}$\r\n&nbsp;&nbsp; &nbsp; &nbsp;primul numar de pe linie indica lungimea traseului de patrulare, dupa care urmeaza descrierea traseului propriu-zis | -|\r\n\r\n\r\nIn total, fisierul de intrare contine M+P+2 linii.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului de iesire $patrol.out$ contine costul minim platit. Se garanteaza ca intotdeauna exista solutie.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 < N &le; 1 024$\r\n* $4 < M &le; 16 000$\r\n* $P &le; 512$\r\n* $2 &le; L[i] < 8$\r\n* Costurile de sedere sunt numere naturale din $[1, 1 600]$\r\n* In orice moment infractorul trebuie sa se deplaseze ( nu poate sta pe loc )\r\n* La costul total se vor calcula si taxele percepute in orasul de plecare si cel de sosire\r\n* Este posibil ca intr-un oras, in acelasi timp, sa fie mai mult de un politist\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. patrol.in |_. patrol.out |_. Explicatii |\r\n| 7 6 1\r\n10 4 9 1 2 5 2\r\n1 2\r\n2 3\r\n2 4\r\n2 6\r\n4 5\r\n6 7\r\n5 7 6 2 4 5\r\n| 34\r\n| Drumul infractorului este 1 2 3 2 6 7. Se observa ca, de exemplu, la timpul 2, infractorul nu poate pleca spre orasul cu numarul 6 pentru ca s-ar intalni pe legatura dintre orasele 2 si 6 cu politistul. In plus, daca ar pleca spre orasul cu numarul 4, el ar fi prins in final de catre politist. |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"patrol\")==',48,''),('problema/noroc','Noroc','2006-11-11 20:32:11','==Include(page=\"template/taskheader\" task_id=\"noroc\")==\r\n\r\nAenag Lurtseam este impatimit al jocurilor de noroc. De data aceasta a gasit un nou joc captivant, si anume $cap$ sau $pajura$. Acesta se joaca in felul urmator: se arunca o moneda in mod repetat, iar la fiecare $cap$ Aenag castiga ${@$@}1$, in timp ce la fiecare $pajura$ pierde ${@$@}1$. Continua sa joace astfel pana cand capitalul sau ajunge la ${@$@}M$ sau pana cand isi pierde toti banii.\r\n\r\nh2. Cerinta\r\n\r\nStiinda ca initial Aenag Lurtseam avea ${@$@}X$, calculati probabilitatea ca acesta sa falimenteze.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare va contine doua numere naturale nenule $X$ si $M$, reprezentand capitalul initial, respectiv capitalul dorit.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire va contine pe prima linie un singur numar real, reprezentand probabilitatea cautata.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; X, M &le; 32.000$\r\n* rezultatul se va afisa rotunjit la $7$ zecimale exacte\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. noroc.in |_. noroc.out |\r\n| 1 2\r\n| 0.5000000 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"noroc\")==',18,''),('problema/nodiv','Nodiv','2006-11-11 17:45:55','==Include(page=\"template/taskheader\" task_id=\"nodiv\")==\r\n\r\nAenag Lurtseam a ajuns in cele din urma la facultate, unde a si primit prima tema. De data aceasta el se confrunta cu o noua problema: primeste un numar natural $N$ si i se cere sa il scrie ca suma de termeni de forma $2^a^3^b^$. Desi tema i s-a parut initial usoara, s-a lovit de o noua constrangere - suma nu trebuie sa contina doi termeni diferiti astfel incat unul sa il divida pe celalalt. De exemplu $15 = 2^1^3^1^ + 2^0^3^2^$ este o descompunere buna, dar $18 = 2^1^3^1^ + 2^2^3^1^$ nu.\r\n\r\nh2. Cerinta\r\n\r\nVa reusi Aenag Lurtseam sa treaca anul fara restante?\r\n\r\nh2. Date de Intrare (fisier: $nodiv.in$)\r\n\r\nPrima linie a fisierului de intrare va contine numarul $T$ de teste, urmat de $T$ linii, fiecare continand cate un numar $N$, numarul ce trebuie descompus.\r\n\r\nh2. Date de Iesire (fisier: $nodiv.out$)\r\n\r\nFisierul de iesire va contine $T$ linii, fiecare avand urmatorul format: un numar $K$ , urmat de $K$ perechi $(a, b)$ reprezentand numarul de termeni din descompunere, respectiv exponentii acelor $K$ termeni.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 2^63^ - 1$\r\n* $1 &le; T &le; 10 000$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. nodiv.in |_. nodiv.out |_. Explicatii  |\r\n| 3\r\n  15\r\n  16\r\n  17\r\n| 2 1 1 0 2\r\n  1 4 0\r\n  2 3 0 0 2\r\n| 15 = 2^1^3^1^ + 2^0^3^2^\r\n  16 = 2^4^3^0^\r\n  17 = 2^3^3^0^ + 2^0^3^2^ |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"nodiv\")==',48,''),('problema/patrol','Patrol','2006-11-11 20:38:11','==Include(page=\"template/taskheader\" task_id=\"patrol\")==\r\n\r\nO tara are $N$ orase si $M$ legaturi directe, bidirectionale, intre aceste orase. Fiecare oras percepe o taxa de sedere cunoscuta. Un infractor porneste din orasul numerotat cu $1$ si doreste sa ajunga in orasul numerotat cu $N$, folosind legaturile existente. Cum lucrurile nu sunt niciodata asa de simple, exista si $P$ politisti care il cauta. Un politist are un traseu de patrulare bine definit. Traseul sau este de fapt un drum simplu ( in care toate orasele sunt distincte ). El va parcurge un drum du-te vino, adica pleaca pe drumul stabilit, dupa care se intoarce pe acelasi drum, etc. De exemplu, daca traseul de patrulare al unui politist este $4 7 5$, el va merge intotdeuna pe $4 7 5 7 4 7 5 7 4...$. Parcurgerea unei legaturi intre oricare doua orase legate direct se realizeaza intr-o unitate de timp, pentru infractor si pentru oricare dintre politisti. Stationarea intr-un oras nu necesita timp suplimentar.\r\nInfractorul porneste din orasul numerotat cu $1$ si doreste sa ajunga in orasul numerotat cu $N$, platind o taxa de sedere minima prin orasele prin care trece, evitand intalnirea cu vreun politist. O intalnire se poate realiza atunci cand infractorul si unul din politisti se afla in acelasi timp in acelasi oras, sau in acelasi timp pe o legatura intre orase. Plecarea din orasul $1$ se realizeaza la momentul $1$, cand toti politistii isi incep patrularea.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine costul total minim de sedere in orase astfel incat sa se indeplineasca conditiile precizate.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $patrol.in$ are urmatoarea structura:\r\n\r\n| $N M P$ \r\n${@C[1] C[2]...C[n]@}$ \r\n${@A[1] B[1]@}$\r\n${@A[2] B[2]@}$ \r\n$.......$     \r\n${@A[M] B[M]@}$\r\n${@L[1] T[1,1]...T[1,L[1]]@}$\r\n${@L[2] T[2,1]...T[2,L[2]]@}$ \r\n$.......$ \r\n${@L[P] T[P,1]...T[P,L[P]]@}$\r\n| numarul de orase, numarul de legaturi si numarul de politisti\r\ncele $N$ costuri de sedere, pentru fiecare oras in parte\r\n&nbsp;\r\n&nbsp;\r\n&nbsp;\r\n&nbsp;\r\n&nbsp;\r\n&nbsp;\r\n\r\nlinia ${@A[i] B[i]@}$ semnifica faptul ca exista o legatura directa intre orasele ${@A[i]@}$ si ${@B[i]@}$\r\nprimul numar de pe linie indica lungimea traseului de patrulare, dupa care urmeaza descrierea traseului propriu-zis | \r\n\r\n\r\nIn total, fisierul de intrare contine M+P+2 linii.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului de iesire $patrol.out$ contine costul minim platit. Se garanteaza ca intotdeauna exista solutie.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 < N &le; 1 024$\r\n* $4 < M &le; 16 000$\r\n* $P &le; 512$\r\n* $2 &le; L[i] < 8$\r\n* Costurile de sedere sunt numere naturale din $[1, 1 600]$\r\n* In orice moment infractorul trebuie sa se deplaseze ( nu poate sta pe loc )\r\n* La costul total se vor calcula si taxele percepute in orasul de plecare si cel de sosire\r\n* Este posibil ca intr-un oras, in acelasi timp, sa fie mai mult de un politist\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. patrol.in |_. patrol.out |\r\n| 7 6 1\r\n10 4 9 1 2 5 2\r\n1 2\r\n2 3\r\n2 4\r\n2 6\r\n4 5\r\n6 7\r\n5 7 6 2 4 5\r\n| 34 |\r\n\r\nh3. Explicatie\r\n\r\nDrumul infractorului este 1 2 3 2 6 7. Se observa ca, de exemplu, la timpul 2, infractorul nu poate pleca spre orasul cu numarul 6 pentru ca s-ar intalni pe legatura dintre orasele 2 si 6 cu politistul. In plus, daca ar pleca spre orasul cu numarul 4, el ar fi prins in final de catre politist.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"patrol\")==',48,''),('problema/note','Note','2006-11-11 17:56:09','==Include(page=\"template/taskheader\" task_id=\"note\")==\r\n\r\nO partitura muzicala este scrisa pe $V$ voci, fiecare voce avand cate $N$ note. Spunem ca un solfegiu se brodeste peste aceasta partitura daca solfegiul are tot lungimea de $N$ note si fiecare din notele solfegiului coincide cu nota de pe pozitia corespunzatoare a partiturii, pe cel putin una dintre voci.\r\nDe exemplu, solfegiul\r\n$mi re la do si fa sol la$\r\nse brodeste partiturii pe $2$ voci cu $8$ note\r\n$mi re do do si fa fa si$\r\n$sol si la do sol mi sol la$\r\n, pentru ca notele $1, 2, 5$ si $6$ din solfegiu sunt cantate conform vocii $I$, iar notele $3, 7$ si $8$ sunt cantate dupa vocea a doua. Se observa ca nota a patra ($do$) este cantata conform ambelor voci.\r\nSpunem ca un solfegiu de o lungime oarecare falseaza in $K$ locuri daca este nevoie de exact $K$ modificari asupra lui pentru a-l face sa se brodeasca peste partitura. O modificare poate fi:\r\n1) Stergerea unei note din solfegiu\r\n2) Adaugarea unei note in solfegiu\r\n3) Inlocuirea unei note in solfegiu.\r\nDe exemplu, solfegiul\r\n$mi re sol do si fa si$\r\nfalseaza in doua locuri, pentru ca trebuie sa modificam nota $sol$ in $la$ si sa inseram inca un $fa$ intre $si$ si $fa$ pentru a-l aduce la forma:\r\n$mi re la do si fa fa si$\r\ncare se brodeste peste partitura.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine daca un solfegiu dat se brodeste peste o partitura data, sau, in caz contrar, care este numarul minim de locuri in care falseaza. Notele vor fi reprezentate prin numere de la $1$ la $100$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $note.in$ va avea urmatoarea structura: pe prima linie se vor afla $V$ si $N$, separate de exact un spatiu, numarul de voci si numarul de note. Urmatoarele $V$ linii contin cate $N$ numere, simbolizand partitura cu $V$ voci si $N$ note pe fiecare voce. Numerele vor fi naturale si intre $1$ si $100$. Linia $V+2$ va contine numarul $M$ de note ale solfegiului. Linia $V+3$ va contine $M$ numere naturale cuprinse in intervalul $[1, 100]$, reprezentand notele solfegiului.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $note.out$ va contine numarul minim de locuri in care solfegiul falseaza, in functie de partitura data. Daca solfegiul se brodeste peste partitura numarul afisat va fi $0$.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; V &le; 512$\r\n* $1 &le; M, N &le; 1024$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. note.in |_. note.out |_. Explicatii  |\r\n| 2 8\r\n  3 2 1 1 7 4 4 7\r\n  5 7 6 1 5 3 5 6\r\n  7\r\n  3 2 5 1 7 4 7\r\n| 2\r\n| Nota a 3a din solfegiu se va inlocui cu 1 sau cu 6, iar intre ultimele doua note se va adauga una din notele 4 sau 5. |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"note\")==',48,''),('problema/petsoft','PetSoft','2006-11-11 20:43:55','==Include(page=\"template/taskheader\" task_id=\"petsoft\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nPetrica detine o companie de software numita PETSOFT cu care este lider in domeniu. Secretul succesului sta in modul de organizare interna din aceasta firma. Fiecare angajat are asociat un numar distinct de la $1$ la $N$ si se stie pentru fiecare angajat cine este seful sau direct (angajatul numarul $1$ este chiar Petrica si nu are nici un sef). Mai exact relatiile dintre angajatii firmei formeaza un arbore cu radacina in nodul $1$. Firma este invitatata la un targ international de software unde isi va prezenta oferta. La conferinta se vor prezenta din partea firmei un numar de echipe (stabilit de Petrica) de cate doi angajati. Petrica nu este interasat de numarul de echipe ci de valoarea lor. Pentru asta el stabileste urmatoarele regula: angajatii $x$ si $y$ pot fi trimisi la conferinta impreuna daca $x$ este seful direct al lui $y$ sau daca $x$ si $y$ au acelasi sef iar valoarea echipei formate din cei doi este $|x - y|$. De asemenea este stiut faptul ca Petrica (angajatul numarul {$1$}) nu va fi incadrat in nici o echipa, el fiind managerul firmei. Valoarea totala e echipelor va fi suma valorilor tuturor echipelor.\r\n\r\nh2. Cerinta\r\n\r\nSe cauta un programator capabil sa stabileasca modul de formare a echipelor astfel incat valoarea totala a echipelor sa fie maxima. Odata gasit, el va fi angajat direct intr-un loc de frunte in ierarhia firmei. Poti fi chiar tu acel programator, dar trebuie sa demostrezi ca esti alegerea buna dezvoltand un program care poate calcula valoarea totala maxima a echipelor pe care firma le va trimite la conferinta.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie in fisierul de intrare $petsoft.in$ se afla un numar intreg $N$ reprezentand numarul de angajati ai firmei. Pe urmatoarele $N-1$ linii sunt date informatiile cu privire la ierhia firmei: pe linia $i$ se afla seful angajatului cu numarul $i$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie din fisierul de iesire petsoft.out se va gasi un numar intreg reprezentand valoarea totala maxima a echipelor ce vor fi trimise la conferinta.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 1000$\r\n* Fiecare angajat poate fi incadrat in maxim o echipa.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. petsoft.in |_. petsoft.out |\r\n| 5\r\n1\r\n4\r\n2\r\n4\r\n| 4 |\r\n\r\nh3. Explicatii\r\n\r\nSe vor forma echipele 2-4 si 3-5.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"petsoft\")==',15,''),('arhiva','Arhiva de probleme, pregatire pentru concursuri de informatica','2006-11-11 20:47:01','==Include(page=\"template/roundheader\" round_id=\"arhiva\")==\r\n\r\n==TableOfContents(context=\"round/arhiva\" prefix=\"task/\")==\r\n\r\np. %{color:red}Reverse% %{color:blue}textile% %{color:green}here.%\r\n==Include(page=\"template/roundfooter\" round_id=\"arhiva\")==',1,''),('problema/oras','Oras','2006-11-11 20:49:09','==Include(page=\"template/taskheader\" task_id=\"oras\")==\r\n\r\nCum este sezonul in care se lucreaza intens la drumurile tarii, primarul unui oras oarecare va cere sa il ajutati la marcarea tuturor straziler din orasul sau cu sensuri unice. Exista $N$ intersectii in oras numerotate de la $1$ la $N$ si oricare doua intersectii din acest oras sunt unite de o strada.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati un sens unic pentru fiecare strada astfel ca pentru orice doua numere $x$ si $y$ ($1 &le; x,y &le; N$) sa existe un drum care traverseaza cel mult doua strazi pentru a ajunge de la intersectia $x$ la intersectia $y$.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $oras.in$ va contine pe prima linie un numar intreg ce reprezinta valoarea lui $N$.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $oras.out$ va contine exact $N$ linii. Fiecare linie va contine exact $N$ caractere. Caracterul $j$ al liniei $i$ va fi $\'1\'$, daca sensul strazii dintre $i$ si $j$ este de la $i$ la $j$, daca nu, acest caracter va fi $\'0\'$ . Caracterul $i$ al liniei $i$ va fi intotdeauna $\'0\'$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; N &le; 200$\r\n* In cazul in care nu exista solutie veti afisa $-1$;\r\n* Daca exista mai multe solutii puteti afisa oricare din ele.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. oras.in |_. oras.out |\r\n| 3\r\n| 010\r\n  001\r\n  100 |\r\n\r\nh3. Explicatii\r\n\r\nO solutie pentru N=3 se obtine orientand astfel strazile 1->2 , 2->3 , 3->1 . Ajungem de la 1 la 2 folosind strada 1->2 , de la 1 la 3 folosind strazile 1->2 , 2->3 , de la 2 la 1 folosim strazile 2->3 , 3->1 , de la 2 la 3 folosind strada 2->3 , de la 3 la 1 folosind strada 3->1 , de la 3 la 2 folosind strazile 3->1 , 1->2 .\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"oras\")==',48,''),('problema/sumdiv','Suma divizorilor','2006-11-11 11:23:50','==Include(page=\"template/taskheader\" task_id=\"sumdiv\")==\n\n==Include(page=\"template/raw\")==\n\nSuma divizorilor\n\n\n\nSe considera doua numere naturale A si B. Fie S suma tuturor divizorilor naturali ai lui A^B (A la puterea B).\n\nh2. Cerinta\n\nSa se afiseze restul impartirii lui S la 9901.\n\nh2. Date de Intrare\n\nPe prima linie a fisierului de intrare sumdiv.in sunt scrise cele doua numere A si B, separate prin cel putin un spatiu.\n\nh2. Date de Iesire\n\nPrima linie a fisierului sumdiv.out va contine restul impartirii lui S la 9901.\n\nh2. Restrictii\n\n&#159; 0 -L- A,B -L- 50 000 000 (cincizeci de milioane)\n\nh2. Exemplu\n\n\n|sumdiv.in |sumdiv.out |Explicatie |\n\n|2 3 |15 |2^3 = 8. |\n| | | |\n| | |Divizorii naturali ai lui 8 sunt: 1,2,4,8. Suma lor este 15. |\n| | | |\n| | |Restul impartirii lui 15 la 9901 este 15 (care trebuie sa apara in fisierul de iesire). |\n| | | |\n| | | |\n\n\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"sumdiv\")==',0,''),('problema/bifo','Bifo','2006-11-11 16:15:42','==Include(page=\"template/taskheader\" task_id=\"bifo\")==\r\n\r\nPentru a-si vindeca rana provocata de Spanul cel Negru, printul Algorel are nevoie de leacul miraculos aflat in posesia vrajitoarei din padurea intunecata. Aceasta i-a promis leacul daca ii rezolva urmatoarea problema, la care ea s-a gandit zadarnic o mie de ani: pornind de la doua cuvinte initiale $A{~1~}$ si $A{~2~}$ si aplicand \"formula bifo\" $A{~n~} = A{~n-2~}A{~n-1~}$ pentru {$3 &le; n$}, se obtin cuvintele $A{~3~}, A{~4~}, A{~5~}$ s.a.m.d. Prin $A{~n-2~}A{~n-1~}$ intelegem concatenarea cuvintelor $A{~n-2~}$ si $A{~n-1~}$ in aceasta ordine. Toate aceste cuvinte ({$A{~1~} A{~2~}, A{~3~} A{~4~}, A{~5~}$} s.a.m.d), sunt la randul lor concatenate, in ordine, formand un sir de caractere infinit denumit sir magic. Formula leacului miraculos are $M$ caractere, pe care vrajitoarea nu le stie. Se stiu insa cele $M$ pozitii din sirul magic in care apar, in ordine, caracterele din formula.\r\n\r\nh2. Cerinta\r\n\r\nCu toata inteligenta lui, Algorel nu poate rezolva aceasta problema. Ajutati-l pe print sa iasa din incurcatura afland formula leacului magic.\r\n\r\nh2. Date de Intrare\r\n\r\nPrimele doua linii ale fisierului $bifo.in$ contin fiecare cate un sir de cel mult $100$ de caractere reprezentand cuvintele $A{~1~}$ (pe prima linie) si respectiv $A{~2~}$ (pe a doua linie). A treia linie contine un numar intreg {$M$}, reprezentand numarul de caractere din formula leacului miraculos. Urmeaza $M$ linii descriind, in ordine, pozitiile din sirul magic unde se gasesc caracterele din formula.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bifo.out$ va contine pe prima linie un sir de $M$ caractere reprezentand formula leacului miraculos.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; M &le; 100$\r\n* $A{~1~}$ si $A{~2~}$ contin doar litere mici ale alfabetului englez\r\n* Numerotarea pozitiilor din sirul infinit incepe cu $1$\r\n* Cele $M$ pozitii vor fi numere intregi (nu neaparat distincte) de maxim $100$ de cifre\r\n* Pentru $60%$ din teste pozitiile vor fi numere intregi intre $1$ si $1.000.000.000$\r\n* Fiecare linie din fisierul de intrare si din fisierul de iesire se termina cu marcaj de sfarsit de linie\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bifo.in |_. bifo.out |_. Explicatii |\r\n| ab\r\ncdx\r\n3\r\n10\r\n4\r\n15\r\n| xdb\r\n| Primele 5 siruri de caractere ob&#254;inute folosind formula bifo sunt:\r\n*ab, cdx, abcdx, cdxabcdx, abcdxcdxabcdx*\r\nConcatenand aceste siruri se ob&#254;ine sirul magic:\r\n{*abcdxabcdxcdxabcdxabcdxcdxabcdx*}... |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bifo\")==',961,''),('sandbox','Sandbox','2006-11-11 19:04:05','|_=. De la macro: ==Hello(target=\"World\")==     Un link:   \"hai acasa\":home |',13,''),('sandbox','Sandbox','2006-11-11 22:05:40','\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n',13,''),('problema/munte','Munte','2006-11-11 22:18:52','==Include(page=\"template/taskheader\" task_id=\"munte\")==\r\n\r\nGheorghe vrea sa cucereasca un munte. El are anumite informatii despre munte. Stie cat de inalt este muntele si care e distanta pana la celaltalta parte a muntelui. El mai are si o lista cu puncte speciale prin care trebuie sa treaca, despre acest puncte stie inaltimea lor si ordinea in care apar, nu stie distanta dintre aceste puncte. Muntele este format din $3$ tipuri de teren.\r\n\r\n* Tipul 1: teren crescator, unde muntele creste un metru pe verticala pentru fiecare metru pe orizontala.\r\n* Tipul 2: teren drept. Pe acesta portiune terenul nici nu urca nici nu coboara.\r\n* Tipul 3: teren descrescator , unde muntele scade un metru pe verticala pentru fiecare metru pe orizontala.\r\n\r\nh2. Cerinta\r\n\r\nGheorghe avand toate aceste informati, $N$ (inaltimea maxima a munteleui, presupunand ca muntele incepe la nivelul $0$ si se termina la nivelul $0$), $D$ - distanta pe orizontala a muntelui si inaltimea la fiecare punct special, vrea sa stie cate posibilitati are de a parcurge muntele.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie din fisierul $munte.in$ se va afla numarul $N$ - inaltimea maxima a muntelui, $D$ - distanta pe orizontala a muntelui si $K$ - numarul de puncte speciale.\r\nPe urmatoarele $K$ linii sunt scrise inaltimile punctelor speciale\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului $munte.out$ se va gasi $P$ - numarul de posibilitati de a traversa muntele.\r\n\r\nObservatii\r\n\r\n* Gheoghe incepe la nivelul $0$ si trebuie sa termine la nivelul $0$\r\n* Doar incepul si sfasitul au nivelul $0$!\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 50$\r\n* $1 &le; D &le; 100$\r\n* $0 &le; K &le; 50$\r\n* $0 &le; P &le; 2^63^-1$\r\n\r\nExemple\r\n\r\ntable(example). |_. munte.in |_. munte.out |_. Explicatii  |\r\n| 2 5 0\r\n| 3\r\n| Cele 3 posibilitati diferite sunt:\r\n  !http://www.infoarena.ro/task/munte?action=download&file=img1.jpg!\r\n  !http://www.infoarena.ro/task/munte?action=download&file=img2.jpg!\r\n  nu este o parcurgere valida pentru ca inaltimea muntelui nu este 2, ci 1 |\r\n| 2 5 2 \r\n  2\r\n  2\r\n| 1\r\n| !http://www.infoarena.ro/task/munte?action=download&file=img3.jpg!\r\n  Singura parcurgere posibila este cea de sus |\r\n| 3 8 4\r\n  2\r\n  2\r\n  3\r\n  1 \r\n| 7 | &nbsp; |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"munte\")==',961,''),('problema/evantai','Evantai','2006-11-11 22:28:56','==Include(page=\"template/taskheader\" task_id=\"evantai\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nLui Algorel ii plac mult sirurile de numere naturale cu proprietati cat mai ciudate. Cautand astfel de ciudatenii ale informaticii, a gasit printr-o carte prafuita de vreme un nou tip de sir denumit evantai. Un evantai este un sir cu un numar par de termeni, $E{~1~} E{~2~} ... E{~2K~}$, cu urmatoarea proprietate:\r\n\r\np=. $E{~1~} + E{~2K~} > E{~2~} + E{~2K-1~} > ... > E{~K~} + E{~K+1~}$\r\n\r\nh2. Cerinta\r\n\r\nFiind dat un sir de numere naturale distincte $A{~1~} A{~2~} ... A{~N~}$, Algorel vrea sa afle cate subsiruri ale acestuia sunt evantaie.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului $evantai.in$ contine numarul intreg $N$, reprezentand numarul de elemente ale sirului. Urmatoarele $N$ linii contin, in ordine, elementele sirului $A$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $evantai.out$ se va afla un singur numar intreg $C$, reprezentand numarul de subsiruri evantai. Rezultatul va fi afisat modulo $30103$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 700$\r\n* Elementele sirului sunt numere intregi distincte cuprinse intre $1$ si $1000$\r\n* Prin subsir se intelege orice insiruire de termeni $A{~i1~} A{~i2~} ... A{~ik~}$ astfel incat $i{~1~} < i{~2~} < ... < i{~k~}$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. evantai.in |_. evantai.out | \r\n| 4\r\n1\r\n2\r\n3\r\n6 | 7 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"evantai\")==',15,''),('problema/ben','Ben','2006-11-11 16:04:35','==Include(page=\"template/taskheader\" task_id=\"ben\")==\r\n\r\nLa o benzinarie sosesc intr-o zi $N$ masini pentru a se alimenta. Pentru fiecare masina se cunoaste momentul sosirii si momentul plecarii din benzinarie, intervalul de timp dintre sosire si plecare fiind utilizat exclusiv pentru alimentare. O pompa de benzina se poate utiliza pentru alimentarea unei singure masini la un moment dat (ea poate sa alimenteze mai multe masini dar nu in acelasi timp). Alimentarea unei masini incepe exact in momentul sosirii ei in benzinarie si se termina exact in momentul plecarii, fiind utilizata o singura pompa pe tot timpul parcarii sale in benzinarie.\r\n\r\nh2. Cerinta\r\n\r\nStiind informatiile despre sosirile si plecarile celor $N$ clienti, aflati $K$ reprezentand numarul minim de pompe de benzina necesare servirii tuturor clientilor. Se cere si numarul de modalitati distincte de servire a clientilor utilizand exact $K$ pompe de alimentare.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul $ben.in$ se afla pe prima linie un numar $N$ reprezentand numarul de clienti. Urmeaza $N$ linii fiecare continand doua numere, $A$ si $B$ ({$A<B$}), separate printr-un spatiu reprezentand timpul de sosire respectiv timpul de plecare al unui client.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $ben.out$ va contine o singura linie pe care se vor afla doua numere intregi $K$ si $S$ reprezentand numarul minim de pompe de alimentare si numarul de modalitati de servire a clientilor folosind exact $K$ pompe de alimentare. Numarul $S$ va fi afisat modulo {$32173$}.\r\n\r\nh2. Restrictii\r\n\r\n* {$0 &le; N &le; 30 000$}, dar pentru $70%$ din teste $N &le; 300$\r\n* Timpii de sosire si plecare vor fi numere intregi din intervalul [{$1, 30 000$}]\r\n* Nu va exista o masina care soseste in momentul pleacarii altei masini\r\n* Daca primul numar din fisierul de iesire este corect veti primi $6$ puncte pe acel test iar daca sunt corecte ambele numere veti primi $10$ puncte. Nu se vor acorda puncte daca este corect numai cel de-al doilea numar.\r\n* Doua modalitati de servire a clientilor se considera diferite daca exista cel putin un client care nu a fost servit la aceeasi pompa in cele doua modalitati\r\n* Clientilor nu le place sa astepte asa ca trebuie sa va asigurati ca exista cel putin o pompa libera la sosirea fiecaruia in benzinarie\r\n* Atentie! Numarul Sse va afisa modulo $32173$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. ben.in |_. ben.out |_. Explicatii |\r\n| 4\r\n1 4\r\n5 7\r\n8 10\r\n2 7\r\n| 2 4\r\n| Numarul minim de pompe de alimentare este 2.\r\nCele 4 modalitati de servire ale clientilor sunt:\r\n1, 1, 1, 2 (prima modalitate) \r\n1, 1, 2, 2 (a doua)\r\n2, 2, 1, 1 (a treia)           \r\n2, 2, 2, 1 (a patra)\r\nFiecare numar reprezinta indicele pompei la care s-a alimentat fiecare client, pastrand ordinea acestora din fisierul de intrare. |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"ben\")==',961,''),('problema/cowfood','Cowfood','2006-11-11 22:40:26','==Include(page=\"template/taskheader\" task_id=\"cowfood\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nCercetatorii nutritionisti fac experimente asupra amestecului optim de ierburi cu care pot fi hranite vacile. Au adunat K feluri de plante diferite si le-au amestecat, obtinand formule reprezentate prin vectori de forma ({$a{~1~}, a{~2~}, .. a{~k~}$}) unde a{~i~} reprezinta cantitatea de plante de tipul $i$ folosita in mixtura. Se stie ca pentru orice amestec valid, $a{~1~} + a{~2~} + ... + a{~k~}$ nu depaseste niciodata o valoare data {$S$}. Toate experimentele desfasurate au esuat insa, deoarece vacile nu au agreat cantitatile de ierburi din amestecurile testate. Mai mult, cercetatorii si-au dat seama ca pentru orice experiment ratat de forma ({$a{~1~}, a{~2~}, .. a{~k~}$}) , un experiment ({$b{~1~}, b{~2~}, .. b{~k~}$}) cu $a{~1~} &le; b{~1~}, a{~2~} &le; b{~2~}, ... a{~k~} &le; b{~k~}$ va esua de asemenea.\r\n\r\nh2. Cerinta\r\n\r\nFiindca cercetatorii vor sa termine lucrul cat mai curand posibil, este datoria ta sa afli cate experimente care mai au sanse de a se incheia cu succes au ramas.\r\n\r\nh2. Date de Intrare\r\n\r\nLinia $1$ a fisierului de intrare $cowfood.in$ contine trei numere naturale {$K$}, $S$ si {$N$}.\r\nLiniile $2 .. N + 1$ contin cate $K$ numere ({$a{~1~}, a{~2~}, .. a{~k~}$}) ce reprezinta cate un experiment despre care se stie sigur ca a dat gres.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $cowfood.out$ va contine pe prima linie numarul de amestecuri ramase care mai au inca sanse de a fi agreate de vaci modulo {$3210121$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; K &le; 30$\r\n* $2 &le; S &le; 10.000$\r\n* $0 &le; N &le; 20$\r\n* orice mixtura valida contine cel putin doua cantitati nenule de ierburi diferite\r\n* toate valorile date in fisierul de intrare se incadreaza in tipuri intregi pe $16$ biti\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. cowfood.in |_. cowfood.out |_. Explicatii |\r\n| 2 5 2\r\n1 3\r\n3 1\r\n| 4\r\n| Cele 4 amestecuri care mai pot fi incercate sunt (1, 1), (1, 2), (2, 1), (2, 2) |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"cowfood\")==',961,''),('sandbox2','Sandbox2','2006-11-11 22:20:59','   \r\n',13,''),('problema/cifru','Secretul Cifrului','2006-11-11 11:23:54','==Include(page=\"template/taskheader\" task_id=\"cifru\")==\n\n==Include(page=\"template/raw\")==\n\nSecretul cifrului\n\nUn criptolog amator isi propune sa construiasca o masina de cifrat care sa cripteze un text alcatuit din exact N simboluri distincte. Cifrarea se realizeaza prin permutarea simbolurilor ce formeaza textul.\n\nCriptologul nostru doreste ca reconstituirea textului initial sa poata fi realizata trecand textul cifrat inca de K-1 ori prin procedura de cifrare. Cu alte cuvinte, daca textul rezultat din prima cifrare este cifrat inca o data, rezultatul este cifrat din nou si asa mai departe, plecand de la textul initial si aplicand in total K operatii de cifrare successive, trebuie sa obtina textul initial.\n\nCriptologul nostru ar vrea sa afle, cunoscand N si K, numarul de moduri distincte in care poate fi realizata masina de cifrat. Doua moduri de realizare a masinii difera daca, exista cel putin un text in urma cifrarii caruia, in cele doua texte obtinute exista cel putin o pozitie in care se afla simboluri diferite.\n\nh2. Cerinta\n\nScrieti un program care determina restul impartirii numarului de moduri distincte in care poate fi realizata masina de cifrat la 19997.\n\nh2. Date de Intrare\n\nFisierul cifru.in contine pe prima (si singura) linie, doua valori numerice naturale separate printr-un spatiu, N si K (cu semnificatia din enunt)\n\nh2. Date de Iesire\n\nFisierul cifru.out va contine pe prima linie, numarul de moduri distincte de realizare a masinii de cifrat modulo 19997.\n\nh2. Restrictii\n\n\n\nS 1 <= N <= 2000; 2 <= K <= 1000000000\n\nS pentru 30% din teste N,K < 13\n\nS pentru 50% din teste N,K <= 100\n\n\n\nExemple\n\n\n|Exemplul 1: |cifru.in |cifru.out |\n| \n| |3 3 |3 |\n\n|Exemplul 2: |cifru.in |cifru.out |\n| \n| |9 6 |11560 |\n\n|Exemplul 3: |cifru.in |cifru.out |\n| \n| |100 200 |13767 |\n\n==Include(page=\"template/taskfooter\" task_id=\"cifru\")==',0,''),('problema/reg','Reg','2006-11-11 11:23:47','==Include(page=\"template/taskheader\" task_id=\"reg\")==\n\n==Include(page=\"template/raw\")==\n\nReg\n\n\n\nAlgostorm a inceput sa programeze satelitii intergalactici intr-un limbaj de programare denumit SuperP++ . Un program in SuperP++ consta dintr-o serie de instructiuni (numele acestor instructiuni sunt niste numere intregi) care trebuiesc executate in ordine. Pentru a fi executata, o instructiune trebuie citita din registri (acestia sunt in numar de K si fiecare registru poate retine cel mult o instructiune la un moment dat). Daca o instructiune nu exista in registri, aceasta trebuie incarcata inainte de a fi executata. O instructiune poate fi incarcata intr-un registru gol sau intr-un registru folosit caz in care instructiunea curenta este stearsa din registru (pentru eliberarea acestuia). Odata stearsa, o instructiune nu mai poate fi incarcata in nici un registru si la intalnirea ei in executarea programului acesta se intrerupe.\n\nh2. Cerinta\n\nAlgostorm a scris un program compus din N instructiuni. Stiind numarul de registri, K , aflati care este numarul maxim de instructiuni din programul lui Algostorm care pot fi executate pana la intreruperea lui, respectand regulile de incarcare si citire.\n\nh2. Date de Intrare\n\nIn fisierul reg.in se afla pe prima linie un numar T reprezentand numarul de teste care vor urma. Pe urmatoarele T linii se afla cate 5 numere: A , B , C , N , K . Programul lui Algostorm va fi descris de urmatoarele relatii ( Xi fiind instructiunea cu numarul i , i=1..N )\n\nX1=1, Xi=(Xi-1 * A + B * i) mod C pentru i=2..N\n\nh2. Date de Iesire\n\nFisierul de iesire reg.out va contine T linii: pentru fiecare test se va afisa pe cate o linie numarul maxim de instructiuni din programul lui Algostorm care pot fi executate utilizand exact K registri.\n\nh2. Restrictii si precizari\n\n. 1 <= N <= 2.000.000\n\n. 1 <= T <= 10\n\n. 1 <= A, B, C, K <= 500.000\n\n. C este mereu prim\n\n. suma numarului de instructiuni ale tuturor programelor dintr-un fisier de intrare nu va depasi 4.000.000\n\n. Pentru 70% din fisierele de intrare N <= 400.000\n\n. Instructiunile se vor executa in ordine, de la 1 catre N\n\n. In timpul concursului s-a impus o limita de memorie de 7MB pentru segmentul de date si 1MB pentru stiva.\n\nh2. Exemplu\n\n\n|reg.in |reg.out |\n\n|2 |3 |\n|1 1 7 5 1 |6 |\n|2 3 5 8 2 | |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"reg\")==',0,''),('problema/robotei','Robotei','2006-11-11 23:16:57','==Include(page=\"template/taskheader\" task_id=\"robotei\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nIn fiecare celula a unui caroiaj de dimensiuni $NxN$ se afla plasat cate un robotel. Coltul din stanga sus al caroiajului are coordonatele ({$0$}, {$0$}) iar cel din dreapta jos ({$N-1$}, {$N-1$}). Roboteii sunt programati sa se miste, in fiecare secunda, dupa urmatoarea regula:\r\n\r\np=. $newX{~i~} = (oldX{~i~}^2^ + offsetX) modulo modX$\r\n\r\np=. $newY{~i~} = (oldY{~i~}^2^ + offsetY) modulo modY$,\r\n\r\n\r\nunde ({$oldX{~i~}, oldY{~i~}$}) reprezinta pozitia veche a robotelului $i$ (modul de numerotare al roboteilor nu este important) si ({$newX{~i~}, newY{~i~}$}) noua lui pozitie; $offsetX$, $offsetY$, $modX$ si $modY$ sunt comune regulilor de miscare ale roboteilor.\r\n\r\nh2. Cerinta\r\n\r\nStiind ca fiecare robotel va efectua $M$ mutari, aflati cati roboti trec prin pozitia ({$X$}, {$Y$}) de $n$ ori, pentru fiecare $n$ intre $0$ si $M$.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare va contine $6$ numere intregi separate de spatii: $N$, $M$, $X$, $Y$, $modX$, $modY$, $offsetX$ si respectiv $offsetY$ cu semnificatiile din enunt.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire va contine cate o linie pentru fiecare $n$ cate doi intregi, $n$ si $C{~n~}$ cu semnificatia: \"$C{~n~}$ robotei trec prin pozitia ({$X$}, {$Y$}) de exact $n$ ori\". Perechile de numere vor fi afisate in ordine crescatoare dupa $n$ si vor fi afisate doar cele pentru care $C{~n~}$ este diferit de $0$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Toate numerele din fisierul de intrare sunt intregi din intervalul $[0, 1.000.000]$\r\n* Aceasta problema va fi testata cu $10$ de teste, fiecare valorand cate $10$ puncte. Valorile utilizate in teste pentru $N$, $M$, $modX$ si $modY$ se regasesc in tabelul de mai jos.\r\n* Pe parcurs, o celula poate contine mai multi robotei.\r\n\r\n\r\n|_. Test | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\r\n|_. N | 20 | 33 | 61 | 43139 | 83 | 504 | 32668 | 906 | 1523 | 44339 |\r\n|_. M | 1000 | 2100 | 400745 | 337654 | 237891 | 367398 | 500000 | 325000 | 476388 | 666732 |\r\n|_. modX | 13 | 31 | 40 | 54 | 72 | 270 | 561 | 877 | 997 | 997 |\r\n|_. modY | 19 | 29 | 50 | 65 | 69 | 256 | 437 | 809 | 991 | 1000 |\r\n\r\nh2. Exemplu\r\n\r\n\r\n|robotei.in |robotei.out|Explicatii |\r\n\r\n|3 4 1 2 2 3 1 1|1 2 |Sunt 3 x 3 = 9 robotei. Robotelul situat in celula (3|\r\n| | |2) va avea urmatorul parcurs: (3 2) -> (0 2) -> (1 2)|\r\n| |2 6 |-> (0 2) -> (1 2). In consecinta, el trece de 2 ori|\r\n| | |prin pozitia (1 2). |\r\n| |3 1 | |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"robotei\")==',15,''),('problema/robotei','Robotei','2006-11-11 23:22:36','==Include(page=\"template/taskheader\" task_id=\"robotei\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nIn fiecare celula a unui caroiaj de dimensiuni $NxN$ se afla plasat cate un robotel. Coltul din stanga sus al caroiajului are coordonatele ({$0$}, {$0$}) iar cel din dreapta jos ({$N-1$}, {$N-1$}). Roboteii sunt programati sa se miste, in fiecare secunda, dupa urmatoarea regula:\r\n\r\np=. $newX{~i~} = (oldX{~i~}^2^ + offsetX) modulo modX$\r\n\r\np=. $newY{~i~} = (oldY{~i~}^2^ + offsetY) modulo modY$,\r\n\r\n\r\nunde ({$oldX{~i~}, oldY{~i~}$}) reprezinta pozitia veche a robotelului $i$ (modul de numerotare al roboteilor nu este important) si ({$newX{~i~}, newY{~i~}$}) noua lui pozitie. $offsetX$, $offsetY$, $modX$ si $modY$ sunt comune regulilor de miscare ale roboteilor.\r\n\r\nh2. Cerinta\r\n\r\nStiind ca fiecare robotel va efectua $M$ mutari, aflati cati roboti trec prin pozitia ({$X$}, {$Y$}) de $n$ ori, pentru fiecare $n$ intre $0$ si $M$.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului de intrare va contine $6$ numere intregi separate de spatii: $N$, $M$, $X$, $Y$, $modX$, $modY$, $offsetX$ si respectiv $offsetY$ cu semnificatiile din enunt.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire va contine cate o linie pentru fiecare $n$ cate doi intregi, $n$ si $C{~n~}$ cu semnificatia: \"$C{~n~}$ robotei trec prin pozitia ({$X$}, {$Y$}) de exact $n$ ori\". Perechile de numere vor fi afisate in ordine crescatoare dupa $n$ si vor fi afisate doar cele pentru care $C{~n~}$ este diferit de $0$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Toate numerele din fisierul de intrare sunt intregi din intervalul $[0, 1.000.000]$\r\n* Aceasta problema va fi testata cu $10$ de teste, fiecare valorand cate $10$ puncte. Valorile utilizate in teste pentru $N$, $M$, $modX$ si $modY$ se regasesc in tabelul de mai jos.\r\n* Pe parcurs, o celula poate contine mai multi robotei.\r\n\r\n\r\n|_. Test | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |\r\n|_. N | 20 | 33 | 61 | 43139 | 83 | 504 | 32668 | 906 | 1523 | 44339 |\r\n|_. M | 1000 | 2100 | 400745 | 337654 | 237891 | 367398 | 500000 | 325000 | 476388 | 666732 |\r\n|_. modX | 13 | 31 | 40 | 54 | 72 | 270 | 561 | 877 | 997 | 997 |\r\n|_. modY | 19 | 29 | 50 | 65 | 69 | 256 | 437 | 809 | 991 | 1000 |\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. robotei.in |_. robotei.out |\r\n| 3 4 1 2 2 3 1 1\r\n| 1 2\r\n2 6\r\n3 1 |\r\n\r\nh3. Explicatii\r\n\r\nSunt 3 x 3 = 9 robotei. Robotelul situat in celula (3 2) va avea urmatorul parcurs: (3 2) -> (0 2) -> ({$1 2$}) -> (0 2) -> ({$1 2$}). In consecinta, el trece de 2 ori prin pozitia ({$1 2$}).\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"robotei\")==',15,''),('problema/patrol','Patrol','2006-11-11 21:04:21','==Include(page=\"template/taskheader\" task_id=\"patrol\")==\r\n\r\nO tara are $N$ orase si $M$ legaturi directe, bidirectionale, intre aceste orase. Fiecare oras percepe o taxa de sedere cunoscuta. Un infractor porneste din orasul numerotat cu $1$ si doreste sa ajunga in orasul numerotat cu $N$, folosind legaturile existente. Cum lucrurile nu sunt niciodata asa de simple, exista si $P$ politisti care il cauta. Un politist are un traseu de patrulare bine definit. Traseul sau este de fapt un drum simplu ( in care toate orasele sunt distincte ). El va parcurge un drum du-te vino, adica pleaca pe drumul stabilit, dupa care se intoarce pe acelasi drum, etc. De exemplu, daca traseul de patrulare al unui politist este $4 7 5$, el va merge intotdeuna pe $4 7 5 7 4 7 5 7 4...$. Parcurgerea unei legaturi intre oricare doua orase legate direct se realizeaza intr-o unitate de timp, pentru infractor si pentru oricare dintre politisti. Stationarea intr-un oras nu necesita timp suplimentar.\r\nInfractorul porneste din orasul numerotat cu $1$ si doreste sa ajunga in orasul numerotat cu $N$, platind o taxa de sedere minima prin orasele prin care trece, evitand intalnirea cu vreun politist. O intalnire se poate realiza atunci cand infractorul si unul din politisti se afla in acelasi timp in acelasi oras, sau in acelasi timp pe o legatura intre orase. Plecarea din orasul $1$ se realizeaza la momentul $1$, cand toti politistii isi incep patrularea.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine costul total minim de sedere in orase astfel incat sa se indeplineasca conditiile precizate.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $patrol.in$ are urmatoarea structura:\r\n\r\ntable(example). | $N M P$ \r\n${@C[1] C[2]...C[n]@}$ \r\n${@A[1] B[1]@}$\r\n${@A[2] B[2]@}$ \r\n$.......$     \r\n${@A[M] B[M]@}$\r\n${@L[1] T[1,1]...T[1,L[1]]@}$\r\n${@L[2] T[2,1]...T[2,L[2]]@}$ \r\n$.......$ \r\n${@L[P] T[P,1]...T[P,L[P]]@}$\r\n| numarul de orase, de legaturi si de politisti\r\ncosturile de sedere, pentru fiecare oras in parte\r\nlinia ${@A[i] B[i]@}$ semnifica faptul ca exista o\r\nlegatura directa intre orasele ${@A[i]@}$ si ${@B[i]@}$\r\nprimul numar de pe linie indica lungimea\r\ntraseului de patrulare, dupa care urmeaza\r\ndescrierea traseului propriu-zis | \r\n\r\n\r\nIn total, fisierul de intrare contine M+P+2 linii.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie a fisierului de iesire $patrol.out$ contine costul minim platit. Se garanteaza ca intotdeauna exista solutie.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 < N &le; 1 024$\r\n* $4 < M &le; 16 000$\r\n* $P &le; 512$\r\n* $2 &le; L[i] < 8$\r\n* Costurile de sedere sunt numere naturale din $[1, 1 600]$\r\n* In orice moment infractorul trebuie sa se deplaseze ( nu poate sta pe loc )\r\n* La costul total se vor calcula si taxele percepute in orasul de plecare si cel de sosire\r\n* Este posibil ca intr-un oras, in acelasi timp, sa fie mai mult de un politist\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. patrol.in |_. patrol.out |\r\n| 7 6 1\r\n10 4 9 1 2 5 2\r\n1 2\r\n2 3\r\n2 4\r\n2 6\r\n4 5\r\n6 7\r\n5 7 6 2 4 5\r\n| 34 |\r\n\r\nh3. Explicatie\r\n\r\nDrumul infractorului este 1 2 3 2 6 7. Se observa ca, de exemplu, la timpul 2, infractorul nu poate pleca spre orasul cu numarul 6 pentru ca s-ar intalni pe legatura dintre orasele 2 si 6 cu politistul. In plus, daca ar pleca spre orasul cu numarul 4, el ar fi prins in final de catre politist.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"patrol\")==',13,''),('problema/timbre','Timbre','2006-11-11 11:23:48','==Include(page=\"template/taskheader\" task_id=\"timbre\")==\n\n==Include(page=\"template/raw\")==\n\nTimbre\n\n\n\nDupa cum stiti cu totii, Adriana este o mare colectionara de timbre. In fiecare zi se duce la magazinul de pe strada ei pentru a-si mari colectia. Intr-o zi, vanzatorul (nimeni altul decat Balaurul Arhirel) s-a gandit sa-i faca o surpriza. A scos dintr-un dulap vechi niste timbre foarte valoroase pe care erau scrise cu fir de aur si de argint numere naturale. Stiind ca fetita n-are bani prea multi, Balaurul i-a spus urmatoarele: \"Eu pot sa impart timbrele in M intervale de forma [1,..,mi]. Tu poti sa iei din orice interval o singura subsecventa de maxim K elemente. Desigur, daca ai ales o subsecventa din intervalul i vei plati o anumita suma...\"\n\nAdriana s-a gandit ca ar fi frumos sa-si numeroteze toate cele N pagini ale clasorului ei cu astfel de timbre. Fiind si o fetita pofticioasa si-a zis : \"Uf, tare as vrea sa mananc o inghetata din banii pe care ii am la mine, dar nu stiu daca o sa-mi ajunga sa platesc timbrele. Cum sa fac?\"\n\nh2. Cerinta\n\n\n\nStiind cele M intervale, precum si costurile acestora, ajutati-o pe Adriana sa cumpere timbrele necesare numerotarii clasorului, platind o suma cat mai mica.\n\nh2. Date de Intrare\n\n\n\nPe prima linie a fisierului \"timbre.in\" se afla N, M, si K. N reprezinta numarul de pagini ale clasorului, M reprezinta numarul de intervale, iar K lungimea maxima a unei subsecvente. Pe urmatoarele M linii se afla doua numere separate printr-un spatiu, mi si ci, unde mi reprezinta marginea superioara a intervalului i, iar ci costul acestuia.\n\nh2. Date de Iesire\n\n\n\nPe prima linie a fisierului \"timbre.out\" se va afla Smin, reprezentand suma minima pe care trebuie sa o plateasca Adriana pentru a cumpara timbrele necesare numerotarii clasorului.\n\nh2. Restrictii si precizari\n\n\n\n. 0 < N < 1001\n\n. 0 < M < 10001\n\n. 0 < K < 1001\n\n. 0 < mi < 100000\n\n. 0 < ci < 10000\n\n. pentru a numerota toate cele N pagini ale clasorului, Adriana are nevoie de timbre cu numerele de la 1 la N\n\nh2. Exemplu\n\n\n\n\n|timbre.in |timbre.out |explicatie |\n\n|4 3 2 |3 |Luam subsecventa [1, 2] din al doilea interval si subsecventa [3, 4] din al treilea interval. Obtinem astfel costul minim 3. |\n| | | |\n|5 3 | | |\n| | | |\n|2 1 | | |\n| | | |\n|6 2 | | |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"timbre\")==',0,''),('problema/divizori','Divizori','2006-11-11 23:31:19','==Include(page=\"template/taskheader\" task_id=\"divizori\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nVom considera un numar natural $N$ . In sirul $A$ vom aseza toti divizorii lui $N$ . Se cere sa se permute elementele sirului $A$ astfel incat pentru oricare doua elemente consecutive $A{~i~}$ si $A{~i+1~}$ sa avem fie $A{~i~}=A{~i+1~}*p$ fie $A{~i+1~}=A{~i~}*p$ , unde $p$ este un numar prim oarecare. Valoarea $p$ poate diferi de la o pereche de elemente la alta.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului $divizori.in$ se afla $N$ .\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului $divizori.out$ se va afisa lungimea sirului $A$ . Pe a doua linie a fisierului se vor afisa elementele lui $A$ . In cazul existentei mai multor solutii, se poate afisa oricare dintre ele.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 2.000.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. divizori.in |_. divizori.out |\r\n| 12 \r\n|6\r\n1 2 4 12 6 3 |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"divizori\")==',961,''),('problema/perm2','Permutari II','2006-11-12 00:14:46','==Include(page=\"template/taskheader\" task_id=\"perm2\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nSe considera multimea $A$ formata din elementele $1, 2, 3 ... N (1<=N<=20.000)$.\r\n\r\nO permutare $P$ este un functie bijectiva definita pe multimea $A$, cu valori in $A$. (bijectiva in sensul ca asociaza in mod unic fiecarui element din $A$ un element tot din $A$).\r\n\r\nUn exemplu de astfel de permutare este ilustrat de tabelul de mai jos\r\n\r\n\r\ntable(numbers). |_. i |1 |2 |3 |4 |\r\n|_. $P(i)$ |2 |3 |4 |1 |\r\n\r\nDefinim permutarea $P^k^$ astfel:\r\n\r\n$P^k^(i)$ =\r\n * $P(i)$, atunci cand $k=1$\r\n * $P(P^k^-1(i))$, pentru $k > 1$\r\n\r\nTabelul de mai jos ilustreaza P^1^ si P^2^:\r\n\r\ntable(numbers). |_. i |1 |2 |3 |4 |\r\n|_. P^1^(i) |2 |3 |4 |1 |\r\n|_. P^2^(i) |3 |4 |1 |2 |\r\n\r\nh2. Cerinta\r\n\r\nSe da $N$ si o permutare $P$. Sa se gaseasca cel mai mic numar natural $K$ strict pozitiv, astfel incat oricare ar fi $1<=i<=N$ $P^k^(i)=i$ (in alte cuvinte, $P^k^$ sa fie _permutarea identica_ ).\r\n\r\nh2. Date de intrare\r\n\r\nFisierul $perm2.in$ va contine pe prima linie numarul intreg $N$.\r\n\r\nPe urmatoarea linie se scriu $N$ numere naturale distincte, fiecare in intervalul {$1..N$}.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $perm2.out$ se va scrie acel numar $K$ ce indeplineste condiitle impuse.\r\n\r\nh2. Exemple\r\n\r\nperm2.in\r\n\r\n6\r\n\r\n1 2 3 4 5 6\r\n\r\nperm2.out\r\n\r\n1\r\n\r\n\r\n\r\nperm2.in\r\n\r\n4\r\n\r\n2 3 4 1\r\n\r\nperm2.out\r\n\r\n4\r\n\r\n\r\n\r\nperm2.in\r\n\r\n8\r\n\r\n1 5 2 3 4 8 6 7\r\n\r\nperm2.out\r\n\r\n12\r\n\r\nPrecizari\r\n\r\nPentru testele furnizate, 1<=K<=100 000\r\n==Include(page=\"template/taskfooter\" task_id=\"perm2\")==',13,''),('problema/perm2','Permutari II','2006-11-12 00:19:34','==Include(page=\"template/taskheader\" task_id=\"perm2\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nSe considera multimea $A$ formata din elementele $1, 2, 3 ... N (1<=N<=20.000)$.\r\n\r\nO permutare $P$ este un functie bijectiva definita pe multimea $A$, cu valori in $A$. (bijectiva in sensul ca asociaza in mod unic fiecarui element din $A$ un element tot din $A$).\r\n\r\nUn exemplu de astfel de permutare este ilustrat de tabelul de mai jos\r\n\r\n\r\ntable(numbers). |_. i |1 |2 |3 |4 |\r\n|_. $P(i)$ |2 |3 |4 |1 |\r\n\r\nDefinim permutarea $P^k^$ astfel:\r\n\r\n$P^k^(i)$ =\r\n\r\n* $P(i)$, atunci cand $k=1$\r\n* $P(P^k^-1(i))$, pentru $k > 1$\r\n\r\nTabelul de mai jos ilustreaza P^1^ si P^2^:\r\n\r\ntable(numbers). |_. i |1 |2 |3 |4 |\r\n|_. $P^1^(i)$ |2 |3 |4 |1 |\r\n|_. $P^2^(i)$ |3 |4 |1 |2 |\r\n\r\nh2. Cerinta\r\n\r\nSe da $N$ si o permutare $P$. Sa se gaseasca cel mai mic numar natural $K$ strict pozitiv, astfel incat oricare ar fi $1<=i<=N$ $P^k^(i)=i$ (in alte cuvinte, $P^k^$ sa fie _permutarea identica_ ).\r\n\r\nh2. Date de intrare\r\n\r\nFisierul $perm2.in$ va contine pe prima linie numarul intreg $N$.\r\n\r\nPe urmatoarea linie se scriu $N$ numere naturale distincte, fiecare in intervalul {$1..N$}.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului $perm2.out$ se va scrie acel numar $K$ ce indeplineste condiitle impuse.\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. perm2.in |_. perm2.out |\r\n| 6\r\n1 2 3 4 5 6 | 1 |\r\n| 4\r\n2 3 4 1 | 4 |\r\n| 8\r\n1 5 2 3 4 8 6 7 | 12 |\r\n\r\nh2. Restrictii si precizari\r\n\r\nPentru testele furnizate, $1<=K<=100.000$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"perm2\")==',13,''),('problema/energii','Energii','2006-11-11 11:23:35','==Include(page=\"template/taskheader\" task_id=\"energii\")==\n\n==Include(page=\"template/raw\")==\n\nLink: [1]File-List\n\nEnergii\n\n\n\nGigel a ajuns administrator la o centrala termo-electrica. Intr-o zi a avut loc o cadere de tensiune si astfel centrala este la \"pamant\". Gigel trebuie sa o repuna in functiune. Stiind ce energie produce fiecare generator cat si costrul punerii in functiune el trebuie sa gasesca o solutie de cost minim, pentru a produce o cantitate de energie egala sau mai mare cu cea necesara repornirii centralei.\n\nh2. Cerinta\n\nAjutati-l pe Gigel sa gaseasca solutia ceruta !\n\nh2. Date de Intrare\n\nFisierul de intrare energii.in are urmatorul format :\n\nS G - numarul de generatoare\n\nS W - cantitatea de energie necesara repornirii centralei\n\nS EG[i] CG[i] - urmatoarele G linii contin catitatea de energie produsa de generator si costul necesar producerii energiei, separate printr-un spatiu (0<i<G+1)\n\nh2. Date de Iesire\n\nFisierul de iesire energii.out are urmatorul format :\n\nS C[min] - costul minim necesar repornirii centralei sau -1 daca nu este suficienta energie pentru repornire\n\nh2. Restrictii si precizari\n\nS 1 < G < 1001\n\nS 1 < W < 5001\n\nS 1 < EG[i],CG[i] < 10001\n\nS Solutia este unica\n\nh2. Exemplu\n\nenergii.in energii.out\n3 9\n\n8\n\n2 4\n\n2 3\n\n8 9\n\n\n\nReferences\n\nVisible links\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/energii/enunt.files/filelist.xml\n==Include(page=\"template/taskfooter\" task_id=\"energii\")==',0,''),('problema/ecu','Ecu','2006-11-11 11:23:42','==Include(page=\"template/taskheader\" task_id=\"ecu\")==\n\n==Include(page=\"template/raw\")==\n\nEcu\n\n\n\nGigel are de rezolvat un sistem complicat de ecuatii neliniare si pentru aceasta intentioneaza sa foloseasca o metoda iterativa care, spera el, va converge catre solutie dupa un numar rezonabil de iteratii. Mai intai, el alege niste valori initiale pentru cele N necunoscute ale sistemului. Aceste valori se noteaza cu .. . In continuare, dupa fiecare iteratie, el va modifica valorile necunoscutelor, conform urmatoarelor relatii:\n\n. , pentru 1<=k<N\n\n.\n\nunde prin s-a notat valoarea necunoscutei k dupa i iteratii. reprezinta ponderea asociata necunoscutei k, iar reprezinta corectia aplicata necunoscutei k, dupa fiecare iteratie.\n\nGigel nu este un programator prea bun si nu stie sa implementeze algoritmul iterativ descris. De aceea, are nevoie de ajutorul dumneavoastra.\n\nh2. Cerinta\n\nDandu-se valorile initiale ale celor N necunoscute, ponderile asociate si corectiile aplicate, sa se determine valorile necunoscutelor dupa M iteratii.\n\nh2. Date de Intrare\n\nPe prima linie a fisierului ecu.in se afla doua numere intregi, separate printr-un spatiu, N si M. Pe urmatoarea linie se afla N numere reale, reprezentand valorile initiale ale necunoscutelor, in ordinea x[1],..,x[N]. Pe urmatoarea linie se afla alte N numere reale, reprezentand ponderile asociate necunoscutelor, in ordine de la x[1] la x[N]. Pe ultima linie a fisierului se afla N numere reale, descriind corectiile ce vor fi aplicate necunoscutelor x[1],x[2],..,x[N], dupa fiecare iteratie. Toate numerele reale sunt date cu cel mult 3 zecimale.\n\nh2. Date de Iesire\n\nPe prima linie a fisierului ecu.out se vor afisa N numere reale, rotunjite la trei zecimale, reprezentand valorile necunoscutelor dupa M iteratii.\n\nh2. Restrictii si precizari:\n\n. 2 <= N <= 30\n\n. 0 <= M <= 1.000.000.000\n\n. -1000 <= <= 1000 , pentru k de la 1 la N\n\n. 0 <= <= 1 , pentru k de la 1 la N\n\n. -0.1 <= [ ]<= 0.1 , pentru k de la 1 la N\n\n.\n\nh2. Exemplu\n\necu.in ecu.out\n3 2 2.173 1.765 2.075\n\n1.0 2.0 3.0\n\n0.1 0.2 0.3\n\n0.001 0.002 0.003\n\n\n\nExplicatie\n\nDupa prima iteratie, valorile necunoscutelor sunt: 1.701; 2.502; 1.803. Dupa cea de-a doua iteratie, valorile necunoscutelor sunt: 2.173; 1.765; 2.075.\n==Include(page=\"template/taskfooter\" task_id=\"ecu\")==',0,''),('problema/rubarba','Rubarba','2006-11-12 00:49:39','==Include(page=\"template/taskheader\" task_id=\"rubarba\")==\r\n\r\nProaspat evadat din temnita, _Paftenie barbarul_ a decis ca este timpul sa puna capat pentru o vreme aventurilor sale. Intorcandu-se la familia lui, s-a dedicat unui nou hobby: gradinaritul. De data aceasta a plantat in gradina sa $N$ tulpini de rubarba. Nefiind specialist in domeniu, a plantat tulpinile aleator, iar acum se pune problema construirii unei sere. Sera trebuie sa fie de forma dreptunghiulara, sa contina in interiorul sau toate tulpinile de rubarba, iar aria sa sa fie minima.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe gradinarul _Paftenie_ sa rezolve problema!\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare este dat numarul $N$ al tulpinilor de rubarba. Pe urmatoarele $N$ linii se afla cate o pereche de numere intregi, reprezentand coordonatele acestora.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire va contine pe prima linie un singur numar real, reprezentand aria minima a dreptunghiului cerut.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1$ &le; $N$ &le; $100.000$\r\n* coordonatele plantelor sunt numere intregi cuprinse intre $0$ si $1.000.000$\r\n* rezultatul se va afisa cu o precizie de $2$ zecimale\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. rubarba.in |_. rubarba.out |\r\n| 9\r\n2\r\n4\r\n7\r\n1\r\n7\r\n5\r\n6\r\n8\r\n3\r\n| 50.32\r\n1\r\n2\r\n2\r\n4\r\n4\r\n6\r\n8\r\n8\r\n9 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"rubarba\")==',13,''),('problema/rubarba','Rubarba','2006-11-12 00:50:40','==Include(page=\"template/taskheader\" task_id=\"rubarba\")==\r\n\r\nProaspat evadat din temnita, _Paftenie barbarul_ a decis ca este timpul sa puna capat pentru o vreme aventurilor sale. Intorcandu-se la familia lui, s-a dedicat unui nou hobby: gradinaritul. De data aceasta a plantat in gradina sa $N$ tulpini de rubarba. Nefiind specialist in domeniu, a plantat tulpinile aleator, iar acum se pune problema construirii unei sere. Sera trebuie sa fie de forma dreptunghiulara, sa contina in interiorul sau toate tulpinile de rubarba, iar aria sa sa fie minima.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe gradinarul _Paftenie_ sa rezolve problema!\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare este dat numarul $N$ al tulpinilor de rubarba. Pe urmatoarele $N$ linii se afla cate o pereche de numere intregi, reprezentand coordonatele acestora.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire va contine pe prima linie un singur numar real, reprezentand aria minima a dreptunghiului cerut.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1$ &le; $N$ &le; $100.000$\r\n* coordonatele plantelor sunt numere intregi cuprinse intre $0$ si $1.000.000$\r\n* rezultatul se va afisa cu o precizie de $2$ zecimale\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. rubarba.in |_. rubarba.out |\r\n| 9\r\n2\r\n4\r\n7\r\n1\r\n7\r\n5\r\n6\r\n8\r\n3\r\n| 50.32\r\n1\r\n2\r\n2\r\n4\r\n4\r\n6\r\n8\r\n8\r\n9 |\r\n\r\nh3. Explicatie\r\n\r\n!rubarba.jpg!\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"rubarba\")==',13,''),('problema/lacate','Lacate','2006-11-12 01:07:42','==Include(page=\"template/taskheader\" task_id=\"lacate\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\n\r\nPentru a pazi subiectele de la concursul preONI, comisia care a propus problemele, formata din $N$ persoane, s-a gandit sa pastreze subiectele intr-un seif. Pentru inchiderea seifului sunt necesare un anumit numar de lacate, pentru fiecare lacat existand un anumit numar de chei care-l pot deschide. Distributia cheilor printre membrii comisiei trebuie sa respecte urmatoarele conditii:\r\n\r\n* oricare doi membri detin acelasi numar de chei\r\n* fiecare membru detine chei de la lacate distincte\r\n* toate lacatele seifului se vor putea deschide numai in prezenta oricarui grup format din cel putin $N-1$ membrii\r\n\r\nh2. Cerinta\r\n\r\nStiind ca nici o cheie nu poate deschide doua lacate distincte, determinati numarul minim de lacate necesare, precum si o distributie a cheilor care sa respecte conditiile de mai sus.\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul de intrare $lacate.in$ se va gasi numarul natural $N$, reprezentand numarul membrilor comisiei.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie din fisierul $lacate.out$ se va gasi doua numere naturale $L$ si $C$ reprezentand numarul minim de lacate necesare, respectiv numarul de chei pe care le va avea fiecare membru. Pe urmatoarele $N$ linii se vor gasi cheile pe care le detine fiecare membru, astfel incat pe linia $i+1$ se vor gasi $C$ numere reprezentand cheile pe care le detine membrul $i$; cheile sunt numerotate cu numere de la $1$ la $L$, fiecare numar reprezentand numarul lacatului pe care il deschide cheia respectiva.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 256$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. lacate.in |_.lacate.out |\r\n| 2\r\n| 1 1\r\n1\r\n1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"lacate\")==',15,''),('problema/lacate','Lacate','2006-11-12 01:07:57','==Include(page=\"template/taskheader\" task_id=\"lacate\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\n\r\nPentru a pazi subiectele de la concursul preONI, comisia care a propus problemele, formata din $N$ persoane, s-a gandit sa pastreze subiectele intr-un seif. Pentru inchiderea seifului sunt necesare un anumit numar de lacate, pentru fiecare lacat existand un anumit numar de chei care-l pot deschide. Distributia cheilor printre membrii comisiei trebuie sa respecte urmatoarele conditii:\r\n* oricare doi membri detin acelasi numar de chei\r\n* fiecare membru detine chei de la lacate distincte\r\n* toate lacatele seifului se vor putea deschide numai in prezenta oricarui grup format din cel putin $N-1$ membrii\r\n\r\nh2. Cerinta\r\n\r\nStiind ca nici o cheie nu poate deschide doua lacate distincte, determinati numarul minim de lacate necesare, precum si o distributie a cheilor care sa respecte conditiile de mai sus.\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul de intrare $lacate.in$ se va gasi numarul natural $N$, reprezentand numarul membrilor comisiei.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie din fisierul $lacate.out$ se va gasi doua numere naturale $L$ si $C$ reprezentand numarul minim de lacate necesare, respectiv numarul de chei pe care le va avea fiecare membru. Pe urmatoarele $N$ linii se vor gasi cheile pe care le detine fiecare membru, astfel incat pe linia $i+1$ se vor gasi $C$ numere reprezentand cheile pe care le detine membrul $i$; cheile sunt numerotate cu numere de la $1$ la $L$, fiecare numar reprezentand numarul lacatului pe care il deschide cheia respectiva.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 256$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. lacate.in |_.lacate.out |\r\n| 2\r\n| 1 1\r\n1\r\n1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"lacate\")==',15,''),('problema/sum','Sum','2006-11-11 11:23:49','==Include(page=\"template/taskheader\" task_id=\"sum\")==\n\n==Include(page=\"template/raw\")==\n\nSum\n\nh2. Cerinta\n\nRaspundeti la N intrebari de tipul: care este suma numerelor Y prime cu un numar X , si care respecta proprietatea 0 <= Y <= 2*X .\n\nh2. Date de Intrare\n\nPrima linie a fisierului de intrare sum.in contine un numar intreg N . Pe urmatoarele N linii se afla cate un numar X .\n\nh2. Date de Iesire\n\nIn fisierul sum.out veti afisa N linii, reprezentand, in ordine, raspunsurile pentru testele din fisierul de intrare.\n\nh2. Restrictii si precizari\n\n. 1 <= N <= 100.000\n\n. 2 <= X <= 100.000\n\nh2. Exemplu\n\n\n|sum.in |sum.out |\n\n|2 |40 |\n|5 |24 |\n|6 | |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"sum\")==',0,''),('problema/geamuri','Geamuri','2006-11-11 11:23:45','==Include(page=\"template/taskheader\" task_id=\"geamuri\")==\n\n==Include(page=\"template/raw\")==\n\nGeamuri\n\n\n\nEnervat de atatea probleme de pe InfoArena care nu-i ieseau si de atatea runde de GInfo cu probleme indentice, Geminski isi ia pistolul si pleaca sa impuste niste geamuri. Ajuns la fata locului, constata ca se afla in fata a N geamuri dreptungiulare, fiecare bine delimitat in raport cu sistemul cartezian ortogonal. Geminski are la el M gloante. Cand se decide sa traga un glont, el isi stabileste un punct bine delimitat in raport cu sistemul cartezian ortogonal, dupa care trage! Geminski are totusi une limitari, astfel ca nu poate trage decat din puncte cu coordonate cuprinse intre 1 si C. Fiecare geam ce contine acel punct se va sparge. Geminski vrea ca atunci cand trage cu glontul al i-lea, sa sparga exact K[i] geamuri.\n\nh2. Cerinta\n\nScrieti un program care sa determine pentru fiecare glont pe care il trage Geminski din cate pozitii il poate trage astfel incat sa sparga exact K[i] geamuri.\n\n\n\nDate intrare\n\nPrimele doua linii ale fisierului de intrare geamuri.in contin numarele intregi C, respectiv N. Urmatoarele N linii contin cate 4 numere intregi x[0], y[0], x[1], y[1], reprezentand coordonatele geamurilor date prin coltul stanga-jos si dreapta-sus (1 <= x[0] <= x[1] <= C, 1 <= y[0] <= y[1] <= C). Urmatoare linie contine numarul intreg M, iar urmatoarele M linii numerele K[i] (1 <= i <= M), cate unul pe linie.\n\nh2. Date de Iesire\n\nFisierul de iesire geamuri.out va contine M linii, cu numarul cautat pe fiecare linie.\n\nh2. Restrictii si precizari\n\nS 1 <= C <= 1024\n\nS 0 <= K[i] <= N <= 50.000\n\nS 1 <= M <= 50.000\n\nS Geamurile se pot suprapune\n\n\n\n\n\ngeamuri.in geamuri.out Explicatie\n8 1 Primul glont poate fi tras doar din (5, 4), iar al doilea din coordonatele (4, 4), (5, 3), (5, 5), (5, 6), (6, 4), (6, 5), (6, 6).\n\n3 7\n\n2 2 5 4\n\n5 3 6 8\n\n4 4 7 6\n\n2\n\n3\n\n2\n\n\n==Include(page=\"template/taskfooter\" task_id=\"geamuri\")==',0,''),('problema/fractii','Fractii','2006-11-11 11:23:33','==Include(page=\"template/taskheader\" task_id=\"fractii\")==\n\n==Include(page=\"template/raw\")==\n\nLink: [1]File-List\n\nFractii\n\n\n\nGigel, intr-o zi cand isi facea temele la matematica, s-a apucat sa scrie pe o foaie de hartie, un sir de fractii ireductibile de forma ^P/[Q] cu 1 <= P,Q <= N, unde N este un numar natural ales de el. De exemplu, pentru N = 4 el a obtinut urmatorul sir:\n\n^1/[1 ] ^1/[2 ] ^1/[3 ] ^1/[4 ] ^2/[1 ] ^2/[3 ] ^3/[1 ] ^3/[2 ] ^3/[4 ] ^4/[1 ] ^4/[3\n\n]Gigel s-a apucat apoi sa numere cate fractii a obtinut pentru N = 4 si a vazut ca sunt 11.\n\nh2. Cerinta\n\nFiind dat un numar natural N, sa se determine cate fractii sunt in sirul de fractii construit dupa regulile de mai sus.\n\nh2. Date de Intrare\n\nFisierul de intrare fractii.in contine pe prima linie numarul natural N.\n\nh2. Date de Iesire\n\nFisierul de iesire fractii.out trebuie sa contina un numar natural pe prima linie care reprezinta cate fractii sunt in sir.\n\nh2. Restrictii si precizari\n\nS 1 <= N <= 1.000.000\n\n\n\nExemple\n\nfractii.in fractii.out\n3 7\n\n\n\nfractii.in fractii.out\n4 11\n\n\n\nfractii.in fractii.out\n5 19\n\n\n\nfractii.in fractii.out\n10 63\n\n\n\nReferences\n\nVisible links\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/fractii/enunt.files/filelist.xml\n==Include(page=\"template/taskfooter\" task_id=\"fractii\")==',0,''),('problema/suma','Suma','2006-11-12 13:01:04','==Include(page=\"template/taskheader\" task_id=\"suma\")==\r\n\r\n\r\nFie suma !http://infoarena.ro/task/suma?action=download&file=suma_formula.jpg!.\r\n\r\nCalculati valoarea $S$ mod $P$ (restul impartirii lui $S$ la $P$).\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $suma.in$ se afla 2 numere intregi $N$ si $P$ (separate printr-un spatiu).\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $suma.out$ veti afisa valoarea ({$S$} mod $P$).\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 10^9^$\r\n* $1 &le; P &le; 30 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. suma.in|_. suma.out|\r\n|7 29997|112|\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"suma\")==',256,''),('problema/fractii','Fractii','2006-11-12 13:02:36','==Include(page=\"template/taskheader\" task_id=\"fractii\")==\r\n\r\n\r\n\r\nGigel, intr-o zi cand isi facea temele la matematica, s-a apucat sa scrie pe o foaie de hartie, un sir de fractii ireductibile de forma $^P^/{~Q~}$ cu $1 <= P,Q <= N$, unde $N$ este un numar natural ales de el. De exemplu, pentru $N = 4$ el a obtinut urmatorul sir:\r\n\r\np=. $^1^/{~1~}  ^1^/{~2~}  ^1^/{~3~}  ^1^/{~4~}  ^2^/{~1~}  ^2^/{~3~}  ^3^/{~1~}  ^3^/{~2~}  ^3^/{~4~}  ^4^/{~1~}  ^4^/{~3~}$\r\n\r\nGigel s-a apucat apoi sa numere cate fractii a obtinut pentru $N = 4$ si a vazut ca sunt $11$.\r\n\r\nh2. Cerinta\r\n\r\nFiind dat un numar natural $N$, sa se determine cate fractii sunt in sirul de fractii construit dupa regulile de mai sus.\r\n\r\nh2. Date de intrare\r\n\r\nFisierul de intrare $fractii.in$ contine pe prima linie numarul natural $N$.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $fractii.out$ trebuie sa contina un numar natural pe prima linie care reprezinta cate fractii sunt in sir.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 1.000.000$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. fractii.in |_. fractii.out |\r\n| 3 | 7 |\r\n| 4 | 11 |\r\n| 5 | 19 |\r\n| 10| 63 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"fractii\")==',15,''),('problema/java','Gandaci Java','2006-11-12 13:14:00','==Include(page=\"template/taskheader\" task_id=\"java\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nPe insula Java, se fac experimente crude pe unele dintre cele mai frumoase creaturi din lume, gandacii. $M$ cercetatori fac experimente pe $N$ gandaci. Din pacate, dupa ce au alcatuit un plan inteligent, toti gandacii au scapat din laborator si au fugit in parti diferite ale insulei. Cercetatorii trebuie sa aduca gandacii inapoi pentru a continua experimentele. Pentru a face asta, fiecare cercetator este trimis sa caute cel mult un gandac. Gandacii sunt numerotati cu numere de la $1$ la $N$. Cercetatori poarte ecusoane cu numere de la $1$ la $M$. Un cercetator poate cauta un gandac doar daca a facut vreodata un experiment pe acel gandac (altfel, nu ar putea sa-l recunoasca).\r\n\r\nCunoscandu-se experimentele care au avut loc inainte sa scape gandacii, sa se determine care este numarul maxim de gandaci care pot fi adusi inapoi in laborator dupa o cantitate finita de timp. Se stie ca, daca un cercetator este trimis in cautarea unui gandac, il va gasi intr-o cantitate finita de timp (pentru ca ar fi imposibil pentru un gandac Java sa fie mai destept decat un cercetator).\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie din fisierul $java.in$ contine numarul natural $T$, reprezentand numarul de teste. In continuare, se vor descrie cele $T$ teste. Prima linie a fiecarui test contine trei numere naturale: $M$, $N$ si $E$. $M$ este numarul de cercetatori, $N$ este numarul de gandaci si $E$ este numarul de experimente care au avut loc. Urmatoarele $E$ linii contin cate doua numere naturale $A$ si $B$, cu semnificatia ca cercetatorul $A$ a facut un experiment pe gandacul $B$. Un cercetator poate face mai multe experimente pe acelasi gandac.\r\n\r\nh2. Date de iesire\r\n\r\nPentru fiecare test afisati cate o linie in fisierul $java.out$ continand un numar natural: numarul maxim de gandaci care pot fi adusi inapoi la laborator dupa o cantitate finita de timp.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; T &le; 6$\r\n* $1 &le; N, M &le; 10.000$\r\n* $0 &le; E &le; 200.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. java.in |_. java.out |\r\n| 2\r\n4 5 2\r\n1 2\r\n1 2\r\n3 3 5\r\n1 1\r\n1 2\r\n2 2\r\n2 3\r\n3 3\r\n| 1\r\n3 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"java\")==',15,''),('problema/frac','Frac','2006-11-11 11:23:40','==Include(page=\"template/taskheader\" task_id=\"frac\")==\n\n==Include(page=\"template/raw\")==\n\nfrac\n\nPatratel este mare pasionat de fractii. Intr-o zi el se gandeste sa scrie pe o foaie de hartie, in ordine crescatoare, toate fractiile ireductibile cu numitorul N. Observand insa la timp ca sunt o infinitate de astfel de fractii, el nu se mai oboseste si doreste sa afle doar a P-a fractie din sirul la care s-a gandit.\n\nh2. Cerinta\n\nSa se determine numaratorul celei de a P-a fractii din sirul construit dupa regulile de mai sus.\n\nh2. Date de Intrare\n\nPrima linie a fisierului frac.in contine doua numere intregi N si P, separate prin cate un spatiu, avand semnificatia descrisa in enunt.\n\nh2. Date de Iesire\n\nPrima linie a fisierului frac.out contine un numar natural care reprezinta numaratorul celei de a P-a fractii din sirul fractiilor ireductibile cu numitorul N.\n\nh2. Restrictii si precizari\n\no 1 <= N <= 12 000 000 000 ( 12 miliarde )\no 1 <= P <= 10^14\no Se garanteaza ca rezultatul nu depaseste 2^61\n\nh2. Exemplu\n\nfrac.in frac.out Explicatie\n12 5 13 Fractiile sirului sunt: 1/12, 5/12, 7/12, 11/12, 13/12, 17/12, etc. A 5-a fractie din acest sir este 13/12 si are numaratorul 13.\n\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"frac\")==',0,''),('problema/harta','Taramul Nicaieri','2006-11-11 11:23:46','==Include(page=\"template/taskheader\" task_id=\"harta\")==\n\n==Include(page=\"template/raw\")==\n\nHarta\n\n\n\nHarta \"Taramului nicaieri\" a fost pierduta, dar din fericire se mai stiu cateva date despre ea. Se stie ca exista N orase intre care se afla diferite drumuri. Drumurile \"Taramului nicaieri\" sunt un pic mai ciudate deoarece daca exista un drum care pleaca din orasul i si ajunge in orasul j nu exista in mod obligatoriu si un drum care pleaca din orasul j si ajunge in orasul i. Deasemenea nu vor exista drumuri care pleaca si ajung in acelasi oras. Si nu vor exista mai multe drumuri identice(adica sa coincida si orasul din care pleaca si cel in care se ajunge).Pentru fiecare oras se stiu cate drumuri pleaca din el si cate drumuri ajung in el.\n\nh2. Cerinta\n\nScrieti un program care determina drumurile de pe harta initiala.\n\nh2. Date de Intrare\n\nPrima linie a fisierului de intrare harta.in contine numarul intreg N, reprezentand numarul de orase. Urmeaza apoi N linii, linia i continand doua numere x,y numarul de drumuri care pleaca din orasul i respectiv numarul de drumuri care intra in orasul i.\n\nh2. Date de Iesire\n\nIn fisierul harta.out veti afisa pe prima linie numarul M de drumuri construite, apoi vor urma M linii pe fiecare aflandu-se o pereche de numere a,b cu semnificatia exista un drum care pleaca din a si ajunge in b.\n\nh2. Restrictii\n\n. 1 <= N <= 100\n\nh2. Exemplu\n\n\n|harta.in |harta.out |\n\n|4 |5 |\n|2 1 |1 2 |\n|0 2 |1 3 |\n|2 1 |3 2 |\n|1 1 |3 4 |\n| |4 1 |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"harta\")==',0,''),('problema/fractal','Fractal','2006-11-12 13:26:26','==Include(page=\"template/taskheader\" task_id=\"fractal\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nHilbert a gasit o curba care poate trece prin fiecare punct al spatiului, aceasta curba se bazeaza pe o constructie recursiva. Numim curba de ordin Hilbert de ordinul $K$ curba curba realizata dupa urmatoarele reguli ce trece prin fiecare nod al unei grile de $2^K^*2^K^$ noduri si trece prin noduri vecine ale grilei.\r\nCurba Hilbert de ordinu 1 este o curba simpla:\r\n!task/fractal?image001.gif!\r\nVor fi descries in urmatoarele imagini trecerile de la o curba de ordin x la o curba de ordin x+1:\r\nOrdin $1$ -> Ordin $2$\r\n!task/fractal?image001.gif! !task/fractal?image002.gif!\r\n\r\nOrdin $2$ -> Ordin $3$\r\n\r\nOrdin $3$ -> Ordin $4$\r\n\r\nOrdin $4$ -> Ordin $5$\r\n\r\n\r\n\r\nSe dau ca date de intrare din fisierul fractal.in numerele K, x si y, unde K este ordinul unei curbe, iar x si y sunt coordanate intregi in interiorul unui patrat de dimensiune 2^K*2^K. Se cere sa scrieti in fisierul de iesire fractal.out in cati pasi se ajunge la coordonatele (x,y) daca punctele din patrat sunt parcurse in ordinea data de curba Hilbert de ordin K.\r\n\r\nh2. Restrictii si precizari\r\n\r\nS 1 <= k <= 15\r\n\r\nS 1 <= x,y <= 2^K\r\n\r\nS Coordonatele x si y sunt intre 1 si 2^K inclusive, iar coltul din stanga sus are coordonatele (1,1)\r\n\r\n\r\n\r\nExemple\r\n\r\nfractal.in fractal.out\r\n\r\n1 1 1 0\r\n\r\n\r\n\r\nfractal.in fractal.out\r\n\r\n3 2 3 13\r\n\r\n\r\n\r\nfractal.in fractal.out\r\n\r\n2 4 1 15\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/fractal/docs/preoni3/fractal/filelist.xml\r\n2. file:///home/eval/eval/www/infoarena/docs/arhiva/fractal/docs/preoni3/fractal/editdata.mso\r\n==Include(page=\"template/taskfooter\" task_id=\"fractal\")==',1,''),('problema/gold','Gold','2006-11-12 13:43:22','==Include(page=\"template/taskheader\" task_id=\"gold\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nFie $N$ mine cu aur aflate la puncte de coordonate intregi in plan. Fiecare mina contine o cantitate cunoscuta de aur, exprimata in kilograme. Doi cautatori de aur au venit in zona si doresc sa imparta minele intre ei. Pentru a le fi mai simplu, se hotarasc sa aleaga doua din cele $N$ mine. Astfel, unele dintre cele $N-2$ mine ramase vor fi de o parte, iar altele de cealalta parte a dreptei formata de cele doua mine alese. Minele dintr-o zona vor fi repartizate primului cautator, urmand ca celelalte sa ajunga in posesia celui de-al doilea. Cantitatea de aur pentru fiecare cautator este data de suma cantitatilor de aur aflate in minele din posesia sa. Problema care se iveste este ca unul dintre cautatori poate avea mult mai mult aur decat celalalt. Totusi, cei doi ajung la un compromis: daca diferenta in modul dintre cele doua cantitati nu depaseste o valoare stabilita $P$ , atunci impartirea se considera a fi una echitabila.\r\n\r\nh2. Cerinta\r\n\r\nSa se determine in cate moduri pot fi stabilite cele doua mine astfel incat impartirea sa fie una echitabila.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $gold.in$ contine {$N$}, numarul de mine. Pe a doua linie se afla valoarea {$P$}, cu semnificatia din enunt. Linia a {$3$}-a va contine $N$ numere naturale nenule, al {$i$}-lea numar reprezentand cantitatea de aur din mina a {$i$}-a. Incepand cu linia a {$4$}-a, vor fi descrise pozitiile minelor referitor la un sistem ortogonal de axe: pe fiecare linie se va gasi o pereche de numere intregi {$(x y)$}, mai precis pe linia $i+3$ aflandu-se coordonatele pentru cea de a {$i$}-a mina.\r\n\r\nh2. Date de Iesire\r\n\r\nPrima linie a fisierului $gold.out$ contine numarul de moduri diferite de a alege doua mine dintre cele $N$ pentru ca impartirea sa fie echitabila.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $4 &le; N &le; 1.024$\r\n* $0 &le; P &le; 98.765$\r\n* Cantitatile de aur din mine sunt numere naturale cuprinse in [{$1, 10.000$}]\r\n* Coordonatele minelor sunt numere intregi in [{$-16.000, 16.000$}]\r\n* Oricare trei mine sunt necoliniare\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. gold.in |_. gold.out |\r\n| 7\r\n5\r\n4 7 8 6 4 6 7\r\n3 10\r\n2 3\r\n8 1\r\n10 4\r\n7 1\r\n7 3\r\n9 8\r\n| 3 |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"gold\")==',961,''),('problema/invsc','Invsc','2006-11-12 13:47:41','==Include(page=\"template/taskheader\" task_id=\"invsc\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nGigel tocmai invatase la scoala algoritmul de calcul a celui mai lung subsir crescator a unui sir de numere naturale. Si atat de mult i-a placut, incat a stat cateva zile si a aplicat acest algoritm pe mai multe siruri de numere( distincte doua cate doua). Pentru asta el se folosea de un vector auxiliar $v$ cu semnficatia {$v{~i~}$}= lungimea celui mai lung subsir crescator din sirul initial care se termina pe pozitia {$i$}( evident rezultatul era reprezentat de maximul din acest vector). Vrand sa ia o nota buna pentru efortul depus e a vrut sa duca profesorului sau de informatica toate calculele sale. Doar ca exact inainte sa plece Gigel de acasa ,sora sa, Georgiana, a luat toate foile cu sirurile pe care acesta aplicase alogitmul tocmai invatat si le-a rupt in bucatele. Lui Gigel i-au ramas astfel doar foile cu vectorii auxiliari folositi.\r\n\r\nh2. Cerinta\r\n\r\nNeavand timp sa asambleze la loc toate foile, Gigel are nevoie de ajutorul vostru pentru a reconstitui vectorii initiali.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $invsc.in$ va contine numarul natural nenul n reprezentand lungimea unui sir pe care Gigel a aplicat algoritmul tocmai invatat. Pe urmatoarele $N$ linii este dat vectorul auxiliar $v$ calculat de Gigel.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $invsc.out$ va contine sirul initial de la care a plecat Gigel, adica n numere naturale nenule distincte cu maxim 8 cifre, fiecare numar pe o linie separata.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $N &le; 200.000$\r\n* se garanteaza ca pentru fiecare test va exista cel putin o solutie\r\n* in cazul in care exista mai multe solutii se poate afisa oricare dintre ele\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. invsc.in |_. invsc.out |\r\n| 5\r\n1\r\n2\r\n2\r\n2\r\n3\r\n| 5\r\n10\r\n7\r\n6\r\n12 |\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"invsc\")==',961,''),('problema/struti','Struti','2006-11-12 13:55:25','==Include(page=\"template/taskheader\" task_id=\"struti\")==\r\n\r\nPatratel s-a lasat de scoala si, pentru ca a aflat ca sunt foarte profitabile, s-a apucat de afaceri cu struti. Pentru a demara afacerea sa, el are nevoie mai intai de toate sa cumpere teren in regiune. Regiunea este dreptunghiulara si are dimensiunile de $M$ km x $N$ km, fiind impartita in zone de $1$ x $1$ km. Fiecare zona are o altitudine cunoscuta, specificata pe harta in metri fata de nivelul marii. Astfel, toate altitudinile sunt numere intregi nenegative. Terenul pe care Patratel vrea sa il cumpere in aceasta regiune trebuie sa fie de asemenea dreptunghiular si sa aiba laturile paralele cu ale regiunii. In plus, terenul nu trebuie ales la intamplare. Pentru ca a studiat comportamentul strutilor, el si-a dat seama ca sunt animale destul de pretentioase. Se defineste diferenta de altitudine a unui teren ca fiind diferenta dintre altitudinea maxima si altitudinea minima ale unor zone de $1$ km^2^ cuprinse in teren. Pentru ca strutii sa se dezvolte optim, diferenta de altitudine a terenului ales trebuie sa fie cat mai mica posibil.\r\n\r\nPatratel primeste $P$ oferte pe care trebuie sa le analizeze. O oferta este formata dintr-o pereche de numere naturale ({$DX DY$}), semnificand faptul ca Patratel poate alege oriunde in regiune un teren cu laturile de dimensiuni $DX$ si $DY$ ( nu neaparat in aceasta ordine ). Pentru fiecare oferta in parte Patratel ar dori sa stie care este diferenta de altitudine minima a unui teren cu laturile specificate in oferta.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati diferenta de altitudine mimima pentru fiecare oferta in parte.\r\n\r\nh2. Date de intrare\r\n\r\nPrima linie a fisierului $struti.in$ contine $M$, $N$ si $P$, dimensiunile regiunii si numarul de oferte, despartite de cate un spatiu. Pe fiecare din urmatoarele $M$ linii se afla cate $N$ numere naturale nenegative, specificand altitudinea zonei respective. Urmatoarele $P$ linii descriu cate o oferta, compusa din doua numere naturale $DX$ si $DY$, cu semnificatiile descrise in enunt.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul $struti.out$ contine $P$ linii, pe linia $i$ aflandu-se $MIN$ si $NR$, diferenta de altitudine minima pentru oferta a $i$-a si numarul de terenuri posibile cu aceasta diferenta minima.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $3 &le; M, N &le; 1 000$\r\n* $P &le; 10$\r\n* $1 < DX, DY &le; minim(M, N)$\r\n* Fiecare teren selectat trebuie sa fie inclus complet in regiune\r\n* Toate altitudinile sunt date in metri si nu depasesc $8 000$\r\n* Punctele pe un test se acorda doar daca fisierul de iesire este in intregime corect\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. struti.in|_. struti.out|_. Explicatie|\r\n|4 4 2\r\n1 4 3 2\r\n5 4 8 9\r\n3 8 5 8\r\n2 0 6 4\r\n2 3\r\n2 2\r\n|5 4 \r\n4 4\r\n|Cele patru terenuri care pot fi selectate pentru prima oferta sunt cele ingrosate:\r\n1 4 3 2   1 4 3 2   1 4 3 2   1 **4 3** 2   \r\n5 4 **8 9**   5 **4 8 9**   **5 4 8** 9   5 **4 8** 9\r\n3 8 **5 8**   3 **8 5 8**   **3 8 5** 8   3 **8 5** 8\r\n2 0 **6 4**   2 0 6 4   2 0 6 4   2 0 6 4|\r\n\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"struti\")==',256,''),('problema/pawns','Pawns','2006-11-11 11:23:54','==Include(page=\"template/taskheader\" task_id=\"pawns\")==\n\n==Include(page=\"template/raw\")==\n\nPawns\n\n\n\nSe considera o tabla impartita in mai multe celule care contin pioni. Celulele sunt conectate intre ele prin sageti, si mergand de la orice celula in directia in care indica sagetile nu vom ajunge niciodata in locul din care am plecat. Deci, exista celule din care nu pleaca sageti si celule in care nu ajung sageti.\nConsideram doi jucatori. Fiecare jucator poate muta, cand ii vine randul, un pion din celula in care se afla intr-o celula spre care pleaca o sageata. Cel care nu mai poate muta atunci cand ii vine randul pierde partida. La inceputul unui joc, prima mutare o face jucatorul 1.\n\nh2. Cerinta\n\nSa se determine daca jucatorul 1 are strategie sigura de castig.\n\nh2. Date de Intrare\n\nFisierul de intrare pawns.in contine pe prima linie doua numere intregi n si m, separate printr-un singur spatiu, care reprezinta numarul de celule de pe tabla, respectiv numarul de sageti.\nPe fiecare dintre urmatoarele m linii se afla cate doua numere intregi x si y, separate intre ele printr-un singur spatiu, cu semnificatia ca exista o sageata care pleaca din celula cu numarul de ordine x si ajunge in celula cu numarul de ordine y.\nPe linia urmatoare se afla un numar t care reprezinta numarul de jocuri care se joaca.\nPe fiecare dintre urmatoarele t linii se afla n numere intregi, separate intre ele prin spatii, care reprezinta numarul de pioni din fiecare celula pentru un anumit joc.\n\nh2. Date de Iesire\n\nFisierul de iesire pawns.out trebuie sa contina t linii. Fiecare dintre cele t linii va contine valoarea 0, daca pentru o configuratie jucatorul 1 nu are strategie sigura de castig si valoarea 1 in caz contrar.\n\nh2. Restrictii si precizari\n\n. 1 <= n, m <= 500;\n\n. 1 <= t <= 15;\n\n. numarul de pioni dintr-o celula nu va depasi valoarea 500;\n\n. celulele sunt numerotate de la 1 la n.\n\nh2. Exemplu\n\n\n|pawns.in |pawns.out |\n\n|3 3 |1 |\n|1 2 |0 |\n|1 3 | |\n|2 3 | |\n|2 | |\n|1 0 0 | |\n|2 2 2 | |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"pawns\")==',0,''),('problema/stramosi','Stramosi','2006-11-11 11:23:34','==Include(page=\"template/taskheader\" task_id=\"stramosi\")==\n\n==Include(page=\"template/raw\")==\n\nStramosi\n\n\n\nFamilia lui Gigel este foarte numeroasa, avand exact N membri. Fiecare membru stie cine este stramosul lui direct, mai putin cativa membri care sunt foarte batrani si nu mai tin minte nici macar cine a fost stramosul lor direct.\n\nGigel, fiind o fire curioasa a facut un inventar al familiei sale, in sensul ca a numerotat fiecare membru cu un numar distinct intre 1 si N si stie deasemenea pentru fiecare membru, care este stramosul lui direct (daca acesta exista). Curiozitate lui este si mai mare, in sensul ca isi pune M intrebari de forma: \"care este al P-lea stramos al membrului cu numar Q?\".\n\nh2. Cerinta\n\nScrieti un program care raspunde corect la toate cele M intrebari ale lui Gigel.\n\n\n\nFisier de intrare\n\nPe prima linia a fisierului stramosi.in se afla numerele N si M.\n\nPe a doua linie se afla N numere intregi, reprezentand stramosii tuturor membrilor, incepand cu membrul 1 si terminand cu membrul N. Daca un membru nu are stramos, atunci in fisier se va afla numarul 0.\n\nPe urmatoarele M linii se afla perechi de numere Q si P, reprezentand o intrebare de forma \"care este al P-lea stramos al membrului cu numar Q?\"\n\n\n\nFisier de iesire\n\nPe fiecare din cele M linii ale fisierului stramosi.out se vor afla raspunsurile la intrebari, adica numerele de ordine al stramosilor (sau 0 daca identitatea stramosului nu este cunoscuta)\n\nh2. Restrictii\n\nS 1 <= N <= 250.000\n\nS 1 <= M <= 300.000\n\nh2. Exemplu\n\nstramosi.in stramosi.out\n13 7 2\n\n0 1 2 2 4 1 6 0 8 8 10 10 12 1\n\n5 2 6\n\n3 2 0\n\n7 1 8\n\n1 3 0\n\n13 3 10\n\n9 2\n\n11 1\n\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"stramosi\")==',0,''),('problema/nrcuv','Lista lui Andrei','2006-11-12 14:03:05','==Include(page=\"template/taskheader\" task_id=\"nrcuv\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\n\r\nFiind foarte pasionat de civilizatiile extraterestre, Andrei a inceput sa studieze limba martienilor pentru a putea comunica usor cu ei atunci cand va fi cazul. Oricat s-a documentat el a putut afla doar ca toate cuvintele acestei limbi contin $N$ litere mici din alfabetul englez si a mai gasit o lista cu perechi de litere ce nu pot aparea pe pozitii vecine intr-un cuvant. Pentru ca are de gand sa studieze fonetica fiecarui cuvant posibil in parte, Andrei ar vrea mai intai sa vada cat de voluminoasa este munca pe care si-o propune si va roaga sa determinati cate cuvinte poate avea limba.\r\n\r\nh2. Cerinta\r\n\r\nDeterminati cate cuvinte de lungime $N$ se pot forma folosind doar litere mici ale alfabetului englez astfel incat oricare doua litere care formeaza o pereche in lista lui Andrei sa nu se afle pe pozitii vecine.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $nrcuv.in$ se afla numerele intregi $N$ si $M$, reprezentand numarul de litere din care este format un cuvant si numarul de perechi din lista lui Andrei. Urmatoarele $M$ linii contin o pereche de forma \"$l{~1~} l{~2~}$\" unde $l{~1~}$ si $l{~2~}$ sunt litere mici ale alfabetului englez.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul $nrcuv.out$ contine pe prima linie numarul cerut modulo $104659$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 1000$\r\n* $0 &le; M &le; 2000$\r\n* Pot exista perechi simetrice sau identice in lista\r\n* Doua pozitii sunt vecine daca modulul diferentei lor este $1$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. nrcuv.in |_. nrcuv.out |\r\n| 2 7\r\na a\r\na b\r\nb c\r\nc d\r\nc f\r\nb a\r\nc f\r\n| 667 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"nrcuv\")==',15,''),('problema/srevni','Srevni','2006-11-11 11:23:53','==Include(page=\"template/taskheader\" task_id=\"srevni\")==\n\n==Include(page=\"template/raw\")==\n\nSrevni\n\n\n\nPe planeta Srevni exista N orase legate intre ele prin strazi cu sens unic. Orasele sunt identificate prin numere cuprinse intre 1 si N.\nIn fiecare din aceste orase se produce un aliment foarte hranitor. Pretul de vanzare al alimentelor poate fi diferit de la oras la oras. Pentru a reduce costurile, transportul alimentelor se realizeaza astfel: o masina de comanda care trebuie sa alimenteze orasul i pleaca din orasul i spre orasul din care trebuie sa aduca alimentele. In momentul cand ajunge la destinatie este incarcata si teleportata in orasul i.\nIntr-o zi Regnos, conducatorul planetei, plictisindu-se se gandi ca ar fi bine sa stie care este cel mai mic pret de achizitie al alimentului pentru fiecare oras al planetei.\n\nDate de intare\n\nIn fisierul de intrare srevni.in vom avea pe prima linie doua numere intregi N si M. Pe linia urmaroate se vor afla N numere naturale separate intre ele prin spatii, care reprezinta preturile alimentelor in fiecare dintre cele N orase. Pe fiecare dintre urmatoarele M linii se vor afla cate doua numere intregi, separate intre ele printr-un spatiu, X si Y, cu semnificatia ca exista drum de la orasul X catre orasul Y.\n\nh2. Date de Iesire\n\nFisierul de iesire srevni.out va contine pe prima linie N numere separate intre ele prin spatii, care reprezinta cele mai mici preturi de achizitie ale alimentelor pentru fiecare dintre cele N orase.\n\nRestrictie\n\n1 <= N <= 100.000;\n1 <= M <= 100.000;\npreturile sunt numere naturale cuprinse intre 1 si 1.000.000.\n\nh2. Exemplu\n\n\n|srevni.in |srevni.out |\n\n|4 4 |1 2 2 3 |\n| | |\n|1 2 4 3 | |\n| | |\n|1 3 | |\n| | |\n|2 4 | |\n| | |\n|3 2 | |\n| | |\n|3 4 | |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"srevni\")==',0,''),('problema/perm','Permutari','2006-11-12 14:33:04','==Include(page=\"template/taskheader\" task_id=\"perm\")==\r\n\r\nO permutare de lungime N este un sir de elemente distincte din multimea {1,2,3 ... N}. Spunem ca o permutare are K maxime daca exista fix K pozitii distincte in permutare, pentru care elementul curent este mai mare decat toate elementele din stanga lui.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care determina cate permutari de lungime N cu K maxime exista.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierul perm.in se vor gasi numerele N si K, separate prin cate un spatiu.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierul perm.out se va gasi numarul de permutari de lungime N cu K maxime.\r\n\r\nh2. Restrictii\r\n\r\nS 1 <= K <= N <= 200\r\n\r\n\r\n\r\nExemple\r\n\r\nperm.in perm.out\r\n3 2 3\r\n\r\n\r\n\r\nperm.in perm.out\r\n5 3 35\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/perm/enunt.files/filelist.xml\r\n==Include(page=\"template/taskfooter\" task_id=\"perm\")==',961,''),('problema/soldati','Soldati','2006-11-11 11:23:47','==Include(page=\"template/taskheader\" task_id=\"soldati\")==\n\n==Include(page=\"template/raw\")==\n\nSoldati\n\n\n\nN soldati sunt asezati in linie, de la stanga la dreapta. O parte dintre soldati au fata indreptata catre dreapta, ceilalti catre stanga. In fiecare unitate de timp (incepand de la momentul de timp 0), daca 2 soldati de pe pozitii consecutive se uita unul catre celalalt (soldatul de pe pozitia din stanga se uita catre dreapta, iar soldatul de pe pozitia din dreapta se uita catre stanga), atunci ei se intorc in directii opuse (cel din stanga se intoarce cu fata catre dreapta, iar cel din dreapta se intoarce cu fata catre stanga). Toate perechile de soldati care se afla fata in fata se intorc in directii opuse simultan (in aceeasi unitate de timp). In mod evident, dupa un anumit numar de unitati de timp, nu vor mai exista perechi de soldati care se afla fata in fata (si, deci, nu se vor mai efectua intoarceri).\n\nScrieti un program care determina dupa cate unitati de timp nu se mai efectueaza intoarceri.\n\nh2. Date de Intrare\n\n\n\nPrima linie a fisierului soldati.in contine numarul intreg T reprezentand numarul de teste din fisier. Pe urmatoarele T linii se afla cate un sir de caractere din multimea {`<\', `>\'}, care nu contine spatii si care este terminat cu caracterul de sfarsit de linie. Un caracter `<\' denota un soldat cu fata indreptata spre stanga, iar un caracter `>\' denota un soldat cu fata indreptata spre dreapta. Caracterele care descriu soldatii sunt scrise pe linie in ordinea in care se afla soldatii asezati in sir (de la stanga la dreapta).\n\nh2. Date de Iesire\n\n\n\nPentru fiecare din cele T teste, afisati in fisierul de iesire soldati.out o linie care contine un numar intreg, reprezentand numarul de unitati de timp dupa care nu se mai efectueaza nici o intoarcere in cazul testului respectiv.\n\nh2. Restrictii si precizari:\n\n. 1 <= T <= 10\n\n. Pe o linie se afla maxim 100.000 de caractere din multimea {`<\',\'>\'}\n\n. Pentru 20% din fisierele de test sirurile vor avea maxim 1000 de caractere\n\nh2. Exemplu:\n\n\n\nsoldati.in soldati.out\n3 0\n\n<<<>>> 4\n\n>>>>< 5\n\n>>><<<\n\n\n==Include(page=\"template/taskfooter\" task_id=\"soldati\")==',0,''),('problema/regine','Regine','2006-11-12 15:03:55','==Include(page=\"template/taskheader\" task_id=\"regine\")==\r\n\r\nPe o tabla triunghiulara de latura $N$, trebuiesc asezate cat mai multe regine, astfel incat acestea sa nu se atace.\r\n\r\nO tabla triunghiulara, de latura $N$, are $N$ linii. Pe linia $i$ sunt $i$ locuri in care reginele pot sta, iar locurile sunt asezate sub forma de triunghi, ca in figura de mai jos. Fiind vorba de o tabla mai speciala si reginele sunt speciale, in sensul ca ele se pot deplasa (ataca) in $6$ directii.\r\n\r\nIn figura de mai jos este reprezentata o tabla de latura $6$, cu o regina pe linia $5$, coloana $4$. Numerotarea liniilor si coloanelor incepe de la $1$ (din varful tablei in jos - pentru linii si de la stanga la dreapta pentru coloane).\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul maxim de regine ce pot fi asezate pe o tabla de dimensiune $N$ si o asezare posibila a lor (oricare dintre solutiile cu numar maxim).\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului se afla un numar natural $N$, reprezentand dimensiunea tablei.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul va contine pe prima linie un singur numar intreg, $X$, reprezentand numarul maxim de regine ce pot fi asezate. Pe urmatoarele $X$ linii se vor scrie cate $2$ numere separate de un singur spatiu, reprezentand linia si respectiv coloana reginelor.\r\n\r\nh2. Restrictii\r\n\r\n* $1 < N < 1 001$\r\n* daca un test are numarul corect de regine, dar configuratia reginelor nu este valida, se acorda $30%$ din punctajul testului.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. regine.in |_. regine.out |\r\n| 3\r\n| 2\r\n2 1\r\n3 3 |\r\n\r\nh3. Explicatii\r\n\r\nPutem aseza maxim $2$ regine: una pe linia $2$, coloana $1$ si una pe linia $3$, coloana $3$.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"regine\")==',18,''),('problema/puternic','Puternic','2006-11-11 11:23:56','==Include(page=\"template/taskheader\" task_id=\"puternic\")==\n\n==Include(page=\"template/raw\")==\n\nputernic\n\nNumerele puternice sunt acele numere naturale care au numarul divizorilor mai mare decat numarul divizorilor oricarui numar natural mai mic decat numarul respectiv. De exemplu, primele 4 numere puternice sunt 1, 2, 4 si 6.\n\nh2. Cerinta\n\nSa se determine cel de-al N-lea numar puternic.\n\nh2. Date de Intrare\n\nFisierul de intrare puternic.in contine pe prima linie numarul N.\n\nh2. Date de Iesire\n\nFisierul de iesire puternic.out contine pe prima si singura linie al N-lea numar puternic.\n\nh2. Restrictii\n\no 1 <= N < 181\n\nh2. Exemplu\n\n\n\nputernic.in puternic.out\n3 4\n\n\n==Include(page=\"template/taskfooter\" task_id=\"puternic\")==',0,''),('problema/pietre','Pietre','2006-11-11 11:23:34','==Include(page=\"template/taskheader\" task_id=\"pietre\")==\n\n==Include(page=\"template/raw\")==\n\nLink: [1]File-List\n\nPietre\n\n\n\nMacarie si Petronela joaca un joc foarte interesant care, spera ei, le va dezvolta inteligenta si mai mult. Astfel ei au in fata doua gramezi de pietre (cu A respectiv B pietre fiecare). Jocul se desfasoara alternativ (Macarie incepe), iar la un moment dat un jucator poate lua un numar oarecare de pietre dintr-o gramada sau poate lua acelasi numar de pietre din ambele gramezi. Pierde cel care nu mai poate lua pietre.\n\nh2. Cerinta\n\nVa trebui sa aflati castigatorul pentru T jocuri stiind ca mereu Macarie incepe jocul.\n\nh2. Date de Intrare\n\nPrima linie a fisierului pietre.in contine numarul T de teste. Urmatoarele T linii contin cate 2 numere intregi A si B seperate prin cate un spatiu care descriu numarul de pietre din cele doua gramezi.\n\nh2. Date de Iesire\n\nFisierul pietre.out va contine T linii corespunzatoare celor T teste cu valoarea 1 daca la testul respectiv castiga Macarie si 2 daca invinge Petronela.\n\nh2. Restrictii si precizari\n\nS 1 <= A, B <= 1.000.000\n\nS 1 <= T <= 10\n\n\n\nExemple\n\npietre.in pietre.out\n2 2\n1 2 1\n2 3\n\n\n\nExplicatii\n\nIn primul test Macarie poate lua 1 piatra din oricare gramada, 2 pietre din a doua gramada sau o piatra din ambele gramezi, in toate cazurile Petronela putand lua toate pietrele ramase castigand jocul.\n\nIn testul 2 Macarie castiga luand 2 pietre din a doua gramada si Petronela va pierde conform acelorasi considerente de la exemplul 1.\n\nReferences\n\nVisible links\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/pietre/pietre.files/filelist.xml\n==Include(page=\"template/taskfooter\" task_id=\"pietre\")==',0,''),('problema/hotel','Hotel','2006-11-12 15:13:31','==Include(page=\"template/taskheader\" task_id=\"hotel\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\n\r\nHotelul \"Informatica\" este unul dintre cele mai luxoase hoteluri din Galaciuc. De-a lungul anului multe grupuri de turisti sosesc la acest hotel sau il parasesc la sfarsitul sejurului, asa ca situatia exacta a camerelor libere si ocupate este destul de greu de aflat, mai ales ca hotelul are un numar mare de camere. Dar anul acesta proprietarul hotelului s-a decis ca are nevoie de o schimbare. De aceea v-a angajat pe dumneavoastra pentru a scrie un program eficient, care sa raspunda necesitatilor sale.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa trateze in mod eficient urmatoarele $3$ tipuri de instructiuni:\r\n\r\n* tipul $1$: sosirea unui grup nou de turisti\r\n\r\nUn grup de turisti avand $M$ membri vrea sa ocupe $M$ camere libere numerotate consecutiv. Programului $i$ se va furniza numarul $i$ al camerei de inceput al secventei de camere ocupate de grup si numarul $M$ de membri ai grupului. Se garanteaza ca oricare din camerele $i,i+1,.., i+M-1$ este libera la momentul respectiv.\r\n\r\n* tipul $2$: plecarea unui grup de turisti\r\n\r\nAtunci cand pleaca, turistii pleaca in grupuri (nu neaparat cele cu care au venit). Un grup care pleaca si care are $M$ membri paraseste $M$ camere (anterior ocupate) numerotate consecutiv. Programului $i$ se va furniza numarul $i$ al camerei de inceput al secventei de camere eliberate, precum si numarul $M$ de membri ai grupului. Se garanteaza ca toate camerele cu numerele de ordine $i,i+1,..,i+M-1$ sunt deja ocupate de turisti.\r\n\r\n* tipul $3$: intrebarea proprietarului\r\n\r\nProprietarul hotelului poate sa intrebe, din cand in cand, care este lungimea maxima a unei secvente de camere libere numerotate consecutiv. El are nevoie de acest numar pentru a putea sti care este numarul maxim posibil de membri ai unui grup care ar putea fi cazati la hotelul \"Informatica\".\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $hotel.in$ se vor afla numerele $N$ si $P$, reprezentand numarul de camere ale hotelului (numerotate de la $1$ la {$N$}), respectiv numarul de instructiuni care urmeaza.\r\nPe fiecare din urmatoarele $P$ linii se va afla un numar $c$, reprezentand tipul instructiunii ce va fi descrisa pe linia respectiva:\r\n\r\n* daca $c$ are valoarea $1$, atunci el va fi urmat (pe aceeasi linie) de alte $2$ numere, $i$ si $M$, reprezentand numarul primei camere distribuite grupului abia sosit si numarul de membri ai grupului\r\n* daca $c$ are valoarea $2$, atunci el va fi urmat (pe aceeasi linie) de alte $2$ numere, $i$ si $M$, reprezentand numarul primei camere care va fi eliberata de grupul care tocmai pleaca, precum si numarul de membri ai grupului care paraseste hotelul\r\n* daca $c$ are valoarea $3$, el nu va fi urmat de nici un alt numar pe linia respectiva; programul va trebui, insa, sa afiseze in fisierul de iesire lungimea maxima a unei secvente de camere libere numerotate consecutiv.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul hotel.out veti afisa, pentru fiecare instructiune de tipul 3, pe cate o linie separata, lungimea maxima a unei secvente de camere libere numerotate consecutiv, luand in considerare instructiunile de tipul 1 si 2 aflate in fisierul de intrare inaintea instructiunii de tip 3 la care se raspunde. Inaintea primei instructiuni, toate camerele sunt libere.\r\n\r\nh2. Restrictii si precizari\r\n\r\nS 3 <= N <= 100.000\r\n\r\nS 3 <= P <= 200.000\r\n\r\nS In orice camera poate fi cazat la un moment dat un singur turist.\r\n\r\nh2. Exemplu\r\n\r\nhotel.in hotel.out\r\n\r\n12 10 12\r\n\r\n3 4\r\n\r\n1 2 3 4\r\n\r\n1 9 4 6\r\n\r\n3 10\r\n\r\n2 2 1\r\n\r\n3\r\n\r\n2 9 2\r\n\r\n3\r\n\r\n2 3 2\r\n\r\n3\r\n==Include(page=\"template/taskfooter\" task_id=\"hotel\")==',15,''),('problema/sah','Sah','2006-11-12 15:21:56','==Include(page=\"template/taskheader\" task_id=\"sah\")==\r\n\r\n\r\nCiobanasul Eduard are o tabla de sah de dimensiuni $N X N$. El cauta o modalitate de a imparti tabla de sah in cat mai multe regiuni dreptunghiulare (cu laturile paralele cu axele de coordonate) disjuncte, astfel incat toate regiunile sa aibe arii diferite, iar intr-o regiune numarul casutelor albe sa fie egal cu numarul casutelor negre. Deoarece vrea sa se intoarca cat mai repede la oitele sale Eduard va cere voua ajutorul.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se $N$ dimensiunea tablei de sah ajutati-l pe Eduard sa gaseasca o impartire in regiuni.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $sah.in$ se afla $N$, dimensiunea tablei de sah.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $sah.out$ va contine $N$ linii cu cate $N$ numere naturale. Al $j$-lea numar de pe linia $i$ va reprezenta regiunea din care face parte casuta de la coordonatele $i, j$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 1000$\r\n* $N$ este par\r\n* Fiecare casuta face parte dintr-o singura regiune\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. sah.in |_. sah.out |\r\n| 4\r\n| 1 1 1 1\r\n1 1 1 1\r\n2 3 3 3\r\n2 3 3 3 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sah\")==',15,''),('problema/poligon2','Poligon 2','2006-11-11 11:23:44','==Include(page=\"template/taskheader\" task_id=\"poligon2\")==\n\n==Include(page=\"template/raw\")==\n\nPoligon 2\n\nGigel a desenat pe hartie un poligon (nu neaparat convex si care se poate chiar autointersecta) cu N varfuri si a marcat mijlocul fiecarei laturi. Fratele lui, insa, a sters poligonul desenat, pe hartie ramanand marcate numai mijloacele laturilor. Gigel ar dori, totusi, sa redeseneze poligonul, asa cum era el initial. Se considera ca poligonul are varfurile numerotate de la 1 la N, in ordinea in care apar pe conturul poligonului. Cu aceasta numerotare a varfurilor, se defineste si o numerotare a laturilor. Latura i (1<=i<N) este segmentul ce uneste varfurile i si i+1. Latura N uneste varfurile 1 si N.\n\nh2. Cerinta\n\nDandu-se coordonatele mijloacelor laturilor unui poligon, determinati coordonatele varfurilor sale.\n\nh2. Date de Intrare\n\nPe prima linie a fisierului de intrare poligon2.in se afla numarul intreg N, de laturi (si varfuri) ale poligonului. Pe urmatoarele N linii se afla cate doua numere reale (cu maxim trei zecimale), separate printr-un spatiu, x si y, reprezentand coordonatele mijloacelor fiecarei laturi, in ordine, de la 1 la N.\n\nh2. Date de Iesire\n\nFisierul de iesire poligon2.out va contine mesajul \"fara solutie\", in cazul in care Gigel a marcat gresit mijloacele laturilor si nu se poate forma nici un poligon avand mijloacele laturilor date. In cazul in care exista cel putin o solutie, veti afisa N linii. Fiecare linie va contine doua numere reale, afisate cu trei zecimale, reprezentand coordonatele (x,y) ale unui varf. Pe prima linie se vor afisa coordonatele varfului numerotat cu 1, pe a doua linie, coordonatele varfului numerotat cu 2 s.a.m.d.\n\nh2. Restrictii\n\n. 3 <= N <= 10.000\n\n. Coordonatele mijloacelor laturilor sunt din intervalul [0,2.000.000.000].\n\n. In cazul in care problema admite cel putin o solutie, cu coordonatele varfurilor afisate in fisierul de iesire, se va calcula, pentru fiecare latura, coordonatele mijlocului acesteia. Veti primi punctaj maxim pentru testul respectiv, daca diferenta dintre valoarile calculate ale coordonatelor mijlocului si cele date in fisierul de intrare este cel mult 0.001, pentru oricare latura. Altfel, nu veti primi nici un punct.\n\n\n\nExemple\n\n\n|poligon2.in |poligon2.out |\n\n|4 |-1.000 1.000 |\n|0 0 | 1.000 -1.000 |\n|2 0 | 3.000 1.000 |\n|2 2 | 1.000 3.000 |\n|0 2 | |\n\n|4 |fara solutie |\n|0 0 | |\n|2 0 | |\n|2 2 | |\n|1 3 | |\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"poligon2\")==',0,''),('problema/pavare2','Pavare2','2006-11-11 11:23:49','==Include(page=\"template/taskheader\" task_id=\"pavare2\")==\n\n==Include(page=\"template/raw\")==\n\nLink: [1]File-List\n\nPavare2\n\n\n\nIn orasul Z exista un bulevard de latime 1 metru si lungime N metri care trebuie pavat. Primaria orasului dispune de placi albe si negre de 1 metru lungime si 1 metru latime in scopul pavarii bulevardului. Dupa cum va imaginati, bulevardul va fi pavat prin asezarea a N placi din stocul primariei. Pentru a alege cea mai buna metoda de pavare, primarul vrea mai intai sa stie cate moduri de pavare sunt astfel incat sa nu existe mai mult de A placi consecutive de culoare alba si B placi consecutive de culoare neagra pe bulevard. Primarul vrea sa afle apoi care este a K-a posibilitate de pavare in ordine lexicografica, stiind ca o placa alba e mai mica din punct de vedere lexicografic decat o placa neagra.\n\nh2. Cerinta\n\nDandu-se numarul N ce reprezinta lungimea bulevardului si numerele A, B si K se cere sa se afle numarul de posibilitati de pavare ce respecta conditiile din enunt. De asemenea, se cere sa se afiseze a K-a posibilitate de pavare in ordine lexicografica, codificand cu `0\' o placa alba si cu `1\' o placa neagra.\n\nh2. Date de Intrare\n\nPe prima linie a fisierului pavare2.in se gasesc numerele N, A, B, separate prin spatii. Pe cea de-a 2-a linie a fisierului se gaseste numarul K.\n\nh2. Date de Iesire\n\nPe prima linie a fisierului pavare2.out se gaseste un singur numar ce reprezinta numarul de posibilitati de pavare, iar pe cea de-a doua linie trebuie sa se afiseze pavarea ceruta codificata ca in enunt, fara a afisa spatii intre caracterele de `0\' si `1\'.\n\nh2. Restrictii si precizari\n\n- 1 <= N <= 100\n\n- 1 <= A, B <= N\n\n- se garanteaza ca exista cel putin K modalitati de a pava bulevardul si K >= 1\n\n- pentru 50 de puncte se garanteaza K = 1\n\nh2. Exemplu\n\npavare2.in pavare2.out Explicatii\n4 2 3 12 Cele 12 posibilitati de pavare sunt, in ordine lexicografica :\n\n7 1001 0010,\n\n0011\n\n0100\n\n0101\n\n0110\n\n0111\n\n1001\n\n1010\n\n1011\n\n1100\n\n1101\n\n1110\n\nSe observa ca a 7-a posibilitate de pavare este 1001.\n\n\n\nReferences\n\nVisible links\n1. file:///home/eval/eval/www/infoarena/docs/arhiva/pavare2/enunt_files/filelist.xml\n==Include(page=\"template/taskfooter\" task_id=\"pavare2\")==',0,''),('problema/robot','Robot','2006-11-11 11:23:39','==Include(page=\"template/taskheader\" task_id=\"robot\")==\n\n==Include(page=\"template/raw\")==\n\nrobot\n\nGigel tocmai si-a cumparat un joc de strategie. Actiunea jocului ia loc pe o harta plana. Pe harta se gaseste un mic robotel si cateva obstacole. Scopul jocului este de a muta robotelul intr-un anumit loc. Fiindca nu se pricepe prea bine la jocuri pe calculator, Gigel va roaga sa-l ajutati.\n\nRobotelul si obstacolele sunt reprezentate de poligoane convexe, cu varfurile in puncte de coordonate intregi. Spunem ca robotelul se afla intr-o pozitie valida pe harta daca poligonul care il reprezinta nu se intersecteaza cu interiorul nici unui obstacol. Daca robotelul este tangent la unul sau mai multe obstacole, fara a intersecta insa interiorul nici unuia dintre ele, pozitia lui este valida.\n\nPe tot parcursul jocului obstacolele raman nemiscate si nerotite. De asemenea, robotelul nu se poate roti, insa acesta se poate misca in orice directie. Pe tot parcursul miscarii sale, robotelul trebuie sa ramana intr-o pozitie valida.\n\nPozitia robotelului pe harta se defineste ca fiind punctul (x,y), cu y egal cu minimul ordonatelor varfurilor robotelului si cu x egal cu minimul absciselor varfurilor robotelului. Curba desenata de pozitia robotelului in timpul miscarii sale in plan se numeste drumul robotelului.\n\nh2. Cerinta\n\nScrieti un program care citeste configuratia initiala a hartii si care calculeaza lungimea unui drum minim parcurs de robotel pentru a ajunge intr-o pozitie finala.\n\nh2. Date de Intrare (fisier: robot.in)\n\nPe prima linie a fisierului de intrare se gaseste numarul N de varfuri ale poligonului reprezentand robotelul. Pe urmatoarele N linii se gasesc coordonatele x si y ale varfurilor robotelului, coordonate separate printr-un spatiu. Pe urmatoarea linie se gaseste numarul M de obstacole. Apoi urmeaza M blocuri reprezentand cate un obstacol, fiecare bloc avand urmatoarea structura:\n\n- pe prima linie a blocului numarul de varfuri P ale poligonului ce reprezinta obstacolul\n\n- pe urmatoarele P linii, coordonatele x si y ale varfurilor obstacolului, coordonate separate printr-un spatiu.\n\nPe ultima linie a fisierului de intrare, se gasesc coordonatele x si y ale pozitiei in care trebuie sa ajunga robotelul.\n\nh2. Date de Iesire (fisier: robot.out)\n\nPe singura linie a fisierului de iesire afisati cu doua zecimale exacte distanta minima parcursa de robot pana la pozitia finala pe un drum care respecta cerintele de mai sus. Daca nu exista nici un astfel de drum afisati -1.\n\nh2. Restrictii si precizari\n\no N -L- 10, M -L- 25, toate coordonatele sunt din intervalul (-5000,5000)\no numarul de varfuri de pe poligoanele tuturor obstacolelor nu depaseste 250.\no puteti presupune ca pozitia initiala a robotelului este valida.\no in fisierul de intrare, pentru toate poligoanele, punctele sunt date in sens trigonometric.\no solutia afisata de voi este considerata corecta daca difera de solutia comisiei in valoare absoluta prin cel mult 0.02\no unii sustin ca adevaratul campion este cel care rezolva ivv; adevarul este insa ca singurul care poate determina adevaratul campion este robotelul.\n\nh2. Exemplu\n\nrobot.in robot.out Explicatie\n3 7.24 Desenul alaturat este reprezentarea grafica a exemplului din stanga. Robotelul apare punctat si obstacolul este desenat cu linie ingrosata. Cerculetul reprezinta pozitia finala a robotelului. Cu o linie usor ingrosata este marcat si un drum de lungime minima.\n\n0 0\n\n2 0\n\n0 2\n\n1\n\n4\n\n3 0\n\n5 0\n\n5 2\n\n3 2\n\n6 2\n\n\n\n\n==Include(page=\"template/taskfooter\" task_id=\"robot\")==',0,''),('problema/lapte','Lapte','2006-11-12 15:42:45','==Include(page=\"template/taskheader\" task_id=\"lapte\")==\r\n\r\nHaralambie este un mare bautor de lapte. Impreuna cu prietenii sai organizeaza adesea petreceri salbatice, in care se intrec in bautul laptelui. De data aceasta ei au organizat un joc. Ei au doua feluri de lapte : $lapte A$ si $lapte B$. In aceasta noapte si-au propus sa bea cel putin $L$ litri din fiecare fel. Dar mai e putin si se face dimineata, parintii lui Haralambie se intorc acasa si petrecerea se sparge. Ajutati-i sa bea cat mai repede.\r\n\r\nh2. Cerinta\r\n\r\nSe cunoaste viteza cu care fiecare persoana bea un litru din $laptele A$ si $laptele B$. Trebuie planificata o strategie astfel incat la sfarsitul petrecerii sa fi baut cel putin $L$ litri din $laptele A$ si cel putin $L$ litri din $laptele B$, iar timpul total sa fie minim. O persoana nu poate bea din doua tipuri de lapte in acelasi timp.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $lapte.in$ sunt scrise numerele $N$ (numarul persoane participante) si $L$ (cantitatea minima de lapte ce trebuie bauta pana la sfarsitul petrecerii). Pe urmatoarele $N$ linii sunt date perechi de numere naturale nenule $a b (1 &le; a, b &le; 100)$ reprezentand timpul in care persoana corespunzatoare bea $1$ litru de $lapte A$, respectiv timpul in care bea $1$ litru de $lapte B$.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie a fisierului $lapte.out$ va contine un singur numar $T$ - timpul minim in care se va bea cantitatea ceruta de lapte. Pe urmatoarele $N$ linii vor fi perechi de numere naturale. Linia $i + 1$ va contine numerele $x y$ , reprezentand cantitatea de $lapte A$, respectiv cantitatea de $lapte B$ pe care o bea persoana $i$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, T, L &le; 100$\r\n* Cantitatea de lapte disponibila se considera nelimitata\r\n* Consumul excesiv de lapte duce la epuizarea bauturii\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. lapte.in |_. lapte.out | explicatii |\r\n| 3 20\r\n1 1\r\n2 4\r\n1 6\r\n| 18\r\n0 18\r\n5 2\r\n18 0 \r\n| Timpul minim este 18. \r\nCantitatea de lapte A bauta este 0+5+18=23.\r\nCantitatea de lapte B bauta este 18+2=20.\r\nPersoana 1 termina de baut in 1*0+1*18=18 minute.\r\nPersoana 2 termina in 2*5+4*2=18 minute.\r\nPersoana 3 termina in 1*18+6*0=18 minute.\r\nTimpul minim dupa care petrecerea va lua sfarsit este max(18,18,18)=18 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"lapte\")==',18,''),('problema/12perm','12-Perm','2006-11-11 14:10:33','==Include(page=\"template/taskheader\" task_id=\"12perm\")==\r\n\r\nSe defineste 12-permutarea $A{~1~},A{~2~},...,A{~N~}$ ca fiind o permutare a numerelor $1,2,...,N$ astfel incat $|A{~i~} - A{~i+1~}|$ pentru $i=1,2,...,N-1$.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un numar natural $N$ calculati numarul de 12-permutari de lungime $N$.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului de intrare $12perm.in$ contine numarul natural $N$ cu semnificatia de mai sus.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $12perm.out$ veti afisa $X$ numarul de 12-permutari de lungime $N$ modulo $1048576$.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 15.000.000$\r\n* $1048576 = 2^20^$\r\n* Pentru $70%$ din teste $N &le; 5.500.000$.\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. 12perm.in |_. 12perm.out |\r\n| 4 | 12 |\r\n\r\n\r\n\r\n\r\nh2. Explicatii\r\n\r\nCele $12$ 12-permutari sunt: $1 2 3 4, 1 2 4 3, 1 3 2 4, 1 3 4 2, 2 1 3 4, 2 4 3 1, 3 1 2 4, 3 4 2 1, 4 2 1 3, 4 2 3 1, 4 3 1 2, 4 3 2 1$\r\n==Include(page=\"template/taskfooter\" task_id=\"12perm\")==',961,''),('sandbox','Sandbox','2006-11-12 16:00:44','== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==',18,''),('problema/farfurii','Farfurii','2006-11-12 11:56:12','==Include(page=\"template/taskheader\" task_id=\"farfurii\")==\r\n\r\nIn fiecare zi Zaharel este obligat de Eugenia sa spele farfuriile si tacamurile dupa fiecare masa. Dupa ce le spala el trebuie sa le aranjeze pe doua rafturi, farfuriile pe primul si tacamurile pe al doilea... dar nu oricum! El are $N$ farfurii de marimi distincte, cuprinse intre $1$ si $N$ si $K$ tacamuri identice. Pentru fiecare pereche de farfurii asezate in raft astfel incat farfuria de marime mai mare, dintre cele doua, apare inaintea farfuriei de marime mai mica, Zaharel pune un tacam pe randul al doilea.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Zaharel sa aseze toate farfuriile pe primul raft astfel incat sa puna toate tacamurile pe al doilea raft. Dintre toate asezarile posibile determinati-o pe aceea minim lexicografica din punct de vedere al marimilor.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie din fisierul de intrare $farfurii.in$ se gasesc numerele naturale $N$ si {$K$}.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie din fisierul de iesire $farfurii.out$ se vor gasi $N$ numere distincte intre $1$ si $N$ reprezentand marimile farfuriilor, afisate in ordinea in care au asezate pe raft.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 100.000$\r\n* $0 &le; K &le; N*(N-1)/2$\r\n* Pentru cel putin $40%$ din teste $N &le; 2.000$\r\n* O asezare ({$A{~1~},A{~2~}...A{~N~}$}) este mai mica din punct de vedere lexicografic decat o alta asezare ({$B{~1~},B{~2~}...B{~N~}$}) daca exista o pozitie $p$ astfel incat $A{~p~}<B{~p~}$ si $A{~1~}=B{~1~}, A{~2~}=B{~2~}, ... A{~p-1~}=B{~p-1~}$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. farfurii.in |_. farfurii.out |_. Explicatii |\r\n| 7 8\r\n| 1 2 5 7 6 4 3\r\n| Pentru perechile  de farfurii din asezare \r\n({*5 4*}) ({*5 3*}) ({*7 6*}) ({*7 4*}) ({*7 3*}) ({*6 4*}) ({*6 3*}) ({*4 3*}) \r\nZaharel pune cate un tacam pe randul al doilea.\r\nO alta asezare posibila este \r\n{*1 2 6 5 7 4 3*}\r\ndar aceasta este mai mare lexicografic |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"farfurii\")==',961,''),('problema/asmin','Asmin','2006-11-12 16:08:53','==Include(page=\"template/taskheader\" task_id=\"asmin\")==\r\n\r\nSe considera un arbore (graf conex aciclic) cu $N$ varfuri, fara radacina fixata. Drept radacina, poate fi ales oricare dintre varfuri. Sa presupunem ca a fost ales varful cu numarul {$T$}. Intre oricare varf si $T$ exista un drum unic care contine fiecare varf al arborelui cel mult o singura data (un drum intre varfurile $i$ si $j$ este o secventa de varfuri, care incepe cu {$i$}, se termina cu {$j$}, iar intre oricare doua varfuri consecutive exista o muchie in arbore). Fiecarui varf {$i$}(inclusiv {$T$}) trebuie sa i se asocieze o valoare {$V{~i~}$}, mai mare sau egala cu {$0$}, astfel incat suma valorilor varfurilor de pe drumul dintre $i$ si radacina {$T$}, impartita la {$K$}, sa dea restul {$R{~i~}$}. Se defineste costul arborelui cu radacina fixata in {$T$}, {$C{~T~}$}, ca fiind suma valorilor asociate fiecarui nod. Dintre toate posibilitatile de alegere a valorilor $V{~i~}$ care respecta conditia precizata anterior, se va alege aceea pentru care $C{~T~}$ este minim.\r\nSe constata usor ca alegand alt varf drept radacina, de exemplu, varful {$S$}(diferit de {$T$}), $C{~S~}$ nu este neaparat egal cu {$C{~T~}$}.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un arbore cu $N$ varfuri, un numar intreg $K$ si valorile {$R{~i~}$}, {$i=1,2,..,N$}, corespunzatoare fiecarui varf, determinati acele varfuri $T$ care pot fi alese drept radacina, pentru care costul $C{~T~}$ este minim (adica {$C{~T~} &le; C{~S~}$}, oricare ar fi $S$ diferit de {$T$}), precum si costul respectiv.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $asmin.in$ se afla doua valori intregi: $N$ si {$K$}. Pe urmatoarele $N-1$ linii se afla cate doua numere intregi {$a b$}, separate printr-un spatiu, avand semnificatia ca exista muchie intre varfurile $a$ si {$b$}. Varfurile sunt numerotate de la $1$ la {$N$}. Pe urmatoarea linie se afla $N$ numere intregi, reprezentand valorile {$R{~i~}$}, {$i=1,2,..,N$}.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie a fisierului de iesire $asmin.out$ se vor afisa doua valori intregi: $C$ si {$M$}. $C$ reprezinta costul minim posibil al arborelui. $M$ reprezinta numarul de varfuri care pot fi alese drept radacina si pentru care se obtine costul {$C$}. Pe a doua linie se afla $M$ numere intregi separate prin cate un spatiu, scrise in ordine crescatoare, reprezentand numerele varfurilor ce pot fi alese ca radacina astfel incat sa se obtina costul {$C$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 16.000$\r\n* $2 &le; K &le; 1.000$\r\n* $0 &le; R{~i~} &le; K-1$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. asmin.in |_. asmin.out |\r\n| 5 3\r\n1 2\r\n1 3\r\n2 4\r\n2 5\r\n0 1 2 1 0\r\n| 5 2\r\n1 5\r\n| \r\n\r\nh3. Explicatii\r\n\r\nValorile asociate varfurilor celor doi arbori sunt  urmatoarele:\r\n$V{~1~}=0   V{~2~}=1  V{~3~}=2   V{~4~}=0   V{~5~}=2$\r\n$V{~1~}=2   V{~2~}=1  V{~3~}=2   V{~4~}=0   V{~5~}=0$\r\n\r\n\r\n \r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"asmin\")==',1,''),('problema/numere2','Numere 2','2006-11-11 18:13:24','==Include(page=\"template/taskheader\" task_id=\"numere2\")==\r\n\r\nDanut a invatat la scoala la ora de matematica despre numere prime. Acum el vrea sa dezvolte un algoritm eficient de verificare a primalitatii. Avand un numar natural $P$, el stie ca $P$ nu este prim daca exista numerele naturale $A$ si $B$ astfel incat $A$ ridicat la puterea $B$ este egal cu $P$ si $B$ este mai mare ca $1$. Danut ar vrea sa stie care este cel mai mic $A$ pentru care exista un numar $B$ astfel incit $A^B^=P$.\r\n\r\nh2. Cerinta\r\n\r\nFiind dat numarul $P$, aflati $A$ si Bastfel incit $A^B^=P$.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul $numere2.in$ se afla pe prima linie scris numarul $P$ fara spatii intre cifre.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $numere2.out$ va contine pe prima linie numarul $A$, iar pe a doua linie numarul $B$. Numerele vor fi afisate fara spatii intre cifre.\r\n\r\nh2. Restrictii\r\n\r\n* $0 < P < 10^100^$ (adica $P$ are cel mult $100$ cifre)\r\n* pentru $50%$ din teste $0 < P < 10^9^$\r\n* $A$ trebuie sa fie minim\r\n* $B$ poate fi egal cu $1$\r\n* $A, B, P$ sunt numere intregi pozitive\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. numere2.in |_. numere2.out |_. Explicatii  |\r\n| 81\r\n| 3\r\n  4\r\n| 3^4=81 |\r\n| 17\r\n| 17\r\n  1\r\n| 17^1^=17 |\r\n| 9904578032905937\r\n| 17\r\n  13\r\n| 17^13^ = 9904578032905937 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"numere2\")==',48,''),('problema/parcele','Parcele','2006-11-11 19:22:47','==Include(page=\"template/taskheader\" task_id=\"parcele\")==\r\n\r\nPe o campie intinsa se afla $N$ copaci situati in puncte de coordonate intregi. Fermierul Ion doreste sa cumpere cateva parcele pe acea campie. Ion poate cumpara numai parcele de forma dreptunghiulara, cu laturile paralele cu axele de coordonate de pe harta zonei, cu dimensiunile intregi fixate ($DX$ pentru axa $OX$ si $DY$ pentru axa $OY$) si avand colturile situate in puncte de coordonate intregi. Cumpararea unei parcele va trece in proprietatea lui Ion interiorul ei (se considera ca laturile parcelei fac parte din interior).\r\n\r\nNumarandu-si banii, Ion s-a hotarat sa cumpere exact DOUA parcele care, evident, sa nu aiba nici un punct comun. Deoarece lui Ion ii plac foarte mult copacii, el isi va alege o modalitate de amplasare a celor doua parcele astfel incat in interiorul lor (inclusiv pe laturi) sa se afle cat mai multi copaci. In acest scop, Ion va cere ajutorul.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care sa determine o modalitate de amplasare a parcelelor, astfel incat Ion sa detina cat mai multi copaci!\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul de intrare $parcele.in$ contine:\r\n- pe prima linie doua numere intregi $DX$ si $DY$, reprezentand dimensiunile unei parcele;\r\n- pe cea de a doua linie un numar intreg $N$, reprezentand numarul de copaci;\r\n- pe fiecare dintre urmatoarele $N$ linii cate doua numere intregi $X[i]$ si $Y[i]$, reprezentand coordonatele copacului cu numarul $i$.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $parcele.out$ veti afisa pe prima linie numarul maxim de copaci pe care ii poate detine Ion.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; DX, DY &le; 99.999$\r\n* 1 &le; N &le; 100.000\r\n* coordonatele copacilor sunt numere intregi intre $0$ si $99999$ inclusiv\r\n* nu exista doi copaci situati in acelasi punct\r\n* parcelele pot fi plasate oriunde, cu conditia ca sa nu se intersecteze\r\n\r\nh2. Exemplu\r\n\r\n\r\ntable(example). |_. parcele.in |_. parcele.out |_. Explicatii |\r\n| 2 1\r\n7\r\n0 0\r\n1 0\r\n1 1\r\n3 0\r\n3 1\r\n4 0\r\n1000 1000\r\n| 6\r\n| O solutie posibila este:\r\n&#8211;        prima parcela are colturile (-1, 0) si (1, 1)\r\n&#8211;        a doua parcela are colturile (3, 0) si (5, 1) |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"parcele\")==',48,''),('problema/mult','Mult','2006-11-11 17:02:52','==Include(page=\"template/taskheader\" task_id=\"mult\")==\r\n\r\nDoi copii (a caror identitate nu va fi dezvaluita pentru a le proteja intimitatea) au ajuns sa se joace cu o foaia de hartie pe care era scris un numar cu $N$ cifre. Primul dintre ei, din lipsa de ocupatie, anunta ca a aflat ca sunt $X$ moduri prin care se poate obtine un multiplu al unui numar $K$ din numarul de pe foaie, stergand una, mai multe sau nici o cifran din el. Cel de-al doilea sustine ca sunt $Y$ moduri si in felul acesta cei doi copii au inceput sa se certe toata ziua.\r\n\r\nh2. Cerinta\r\n\r\nAflati numarul de posibilitati de a obtine un multiplu a lui $K$ din numarul initial daca singura operatie permisa este stergerea unei cifre pentru ca cei doi copii sa se impace.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $mult.in$ contine doua numere intregi $N$ si $K$ cu semnificatia din enunt. Urmatoarea linie contine $N$ cifre separate prin spatiu, care reprezinta numarul de pe foaie.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $mult.out$ se va scrie numarul pe care cei doi copii incearca sa-l afle.\r\n\r\nh2. Restrictii si precizari:\r\n\r\n* $1 &le; N &le; 2.500$\r\n* $3 &le; K &le; 500$\r\n* un numar se considera corect scris chiar daca are prima cifra $0$.\r\n\r\nh2. Exemplu:\r\n\r\ntable(example). |_. mult.in |_. mult.out |_. Explicatii |\r\n| 5 3\r\n  5 4 7 0 3\r\n| 11\r\n| Multiplii care se pot obtine sunt:\r\n  0, 3, 03, 54 , 57, 540, 543, 570, 573, 5403, 5703 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"mult\")==',48,''),('problema/mult','Mult','2006-11-12 16:19:32','==Include(page=\"template/taskheader\" task_id=\"mult\")==\r\n\r\nDoi copii (a caror identitate nu va fi dezvaluita pentru a le proteja intimitatea) au ajuns sa se joace cu o foaia de hartie pe care era scris un numar cu $N$ cifre. Primul dintre ei, din lipsa de ocupatie, anunta ca a aflat ca sunt $X$ moduri prin care se poate obtine un multiplu al unui numar $K$ din numarul de pe foaie, stergand una, mai multe sau nici o cifran din el. Cel de-al doilea sustine ca sunt $Y$ moduri si in felul acesta cei doi copii au inceput sa se certe toata ziua.\r\n\r\nh2. Cerinta\r\n\r\nAflati numarul de posibilitati de a obtine un multiplu a lui $K$ din numarul initial daca singura operatie permisa este stergerea unei cifre pentru ca cei doi copii sa se impace.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $mult.in$ contine doua numere intregi $N$ si $K$ cu semnificatia din enunt. Urmatoarea linie contine $N$ cifre separate prin spatiu, care reprezinta numarul de pe foaie.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $mult.out$ se va scrie numarul pe care cei doi copii incearca sa-l afle.\r\n\r\nh2. Restrictii si precizari:\r\n\r\n* $1 &le; N &le; 2.500$\r\n* $3 &le; K &le; 500$\r\n* un numar se considera corect scris chiar daca are prima cifra $0$.\r\n\r\nh2. Exemplu:\r\n\r\ntable(example). |_. mult.in |_. mult.out |\r\n| 5 3\r\n  5 4 7 0 3\r\n| 11 |\r\n\r\nh3. Explicatii\r\n\r\nMultiplii care se pot obtine sunt: $0, 3, 03, 54 , 57, 540, 543, 570, 573, 5403, 5703$\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"mult\")==',15,''),('problema/sir','Sir','2006-11-11 18:49:46','==Include(page=\"template/taskheader\" task_id=\"sir\")==\r\n\r\nExplorand pestera arheologica de la Altamira, profesorul Richard a gasit un sir de numere de lungime $N$.\r\n\r\nh2. Cerinta\r\n\r\nDorind sa descifreze semnificatia acestui sir, el trebuie sa gaseasca secventa de lungime maxima de lungime cuprinsa intre $X$ si $Y$ cu propietatea: $MAX - MIN &le; Z$ unde, $MAX$ reprezinta valoarea maxima din secventa, $MIN$ valoare minima din secventa, iar $Z$ un numar natural dat.\r\n\r\nAjutati-l pe profesorul Richard sa descifreze limba antica din pestera Altamira si astfel, sa devina celebru.\r\n\r\nh2. Restrictii si prezizari:\r\n\r\n* $3 &le; N &le; 100.000$\r\n* $1 &le; X &le; Y &le; N$\r\n* $0 &le; Z &le; 30.000$\r\n* Valorile sirului sunt numere naturale &le; $30.000$\r\n* In cazul in care exista mai multe solutii se va afisa secventa cu pozitia de inceput maxima\r\n\r\nh2. Date de Intrare:\r\n\r\nDe pe prima linie a fisierului $sir.in$ se vor citi $4$ numere $N X Y Z$. Pe a doua linie a fisierului de intrare se vor citi $N$ numere, reprezentand valorile sirului.\r\n\r\nh2. Date de Iesire:\r\n\r\nPe prima linie a fisierului $sir.out$ se vor afisa $3$ numere separate prin spatii reprezentand lungimea maxima a secventei cu propietatea data, pozitia de inceput a secventei si pozitia de sfarsit a acesteia. In cazul in care nu exista solutie se va afisa un singur numar, $-1$.\r\n\r\nh2. Exemple:\r\n\r\n\r\ntable(example). |_. sir.in|_. sir.out|_. Explicatie|\r\n|6 2 4 3\r\n1 5 3 2 5 9\r\n|4 2 5\r\n|Secventa maxima cu lungime cuprinsa intre 2 si 4 care indeplineste propietatea din enunt are lungimea 4. Aceasta secventa incepe de pe pozitia 2 si se termina pe pozitia 5. |\r\n|3 2 3 1\r\n2 5 2\r\n|-1\r\n|Nu exista secventa de lungime cuprinsa intre 2 si 3 care sa indeplineasca propietatea din enunt|\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sir\")==',4895,''),('problema/bool','Bool','2006-11-11 16:43:03','==Include(page=\"template/taskheader\" task_id=\"bool\")==\r\n\r\nHaralambie a primit la scoala o tema destul de dificila. El trebuie sa evalueze o expresie logica. Aceasta expresie contine variabile(litere mari ale alfabetului englez de la $A$ la $Z$), constante({$TRUE$} si {$FALSE$}), paranteze rotunde {$($} si {$)$}, si operatorii logici $NOT$, $AND$ si $OR$. $NOT$ are prioritatea cea mai mare, $OR$ are prioritatea cea mai mica. Initial toate variabilele au valoarea $FALSE$. Lui Haralambie ii place sa evalueze expresii, dar variabilele isi mai schimba uneori valoarea si expresia trebuie reevaluata. Speriat din aceasta cauza, a decis sa apeleze la ajutorul vostru! Dupa cum este mentionat mai sus o expresie logica este definita in unul din modurile urmatoare:\r\n\r\n\r\ntable(example). |_. expresie |_. explicatie |\r\n| TRUE | &nbsp; |\r\n| FALSE | &nbsp; |\r\n| c     |  c - litera mare a alfabetului englez |\r\n| (e)   |  e - expresie logica |\r\n| NOT e |  e - expresie logica |\r\n| e1 AND e2 | e1 si e2 - expresii logice |\r\n| e1 OR e2 | e1 si e2 - expresii logice |\r\n\r\nh2. Cerinta\r\n\r\nSe da expresia ce trebuie evaluata si modificarile ce apar la valorile variabilelor. Pentru fiecare modificare de variabila trebuie reevaluata expresia si afisat rezultatul ($1$ pentru adevarat si $0$ pentru fals).\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $bool.in$ este scrisa expresia logica definita ca mai sus. Pe a doua linie este dat numarul $N$ de modificari ale variabilelor. Pe linia a treia sunt date $N$ caractere intre $A$ si $Z$, reprezentand variabilele a caror valoare este modificata.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $bool.out$ va contine o singura linie de lungime $N$. Pentru fiecare modificare de variabila se va afisa un caracter reprezentand valoarea logica a expresiei: $1$ pentru adevarat si $0$ pentru fals.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100$\r\n* $1 &le; Lungime expresiei &le; 1.000$\r\n* Toate literele care apar in expresie vor fi majuscule\r\n* Nu va exista mai mult de un spatiu intre doua caractere din expresie\r\n* O variabila care are valoarea $TRUE$ isi schimba valoarea in $FALSE$, iar o variabila $FALSE$ se schimba in $TRUE$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bool.in |_. bool.out |\r\n| A AND ((B OR NOT C) OR ((TRUE)))\r\n4\r\nABCA\r\n| 1110 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bool\")==',18,''),('problema/gard3','Gard3','2006-11-12 16:36:43','==Include(page=\"template/taskheader\" task_id=\"gard3\")==\r\n\r\nFermierul Ion mai avea o ferma in forma de poligon convex cu $N$ laturi. Intr-o buna zi, el se hotaraste s-o imparta in $K$ regiuni, de asemenea poligoane convexe. Dupa impartire, el va folosi fiecare zona intr-un anumit scop (de exemplu, in zona $1$ va planta vita de vie, in zona $2$ va creste vaci etc.) Pentru aceasta, el va construi $K-1$ garduri. Fiecare gard va fi un segment care va uni doua varfuri din poligon. Gardurile nu se vor intersecta decat, eventual, in varfurile poligonului.\r\nInainte de a se apuca de treaba, fermierul Ion doreste sa afle in cate moduri poate imparti ferma sa in $K$ regiuni (pentru a le examina si a alege un anumit mod de impartire).\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care, pentru valorile $N$ si $K$ date, va afisa numarul de moduri in care fermierul Ion poate imparti ferma sa in $K$ regiuni.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $gard3.in$ contine pe prima linie numerele naturale $N$ si {$K$}, separate printr-un spatiu.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $gard3.out$ se va afisa numarul de moduri in care se poate imparti ferma in $K$ regiuni.\r\n\r\nh2. Restrictii\r\n\r\n* $3 &le; N &le; 50$\r\n* $1 &le; K &le; N-2$\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. gard3.in |_. gard3.out |\r\n| 5 2 | 5 |\r\n\r\nh3. Explicatie\r\n\r\nSe construieste un singur gard. Acesta va uni una dintre  perechile de varfuri: \r\n$({*1,3*}) ({*1,4*}) ({*2,4*}) ({*2,5*}) (3, 5)$.\r\n\r\ntable(example). |_. gard3.in |_. gard3.out |\r\n| 10 7 | 5005 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"gard3\")==',15,''),('home','info-arena 2.0','2006-11-12 16:45:39','==html|<img src=\"http://msig.info/web2v2/info-arena+2.0BETA.png\" alt=\"info-arena 2.0 BETA\" />==\r\n\r\nh3. Niste probleme\r\n\r\n!>home?chuck_norris.jpg! !http://www.infoarena.ro/home?action=download&file=horse.jpeg!\r\n\r\ntable{border-width:0}. | !home?gold-penis.jpg 50%!\r\n| !home?gold-penis.jpg 50%!\r\n| !home?gold-penis.jpg 50%! |\r\n| !home?gold-penis.jpg 50%!\r\n| !user/domino?avatar!\r\n| !home?gold-penis.jpg 150%! |\r\n| !home?gold-penis.jpg 50%!\r\n| !home?gold-penis.jpg 50%!\r\n| !home?gold-penis.jpg 50%! |\r\n\r\n\r\nAici e \'arhiva de probleme\':round/arhiva.\r\n\r\nDaca esti admin vezi \'lista rundelor\':page_index?prefix=round si \'lista problemelor\':page_index?prefix=task.\r\n\r\ninfo-arena organizeaza concursuri online de informatica. Rezolva probleme din \'arhiva\':round/archive.\r\n\r\nSite-ul este complet editabil de catre administratori. Se recomanda sa citesti \'documentatia de textile\':Textile. Daca vrei sa testezi optiunile de formatare ale Textile poti sa te duci in \'sandbox\':Sandbox ca sa testezi.\r\n\r\nSMF SSI testing place: \'here\':SSItest\r\n\r\nh2. Ultimele stiri\r\n\r\n==News()==\r\n\r\np(strap). Vezi \'arhiva stiri\':news',1,''),('arhiva','Arhiva de probleme, pregatire pentru concursuri de informatica','2006-11-12 15:49:43','h2. Probleme cu explicatii naspet\r\n\r\n== Grep(page=\"task/%\" substr=\"%|_. Expl%\") ==\r\n\r\n\r\n\r\n\r\n\r\n==Include(page=\"template/roundheader\" round_id=\"arhiva\")==\r\n\r\n\r\n\r\np. %{color:red}Reverse% %{color:blue}textile% %{color:green}here.%\r\n==Include(page=\"template/roundfooter\" round_id=\"arhiva\")==',13,''),('home','info-arena 2.0','2006-11-13 05:14:30','==html|<img src=\"http://msig.info/web2v2/info-arena+2.0BETA.png\" alt=\"info-arena 2.0 BETA\" />==\r\n\r\n*Atentie:* Nu mai futeti prima pagina, editati si voi in \'sandbox\':Sandbox.\r\n\r\nAici e \'arhiva de probleme\':round/arhiva.\r\n\r\nDaca esti admin vezi \'lista rundelor\':page_index?prefix=round si \'lista problemelor\':page_index?prefix=task.\r\n\r\nSite-ul este complet editabil de catre administratori. Se recomanda sa citesti \'documentatia de textile\':Textile. Daca vrei sa testezi optiunile de formatare ale Textile poti sa te duci in \'sandbox\':Sandbox ca sa testezi.\r\n\r\nSMF SSI testing place: \'here\':SSItest\r\n\r\nh2. Ultimele stiri\r\n\r\n==News()==\r\n\r\np(strap). Vezi \'arhiva stiri\':news',1142,''),('sandbox','Sandbox','2006-11-12 16:01:09','\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n== Gallery(page=\"%\" file=\"ec.%\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',18,''),('sandbox','Sandbox','2006-11-13 13:34:18','== Gallery(page=\"%\" file=\"ec.%\") == \r\nh2. PLUIS\r\n== Gallery(page=\"%\" file=\"horse.%\") ==\r\n&nbsp;&nbsp;&nbsp;\r\n\r\n\r\n\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',18,''),('home','info-arena 2.0','2006-11-13 18:00:37','==html|<img src=\"http://msig.info/web2v2/info-arena+2.0BETA.png\" alt=\"info-arena 2.0 BETA\" />==\r\n\r\nSite-ul este complet editabil de catre administratori. Se recomanda sa citesti \'documentatia de textile\':Textile. Daca vrei sa testezi optiunile de formatare ale Textile poti sa te duci in \'sandbox\':Sandbox ca sa testezi.\r\n\r\ntable.\r\n|Continut care mai trebuie formatat:\r\n* \"Articole\":Articles\r\n* \"News\":News\r\n\r\nDe asemenea, mai trebuie convertit *TOT* continutul din \"wiki-ul\":http://infoarena.devnet.ro/wiki/index.php/Main_Page vechi.|\r\n\r\nAici e \'arhiva de probleme\':round/arhiva.\r\n\r\nDaca esti admin vezi \'lista rundelor\':page_index?prefix=round si \'lista problemelor\':page_index?prefix=task.\r\n\r\nh2. Ultimele 3 stiri\r\n\r\n==News(pager_style=\"none\" display_entries=\"3\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':news',1,''),('home','info-arena 2.0','2006-11-13 18:02:30','==html|<img src=\"http://msig.info/web2v2/info-arena+2.0BETA.png\" alt=\"info-arena 2.0 BETA\" />==\r\n\r\nSite-ul este complet editabil de catre administratori. Se recomanda sa citesti \'documentatia de textile\':Textile. Daca vrei sa testezi optiunile de formatare ale Textile poti sa te duci in \'sandbox\':Sandbox ca sa testezi.\r\n\r\n\r\n table. | Continut care mai trebuie formatat:\r\n* \"Articole\":Articles\r\n* \"News\":News\r\n\r\nDe asemenea, mai trebuie convertit *TOT* continutul din \"wiki-ul\":http://infoarena.devnet.ro/wiki/index.php/Main_Page vechi. |\r\n\r\nAici e \'arhiva de probleme\':round/arhiva.\r\n\r\nDaca esti admin vezi \'lista rundelor\':page_index?prefix=round si \'lista problemelor\':page_index?prefix=task.\r\n\r\nh2. Ultimele 3 stiri\r\n\r\n==News(pager_style=\"none\" display_entries=\"3\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':news',1,''),('multe-smenuri-de-programare-in-cc-si-nu-numai','Multe \"smenuri\" de programare in C/C++... si nu numai!','2006-11-13 17:58:17','h1. Multe \"smenuri\" de programare in C/C++... si nu numai!\r\n\r\n(Creat de \'_domino_\':user/domino la data de _2004-11-10_ categoria _Limbaje_, autor(i) _Mircea Pasoi_)\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nAcest articol vine ca o completare a articolului scris de Alexandru Mosoi, prezentand noi trucuri care le-am folosit si m-au ajutat mult. O mare parte din acestea le-am invatat din sursele lui Radu Berinde (cred ca stiti cu totii cine este), asadar ii multumesc!\r\n\r\nh2. Array-uri neindexate de la 0\r\n\r\nUn dezavantaj fata de Pascal este faptul ca in C nu putem avea expresii de genul {@A[-100]@} unde $A$ este un vector. Dar acest lucru se poate remedia. Spre exemplu, daca vrem sa facem un vector $A$ cu elemente de la $-100$ la $100$ procedam astfel:\r\n\r\n{@int A[201];@}\r\n{@#define A (A + 100)@}\r\n\r\nh2. Fisiere de intrare si iesire\r\n\r\nFolositi {@freopen()@} in loc de {@fopen()@} deoarece este mai comod, in special la concursurile in care intrare si iesirea sunt standard.\r\n\r\n{@freopen(\"in.txt\", \"r\", stdin);@}\r\n{@freopen(\"out.txt\", \"w\", stdout);@}\r\n\r\nh2. Cautare binara (ideea originala de la Mihai Patrascu)\r\n\r\nUrmatorul cod este de aproximativ $4$ ori mai rapid (am testat cu cautare binara ca in manual) , mai usor de inteles, mai flexibil si mai scurt... ce ati putea dori mai mult?\r\n\r\np(pre). \r\n{@int N, A[N];@}\r\n{@int binary_search(int val)@}\r\n{@{@}\r\n{@    int i, step;@}\r\n{@    for (step = 1; step < N; step <<= 1);@}\r\n{@    for (i = 0; step; step >>= 1)@}\r\n{@        if (i + step < N && A[i + step] <= val)@}\r\n{@           i += step;@}\r\n{@    return i;@}\r\n{@}@}\r\n\r\nProcedura de mai sus face cautarea binara folosind puteri a lui $2$ in ordine descrescatoare, practic incerc sa determin fiecare bit al rezultatului.\r\n\r\nh2. Impartire in bucati de marime $sqrt(n)$ (cunoscut si ca \"smenul lui Bogdan Batog\")\r\n\r\nSa presupunem ca avem un vector de lungime n cu numere reale pe care se fac urmatoarele operatii:\r\n{@ADUNA(st, dr, x)@} - toate elementele cu indicii intre $st$ si $dr$ isi cresc valoarea cu $x$\r\n{@SUMA(st, dr)@} - returneaza suma elementelor cu indicii intre $st$ si $dr$\r\n\r\nPentru cei ce cunosc arbori de intervale, rezolvarea acestei probleme in $O(lg n)$ per operatie este o munca usoara, dar presupunand ca nu stim aceasta structura putem folosi urmatorul truc: vom construi un al doilea vector de lungime $sqrt(n)$ care retine suma elementelor pe bucati de lungime {$sqrt(n)$}. Pentru a face o operatie pe un interval [{$st, dr$}] vom imparti acest interval in bucati de $sqrt(n)$ a caror actualizare o facem in vectorul $B$ si elementele care raman in margine in vectorul {$A$}. De exemplu pe vectorul {@A[0..15]@} vom avea vectorul {@B[0..3]@}. Pentru a actualiza de exemplu [{$2, 12$}] vom actualiza {@B[1]@} (care corespunde lui [{$4..7$}]), {@B[2]@} (pentru [{$8..11$}]) si {@A[2]@}, {@A[3]@}, {@A[12]@} (elementele din margini). Cum sunt maxim $sqrt(n)$ elemente de actualizat in $B$ si pe margini nu vom actualiza niciodata mai mult de $2 * sqrt(n)$ elemente putem concluziona ca operatiile vor avea complexitate {$O(sqrt(n))$}.\r\n\r\nDaca am avea aceeasi problema dar in doua dimensiuni, am putea face acelasi \"smen\" pentru fiecare linie pentru o complexitate $O(n*sqrt(n))$ per operatie, sau cu arbori de intervale pe fiecare linie {$O(n*lg n)$}. Putem, de asemenea obtine o complexitate $O(n)$ folosind urmatoarea impartire:\r\n$A$ - pentru bucati $1 * 1$\r\n$B$ - pentru bucati $sqrt(n) * sqrt(n)$\r\n$C$ - pentru bucati $1 * sqrt(n)$\r\n$D$ - pentru bucati $sqrt(n) * 1$\r\nAcest mod de reprezentare este o extindere directa a aceluiasi smen in doua dimensiuni. Aceasta idee poate fi folosita si pentru alte operatii: inmultire, minim, maxim, etc. In general, orice se poate rezolva cu acest \"smen\" se poate obtine la o complexitate mai buna cu arbori de intervale, dar merita sa stiti si aceasta ideea deoarece de multe ori scuteste din efortul de implementare, desi se pierde din viteza... alegerea voastra! ;)\r\n\r\nh2. LCA in $O(sqrt(n))$ (ideea originala de la Radu Berinde)\r\n\r\nDaca nu stiti ce este LCA, va recomand sa cititi \"articolul\":http://www.infoarena.ro/LCA_Lowest_common_ancestor lui Emilian Miron din cadrul site-ului pentru a va documenta. In continuare vom prezenta un algoritm mai ineficient, dar foarte usor de implementat. Consideram arborele si atribuim fiecarui nod o inaltime. Vom imparti arborele in $sqrt(H)$ intervale in functie de inaltime, unde $H$ e inaltimea maxima (de exemplu la $H=9$ nodurile cu inaltimi intre $0$ si $2$ vor forma un interval, [{$3..5$}] alt interval si ultimul interval de inaltimi [{$6..8$}]). Astfel, pentru fiecare nod, pe langa tatal sau, vom retine si tatal din intervalul de mai sus, printr-o parcurede DF. In continuare, codul:\r\n\r\n$H$ se calculeaza inainte sau poate fi constant\r\n$T$ sunt tatii nodului si $N$ numarul de noduri\r\n\r\np(pre). \r\n{@void DF(int n, int t2, int lev)@}\r\n{@{@}\r\n{@    int i;@}\r\n{@    T2[n] = t2, Lev[n] = lev;@}\r\n{@    if (lev % H == 0) t2 = n;@}\r\n{@    for (i = 0; i < N; i++)@}\r\n{@        if (T[i] == n) DF(i, t2, lev+1);@}\r\n{@}@}\r\n\r\nOperatia de LCA se va realiza apoi foarte usor, urcand pe tatii din intervale, pana se ajunge la doua noduri in acelasi interval, apoi folosindu-se metoda clasica. Cod:\r\n\r\nint LCA(int x, int y)\r\n\r\n{\r\nwhile (T2[x] != T2[y])\r\nif (Lev[x] > Lev[y])\r\nx = T2[x];\r\nelse\r\ny = T2[y];\r\n\r\nwhile (x != y)\r\nif (Lev[x] > Lev[y])\r\nx = T[x];\r\nelse\r\ny = T[y];\r\nreturn x;\r\n}\r\n\r\n\r\n\r\nh2. LCA in O(lg^2 n)\r\n\r\nAceeasi problema, dar o alta rezolvare. Vom construi o matrice A[i][j] cu semnificatia A[i][j] = al 2^i-lea tata al nodului j. Folosind aceasta matrice putem cauta binar (O(lg n)) nivelul pe care s-ar putea afla LCA-ul a doua noduri si sa determinam daca nodul ales este corect - adica daca nodul situat la acel nivel este acelasi pentru cele doua noduri pentru care se face LCA (O(lg n) cu matricea de mai sus). Complexitate finala O(lg^2 n) si O(n*lg n) memorie.\r\n\r\nh2. For-uri \"complicate\"\r\n\r\nfor-ul in C/C++ este foarte flexibil si poate ajuta foarte mult in compactarea codului, deci si a timpului de implementare. In continuare vom prezenta algoritmul merge sort (sortare prin interclasare) scris in cateva linii (putine, zic eu!):\r\n\r\nint N, A[N], B[N];\r\n\r\nvoid merge_sort(int l, int r)\r\n{\r\nint m = (l + r) >> 1, i, j, k;\r\n\r\nif (l == r) return;\r\n\r\nmerge_sort(l, m);\r\nmerge_sort(m + 1, r);\r\n\r\n\r\n\r\nfor (i=l, j=m+1, k=l; i<=m || j<=r; )\r\nif (j > r || (i <= m && A[i] < A[j]))\r\nB[k++] = A[i++];\r\nelse\r\nB[k++] = A[j++];\r\nfor (k = l; k <= r; k++) A[k] = B[k];\r\n}\r\n\r\nh2. Recomandari generale\r\n\r\nI. Programare dinamica cu memoizare: mult mai simplu si uneori chiar mai rapida cand nu ne trebuie tot array-ul\r\n\r\nII. Algoritmi randomizati: de multe ori mai usor de implementat si mai eficienti, mai bine decat cei euristici, dar necesita o analiza mult mai atenta a performantei. Exemple calsice: quciksort, statistici de ordine\r\n\r\n\r\n\r\nh2. \"Smenul lui Mars\" (Marius Andrei)\r\n\r\nConsideram urmatoarea problema: se da un vector A de N elemente pe care se fac M astfel de operatii: ADUNA(st, dr, x) - toate elementele cu indicii intre st si dr isi cresc valoarea cu x. La sfarsit trebuie sa se afiseze vectorul rezultat. In continuarea vom descrie o metoda care ne da un timp de rulare de O(1) pentru operatia ADUNA si O(N) pentru a determina un element din vector. Vom construi un al doilea vector B de N+1 elemente, cu proprietatea ca A[i] = B[0] + B[1] + ... B[i]. Astfel, o operatie ADUNA(st, dr, x) devine:\r\n\r\nB[st] += x;\r\nB[dr + 1] -= x;\r\n\r\nDa, este chiar asa de simplu! Pentru a determina un element A[i] vom aduna pur si simplu B[0] + B[1] + ... B[i]. Incercati pe foaie sa vedeti cum funtioneaza. Aceasta ideea poate fi extinsa si in doua dimensiuni, construind B astfel incat A[i][j] = suma subtabloului din B cu coltul in (0, 0) si (i, j), astfel (pt. ADUNA(x1,y1,x2,y2,v)):\r\n\r\nB[x1][y1] += v;\r\nB[x1][y2 + 1] -= v;\r\nB[x2 + 1][y1] -= v;\r\nB[x2 + 1][y2 + 1] += v;\r\n\r\nPe cazul general, daca vrem sa facem operatii in d dimensiuni vom avea o complexitate O(2^d). Reamintesc ca aceasta metoda este eficienta doar cand se vrea afisata vectorul/matricea/etc. doar la sfarsitul operatiilor, deoarece aflarea unui element este o operatie foarte ineficienta.\r\n\r\nh2. Grafuri cu liste de adiacenta (ideea originala de la Radu Berinde)\r\n\r\nSe stie (sau ar trebui sa se stie!) ca lucrul cu pointerii este foarte incet... astfel, cand retinem un graf rar (numar mare de noduri, numar mic de muchii) cu pointeri (vezi mai jos) incetinim foarte mult programul.\r\n\r\nstruct list\r\n{\r\nint n;\r\nstruct list *next;\r\n}\r\ntypedef struct list list;\r\n\r\nIn contiuare vom prezenta o metoda care este de 3-4 ori mai rapida (adica parcurgerile DF , BF sau altii algoritmi ruleaza de 3-4 ori mai rapid cand graful este stocat astfel), dar are ca dezavantaj necesitatea de a citi de doua ori fisierul de intrare.\r\n\r\n#include <stdlib.h>\r\n\r\n#include <stdio.h>\r\n\r\n\r\n\r\nint N, M, *G[N], Deg[N];\r\n\r\n\r\n\r\nint main(void)\r\n{\r\n\r\nint i, j;\r\n\r\n\r\n\r\nfreopen(\"in.txt\", \"r\", stdin);\r\n\r\nscanf(\"%d %d\", &N, &M);\r\n\r\nfor (; M > 0; M--)\r\n\r\n{\r\n\r\nscanf(\"%d %d\", &i, &j);\r\n\r\nDeg[i - 1]++, Deg[j - 1]++;\r\n\r\n}\r\n\r\n\r\n\r\nfor (i = 0; i < N; Deg[i++] = 0)\r\nG[i] = (int *) malloc(Deg[i]*sizeof(int));\r\n\r\nfseek(stdin, 0, SEEK_SET);\r\n\r\nscanf(\"%d %d\", &N, &M);\r\n\r\nfor (; M > 0; M--)\r\n\r\n{\r\n\r\nscanf(\"%d %d\", &i, &j);\r\n\r\ni--, j--;\r\n\r\nG[i][Deg[i]++] = j,\r\n\r\nG[j][Deg[j]++] = i;\r\n\r\n}\r\n\r\n}\r\n\r\nSporul de viteza se datoreaza faptului ca se folosesc vectori in loc de pointeri si struct-uri. Daca ne permite memoria putem evita citirea de doua ori a fisierul prin pastrarea muchiilor intr-o lista de muchii si apoi, dupa calcularea gradelor, inserarea muchiilor in liste. Pentru a demonstra eficienta acestei metode faceti urmatorul test: implementati o sursa cu pointeri si struct si implementati un BF, apoi scrieti codul de mai sus cu urmatoarele modificari:\r\n\r\n...\r\n\r\nfor (i = 0; i < N; i++)\r\n\r\n{\r\n\r\nG[i] = (int *) malloc((Deg[i]+1)*sizeof(int));\r\n\r\nG[i][Deg[i]] = -1;\r\n\r\nDeg[i] = 0;\r\n\r\n}\r\n\r\n...\r\n\r\nsi implementati BF astfel:\r\n\r\nvoid BF(int n)\r\n\r\n{\r\n\r\nint Q[N], ql, qr, *p;\r\n\r\nchar U[N];\r\n\r\n\r\n\r\nmemset(U, 0, sizeof(U));\r\n\r\nU[Q[ql = qr = 0] = n] = 1;\r\n\r\nfor (; ql <= qr; ql++)\r\n\r\nfor (p = G[Q[ql]]; *p != -1; p++)\r\n\r\nif (!U[*p]) U[Q[++qr] = *p] = 1;\r\n}\r\n\r\nApoi, incercati sa vedeti diferenta de timp intre cele doua programe... impresionant, nu?\r\n\r\n\r\n\r\nh2. Numere mari (ideea originala de la Radu Berinde)\r\n\r\nIn continuare voi prezenta cum se pot realiza operatii pe numere mari cu foarte putine linii de cod. In general, multi programatori se complica la aceste operatii, desi nu este nevoie! Vom considera ca numerele mari sunt vectori in care elementul de indice 0 indica lungimea numarului, iar cifrele sunt retinute in ordinea inversa decat cea a citirii.\r\n\r\nh3. Suma a doua numere mari\r\n\r\nvoid add(int A[], int B[])\r\n{\r\nint i, t = 0;\r\n\r\n\r\n\r\nfor (i=1; i<=A[0] || i<=B[0] || t; i++, t/=10)\r\nA[i] = (t += A[i] + B[i]) % 10;\r\nA[0] = i - 1;\r\n}\r\n\r\nh3. Inmultirea unui numar mare cu un numar mic\r\n\r\nvoid mul(int A[], int B)\r\n{\r\nint i, t = 0;\r\n\r\n\r\n\r\nfor (i = 1; i <= A[0] || t; i++, t /= 10)\r\nA[i] = (t += A[i] * B) % 10;\r\nA[0] = i - 1;\r\n}\r\n\r\nh3. Inmultirea unui numar mare cu un numar mare\r\n\r\nvoid mul(int A[], int B[])\r\n{\r\nint i, j, t, C[];\r\n\r\n\r\n\r\nmemset(C, 0, sizeof(C));\r\nfor (i = 1; i <= A[0]; i++)\r\n{\r\nfor (t=0, j=1; j <= B[0] || t; j++, t/=10)\r\nC[i+j-1]=(t+=C[i+j-1]+A[i]*B[j])%10;\r\nif (i + j - 2 > C[0]) C[0] = i + j - 2;\r\n}\r\nmemcpy(A, C, sizeof(C));\r\n}\r\n\r\nh3. Scaderea a doua numere mari\r\n\r\nvoid sub(int A[], int B[])\r\n{\r\nint i, t = 0;\r\n\r\n\r\n\r\nfor (i = 1; i <= A[0]; i++)\r\nA[i] += (t = (A[i] -= B[i] + t) < 0) * 10;\r\nfor (; A[0] > 1 && !A[A[0]]; A[0]--);\r\n}\r\n\r\nh3. Impartirea unui numar mare la un numar mic\r\n\r\nvoid div(int A[], int B)\r\n{\r\nint i, t = 0;\r\n\r\n\r\n\r\nfor (i = A[0]; i > 0; i--, t %= B)\r\nA[i] = (t = t * 10 + A[i]) / B;\r\nfor (; A[0] > 1 && !A[A[0]]; A[0]--);\r\n}\r\n\r\nh3. Restul unui numar mare la un numar mic\r\n\r\nint mod(int A[], int B)\r\n{\r\nint i, t = 0;\r\n\r\n\r\n\r\nfor (i = A[0]; i > 0; i--)\r\nt = (t * 10 + A[i]) % B;\r\nreturn t;\r\n}\r\n\r\n\r\n\r\nh2. AVL-uri (ideea originala de la Radu Berinde - again)\r\n\r\nAVL-urile sunt arbori de cautare echilibrati care au complexitate O(lg n) pe operatiile de inserare, stergere si cautare. Pentru mai multe detalii cautati cartea \"Arbori\" pe [2]site-ul doamnei profesoare Emanuela Cerchez. In continuare voi prezenta o metoda destul de simpla de a implementa aceastra structura de date in timp de concurs. Enjoy!\r\n\r\n#define max(a, b) ((a) > (b) ? (a) : (b))\r\n#define geth(n) (n->h = 1 + max(n->l->h, n->r->h))\r\n\r\n\r\n\r\nstruct node\r\n{\r\nint key, h;\r\nstruct node *l, *r;\r\n} *R, *NIL;\r\ntypedef struct node node;\r\n\r\n\r\n\r\nvoid init(void)\r\n{\r\nR = NIL = (node *) malloc(sizeof(node));\r\nNIL->key = NIL->h = 0,\r\n\r\nNIL->l = NIL->r = NULL;\r\n}\r\n\r\n\r\n\r\nnode* rotleft(node *n)\r\n{\r\nnode *t = n->l;\r\n\r\nn->l = t->r, t->r = n,\r\ngeth(n), geth(t);\r\nreturn t;\r\n}\r\n\r\n\r\n\r\nnode* rotright(node *n)\r\n{\r\nnode *t = n->r;\r\n\r\nn->r = t->l, t->l = n,\r\ngeth(n), geth(t);\r\nreturn t;\r\n}\r\n\r\n\r\n\r\nnode* balance(node *n)\r\n{\r\ngeth(n);\r\nif (n->l->h > n->r->h + 1)\r\n{\r\nif (n->l->r->h > n->l->l->h)\r\nn->l = rotright(n->l);\r\nn = rotleft(n);\r\n}\r\nelse\r\nif (n->r->h > n->l->h + 1)\r\n{\r\nif (n->r->l->h > n->r->r->h)\r\nn->r = rotleft(n->r);\r\nn = rotright(n);\r\n}\r\nreturn n;\r\n}\r\n\r\n\r\n\r\nnode* insert(node *n, int key)\r\n{\r\nif (n == NIL)\r\n{\r\nn = (node *) malloc(sizeof(node));\r\nn->key = key, n->h = 1, n->l = n->r = NIL;\r\nreturn n;\r\n}\r\nif (key < n->key)\r\nn->l = insert(n->l, key);\r\nelse\r\nn->r = insert(n->r, key);\r\nreturn balance(n);\r\n}\r\n\r\n\r\n\r\nnode* erase(node *n, int key)\r\n{\r\nnode *t;\r\n\r\nif (n == NIL) return n;\r\nif (n->key == key)\r\n{\r\nif (n->l == NIL || n->r == NIL)\r\n{\r\nt = n->l == NIL ? n->r : n->l;\r\nfree(n); return t;\r\n}\r\nelse\r\n{\r\nfor (t = n->r; t->l != NIL; t = t->l);\r\nn->key = t->key,\r\n\r\nn->r = erase(n->r, t->key);\r\nreturn balance(n);\r\n}\r\n}\r\nif (key < n->key)\r\nn->l = erase(n->l, key);\r\nelse\r\nn->r = erase(n->r, key);\r\nreturn balance(n);\r\n}\r\n\r\n\r\n\r\nint search(node *n, int key)\r\n{\r\nif (n == NIL) return 0;\r\nif (n->key == key) return 1;\r\nif (key < n->key)\r\nreturn search(n->l, key);\r\nelse\r\nreturn search(n->r, key);\r\n}\r\n\r\nAici se termina acest articol. Am incercat sa pun accentul pe simplitate si eficienta, si cred ca am reusit acest lucru. Sper ca ati invatat cate ceva din el si recomand sa luati fiecare bucata in parte si sa incercati sa implementati efectiv ca sa intelegi mai bine. Bafta la concursuri tuturor! ;)\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://info.devnet.ro/articole.php?page=art&art=19\r\n2. http://www.liis.ro/%7eema/\r\n\r\n',961,''),('multe-smenuri-de-programare-in-cc-si-nu-numai','Multe \"smenuri\" de programare in C/C++... si nu numai!','2006-11-13 20:42:28','h1. Multe \"smenuri\" de programare in C/C++... si nu numai!\r\n\r\n(Creat de \'_domino_\':user/domino la data de _2004-11-10_ categoria _Limbaje_, autor(i) _Mircea Pasoi_)\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nAcest articol vine ca o completare a articolului scris de Alexandru Mosoi, prezentand noi trucuri care le-am folosit si m-au ajutat mult. O mare parte din acestea le-am invatat din sursele lui Radu Berinde (cred ca stiti cu totii cine este), asadar ii multumesc!\r\n\r\nh2. Array-uri neindexate de la 0\r\n\r\nUn dezavantaj fata de Pascal este faptul ca in C nu putem avea expresii de genul {@A[-100]@} unde $A$ este un vector. Dar acest lucru se poate remedia. Spre exemplu, daca vrem sa facem un vector $A$ cu elemente de la $-100$ la $100$ procedam astfel:\r\n\r\np(pre). {@int A[201];@}\r\n{@#define A (A + 100)@}\r\n\r\nh2. Fisiere de intrare si iesire\r\n\r\nFolositi {@freopen()@} in loc de {@fopen()@} deoarece este mai comod, in special la concursurile in care intrare si iesirea sunt standard.\r\n\r\np(pre). {@freopen(\"in.txt\", \"r\", stdin);@}\r\n{@freopen(\"out.txt\", \"w\", stdout);@}\r\n\r\nh2. Cautare binara (ideea originala de la Mihai Patrascu)\r\n\r\nUrmatorul cod este de aproximativ $4$ ori mai rapid (am testat cu cautare binara ca in manual) , mai usor de inteles, mai flexibil si mai scurt... ce ati putea dori mai mult?\r\n\r\np(pre). {@int N, A[N];@}\r\n{@int binary_search(int val)@}\r\n{@{@}\r\n{@    int i, step;@}\r\n{@    for (step = 1; step < N; step <<= 1);@}\r\n{@    for (i = 0; step; step >>= 1)@}\r\n{@        if (i + step < N && A[i + step] <= val)@}\r\n{@           i += step;@}\r\n{@    return i;@}\r\n{@}@}\r\n\r\nProcedura de mai sus face cautarea binara folosind puteri a lui $2$ in ordine descrescatoare, practic incerc sa determin fiecare bit al rezultatului.\r\n\r\nh2. Impartire in bucati de marime $sqrt(n)$ (cunoscut si ca \"smenul lui Bogdan Batog\")\r\n\r\nSa presupunem ca avem un vector de lungime n cu numere reale pe care se fac urmatoarele operatii:\r\n{@ADUNA(st, dr, x)@} - toate elementele cu indicii intre $st$ si $dr$ isi cresc valoarea cu $x$\r\n{@SUMA(st, dr)@} - returneaza suma elementelor cu indicii intre $st$ si $dr$\r\n\r\nPentru cei ce cunosc arbori de intervale, rezolvarea acestei probleme in $O(lg n)$ per operatie este o munca usoara, dar presupunand ca nu stim aceasta structura putem folosi urmatorul truc: vom construi un al doilea vector de lungime $sqrt(n)$ care retine suma elementelor pe bucati de lungime {$sqrt(n)$}. Pentru a face o operatie pe un interval [{$st, dr$}] vom imparti acest interval in bucati de $sqrt(n)$ a caror actualizare o facem in vectorul $B$ si elementele care raman in margine in vectorul {$A$}. De exemplu pe vectorul {$A{~0..15~}$} vom avea vectorul {$B{~0..3~}$}. Pentru a actualiza de exemplu [{$2, 12$}] vom actualiza {$B{~1~}$} (care corespunde lui [{$4..7$}]), {$B{~2~}$} (pentru [{$8..11$}]) si {$A{~2~}$}, {$A{~3~}$}, {$A{~12~}$} (elementele din margini). Cum sunt maxim $sqrt(n)$ elemente de actualizat in $B$ si pe margini nu vom actualiza niciodata mai mult de $2 * sqrt(n)$ elemente putem concluziona ca operatiile vor avea complexitate {$O(sqrt(n))$}.\r\n\r\nDaca am avea aceeasi problema dar in doua dimensiuni, am putea face acelasi \"smen\" pentru fiecare linie pentru o complexitate $O(n*sqrt(n))$ per operatie, sau cu arbori de intervale pe fiecare linie {$O(n*lg n)$}. Putem, de asemenea obtine o complexitate $O(n)$ folosind urmatoarea impartire:\r\n$A$ - pentru bucati $1 * 1$\r\n$B$ - pentru bucati $sqrt(n) * sqrt(n)$\r\n$C$ - pentru bucati $1 * sqrt(n)$\r\n$D$ - pentru bucati $sqrt(n) * 1$\r\nAcest mod de reprezentare este o extindere directa a aceluiasi smen in doua dimensiuni. Aceasta idee poate fi folosita si pentru alte operatii: inmultire, minim, maxim, etc. In general, orice se poate rezolva cu acest \"smen\" se poate obtine la o complexitate mai buna cu arbori de intervale, dar merita sa stiti si aceasta ideea deoarece de multe ori scuteste din efortul de implementare, desi se pierde din viteza... alegerea voastra! ;)\r\n\r\nh2. LCA in $O(sqrt(n))$ (ideea originala de la Radu Berinde)\r\n\r\nDaca nu stiti ce este LCA, va recomand sa cititi \"articolul\":http://www.infoarena.ro/LCA_Lowest_common_ancestor lui Emilian Miron din cadrul site-ului pentru a va documenta. In continuare vom prezenta un algoritm mai ineficient, dar foarte usor de implementat. Consideram arborele si atribuim fiecarui nod o inaltime. Vom imparti arborele in $sqrt(H)$ intervale in functie de inaltime, unde $H$ e inaltimea maxima (de exemplu la $H=9$ nodurile cu inaltimi intre $0$ si $2$ vor forma un interval, [{$3..5$}] alt interval si ultimul interval de inaltimi [{$6..8$}]). Astfel, pentru fiecare nod, pe langa tatal sau, vom retine si tatal din intervalul de mai sus, printr-o parcurede DF. In continuare, codul:\r\n\r\n$H$ se calculeaza inainte sau poate fi constant\r\n$T$ sunt tatii nodului si $N$ numarul de noduri\r\n\r\np(pre). {@void DF(int n, int t2, int lev)@}\r\n{@{@}\r\n{@    int i;@}\r\n{@    T2[n] = t2, Lev[n] = lev;@}\r\n{@    if (lev % H == 0) t2 = n;@}\r\n{@    for (i = 0; i < N; i++)@}\r\n{@        if (T[i] == n) DF(i, t2, lev+1);@}\r\n{@}@}\r\n\r\nOperatia de LCA se va realiza apoi foarte usor, urcand pe tatii din intervale, pana se ajunge la doua noduri in acelasi interval, apoi folosindu-se metoda clasica. Cod:\r\n\r\np(pre). {@int LCA(int x, int y)@}\r\n{@{@}\r\n{@    while (T2[x] != T2[y])@}\r\n{@        if (Lev[x] > Lev[y])@}\r\n{@            x = T2[x];@}\r\n{@        else@}\r\n{@            y = T2[y];@}\r\n{@    while (x != y)@}\r\n{@        if (Lev[x] > Lev[y])@}\r\n{@            x = T[x];@}\r\n{@        else@}\r\n{@            y = T[y];@}\r\n{@    return x;@}\r\n{@}@}\r\n\r\n\r\n\r\nh2. LCA in $O(lg^2^ n)$\r\n\r\nAceeasi problema, dar o alta rezolvare. Vom construi o matrice $A{~i,j~}$ cu semnificatia $A{~i,j~}$ = al {$2^i^$}-lea tata al nodului {$j$}. Folosind aceasta matrice putem cauta binar ({$O(lg n)$}) nivelul pe care s-ar putea afla LCA-ul a doua noduri si sa determinam daca nodul ales este corect - adica daca nodul situat la acel nivel este acelasi pentru cele doua noduri pentru care se face LCA ({$O(lg n)$} cu matricea de mai sus). Complexitate finala $O(lg^2^ n)$ si $O(n*lg n)$ memorie.\r\n\r\nh2. For-uri \"complicate\"\r\n\r\nfor-ul in C/C++ este foarte flexibil si poate ajuta foarte mult in compactarea codului, deci si a timpului de implementare. In continuare vom prezenta algoritmul merge sort (sortare prin interclasare) scris in cateva linii (putine, zic eu!):\r\n\r\np(pre). {@int N, A[N], B[N];@}\r\n{@void merge_sort(int l, int r)@}\r\n{@{@}\r\n{@    int m = (l + r) >> 1, i, j, k;@}\r\n{@    if (l == r) return;@}\r\n{@    merge_sort(l, m);@}\r\n{@    merge_sort(m + 1, r);@}\r\n{@    for (i=l, j=m+1, k=l; i<=m || j<=r; )@}\r\n{@        if (j > r || (i <= m && A[i] < A[j]))@}\r\n{@            B[k++] = A[i++];@}\r\n{@        else@}\r\n{@            B[k++] = A[j++];@}\r\n{@    for (k = l; k <= r; k++) A[k] = B[k];@}\r\n{@}@}\r\n\r\nh2. Recomandari generale\r\n\r\n# Programare dinamica cu memoizare: mult mai simplu si uneori chiar mai rapida cand nu ne trebuie tot array-ul\r\n# Algoritmi randomizati: de multe ori mai usor de implementat si mai eficienti, mai bine decat cei euristici, dar necesita o analiza mult mai atenta a performantei. Exemple calsice: quciksort, statistici de ordine\r\n\r\nh2. \"Smenul lui Mars\" (Marius Andrei)\r\n\r\nConsideram urmatoarea problema: se da un vector $A$ de $N$ elemente pe care se fac $M$ astfel de operatii: {@ADUNA(st, dr, x)@} - toate elementele cu indicii intre $st$ si $dr$ isi cresc valoarea cu {$x$}. La sfarsit trebuie sa se afiseze vectorul rezultat. In continuarea vom descrie o metoda care ne da un timp de rulare de $O(1)$ pentru operatia $ADUNA$ si $O(N)$ pentru a determina un element din vector. Vom construi un al doilea vector $B$ de $N+1$ elemente, cu proprietatea ca {$A{~i~} = B{~0~} + B{~1~} + ... B{~i~}$}. Astfel, o operatie {@ADUNA(st, dr, x)@} devine:\r\n\r\np(pre). {@B[st] += x;@}\r\n{@B[dr + 1] -= x;@}\r\n\r\nDa, este chiar asa de simplu! Pentru a determina un element A{~i~} vom aduna pur si simplu {$B{~0~} + B{~1~} + ... B{~i~}$}. Incercati pe foaie sa vedeti cum funtioneaza. Aceasta ideea poate fi extinsa si in doua dimensiuni, construind $B$ astfel incat $A{~i,j~}$ = suma subtabloului din $B$ cu coltul in ({$0, 0$}) si ({$i, j$}), astfel (pt. {@ADUNA(x1,y1,x2,y2,v)@}):\r\n\r\np(pre). {@B[x1][y1] += v;@}\r\n{@B[x1][y2 + 1] -= v;@}\r\n{@B[x2 + 1][y1] -= v;@}\r\n{@B[x2 + 1][y2 + 1] += v;@}\r\n\r\nPe cazul general, daca vrem sa facem operatii in $d$ dimensiuni vom avea o complexitate {$O(2^d^)$}. Reamintesc ca aceasta metoda este eficienta doar cand se vrea afisata vectorul/matricea/etc. doar la sfarsitul operatiilor, deoarece aflarea unui element este o operatie foarte ineficienta.\r\n\r\nh2. Grafuri cu liste de adiacenta (ideea originala de la Radu Berinde)\r\n\r\nSe stie (sau ar trebui sa se stie!) ca lucrul cu pointerii este foarte incet... astfel, cand retinem un graf rar (numar mare de noduri, numar mic de muchii) cu pointeri (vezi mai jos) incetinim foarte mult programul.\r\n\r\np(pre). {@struct list@}\r\n{@{@}\r\n{@    int n;@}\r\n{@    struct list *next;@}\r\n{@}@}\r\n{@typedef struct list list;@}\r\n\r\nIn contiuare vom prezenta o metoda care este de $3-4$ ori mai rapida (adica parcurgerile DF , BF sau altii algoritmi ruleaza de $3-4$ ori mai rapid cand graful este stocat astfel), dar are ca dezavantaj necesitatea de a citi de doua ori fisierul de intrare.\r\n\r\np(pre). {@#include <stdlib.h>@}\r\n{@#include <stdio.h>@}\r\n{@ @}\r\n{@int N, M, *G[N], Deg[N];@}\r\n{@ @}\r\n{@int main(void)@}\r\n{@{@}\r\n{@ @}\r\n{@    int i, j;@}\r\n{@ @}\r\n{@    freopen(\"in.txt\", \"r\", stdin);@}\r\n{@    scanf(\"%d %d\", &N, &M);@}\r\n{@    for (; M > 0; M--)@}\r\n{@    {@}\r\n{@        scanf(\"%d %d\", &i, &j);@}\r\n{@        Deg[i - 1]++, Deg[j - 1]++;@}\r\n{@    }@}\r\n{@    for (i = 0; i < N; Deg[i++] = 0)@}\r\n{@        G[i] = (int *) malloc(Deg[i]*sizeof(int));@}\r\n{@    fseek(stdin, 0, SEEK_SET);@}\r\n{@    scanf(\"%d %d\", &N, &M);@}\r\n{@    for (; M > 0; M--)@}\r\n{@    {@}\r\n{@        scanf(\"%d %d\", &i, &j);@}\r\n{@        i--, j--;@}\r\n{@        G[i][Deg[i]++] = j,@}\r\n{@            G[j][Deg[j]++] = i;@}\r\n{@    }@}\r\n{@ @}\r\n{@    return 0;@}\r\n{@}@}\r\n\r\nSporul de viteza se datoreaza faptului ca se folosesc vectori in loc de pointeri si struct-uri. Daca ne permite memoria putem evita citirea de doua ori a fisierul prin pastrarea muchiilor intr-o lista de muchii si apoi, dupa calcularea gradelor, inserarea muchiilor in liste. Pentru a demonstra eficienta acestei metode faceti urmatorul test: implementati o sursa cu pointeri si struct si implementati un BF, apoi scrieti codul de mai sus cu urmatoarele modificari:\r\n\r\np(pre). {@...@}\r\n{@for (i = 0; i < N; i++)@}\r\n{@{@}\r\n{@      G[i] = (int *) malloc((Deg[i]+1)*sizeof(int));@}\r\n{@      G[i][Deg[i]] = -1;@}\r\n{@      Deg[i] = 0;@}\r\n{@}@}\r\n{@...@}\r\n\r\nsi implementati BF astfel:\r\n\r\np(pre). {@void BF@}\r\n{@{@}\r\n{@      int Q[N], ql, qr, *p;@}\r\n{@      char U[N];@}\r\n{@      memset(U, 0, sizeof(U));@}\r\n{@      U[Q[ql = qr = 0] = n] = 1;@}\r\n{@      for (; ql <= qr; ql++)@}\r\n{@              for (p = G[Q[ql]]; *p != -1; p++)@}\r\n{@                      if (!U[*p]) U[Q[++qr] = *p] = 1;@}\r\n{@}@}\r\n\r\nApoi, incercati sa vedeti diferenta de timp intre cele doua programe... impresionant, nu?\r\n\r\n\r\n\r\nh2. Numere mari (ideea originala de la Radu Berinde)\r\n\r\nIn continuare voi prezenta cum se pot realiza operatii pe numere mari cu foarte putine linii de cod. In general, multi programatori se complica la aceste operatii, desi nu este nevoie! Vom considera ca numerele mari sunt vectori in care elementul de indice $0$ indica lungimea numarului, iar cifrele sunt retinute in ordinea inversa decat cea a citirii.\r\n\r\nh3. Suma a doua numere mari\r\n\r\np(pre). {@void add(int A[], int B[])@}\r\n{@{@}\r\n{@      int i, t = 0;@}\r\n{@      for (i=1; i<=A[0] || i<=B[0] || t; i++, t/=10)@}\r\n{@              A[i] = (t += A[i] + B[i]) % 10;@}\r\n{@      A[0] = i - 1;@}\r\n{@}@}\r\n\r\nh3. Inmultirea unui numar mare cu un numar mic\r\n\r\np(pre). {@void mul(int A[], int B)@}\r\n{@{@}\r\n{@      int i, t = 0;@}\r\n{@      for (i = 1; i <= A[0] || t; i++, t /= 10)@}\r\n{@              A[i] = (t += A[i] * B) % 10;@}\r\n{@      A[0] = i - 1;@}\r\n{@}@}\r\n\r\nh3. Inmultirea unui numar mare cu un numar mare\r\n\r\np(pre). {@void mul(int A[], int B[])@}\r\n{@{@}\r\n{@      int i, j, t, C[];@}\r\n{@      memset(C, 0, sizeof(C));@}\r\n{@      for (i = 1; i <= A[0]; i++)@}\r\n{@      {@}\r\n{@              for (t=0, j=1; j <= B[0] || t; j++, t/=10)@}\r\n{@                      C[i+j-1]=(t+=C[i+j-1]+A[i]*B[j])%10;@}\r\n{@              if (i + j - 2 > C[0]) C[0] = i + j - 2;@}\r\n{@      }@}\r\n{@      memcpy(A, C, sizeof(C));@}\r\n{@}@}\r\n\r\nh3. Scaderea a doua numere mari\r\n\r\np(pre). {@void sub(int A[], int B[])@}\r\n{@{@}\r\n{@      int i, t = 0;@}\r\n{@      for (i = 1; i <= A[0]; i++)@}\r\n{@              A[i] += (t = (A[i] -= B[i] + t) < 0) * 10;@}\r\n{@      for (; A[0] > 1 && !A[A[0]]; A[0]--);@}\r\n{@}@}\r\n\r\nh3. Impartirea unui numar mare la un numar mic\r\n\r\np(pre). {@void div(int A[], int B)@}\r\n{@{@}\r\n{@      int i, t = 0;@}\r\n{@      for (i = A[0]; i > 0; i--, t %= B)@}\r\n{@              A[i] = (t = t * 10 + A[i]) / B;@}\r\n{@      for (; A[0] > 1 && !A[A[0]]; A[0]--);@}\r\n{@}@}\r\n\r\nh3. Restul unui numar mare la un numar mic\r\n\r\np(pre). {@int mod(int A[], int B)@}\r\n{@{@}\r\n{@      int i, t = 0;@}\r\n{@      for (i = A[0]; i > 0; i--)@}\r\n{@              t = (t * 10 + A[i]) % B;@}\r\n{@      return t;@}\r\n{@}@}\r\n\r\nh2. AVL-uri (ideea originala de la Radu Berinde - again)\r\n\r\nAVL-urile sunt arbori de cautare echilibrati care au complexitate O(lg n) pe operatiile de inserare, stergere si cautare. Pentru mai multe detalii cautati cartea \"Arbori\" pe [2]site-ul doamnei profesoare Emanuela Cerchez. In continuare voi prezenta o metoda destul de simpla de a implementa aceastra structura de date in timp de concurs. Enjoy!\r\n\r\np(pre). {@#define max(a, b) ((a) > (b) ? (a) : (b))@}\r\n{@#define geth(n) (n->h = 1 + max(n->l->h, n->r->h))@}\r\n{@ @}\r\n{@struct node@}\r\n{@{@}\r\n{@      int key, h;@}\r\n{@      struct node *l, *r;@}\r\n{@} *R, *NIL;@}\r\n{@typedef struct node node;@}\r\n{@ @}\r\n{@void init(void)@}\r\n{@{@}\r\n{@      R = NIL = (node *) malloc(sizeof(node));@}\r\n{@      NIL->key = NIL->h = 0,@}\r\n{@ @}\r\n{@              NIL->l = NIL->r = NULL;@}\r\n{@}@}\r\n{@ @}\r\n{@node* rotleft(node *n)@}\r\n{@{@}\r\n{@      node *t = n->l;@}\r\n{@ @}\r\n{@      n->l = t->r, t->r = n,@}\r\n{@              geth(n), geth(t);@}\r\n{@      return t;@}\r\n{@}@}\r\n{@ @}\r\n{@node* rotright(node *n)@}\r\n{@{@}\r\n{@      node *t = n->r;@}\r\n{@ @}\r\n{@      n->r = t->l, t->l = n,@}\r\n{@              geth(n), geth(t);@}\r\n{@      return t;@}\r\n{@}@}\r\n{@ @}\r\n{@node* balance(node *n)@}\r\n{@{@}\r\n{@      geth(n);@}\r\n{@      if (n->l->h > n->r->h + 1)@}\r\n{@      {@}\r\n{@              if (n->l->r->h > n->l->l->h)@}\r\n{@                      n->l = rotright(n->l);@}\r\n{@              n = rotleft(n);@}\r\n{@      }@}\r\n{@      else@}\r\n{@              if (n->r->h > n->l->h + 1)@}\r\n{@              {@}\r\n{@                      if (n->r->l->h > n->r->r->h)@}\r\n{@                              n->r = rotleft(n->r);@}\r\n{@                      n = rotright(n);@}\r\n{@              }@}\r\n{@      return n;@}\r\n{@}@}\r\n{@ @}\r\n{@node* insert(node *n, int key)@}\r\n{@{@}\r\n{@      if (n == NIL)@}\r\n{@      {@}\r\n{@              n = (node *) malloc(sizeof(node));@}\r\n{@              n->key = key, n->h = 1, n->l = n->r = NIL;@}\r\n{@              return n;@}\r\n{@      }@}\r\n{@      if (key < n->key)@}\r\n{@              n->l = insert(n->l, key);@}\r\n{@      else@}\r\n{@              n->r = insert(n->r, key);@}\r\n{@      return balance(n);@}\r\n{@}@}\r\n{@ @}\r\n{@node* erase(node *n, int key)@}\r\n{@{@}\r\n{@      node *t;@}\r\n{@      if (n == NIL) return n;@}\r\n{@      if (n->key == key)@}\r\n{@      {@}\r\n{@              if (n->l == NIL || n->r == NIL)@}\r\n{@              {@}\r\n{@                      t = n->l == NIL ? n->r : n->l;@}\r\n{@                      free(n); return t;@}\r\n{@              }@}\r\n{@              else@}\r\n{@              {@}\r\n{@                      for (t = n->r; t->l != NIL; t = t->l);@}\r\n{@                      n->key = t->key,@}\r\n{@                              n->r = erase(n->r, t->key);@}\r\n{@                      return balance(n);@}\r\n{@              }@}\r\n{@      }@}\r\n{@      if (key < n->key)@}\r\n{@              n->l = erase(n->l, key);@}\r\n{@      else@}\r\n{@              n->r = erase(n->r, key);@}\r\n{@      return balance(n);@}\r\n{@}@}\r\n{@ @}\r\n{@int search(node *n, int key)@}\r\n{@{@}\r\n{@      if (n == NIL) return 0;@}\r\n{@      if (n->key == key) return 1;@}\r\n{@      if (key < n->key)@}\r\n{@              return search(n->l, key);@}\r\n{@      else@}\r\n{@              return search(n->r, key);@}\r\n{@}@}\r\n\r\nAici se termina acest articol. Am incercat sa pun accentul pe simplitate si eficienta, si cred ca am reusit acest lucru. Sper ca ati invatat cate ceva din el si recomand sa luati fiecare bucata in parte si sa incercati sa implementati efectiv ca sa intelegi mai bine. Bafta la concursuri tuturor! ;)\r\n\r\n',961,''),('usaco-oct-2005-divizia-gold','USACO oct 2005, divizia GOLD','2006-11-13 22:14:05','h1. USACO oct 2005, divizia GOLD\r\n\r\n(Creat de \'_greco_\':user/greco la data de _2005-11-21_ categoria _Competitii_, autor(i) _Florea Tiberiu_)\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nCa de obicei, USACO debuteaza in luna octombrie cu un concurs prin care oricine se poate califica la o divizie superioara celei in care se afla.\r\n\r\nRomania a avut $8$ concurenti care s-au calificat (sau recalificat) la divizia GOLD, fiind depasita in acest clasament doar de China ({$16$}) si SUA ({$10$}). Bineinteles, acest clasament nu este foarte relevant, deoarece multi dintre cei calificati deja au preferat sa nu participe sau sa nu ia concursul foarte in serios.\r\n\r\nElevii romani care au obtinut punctajul necesar pentru (re)calificare sunt:\r\n\r\n* Andrei Teodorescu (andreit1)\r\n* Vladu Adrian (azotlic1)\r\n* Andrei Blanaru (blanaru1)\r\n* Sorin Fagateanu (cyronon1)\r\n* Ionel Corneliu Gog (gogione1)\r\n* Tiberiu Florea (greco2)\r\n* Pasoi Mircea (mircea_1)\r\n* Vlad Berteanu (vladcyb1)\r\n\r\nProba a constat in $2$ probleme de nivel mediu care trebuiau rezolvate in $2$ ore.\r\n\r\nh2. Skiing\r\n\r\nPrima rezolvare care ne vine in minte citind o astfel de problema este transformarea matricii intr-un graf cu R * C noduri si calcularea drumului minim dintre nodurile ({$1, 1$}) si ({$R, C$}). O observatie destul de evidenta este ca toate muchiile care intra intr-un nod (a, b) vor avea acelasi cost, adica {$V * 2 ^ H{~1,1~} - H{~a,b~}^$}. Deoarece implementarea obisnuita a algoritmului Dijkstra are complexitatea $O (N^2^ + M)$ considerand $N$ = numarul de pozitii si $M$ numarul de muchii dintre acestea ({$N = R * C, M = 4 * R * C - 2 * (R + C)$}) va trebui implementata varianta in care se foloseste o coada de prioritate pentru nodurile care nu au fost explorate deja: implementand varianta cu heap-uri vom obtine complexitatea {$O((N + M) * lg N)$}, care se incadreaza in timp.\r\n\r\nPentru cei care nu sunt familiari cu aceasta varianta a algoritmului, ea arata cam asa:\r\n\r\np(pre). D{~sursa~} <- 0\r\nheap_sz = 1\r\nheap{~heap_sz~} <- sursa\r\npentru $i$ de la $1$ la $N$\r\n    daca i != sursa\r\n        D{~i~} <- oo\r\n        heap_sz <- heap_sz + 1\r\n        heap[heap_sz] <- i\r\ncat timp heap_sz > 0\r\n    x <- extrage_min (heap)\r\n    daca x = destinatie\r\n        returneaza D{~x~}\r\n    altfel\r\n        pentru i de la 1 la N\r\n            daca D{~i~} > D{~x~} + cost (x, i)\r\n                descreste_cheie (i, D{~x~} + cost (x,i))\r\n\r\nFiecare nod este extras cel mult o data din heap, si pentru fiecare muchie este apelata cel mult o data functia descreste_cheie. Fiecare dintre aceste operatii se efectueaza in {$O(lg N)$}, de aici rezultand complexitatea dorita.\r\n\r\nDe asemenea, putea fi aplicata o alta varianta a algoritmului Dijkstra, care profita mai mult de specificul problemei: In afara de vectorul estimarilor distantelor pana la fiecare nod, se memoreaza si nodul cu estimarea minima de pe fiecare din cele $R$ linii. Astfel, in momentul in care se extrage fiecare nod, cautam minimul in acest vector de dimensiune {$R$}, iar apoi reactualizam valoarea liniei pe care se afla nodul curent. Complexitatea acestui algoritm este {$O(N * R)$}, adica {$O(R^2^ * C)$}.\r\n\r\nIn implementarea oricaruia dintre acesti algoritmi trebuiau avute in vedere eventualele probleme cu precizia calculelor; o idee buna era ca numai costul final sa se inmulteasca cu {$V$}.\r\n\r\nh2. Flying right\r\n\r\nAceasta problema poate fi rezolvata cu ajutorul unui algoritm greedy, ideea nu este greu de gasit sau demonstrat, insa la implementare pot aparea unele probleme. In primul rand trebuie sa remarcam ca cele doua parti ale problemei se vor rezolva independent una de cealalta, drumurile se vor imparti in $2$ multimi (cele de dimineata, si cele de seara), si se va aplica aceeasi rezolvare pentru fiecare din cele doua multimi, raspunsul final fiind suma celor doua rezultate partiale. Rezolvarea urmatoare trateaza calcularea rezultatului optim pentru drumurile de dimineata.\r\n\r\nPentru fiecare din cele $N$ ferme tinem o lista de grupuri care doresc sa plece din orasul respectiv si sortam aceste liste crescator dupa indicele destinatiei fiecarui grup. Parcurgem in ordine cele $N$ ferme, memorand numarul si destinatiile vacilor care se afla la un moment dat in avion, sortate in ordine descrescatoare. In momentul in care am ajuns la ferma {$i$}, primul lucru pe care trebuie sa il facem este sa dam jos vacile care au ajuns la destinatie, incrementand corespunzator solutia de pana atunci. Evident, vacile care coboara la ferma respectiva se vor afla pe ultimele pozitii in ordinea descrisa din avion. Urmatorul pas este sa luam in avion din vacile care pleaca de la ferma $i$ pana cand acestea sunt epuizate sau capacitatea avionului este saturata. Daca au mai ramas vaci care nu au avut loc in avion, atata timp cat putem lua o vaca a carei destinatie este mai apropiata decat cea mai departata dintre destinatiile vacilor care se afla deja in avion, consideram ca vaca respectiva din avion nu a fost luata deloc, si ca alocam locul ei noii vaci, care va cobori mai repede.\r\n\r\nEste usor de vazut ca algoritmul de mai sus produce o solutie optima, insa implementarea sa nu este foarte lejera. Putem folosi urmatoarea metoda ({$v$} este un vector in care retinem destinatiile vacilor care se afla in avion, sortate descrescator):\r\n\r\np(pre). sol = 0, nr <- 0\r\npentru i de la 1 la N\r\n    cat timp nr > 0 si v{~nr~} = i\r\n        sol <- sol + 1\r\n        nr <- nr - 1\r\n        pentru j <- 1, j &le; C si j &le; nr vaci ce asteapta sa plece de la ferma i\r\n            nr <- nr + 1\r\n        v{~nr + 1~} = distanta celei de-a j-a vaci (in ordinea crescatoare a destinatiilor) de la ferma i\r\n        sorteaza v\r\n        pastreaza primele maxim C pozitii din v\r\n\r\nLa fiecare pas, vectorul $v$ poate fi sortat folosind {@qsort (stdlib.h)@} sau {@sort (algorithm)@}. Este necesar sa adaugam in $v$ doar primele $C$ vaci de la ferma {$i$}, deoarece daca o vaca nu este intre primele $C$ din multimea vacilor de la ferma {$i$}, este evident ca nu va fi nici intre primele $C$ din reuniunea acestei multimi cu multimea vacilor aflate deja in avion.\r\n\r\nSa recapitulam pasii algoritmului, alaturi de complexitatea fiecaruia dintre ei:\r\n\r\n* sortarea tuturor grupurilor dupa destinatie: $O(K * lg K)$\r\n* parcurgerea grupurilor si inserarea in listele corespunzatoare: $O(K)$\r\n* parcurgerea fermelor de la 1 la N, aplicand procedeul descris: $O(N * C * lg C)$\r\n\r\nAsadar, complexitatea totala a algoritmului este de {$O(K * lg K + N * C * lg C)$}, dand un timp de rulare rezonabil si o implementare fara mari batai de cap.\r\n\r\n',961,''),('hashing','Hashing','2006-11-13 22:33:02','h1. Hashing\n\n(Creat de \'_skipy_\':user/skipy la data de _2004-11-22_ categoria _Tabele de dispersie_, autor(i) _Giurgea Mihnea_)\n\n*Continut scurt:*\n ==Include(page=\"template/raw\")==\n\nDiverse modalitati pentru hashing / tabele de dispersie...\n\n\n*Continut lung:*\n==Include(page=\"template/raw\")==\n\n1. Scop hashing (sau tabele de dispersie)\n\nNe propunem sa creeem o structura de date eficienta care sa poata face urmatoarele operatii cat mai repede posibil: Insereaza, Cauta si Sterge. Ideea in spatele hashing-ului este memorarea unui element intr-un tablou sau lista in functie de cheia sa. Pe cazul mediu toate aceste operatii necesita O(1) timp. Sa vedem cum:\n\n2. Adresare directa\n\nElementele sunt puse intr-un tablou alocat static pe pozitiile cheilor lor. Prin adresare directa, un element cu cheia k va fi memorat in locatia k. Toate cele 3 operatii sunt extrem de simple(necesita doar o accesare de memorie), dar dezavantajul este ca aceasta tehnica \"mananca\" foarte multa memorie: O(|U|), unde U este universul de chei.\n\n3. Standard hashing\n\nPrimul pas in a rezolva problema memoriei este de a folosi O(N) memorie in loc de O(|U|), unde N este numarul de elemente adaugate in hash. Astfel, un element cu cheia k nu va fi memorat in locatia k, ci h(k), unde h : U -> {0,1,...,N-1} - o functie aleasa aleator, dar determinista( h(x) va returna mereu aceeasi valoare in cursul rularii unui program ). Daca functia este aleasa aleator, elementele vor fi \"imprastiate\" in hash in mod echivalent, egal. Ideal ar fi ca fiecare element sa fie stocat in locatia lui. Acest lucru insa nu este posibil, pentru ca N < |U| si, deci, de multe ori mai multe elemente vor fi repartizate in aceeasi locatie. Aceasta problema se numeste coliziune.\n\nCum rezolvam coliziunile?\n\nA) inlantuire\n\nIn fiecare locatie din hash tinem o lista inlantuita; astfel, la oricare din cele 3 operatii se va parcurge toata lista. Pe un caz pur teoretic, toate cele N elemente ar putea fi repartizate in aceeasi locatie, insa pe cazuri practice lungimea medie a celui mai lung lant este de lg(N).\n\nMemorie: O(N), pointeri: da\n\nB) \"liste statice\"\n\nAceasta metoda este o imbunatatire a punctului A): pentru ca lungimea unui lant este cel mult lg(N), putem sa folosim, in loc de liste inlantuite, vectori alocati dinamic de lungime lg(N) - sau lg(N) + 3, ca sa fiti siguri :). Scapam astfel de lucrul cu pointerii.\n\nMemorie: O(N*lg(N)), pointeri: nu\n\nC) adresare directa\n\nPrin adresare directa, toate elementele sunt memorate in tabela de hash. Pentru a realiza operatiile cerute, verificam succesiv tabela de hash pana cand fie gasim o locatie libera(in cazul Inserarii), fie gasim elementul cautat (pentru Cauta, Sterge). Insa, in loc sa cautam tabela de hash in ordinea 0,1,....,N-1, sirul de pozitii examinate depinde de cheia ce se insereaza. Pentru a determina locatiile corespunzatoare, extindem functia de hash astfel incat sa contina si numarul de verificare ca un al doilea parametru h : U * {0,1,....,N-1} -> {0,1,...,N-1}. Astfel, cand vom insera un element, verificam mai intai locatia h(k , 0), apoi h(k , 1) etc. Cand ajungem sa verificam h(k , N) putem sa ne oprim pentru ca tabela de hash este plina; pentru cautare aplicam aceeasi metoda; daca ajungem la h(k , N) sau la o pozitie goala inseamnca ca elementul nu exista. Stergerile se fac insa mai greu, pentru ca nu se poate \"sterge\" pur si simplu un element deoarece ar strica tot hash-ul; in schimb, se marcheaza\nlocatia ce trebuie stearsa cu o valoare STERS si se modifica functia Insereaza astfel incat sa vada locatiile cu valoarea STERS ca pozitii goale.\n\nMemorie: O(N), pointeri: nu\n\n\n\n4. Mihai Patrascu\'s Double hashing\n\nO imbunatarire foarte mare la tabela de hashing este... inca o tabela de hashing. Vom avea 2 tabele, fiecare cu proria ei functie de hash, iar coliziunile le rezolvam prin inlantuire; cand inseram un element il vom adauga in tabela in care intra intr-un lant mai scurt. Cautarea se face in ambele tabele in locatiile returnate de cele 2 functii de hash; stergerea la fel. Astfel, lungime celui mai lung lant va fi, in medie, lg(lg(N)). Dar, in practica, lungimea unui astfel de lant nu va depasi 4 elemente, pentru ca cel mai mic N pt care lg(lg(N)) = 5 este 2^32 ~ 2.000.000.000!!! Deci in loc de liste folosim vectori statice de dimensiune 4.\n\nMemorie: O(N), pointeri: nu\n\n5. Functii de hash\n\nToate functiile de hash intorc un numar intre 0 si M-1, unde M este dimensiunea maxima a tabelei de hash. Este recomandat ca M sa fie ales un numar prim si sa se evite alegerea lui M = 2^k.\n\nA) pentru numere intregi:\n\n* h(x) = x % M\n* h(x) = (x * r) % M , r - numar aleator ales la inceputul programului\n\nB) pentru 3. C)\n\n* h(x , i) = ( h\'(x) + i ) % M\n* h(x , i) = ( h\'(x) + r1 * i + r2 * i^2 ) % M\n* h(x , i) = ( h1(x) + i * h2(x) ) % M\n\nr1, r2 - numere alese aleator la inceputul programului.\n\nC) pentru numere reale\n\n* h(x) = [ {a * x} * M ] , 0 < a < 1\n\n{x} - partea fractionara a lui x; [x] = partea intreaga a lui x; [x] + {x} = x - prin definitie;\n\na este un numar care trebuie ales inainte sau la inceputul rularii programului; alegerea lui influenteaza eficienta functiei; Knuth propune urmatoarea valoare pentru a : ( sqrt(5) - 1 ) / 2 ~ 0.6180339887...\n\nTeme pentru acasa\n\nIncercati sa rezolvati urmatoarele probleme:\n\n[1]SGU 119: Magic Pairs\n\n[2]SGU 174: Walls\n\n[3]Algoritmus 3 - 3: Colinearitate\n\n\n\n\n\nReferences\n\nVisible links\n1. http://acm.sgu.ru/problem.php?contest=0&problem=119\n2. http://acm.sgu.ru/problem.php?contest=0&problem=174\n3. http://www.algoritmus.org/probleme/probleme_runda03.php\n\n',961,''),('multe-smenuri-de-programare-in-cc-si-nu-numai','Multe \"smenuri\" de programare in C/C++... si nu numai!','2006-11-14 11:52:27','h1. Multe \"smenuri\" de programare in C/C++... si nu numai!\r\n\r\n(Creat de \'_domino_\':user/domino la data de _2004-11-10_ categoria _Limbaje_, autor(i) _Mircea Pasoi_)\r\n\r\nAcest articol vine ca o completare a articolului scris de Alexandru Mosoi, prezentand noi trucuri care le-am folosit si m-au ajutat mult. O mare parte din acestea le-am invatat din sursele lui Radu Berinde (cred ca stiti cu totii cine este), asadar ii multumesc!\r\n\r\nh2. Array-uri neindexate de la 0\r\n\r\nUn dezavantaj fata de Pascal este faptul ca in C nu putem avea expresii de genul {@A[-100]@} unde $A$ este un vector. Dar acest lucru se poate remedia. Spre exemplu, daca vrem sa facem un vector $A$ cu elemente de la $-100$ la $100$ procedam astfel:\r\n\r\np(pre). {@int A[201];@}\r\n{@#define A (A + 100)@}\r\n\r\nh2. Fisiere de intrare si iesire\r\n\r\nFolositi {@freopen()@} in loc de {@fopen()@} deoarece este mai comod, in special la concursurile in care intrare si iesirea sunt standard.\r\n\r\np(pre). {@freopen(\"in.txt\", \"r\", stdin);@}\r\n{@freopen(\"out.txt\", \"w\", stdout);@}\r\n\r\nh2. Cautare binara (ideea originala de la Mihai Patrascu)\r\n\r\nUrmatorul cod este de aproximativ $4$ ori mai rapid (am testat cu cautare binara ca in manual) , mai usor de inteles, mai flexibil si mai scurt... ce ati putea dori mai mult?\r\n\r\np(pre). {@int N, A[N];@}\r\n{@int binary_search(int val)@}\r\n{@{@}\r\n{@    int i, step;@}\r\n{@    for (step = 1; step < N; step <<= 1);@}\r\n{@    for (i = 0; step; step >>= 1)@}\r\n{@        if (i + step < N && A[i + step] <= val)@}\r\n{@           i += step;@}\r\n{@    return i;@}\r\n{@}@}\r\n\r\nProcedura de mai sus face cautarea binara folosind puteri a lui $2$ in ordine descrescatoare, practic incerc sa determin fiecare bit al rezultatului.\r\n\r\nh2. Impartire in bucati de marime $sqrt(n)$ (cunoscut si ca \"smenul lui Bogdan Batog\")\r\n\r\nSa presupunem ca avem un vector de lungime n cu numere reale pe care se fac urmatoarele operatii:\r\n{@ADUNA(st, dr, x)@} - toate elementele cu indicii intre $st$ si $dr$ isi cresc valoarea cu $x$\r\n{@SUMA(st, dr)@} - returneaza suma elementelor cu indicii intre $st$ si $dr$\r\n\r\nPentru cei ce cunosc arbori de intervale, rezolvarea acestei probleme in $O(lg n)$ per operatie este o munca usoara, dar presupunand ca nu stim aceasta structura putem folosi urmatorul truc: vom construi un al doilea vector de lungime $sqrt(n)$ care retine suma elementelor pe bucati de lungime {$sqrt(n)$}. Pentru a face o operatie pe un interval [{$st, dr$}] vom imparti acest interval in bucati de $sqrt(n)$ a caror actualizare o facem in vectorul $B$ si elementele care raman in margine in vectorul {$A$}. De exemplu pe vectorul {$A{~0..15~}$} vom avea vectorul {$B{~0..3~}$}. Pentru a actualiza de exemplu [{$2, 12$}] vom actualiza {$B{~1~}$} (care corespunde lui [{$4..7$}]), {$B{~2~}$} (pentru [{$8..11$}]) si {$A{~2~}$}, {$A{~3~}$}, {$A{~12~}$} (elementele din margini). Cum sunt maxim $sqrt(n)$ elemente de actualizat in $B$ si pe margini nu vom actualiza niciodata mai mult de $2 * sqrt(n)$ elemente putem concluziona ca operatiile vor avea complexitate {$O(sqrt(n))$}.\r\n\r\nDaca am avea aceeasi problema dar in doua dimensiuni, am putea face acelasi \"smen\" pentru fiecare linie pentru o complexitate $O(n*sqrt(n))$ per operatie, sau cu arbori de intervale pe fiecare linie {$O(n*lg n)$}. Putem, de asemenea obtine o complexitate $O(n)$ folosind urmatoarea impartire:\r\n$A$ - pentru bucati $1 * 1$\r\n$B$ - pentru bucati $sqrt(n) * sqrt(n)$\r\n$C$ - pentru bucati $1 * sqrt(n)$\r\n$D$ - pentru bucati $sqrt(n) * 1$\r\nAcest mod de reprezentare este o extindere directa a aceluiasi smen in doua dimensiuni. Aceasta idee poate fi folosita si pentru alte operatii: inmultire, minim, maxim, etc. In general, orice se poate rezolva cu acest \"smen\" se poate obtine la o complexitate mai buna cu arbori de intervale, dar merita sa stiti si aceasta ideea deoarece de multe ori scuteste din efortul de implementare, desi se pierde din viteza... alegerea voastra! ;)\r\n\r\nh2. LCA in $O(sqrt(n))$ (ideea originala de la Radu Berinde)\r\n\r\nDaca nu stiti ce este LCA, va recomand sa cititi \"articolul\":http://www.infoarena.ro/LCA_Lowest_common_ancestor lui Emilian Miron din cadrul site-ului pentru a va documenta. In continuare vom prezenta un algoritm mai ineficient, dar foarte usor de implementat. Consideram arborele si atribuim fiecarui nod o inaltime. Vom imparti arborele in $sqrt(H)$ intervale in functie de inaltime, unde $H$ e inaltimea maxima (de exemplu la $H=9$ nodurile cu inaltimi intre $0$ si $2$ vor forma un interval, [{$3..5$}] alt interval si ultimul interval de inaltimi [{$6..8$}]). Astfel, pentru fiecare nod, pe langa tatal sau, vom retine si tatal din intervalul de mai sus, printr-o parcurede DF. In continuare, codul:\r\n\r\n$H$ se calculeaza inainte sau poate fi constant\r\n$T$ sunt tatii nodului si $N$ numarul de noduri\r\n\r\np(pre). {@void DF(int n, int t2, int lev)@}\r\n{@{@}\r\n{@    int i;@}\r\n{@    T2[n] = t2, Lev[n] = lev;@}\r\n{@    if (lev % H @}&#0061;&#0061;{@ 0) t2 = n;@}\r\n{@    for (i = 0; i < N; i++)@}\r\n{@        if (T[i] @}&#0061;&#0061;{@ n) DF(i, t2, lev+1);@}\r\n{@}@}\r\n\r\nOperatia de LCA se va realiza apoi foarte usor, urcand pe tatii din intervale, pana se ajunge la doua noduri in acelasi interval, apoi folosindu-se metoda clasica. Cod:\r\n\r\np(pre). {@int LCA(int x, int y)@}\r\n{@{@}\r\n{@    while (T2[x] != T2[y])@}\r\n{@        if (Lev[x] > Lev[y])@}\r\n{@            x = T2[x];@}\r\n{@        else@}\r\n{@            y = T2[y];@}\r\n{@    while (x != y)@}\r\n{@        if (Lev[x] > Lev[y])@}\r\n{@            x = T[x];@}\r\n{@        else@}\r\n{@            y = T[y];@}\r\n{@    return x;@}\r\n{@}@}\r\n\r\n\r\n\r\nh2. LCA in $O(lg^2^ n)$\r\n\r\nAceeasi problema, dar o alta rezolvare. Vom construi o matrice $A{~i,j~}$ cu semnificatia $A{~i,j~}$ = al {$2^i^$}-lea tata al nodului {$j$}. Folosind aceasta matrice putem cauta binar ({$O(lg n)$}) nivelul pe care s-ar putea afla LCA-ul a doua noduri si sa determinam daca nodul ales este corect - adica daca nodul situat la acel nivel este acelasi pentru cele doua noduri pentru care se face LCA ({$O(lg n)$} cu matricea de mai sus). Complexitate finala $O(lg^2^ n)$ si $O(n*lg n)$ memorie.\r\n\r\nh2. For-uri \"complicate\"\r\n\r\nfor-ul in C/C++ este foarte flexibil si poate ajuta foarte mult in compactarea codului, deci si a timpului de implementare. In continuare vom prezenta algoritmul merge sort (sortare prin interclasare) scris in cateva linii (putine, zic eu!):\r\n\r\np(pre). {@int N, A[N], B[N];@}\r\n{@void merge_sort(int l, int r)@}\r\n{@{@}\r\n{@    int m = (l + r) >> 1, i, j, k;@}\r\n{@    if (l @}&#0061;&#0061;{@ r) return;@}\r\n{@    merge_sort(l, m);@}\r\n{@    merge_sort(m + 1, r);@}\r\n{@    for (i=l, j=m+1, k=l; i<=m || j<=r; )@}\r\n{@        if (j > r || (i <= m && A[i] < A[j]))@}\r\n{@            B[k++] = A[i++];@}\r\n{@        else@}\r\n{@            B[k++] = A[j++];@}\r\n{@    for (k = l; k <= r; k++) A[k] = B[k];@}\r\n{@}@}\r\n\r\nh2. Recomandari generale\r\n\r\n# Programare dinamica cu memoizare: mult mai simplu si uneori chiar mai rapida cand nu ne trebuie tot array-ul\r\n# Algoritmi randomizati: de multe ori mai usor de implementat si mai eficienti, mai bine decat cei euristici, dar necesita o analiza mult mai atenta a performantei. Exemple calsice: quciksort, statistici de ordine\r\n\r\nh2. \"Smenul lui Mars\" (Marius Andrei)\r\n\r\nConsideram urmatoarea problema: se da un vector $A$ de $N$ elemente pe care se fac $M$ astfel de operatii: {@ADUNA(st, dr, x)@} - toate elementele cu indicii intre $st$ si $dr$ isi cresc valoarea cu {$x$}. La sfarsit trebuie sa se afiseze vectorul rezultat. In continuarea vom descrie o metoda care ne da un timp de rulare de $O(1)$ pentru operatia $ADUNA$ si $O(N)$ pentru a determina un element din vector. Vom construi un al doilea vector $B$ de $N+1$ elemente, cu proprietatea ca {$A{~i~} = B{~0~} + B{~1~} + ... B{~i~}$}. Astfel, o operatie {@ADUNA(st, dr, x)@} devine:\r\n\r\np(pre). {@B[st] += x;@}\r\n{@B[dr + 1] -= x;@}\r\n\r\nDa, este chiar asa de simplu! Pentru a determina un element A{~i~} vom aduna pur si simplu {$B{~0~} + B{~1~} + ... B{~i~}$}. Incercati pe foaie sa vedeti cum funtioneaza. Aceasta ideea poate fi extinsa si in doua dimensiuni, construind $B$ astfel incat $A{~i,j~}$ = suma subtabloului din $B$ cu coltul in ({$0, 0$}) si ({$i, j$}), astfel (pt. {@ADUNA(x1,y1,x2,y2,v)@}):\r\n\r\np(pre). {@B[x1][y1] += v;@}\r\n{@B[x1][y2 + 1] -= v;@}\r\n{@B[x2 + 1][y1] -= v;@}\r\n{@B[x2 + 1][y2 + 1] += v;@}\r\n\r\nPe cazul general, daca vrem sa facem operatii in $d$ dimensiuni vom avea o complexitate {$O(2^d^)$}. Reamintesc ca aceasta metoda este eficienta doar cand se vrea afisata vectorul/matricea/etc. doar la sfarsitul operatiilor, deoarece aflarea unui element este o operatie foarte ineficienta.\r\n\r\nh2. Grafuri cu liste de adiacenta (ideea originala de la Radu Berinde)\r\n\r\nSe stie (sau ar trebui sa se stie!) ca lucrul cu pointerii este foarte incet... astfel, cand retinem un graf rar (numar mare de noduri, numar mic de muchii) cu pointeri (vezi mai jos) incetinim foarte mult programul.\r\n\r\np(pre). {@struct list@}\r\n{@{@}\r\n{@    int n;@}\r\n{@    struct list *next;@}\r\n{@}@}\r\n{@typedef struct list list;@}\r\n\r\nIn contiuare vom prezenta o metoda care este de $3-4$ ori mai rapida (adica parcurgerile DF , BF sau altii algoritmi ruleaza de $3-4$ ori mai rapid cand graful este stocat astfel), dar are ca dezavantaj necesitatea de a citi de doua ori fisierul de intrare.\r\n\r\np(pre). {@#include <stdlib.h>@}\r\n{@#include <stdio.h>@}\r\n{@ @}\r\n{@int N, M, *G[N], Deg[N];@}\r\n{@ @}\r\n{@int main(void)@}\r\n{@{@}\r\n{@ @}\r\n{@    int i, j;@}\r\n{@ @}\r\n{@    freopen(\"in.txt\", \"r\", stdin);@}\r\n{@    scanf(\"%d %d\", &N, &M);@}\r\n{@    for (; M > 0; M--)@}\r\n{@    {@}\r\n{@        scanf(\"%d %d\", &i, &j);@}\r\n{@        Deg[i - 1]++, Deg[j - 1]++;@}\r\n{@    }@}\r\n{@    for (i = 0; i < N; Deg[i++] = 0)@}\r\n{@        G[i] = (int *) malloc(Deg[i]*sizeof(int));@}\r\n{@    fseek(stdin, 0, SEEK_SET);@}\r\n{@    scanf(\"%d %d\", &N, &M);@}\r\n{@    for (; M > 0; M--)@}\r\n{@    {@}\r\n{@        scanf(\"%d %d\", &i, &j);@}\r\n{@        i--, j--;@}\r\n{@        G[i][Deg[i]++] = j,@}\r\n{@            G[j][Deg[j]++] = i;@}\r\n{@    }@}\r\n{@ @}\r\n{@    return 0;@}\r\n{@}@}\r\n\r\nSporul de viteza se datoreaza faptului ca se folosesc vectori in loc de pointeri si struct-uri. Daca ne permite memoria putem evita citirea de doua ori a fisierul prin pastrarea muchiilor intr-o lista de muchii si apoi, dupa calcularea gradelor, inserarea muchiilor in liste. Pentru a demonstra eficienta acestei metode faceti urmatorul test: implementati o sursa cu pointeri si struct si implementati un BF, apoi scrieti codul de mai sus cu urmatoarele modificari:\r\n\r\np(pre). {@...@}\r\n{@for (i = 0; i < N; i++)@}\r\n{@{@}\r\n{@      G[i] = (int *) malloc((Deg[i]+1)*sizeof(int));@}\r\n{@      G[i][Deg[i]] = -1;@}\r\n{@      Deg[i] = 0;@}\r\n{@}@}\r\n{@...@}\r\n\r\nsi implementati BF astfel:\r\n\r\np(pre). {@void BF@}\r\n{@{@}\r\n{@      int Q[N], ql, qr, *p;@}\r\n{@      char U[N];@}\r\n{@      memset(U, 0, sizeof(U));@}\r\n{@      U[Q[ql = qr = 0] = n] = 1;@}\r\n{@      for (; ql <= qr; ql++)@}\r\n{@              for (p = G[Q[ql]]; *p != -1; p++)@}\r\n{@                      if (!U[*p]) U[Q[++qr] = *p] = 1;@}\r\n{@}@}\r\n\r\nApoi, incercati sa vedeti diferenta de timp intre cele doua programe... impresionant, nu?\r\n\r\n\r\n\r\nh2. Numere mari (ideea originala de la Radu Berinde)\r\n\r\nIn continuare voi prezenta cum se pot realiza operatii pe numere mari cu foarte putine linii de cod. In general, multi programatori se complica la aceste operatii, desi nu este nevoie! Vom considera ca numerele mari sunt vectori in care elementul de indice $0$ indica lungimea numarului, iar cifrele sunt retinute in ordinea inversa decat cea a citirii.\r\n\r\nh3. Suma a doua numere mari\r\n\r\np(pre). {@void add(int A[], int B[])@}\r\n{@{@}\r\n{@      int i, t = 0;@}\r\n{@      for (i=1; i<=A[0] || i<=B[0] || t; i++, t/=10)@}\r\n{@              A[i] = (t += A[i] + B[i]) % 10;@}\r\n{@      A[0] = i - 1;@}\r\n{@}@}\r\n\r\nh3. Inmultirea unui numar mare cu un numar mic\r\n\r\np(pre). {@void mul(int A[], int B)@}\r\n{@{@}\r\n{@      int i, t = 0;@}\r\n{@      for (i = 1; i <= A[0] || t; i++, t /= 10)@}\r\n{@              A[i] = (t += A[i] * B) % 10;@}\r\n{@      A[0] = i - 1;@}\r\n{@}@}\r\n\r\nh3. Inmultirea unui numar mare cu un numar mare\r\n\r\np(pre). {@void mul(int A[], int B[])@}\r\n{@{@}\r\n{@      int i, j, t, C[];@}\r\n{@      memset(C, 0, sizeof(C));@}\r\n{@      for (i = 1; i <= A[0]; i++)@}\r\n{@      {@}\r\n{@              for (t=0, j=1; j <= B[0] || t; j++, t/=10)@}\r\n{@                      C[i+j-1]=(t+=C[i+j-1]+A[i]*B[j])%10;@}\r\n{@              if (i + j - 2 > C[0]) C[0] = i + j - 2;@}\r\n{@      }@}\r\n{@      memcpy(A, C, sizeof(C));@}\r\n{@}@}\r\n\r\nh3. Scaderea a doua numere mari\r\n\r\np(pre). {@void sub(int A[], int B[])@}\r\n{@{@}\r\n{@      int i, t = 0;@}\r\n{@      for (i = 1; i <= A[0]; i++)@}\r\n{@              A[i] += (t = (A[i] -= B[i] + t) < 0) * 10;@}\r\n{@      for (; A[0] > 1 && !A[A[0]]; A[0]--);@}\r\n{@}@}\r\n\r\nh3. Impartirea unui numar mare la un numar mic\r\n\r\np(pre). {@void div(int A[], int B)@}\r\n{@{@}\r\n{@      int i, t = 0;@}\r\n{@      for (i = A[0]; i > 0; i--, t %= B)@}\r\n{@              A[i] = (t = t * 10 + A[i]) / B;@}\r\n{@      for (; A[0] > 1 && !A[A[0]]; A[0]--);@}\r\n{@}@}\r\n\r\nh3. Restul unui numar mare la un numar mic\r\n\r\np(pre). {@int mod(int A[], int B)@}\r\n{@{@}\r\n{@      int i, t = 0;@}\r\n{@      for (i = A[0]; i > 0; i--)@}\r\n{@              t = (t * 10 + A[i]) % B;@}\r\n{@      return t;@}\r\n{@}@}\r\n\r\nh2. AVL-uri (ideea originala de la Radu Berinde - again)\r\n\r\nAVL-urile sunt arbori de cautare echilibrati care au complexitate O(lg n) pe operatiile de inserare, stergere si cautare. Pentru mai multe detalii cautati cartea \"Arbori\" pe [2]site-ul doamnei profesoare Emanuela Cerchez. In continuare voi prezenta o metoda destul de simpla de a implementa aceastra structura de date in timp de concurs. Enjoy!\r\n\r\np(pre). {@#define max(a, b) ((a) > (b) ? (a) : (b))@}\r\n{@#define geth(n) (n->h = 1 + max(n->l->h, n->r->h))@}\r\n{@ @}\r\n{@struct node@}\r\n{@{@}\r\n{@      int key, h;@}\r\n{@      struct node *l, *r;@}\r\n{@} *R, *NIL;@}\r\n{@typedef struct node node;@}\r\n{@ @}\r\n{@void init(void)@}\r\n{@{@}\r\n{@      R = NIL = (node *) malloc(sizeof(node));@}\r\n{@      NIL->key = NIL->h = 0,@}\r\n{@ @}\r\n{@              NIL->l = NIL->r = NULL;@}\r\n{@}@}\r\n{@ @}\r\n{@node* rotleft(node *n)@}\r\n{@{@}\r\n{@      node *t = n->l;@}\r\n{@ @}\r\n{@      n->l = t->r, t->r = n,@}\r\n{@              geth(n), geth(t);@}\r\n{@      return t;@}\r\n{@}@}\r\n{@ @}\r\n{@node* rotright(node *n)@}\r\n{@{@}\r\n{@      node *t = n->r;@}\r\n{@ @}\r\n{@      n->r = t->l, t->l = n,@}\r\n{@              geth(n), geth(t);@}\r\n{@      return t;@}\r\n{@}@}\r\n{@ @}\r\n{@node* balance(node *n)@}\r\n{@{@}\r\n{@      geth(n);@}\r\n{@      if (n->l->h > n->r->h + 1)@}\r\n{@      {@}\r\n{@              if (n->l->r->h > n->l->l->h)@}\r\n{@                      n->l = rotright(n->l);@}\r\n{@              n = rotleft(n);@}\r\n{@      }@}\r\n{@      else@}\r\n{@              if (n->r->h > n->l->h + 1)@}\r\n{@              {@}\r\n{@                      if (n->r->l->h > n->r->r->h)@}\r\n{@                              n->r = rotleft(n->r);@}\r\n{@                      n = rotright(n);@}\r\n{@              }@}\r\n{@      return n;@}\r\n{@}@}\r\n{@ @}\r\n{@node* insert(node *n, int key)@}\r\n{@{@}\r\n{@      if (n @}&#0061;&#0061;{@ NIL)@}\r\n{@      {@}\r\n{@              n = (node *) malloc(sizeof(node));@}\r\n{@              n->key = key, n->h = 1, n->l = n->r = NIL;@}\r\n{@              return n;@}\r\n{@      }@}\r\n{@      if (key < n->key)@}\r\n{@              n->l = insert(n->l, key);@}\r\n{@      else@}\r\n{@              n->r = insert(n->r, key);@}\r\n{@      return balance(n);@}\r\n{@}@}\r\n{@ @}\r\n{@node* erase(node *n, int key)@}\r\n{@{@}\r\n{@      node *t;@}\r\n{@      if (n @}&#0061;&#0061;{@ NIL) return n;@}\r\n{@      if (n->key @}&#0061;&#0061;{@ key)@}\r\n{@      {@}\r\n{@              if (n->l @}&#0061;&#0061;{@ NIL || n->r == NIL)@}\r\n{@              {@}\r\n{@                      t = n->l @}&#0061;&#0061;{@ NIL ? n->r : n->l;@}\r\n{@                      free(n); return t;@}\r\n{@              }@}\r\n{@              else@}\r\n{@              {@}\r\n{@                      for (t = n->r; t->l != NIL; t = t->l);@}\r\n{@                      n->key = t->key,@}\r\n{@                              n->r = erase(n->r, t->key);@}\r\n{@                      return balance(n);@}\r\n{@              }@}\r\n{@      }@}\r\n{@      if (key < n->key)@}\r\n{@              n->l = erase(n->l, key);@}\r\n{@      else@}\r\n{@              n->r = erase(n->r, key);@}\r\n{@      return balance(n);@}\r\n{@}@}\r\n{@ @}\r\n{@int search(node *n, int key)@}\r\n{@{@}\r\n{@      if (n @}&#0061;&#0061;{@ NIL) return 0;@}\r\n{@      if (n->key @}&#0061;&#0061;{@ key) return 1;@}\r\n{@      if (key < n->key)@}\r\n{@              return search(n->l, key);@}\r\n{@      else@}\r\n{@              return search(n->r, key);@}\r\n{@}@}\r\n\r\nAici se termina acest articol. Am incercat sa pun accentul pe simplitate si eficienta, si cred ca am reusit acest lucru. Sper ca ati invatat cate ceva din el si recomand sa luati fiecare bucata in parte si sa incercati sa implementati efectiv ca sa intelegi mai bine. Bafta la concursuri tuturor! ;)\r\n\r\n',961,''),('sandbox','Sandbox','2006-11-13 13:35:39','\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',18,''),('sandbox','Sandbox','2006-11-14 23:55:12','bc.. \r\nvoid DF(int n, int t2, int lev)\r\n{\r\n    int i;\r\n    T2[n] = t2, Lev[n] = lev;\r\n    if (lev % H &#8801;= 0) t2 = n;\r\n    for (i = 0; i < N; i++)\r\n        if (T[i] == n) DF(i, t2, lev+1);\r\n}\r\n\r\n\r\np. &nbsp;\r\n\r\n\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',1142,''),('sandbox','Sandbox','2006-11-14 23:55:38','bc.. \r\nvoid DF(int n, int t2, int lev)\r\n{\r\n    int i;\r\n    T2[n] = t2, Lev[n] = lev;\r\n    if (lev % H == 0) t2 = n;\r\n    for (i = 0; i < N; i++)\r\n        if (T[i] == n) DF(i, t2, lev+1);\r\n}\r\n\r\n\r\np. &nbsp;\r\n\r\n\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',1142,''),('sandbox','Sandbox','2006-11-14 23:59:08','p(pre).\r\nvoid DF(int n, int t2, int lev)\r\n{\r\n    int i;\r\n    T2[n] = t2, Lev[n] = lev;\r\n    if (lev % H &equiv;&eq; 0) t2 = n;\r\n    for (i = 0; i < N; i++)\r\n        if (T[i] == n) DF(i, t2, lev+1);\r\n}\r\n\r\np. &nbsp;\r\n\r\n\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',1142,''),('sandbox','Sandbox','2006-11-15 00:34:50','\r\n== code(cpp) | \r\n\r\nvoid DF(int n, int t2, int lev)\r\n{\r\n    int i;\r\n    T2[n] = t2, Lev[n] = lev;\r\n    if (lev % H == 0) t2 = n;\r\n    for (i = 0; i < N; i++)\r\n        if (T[i] == n) DF(i, t2, lev+1);\r\n}\r\n\r\n== \r\n\r\n\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',13,''),('sandbox','Sandbox','2006-11-15 02:43:11','bc.. void DF(int n, int t2, int lev)\r\n{\r\n    int i;\r\n    T2[n] = t2, Lev[n] = lev;\r\n    if (lev % H == 0) t2 = n;\r\n    for (i = 0; i < N; i++)\r\n        if (T[i] == n) DF(i, t2, lev+1);\r\n}\r\n\r\np1. &nbsp\r\n\r\n\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',1142,''),('sandbox','Sandbox','2006-11-15 02:45:45','h1. Titlu\r\n\r\nUite aici code frate: \r\n\r\nh1. Capsuni\r\n\r\nbc[cpp].. \r\n#include <stdio.h>\r\n\r\nint main() {\r\n    int x, y;\r\n    scanf(\"%d%d\", &x, &y);\r\n    if (x == y) {\r\n        printf(\"%d\", x + y)\r\n    } else if (x == y / 2) {\r\n        printf(\"%d\", x + y);\r\n    }\r\n}\r\n\r\np. &nbsp;\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',1142,''),('sandbox','Sandbox','2006-11-15 02:46:42','bc..\r\nvoid DF(int n, int t2, int lev)\r\n{\r\n    int i;\r\n    T2[n] = t2, Lev[n] = lev;\r\n    if (lev % H == 0) t2 = n;\r\n    for (i = 0; i < N; i++)\r\n        if (T[i] == n) DF(i, t2, lev+1);\r\n}\r\n\r\np1. &nbsp\r\n\r\n\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',1142,''),('sandbox','Sandbox','2006-11-15 02:47:20','h1. dsfdsjfds\r\n\r\nbc[cpp]..\r\nvoid DF(int n, int t2, int lev)\r\n{\r\n    int i;\r\n    T2[n] = t2, Lev[n] = lev;\r\n    if (lev % H == 0) t2 = n;\r\n    for (i = 0; i < N; i++)\r\n        if (T[i] == n) DF(i, t2, lev+1);\r\n}\r\n\r\np1. &nbsp;\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',1142,''),('home','info-arena 2.0','2006-11-15 02:49:22','==html|<img src=\"http://msig.info/web2v2/info-arena+2.0BETA.png\" alt=\"info-arena 2.0 BETA\" />==\r\n\r\nSite-ul este complet editabil de catre administratori. Se recomanda sa citesti \'documentatia de textile\':Textile. Daca vrei sa testezi optiunile de formatare ale Textile poti sa te duci in \'sandbox\':Sandbox ca sa testezi.\r\n\r\nAtentie: S-a reparat bug-ul cu == in bc. Folositi bc[limbaj] pentru blocuri de cod sursa. *Nu* e urgent, dar e mai bine decat cu @ @.\r\n\r\nAm sters si pula cea de aur.\r\n\r\ntable. | Continut care mai trebuie formatat:\r\n&nbsp;\r\n* \"Articole\":Articles\r\n* \"News\":News\r\n&nbsp;\r\nDe asemenea, mai trebuie convertit *TOT* continutul din \"wiki-ul\":http://infoarena.devnet.ro/wiki/index.php/Main_Page vechi. |\r\n\r\nAici e \'arhiva de probleme\':round/arhiva.\r\n\r\nDaca esti admin vezi \'lista rundelor\':page_index?prefix=round si \'lista problemelor\':page_index?prefix=task.\r\n\r\nh2. Ultimele 3 stiri\r\n\r\n==News(pager_style=\"none\" display_entries=\"3\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':news',1142,''),('home','info-arena 2.0','2006-11-15 02:50:38','==html|<img src=\"http://msig.info/web2v2/info-arena+2.0BETA.png\" alt=\"info-arena 2.0 BETA\" />==\r\n\r\nSite-ul este complet editabil de catre administratori. Se recomanda sa citesti \'documentatia de textile\':Textile. Daca vrei sa testezi optiunile de formatare ale Textile poti sa te duci in \'sandbox\':Sandbox ca sa testezi.\r\n\r\nAtentie: S-a reparat bug-ul cu == in bc. Folositi {@bc[limbaj].. @} pentru blocuri de cod sursa. *Nu* e urgent, dar e mai bine decat cu @ @ pe fiecare linie.\r\n\r\nAm sters si pula cea de aur.\r\n\r\ntable. | Continut care mai trebuie formatat:\r\n&nbsp;\r\n* \"Articole\":Articles\r\n* \"News\":News\r\n&nbsp;\r\nDe asemenea, mai trebuie convertit *TOT* continutul din \"wiki-ul\":http://infoarena.devnet.ro/wiki/index.php/Main_Page vechi. |\r\n\r\nAici e \'arhiva de probleme\':round/arhiva.\r\n\r\nDaca esti admin vezi \'lista rundelor\':page_index?prefix=round si \'lista problemelor\':page_index?prefix=task.\r\n\r\nh2. Ultimele 3 stiri\r\n\r\n==News(pager_style=\"none\" display_entries=\"3\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':news',1142,''),('multe-smenuri-de-programare-in-cc-si-nu-numai','Multe \"smenuri\" de programare in C/C++... si nu numai!','2006-11-15 12:29:55','h1. Multe \"smenuri\" de programare in C/C++... si nu numai!\r\n\r\n(Creat de ==user(user=\"domino\" type=\"tiny\")== la data de _2004-11-10_ categoria _Limbaje_, autor(i) _Mircea Pasoi_)\r\n\r\nAcest articol vine ca o completare a articolului scris de Alexandru Mosoi, prezentand noi trucuri care le-am folosit si m-au ajutat mult. O mare parte din acestea le-am invatat din sursele lui Radu Berinde (cred ca stiti cu totii cine este), asadar ii multumesc!\r\n\r\nh2. Array-uri neindexate de la 0\r\n\r\nUn dezavantaj fata de Pascal este faptul ca in C nu putem avea expresii de genul {@A[-100]@} unde $A$ este un vector. Dar acest lucru se poate remedia. Spre exemplu, daca vrem sa facem un vector $A$ cu elemente de la $-100$ la $100$ procedam astfel:\r\n\r\n== code(c) |\r\nint A[201];\r\n#define A (A + 100)\r\n==\r\n\r\nh2. Fisiere de intrare si iesire\r\n\r\nFolositi {@freopen()@} in loc de {@fopen()@} deoarece este mai comod, in special la concursurile in care intrare si iesirea sunt standard.\r\n\r\n== code(c) |\r\nfreopen(\"in.txt\", \"r\", stdin);\r\nfreopen(\"out.txt\", \"w\", stdout);\r\n==\r\n\r\nh2. Cautare binara (ideea originala de la Mihai Patrascu)\r\n\r\nUrmatorul cod este de aproximativ $4$ ori mai rapid (am testat cu cautare binara ca in manual) , mai usor de inteles, mai flexibil si mai scurt... ce ati putea dori mai mult?\r\n\r\n== code(c) |\r\nint N, A[N];\r\n\r\nint binary_search(int val)\r\n{\r\n    int i, step;\r\n    for (step = 1; step < N; step <<= 1);\r\n    for (i = 0; step; step >>= 1)\r\n        if (i + step < N && A[i + step] <= val)\r\n           i += step;\r\n    return i;\r\n}\r\n==\r\n\r\nProcedura de mai sus face cautarea binara folosind puteri a lui $2$ in ordine descrescatoare, practic incerc sa determin fiecare bit al rezultatului.\r\n\r\nh2. Impartire in bucati de marime $sqrt(n)$ (cunoscut si ca \"smenul lui Bogdan Batog\")\r\n\r\nSa presupunem ca avem un vector de lungime n cu numere reale pe care se fac urmatoarele operatii:\r\n{@ADUNA(st, dr, x)@} - toate elementele cu indicii intre $st$ si $dr$ isi cresc valoarea cu $x$\r\n{@SUMA(st, dr)@} - returneaza suma elementelor cu indicii intre $st$ si $dr$\r\n\r\nPentru cei ce cunosc arbori de intervale, rezolvarea acestei probleme in $O(lg n)$ per operatie este o munca usoara, dar presupunand ca nu stim aceasta structura putem folosi urmatorul truc: vom construi un al doilea vector de lungime $sqrt(n)$ care retine suma elementelor pe bucati de lungime {$sqrt(n)$}. Pentru a face o operatie pe un interval [{$st, dr$}] vom imparti acest interval in bucati de $sqrt(n)$ a caror actualizare o facem in vectorul $B$ si elementele care raman in margine in vectorul {$A$}. De exemplu pe vectorul {$A{~0..15~}$} vom avea vectorul {$B{~0..3~}$}. Pentru a actualiza de exemplu [{$2, 12$}] vom actualiza {$B{~1~}$} (care corespunde lui [{$4..7$}]), {$B{~2~}$} (pentru [{$8..11$}]) si {$A{~2~}$}, {$A{~3~}$}, {$A{~12~}$} (elementele din margini). Cum sunt maxim $sqrt(n)$ elemente de actualizat in $B$ si pe margini nu vom actualiza niciodata mai mult de $2 * sqrt(n)$ elemente putem concluziona ca operatiile vor avea complexitate {$O(sqrt(n))$}.\r\n\r\nDaca am avea aceeasi problema dar in doua dimensiuni, am putea face acelasi \"smen\" pentru fiecare linie pentru o complexitate $O(n*sqrt(n))$ per operatie, sau cu arbori de intervale pe fiecare linie {$O(n*lg n)$}. Putem, de asemenea obtine o complexitate $O(n)$ folosind urmatoarea impartire:\r\n$A$ - pentru bucati $1 * 1$\r\n$B$ - pentru bucati $sqrt(n) * sqrt(n)$\r\n$C$ - pentru bucati $1 * sqrt(n)$\r\n$D$ - pentru bucati $sqrt(n) * 1$\r\nAcest mod de reprezentare este o extindere directa a aceluiasi smen in doua dimensiuni. Aceasta idee poate fi folosita si pentru alte operatii: inmultire, minim, maxim, etc. In general, orice se poate rezolva cu acest \"smen\" se poate obtine la o complexitate mai buna cu arbori de intervale, dar merita sa stiti si aceasta ideea deoarece de multe ori scuteste din efortul de implementare, desi se pierde din viteza... alegerea voastra! ;)\r\n\r\nh2. LCA in $O(sqrt(n))$ (ideea originala de la Radu Berinde)\r\n\r\nDaca nu stiti ce este LCA, va recomand sa cititi \"articolul\":http://www.infoarena.ro/LCA_Lowest_common_ancestor lui Emilian Miron din cadrul site-ului pentru a va documenta. In continuare vom prezenta un algoritm mai ineficient, dar foarte usor de implementat. Consideram arborele si atribuim fiecarui nod o inaltime. Vom imparti arborele in $sqrt(H)$ intervale in functie de inaltime, unde $H$ e inaltimea maxima (de exemplu la $H=9$ nodurile cu inaltimi intre $0$ si $2$ vor forma un interval, [{$3..5$}] alt interval si ultimul interval de inaltimi [{$6..8$}]). Astfel, pentru fiecare nod, pe langa tatal sau, vom retine si tatal din intervalul de mai sus, printr-o parcurede DF. In continuare, codul:\r\n\r\n$H$ se calculeaza inainte sau poate fi constant\r\n$T$ sunt tatii nodului si $N$ numarul de noduri\r\n\r\n== code(c) |\r\nvoid DF(int n, int t2, int lev)\r\n{\r\n    int i;\r\n    T2[n] = t2, Lev[n] = lev;\r\n    if (lev % H == 0) t2 = n;\r\n    for (i = 0; i < N; i++)\r\n        if (T[i] == n) DF(i, t2, lev+1);\r\n}\r\n==\r\n\r\nOperatia de LCA se va realiza apoi foarte usor, urcand pe tatii din intervale, pana se ajunge la doua noduri in acelasi interval, apoi folosindu-se metoda clasica. Cod:\r\n\r\n== code(c) |\r\nint LCA(int x, int y)\r\n{\r\n    while (T2[x] != T2[y])\r\n        if (Lev[x] > Lev[y])\r\n            x = T2[x];\r\n        else\r\n            y = T2[y];\r\n    while (x != y)\r\n        if (Lev[x] > Lev[y])\r\n            x = T[x];\r\n        else\r\n            y = T[y];\r\n    return x;\r\n}\r\n==\r\n\r\n\r\nh2. LCA in $O(lg^2^ n)$\r\n\r\nAceeasi problema, dar o alta rezolvare. Vom construi o matrice $A{~i,j~}$ cu semnificatia $A{~i,j~}$ = al {$2^i^$}-lea tata al nodului {$j$}. Folosind aceasta matrice putem cauta binar ({$O(lg n)$}) nivelul pe care s-ar putea afla LCA-ul a doua noduri si sa determinam daca nodul ales este corect - adica daca nodul situat la acel nivel este acelasi pentru cele doua noduri pentru care se face LCA ({$O(lg n)$} cu matricea de mai sus). Complexitate finala $O(lg^2^ n)$ si $O(n*lg n)$ memorie.\r\n\r\nh2. For-uri \"complicate\"\r\n\r\nfor-ul in C/C++ este foarte flexibil si poate ajuta foarte mult in compactarea codului, deci si a timpului de implementare. In continuare vom prezenta algoritmul merge sort (sortare prin interclasare) scris in cateva linii (putine, zic eu!):\r\n\r\n== code(c) |\r\nint N, A[N], B[N];\r\nvoid merge_sort(int l, int r)\r\n{\r\n    int m = (l + r) >> 1, i, j, k;\r\n    if (l == r) return;\r\n    merge_sort(l, m);\r\n    merge_sort(m + 1, r);\r\n    for (i=l, j=m+1, k=l; i<=m || j<=r; )\r\n        if (j > r || (i <= m && A[i] < A[j]))\r\n            B[k++] = A[i++];\r\n        else\r\n            B[k++] = A[j++];\r\n    for (k = l; k <= r; k++) A[k] = B[k];\r\n}\r\n==\r\n\r\nh2. Recomandari generale\r\n\r\n# Programare dinamica cu memoizare: mult mai simplu si uneori chiar mai rapida cand nu ne trebuie tot array-ul\r\n# Algoritmi randomizati: de multe ori mai usor de implementat si mai eficienti, mai bine decat cei euristici, dar necesita o analiza mult mai atenta a performantei. Exemple calsice: quciksort, statistici de ordine\r\n\r\nh2. \"Smenul lui Mars\" (Marius Andrei)\r\n\r\nConsideram urmatoarea problema: se da un vector $A$ de $N$ elemente pe care se fac $M$ astfel de operatii: {@ADUNA(st, dr, x)@} - toate elementele cu indicii intre $st$ si $dr$ isi cresc valoarea cu {$x$}. La sfarsit trebuie sa se afiseze vectorul rezultat. In continuarea vom descrie o metoda care ne da un timp de rulare de $O(1)$ pentru operatia $ADUNA$ si $O(N)$ pentru a determina un element din vector. Vom construi un al doilea vector $B$ de $N+1$ elemente, cu proprietatea ca {$A{~i~} = B{~0~} + B{~1~} + ... B{~i~}$}. Astfel, o operatie {@ADUNA(st, dr, x)@} devine:\r\n\r\n== code(c) |\r\nB[st] += x;\r\n[dr + 1] -= x;\r\n==\r\n\r\nDa, este chiar asa de simplu! Pentru a determina un element A{~i~} vom aduna pur si simplu {$B{~0~} + B{~1~} + ... B{~i~}$}. Incercati pe foaie sa vedeti cum funtioneaza. Aceasta ideea poate fi extinsa si in doua dimensiuni, construind $B$ astfel incat $A{~i,j~}$ = suma subtabloului din $B$ cu coltul in ({$0, 0$}) si ({$i, j$}), astfel (pt. {@ADUNA(x1,y1,x2,y2,v)@}):\r\n\r\n== code(c) |\r\nB[x1][y1] += v;\r\nB[x1][y2 + 1] -= v;\r\nB[x2 + 1][y1] -= v;\r\nB[x2 + 1][y2 + 1] += v;\r\n==\r\n\r\nPe cazul general, daca vrem sa facem operatii in $d$ dimensiuni vom avea o complexitate {$O(2^d^)$}. Reamintesc ca aceasta metoda este eficienta doar cand se vrea afisata vectorul/matricea/etc. doar la sfarsitul operatiilor, deoarece aflarea unui element este o operatie foarte ineficienta.\r\n\r\nh2. Grafuri cu liste de adiacenta (ideea originala de la Radu Berinde)\r\n\r\nSe stie (sau ar trebui sa se stie!) ca lucrul cu pointerii este foarte incet... astfel, cand retinem un graf rar (numar mare de noduri, numar mic de muchii) cu pointeri (vezi mai jos) incetinim foarte mult programul.\r\n\r\n== code(c) |\r\nstruct list\r\n{\r\n    int n;\r\n    struct list *next;\r\n}\r\ntypedef struct list list;\r\n==\r\n\r\nIn contiuare vom prezenta o metoda care este de $3-4$ ori mai rapida (adica parcurgerile DF , BF sau altii algoritmi ruleaza de $3-4$ ori mai rapid cand graful este stocat astfel), dar are ca dezavantaj necesitatea de a citi de doua ori fisierul de intrare.\r\n\r\n== code(c) |\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nint N, M, *G[N], Deg[N];\r\n\r\nint main(void)\r\n{\r\n    int i, j;\r\n \r\n    freopen(\"in.txt\", \"r\", stdin);\r\n    scanf(\"%d %d\", &N, &M);\r\n    for (; M > 0; M--)\r\n    {\r\n        scanf(\"%d %d\", &i, &j);\r\n        Deg[i - 1]++, Deg[j - 1]++;\r\n    }\r\n    for (i = 0; i < N; Deg[i++] = 0)\r\n        G[i] = (int *) malloc(Deg[i]*sizeof(int));\r\n    fseek(stdin, 0, SEEK_SET);\r\n    scanf(\"%d %d\", &N, &M);\r\n    for (; M > 0; M--)\r\n    {\r\n        scanf(\"%d %d\", &i, &j);\r\n        i--, j--;\r\n        G[i][Deg[i]++] = j,\r\n            G[j][Deg[j]++] = i;\r\n    }\r\n\r\n    return 0;\r\n}\r\n==\r\n\r\nSporul de viteza se datoreaza faptului ca se folosesc vectori in loc de pointeri si struct-uri. Daca ne permite memoria putem evita citirea de doua ori a fisierul prin pastrarea muchiilor intr-o lista de muchii si apoi, dupa calcularea gradelor, inserarea muchiilor in liste. Pentru a demonstra eficienta acestei metode faceti urmatorul test: implementati o sursa cu pointeri si struct si implementati un BF, apoi scrieti codul de mai sus cu urmatoarele modificari:\r\n\r\n== code(c) |\r\n...\r\nfor (i = 0; i < N; i++)\r\n{\r\n      G[i] = (int *) malloc((Deg[i]+1)*sizeof(int));\r\n      G[i][Deg[i]] = -1;\r\n      Deg[i] = 0;\r\n}\r\n...\r\n==\r\n\r\nsi implementati BF astfel:\r\n\r\n== code(c) |\r\nvoid BF\r\n{\r\n      int Q[N], ql, qr, *p;\r\n      char U[N];\r\n      memset(U, 0, sizeof(U));\r\n      U[Q[ql = qr = 0] = n] = 1;\r\n      for (; ql <= qr; ql++)\r\n              for (p = G[Q[ql]]; *p != -1; p++)\r\n                      if (!U[*p]) U[Q[++qr] = *p] = 1;\r\n}\r\n==\r\n\r\nApoi, incercati sa vedeti diferenta de timp intre cele doua programe... impresionant, nu?\r\n\r\n\r\n\r\nh2. Numere mari (ideea originala de la Radu Berinde)\r\n\r\nIn continuare voi prezenta cum se pot realiza operatii pe numere mari cu foarte putine linii de cod. In general, multi programatori se complica la aceste operatii, desi nu este nevoie! Vom considera ca numerele mari sunt vectori in care elementul de indice $0$ indica lungimea numarului, iar cifrele sunt retinute in ordinea inversa decat cea a citirii.\r\n\r\nh3. Suma a doua numere mari\r\n\r\n== code(c) |\r\nvoid add(int A[], int B[])\r\n{\r\n      int i, t = 0;\r\n      for (i=1; i<=A[0] || i<=B[0] || t; i++, t/=10)\r\n              A[i] = (t += A[i] + B[i]) % 10;\r\n      A[0] = i - 1;\r\n}\r\n==\r\n\r\nh3. Inmultirea unui numar mare cu un numar mic\r\n\r\n== code(c) |\r\nvoid mul(int A[], int B)\r\n{\r\n      int i, t = 0;\r\n      for (i = 1; i <= A[0] || t; i++, t /= 10)\r\n              A[i] = (t += A[i] * B) % 10;\r\n      A[0] = i - 1;\r\n}\r\n==\r\n\r\nh3. Inmultirea unui numar mare cu un numar mare\r\n\r\n== code(c) |\r\nvoid mul(int A[], int B[])\r\n{\r\n      int i, j, t, C[];\r\n      memset(C, 0, sizeof(C));\r\n      for (i = 1; i <= A[0]; i++)\r\n      {\r\n              for (t=0, j=1; j <= B[0] || t; j++, t/=10)\r\n                      C[i+j-1]=(t+=C[i+j-1]+A[i]*B[j])%10;\r\n              if (i + j - 2 > C[0]) C[0] = i + j - 2;\r\n      }\r\n      memcpy(A, C, sizeof(C));\r\n}\r\n==\r\n\r\nh3. Scaderea a doua numere mari\r\n\r\n== code(c) |\r\nvoid sub(int A[], int B[])\r\n{\r\n      int i, t = 0;\r\n      for (i = 1; i <= A[0]; i++)\r\n              A[i] += (t = (A[i] -= B[i] + t) < 0) * 10;\r\n      for (; A[0] > 1 && !A[A[0]]; A[0]--);\r\n}\r\n==\r\n\r\nh3. Impartirea unui numar mare la un numar mic\r\n\r\n== code(c) |\r\nvoid div(int A[], int B)\r\n{\r\n      int i, t = 0;\r\n      for (i = A[0]; i > 0; i--, t %= B)\r\n              A[i] = (t = t * 10 + A[i]) / B;\r\n      for (; A[0] > 1 && !A[A[0]]; A[0]--);\r\n}\r\n==\r\n\r\nh3. Restul unui numar mare la un numar mic\r\n\r\n== code(c) |\r\nint mod(int A[], int B)\r\n{\r\n      int i, t = 0;\r\n      for (i = A[0]; i > 0; i--)\r\n              t = (t * 10 + A[i]) % B;\r\n      return t;\r\n}\r\n==\r\n\r\nh2. AVL-uri (ideea originala de la Radu Berinde - again)\r\n\r\nAVL-urile sunt arbori de cautare echilibrati care au complexitate O(lg n) pe operatiile de inserare, stergere si cautare. Pentru mai multe detalii cautati cartea \"Arbori\" pe [2]site-ul doamnei profesoare Emanuela Cerchez. In continuare voi prezenta o metoda destul de simpla de a implementa aceastra structura de date in timp de concurs. Enjoy!\r\n\r\n== code(c) |\r\n#define max(a, b) ((a) > (b) ? (a) : (b))\r\n#define geth(n) (n->h = 1 + max(n->l->h, n->r->h))\r\n\r\nstruct node\r\n{\r\n      int key, h;\r\n      struct node *l, *r;\r\n} *R, *NIL;\r\ntypedef struct node node;\r\n\r\nvoid init(void)\r\n{\r\n      R = NIL = (node *) malloc(sizeof(node));\r\n      NIL->key = NIL->h = 0,\r\n              NIL->l = NIL->r = NULL;\r\n}\r\n\r\nnode* rotleft(node *n)\r\n{\r\n      node *t = n->l;\r\n\r\n      n->l = t->r, t->r = n,\r\n              geth(n), geth(t);\r\n      return t;\r\n}\r\n\r\nnode* rotright(node *n)\r\n{\r\n      node *t = n->r;\r\n \r\n      n->r = t->l, t->l = n,\r\n              geth(n), geth(t);\r\n      return t;\r\n}\r\n\r\nnode* balance(node *n)\r\n{\r\n      geth(n);\r\n      if (n->l->h > n->r->h + 1)\r\n      {\r\n              if (n->l->r->h > n->l->l->h)\r\n                      n->l = rotright(n->l);\r\n              n = rotleft(n);\r\n      }\r\n      else\r\n              if (n->r->h > n->l->h + 1)\r\n              {\r\n                      if (n->r->l->h > n->r->r->h)\r\n                              n->r = rotleft(n->r);\r\n                      n = rotright(n);\r\n              }\r\n      return n;\r\n}\r\n\r\nnode* insert(node *n, int key)\r\n{\r\n      if (n == NIL)\r\n      {\r\n              n = (node *) malloc(sizeof(node));\r\n              n->key = key, n->h = 1, n->l = n->r = NIL;\r\n              return n;\r\n      }\r\n      if (key < n->key)\r\n              n->l = insert(n->l, key);\r\n      else\r\n              n->r = insert(n->r, key);\r\n      return balance(n);\r\n}\r\n\r\nnode* erase(node *n, int key)\r\n{\r\n      node *t;\r\n      if (n == NIL) return n;\r\n      if (n->key == key)\r\n      {\r\n              if (n->l == NIL || n->r == NIL)\r\n              {\r\n                      t = n->l == NIL ? n->r : n->l;\r\n                      free(n); return t;\r\n              }\r\n              else\r\n              {\r\n                      for (t = n->r; t->l != NIL; t = t->l);\r\n                      n->key = t->key,\r\n                              n->r = erase(n->r, t->key);\r\n                      return balance(n);\r\n              }\r\n      }\r\n      if (key < n->key)\r\n              n->l = erase(n->l, key);\r\n      else\r\n              n->r = erase(n->r, key);\r\n      return balance(n);\r\n}\r\n\r\nint search(node *n, int key)\r\n{\r\n      if (n == NIL) return 0;\r\n      if (n->key == key) return 1;\r\n      if (key < n->key)\r\n              return search(n->l, key);\r\n      else\r\n              return search(n->r, key);\r\n}\r\n\r\nAici se termina acest articol. Am incercat sa pun accentul pe simplitate si eficienta, si cred ca am reusit acest lucru. Sper ca ati invatat cate ceva din el si recomand sa luati fiecare bucata in parte si sa incercati sa implementati efectiv ca sa intelegi mai bine. Bafta la concursuri tuturor! ;)\r\n\r\n',13,''),('multe-smenuri-de-programare-in-cc-si-nu-numai','Multe \"smenuri\" de programare in C/C++... si nu numai!','2006-11-15 12:30:08','h1. Multe \"smenuri\" de programare in C/C++... si nu numai!\r\n\r\n(Creat de ==user(user=\"domino\" type=\"tiny\")== la data de _2004-11-10_ categoria _Limbaje_, autor(i) _Mircea Pasoi_)\r\n\r\nAcest articol vine ca o completare a articolului scris de Alexandru Mosoi, prezentand noi trucuri care le-am folosit si m-au ajutat mult. O mare parte din acestea le-am invatat din sursele lui Radu Berinde (cred ca stiti cu totii cine este), asadar ii multumesc!\r\n\r\nh2. Array-uri neindexate de la 0\r\n\r\nUn dezavantaj fata de Pascal este faptul ca in C nu putem avea expresii de genul {@A[-100]@} unde $A$ este un vector. Dar acest lucru se poate remedia. Spre exemplu, daca vrem sa facem un vector $A$ cu elemente de la $-100$ la $100$ procedam astfel:\r\n\r\n== code(c) |\r\nint A[201];\r\n#define A (A + 100)\r\n==\r\n\r\nh2. Fisiere de intrare si iesire\r\n\r\nFolositi {@freopen()@} in loc de {@fopen()@} deoarece este mai comod, in special la concursurile in care intrare si iesirea sunt standard.\r\n\r\n== code(c) |\r\nfreopen(\"in.txt\", \"r\", stdin);\r\nfreopen(\"out.txt\", \"w\", stdout);\r\n==\r\n\r\nh2. Cautare binara (ideea originala de la Mihai Patrascu)\r\n\r\nUrmatorul cod este de aproximativ $4$ ori mai rapid (am testat cu cautare binara ca in manual) , mai usor de inteles, mai flexibil si mai scurt... ce ati putea dori mai mult?\r\n\r\n== code(c) |\r\nint N, A[N];\r\n\r\nint binary_search(int val)\r\n{\r\n    int i, step;\r\n    for (step = 1; step < N; step <<= 1);\r\n    for (i = 0; step; step >>= 1)\r\n        if (i + step < N && A[i + step] <= val)\r\n           i += step;\r\n    return i;\r\n}\r\n==\r\n\r\nProcedura de mai sus face cautarea binara folosind puteri a lui $2$ in ordine descrescatoare, practic incerc sa determin fiecare bit al rezultatului.\r\n\r\nh2. Impartire in bucati de marime $sqrt(n)$ (cunoscut si ca \"smenul lui Bogdan Batog\")\r\n\r\nSa presupunem ca avem un vector de lungime n cu numere reale pe care se fac urmatoarele operatii:\r\n{@ADUNA(st, dr, x)@} - toate elementele cu indicii intre $st$ si $dr$ isi cresc valoarea cu $x$\r\n{@SUMA(st, dr)@} - returneaza suma elementelor cu indicii intre $st$ si $dr$\r\n\r\nPentru cei ce cunosc arbori de intervale, rezolvarea acestei probleme in $O(lg n)$ per operatie este o munca usoara, dar presupunand ca nu stim aceasta structura putem folosi urmatorul truc: vom construi un al doilea vector de lungime $sqrt(n)$ care retine suma elementelor pe bucati de lungime {$sqrt(n)$}. Pentru a face o operatie pe un interval [{$st, dr$}] vom imparti acest interval in bucati de $sqrt(n)$ a caror actualizare o facem in vectorul $B$ si elementele care raman in margine in vectorul {$A$}. De exemplu pe vectorul {$A{~0..15~}$} vom avea vectorul {$B{~0..3~}$}. Pentru a actualiza de exemplu [{$2, 12$}] vom actualiza {$B{~1~}$} (care corespunde lui [{$4..7$}]), {$B{~2~}$} (pentru [{$8..11$}]) si {$A{~2~}$}, {$A{~3~}$}, {$A{~12~}$} (elementele din margini). Cum sunt maxim $sqrt(n)$ elemente de actualizat in $B$ si pe margini nu vom actualiza niciodata mai mult de $2 * sqrt(n)$ elemente putem concluziona ca operatiile vor avea complexitate {$O(sqrt(n))$}.\r\n\r\nDaca am avea aceeasi problema dar in doua dimensiuni, am putea face acelasi \"smen\" pentru fiecare linie pentru o complexitate $O(n*sqrt(n))$ per operatie, sau cu arbori de intervale pe fiecare linie {$O(n*lg n)$}. Putem, de asemenea obtine o complexitate $O(n)$ folosind urmatoarea impartire:\r\n$A$ - pentru bucati $1 * 1$\r\n$B$ - pentru bucati $sqrt(n) * sqrt(n)$\r\n$C$ - pentru bucati $1 * sqrt(n)$\r\n$D$ - pentru bucati $sqrt(n) * 1$\r\nAcest mod de reprezentare este o extindere directa a aceluiasi smen in doua dimensiuni. Aceasta idee poate fi folosita si pentru alte operatii: inmultire, minim, maxim, etc. In general, orice se poate rezolva cu acest \"smen\" se poate obtine la o complexitate mai buna cu arbori de intervale, dar merita sa stiti si aceasta ideea deoarece de multe ori scuteste din efortul de implementare, desi se pierde din viteza... alegerea voastra! ;)\r\n\r\nh2. LCA in $O(sqrt(n))$ (ideea originala de la Radu Berinde)\r\n\r\nDaca nu stiti ce este LCA, va recomand sa cititi \"articolul\":http://www.infoarena.ro/LCA_Lowest_common_ancestor lui Emilian Miron din cadrul site-ului pentru a va documenta. In continuare vom prezenta un algoritm mai ineficient, dar foarte usor de implementat. Consideram arborele si atribuim fiecarui nod o inaltime. Vom imparti arborele in $sqrt(H)$ intervale in functie de inaltime, unde $H$ e inaltimea maxima (de exemplu la $H=9$ nodurile cu inaltimi intre $0$ si $2$ vor forma un interval, [{$3..5$}] alt interval si ultimul interval de inaltimi [{$6..8$}]). Astfel, pentru fiecare nod, pe langa tatal sau, vom retine si tatal din intervalul de mai sus, printr-o parcurede DF. In continuare, codul:\r\n\r\n$H$ se calculeaza inainte sau poate fi constant\r\n$T$ sunt tatii nodului si $N$ numarul de noduri\r\n\r\n== code(c) |\r\nvoid DF(int n, int t2, int lev)\r\n{\r\n    int i;\r\n    T2[n] = t2, Lev[n] = lev;\r\n    if (lev % H == 0) t2 = n;\r\n    for (i = 0; i < N; i++)\r\n        if (T[i] == n) DF(i, t2, lev+1);\r\n}\r\n==\r\n\r\nOperatia de LCA se va realiza apoi foarte usor, urcand pe tatii din intervale, pana se ajunge la doua noduri in acelasi interval, apoi folosindu-se metoda clasica. Cod:\r\n\r\n== code(c) |\r\nint LCA(int x, int y)\r\n{\r\n    while (T2[x] != T2[y])\r\n        if (Lev[x] > Lev[y])\r\n            x = T2[x];\r\n        else\r\n            y = T2[y];\r\n    while (x != y)\r\n        if (Lev[x] > Lev[y])\r\n            x = T[x];\r\n        else\r\n            y = T[y];\r\n    return x;\r\n}\r\n==\r\n\r\n\r\nh2. LCA in $O(lg^2^ n)$\r\n\r\nAceeasi problema, dar o alta rezolvare. Vom construi o matrice $A{~i,j~}$ cu semnificatia $A{~i,j~}$ = al {$2^i^$}-lea tata al nodului {$j$}. Folosind aceasta matrice putem cauta binar ({$O(lg n)$}) nivelul pe care s-ar putea afla LCA-ul a doua noduri si sa determinam daca nodul ales este corect - adica daca nodul situat la acel nivel este acelasi pentru cele doua noduri pentru care se face LCA ({$O(lg n)$} cu matricea de mai sus). Complexitate finala $O(lg^2^ n)$ si $O(n*lg n)$ memorie.\r\n\r\nh2. For-uri \"complicate\"\r\n\r\nfor-ul in C/C++ este foarte flexibil si poate ajuta foarte mult in compactarea codului, deci si a timpului de implementare. In continuare vom prezenta algoritmul merge sort (sortare prin interclasare) scris in cateva linii (putine, zic eu!):\r\n\r\n== code(c) |\r\nint N, A[N], B[N];\r\nvoid merge_sort(int l, int r)\r\n{\r\n    int m = (l + r) >> 1, i, j, k;\r\n    if (l == r) return;\r\n    merge_sort(l, m);\r\n    merge_sort(m + 1, r);\r\n    for (i=l, j=m+1, k=l; i<=m || j<=r; )\r\n        if (j > r || (i <= m && A[i] < A[j]))\r\n            B[k++] = A[i++];\r\n        else\r\n            B[k++] = A[j++];\r\n    for (k = l; k <= r; k++) A[k] = B[k];\r\n}\r\n==\r\n\r\nh2. Recomandari generale\r\n\r\n# Programare dinamica cu memoizare: mult mai simplu si uneori chiar mai rapida cand nu ne trebuie tot array-ul\r\n# Algoritmi randomizati: de multe ori mai usor de implementat si mai eficienti, mai bine decat cei euristici, dar necesita o analiza mult mai atenta a performantei. Exemple calsice: quciksort, statistici de ordine\r\n\r\nh2. \"Smenul lui Mars\" (Marius Andrei)\r\n\r\nConsideram urmatoarea problema: se da un vector $A$ de $N$ elemente pe care se fac $M$ astfel de operatii: {@ADUNA(st, dr, x)@} - toate elementele cu indicii intre $st$ si $dr$ isi cresc valoarea cu {$x$}. La sfarsit trebuie sa se afiseze vectorul rezultat. In continuarea vom descrie o metoda care ne da un timp de rulare de $O(1)$ pentru operatia $ADUNA$ si $O(N)$ pentru a determina un element din vector. Vom construi un al doilea vector $B$ de $N+1$ elemente, cu proprietatea ca {$A{~i~} = B{~0~} + B{~1~} + ... B{~i~}$}. Astfel, o operatie {@ADUNA(st, dr, x)@} devine:\r\n\r\n== code(c) |\r\nB[st] += x;\r\n[dr + 1] -= x;\r\n==\r\n\r\nDa, este chiar asa de simplu! Pentru a determina un element A{~i~} vom aduna pur si simplu {$B{~0~} + B{~1~} + ... B{~i~}$}. Incercati pe foaie sa vedeti cum funtioneaza. Aceasta ideea poate fi extinsa si in doua dimensiuni, construind $B$ astfel incat $A{~i,j~}$ = suma subtabloului din $B$ cu coltul in ({$0, 0$}) si ({$i, j$}), astfel (pt. {@ADUNA(x1,y1,x2,y2,v)@}):\r\n\r\n== code(c) |\r\nB[x1][y1] += v;\r\nB[x1][y2 + 1] -= v;\r\nB[x2 + 1][y1] -= v;\r\nB[x2 + 1][y2 + 1] += v;\r\n==\r\n\r\nPe cazul general, daca vrem sa facem operatii in $d$ dimensiuni vom avea o complexitate {$O(2^d^)$}. Reamintesc ca aceasta metoda este eficienta doar cand se vrea afisata vectorul/matricea/etc. doar la sfarsitul operatiilor, deoarece aflarea unui element este o operatie foarte ineficienta.\r\n\r\nh2. Grafuri cu liste de adiacenta (ideea originala de la Radu Berinde)\r\n\r\nSe stie (sau ar trebui sa se stie!) ca lucrul cu pointerii este foarte incet... astfel, cand retinem un graf rar (numar mare de noduri, numar mic de muchii) cu pointeri (vezi mai jos) incetinim foarte mult programul.\r\n\r\n== code(c) |\r\nstruct list\r\n{\r\n    int n;\r\n    struct list *next;\r\n}\r\ntypedef struct list list;\r\n==\r\n\r\nIn contiuare vom prezenta o metoda care este de $3-4$ ori mai rapida (adica parcurgerile DF , BF sau altii algoritmi ruleaza de $3-4$ ori mai rapid cand graful este stocat astfel), dar are ca dezavantaj necesitatea de a citi de doua ori fisierul de intrare.\r\n\r\n== code(c) |\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nint N, M, *G[N], Deg[N];\r\n\r\nint main(void)\r\n{\r\n    int i, j;\r\n \r\n    freopen(\"in.txt\", \"r\", stdin);\r\n    scanf(\"%d %d\", &N, &M);\r\n    for (; M > 0; M--)\r\n    {\r\n        scanf(\"%d %d\", &i, &j);\r\n        Deg[i - 1]++, Deg[j - 1]++;\r\n    }\r\n    for (i = 0; i < N; Deg[i++] = 0)\r\n        G[i] = (int *) malloc(Deg[i]*sizeof(int));\r\n    fseek(stdin, 0, SEEK_SET);\r\n    scanf(\"%d %d\", &N, &M);\r\n    for (; M > 0; M--)\r\n    {\r\n        scanf(\"%d %d\", &i, &j);\r\n        i--, j--;\r\n        G[i][Deg[i]++] = j,\r\n            G[j][Deg[j]++] = i;\r\n    }\r\n\r\n    return 0;\r\n}\r\n==\r\n\r\nSporul de viteza se datoreaza faptului ca se folosesc vectori in loc de pointeri si struct-uri. Daca ne permite memoria putem evita citirea de doua ori a fisierul prin pastrarea muchiilor intr-o lista de muchii si apoi, dupa calcularea gradelor, inserarea muchiilor in liste. Pentru a demonstra eficienta acestei metode faceti urmatorul test: implementati o sursa cu pointeri si struct si implementati un BF, apoi scrieti codul de mai sus cu urmatoarele modificari:\r\n\r\n== code(c) |\r\n...\r\nfor (i = 0; i < N; i++)\r\n{\r\n      G[i] = (int *) malloc((Deg[i]+1)*sizeof(int));\r\n      G[i][Deg[i]] = -1;\r\n      Deg[i] = 0;\r\n}\r\n...\r\n==\r\n\r\nsi implementati BF astfel:\r\n\r\n== code(c) |\r\nvoid BF\r\n{\r\n      int Q[N], ql, qr, *p;\r\n      char U[N];\r\n      memset(U, 0, sizeof(U));\r\n      U[Q[ql = qr = 0] = n] = 1;\r\n      for (; ql <= qr; ql++)\r\n              for (p = G[Q[ql]]; *p != -1; p++)\r\n                      if (!U[*p]) U[Q[++qr] = *p] = 1;\r\n}\r\n==\r\n\r\nApoi, incercati sa vedeti diferenta de timp intre cele doua programe... impresionant, nu?\r\n\r\n\r\n\r\nh2. Numere mari (ideea originala de la Radu Berinde)\r\n\r\nIn continuare voi prezenta cum se pot realiza operatii pe numere mari cu foarte putine linii de cod. In general, multi programatori se complica la aceste operatii, desi nu este nevoie! Vom considera ca numerele mari sunt vectori in care elementul de indice $0$ indica lungimea numarului, iar cifrele sunt retinute in ordinea inversa decat cea a citirii.\r\n\r\nh3. Suma a doua numere mari\r\n\r\n== code(c) |\r\nvoid add(int A[], int B[])\r\n{\r\n      int i, t = 0;\r\n      for (i=1; i<=A[0] || i<=B[0] || t; i++, t/=10)\r\n              A[i] = (t += A[i] + B[i]) % 10;\r\n      A[0] = i - 1;\r\n}\r\n==\r\n\r\nh3. Inmultirea unui numar mare cu un numar mic\r\n\r\n== code(c) |\r\nvoid mul(int A[], int B)\r\n{\r\n      int i, t = 0;\r\n      for (i = 1; i <= A[0] || t; i++, t /= 10)\r\n              A[i] = (t += A[i] * B) % 10;\r\n      A[0] = i - 1;\r\n}\r\n==\r\n\r\nh3. Inmultirea unui numar mare cu un numar mare\r\n\r\n== code(c) |\r\nvoid mul(int A[], int B[])\r\n{\r\n      int i, j, t, C[];\r\n      memset(C, 0, sizeof(C));\r\n      for (i = 1; i <= A[0]; i++)\r\n      {\r\n              for (t=0, j=1; j <= B[0] || t; j++, t/=10)\r\n                      C[i+j-1]=(t+=C[i+j-1]+A[i]*B[j])%10;\r\n              if (i + j - 2 > C[0]) C[0] = i + j - 2;\r\n      }\r\n      memcpy(A, C, sizeof(C));\r\n}\r\n==\r\n\r\nh3. Scaderea a doua numere mari\r\n\r\n== code(c) |\r\nvoid sub(int A[], int B[])\r\n{\r\n      int i, t = 0;\r\n      for (i = 1; i <= A[0]; i++)\r\n              A[i] += (t = (A[i] -= B[i] + t) < 0) * 10;\r\n      for (; A[0] > 1 && !A[A[0]]; A[0]--);\r\n}\r\n==\r\n\r\nh3. Impartirea unui numar mare la un numar mic\r\n\r\n== code(c) |\r\nvoid div(int A[], int B)\r\n{\r\n      int i, t = 0;\r\n      for (i = A[0]; i > 0; i--, t %= B)\r\n              A[i] = (t = t * 10 + A[i]) / B;\r\n      for (; A[0] > 1 && !A[A[0]]; A[0]--);\r\n}\r\n==\r\n\r\nh3. Restul unui numar mare la un numar mic\r\n\r\n== code(c) |\r\nint mod(int A[], int B)\r\n{\r\n      int i, t = 0;\r\n      for (i = A[0]; i > 0; i--)\r\n              t = (t * 10 + A[i]) % B;\r\n      return t;\r\n}\r\n==\r\n\r\nh2. AVL-uri (ideea originala de la Radu Berinde - again)\r\n\r\nAVL-urile sunt arbori de cautare echilibrati care au complexitate O(lg n) pe operatiile de inserare, stergere si cautare. Pentru mai multe detalii cautati cartea \"Arbori\" pe [2]site-ul doamnei profesoare Emanuela Cerchez. In continuare voi prezenta o metoda destul de simpla de a implementa aceastra structura de date in timp de concurs. Enjoy!\r\n\r\n== code(c) |\r\n#define max(a, b) ((a) > (b) ? (a) : (b))\r\n#define geth(n) (n->h = 1 + max(n->l->h, n->r->h))\r\n\r\nstruct node\r\n{\r\n      int key, h;\r\n      struct node *l, *r;\r\n} *R, *NIL;\r\ntypedef struct node node;\r\n\r\nvoid init(void)\r\n{\r\n      R = NIL = (node *) malloc(sizeof(node));\r\n      NIL->key = NIL->h = 0,\r\n              NIL->l = NIL->r = NULL;\r\n}\r\n\r\nnode* rotleft(node *n)\r\n{\r\n      node *t = n->l;\r\n\r\n      n->l = t->r, t->r = n,\r\n              geth(n), geth(t);\r\n      return t;\r\n}\r\n\r\nnode* rotright(node *n)\r\n{\r\n      node *t = n->r;\r\n \r\n      n->r = t->l, t->l = n,\r\n              geth(n), geth(t);\r\n      return t;\r\n}\r\n\r\nnode* balance(node *n)\r\n{\r\n      geth(n);\r\n      if (n->l->h > n->r->h + 1)\r\n      {\r\n              if (n->l->r->h > n->l->l->h)\r\n                      n->l = rotright(n->l);\r\n              n = rotleft(n);\r\n      }\r\n      else\r\n              if (n->r->h > n->l->h + 1)\r\n              {\r\n                      if (n->r->l->h > n->r->r->h)\r\n                              n->r = rotleft(n->r);\r\n                      n = rotright(n);\r\n              }\r\n      return n;\r\n}\r\n\r\nnode* insert(node *n, int key)\r\n{\r\n      if (n == NIL)\r\n      {\r\n              n = (node *) malloc(sizeof(node));\r\n              n->key = key, n->h = 1, n->l = n->r = NIL;\r\n              return n;\r\n      }\r\n      if (key < n->key)\r\n              n->l = insert(n->l, key);\r\n      else\r\n              n->r = insert(n->r, key);\r\n      return balance(n);\r\n}\r\n\r\nnode* erase(node *n, int key)\r\n{\r\n      node *t;\r\n      if (n == NIL) return n;\r\n      if (n->key == key)\r\n      {\r\n              if (n->l == NIL || n->r == NIL)\r\n              {\r\n                      t = n->l == NIL ? n->r : n->l;\r\n                      free(n); return t;\r\n              }\r\n              else\r\n              {\r\n                      for (t = n->r; t->l != NIL; t = t->l);\r\n                      n->key = t->key,\r\n                              n->r = erase(n->r, t->key);\r\n                      return balance(n);\r\n              }\r\n      }\r\n      if (key < n->key)\r\n              n->l = erase(n->l, key);\r\n      else\r\n              n->r = erase(n->r, key);\r\n      return balance(n);\r\n}\r\n\r\nint search(node *n, int key)\r\n{\r\n      if (n == NIL) return 0;\r\n      if (n->key == key) return 1;\r\n      if (key < n->key)\r\n              return search(n->l, key);\r\n      else\r\n              return search(n->r, key);\r\n}\r\n\r\nAici se termina acest articol. Am incercat sa pun accentul pe simplitate si eficienta, si cred ca am reusit acest lucru. Sper ca ati invatat cate ceva din el si recomand sa luati fiecare bucata in parte si sa incercati sa implementati efectiv ca sa intelegi mai bine. Bafta la concursuri tuturor! ;)\r\n==',13,''),('sandbox','Sandbox','2006-11-15 03:08:37','bc[cpp].. void DF(int n, int t2, int lev)\r\n{\r\n    int i;\r\n    T2[n] = t2, Lev[n] = lev;\r\n    if (lev % H == 0) t2 = n;\r\n    for (i = 0; i < N; i++)\r\n        if (T[i] == n) DF(i, t2, lev+1);\r\n}\r\n\r\np. &nbsp;\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',1142,''),('ciurul-lui-erathostene','Ciurul lui Erathostene','2006-11-16 00:48:43','h1. Ciurul lui Erathostene\r\n\r\n(Creat de \'_Cosmin_\':user/Cosmin la data de _2004-11-24_ categoria _Teoria numerelor_, autor(i) _Cosmin_)\r\n\r\nArticolul de fata incearca o implementarea mai eficienta a acestui algoritm clasic. Se poate optimiza pentru a folosi doar O(sqrt(n)) memorie, varianta prezentata aici folosind O(n / log n) memorie, unde log n e numarul de biti al unui cuvant.\r\n\r\nCiurul lui Erathostene e un algoritm clasic care se invata la scoala impreuna cu conceptul de numere prime inca din clasa a 6. Acest algoritm determina toate numerele prime mai mici decat un numar dat ca parametru. Ideea lui de abordare a acestei probleme poate fi modificata pentru a rezolva si alte probleme precum problema Fractii din arhiva infoarena, problema \"Riemann vs Mertens\":http://acm.uva.es/p/v107/10738.html din arhiva \"uva\":http://acm.uva.es/, problema \"Divizibilitate\":http://algoritmus.org/probleme/Probleme_Runda04.php a rundei 4 a concursului algoritmus, sau problema \"Square Free\":http://www.topcoder.com/stat?c=problem_statement&pm=2342&rd=4770 a SRM-ului 190 de pe TOPCODER, rezolvarea ei o gasiti \"aici\":http://www.topcoder.com/index?t=statistics&c=srm190_prob. \r\nIn articolul acesta nu ne vom concentra asupra acestor probleme ci asupra implementarii optimizate ale algoritmului original.\r\n\r\nAm mai scris despre aceste optimizari intr-un articol din ginfo, dar codul de acolo nu era testat si nu merge :).\r\n\r\nIdeea la acest algoritm e ca marcam intr-un sir fiecare multiplu al unui numar prim si numerele ramase nemarcate sunt numere prime, o descriere mai grafica gasiti la \"adresa\":http://mathworld.wolfram.com/SieveofEratosthenes.html.\r\n\r\nSa incercam o prima implementare a acestui algoritm (implementarile vor folosi limbajul java, dar sunt foarte usor transformabile in C/C++).\r\n\r\n== code(java) | \r\n  //class PrimeNumbersSieve1\r\n  final int MAXSIZE = 1000001;\r\n  char[] p = new char[MAXSIZE];\r\n  //p[i] == 0 if i is prime\r\n  public int getTheNumber(int n) {\r\n    int i, j, nr = 0;\r\n    for (i = 2; i <= n; ++i) {\r\n      if (p[i] == 0) {\r\n        nr++;\r\n        for (j = i + i; j <= n; j += i) {\r\n          p[j] = 1;\r\n        }\r\n      }\r\n    }\r\n    return nr;\r\n  }\r\n==\r\n\r\nO prima idee de optimizare ar fi sa nu mai luam in calcul numerele pare pentru ca stim ca singurul numar prim par e {$2$}. Deci sa vedem noua varianta a programului:\r\n\r\n== code(java) | \r\n  //class PrimeNumbersSieve2\r\n  final int MAXSIZE = 1000001;\r\n  char[] p = new char[MAXSIZE];\r\n\r\n  //p[i] == 0 if i is prime\r\n  \r\n  public int getTheNumber(int n) {\r\n    int i, j, nr = 1;\r\n    for (i = 3; i <= n; i += 2) {\r\n      if (p[i] == 0) {\r\n        nr++;\r\n        for (j = i + i + i; j <= n; j += i << 1) {\r\n          p[j] = 1;\r\n        }\r\n      }\r\n    }\r\n    return nr;\r\n  }\r\n==\r\n\r\nPutem incerca o optimizare de memorie, pentru ca nu mai avem nevoie de elementele cu index par din sirul {$p$}. Acum semnificatia lui $p{~i~}$ s-a schimbat $p{~i~}$ fiind 0 daca $2*i+1$ e numar prim si $1$ daca nu.\r\n\r\n== code(java) | \r\n  // class PrimeNumbersSieve3 \r\n  final int MAXSIZE = 1000000/2+1;\r\n  char[] p = new char[MAXSIZE];\r\n\r\n  //p[i] == 0 if 2*i + 1 is prime\r\n  \r\n  public int getTheNumber(int n) {\r\n    int i, j, nr = 1;\r\n    for (i = 1; (i << 1) + 1 <= n; i += 1) {\r\n      if (p[i] == 0) {\r\n        nr++;\r\n        for (j = i + i + i + 1; (j << 1) + 1 <= n; j += (i << 1) + 1) {\r\n          p[j] = 1;\r\n        }\r\n      }\r\n    }\r\n    return nr;\r\n  }\r\n==\r\n\r\nUrmatoarea optimizare va fi marcarea multiplilor numarului prim $i$ de la $i*i$ nu de la $2*i$ cum am facut in prima varianta sau de la $3*i$ cum am facut in a {$2$}-a. Aceasta optimizare este evidenta: orice numar prim compus multiplu de $i$ mai mic decat $i*i$ are un factor prim mai mic decat {$i$}, si acel factor l-a marcat mai devreme, deci nu are rost sa il marcam si la pasul {$i$}. Ideea aceasta este exact ideea ce se foloseste la rezolvarea problemei \"Numere Prime\":http://www.infoarena.ro/task/prim din arhiva infoarena. Sa vedem acum codul sursa:\r\n\r\n== code(java) | \r\n  //class PrimeNumbersSieve4 \r\n  final int MAXSIZE = 1000000/2+1;\r\n  char[] p = new char[MAXSIZE];\r\n\r\n  //p[i] == 0 if 2*i + 1 is prime\r\n  \r\n  public int getTheNumber(int n) {\r\n    int i, j, nr = 1;\r\n    for (i = 1; ((i * i) << 1) + (i << 1) <= n; i += 1) {\r\n      if (p[i] == 0) {\r\n        for (j = ((i * i) << 1) + (i << 1); (j << 1) + 1 <= n; j += (i << 1) + 1) {\r\n          p[j] = 1;\r\n        }\r\n      }\r\n    }\r\n    for (i=1; 2 * i + 1 <= n; ++i) \r\n        if (p[i] == 0) nr++;\r\n    return nr;\r\n  }\r\n==\r\n\r\nCodul sursa arata putin urat pentru ca nu lucram direct cu $i$ ci cu {$2*i+1$}, am mai facut optimizarea ce apare si in \"mathworld\":http://mathworld.wolfram.com/, nu parcurgem numerele pana la $n$ pentru marcarea multiplilor ci pana la $sqrt(n)$ lucru care e evident dupa cele explicate mai sus.\r\n\r\nUltima imbunatatire care o vom aduce este aceea de a folosi mai putina memorie. Cum pentru fiecare numar e necesara doar o informatie booleana, aceasta o putem tine intr-un bit, nu este necesar un char intreg. Sa vedem cum arata codul:\r\n\r\n== code(java) | \r\n  //class PrimeNumbersSieve5 \r\n  final int MAXSIZE = 100000000/2/8+1;\r\n  char[] p = new char[MAXSIZE];\r\n\r\n  //p[i] == 0 if 2*i + 1 is prime\r\n  \r\n  public int getTheNumber(int n) {\r\n    int i, j, nr = 1;\r\n    for (i = 1; ((i * i) << 1) + (i << 1) <= n; i += 1) {      \r\n      if ((p[i >> 3] & (1 << (i & 7))) == 0) {\r\n        for (j = ((i * i) << 1) + (i << 1); (j << 1) + 1 <= n; j += (i << 1) + 1) {\r\n          p[j >> 3] |= (1 << (j & 7));\r\n        }\r\n      }\r\n    }\r\n    for (i = 1; 2 * i + 1 <= n; ++i)  \r\n         if ((p[i >> 3] & (1 << (i & 7))) == 0) \r\n             nr++;\r\n    return nr;\r\n  }\r\n==\r\n\r\nCodul {@p[i >> 3] & (1 << (i & 7)) @}&#0061;&#0061;{@ 0@} testeaza daca al {@i@}-lea bit din sirul de biti e $0$ (deci daca {@2*i+1@} e prim). {@i >> 3@} e echivalent cu {@i / 8@} deci se gaseste pt bitul al {@i@}-lea in ce char e el stocat din sirul nostru de charuri. {@i & 7@} e echivalent cu {@i % 8@} ca sa aflam pe ce bit al charului e stocat numarul prim {@i@}.\r\n\r\nCodul {@p[j >> 3] |= (1 << (j & 7))@} seteaza bitul {@j % 8@} al charului {@j / 8@} in {@1@}, pentru ca sa stim ca numarul {@2 * j + 1@} nu e prim.\r\n\r\nUltima varianta arata destul de urat fata de prima, sa vedem daca s-a meritat efortul. Urmatoarele date sunt obtinute pe un procesor Athlon XP la 1.8 Ghz:\r\n\r\n* 10 runs of {@BruteForcePrimes().method1(1000000)@} lasted: 24.956 seconds\r\n* 10 runs of {@PrimeNumbersSieve1().getTheNumber(1000000)@} lasted: 3.024 seconds\r\n* 10 runs of {@PrimeNumbersSieve2().getTheNumber(1000000)@} lasted: 1.842 seconds\r\n* 10 runs of {@PrimeNumbersSieve3().getTheNumber(1000000)@} lasted: 1.422 seconds\r\n* 10 runs of {@PrimeNumbersSieve4().getTheNumber(1000000)@} lasted: 0.971 seconds\r\n* 10 runs of {@PrimeNumbersSieve5().getTheNumber(1000000)@} lasted: 0.22 seconds\r\n\r\nCodul folosit pentru testare e:\r\n\r\n== code(java) | \r\n  public static void main(String[] arg) {\r\n    double tick = System.currentTimeMillis();\r\n    for (int i = 0; i < 10; ++i) {\r\n      System.out.println(\"Run \" + i \r\n    + \" result: \"+\r\n      new PrimeNumbersSieve1().\r\n      getTheNumber(1000000));\r\n    }\r\n    System.out.println(\" 10 runs of \"\r\n  + \"PrimeNumbersSieve1().\" \r\n  + \"getTheNumber(1000000) \" \r\n  + \"lasted: \" \r\n  + (System.currentTimeMillis() \r\n  - tick) \r\n  * 1e-3 + \" seconds\");\r\n  }\r\n==\r\n\r\nS-a rulat fiecare cod de $10$ ori pentru a da ocazia optimizarilor Just In Time din java sa isi faca treaba.\r\n\r\nSe pare ca optimizarile codului initial au dus la o imbunatatire a vitezei cu un factor de {$10$}.\r\n\r\nProblemele sugerate la inceputul articolului sunt destul de frumoase si ar trebui rezolvate. Pentru fiecare dintre ele puteti sa va testati rezolvarea: la algoritmus sunt disponibile fisierele de intrare si iesire, infoarena si uva au evaluatoare automate si pentru problema de pe TOPCODER puteti intra in applet-ul lor si sa incercati sa o rezolvati in practice roomul asociat SRM-ului 190 dupa ce o rezolvati folositi optiunea Run System Test din Practice Room Options.\r\n\r\n',961,''),('warm-up-2004/solutii','Solutiile oficiale pentru Concursul \"de incalzire\"','2006-11-16 10:36:11','h1. Solutiile oficiale pentru Concursul \"de incalzire\"\r\n\r\n(Creat de ==user(user=\"silviug\" type=\"tiny\")== la data de _2004-11-15_ categoria _Competitii_, autor(i) _Mircea Pasoi_)\r\n\r\nIn acest articol voi prezenta cateva idei de rezolvare pentru problemele din concursul \"de incalzire\" de la clasele 9-10 si 11-12.\r\n\r\nIncep prin a recunoaste faptul ca setul de probleme a fost unul foarte dur, comparabil cu unul de la nationale, chiar baraje. Pe viitor vom incerca sa facem concursurile mai gradate. Reversul medaliei este ca aveti acum probleme dure cu care sa va pregatiti si la care voi prezenta idei de solutie avand astfel ce invata! Nu voi incerca sa dau solutii foarte explicite, ci doar voi schita ideile de baza deoarece este important sa incercati sa intelegi si sa implementati singuri solutiile! ;)\r\n\r\nh2. Clasele 9-10\r\n\r\nh3. Coins\r\n\r\nPrimul fapt care trebuie observat este numarul destul de mic al starilor de joc si anume {$2^22^ = 4.194.304$}. Recomand \"cartea doamnei Cerchez\":http://www.liis.ro/%7eema/ despre arbori pentru a citi capitolul despre Arbori de Joc. Ideea principala este ca se exploreaza intregul arbore de joc format de starile tablei de $22$ de patralele si se retine intr-un vector boolean pentru fiecare configuratie daca jucatorul care incepe cu acea configuratie castiga sau nu. Astfel, se va raspunde la fiecare din cele $N$ teste in $O(1)$ dupa preprocesarea in $O(22 * 2^22^) = O(1)$ :).\r\n\r\nh3. Zaharel\r\n\r\nSolutia se bazeaza pe proprietatea foarte importanta (subliniata si in enunt) ca pe fiecare linie exista un punct rosu si pe fiecare coloana un punct albastru. Presupunem ca tinem o lista cu puncte. Initial bagam un punct rosu oarecare. Pe coloana punctului rosu respectiv exista un punct albastru (din proprietatea de mai sus). Inseram acel punct albastru in lista. Pe linia punctul albastru va exista un punct rosu , pe care il vom insera in lista. Repetand acest procedeu vom ajunge la un moment dat la un punct care a mai fost in lista ,deci la un ciclu (acest lucru este evident deoarece numarul punctelor este finit). Punctele rosii de pe ciclu vor reprezenta primul poligon, iar punctele albastre al doilea poligon. Este evident ca vor avea acelasi numar de varfuri, vom arata in continuare ca au si acelasi centru de greutate. Fie primul punct (acela rosu) ({$x{~1~}, y{~1~}$}). Al doilea va fi ({$x{~2~}, y{~1~}$}), al treilea ({$x{~2~}, y{~2~}$}), al patrulea ({$x{~3~}, y{~2~}$}) .. penultimul ({$x{~k~}, y{~k-1~}$}), ultimul ({$x{~k~}, y{~k~}$}) (care va coincide cu un alt punct ({$x{~p~}, y{~p~}$}), {$p < k$}). Se observa ca poligonul rosu va avea ca centru de greutate punctul ({$(x{~p~}&#0043;x{~p+1~}+...+x{~k-1~})/(k-p)$}, (y_p+y_p+1+...+y_k-1)/k-p), iar cel albastru ((x_p+1+x_p+2+...+x_k)/k-p, (y_p+1+y_p+2+...+y_k)/k-p), care coincid deoarece (x_p,y_p) = (x_k, y_k).\r\n\r\nh3. Sobo\r\n\r\nProblema se rezolva prin programare dinamica. Se retine in A[i] = costul minim in cazul cel mai defavorabil pentru a recunoaste sobolanul inteligent din multimea de sobolani cu numerele de ordine pozitiile bitilor de 1 in reprezentarea binara a lui i. Astfel, A va avea valori pentru i intre 0 si 2^N-1. Raspunsul va fi A[2^N-1]. Este evident ca graful format de aceste stari este aciclic deoarece fiecare raspuns imparte o multime in doua multimi mai mici. Astfel pentru a calcula un A[i] vom lua fiecare raspuns care imparte in doua multimi nevide multimea curenta, vom vedea in care multime costul este mai mare (cazul cel mai defavorabil) , adaugam pretul raspunsului si actualizam in A[i] daca valoarea aceasta este mai mica decat cea curenta (sa nu uitam ca vrem cost minim in cazul cel mai defavorabil). Cea mai simpla metoda de a implementa acest mecanism este cu memoizare. Complexitatea finala O(2^N * L * N). Se poate optimiza la O(2^N * L) folosind operatii pe biti.\r\n\r\n\r\n\r\nh2. Clasele 11-12\r\n\r\nh3. Xor Max\r\n\r\nFie X[i] = A[1] xor A[2] xor ... A[i]. Pentru fiecare X[i] vom incearca sa gasim un X[j] (j < i) astfel incat X[i] xor X[j] sa fie maxim. Pentru a realiza aceasta operatie eficient vom mentine un \"trie\" (vezi in CLR varianta in romana la pagina 223 - capitolul \"Arbori binari de cautare\" problema 13-2 - se asemana cu \"suffix trees/tries\" doar ca vom lucra cu siruri binare). Fie b numarul maxim de biti pe care ii are un element din vector. Vom realiza operatia de gasire a lui X[j] in O(b). Structura de date mentionata mai sus va memora sirurile de biti formate de vectorul X. Vom parcurge bitii lui X[i] de la cel mai semnificativ la cel mai nesemnificativ. Astfel daca bitul curent este 1, vom incerca sa gasim un sir de biti care are acest bit 0 (pentru a maxima xor-ul), iar daca bitul curent este 0 vom proceda invers. Complexitatea finala a algoritmului este O(N*b).\r\n\r\nh3. Boom\r\n\r\nVom construi un graf din cele 2^N stari posibile. Prin stare intelegem un numar binar in care bitii de 1 reprezinta locurile in care s-ar putea afla sobolanul. Pentru fiecare astfel de nod, exista M muchii la alte noduri, care se obtin aplicand bomba asupra pozitiilor si avansarea pozitiilor ramase. Deoarece muchiile au costuri numere naturale, iar graful nu este neaparat aciclic vom aplica algoritmul Dijkstra, pentru a determina drumul de cost minim de la nodul 2^N-1 la nodul 0. Pentru a se incadra in timp era necesara implementarea cozii de prioritate cu heap-uri. Complexitate finala O(2^N * N * M).\r\n\r\nh3. PetSoft\r\n\r\nIn fiecare nod din arbore vom retine doua valori A[i][0] = costul minim pentru a cupla subarborele cu radacina in i, fara a cupla nodul i cu cineva, si A[i][1] acelasi lucru, dar cupland nodul i cu cineva. Pentru a calcula aceste valori in fiecare nod, luam numerele de ordine a fiilor , le sortam si aplicam o alta dinamica pentru a obtine echipe cu cost maxim. Astfel determinam A[i][0]. Pentru a calcula A[i][1], inseram si nodul i in lista fiilor, sortam din nou si aplicam aceeasi dinamica (atentie la detalii de implementare!). Dinamica se face astfel: retinem in C[i][j] = costul maxim pentru a forma echipe de cost maxim cu valorile de pe pozitiile i, i+1...j-1, j. Este evident ca C[i][j] se obtine din C[i+1][j], C[i][j-1] si C[i+1][j-1]. Complexitatea finala este O(N^2).\r\n\r\nReferences\r\n\r\nVisible links\r\n1. \r\n\r\n',961,'public'),('hashing','Hashing','2006-11-16 12:04:37','h1. Hashing\r\n\r\n(Creat de \'_skipy_\':user/skipy la data de _2004-11-22_ categoria _Tabele de dispersie_, autor(i) _Giurgea Mihnea_)\r\n\r\nh2. Scop hashing (sau tabele de dispersie)\r\n\r\nNe propunem sa creeem o structura de date eficienta care sa poata face urmatoarele operatii cat mai repede posibil: {@Insereaza@}, {@Cauta@} si {@Sterge@}. Ideea in spatele hashing-ului este memorarea unui element intr-un tablou sau lista in functie de cheia sa. Pe cazul mediu toate aceste operatii necesita $O(1)$ timp. Sa vedem cum:\r\n\r\nh2. Adresare directa\r\n\r\nElementele sunt puse intr-un tablou alocat static pe pozitiile cheilor lor. Prin adresare directa, un element cu cheia $k$ va fi memorat in locatia {$k$}. Toate cele $3$ operatii sunt extrem de simple(necesita doar o accesare de memorie), dar dezavantajul este ca aceasta tehnica \"mananca\" foarte multa memorie: {$O(|U|)$}, unde $U$ este universul de chei.\r\n\r\nh2. Standard hashing\r\n\r\nPrimul pas in a rezolva problema memoriei este de a folosi $O(N)$ memorie in loc de {$O(|U|)$}, unde $N$ este numarul de elemente adaugate in hash. Astfel, un element cu cheia $k$ nu va fi memorat in locatia {$k$}, ci {$h(k)$}, unde {@h:U->{0,1,...,N-1}@} - o functie aleasa aleator, dar determinista( $h(x)$ va returna mereu aceeasi valoare in cursul rularii unui program ). Daca functia este aleasa aleator, elementele vor fi \"imprastiate\" in hash in mod echivalent, egal. Ideal ar fi ca fiecare element sa fie stocat in locatia lui. Acest lucru insa nu este posibil, pentru ca $N < |U|$ si, deci, de multe ori mai multe elemente vor fi repartizate in aceeasi locatie. Aceasta problema se numeste coliziune.\r\n\r\nCum rezolvam coliziunile?\r\n\r\nh3. Inlantuire\r\n\r\nIn fiecare locatie din hash tinem o lista inlantuita; astfel, la oricare din cele $3$ operatii se va parcurge toata lista. Pe un caz pur teoretic, toate cele $N$ elemente ar putea fi repartizate in aceeasi locatie, insa pe cazuri practice lungimea medie a celui mai lung lant este de {$lg(N)$}.\r\n\r\n* Memorie: {$O(N)$}, pointeri: da\r\n\r\nh3. Liste statice\r\n\r\nAceasta metoda este o imbunatatire a punctului anterior: pentru ca lungimea unui lant este cel mult {$lg(N)$}, putem sa folosim, in loc de liste inlantuite, vectori alocati dinamic de lungime $lg(N)$ - sau {$lg(N) + 3$}, ca sa fiti siguri :). Scapam astfel de lucrul cu pointerii.\r\n\r\n* Memorie: {$O(N*lg(N))$}, pointeri: nu\r\n\r\nh3. Adresare directa\r\n\r\nPrin adresare directa, toate elementele sunt memorate in tabela de hash. Pentru a realiza operatiile cerute, verificam succesiv tabela de hash pana cand fie gasim o locatie libera(in cazul Inserarii), fie gasim elementul cautat (pentru {@Cauta@}, {@Sterge@}). Insa, in loc sa cautam tabela de hash in ordinea {$0,1,....,N-1$}, sirul de pozitii examinate depinde de cheia ce se insereaza. Pentru a determina locatiile corespunzatoare, extindem functia de hash astfel incat sa contina si numarul de verificare ca un al doilea parametru {@h:U*{0,1,....,N-1}->{0,1,...,N-1}@}. Astfel, cand vom insera un element, verificam mai intai locatia {$h(k , 0)$}, apoi {$h(k , 1)$} etc. Cand ajungem sa verificam {$h(k , N)$} putem sa ne oprim pentru ca tabela de hash este plina; pentru cautare aplicam aceeasi metoda; daca ajungem la {$h(k , N)$} sau la o pozitie goala inseamnca ca elementul nu exista. Stergerile se fac insa mai greu, pentru ca nu se poate \"sterge\" pur si simplu un element deoarece ar strica tot hash-ul; in schimb, se marcheaza\r\nlocatia ce trebuie stearsa cu o valoare $STERS$ si se modifica functia Insereaza astfel incat sa vada locatiile cu valoarea $STERS$ ca pozitii goale.\r\n\r\n* Memorie: {$O(N)$}, pointeri: nu\r\n\r\nh3. Mihai Patrascu\'s Double hashing\r\n\r\nO imbunatarire foarte mare la tabela de hashing este... inca o tabela de hashing. Vom avea $2$ tabele, fiecare cu proria ei functie de hash, iar coliziunile le rezolvam prin inlantuire; cand inseram un element il vom adauga in tabela in care intra intr-un lant mai scurt. Cautarea se face in ambele tabele in locatiile returnate de cele $2$ functii de hash; stergerea la fel. Astfel, lungime celui mai lung lant va fi, in medie, {$lg(lg(N))$}. Dar, in practica, lungimea unui astfel de lant nu va depasi $4$ elemente, pentru ca cel mai mic $N$ pt care $lg(lg(N)) = 5$ este {$2^32^$ ~ 2.000.000.000$}!!! Deci in loc de liste folosim vectori statice de dimensiune 4.\r\n\r\n* Memorie: {$O(N)$}, pointeri: nu\r\n\r\nh2. Functii de hash\r\n\r\nToate functiile de hash intorc un numar intre $0$ si {$M-1$}, unde $M$ este dimensiunea maxima a tabelei de hash. Este recomandat ca $M$ sa fie ales un numar prim si sa se evite alegerea lui {$M=2^k^$}.\r\n\r\nh3. Pentru numere intregi:\r\n\r\np(pre). \r\n* h(x) = x {@%@} M\r\n* h(x) = (x * r) % M , r - numar aleator ales la inceputul programului\r\n\r\nh3. Pentru 3. C)\r\n\r\np(pre). \r\n* h(x , i) = ( h\'(x) + i ) {@%@} M\r\n* h(x , i) = ( h\'(x) + r1 * i + r2 * i^2^ ) {@%@} M\r\n* h(x , i) = ( h1(x) + i * h2(x) ) {@%@} M\r\nr1, r2 - numere alese aleator la inceputul programului.\r\n\r\nh3. Pentru numere reale\r\n\r\np(pre). \r\n* h(x) = [ {a * x} * M ] , 0 < a < 1\r\n\r\n${x}$ - partea fractionara a lui {$x$}\r\n$[x]$ = partea intreaga a lui {$x$}; \r\n$[x] + {x} = x$ - prin definitie;\r\n$a$ este un numar care trebuie ales inainte sau la inceputul rularii programului; alegerea lui influenteaza eficienta functiei; Knuth propune urmatoarea valoare pentru $a=(sqrt(5)-1)/2$ ~ {$0.6180339887$}...\r\n\r\nh2. Teme pentru acasa\r\n\r\nIncercati sa rezolvati urmatoarele probleme:\r\n\r\n* \"Magic Pairs\":http://acm.sgu.ru/problem.php?contest=0&problem=119\r\n* \"Walls\":http://acm.sgu.ru/problem.php?contest=0&problem=174\r\n* \"Algoritmus 3 - 3: Colinearitate\":http://www.algoritmus.org/probleme/probleme_runda03.php\r\n\r\n',961,'public'),('automate-finite-si-kmp','Automate finite si KMP','2006-11-16 12:16:27','h1. Automate finite si KMP\r\n\r\n(Creat de ==user(user=\"azotlichid\" type=\"tiny\")== la data de _2005-01-12_ categoria _Automate_, autor(i) _Vladu Adrian_)\r\n\r\nIn acest articol vom aborda cele mai comune probleme legate de pattern matching si vom oferi suportul teoretic necesar intelegerii algoritmului Knuth-Morris-Pratt, pornind de la potrivirea standard cu automate finite si rafinand-o treptat pana la un algoritm de complexitate {$O(n + m)$}. Toate acestea intr-o maniera usor de inteles ;)\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nh2. Automate finite\r\n\r\nh3. Ce sunt automatele finite ?\r\n\r\nUn automat finit este definit ca un cvintuplu {${@<@}Q, q{~0~}, A, &#0931;, &#0948;{@>@}$} unde $Q$ este o multime finita de stari {$Q = {q{~0~}, q{~1~}, ... q{~n~}}$}, $q{~0~}$ apartine $Q$ ({$q{~0~}$} = stare initiala), $A$ inclus in $Q$ ({$A$} = multimea starilor de acceptare), $&#0931;$ este un alfabet, iar functia {$&#0948; : Q x S -> Q$}.\r\n\r\nAceasta este definitia matematica si foarte abstractizata a automatelor. Pentru a le intelege mai usor, sa luam un exemplu concret\r\n\r\nQ = {q0, q1, q2, q3}\r\nA = {q3}\r\nS = {a, b}\r\nd =\r\n\r\n\r\n\r\n\r\n| | a | b |\r\n\r\n| 0 | 1 | 2 |\r\n\r\n| 1 | 3 | 1 |\r\n\r\n| 2 | 3 | 0 |\r\n\r\n| 3 | 3 | 3 |\r\n\r\n\r\nCe inseamna asta? Sa spunem ca automatul primeste un string s = \'bbaba\'\r\nInitial ne aflam in q0. Pentru fiecare element al stringului s_i facem tranzitia d(qk, s_i).\r\n\r\nPornim din k = 0. Vom avea :\r\n\r\nk = 0; d(0, b) = 2;\r\nk = 2; d(2, b) = 0;\r\nk = 0; d(0, a) = 1;\r\nk = 1; d(1, b) = 1;\r\nk = 2; d(1, a) = 3;\r\n\r\nDaca ultima stare obtinuta qk apartine A, atunci spunem ca automatul accepta stringul. Altfel spus, daca avem stringul s, lungime(s) = n, automatul accepta stringul daca si numai daca d ( ... d( d(0, s(1)), s(2) ) ..., s(n) ) apartine A.\r\n\r\nStringurile \'aa\', \'aaaaaaa\', \'aabababab\', \'aaaba\', \'ba\', \'aba\' sunt acceptate de automat, dar \'ba\', \'abbbbbb\', \'bba\' nu.\r\n\r\nLa ce folosesc ?\r\n\r\n1. Inteligenta artificiala (prima si cea mai involuata stare a inteligentei artificiale)\r\n2. Aplicatii teoretice si probleme de matematica :)\r\n3. Pattern matching\r\n\r\nSe dau stringurile M si N. Se cere sa gasim toate aparitiile lui N in M.\r\nVom numi Mi prefixul lui M de lungime i. Presupunand ca avem construit automatul care accepta stringul N, vom cauta toate prefixele lui M acceptate de automat, deci toate numerele 1 <= i <= lungime(M) cu proprietatea ca automatul accepta stringul Mi.\r\n\r\n\r\n\r\nAlgoritm_potrivire_cu_automat_finit\r\n\r\n1: n = lungime(N)\r\n2: q = 0;\r\n3: pt i <- 1, n\r\n4: q = d(q, M[i])\r\n5: daca q apartine A\r\n6: scrie \"potrivire la pozitia \" i - n + 1\r\n\r\ncomplexitate : O(n)\r\n\r\nSa vedem cum se construieste automatul de potrivire pentru un string N. Fie m = lungime(M). Construim un automat cu m + 1 stari {q0, q1, ... qm}, A = {qm} . Faptul ca ne aflam in starea x inseamna ca au fost acceptate primele x caractere din sirul de intrare.\r\nDin fiecare stare qx apartine Q si pt fiecare c apartine S construim d(x, c) = y cu proprietatea ca My este cel mai lung prefix al lui M care este sufix al lui Mxc (prefixul de lungime x al lui M, concatenat cu caracterul c).\r\n\r\n\r\n\r\nAlgoritm_constructie_automat_finit\r\n\r\n1: m <- lungime(M)\r\n2: pt q <- 0, m\r\n3: pt c apartine S\r\n4: gaseste Mi = cel mai lung prefix al lui M cu Mi sufix al lui Mqc\r\n5: d(q, c) = i\r\n\r\ncomplexitate : linia 4 are complexitatea O(m^2) (implementata in maniera bruta) si se executa de (m + 1) * |S| ori => complexitate totala O(m^3 * |S|)\r\n\r\nPractic, algoritmul calculeaza pentru toate 0 =< i =< m, c apartine S cat de mult putem lua de la sfarsitul lui Mic astfel incat acesta sa fie un \"inceput\" de N.\r\n\r\nAcesta se poate rafina, eliminand operatii redundante, dupa cum vom vedea in cele ce urmeaza.\r\n\r\n\r\n\r\nAlgoritmul KMP\r\n\r\nGaseste toate aparitiile un string N in M in timp O(n + m), unde n = lungime(N), m = lungime(M). O parte esentiala a sa este functia prefix p : {1..n} -> {0..n-1} unde p[i] = cel mai lung prefix al lui M care este sufix al lui Mi. Evident, Mp[i] (prefixul de lungime p[i] al lui M) prefix al lui Mi, deci p[i] < i.\r\n\r\nAlgoritm_calcul_functie_prefix\r\n\r\n1: n <- lungime(N)\r\n2: k <- 0\r\n3: p[1] <- 0\r\n4: pt i <- 2, n\r\n5: cat timp (k > 0) si (N[k + 1] ** N[i])\r\n6: k <- p[k]\r\n7: daca N[k + 1] = N[i]\r\n8: k <- k + 1\r\n9: p[i] <- k\r\n\r\nAnaliza complexitatii :\r\n- la fiecare pas (i = 2, n) k se incrementeaza cel mult o data, deci pe parcursul algoritmului k se va incrementa de cel mult n - 1 ori (linia 8)\r\n- in linia 5, k se decrementeaza cel mult pana devine 0, deci se va decrementa de cel\r\nmult n - 1 ori pe parcursul algoritmului\r\n\r\n=> Complexitate : O(n)\r\n\r\nAlgoritmul este similar cu constructia automatului de acceptare. Din fiecare stare i in care s-a acceptat Ni, vedem cat de mult putem lua de la sfarsitul lui Ni astfel incat sufixul respectiv sa fie prefix pentru N. De remarcat ca in cazul in care starea candidata k nu este buna, nu mergem in k - 1, ci in p[k]. Aceasta este de fapt \"magia\" care ofera complexitate liniara.\r\n\r\nAlgoritmul de potrivire este similar celui al calculului functiei prefix, numai ca aici la fiecare pas i cautam cel mai lung prefix al lui N care este sufix al lui Mi.\r\n\r\n\r\n\r\nAlgoritm_potrivire_KMP\r\n\r\n1: m <- lungime(M), n <- lungime(N)\r\n2: q <- 0\r\n3: pt i <- 1, m\r\n4: cat timp (q > 0) si (N[q + 1] ** M[i])\r\n5: q <- pi[q]\r\n6: daca N[q + 1] = M[i]\r\n7: q <- q + 1\r\n8: daca q = n\r\n9: scrie \"potrivire la pozitia \" i - n + 1\r\n\r\n\r\n\r\nAnalog Algoritm_Calcul_Functie_Prefix, complexitatea algoritmului efectiv de potrivire este O(m). Astfel rezulta complexitatea liniara a algoritmului KMP O(n + m)\r\n\r\nTeme pentru acasa:\r\n\r\n- folosind functia prefix, rafinati constructia automatului finit de acceptare pt un string, aducand-o la complexitatea O(m^2 * |S|)\r\n- problema \"[1]Microvirus\" (hint : construiti automatul de potrivire pentru stringul dat)\r\n- Timus 1158\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://www.liis.ro/%7ecampion/problems/2/64/microvirus.htm\r\n\r\n',961,'public'),('automate-finite-si-kmp','Automate finite si KMP','2006-11-16 12:31:36','h1. Automate finite si KMP\r\n\r\n(Creat de ==user(user=\"azotlichid\" type=\"tiny\")== la data de _2005-01-12_ categoria _Automate_, autor(i) _Vladu Adrian_)\r\n\r\nIn acest articol vom aborda cele mai comune probleme legate de pattern matching si vom oferi suportul teoretic necesar intelegerii algoritmului Knuth-Morris-Pratt, pornind de la potrivirea standard cu automate finite si rafinand-o treptat pana la un algoritm de complexitate {$O(n + m)$}. Toate acestea intr-o maniera usor de inteles ;)\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nh2. Automate finite\r\n\r\nh3. Ce sunt automatele finite ?\r\n\r\nUn automat finit este definit ca un cvintuplu {@<@}{$Q, q{~0~}, A, &#0931;, &#0948;$}{@>@} unde $Q$ este o multime finita de stari {$Q = {q{~0~}, q{~1~}, ... q{~n~}}$}, $q{~0~}$ apartine $Q$ ({$q{~0~}$} = stare initiala), $A$ inclus in $Q$ ({$A$} = multimea starilor de acceptare), $&#0931;$ este un alfabet, iar functia {$&#0948; : Q x S -> Q$}.\r\n\r\nAceasta este definitia matematica si foarte abstractizata a automatelor. Pentru a le intelege mai usor, sa luam un exemplu concret\r\n\r\n!http://www.infoarena.ro/Automate_finite_si_KMP?action=download&file=dfa.jpg!\r\n\r\n* $Q = {q{~0~}, q{~1~}, q{~2~}, q{~3~}}$\r\n* $A = {q{~3~}}$\r\n* $&#0931; = {a, b}$\r\n* &#0948; = \r\n\r\ntable. | &#0948; | a | b |\r\n| 0&nbsp; | 1 | 2 |\r\n| 1 | 3 | 1 |\r\n| 2 | 3 | 0&nbsp; |\r\n| 3 | 3 | 3 |\r\n\r\n\r\nCe inseamna asta? Sa spunem ca automatul primeste un string $s$ = *bbaba*\r\nInitial ne aflam in {$q{~0~}$}. Pentru fiecare element al stringului $s{~i~}$ facem tranzitia {$&#0948;(q{~k~}, s{~i~})$}.\r\n\r\nPornim din {$k = 0$}. Vom avea :\r\n\r\n* $k = 0; &#0948;(0, b) = 2;$\r\n* $k = 2; &#0948;(2, b) = 0;$\r\n* $k = 0; &#0948;(0, a) = 1;$\r\n* $k = 1; &#0948;(1, b) = 1;$\r\n* $k = 2; &#0948;(1, a) = 3;$\r\n\r\nDaca ultima stare obtinuta $q{~k~}$ apartine {$A$}, atunci spunem ca automatul accepta stringul. Altfel spus, daca avem stringul {$s$}, {$lungime(s) = n$}, automatul accepta stringul daca si numai daca $&#0948;( ... &#0948;( &#0948;(0, s{~1~}), s{~2~} ) ..., s{~n~} )$ apartine {$A$}.\r\n\r\nStringurile \'{$aa$}\', \'{$aaaaaaa$}\', \'{$aabababab$}\', \'{$aaaba$}\', \'{$ba$}\', \'{$aba$}\' sunt acceptate de automat, dar \'{$ba$}\', \'{$abbbbbb$}\', \'{$bba$}\' nu.\r\n\r\nh3. La ce folosesc ?\r\n\r\n# Inteligenta artificiala (prima si cea mai involuata stare a inteligentei artificiale)\r\n# Aplicatii teoretice si probleme de matematica :)\r\n# Pattern matching\r\n\r\nSe dau stringurile $M$ si {$N$}. Se cere sa gasim toate aparitiile lui $N$ in {$M$}.\r\nVom numi {$M{~i~}$} prefixul lui $M$ de lungime {$i$}. Presupunand ca avem construit automatul care accepta stringul {$N$}, vom cauta toate prefixele lui $M$ acceptate de automat, deci toate numerele $1 &le; i &le; lungime(M)$ cu proprietatea ca automatul accepta stringul {$M{~i~}$}.\r\n\r\nh3. Algoritm_potrivire_cu_automat_finit\r\n\r\n== code(c) | n = lungime(N)\r\nq = 0;\r\npt i <- 1, n\r\n    q = d(q, M[i])\r\n    daca q apartine A\r\n        scrie \"potrivire la pozitia \" i - n + 1\r\n==\r\n\r\n* Complexitate : $O(n)$\r\n\r\nSa vedem cum se construieste automatul de potrivire pentru un string N. Fie m = lungime(M). Construim un automat cu m + 1 stari {q0, q1, ... qm}, A = {qm} . Faptul ca ne aflam in starea x inseamna ca au fost acceptate primele x caractere din sirul de intrare.\r\nDin fiecare stare qx apartine Q si pt fiecare c apartine S construim d(x, c) = y cu proprietatea ca My este cel mai lung prefix al lui M care este sufix al lui Mxc (prefixul de lungime x al lui M, concatenat cu caracterul c).\r\n\r\n\r\n\r\nh3. Algoritm_constructie_automat_finit\r\n\r\n1: m <- lungime(M)\r\n2: pt q <- 0, m\r\n3: pt c apartine S\r\n4: gaseste Mi = cel mai lung prefix al lui M cu Mi sufix al lui Mqc\r\n5: d(q, c) = i\r\n\r\ncomplexitate : linia 4 are complexitatea O(m^2) (implementata in maniera bruta) si se executa de (m + 1) * |S| ori => complexitate totala O(m^3 * |S|)\r\n\r\nPractic, algoritmul calculeaza pentru toate 0 =< i =< m, c apartine S cat de mult putem lua de la sfarsitul lui Mic astfel incat acesta sa fie un \"inceput\" de N.\r\n\r\nAcesta se poate rafina, eliminand operatii redundante, dupa cum vom vedea in cele ce urmeaza.\r\n\r\nh2. Algoritmul KMP\r\n\r\nGaseste toate aparitiile un string N in M in timp O(n + m), unde n = lungime(N), m = lungime(M). O parte esentiala a sa este functia prefix p : {1..n} -> {0..n-1} unde p[i] = cel mai lung prefix al lui M care este sufix al lui Mi. Evident, Mp[i] (prefixul de lungime p[i] al lui M) prefix al lui Mi, deci p[i] < i.\r\n\r\nh3. Algoritm_calcul_functie_prefix\r\n\r\n1: n <- lungime(N)\r\n2: k <- 0\r\n3: p[1] <- 0\r\n4: pt i <- 2, n\r\n5: cat timp (k > 0) si (N[k + 1] ** N[i])\r\n6: k <- p[k]\r\n7: daca N[k + 1] = N[i]\r\n8: k <- k + 1\r\n9: p[i] <- k\r\n\r\nAnaliza complexitatii :\r\n- la fiecare pas (i = 2, n) k se incrementeaza cel mult o data, deci pe parcursul algoritmului k se va incrementa de cel mult n - 1 ori (linia 8)\r\n- in linia 5, k se decrementeaza cel mult pana devine 0, deci se va decrementa de cel\r\nmult n - 1 ori pe parcursul algoritmului\r\n\r\n=> Complexitate : O(n)\r\n\r\nAlgoritmul este similar cu constructia automatului de acceptare. Din fiecare stare i in care s-a acceptat Ni, vedem cat de mult putem lua de la sfarsitul lui Ni astfel incat sufixul respectiv sa fie prefix pentru N. De remarcat ca in cazul in care starea candidata k nu este buna, nu mergem in k - 1, ci in p[k]. Aceasta este de fapt \"magia\" care ofera complexitate liniara.\r\n\r\nAlgoritmul de potrivire este similar celui al calculului functiei prefix, numai ca aici la fiecare pas i cautam cel mai lung prefix al lui N care este sufix al lui Mi.\r\n\r\n\r\n\r\nh3. Algoritm_potrivire_KMP\r\n\r\n1: m <- lungime(M), n <- lungime(N)\r\n2: q <- 0\r\n3: pt i <- 1, m\r\n4: cat timp (q > 0) si (N[q + 1] ** M[i])\r\n5: q <- pi[q]\r\n6: daca N[q + 1] = M[i]\r\n7: q <- q + 1\r\n8: daca q = n\r\n9: scrie \"potrivire la pozitia \" i - n + 1\r\n\r\n\r\n\r\nAnalog Algoritm_Calcul_Functie_Prefix, complexitatea algoritmului efectiv de potrivire este O(m). Astfel rezulta complexitatea liniara a algoritmului KMP O(n + m)\r\n\r\nTeme pentru acasa:\r\n\r\n- folosind functia prefix, rafinati constructia automatului finit de acceptare pt un string, aducand-o la complexitatea O(m^2 * |S|)\r\n- problema \"[1]Microvirus\" (hint : construiti automatul de potrivire pentru stringul dat)\r\n- Timus 1158\r\n\r\n\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://www.liis.ro/%7ecampion/problems/2/64/microvirus.htm\r\n\r\n',961,'public'),('agora-finala/solutii','Concursul Agora - Etapa Finala - Solutii','2005-07-12 00:00:00','h1. Concursul Agora - Etapa Finala - Solutii\n\n(Creat de \'_Cosmin_\':user/Cosmin la data de _2005-07-12_ categoria _Competitii_, autor(i) _Cosmin_)\n\n*Continut scurt:*\n ==Include(page=\"template/raw\")==\n\nArticolul contine cateva idei de solutionare a problemelor de la etapa finala a concursului Agora. Concursul s-a desfasurat la Cluj in 9 iulie pentru concurentii ce s-au calificat in finala, dar s-a desfasurat si online pentru cei care doreau sa isi incerce puterile.\n\n\n*Continut lung:*\n==Include(page=\"template/raw\")==\n\nProblema 1: Drumuri\n\nProblema cerea determinarea unei partitionari a muchiilor dintr-un graf conex in perechi disjuncte astfel ca in fiecare pereche de muchii cele doua muchii sa aiba un capat comun. Pentru orice graf conex cu numar par de muchii exista o asemenea partitionare a muchiilor. Algoritmul ce solutioneaza problema ne demonstreaza acest lucru. Putem determina pentru graful nostru un arbore partial (arbore DFS sau BFS sau care mai vreti voi). Putem lua o frunza din arborele nostru, daca ea are grad par atunci o putem elimina din arbore si toate muchiile ce aveau un capat in ea sa le imperechem doua cate doua. Daca in schimb frunza are grad impar atunci eliminam toate muchiile mai putin cea din arbore si eliminam nodul virtual din graf, dar nu si muchia asociata care devine o muchie oarecare si va putea fi eliminata cand procesam tata frunzei actuale. Singura problema ce poate aparea este cand ajungem la radacina, dar cum dintr-un graf cu numar par de muchii am eliminat la fiecare pas un numar par de muchii inseamna\nca radacina are grad par, deci problema noastra este rezolvata. Complexitatea algoritmului este O(N + M) si ca timp si ca memorie, acest algoritm poate fi foarte usor implementat ca o parcurgere dfs care dupa ce viziteaza un nod si fii sai il elimina din graf.\n\nProblema 2: Colectie\n\nProblema se imparte in doua bucati: Prima este determinarea numarului de cifre i care apar in scrierea numerelor de la 1 la K unde i este intre 0 si 9. Aceasta problema se poate rezolva in O(log K) cu programare dinamica, o rezolvare eficienta a fost ceruta la bacalaureat in anul 2001 deci nu e asa grea :) , o rezolvare care lua putin timp ar fi fost metoda constantelor, adica putem tine minte din 100 de mii in 100 de mii rezultatele partiale (aceasta abordare a fost luata de Patcas Csaba la etapa finala).\nAcum avem de rezolvat o problema de obtinere a unui vector dimensiune 10 ca suma unei submultimi de vectori dati la intrare. Aceasta problema o putem rezolva cu o tehnica intalnita pe la concursuri de programare, dar care nu a devenit inca clasica. Impartim multimea de vector in doua multimi de dimensiuni n / 2 si n - n /2. Pentru prima multime determinam toate submultimile si sumele vectoriale asociate acelor submultimi, si sortam submultimile dupa acele sume. Acum pentru fiecare submultime de vectori din a doua multime obtinem o suma vectoriala sum, noi vrem sa mai adaugam ceva elemente la aceasta suma pentru a obtine un vector target ce reprezinta pentru fiecare cifra numarul de etichete necesare pentru a eticheta toate numerele de la 1 la K. Deci vom cauta binar in primul sir vectorul target - sum. Faza de sortare dureaza O(n^2 * 2^n) si faza de cautare binara tot atat.Astfel rezolvare are complexitatea O(2^n * n^2 + log K) ca timp si O(2^n * n) ca spatiu.\n\nProblema 3: Heroes of Might and Magic\n\nProblema cerea determinarea numarului de drumuri de la un punct (start_x, start_y) dintr-o matrice pana la un punct (end_x, end_y) din aceiasi matrice, drum care sa aiba cel mult K pasi. Problema se rezolva usor folosind metoda programarii dinamice. Vom folosi o matrice tridimensionala unde num_ways[i][j][k] are semnificatia: numarul de drumuri ce incep in (start_x, start_y), se termina in (i, j) si au fix k pasi. Solutia se va afla in num_ways[end_x][end_y][0]+num_ways[end_x][end_y][1]+...num_ways[end_x][end_y][K]. Formula de recurenta pentru problema este usor de determinat:\nnum_ways[i][j][k] = num_ways[i + 1][j][k - 1] num_ways[i - 1][j][k - 1] + num_ways[i][j - 1][k - 1] + num_ways[i][j + 1][k - 1] . Se observa ca pentru a determina valorile corespunzatoare lui k avem nevoie doa r de valorile corespunzatoare lui k - 1, deci putem folosi doua matrici bidimensionale in loc de una tridimensionala. Complexitatea solutiei ca si timp este O(N * M * K) iar ca si spatiu este O(N * M).\n\n',0,'public'),('agora-finala/solutii','Concursul Agora - Etapa Finala - Solutii','2006-11-16 22:16:50','h1. Concursul Agora - Etapa Finala - Solutii\r\n\r\n(Creat de ==user(user=\"Cosmin\" type=\"tiny\")== la data de _2005-07-12_ categoria _Competitii_, autor(i) _Cosmin_)\r\n\r\nArticolul contine cateva idei de solutionare a problemelor de la etapa finala a concursului Agora. Concursul s-a desfasurat la Cluj in 9 iulie pentru concurentii ce s-au calificat in finala, dar s-a desfasurat si online pentru cei care doreau sa isi incerce puterile.\r\n==Include(page=\"template/raw\")==\r\n\r\nh2. Problema 1: Drumuri\r\n\r\nProblema cerea determinarea unei partitionari a muchiilor dintr-un graf conex in perechi disjuncte astfel ca in fiecare pereche de muchii cele doua muchii sa aiba un capat comun. Pentru orice graf conex cu numar par de muchii exista o asemenea partitionare a muchiilor. Algoritmul ce solutioneaza problema ne demonstreaza acest lucru. Putem determina pentru graful nostru un arbore partial (arbore DFS sau BFS sau care mai vreti voi). Putem lua o frunza din arborele nostru, daca ea are grad par atunci o putem elimina din arbore si toate muchiile ce aveau un capat in ea sa le imperechem doua cate doua. Daca in schimb frunza are grad impar atunci eliminam toate muchiile mai putin cea din arbore si eliminam nodul virtual din graf, dar nu si muchia asociata care devine o muchie oarecare si va putea fi eliminata cand procesam tata frunzei actuale. Singura problema ce poate aparea este cand ajungem la radacina, dar cum dintr-un graf cu numar par de muchii am eliminat la fiecare pas un numar par de muchii inseamna\r\nca radacina are grad par, deci problema noastra este rezolvata. Complexitatea algoritmului este $O(N + M)$ si ca timp si ca memorie, acest algoritm poate fi foarte usor implementat ca o parcurgere DFS care dupa ce viziteaza un nod si fii sai il elimina din graf.\r\n\r\nh2. Problema 2: Colectie\r\n\r\nProblema se imparte in doua bucati: Prima este determinarea numarului de cifre $i$ care apar in scrierea numerelor de la $1$ la $K$ unde $i$ este intre $0$ si {$9$}. Aceasta problema se poate rezolva in $O(log K)$ cu programare dinamica, o rezolvare eficienta a fost ceruta la bacalaureat in anul 2001 deci nu e asa grea :) , o rezolvare care lua putin timp ar fi fost metoda constantelor, adica putem tine minte din $100.000$ in $100.000$ rezultatele partiale (aceasta abordare a fost luata de Patcas Csaba la etapa finala).\r\nAcum avem de rezolvat o problema de obtinere a unui vector dimensiune $10$ ca suma unei submultimi de vectori dati la intrare. Aceasta problema o putem rezolva cu o tehnica intalnita pe la concursuri de programare, dar care nu a devenit inca clasica. Impartim multimea de vector in doua multimi de dimensiuni $n / 2$ si {$n - n /2$}. Pentru prima multime determinam toate submultimile si sumele vectoriale asociate acelor submultimi, si sortam submultimile dupa acele sume. Acum pentru fiecare submultime de vectori din a doua multime obtinem o suma vectoriala {$sum$}, noi vrem sa mai adaugam ceva elemente la aceasta suma pentru a obtine un vector $target$ ce reprezinta pentru fiecare cifra numarul de etichete necesare pentru a eticheta toate numerele de la $1$ la {$K$}. Deci vom cauta binar in primul sir vectorul {$target - sum$}. Faza de sortare dureaza $O(n^2^ * 2^n^)$ si faza de cautare binara tot atat.Astfel rezolvare are complexitatea $O(2^n^ * n^2^ + log K)$ ca timp si $O(2^n^ * n)$ ca spatiu.\r\n\r\nh2. Problema 3: Heroes of Might and Magic\r\n\r\nProblema cerea determinarea numarului de drumuri de la un punct ({$start_x, start_y$}) dintr-o matrice pana la un punct ({$end_x, end_y$}) din aceiasi matrice, drum care sa aiba cel mult $K$ pasi. Problema se rezolva usor folosind metoda programarii dinamice. Vom folosi o matrice tridimensionala unde $num_ways{~i,j,k~}$ are semnificatia: numarul de drumuri ce incep in ({$start_x, start_y$}), se termina in ({$i, j$}) si au fix $k$ pasi. Solutia se va afla in {$num_ways{~end_x,end_y,0~}+num_ways{~end_x,end_y,1~}+...num_ways{~end_x,end_y,K~}$}. Formula de recurenta pentru problema este usor de determinat:\r\n{$num_ways{~i,j,k~} = num_ways{~i+1,j,k-1~}+num_ways{~i-1,j,k-1~} + num_ways{~i,j-1,k-1~} + num_ways{~i,j+1,k-1~}$}. Se observa ca pentru a determina valorile corespunzatoare lui $k$ avem nevoie doar de valorile corespunzatoare lui {$k - 1$}, deci putem folosi doua matrici bidimensionale in loc de una tridimensionala. Complexitatea solutiei ca si timp este $O(N * M * K)$ iar ca si spatiu este {$O(N * M)$}.\r\n\r\n',961,'public'),('agora-finala/solutii','Concursul Agora - Etapa Finala - Solutii','2006-11-16 22:18:09','h1. Concursul Agora - Etapa Finala - Solutii\r\n\r\n(Creat de ==user(user=\"Cosmin\" type=\"tiny\")== la data de _2005-07-12_ categoria _Competitii_, autor(i) _Cosmin_)\r\n\r\nArticolul contine cateva idei de solutionare a problemelor de la etapa finala a concursului Agora. Concursul s-a desfasurat la Cluj in 9 iulie pentru concurentii ce s-au calificat in finala, dar s-a desfasurat si online pentru cei care doreau sa isi incerce puterile.\r\n==Include(page=\"template/raw\")==\r\n\r\nh2. Problema 1: Drumuri\r\n\r\nProblema cerea determinarea unei partitionari a muchiilor dintr-un graf conex in perechi disjuncte astfel ca in fiecare pereche de muchii cele doua muchii sa aiba un capat comun. Pentru orice graf conex cu numar par de muchii exista o asemenea partitionare a muchiilor. Algoritmul ce solutioneaza problema ne demonstreaza acest lucru. Putem determina pentru graful nostru un arbore partial (arbore DFS sau BFS sau care mai vreti voi). Putem lua o frunza din arborele nostru, daca ea are grad par atunci o putem elimina din arbore si toate muchiile ce aveau un capat in ea sa le imperechem doua cate doua. Daca in schimb frunza are grad impar atunci eliminam toate muchiile mai putin cea din arbore si eliminam nodul virtual din graf, dar nu si muchia asociata care devine o muchie oarecare si va putea fi eliminata cand procesam tata frunzei actuale. Singura problema ce poate aparea este cand ajungem la radacina, dar cum dintr-un graf cu numar par de muchii am eliminat la fiecare pas un numar par de muchii inseamna\r\nca radacina are grad par, deci problema noastra este rezolvata. Complexitatea algoritmului este $O(N + M)$ si ca timp si ca memorie, acest algoritm poate fi foarte usor implementat ca o parcurgere DFS care dupa ce viziteaza un nod si fii sai il elimina din graf.\r\n\r\nh2. Problema 2: Colectie\r\n\r\nProblema se imparte in doua bucati: Prima este determinarea numarului de cifre $i$ care apar in scrierea numerelor de la $1$ la $K$ unde $i$ este intre $0$ si {$9$}. Aceasta problema se poate rezolva in $O(log K)$ cu programare dinamica, o rezolvare eficienta a fost ceruta la bacalaureat in anul 2001 deci nu e asa grea :) , o rezolvare care lua putin timp ar fi fost metoda constantelor, adica putem tine minte din $100.000$ in $100.000$ rezultatele partiale (aceasta abordare a fost luata de Patcas Csaba la etapa finala).\r\nAcum avem de rezolvat o problema de obtinere a unui vector dimensiune $10$ ca suma unei submultimi de vectori dati la intrare. Aceasta problema o putem rezolva cu o tehnica intalnita pe la concursuri de programare, dar care nu a devenit inca clasica. Impartim multimea de vector in doua multimi de dimensiuni $n / 2$ si {$n - n /2$}. Pentru prima multime determinam toate submultimile si sumele vectoriale asociate acelor submultimi, si sortam submultimile dupa acele sume. Acum pentru fiecare submultime de vectori din a doua multime obtinem o suma vectoriala {$sum$}, noi vrem sa mai adaugam ceva elemente la aceasta suma pentru a obtine un vector $target$ ce reprezinta pentru fiecare cifra numarul de etichete necesare pentru a eticheta toate numerele de la $1$ la {$K$}. Deci vom cauta binar in primul sir vectorul {$target - sum$}. Faza de sortare dureaza $O(n^2^ * 2^n^)$ si faza de cautare binara tot atat.Astfel rezolvare are complexitatea $O(2^n^ * n^2^ + log K)$ ca timp si $O(2^n^ * n)$ ca spatiu.\r\n\r\nh2. Problema 3: Heroes of Might and Magic\r\n\r\nProblema cerea determinarea numarului de drumuri de la un punct ({$start_x, start_y$}) dintr-o matrice pana la un punct ({$end_x, end_y$}) din aceiasi matrice, drum care sa aiba cel mult $K$ pasi. Problema se rezolva usor folosind metoda programarii dinamice. Vom folosi o matrice tridimensionala unde $num_ways{~i,j,k~}$ are semnificatia: numarul de drumuri ce incep in ({$start_x, start_y$}), se termina in ({$i, j$}) si au fix $k$ pasi. Solutia se va afla in {$num_ways{~end_x,end_y,0~}&#0043;num_ways{~end_x,end_y,1~}&#0043;...&#0043;num_ways{~end_x,end_y,K~}$}. Formula de recurenta pentru problema este usor de determinat:\r\n{$num_ways{~i,j,k~} = num_ways{~i+1,j,k-1~}&#0043;num_ways{~i-1,j,k-1~} &#0043; num_ways{~i,j-1,k-1~} &#0043; num_ways{~i,j+1,k-1~}$}. Se observa ca pentru a determina valorile corespunzatoare lui $k$ avem nevoie doar de valorile corespunzatoare lui {$k - 1$}, deci putem folosi doua matrici bidimensionale in loc de una tridimensionala. Complexitatea solutiei ca si timp este $O(N * M * K)$ iar ca si spatiu este {$O(N * M)$}.\r\n\r\n',961,'public'),('stl','STL','2006-11-16 23:39:59','h1. STL\r\n\r\n(Creat de ==user(user=\"rgrig\" type=\"tiny\")== la data de _2004-12-05_ categoria _Limbaje_, autor(i) _Radu Grigore_)\r\n\r\nBiblioteca standard C++ are doua componente mari: \"standard template library\" (STL) si stream-uri de intrare/iesire. Acest articol prezinta un subset al STL pe care il folosesc adesea in practica.\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nh2. Introducere\r\n\r\nSTL se bazeaza pe trei concepte centrale: containeri, iteratori si algoritmi. Ca tehnica de programare folosita e bine sa stiti ca orientarea pe obiecte aproape ca lipseste. In schimb se utilizeaza din plin polimorfismul parametric. In C++ numele acestuia este \"template\"; in C# si Java se obisnuieste sa se spuna \"generice\".\r\n\r\nIn continuare voi presupune ca sunteti familiari cu utilizarea template-urilor si cunoasteti bine limbajul C. Codul folosit presupune ca la inceputul fisierului exista:\r\n\r\n== code(cpp) |#include <iostream>\r\n#include <deque>\r\n#include <list>\r\n#include <vector>\r\n#include <set>\r\n#include <map>\r\n#include <iterator>\r\n#include <algorithm>\r\n#include <cassert>\r\n#include <string>\r\nusing namespace std;\r\n==\r\n\r\nh2. Containeri\r\n\r\nIn limbajul de baza avem la dispozitie tablourile pentru reprezentarea unei secvente indexate de elemente. Dimensiunea unui tablou trebuie fie sa fie cunoscuta la compilare, fie sa fie gestionata explicit de programator prin alocare dinamica. Principalul avantaj al STL este ca ne scapa de aceasta grija. In afara de adresarea indexata obisnuita secventele STL au si operatia {$push_back$}: adauga un element la sfarsit (si, evident, creste dimensiunea cu {$1$}). Exista si operatia inversa {$pop_back$}: elimina ultimul element. Cele trei secvente STL care suporta aceste operatii sunt {$vector$}, $deque$ si {$list$}. Un exemplu de utilizare este:\r\n\r\n== code(cpp) |// v are 10 elemente egale cu 0\r\nvector<int> v(10);\r\n// acces indexat\r\nv[1] = 2; cout << v[0] << endl;\r\nv.push_back(3); cout << v[10] << endl;\r\nv.pop_back();\r\n==\r\n\r\nCele trei secvente difera prin implementare. Pe scurt, $vector$ tine datele intr-o zona continua de memorie, $list$ este o lista dublu inlantuita a elementelor, iar $deque$ este ceva intre: o lista inlantuita de pachete continue. (deque vine de la \"double ended queue\" dar se pronunta \"deck\" -- pachet tocmai pentru a sugera implementarea)\r\n\r\nEste util sa stim in mare care e implementarea pentru a alege secventa in functie de operatiile pe care le avem de facut si de frecventa lor. De exemplu $vector$ are cel mai rapid acces indexat; pe de alta parte adaugarea unui element poate duce la copierea intregului continut daca nu mai exista memorie rezervata la coada (adica {$v.capacity() == v.size()$}). Lista este rapida pentru inserari de elemente in interior dar este lenta pentru accesele indexate. $Deque$ este mai eficienta decat $vector$ daca se fac multe operatii $push_back$ dar este ceva mai lenta pentru accese indexate uzuale. In plus mai exista si o diferenta de interfata. Atat $deque$ cat si $list$ ofera in plus fata de vector operatiile $push_front$ si {$pop_front$}. Aceasta deoarece in cazul vectorilor ele ar fi avut complexitatea $O(n)$ daca se dorea pastrarea rapiditatii accesului indexat.\r\n\r\nSa vedem o implementare de jucarie a unei cozi cu ajutorul $deque$ pentru a mai ilustra cateva functii membre.\r\n\r\n== code(cpp) |template <typename T>\r\nclass Queue\r\n{\r\n    private:\r\n        deque<T> data;\r\n    public:\r\n        void Push(const T& el)\r\n        {\r\n            data.push_back(el);\r\n        }\r\n        T Pop()\r\n        {\r\n            assert(!data.empty());\r\n            T result(data.front());\r\n            data.pop_front();\r\n            return result;\r\n        }\r\n};\r\n\r\n\r\nInteresant este ca STL are deja astfel de adaptori ale secventelor simple: stack, queue si priority_queue. Metodele uzuale sunt pop, push si top; push si pop au semantica uzuala iar top intoarce o referinta la elementul care va fi inlaturat de urmatorul pop. In plus se mai poate testa daca containerul e gol cu empty. Voi da un exemplu de utilizare a priority_queue:\r\n\r\npriority_queue<int> pq;\r\n\r\npq.push(3);\r\n\r\npq.push(4);\r\n\r\npq.push(1);\r\n\r\ncout << pq.top() << endl; pq.pop(); // scrie 4\r\n\r\ncout << pq.top() << endl; pq.pop(); // scrie 3\r\n\r\ncout << pq.top() << endl; pq.pop(); // scrie 1\r\n\r\ncout << pq.empty() << endl; // scrie 1 (=true)\r\n\r\nDesigur, putem redefini operatorul \"mai mic\" daca dorim o ordonare diferita. De exemplu putem afla cel mai apropiat punct de (0, 0, 0) astfel:\r\n\r\nstruct Point {\r\n\r\nint x, y, z;\r\n\r\nbool operator < (const Point& o) const {\r\n\r\nreturn x*x+y*y+z*z > o.x*o.x+o.y*o.y+o.z*o.z;\r\n\r\n}\r\n\r\n};\r\n\r\npriority_queue<Point> pq;\r\n\r\nIntrucat operatiunile de extindere/micsorare la capete sunt uzuale pentru adaptorii stack/queue acestia folosesc in mod obisnuit drept container un deque. Iar o coada de prioritati este implementata cu heap-uri asa incat rapiditatea accesului indexat este importanta si vector-ul este alegerea default. Aceste alegeri pot fi insa configurate. De exemplu daca aveti o coada de prioritati in care stiti ca veti introduce foarte multe elemente si veti extrage doar cateva ar fi poate mai bine sa folositi:\r\n\r\npriority_queue<int, deque<int> > pq;\r\n\r\n\r\n\r\nCam atat despre secvente. Celalalt tip important de containeri sunt containerii asociativi: map si set (mai exista multimap si multiset dar nu voi vorbi despre ei). Primul este o multime de perechi (cheie, valoare) ce pot fi regasite rapid dupa cheie, care este unica. Implementarea este cu arbori rosu-negru asa incat timpul de inserare si cel de cautare este O(lg n). O utilizare tipica pentru map este:\r\n\r\nmap<string, int> name_to_phone;\r\n\r\nname_to_phone[\"Ion Ion\"] = 8234783;\r\n\r\nname_to_phone[\"Me\"] = 8237462;\r\n\r\ncout << name_to_phone[\"Ion Ion\"] << endl;\r\n\r\nPentru un set utilizarea uzuala este:\r\n\r\nset<string> s;\r\n\r\ns.insert(\"Ion ion\");\r\n\r\ns.insert(\"baubau\");\r\n\r\n\r\n\r\n// scrie 0=false\r\n\r\ncout << (s.find(\"Gica\") != s.end()) << endl;\r\n\r\n\r\n\r\n// scrie 1=true\r\n\r\ncout << (s.find(\"baubau\") != s.end()) << endl\r\n\r\n\r\n\r\nPentru a se putea construi un arbore de cautare pentru chei de tipul T atat set cat si map necesita ca less<T> sa fie bine definit. Daca nu oferiti voi o specializare a template-ului, cea generica apeleaza operatorul <. Cu alte cuvinte cu exceptia unor situatii deosebite ce probabil nu apar intr-un concurs e ok de retinut ca trebuie sa fie definit operatorul <.\r\n\r\nUn map este foarte util pentru a memoiza o functie recursiva.\r\n\r\ntemplate <typename T, typename U>\r\n\r\nU my_func(T t)\r\n\r\n{\r\n\r\n// se autoapeleaza\r\n\r\n// nu are \"side-effects\"\r\n\r\nreturn result;\r\n\r\n}\r\n\r\nSe transforma in:\r\n\r\nmap<T, U> cache;\r\n\r\ntemplate <typename T, U>\r\n\r\nU my_func(T t)\r\n\r\n{\r\n\r\nmap<T, U>::const_iterator it =\r\n\r\ncache.find(t);\r\n\r\nif (it != cache.end()) return *it;\r\n\r\n// corpul vechi\r\n\r\nreturn cache[t] = result;\r\n\r\n}\r\n\r\nTransformarea e automata si se face foarte usor. In multe cazuri plusul de viteza este suficient si nu e nevoie ca tot codul sa fie transformat in varianta programare dinamica. In plus solutia de mai sus merge si atunci cand t poate avea valori foarte mari sau nu este un intreg (de exemplu e o structura, un string, etc.) si deci trecerea la programare dinamica n-ar fi evidenta si ar lua ceva timp de gasit o solutie.\r\n\r\nExemplul de mai sus foloseste o functie template numai pentru a sugera ca acolo pot fi orice tipuri (nu doar intregi). In practica template-urile mai mult se folosesc decat se scriu.\r\n\r\nSa trecem acum la iteratori.\r\n\r\n\r\n\r\nIteratori\r\n\r\nGanditiva la algoritmul de gasire a maximului. El nu depinde de implementarea folosita pentru reprezentarea multimii! Tot ceea ce trebuie sa faci este sa accesezi toate elementele.. nici macar nu conteaza ordinea. Ei bine iteratorii permit o astfel de decuplare intre structurile de date si algoritmi.\r\n\r\nExemplu:\r\n\r\ntemplate <typename T>\r\n\r\ntypename T::value_type max(\r\n\r\ntypename T::const_iterator begin,\r\n\r\ntypename T::const_iterator end)\r\n\r\n{\r\n\r\nassert (begin != end); // container empty\r\n\r\ntypename T::const_iterator it;\r\n\r\ntypename T::value_type r = *begin;\r\n\r\nfor (it = begin; it != end; ++it)\r\n\r\nif (*it > r) r = *it;\r\n\r\nreturn r;\r\n\r\n}\r\n\r\n\r\n\r\nObservati ca sintaxa pentru iteratori seamana mult cu sintaxa pentru pointeri. Iteratorii din C++ sunt analogul enumeratorilor din C# si Java, doar ca sunt mai flexibili. Operatile care se pot face cu ei sunt: \"treci la urmatorul element\" (++it), \"treci la elementul anterior\" (--it), \"da-mi o referinta la elementul catre care arati\" (*it) si compararea (it_a == it_b, it_a != it_b). Unii iteratori pot in plus sa se deplaseze cu n pozitii (it += n, it -= n).\r\n\r\nCodul de mai sus poate fi utilizat pentru oricare dintre cele trei secvente prezentate anterior astfel:\r\n\r\n#define ALL(c) (c).begin(), (c).end()\r\n\r\ndeque<int> d;\r\n\r\nvector<int> v;\r\n\r\n// ... some work ..\r\n\r\ncout << max(ALL(d)) << endl;\r\n\r\ncout << max(ALL(v)) << endl;\r\n\r\nAlgoritmi\r\n\r\nDupa cum vedeti utilizarea functiei max este simpla, mai complicata este definitia. Din fericire header-ul <algorithm> are deja scrise tot felul de astfel de functii dragute. Una de care s-ar putea sa va indragostiti :) este next_permutation. Ia primeste ca parametrii limitele unei secvente (ca mai sus) si transforma acea secventa in urmatoarea permutare in ordine lexicografica si intoarce true, sau intoarce false daca ordonarea este deja ultima. Iata cum se foloseste:\r\n\r\nstring handle(\"rgrig\");\r\n\r\nsort(ALL(handle)); // alta functie draguta\r\n\r\ndo {\r\n\r\ncout << handle << endl;\r\n\r\n} while (next_permutation(ALL(handle));\r\n\r\nCodul de mai sus ilustreaza o alta functie utila: sort. In exemplul urmator vom vedea cum poate fi folosita next_permutation pentru a genera toate combinarile de n elemente luate cate k.\r\n\r\nvector<int> choose(n);\r\nfor (int i = n-k; i < n; ++i)\r\nchoose[i] = 1;\r\ndo {\r\n// .. foloseste choose ..\r\n} next_permutation(ALL(choose));\r\n\r\nAm utilizat un vector de intregi si nu unul de booleeni asa cum ar dicta \"spiritul\" C++ pentru ca secventa vector are o specializare pentru tipul bool si impacheteaza cate 32 de elemente intr-un intreg nativ. Asta are tot felul de efecte neplacute printre care scaderea vitezei. Exista si un efect \"placut\" dar util probabil in conjuncturi speciale: ocupa mai putin spatiu.\r\n\r\n\r\n\r\nO alta functie interesanta este copy. Pe aceasta o putem folosi pentru a concatena doua secvente sau pentru a tipari continutul unei secvente.\r\n\r\nvector<int> a, b;\r\n// .. pune niste valori in a si b ..\r\n// pune tot continutul lui b la sfarsitul lui a\r\ncopy(ALL(b), back_inserter(a));\r\n// tipareste continutul lui a\r\ncopy(ALL(a), ostream_iterator<int>(cout, \", \"));\r\n\r\nO functie utila pentru prelucrarea sirurilor inainte de parsare este replace. De exemplu pentru a inlocui toate virgulele cu spatii intr-un sir se procedeaza astfel:\r\n\r\nstring s(\"a,b,c,d\");\r\nreplace(ALL(s), \',\', \' \');\r\n\r\nDaca doriti sa cautati o sub-secventa intr-o secventa mai mare atunci puteti folosi search. Acesta intoarce un iterator care arata la locul unde s-a gasit sub-secventa sau \"end\" in caz contrar. De exemplu, pentru a gasi toate aparitiile unui cuvant intr-un sir putem scrie:\r\n\r\n// un deque e mai eficient decat string pt. texte lungi\r\ndeque<char> text;\r\nstring word;\r\n// .. pune niste valori in text si word ..\r\ndeque<char>::iterator it = text.begin();\r\nint c = 0;\r\nwhile (\r\n\r\n(it = search(it, text.end(), ALL(word))) != text.end()) {\r\n++c; ++it;\r\n}\r\n// c contine numarul de aparitii al lui word in text\r\n\r\nAtentie: complexitatea functiei search este O(mn) asa incat uneori va trebui sa faceti totusi cautarea de mana.\r\n\r\nPentru a numara de cate ori apare un element intr-o secventa putem utiliza functia count.\r\n\r\n#define ALLARRAY(a) (a), ((a) + sizeof(a)/sizeof(a[0]))\r\nint av[] = {1, 2, 3, 1, 2, 3, 1};\r\n\r\n// un mod de a pune date in v\r\n\r\nvector<int> v(ALLARRAY(av));\r\n\r\ncout << count(ALL(v), 1) << endl; // prints 3\r\nif (!count(ALL(v), 4))\r\ncout << \"v nu contine 4\" << endl;\r\n\r\nDaca vrem sa stim numai daca un element apare sau nu intro secventa o varianta ce se poate dovedi mai rapida in situatii foarte particulare este sa folosim find.\r\n\r\nif (find(ALL(v), 4) == v.end())\r\ncout << \"v nu contine 4\" << endl;\r\n\r\nIn sfarsit, o ultima functie interesanta ce lucreaza pe secvente este reverse. Utilizare tipica:\r\n\r\nint av[] = {1, 1, 2, 1};\r\nvector<int> v(ALLARRAY(av));\r\nreverse(ALL(v)); // acum v contine 1, 2, 1, 1\r\n\r\nAlte mici utilitare care operaza cu valori normale (nu containeri) sunt: max, min, swap. Semantica este probabil evidenta din nume, dar voi da totusi un exemplu de utilizare:\r\n\r\nint a = 2, b = 1;\r\nint m = min(a, b);\r\nint M = max(a, b);\r\nswap(m, M);\r\ncout << M << \" \" << m << endl; // prints \"1 2\"\r\n\r\nConcluzie si referinte\r\n\r\nCe am prezentat in acest articol reprezinta o portiune reprezentativa a STL, dar este totusi doar o portiune. Am preferat sa dau multe exemple simple in locul unor explicatii mai teoretice. Uneori mi-a fost tare greu sa ma abtin :) de exemplu sa nu povestesc mai in detaliu cum e gestionata implicit zona de memorie \"rezervata\" si de ce...\r\n\r\nPentru mai multe detalii puteti fie sa consultati o referinta electronica, fie sa luati cartea lui Bjarne Stroustrup \"Limbajul C++\" aparuta la teora. Vezi si:\r\n\r\n1. [1]O alta prezentare introductiva\r\n\r\n2. [2]Referinta SGI\r\n\r\n3. [3]Referinta Dinkumware\r\n\r\n4. [4]Standardul\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://www.topcoder.com/index?t=features&c=feat_082803\r\n2. http://www.sgi.com/tech/stl/\r\n3. http://www.dinkumware.com/refxcpp.html\r\n4. http://www.csci.csusb.edu/dick/c++std/cd2/\r\n\r\n',961,'public'),('sandbox','Sandbox','2006-11-17 00:45:12','\r\n|{background-color:gold}. Mircea Pasoi |{background-color:gold}. aur |\r\n|{background-color:gold}. Codrut Grosu |{background-color:gold}. aur |\r\n|{background-color:silver}. Tiberiu Florea |{background-color:silver}. argint |\r\n|{background-color:bronze}. Adrian Vladu |{background-color:bronze}. bronz |\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',961,'public'),('home','info-arena 2.0','2006-11-16 11:24:02','==html|<img src=\"http://msig.info/web2v2/info-arena+2.0BETA.png\" alt=\"info-arena 2.0 BETA\" />==\r\n\r\nSite-ul este complet editabil de catre administratori. Se recomanda sa citesti \'documentatia de textile\':Textile. Daca vrei sa testezi optiunile de formatare ale Textile poti sa te duci in \'sandbox\':Sandbox ca sa testezi.\r\n\r\n== code(c) | \r\n#defin JEG(a, b) ( (a) < (b) ? (a) : (b) )\r\n\r\nint main (void) {\r\n    double f = -1.3e6;\r\n    int a;\r\n    char *s = \"ma\\\\\\\"ma\";\r\n    printf(\"hai cu sorcova\\n\");\r\n    scanf(\"%d\", &a);\r\n\r\n/* Nu putem sa mai scoatem din culori ?\r\n   Sintaxa asta arata k dreq :-L\r\n*/\r\n    return 0;\r\n}\r\n==\r\n\r\ntable. | Continut care mai trebuie formatat:\r\n&nbsp;\r\n* \"Articole\":Articles\r\n* \"News\":News\r\n&nbsp;\r\nDe asemenea, mai trebuie convertit *TOT* continutul din \"wiki-ul\":http://infoarena.devnet.ro/wiki/index.php/Main_Page vechi. |\r\n\r\nAici e \'arhiva de probleme\':round/arhiva.\r\n\r\nDaca esti admin vezi \'lista rundelor\':page_index?prefix=round si \'lista problemelor\':page_index?prefix=task.\r\n\r\nh2. Ultimele 3 stiri\r\n\r\n==News(pager_style=\"none\" display_entries=\"3\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':news',18,'public'),('usaco-ianuarie-2005-divizia-gold','Usaco ianuarie 2005, divizia GOLD','2006-11-17 19:54:10','h1. Usaco ianuarie 2005, divizia GOLD\r\n\r\n(Creat de \'_silviug_\':user/silviug la data de _2005-03-03_ categoria _Competitii_, autor(i) _Silviu Ganceanu, Mircea Pasoi_)\r\n\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nAcest set de probleme a fost considerat unul dintre cele mai grele, daca nu cel mai greu, de pana acum. Problemele au fost intr-adevar dure cu atat mai mult cu cat timpul de lucru a fost mic (3 ore). In ciuda acestui fapt concurentii din Romania s-au comportat bine, concursul marcand primul succes de pe anul acesta al tarii noastre: locul 5 obtinut de Adrian Vladu.\r\n\r\nDesi rezultatele i-au determinat pe antrenorii americani sa considere setul de probleme cel mai greu de pana acum, pentru multi dintre elevii Romaniei problemele nu au fost in totalitate noi: cover a fost propusa (sub o forma un pic diferita) la CEOI, o varinta ceva mai blanda a problemei juice (cu limite mai mici) am putut vedea si in finala rundei .Campion de anul trecut iar ideea de rezolvare pentru naptime nu era noua (o problema din concursul $\"Stelele Informaticii\"$ de anul trecut se pare ca semana mult cu aceasta).\r\n\r\nCu toate aceastea problemele au fost deosebit de dificile necesitand concentrare maxima. Rezultatele elevilor din Romania s-au imbunatatit semnificativ fata de concursul precedent, acestia obtinand locuri mai bune. O parte din succesul acestora indraznesc sa o pun si pe seama faptului ca problema cea mai grea din concurs era cunoscuta la noi in tara. Avem astfel urmatorul clasament:\r\n\r\ntable(example). | 1. | Adrian Vladu | 958 puncte |\r\n| 2. | Sorin Stancu-Mara | 703 puncte |\r\n| 3. | Mircea Pasoi | 700 puncte |\r\n| 4. | Andrei Teodorescu | 640 puncte |\r\n| 5. | Dan-Ionut Fechete | 547 puncte |\r\n| 6. | Adrian Diaconu | 502 puncte |\r\n\r\nRestul concurentilor au obtinut punctaje frumoase dar mai mici de 400 de puncte. Sunt de remarcat comportarile bune de pana acum ale lui Andrei Teodorescu care reuseste sa se \"tina\" de mult mai titratii elevi ai Romaniei care au deja in palmares cel putin o medalie internationala.\r\n\r\nSetul de probleme, impreuna cu testele si clasamentul, se gaseste in cadrul \"sectiunii download\":http://info.devnet.ro/download.php?page=cat&cat=33 . In continuare vom prezenta solutiile:\r\n\r\nh2. Cover\r\n\r\nProblema nu era foarte dificila, cu atat mai mult cu cat ideea de rezolvare a problemei guards din concursul CEOI 2002 era aceeasi: se construieste un graf bipartit avand intr-o multime barele orizontale (set maximal de pozitii de pe o linie din matrice in care avem noroi) si in cealalta multime barele verticale (definite analog dar pentru coloane). Intre doua noduri din acest graf bipartit vom avea muchie doar daca barele corespunzatoare lor au o celula comuna. Pentru exemplificare vom lucra cu exemplul din enunt:\r\n\r\n$ *.*. $\r\n$ .*** $\r\n$ ***. $\r\n$ ..*. $\r\n\r\nIata cum vom construi prima multime a grafului bipartit (vom pune numarul nodului din graf corespunzator fiecarei celule):\r\n\r\n$ 1.2. $\r\n$ .333 $\r\n$ 444. $\r\n$ ..5. $\r\n\r\nA doua multime a grafului bipartit va arata astfel (nodurile vor fi numerotate incepand tot cu 1):\r\n\r\n$ 1.2. $\r\n$ .324 $\r\n$ 532. $\r\n$ ..2. $\r\n\r\nMuchiile din graful bipartit vor fi urmatoarele:\r\n\r\n$(1, 1) (2, 2) (3, 3) (3, 2) (3, 4) (4, 5) (4, 3) (4, 2) (5, 2)$\r\n\r\nAsadar fiecarei celule din harta terenului ii corespunde o singura muchie in acest graf bipartit. Avand construit graful trebuie sa aflam numarul minim de noduri selectate astfel incat orice muchie sa aiba cel putin un capat intre nodurile selectate (in literatura de specialitate aceasta problema se numeste $Minimum Vertex Cover$). Explicatia acestui lucru este simpla: orice muchie, fiind de fapt o celula, ea trebuie sa fie \"acoperita\" de cel putin un nod din graf (adica o placa orizontala sau verticala utilizata de FJ). Problema acesta este NP-completa pentru grafuri generale dar in cazul grafurilor bipartite ea se poate rezolva in timp polinomial. De asemenea s-a demonstrat ca numarul minim de noduri dintr-un astfel de set este egal cu cardinalul cuplajului maximal din graful bipartit. De aici nu mai e decat un pas spre solutia finala. Avem, astfel, urmatorii pasi in algoritmul de rezolvare a problemei:\r\n\r\n\r\n* PAS 1: Construirea grafului bipartit$\r\n* PAS 2: Aflarea cuplajului maximal$\r\n\r\n\r\nPrimul pas este banal si consta din simple parcurgeri ale matricii. Pentru aflarea cuplajului maximal se poate afla utilizand un algoritm de aflarea a fluxului maxim in reteaua asociata grafului bipartit sau se poate algoritmul bazat pe gasirea succesiva a drumurilor in crestere in graf.\r\n\r\nComplexitatea finala a algoritmului va fi O(N^2*M^2) deoarece in graful bipartit avem maxim N*M muchii si vom N*M noduri. Cum algoritmul pentru aflarea cuplajului maximal are complexitatea V*E (V = numarul de noduri din graf, E = numarul de muchii din graf) concluzia este evidenta.\r\n\r\nCa tema, recomand rezolvarea urmatoarelor probleme a caror solutie se bazeaza pe aflarea cuplajului maximal intr-un graf bipartit (in unele cazuri acest lucru insa nu este de ajuns):\r\n\r\n1. guards (CEOI 2002)\r\n2. knigths (Baltica 2001) - in solutia oficiala a acestei probleme gasiti mai multe informatii despre notiunea de cuplaj maximal intr-un graf bipartit si problemele inrudite\r\n3. Problema Paznici din runda a patra a concursului Algoritmus (gasiti pe pagina si explicatia solutiei) [2]http://algoritmus.org/probleme/Probleme_Runda04.php\r\n4. [3]http://acm.timus.ru/problem.aspx?space=1&num=1106\r\n5. [4]http://acm.sgu.ru/problem.php?contest=0&problem=234\r\n6. [5]http://acm.sgu.ru/problem.php?contest=0&problem=210\r\n7. [6]http://acm.sgu.ru/problem.php?contest=0&problem=218\r\n8. [7]http://online-judge.uva.es/p/v107/10735.html\r\n9. [8]http://online-judge.uva.es/p/v108/10804.html\r\n10. [9]http://online-judge.uva.es/board/viewtopic.php?t=7462\r\n\r\nMentionez ca problema 8 m-a impresionat in mod placut fiind una dintre cele mai frumoase probleme pe care le-am intalnit in ultimele cateva luni.\r\n\r\nJuice\r\n\r\nFie A(i, j) inaltimea blocului aflat in pozitia (i, j). Aflam inaltimea maxima la care poate urca nivelul sucului in fiecare celula. Daca notam aceasta inaltime cu B(i, j) solutia problemei va fi suma( B(i, j) - A(i, j) ).\r\n\r\nVom numi celula turn o celula (i, j) care are propietatea ca B(i, j) = A(i, j) (nu putem pune suc in ea pentru ca ar curge in afara matricei). Componenta conexa a unei celule turn (i, j) este compusa din acele celule (x, y) pentru care avem B(x, y) = A(i, j). Definim inaltimea componentei conexe ca fiind inaltimea comuna a tuturor celulelor componente. Facem urmatoarele observatii utile in rezolvarea problemei:\r\n\r\n1. Celulele de pe marginea matricei sunt celule turn\r\n2. Celula (x, y) devine celula turn daca este vecina unei celule (i, j) ce face parte dintr-o componenta conexa si are propietatea ca B(i, j) < A(x, y).\r\n\r\nIncet, incet se contureaza solutia problemei observand ca, pentru a declara o celula ca fiind turn, trebuie sa aflam componentele conexe ale celulelor turn mai joase decat ea. Acest lucru ne aduce la ideea de procesa aceste celule turn in ordinea inaltimii lor afland pentru fiecare componenta conexa corespunzatoare. In acelasi timp aflam si celule ce devin turn si sunt mai inalte. Pentru aceasta utilizam o coada de prioritati (un heap) in care pastram toate celule turn neprocesate inca ordonate descrescator dupa inaltime. Ajungem astfel la nimic altceva decat un algoritm de tip FILL modificat corespunzator cerintelor acestei probleme. Iata o descriere a acestuia:\r\n\r\n\r\n\r\nPAS 1: Se introduc in coada de prioritati\r\n\r\npozitiile de pe margine\r\n\r\n\r\n\r\nPAS 2: Cat timp heapul nu este gol:\r\n\r\n* se selecteaza celula turn cea mai joasa\r\n\r\n* se afla componenta conexa a acesteia\r\n\r\n* se introduc in coada de prioritati\r\n\r\ncelulele vecine cu componenta conexa construita\r\n\r\ncare au inaltimea mai mare decat inaltimea\r\n\r\ncomponentei\r\n\r\n\r\n\r\nSe poate modifica usor algoritmul FILL pentru a rezolva toate aceste cerinte. Complexitatea finala a algoritmului va fi O(N^2*logN) deoarece, in cazul cel mai defavorabil, toate celulele sunt turn (un exemplu este cand matricea este piramidala) si in consecinta toate celulele vor fi introduse si scoase din heap necesitand logN pentru fiecare operatie. Aflarea componentelor conexe va necesita O(N^2) timp in total fiindca o celula va fi selectata o singura data intr-o componenta conexa si va fi accesata de maxim 4 ori de algoritmul FILL. Ca detalii de implementare, programatorii in C++ pot folosi cozile de prioritati din STL (pririority_queue ce se gaseste in headerul <queue>) pentru a reduce din complexitatea implementarii. Totusi, trebuie acordata atentie utilizarii acestora deoarece este posibil ca sursa sa depasesca timpul de executie.\r\n\r\nNaptime\r\n\r\nVom incerca sa rezolvam problema, ignorand la inceput faptul ca sirul este circular. Astfel, problema se transforma intr-una relativ usoara, abordabila cu programare dinamica. O prima incercare ar fi sa realizam o astfel de rezolvare: A(i, j) = utilitatea de somn maxima care se poate obtine alegand j perioade din primele i.\r\nRelatia de recurenta care se obtine este A(i, j)=max(A(i-k, j-k)+suma U[i-k+2]...U[i]) unde U este vectorul de utilitati. Din pacate aceasta abordare are dezavantajul ca are complexitatea de timp O(N*B^2) si de memorie O(N*B), neincadrandu-se nici in timp si nici in spatiu de memorie. Astfel, vom incerca sa imbunatatim aceasta dinamica modificand un pic semnificatia matricei A bazandu-ne pe faptul ca alegerea unei secvente continue de perioade aduca ca utilitate suma lor, mai putin prima perioada folosita:\r\nA(i, j, 1) = utilitatea de somn maxima care se poate obtine alegand j perioade din primele i si ultima perioada folosita sa fie j\r\nA(i, j, 0) = utilitatea de somn maxima care se poate obtine alegand j perioade din primele i si ultima perioada folosita sa NU fie j\r\nObtinem relatiile de recurenta:\r\nA(i, j, 1) = max(A(i-1, j-1, 1) + U[i], A(i-1, j-1, 0))\r\nA(i, j, 0) = max(A(i-1, j, 0), A(i-1, j, 1))\r\nAm redus complexitatea la O(N*B) si memoria la O(N), o imbunatatire substantiala.\r\n\r\nDeoarece sirul este circular, putem rezolva problema aplicand de N ori dinamica de mai sus considerand sirul liniar si alegand fiecare pozitie ca fiind pozitia initiala, dar aceasta solutie depaseste cu mult limita de timp pe cazul cel mai defavorabil. Totusi, aceasta idee ar fi adus 10 teste din cele 14. Cu un mic truc, si anume alegerea aleatorie a pozitiei de start cat timp nu s-a depasit timpul de executie, s-ar mai fi putut obtine inca 2 teste, in total 12 (desi aceasta rezolvare nu obtine solutia optima pe testele foarte mari).\r\n\r\nPutem scapa de faptul ca sirul este circular mult mai elegant, aplicand de 2 ori dinamica: odata cum am zis mai sus (acoperind cazul cand pozitiile N si 1 nu sunt in aceeasi secventa de pozitii consecutive) si inca odata fortand sa existe o secventa de utilitati aleasa care contine pozitiile N si 1. A doua dinamica se poate obtine exact ca mai sus, aplicand aceeasi idee doar ca se initializeaza A(1, 1, 1)=U[1] in loc de 0, si apoi pentru fiecare i se verifica rezultatul curent cu max(A(i, B-(N-i), 0), A(i, B-(N-i), 1)) + suma U[i+2]...U[N]. Pentru a se incadara in limita de 0.3s trebuie acordata o mare grija la implementare, de exemplu, optimizand dinamica de mai sus de la 2*N memorie (ultimele doua linii din matricea A) la doar N pastrand doar ultima linie si parcurgand indicele j descrescator.\r\n\r\nReferences\r\n\r\nVisible links\r\n2. http://algoritmus.org/probleme/probleme_runda04.php\r\n3. http://acm.timus.ru/problem.aspx?space=1&num=1106\r\n4. http://acm.sgu.ru/problem.php?contest=0&problem=234\r\n5. http://acm.sgu.ru/problem.php?contest=0&problem=210\r\n6. http://acm.sgu.ru/problem.php?contest=0&problem=218\r\n7. http://online-judge.uva.es/p/v107/10735.html\r\n8. http://online-judge.uva.es/p/v108/10804.html\r\n9. http://online-judge.uva.es/board/viewtopic.php?t=7462\r\n\r\n',18,'public'),('djgpp-instalarea-de-la-a-la-z','DJGPP - instalarea de la A la Z','2006-11-17 20:01:26','h1. DJGPP - instalarea de la A la Z\r\n\r\n(Creat de \'_thestick_\':user/thestick la data de _2006-03-12_ categoria _Diverse_, autor(i) _Aursulesei Tudor_)\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nProbabil ca ai auzit de puternicul compilator Gnu C. Este acela folosit pe la mai toate competitiile mai mari de nationala (inclusiv). Avantaje:\r\n\r\n* lucreaza pe 32 de biti; asta inseamna ca programele compilate cu el vor merge mult mai repede!\r\n* stiva mai mare => erorile gen $stack overflow$ vor apare mult mai rar.\r\n* memorie mai mare => long @x[10000000]@ chiar exista\r\n* e cel mai tare; ce mai... @:)@\r\n\r\nAcest ghid este valabil pentru $Windows XP$.\r\nInainte sa purcedem, trebuie sa raspundem la cateva intrebari:\r\n\r\nh2.1. Ce este DJGPP?\r\n\r\nO colectie de programe de UNIX portate pentru DOS. Vizitati [1]http://delorie.com/djgpp pentru detalii. Cel mai important ,dupa ce veti instala corect DJGPP , veti putea scrie din linia de comanda in DOS comenzi gen \"gcc test.c *o test.exe\".\r\n\r\n2. Ce este RHIDE ?\r\n\r\nEste un IDE (Integrated Development Environment) pentru DJGPP. Deosebit de puternic si seamana cu Borland C 3.1 la culoare : ). Se impaca de minune cu GCC! Important ; NU vom folosi versiunea de RHIDE pe care ne-o ofera DJGPP , ci vom folosi una mai noua , dezvoltata de SET ( [2]http://setedit.sourceforge.net ). Are propriul lui editor , setedit , dar a dezvoltat si RHIDE , eliminand o parte din buguri.\r\n\r\nVersiunea lui se gaseste la [3]http://sourceforge.net/project/showfiles.php?group_id=32835 , sectiunea extra! Recomand sa o luati acum : pachetul RHIDE 1.5 + Ed 0.5.4 + gdb 6.1.1. Nu mai sta si downloadeaz-o!\r\n\r\nSa incepem\r\n\r\nAccesam linukul [4]http://www.delorie.com/djgpp/zip-picker.html si alegem optiunile (pe rand)\r\n\r\nBuild and run programs with DJGPP\r\n\r\nWindows 2000/XP\r\n\r\nYes\r\n\r\nC si C++\r\n\r\nLa Integrated Development Environments and Tools aveti grija sa nu fie selectat RHIDE ( dupa cum am zis si mai sus , vom folosi o alta versiune ).\r\n\r\nDe asemenea , alegem No la Optiunea \"Would you like GDB?\" Contiunam cu \"Tell me witch files I need\"\r\n\r\nAr trebui sa obtinem urmatoarea lista :\r\n\r\nunzip32.exe to unzip the zip files 95kb\r\n\r\n\r\n\r\nv2/copying.dj Copyright info 3kb\r\n\r\nv2/djdev203.zip Basic Development Kit 1.5mb\r\n\r\nv2/faq230b.zip F.A.Q. 664kb\r\n\r\nv2/readme.1st Installation instructions 22kb\r\n\r\n\r\n\r\nv2gnu/bnu2161b.zip Basic assembler, linker 3.3mb\r\n\r\nv2gnu/gcc401b.zip Basic GCC compiler 4.0mb\r\n\r\nv2gnu/gdb611b.zip GNU debugger 1.5mb\r\n\r\nv2gnu/gpp401b.zip C++ compiler 4.4mb\r\n\r\nv2gnu/mak3791b.zip Make (processes makefiles)267b\r\n\r\nv2gnu/txi48b.zip Info file viewer 779kb\r\n\r\nDownloadati-le!\r\n\r\nIncercati sa le puneti pe toate intr-un director gen c:/djgpp [de altfel , acesta il folosesc eu si vi-l recomand] . Deschideti o fereastra de Explorer si faceti drag-n-drop la fiecare arhiva peste executabilul unzip32.exe . Ar trebui sa va apara directoare gen /bin si /include. Sa nu uitam de versiunea de RHIDE pe care am mentionat-o mai sus. Despachetati-o si pe aceasta in acelasi mod!\r\n\r\nVom contiuna cu setarea variabilei de mediu DJGPP. [ foarte important]\r\n\r\nCilc dreapta pe My Computer -> Properties -> Advanced -> Environment Variables.\r\n\r\nEditati variabila PATH astfel incat aceasta sa arate si spre calea C:/DJGPP/BIN . De asemenea ,creeati o variabila noua numita DJGPP care sa \"pointeze\" catre C:/DJGPP/DJGPP.ENV.\r\n\r\nRecomand creerea unui fisier batch care sa lanseze RHIDE. Va prezint un exemplu:\r\n\r\n@echo off\r\nset PATH=c:/djgpp/bin;%PATH%\r\nset DJGPP=c:/djgpp/djgpp.env\r\nchdir c:/djgpp/lucru\r\nc:/djgpp/bin/rhide.exe\r\n\r\nRulati batchul. Ar trebui SA NU DATI de o eroare care zice ceva de variabila path pusa gresit sau de variabila DJGPP. Daca va apare cititi fisierul readme.1st [ deschideti-l cu Word , nu cu notepad] . Daca nu aveti nici o eroare , ar trebui sa fiti intampinati de o fereastra in care se zice ceva de Robert Hohne [RH din rhide] , Salvador Eduardo Tropea [ omul care a imbunatatit RHIDE]. Creeati un fisier nou in care sa bagati cateva linii de test\r\n\r\n#include <stdio.h>\r\nint main()\r\n{\r\nprintf(\"%d %d %d\",1,2,3);\r\n\r\nreturn 0;\r\n\r\n}\r\n\r\nCtrl+F9 ca sa compilati . Ctrl+F2 reset la program . Shift + F4 ruleaza pana la linia la care se afla cursorul. Shfit + F8 e Step Over fara sa se schimbe modul monitorului //fara flick la monitor . Shift+ F7 e Run Into fara sa se schimbe modul monitorului. Shift + F2 e GREP [utilitar deosebit de ..util]. Alt + F5 arata rezultatul rularii programului [ in versiunea de RHIDE de pe DJGPP , nu prea mergea aceasta functie]. Recomand optiunile: Din Options-> Environment-> Preferences\r\n\r\n-Screen Mode 80*50\r\n\r\n-Sxntax highlighing\r\n\r\nIar tot Din Options-> Environment -> Editor -> Editor Options\r\n\r\n-Autoindent\r\n-Use Tabs\r\n-Intelligent C indent\r\n-Match pair on the fly\r\n\r\n...Si altele , pe care va las sa le descoperiti singuri.\r\n\r\nAvertizare .Desi aceasta versiune de RHIDE este mai stabila decat cea de pe DJGPP ,este sansa sa se prabuseasca la Debugging ceva mai complex [crash :)] . Nimic nu este perfect. Eu am renuntat la orice alt IDE, deoarece RHIDE e cel mai bun. Daca o sa te deranjeze crashurile , ramai la Borland C. Nu este greu sa te inveti cu toate capriciile acestui program care te forteaza sa salvezi din 15 in 15 secunde,lucru benefic de alt fel. Dupa ce va obisnuiti, crashurile vor ramane o amintire neplacuta!\r\n\r\nAmintiti-va , totusi , sa salvati cat mai des si sa nu urmariti evoluia unor variabile prea mari gen x[10000000] :) . De asemenea nu incercati sa afisati pe ecran si sa vedeti ce rezultat a iesit cu Alt+F5. S-ar putea sa nu mearga. Daca aveti probleme MARI cu programul , stergeti\r\n\r\nrh_opt.gpr\r\nrh_opt.gdt\r\n\r\nAsta o sa il faca ca nou , in caz ca refuza sa porneasca sau e mai instabil decat era cand l-ati instalat.\r\n\r\nRecomand de asemenea sa explorati fiecare meniu si scurtatura a programului , deoarece eu v-am prezentat sumar aproximativ 30% din functii si 30% din optiunile lui optime de functionare! Insist sa verificati sistematic si metodic optiunile; Nu o sa regretati! De asemenea , poate lucra cu FPC [free pascal compiler] , insa va recomand IDE-ul din Free Pascal. Este o opera de arta pentru pascalisti!\r\n\r\nVa rog , totusi , inainte sa va plangeti de bugurile acestui program , sa folostiti si versiunea de RHIDE pe care v-o pune la dispotitie DJGPP. Acolo , de abia , gasiti buguri!\r\n~~~FIN~~~\r\nPOVESTITOR : Tudor Aursulesei\r\nMultumiri : DJ , RH si SET\r\n\r\nDaca ati avut timp si rabdare sa cititi pana aici , doresc sa imi cer scuze pentru felul defectuos in care [probabil] m-am exprimat.\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://delorie.com/djgpp\r\n2. http://setedit.sourceforge.net/\r\n3. http://sourceforge.net/project/showfiles.php?group_id=32835\r\n4. http://www.delorie.com/djgpp/zip-picker.html\r\n\r\n',18,'public'),('djgpp-instalarea-de-la-a-la-z','DJGPP - instalarea de la A la Z','2006-11-17 20:01:46','h1. DJGPP - instalarea de la A la Z\r\n\r\n(Creat de \'_thestick_\':user/thestick la data de _2006-03-12_ categoria _Diverse_, autor(i) _Aursulesei Tudor_)\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nProbabil ca ai auzit de puternicul compilator Gnu C. Este acela folosit pe la mai toate competitiile mai mari de nationala (inclusiv). Avantaje:\r\n\r\n* lucreaza pe 32 de biti; asta inseamna ca programele compilate cu el vor merge mult mai repede!\r\n* stiva mai mare => erorile gen $stack overflow$ vor apare mult mai rar.\r\n* memorie mai mare => long @x[10000000]@ chiar exista\r\n* e cel mai tare; ce mai... ${:)}$\r\n\r\nAcest ghid este valabil pentru $Windows XP$.\r\nInainte sa purcedem, trebuie sa raspundem la cateva intrebari:\r\n\r\nh2.1. Ce este DJGPP?\r\n\r\nO colectie de programe de UNIX portate pentru DOS. Vizitati [1]http://delorie.com/djgpp pentru detalii. Cel mai important ,dupa ce veti instala corect DJGPP , veti putea scrie din linia de comanda in DOS comenzi gen \"gcc test.c *o test.exe\".\r\n\r\n2. Ce este RHIDE ?\r\n\r\nEste un IDE (Integrated Development Environment) pentru DJGPP. Deosebit de puternic si seamana cu Borland C 3.1 la culoare : ). Se impaca de minune cu GCC! Important ; NU vom folosi versiunea de RHIDE pe care ne-o ofera DJGPP , ci vom folosi una mai noua , dezvoltata de SET ( [2]http://setedit.sourceforge.net ). Are propriul lui editor , setedit , dar a dezvoltat si RHIDE , eliminand o parte din buguri.\r\n\r\nVersiunea lui se gaseste la [3]http://sourceforge.net/project/showfiles.php?group_id=32835 , sectiunea extra! Recomand sa o luati acum : pachetul RHIDE 1.5 + Ed 0.5.4 + gdb 6.1.1. Nu mai sta si downloadeaz-o!\r\n\r\nSa incepem\r\n\r\nAccesam linukul [4]http://www.delorie.com/djgpp/zip-picker.html si alegem optiunile (pe rand)\r\n\r\nBuild and run programs with DJGPP\r\n\r\nWindows 2000/XP\r\n\r\nYes\r\n\r\nC si C++\r\n\r\nLa Integrated Development Environments and Tools aveti grija sa nu fie selectat RHIDE ( dupa cum am zis si mai sus , vom folosi o alta versiune ).\r\n\r\nDe asemenea , alegem No la Optiunea \"Would you like GDB?\" Contiunam cu \"Tell me witch files I need\"\r\n\r\nAr trebui sa obtinem urmatoarea lista :\r\n\r\nunzip32.exe to unzip the zip files 95kb\r\n\r\n\r\n\r\nv2/copying.dj Copyright info 3kb\r\n\r\nv2/djdev203.zip Basic Development Kit 1.5mb\r\n\r\nv2/faq230b.zip F.A.Q. 664kb\r\n\r\nv2/readme.1st Installation instructions 22kb\r\n\r\n\r\n\r\nv2gnu/bnu2161b.zip Basic assembler, linker 3.3mb\r\n\r\nv2gnu/gcc401b.zip Basic GCC compiler 4.0mb\r\n\r\nv2gnu/gdb611b.zip GNU debugger 1.5mb\r\n\r\nv2gnu/gpp401b.zip C++ compiler 4.4mb\r\n\r\nv2gnu/mak3791b.zip Make (processes makefiles)267b\r\n\r\nv2gnu/txi48b.zip Info file viewer 779kb\r\n\r\nDownloadati-le!\r\n\r\nIncercati sa le puneti pe toate intr-un director gen c:/djgpp [de altfel , acesta il folosesc eu si vi-l recomand] . Deschideti o fereastra de Explorer si faceti drag-n-drop la fiecare arhiva peste executabilul unzip32.exe . Ar trebui sa va apara directoare gen /bin si /include. Sa nu uitam de versiunea de RHIDE pe care am mentionat-o mai sus. Despachetati-o si pe aceasta in acelasi mod!\r\n\r\nVom contiuna cu setarea variabilei de mediu DJGPP. [ foarte important]\r\n\r\nCilc dreapta pe My Computer -> Properties -> Advanced -> Environment Variables.\r\n\r\nEditati variabila PATH astfel incat aceasta sa arate si spre calea C:/DJGPP/BIN . De asemenea ,creeati o variabila noua numita DJGPP care sa \"pointeze\" catre C:/DJGPP/DJGPP.ENV.\r\n\r\nRecomand creerea unui fisier batch care sa lanseze RHIDE. Va prezint un exemplu:\r\n\r\n@echo off\r\nset PATH=c:/djgpp/bin;%PATH%\r\nset DJGPP=c:/djgpp/djgpp.env\r\nchdir c:/djgpp/lucru\r\nc:/djgpp/bin/rhide.exe\r\n\r\nRulati batchul. Ar trebui SA NU DATI de o eroare care zice ceva de variabila path pusa gresit sau de variabila DJGPP. Daca va apare cititi fisierul readme.1st [ deschideti-l cu Word , nu cu notepad] . Daca nu aveti nici o eroare , ar trebui sa fiti intampinati de o fereastra in care se zice ceva de Robert Hohne [RH din rhide] , Salvador Eduardo Tropea [ omul care a imbunatatit RHIDE]. Creeati un fisier nou in care sa bagati cateva linii de test\r\n\r\n#include <stdio.h>\r\nint main()\r\n{\r\nprintf(\"%d %d %d\",1,2,3);\r\n\r\nreturn 0;\r\n\r\n}\r\n\r\nCtrl+F9 ca sa compilati . Ctrl+F2 reset la program . Shift + F4 ruleaza pana la linia la care se afla cursorul. Shfit + F8 e Step Over fara sa se schimbe modul monitorului //fara flick la monitor . Shift+ F7 e Run Into fara sa se schimbe modul monitorului. Shift + F2 e GREP [utilitar deosebit de ..util]. Alt + F5 arata rezultatul rularii programului [ in versiunea de RHIDE de pe DJGPP , nu prea mergea aceasta functie]. Recomand optiunile: Din Options-> Environment-> Preferences\r\n\r\n-Screen Mode 80*50\r\n\r\n-Sxntax highlighing\r\n\r\nIar tot Din Options-> Environment -> Editor -> Editor Options\r\n\r\n-Autoindent\r\n-Use Tabs\r\n-Intelligent C indent\r\n-Match pair on the fly\r\n\r\n...Si altele , pe care va las sa le descoperiti singuri.\r\n\r\nAvertizare .Desi aceasta versiune de RHIDE este mai stabila decat cea de pe DJGPP ,este sansa sa se prabuseasca la Debugging ceva mai complex [crash :)] . Nimic nu este perfect. Eu am renuntat la orice alt IDE, deoarece RHIDE e cel mai bun. Daca o sa te deranjeze crashurile , ramai la Borland C. Nu este greu sa te inveti cu toate capriciile acestui program care te forteaza sa salvezi din 15 in 15 secunde,lucru benefic de alt fel. Dupa ce va obisnuiti, crashurile vor ramane o amintire neplacuta!\r\n\r\nAmintiti-va , totusi , sa salvati cat mai des si sa nu urmariti evoluia unor variabile prea mari gen x[10000000] :) . De asemenea nu incercati sa afisati pe ecran si sa vedeti ce rezultat a iesit cu Alt+F5. S-ar putea sa nu mearga. Daca aveti probleme MARI cu programul , stergeti\r\n\r\nrh_opt.gpr\r\nrh_opt.gdt\r\n\r\nAsta o sa il faca ca nou , in caz ca refuza sa porneasca sau e mai instabil decat era cand l-ati instalat.\r\n\r\nRecomand de asemenea sa explorati fiecare meniu si scurtatura a programului , deoarece eu v-am prezentat sumar aproximativ 30% din functii si 30% din optiunile lui optime de functionare! Insist sa verificati sistematic si metodic optiunile; Nu o sa regretati! De asemenea , poate lucra cu FPC [free pascal compiler] , insa va recomand IDE-ul din Free Pascal. Este o opera de arta pentru pascalisti!\r\n\r\nVa rog , totusi , inainte sa va plangeti de bugurile acestui program , sa folostiti si versiunea de RHIDE pe care v-o pune la dispotitie DJGPP. Acolo , de abia , gasiti buguri!\r\n~~~FIN~~~\r\nPOVESTITOR : Tudor Aursulesei\r\nMultumiri : DJ , RH si SET\r\n\r\nDaca ati avut timp si rabdare sa cititi pana aici , doresc sa imi cer scuze pentru felul defectuos in care [probabil] m-am exprimat.\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://delorie.com/djgpp\r\n2. http://setedit.sourceforge.net/\r\n3. http://sourceforge.net/project/showfiles.php?group_id=32835\r\n4. http://www.delorie.com/djgpp/zip-picker.html\r\n\r\n',18,'public'),('djgpp-instalarea-de-la-a-la-z','DJGPP - instalarea de la A la Z','2006-11-17 20:02:11','h1. DJGPP - instalarea de la A la Z\r\n\r\n(Creat de \'_thestick_\':user/thestick la data de _2006-03-12_ categoria _Diverse_, autor(i) _Aursulesei Tudor_)\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nProbabil ca ai auzit de puternicul compilator Gnu C. Este acela folosit pe la mai toate competitiile mai mari de nationala (inclusiv). Avantaje:\r\n\r\n* lucreaza pe 32 de biti; asta inseamna ca programele compilate cu el vor merge mult mai repede!\r\n* stiva mai mare => erorile gen $stack overflow$ vor apare mult mai rar.\r\n* memorie mai mare => long @x[10000000]@ chiar exista\r\n* e cel mai tare; ce mai... ${:)}$\r\n\r\nAcest ghid este valabil pentru $Windows XP$.\r\nInainte sa purcedem, trebuie sa raspundem la cateva intrebari:\r\n\r\nh2. 1. Ce este DJGPP?\r\n\r\nO colectie de programe de UNIX portate pentru DOS. Vizitati [1]http://delorie.com/djgpp pentru detalii. Cel mai important ,dupa ce veti instala corect DJGPP , veti putea scrie din linia de comanda in DOS comenzi gen \"gcc test.c *o test.exe\".\r\n\r\n2. Ce este RHIDE ?\r\n\r\nEste un IDE (Integrated Development Environment) pentru DJGPP. Deosebit de puternic si seamana cu Borland C 3.1 la culoare : ). Se impaca de minune cu GCC! Important ; NU vom folosi versiunea de RHIDE pe care ne-o ofera DJGPP , ci vom folosi una mai noua , dezvoltata de SET ( [2]http://setedit.sourceforge.net ). Are propriul lui editor , setedit , dar a dezvoltat si RHIDE , eliminand o parte din buguri.\r\n\r\nVersiunea lui se gaseste la [3]http://sourceforge.net/project/showfiles.php?group_id=32835 , sectiunea extra! Recomand sa o luati acum : pachetul RHIDE 1.5 + Ed 0.5.4 + gdb 6.1.1. Nu mai sta si downloadeaz-o!\r\n\r\nSa incepem\r\n\r\nAccesam linukul [4]http://www.delorie.com/djgpp/zip-picker.html si alegem optiunile (pe rand)\r\n\r\nBuild and run programs with DJGPP\r\n\r\nWindows 2000/XP\r\n\r\nYes\r\n\r\nC si C++\r\n\r\nLa Integrated Development Environments and Tools aveti grija sa nu fie selectat RHIDE ( dupa cum am zis si mai sus , vom folosi o alta versiune ).\r\n\r\nDe asemenea , alegem No la Optiunea \"Would you like GDB?\" Contiunam cu \"Tell me witch files I need\"\r\n\r\nAr trebui sa obtinem urmatoarea lista :\r\n\r\nunzip32.exe to unzip the zip files 95kb\r\n\r\n\r\n\r\nv2/copying.dj Copyright info 3kb\r\n\r\nv2/djdev203.zip Basic Development Kit 1.5mb\r\n\r\nv2/faq230b.zip F.A.Q. 664kb\r\n\r\nv2/readme.1st Installation instructions 22kb\r\n\r\n\r\n\r\nv2gnu/bnu2161b.zip Basic assembler, linker 3.3mb\r\n\r\nv2gnu/gcc401b.zip Basic GCC compiler 4.0mb\r\n\r\nv2gnu/gdb611b.zip GNU debugger 1.5mb\r\n\r\nv2gnu/gpp401b.zip C++ compiler 4.4mb\r\n\r\nv2gnu/mak3791b.zip Make (processes makefiles)267b\r\n\r\nv2gnu/txi48b.zip Info file viewer 779kb\r\n\r\nDownloadati-le!\r\n\r\nIncercati sa le puneti pe toate intr-un director gen c:/djgpp [de altfel , acesta il folosesc eu si vi-l recomand] . Deschideti o fereastra de Explorer si faceti drag-n-drop la fiecare arhiva peste executabilul unzip32.exe . Ar trebui sa va apara directoare gen /bin si /include. Sa nu uitam de versiunea de RHIDE pe care am mentionat-o mai sus. Despachetati-o si pe aceasta in acelasi mod!\r\n\r\nVom contiuna cu setarea variabilei de mediu DJGPP. [ foarte important]\r\n\r\nCilc dreapta pe My Computer -> Properties -> Advanced -> Environment Variables.\r\n\r\nEditati variabila PATH astfel incat aceasta sa arate si spre calea C:/DJGPP/BIN . De asemenea ,creeati o variabila noua numita DJGPP care sa \"pointeze\" catre C:/DJGPP/DJGPP.ENV.\r\n\r\nRecomand creerea unui fisier batch care sa lanseze RHIDE. Va prezint un exemplu:\r\n\r\n@echo off\r\nset PATH=c:/djgpp/bin;%PATH%\r\nset DJGPP=c:/djgpp/djgpp.env\r\nchdir c:/djgpp/lucru\r\nc:/djgpp/bin/rhide.exe\r\n\r\nRulati batchul. Ar trebui SA NU DATI de o eroare care zice ceva de variabila path pusa gresit sau de variabila DJGPP. Daca va apare cititi fisierul readme.1st [ deschideti-l cu Word , nu cu notepad] . Daca nu aveti nici o eroare , ar trebui sa fiti intampinati de o fereastra in care se zice ceva de Robert Hohne [RH din rhide] , Salvador Eduardo Tropea [ omul care a imbunatatit RHIDE]. Creeati un fisier nou in care sa bagati cateva linii de test\r\n\r\n#include <stdio.h>\r\nint main()\r\n{\r\nprintf(\"%d %d %d\",1,2,3);\r\n\r\nreturn 0;\r\n\r\n}\r\n\r\nCtrl+F9 ca sa compilati . Ctrl+F2 reset la program . Shift + F4 ruleaza pana la linia la care se afla cursorul. Shfit + F8 e Step Over fara sa se schimbe modul monitorului //fara flick la monitor . Shift+ F7 e Run Into fara sa se schimbe modul monitorului. Shift + F2 e GREP [utilitar deosebit de ..util]. Alt + F5 arata rezultatul rularii programului [ in versiunea de RHIDE de pe DJGPP , nu prea mergea aceasta functie]. Recomand optiunile: Din Options-> Environment-> Preferences\r\n\r\n-Screen Mode 80*50\r\n\r\n-Sxntax highlighing\r\n\r\nIar tot Din Options-> Environment -> Editor -> Editor Options\r\n\r\n-Autoindent\r\n-Use Tabs\r\n-Intelligent C indent\r\n-Match pair on the fly\r\n\r\n...Si altele , pe care va las sa le descoperiti singuri.\r\n\r\nAvertizare .Desi aceasta versiune de RHIDE este mai stabila decat cea de pe DJGPP ,este sansa sa se prabuseasca la Debugging ceva mai complex [crash :)] . Nimic nu este perfect. Eu am renuntat la orice alt IDE, deoarece RHIDE e cel mai bun. Daca o sa te deranjeze crashurile , ramai la Borland C. Nu este greu sa te inveti cu toate capriciile acestui program care te forteaza sa salvezi din 15 in 15 secunde,lucru benefic de alt fel. Dupa ce va obisnuiti, crashurile vor ramane o amintire neplacuta!\r\n\r\nAmintiti-va , totusi , sa salvati cat mai des si sa nu urmariti evoluia unor variabile prea mari gen x[10000000] :) . De asemenea nu incercati sa afisati pe ecran si sa vedeti ce rezultat a iesit cu Alt+F5. S-ar putea sa nu mearga. Daca aveti probleme MARI cu programul , stergeti\r\n\r\nrh_opt.gpr\r\nrh_opt.gdt\r\n\r\nAsta o sa il faca ca nou , in caz ca refuza sa porneasca sau e mai instabil decat era cand l-ati instalat.\r\n\r\nRecomand de asemenea sa explorati fiecare meniu si scurtatura a programului , deoarece eu v-am prezentat sumar aproximativ 30% din functii si 30% din optiunile lui optime de functionare! Insist sa verificati sistematic si metodic optiunile; Nu o sa regretati! De asemenea , poate lucra cu FPC [free pascal compiler] , insa va recomand IDE-ul din Free Pascal. Este o opera de arta pentru pascalisti!\r\n\r\nVa rog , totusi , inainte sa va plangeti de bugurile acestui program , sa folostiti si versiunea de RHIDE pe care v-o pune la dispotitie DJGPP. Acolo , de abia , gasiti buguri!\r\n~~~FIN~~~\r\nPOVESTITOR : Tudor Aursulesei\r\nMultumiri : DJ , RH si SET\r\n\r\nDaca ati avut timp si rabdare sa cititi pana aici , doresc sa imi cer scuze pentru felul defectuos in care [probabil] m-am exprimat.\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://delorie.com/djgpp\r\n2. http://setedit.sourceforge.net/\r\n3. http://sourceforge.net/project/showfiles.php?group_id=32835\r\n4. http://www.delorie.com/djgpp/zip-picker.html\r\n\r\n',18,'public'),('djgpp-instalarea-de-la-a-la-z','DJGPP - instalarea de la A la Z','2006-11-17 20:31:37','h1. DJGPP - instalarea de la A la Z\r\n\r\n(Creat de ==user(user=\"TheStick\" type=\"tiny\")== la data de _2006-03-12_ categoria _Diverse_, autor(i) _Aursulesei Tudor_)\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nProbabil ca ai auzit de puternicul compilator $Gnu C$. Este acela folosit pe la mai toate competitiile mai mari de nationala (inclusiv). Avantaje:\r\n\r\n* lucreaza pe 32 de biti; asta inseamna ca programele compilate cu el vor merge mult mai repede!\r\n* stiva mai mare &#8658; erorile gen $stack overflow$ vor apare mult mai rar.\r\n* memorie mai mare &#8658; @long x[10000000]@ chiar exista\r\n* e cel mai tare; ce mai... ${:)}$\r\n\r\nAcest ghid este valabil pentru $Windows XP$.\r\nInainte sa purcedem, trebuie sa raspundem la cateva intrebari:\r\n\r\nh2. Ce este DJGPP?\r\n\r\nO colectie de programe de $UNIX$ portate pentru $DOS$. Vizitati \"http://delorie.com/djgpp\":http://delorie.com/djgpp pentru detalii. Cel mai important, dupa ce veti instala corect $DJGPP$, veti putea scrie din linia de comanda in $DOS$ comenzi gen $gcc test.c *o test.exe$.\r\n\r\nh2. Ce este RHIDE?\r\n\r\nEste un $IDE (Integrated Development Environment)$ pentru $DJGPP$. Deosebit de puternic si seamana cu $Borland C 3.1$ la culoare ${:)}$. Se impaca de minune cu $GCC$! Important; ${NU}$ vom folosi versiunea de ${RHIDE}$ pe care ne-o ofera ${DJGPP}$, ci vom folosi una mai noua, dezvoltata de \"SET\":http://setedit.sourceforge.net. Are propriul lui editor, $Setedit$, dar a dezvoltat si $RHIDE$, eliminand o parte din buguri.\r\n\r\nVersiunea lui se gaseste la \"http://sourceforge.net/project/showfiles.php?group_id=32835\":http://sourceforge.net/project/showfiles.php?group_id=32835 , sectiunea extra! Recomand sa o luati acum: $pachetul RHIDE 1.5 + Ed 0.5.4 + gdb 6.1.1$ Nu mai sta si downloadeaz-o!\r\n\r\nh2. Sa incepem\r\n\r\nAccesam link-ul \"http://www.delorie.com/djgpp/zip-picker.html\":http://www.delorie.com/djgpp/zip-picker.html si alegem optiunile (pe rand)\r\n\r\n* Build and run programs with DJGPP\r\n* Windows 2000/XP\r\n* Yes\r\n* C si C++\r\n\r\nLa $Integrated Development Environments and Tools$ aveti grija sa nu fie selectat $RHIDE$ (dupa cum am zis si mai sus, vom folosi o alta versiune).\r\n\r\nDe asemenea, alegem $No$ la Optiunea $Would you like GDB?$ Contiunam cu $Tell me which files I need$\r\n\r\nAr trebui sa obtinem urmatoarea lista:\r\n\r\n* unzip32.exe to unzip the zip files 95kb\r\n* v2/copying.dj Copyright info 3kb\r\n* v2/djdev203.zip Basic Development Kit 1.5mb\r\n* v2/faq230b.zip F.A.Q. 664kb\r\n* v2/readme.1st Installation instructions 22kb\r\n* v2gnu/bnu2161b.zip Basic assembler, linker 3.3mb\r\n* v2gnu/gcc401b.zip Basic GCC compiler 4.0mb\r\n* v2gnu/gdb611b.zip GNU debugger 1.5mb\r\n* v2gnu/gpp401b.zip C++ compiler 4.4mb\r\n* v2gnu/mak3791b.zip Make (processes makefiles)267b\r\n* v2gnu/txi48b.zip Info file viewer 779kb\r\n\r\nDownloadati-le!\r\n\r\nIncercati sa le puneti pe toate intr-un director gen $c:\\djgpp\\$ (de altfel, pe acesta il folosesc eu si vi-l recomand). Deschideti o fereastra de $Explorer$ si faceti drag-n-drop la fiecare arhiva peste executabilul $unzip32.exe$. Ar trebui sa va apara directoare gen $bin$ si $include$. Sa nu uitam de versiunea de $RHIDE$ pe care am mentionat-o mai sus. Despachetati-o si pe aceasta in acelasi mod!\r\n\r\nVom contiuna cu setarea variabilei de mediu $DJGPP$. (foarte important)\r\nClick dreapta pe $My Computer &#8594; Properties &#8594; Advanced &#8594; Environment Variables$.\r\nEditati variabila $PATH$ astfel incat aceasta sa arate si spre calea $C:\\DJGPP\\BIN$. De asemenea, creeati o variabila noua numita $DJGPP$ care sa \"pointeze\" catre $C:\\DJGPP\\DJGPP.ENV$.\r\n\r\nRecomand creerea unui fisier batch care sa lanseze $RHIDE$. Va prezint un exemplu:\r\n\r\n== code(c) |@echo off\r\nset PATH=c:/djgpp/bin;%PATH%\r\nset DJGPP=c:/djgpp/djgpp.env\r\nchdir c:/djgpp/lucru\r\nc:/djgpp/bin/rhide.exe\r\n==\r\n\r\nRulati batch-ul. Ar trebui $sa nu dati$ de o eroare care zice ceva de variabila $PATH$ pusa gresit sau de variabila $DJGPP$. Daca va apare, cititi fisierul $readme.1st$ (deschideti-l cu $Word$, nu cu $Notepad$) . Daca nu aveti nici o eroare, ar trebui sa fiti intampinati de o fereastra in care se zice ceva de $Robert Hohne (RH din RHIDE) si Salvador Eduardo Tropea (omul care a imbunatatit RHIDE)$. Creeati un fisier nou in care sa bagati cateva linii de test.\r\n\r\n== code(c) |#include <stdio.h>\r\nint main()\r\n{\r\n    printf(\"%d %d %d\" , 1, 2, 3);\r\n    return 0;\r\n}\r\n==\r\n\r\n$Ctrl+F9$ ca sa compilati. $Ctrl+F2$ reset la program. $Shift + F4 $ruleaza pana la linia la care se afla cursorul. $Shift+F8$ e $Step Over$ fara sa se schimbe modul monitorului (fara flick la monitor). $Shift+F7$ e $Run Into$ fara sa se schimbe modul monitorului. $Shift+F2$ e $GREP$ (utilitar deosebit de util). $Alt + F5$ arata rezultatul rularii programului (in versiunea de $RHIDE$ de pe $DJGPP$, nu prea mergea aceasta functie). Recomand optiunile din $Options &#8594; Environment &#8594; Preferences$.\r\n\r\n* Screen Mode 80 x 50\r\n* Syntax highlighting\r\n\r\nIar tot din $Options &#8594; Environment &#8594; Editor &#8594; Editor Options$\r\n\r\n* Autoindent\r\n* Use Tabs\r\n* Intelligent C indent\r\n* Match pair on the fly\r\n\r\n...Si altele , pe care va las sa le descoperiti singuri.\r\n\r\nAvertizare. Desi aceasta versiune de $RHIDE$ este mai stabila decat cea de pe $DJGPP$, este sansa sa se prabuseasca la $Debugging$ ceva mai complex (crash ${:)}$). Nimic nu este perfect. Eu am renuntat la orice alt $IDE$, deoarece $RHIDE$ e cel mai bun. Daca o sa te deranjeze crash-urile, ramai la $Borland C$. Nu este greu sa te inveti cu toate capriciile acestui program care te forteaza sa salvezi din 15 in 15 secunde, lucru benefic de alt fel. Dupa ce va obisnuiti, crash-urile vor ramane o amintire neplacuta!\r\n\r\nAmintiti-va totusi sa salvati cat mai des si sa nu urmariti evolutia unor variabile prea mari gen @x[10000000]@ ${:)}$. De asemenea nu incercati sa afisati pe ecran si sa vedeti ce rezultat a iesit cu $Alt+F5$. S-ar putea sa nu mearga. Daca aveti probleme $MARI$ cu programul, stergeti\r\n\r\n* rh_opt.gpr\r\n* rh_opt.gdt\r\n\r\nAsta o sa il faca ca nou, in caz ca refuza sa porneasca sau e mai instabil decat era cand l-ati instalat.\r\n\r\nRecomand de asemenea sa explorati fiecare meniu si scurtatura a programului, deoarece eu v-am prezentat sumar aproximativ $30%$ din functii si $30%$ din optiunile lui optime de functionare! Insist sa verificati sistematic si metodic optiunile; Nu o sa regretati! De asemenea, poate lucra cu $FPC (Free Pascal Compiler)$ , insa va recomand $IDE$-ul din $Free Pascal$. Este o opera de arta pentru pascalisti!\r\n\r\nVa rog totusi, inainte sa va plangeti de bugurile acestui program, sa folostiti si versiunea de $RHIDE$ pe care v-o pune la dispozitie $DJGPP$. Acolo, de abia, gasiti bug-uri!\r\n\r\nh2. ~~~FIN~~~\r\n\r\nh3. POVESTITOR: Tudor Aursulesei\r\nMultumiri: DJ, RH si SET\r\n\r\nDaca ati avut timp si rabdare sa cititi pana aici, doresc sa imi cer scuze pentru felul defectuos in care (probabil) m-am exprimat.\r\n\r\n',18,'public'),('usaco-dec-2004-divizia-gold','USACO decembrie 2004, divizia GOLD - idei de solutii','2006-11-17 23:31:30','h1. USACO decembrie 2004, divizia GOLD - idei de solutii\r\n\r\n(Creat de ==user(user=\"silviug\" type=\"tiny\")== la data de _2004-12-18_ categoria _Competitii_, autor(i) _Silviu Ganceanu_)\r\n\r\n\"Setul de probleme\": pe marginea caruia voi discuta in urmatoarele randuri se afla disponibil in sectiunea download impreuna cu datele de test si rezultatele finale ale concursului (cei care nu stiu setul de probleme si vor sa citeasca articolul sunt rugati sa parcurga mai intai textele problemelor).\r\n\r\nVoi incepe prin cateva observatii in legatura cu evolutia concurentilor din Romania in acest concurs. Asadar un clasament (neoficial) alcatuit intre acestia ar arata in urmatorul mod:\r\n\r\n# Vladu Adrian 783 puncte\r\n# Stancu-Mara Sorin 782 puncte\r\n# Andrei-Marius Teodorescu 710 puncte\r\n# Fechete Dan Ionut 490 puncte\r\n# Pasaila Daniel 436 puncte\r\n# Paul Diac 406 puncte\r\n\r\nRestul concurentilor au avut punctaje sub $400$ de puncte. Primii doi din clasamentul \"nostru\" au reusit sa se strecoare intre primele $20$ de locuri din clasamentul final dar, din nou, remarc lipsa unui roman in topul celor mai buni. Sper mai multe de la concursurile viitore! Mai vreau sa precizez ca Romania nu a dispus de tot arsenalul avut in dotare si concurenti cu rezultate in competiile internationale anterioare precum Dan Crestez si Dan Spatarel nu au fost prezenti in concurs (cel putin nu cu numele lor!). Ei sunt rugati sa participe in viitoarele concursuri (sau sa renunte la pseudonime - daca e cazul), spre binele lor si spre prestigiul Romaniei!\r\n\r\nSetul de probleme a fost unul dificil dar deosebit de frumos, necesitand cunostinte avansate de programare dinamica, structuri de date si teoria grafurilor. Totusi, pentru un concurent experimentat, problemele nu erau in totalitate noi. Spun asta pentru ca toate problemele aveau in substrat idei deja folosite in alte concursuri (CEOI, IOI si chiar barajele noastre).\r\n\r\nLasand comentariile deoparte sa trecem la ce ne intereseaza cel mai mult: solutiile.\r\n\r\nh2. Divide\r\n\r\nProblema se rezolva prin programare dinamica. Prima idee, destul de intuitiva de altfel, este o solutie de complexitate {$O(L * B)$}. Sa notam cu $BST{~l~}$ = numar minim de stropitori de care avem nevoie pentru a acoperi complet intervalul [{$0, l$}] cu $l$ par. Avem urmatoarea recurenta:\r\n\r\n* $BST{~l~}$ = $INFINIT$ daca $l$ este inclus intr-un interval al unei vaci\r\n* $BST{~l~}$ = {$minim(BST{~l - 2 * x~}) + 1$}, cu $x$ intre $A$ si $B$ astfel incat $2 * x$ este mai mic sau egal cu $l$\r\n\r\nPrintr-o implementare directa a recurentei de mai sus obtinem o solutie care foloseste $O(L)$ memorie si $O(L * B)$ operatii (cu observatia ca spatiul de memorie se poate reduce la {$O(B)$}).\r\n\r\nPentru a reduce complexitatea la $O(L)$ operatii se utilizeaza o coada care pastreaza valorile $BST{~x~}$ cu $x$ in intervalul [{$i - 2*B, i - 2*A$}] sortate crescator. Se observa cum se modifica coada cand se trece de la pozitia $i$ la pozitia $i + 2$ (practic \"intra\" valoarea $BST{~i + 2 - 2*A~}$ si \"iese\" valoarea {$BST{~i - 2*B~}$}. Nu voi intra in detalii despre modul cum lucreaza aceasta coada. Pe aceeasi idee (utilizarea acestei cozi) se rezolva si problema \"secventa\":http://www.infoarena.ro/task/secventa (preOJI 2004 - infoarena) si \"trans\":http://www.infoarena.ro/task/trans (prima proba a selectiei lotului national largit, Buzau 2004).\r\n\r\nh2. Obstacle\r\n\r\nSi aceasta problema se rezolva tot programare dinamica. Asadar avem $BST{~i, 0~}$ = distanta minima parcursa pentru a ajunge la capatul din stanga al gardului numarul $i$ si $BST{~i, 1~}$ = distanta minima parcursa pentru a ajunge la capatul din dreapta al gardului numarul {$i$}. De asemenea notam cu $Cap{~i, 0~}$ = pozitia capatului din stanga al gardului $i$ in sistemul de coordonte si $Cap{~i, 1~}$ = analog pentru capatul din dreapta. Avem urmatoarele recurenta:\r\n\r\n* $BST{~i, j~}$ = $minim(BST{~k, l~} + dst(Cap{~k, l~}, Cap{~i, j~})$ cu $k$ de la $i + 1$ la {$N$}, $l$ si $j$ fiind $0$ sau $1$ si cu proprietatea ca drumul pe Oy dintre $Cap{~k, l~} la gardul $i$ nu se interpune nici un alt gard.\r\n\r\nAceasta recurenta implementata direct ne da o solutie $O(N^2^)$ care, putin optimizata, ar fi putut obtine punctajul maxim. Totusi exista o solutie $O(N log N)$ care utilizeaza o structura de date numita arbori de intervale. Practic noi trebuie sa aflam pentru fiecare gard $i$ care este gardul pe care cade o bila lasata libera din capatul din stanga si din capatul din dreapta. Aceste informatii ne permit reducerea complexitatii recurentei de mai sus la $O(N)$ (nu va mai spun cum, ganditi si voi!). Pentru a afla informatiile despre care vorbeam se parcurg cele $N$ garduri de la $1$ la $N$ (in ordinea asta!) si se proiecteaza, pe rand, pe axa Ox. Practic se pastreaza axa Ox ca un interval [{$-200.000, 200.000$}] si, pentru un gard {$i$}, se egaleaza toate pozitiile din intervalul [{$Cap{~i, 0~}, Cap{~i, 1~}$}] cu {$i$}. Pentru un afla gardul pe care cade bila se interogheaza arborele pentru fiecare capat al gardului {$i$}. Explicatiile mele nu dezvaluie modul in care lucreaza acest arbore de intervale (mi-ar lua cateva zeci de randuri bune\r\ndaca as intra in detalii). Pentru cei care nu au idee cum functioneaza acest \"monstru informatic\" le recomand citirea \"articolului\":http://info.devnet.ro/download.php?page=cat&cat=24 scris pe tema aceasta din sectiunea \"Download\":http://www.infoarena.ro/Downloads.\r\n\r\nh2. Skiarea\r\n\r\nProblema se poate rezolva utilizand cunostinte de teoria grafurilor. Mai intai se contruiesc componentele conexe ale fiecarei celule printr-un algoritm de tipul FLOOD FILL. Prin componenta conexa intelegem set de celule din matrice cu aceeasi valoarea si care indeplineste propietatea ca intre oricare doua celule exista drum (dupa regulile din enunt). Odata aflate aceste componente conexe se construieste un graf asociat lor in urmatorul mod:\r\n\r\n* fiecare componenta conexa are asociat un nod\r\n* intre doua noduri x si y exista drum daca componenta conexa asociata lui x este \"vecina\" cu componenta conexa a lui y (este usor de intuit ce inseamna \"vecina\") si daca valoarea celulelor din x este mai mare decat valoarea celulelor din y.\r\n\r\nGraful astfel construit este aciclic (acesta se demostreaza usor). In acest graf aflam nodurile in care nu intra nici o muchie - noduri \"sursa\" - (fie numarul lor P) si toate nodurile din care nu iese nici o muchie - noduri \"destinatie\" - (fie numarul lor Q). Solutia pentru problema noastra va fi:\r\n\r\n* maxim dintre P si Q, daca graful are doua sau mai multe noduri\r\n* 0, daca graful are un singur nod.\r\n\r\nToate cele trei etape (FLOOD FILL-ul, construirea grafului, aflarea nodurilor \"sursa\" si \"destinatie\") se pot realiza in O(N*M) operatii utilizand O(N*M) spatiu de memorie. Mare atentie insa: nici unul dintre pasi nu trebuie realizat recursiv!! (pentru ca altfel se iese din segmentul de stiva pe testele mari).\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://info.devnet.ro/download.php?page=cat&cat=30\r\n2. http://info.devnet.ro/download.php?page=cat&cat=24\r\n\r\n',961,'public'),('doua-probleme-de-la-runda-6-a-concursului-algoritmus','Doua probleme de la runda 6 a concursului Algoritmus','2006-11-17 23:42:39','h1. Doua probleme de la runda 6 a concursului Algoritmus\r\n\r\n(Creat de ==user(user=\"Cosmin\" type=\"tiny\")== la data de _2005-01-13_ categoria _Competitii_, autor(i) _Cosmin_)\r\n\r\nDupa incheierea brusca a concursului Algoritmus, ideile de rezolvare ale rundei 6 nu au mai aparut pe site. In acest articol va voi prezenta ideile de rezolvare la problemele la care eu am realizat solutiile oficiale.\r\n\r\nh2. Problema 1: Suprafata\r\n\r\nPentru a rezolva problema folosim paradigma liniei de baleiere folosita mult in rezolvarea problemelor de geometrie computationala (vezi si articolul arbori de intervale din sectiunea download pt alte exemple de probleme in care se foloseste linia de baleiere). Vom considera ca puncte eveniment toate punctele de intersectie intre oricare doua cercuri si punctele de $y maxim$ si de $y minim$ pentru un cerc. Noi avem nevoie numai de coordonata $y$ a acestor puncte pe care o punem intr-un sir. Sortam acest sir ce are maxim $n*(n-1) + 2*n$ coordonate distincte ( $n*(n-1)$ provin din intersectii a cate doua cercuri iar celelalte $2*n$ din $y maxim$ si $y minim$ pentru fiecare cerc). Intre doua coordonate $Y$ consecutive din vectorul sortat nu exista nici o intersectie intre cercuri. Intersectia unui cerc cu o banda determinata de $Y{~i~}$ si $Y{~i+1~}$ este un fel de trapez curbat pe care ni-l putem imagina ca o paranteza deschisa si una inchisa. Pentru a determina aria intersectiei multimii de cercuri cu banda determinata de $Y{~i~}$\r\nsi $Y{~i+1~}$ putem sa facem un algoritm care sorteaza intai \"parantezele\" si dupa aceea parcurge sirul sortat al parantezelor. Cand nivelul de imbricare e $0$ inseamna ca tocmai am iesit din cercuri iar nivel de imbricare mai mare ca $0$ inseamna ca suntem in interiorul intersectiei. De aici scoatem un algoritm liniar care ne determina intersectia cercurilor cu aceasta banda. Pentru a determina aria ocupata de un trapez curbat trebuie sa putem determina aria dintre coarda si arcul de cerc corespunzator, aceasta arie se poate gasi daca stim unghiul $alfa$ ce se opune coardei pentru ca aceasta arie e diferenta dintre aria sectorului de cerc ( {$r*r*alpha/2$}) si aria triunghiului format dintre centrul cercului si coarda ({$r*r*sin alpha /2$}), unghiul $alpha$ il aflam folosind functia $arccos$ si $cos alpha$ il determinam cu ajutorul teoremei lui Pitagora generalizate. O mica problema apare in sortarea parantezelor pentru ca daca parantezele provin din cercuri diferite dar le corespunde aceeiasi coarda atunci trebuie sa fim atenti la ordinea in care punem parantezele. Aceasta problema e rezolvata daca gasim un $X3$ pentru fiecare coarda numar ce reprezinta coordonata $X$ a intersectiei parantezei repsective cu linia orizontala de ordonata {$(Y{~i~} + Y{~i+1~}) / 2$}. Am aratat astfel cum se realizeaza determinarea ariei reuniunii cercurilor cu o banda ce nu contine nici o intersectie in {$O(n log n)$}. Din cauza faptului ca sunt in total maxim $O(n^2^)$ benzi repetand algoritmul pe fiecare banda obtinem aria reuniunii\r\ncercurilor in timp {$O(n^3^ log n)$}.\r\n\r\nh2. Problema 4: Joc\r\n\r\nProblema cere determinarea numarului maxim de drumuri disjuncte relativ la noduri pornind de la nodul A si terminandu-se in nodul B. Daca ar fi restrictia numai pentru muchii nu si pentru noduri atunci raspunsul ar fi egal cu fluxul maxim in reteaua de transport formata astfel: sursa e nodul A, destinatia e nodul B iar orice muchie (i,j) din graful initial e dublata in reteaua de transport (i,j) si (j,i) fiecare muchie avand capacitate 1. Acesta afirmatie e intiutiva, o demonstratie matematica a ei ar fi aplicarea teoremei clasice : fluxul maxim intr-o retea reziduala este egala cu taietura minima in acea retea si a teoremei lui Menger: numarul maxim de drumuri disjuncte relativ la muchii de la S la T este egal cu taietura minima. Problema noastra mai are insa o dificultate, aceea ca trebuie sa nu avem acelasi nod in doua drumuri diferite. Aceasta problema o rezolvam dubland fiecare nod si muchiile ce intrau in nod intra acum in primul dintre cele 2 noduri, muchiile ce ieseau ies acum din al doilea nod\r\nsi mai adaugam o muchie intre primul nod si al doilea nod. Acum drumurile disjuncte relativ la muchii din aceasta retea corespund unor drumuri disjuncte relativ la noduri in prima retea.\r\nAstfel am redus problema initiala la una de flux in graf pe graful transformat. Complexitatea algoritmului e O(n*m).\r\nImplementarea nu mai dubleaza nodurile la propriu ci foloseste c[i][i] pentru a reprezenta muchia intre cele doua noduri ce reprezinta nodul i din graful initial.\r\n\r\n',961,'public'),('preoni-2005/runda-1/solutii','preONI 2005 runda #1 - solutii','2006-11-18 00:01:33','h1. preONI 2005 runda #1 - solutii\r\n\r\n(Creat de ==user(user=\"domino\" type=\"tiny\")== la data de _2005-01-24_ categoria _Competitii_, autor(i) _Mircea Pasoi_)\r\n\r\nArticolul contine ideile de rezolvare ale problemelor propuse la prima runda a concursului preONI ce s-a desfasurat pe data de 23 ianuarie 2005, cat si comentarii legate de concurs.\r\n\r\nCum s-a si promis, setul de probleme de data aceasta n-a fost dur, problemele fiind mult mai accesibile, fapt care se vede imediat din punctaje. Spre deosebire de concursurile anterioare in care problemele erau toate de acelasi nivel, de data aceasta a existat o problema usoara, una medie si una grea la fiecare grupa (gen TopCoder).\r\n\r\nToti care am participat la compunerea problemelor suntem de parere ca probleme au fost de nivelul ONI, chiar un pic mai usoare. De asemenea, testele au fost create astfel incat sa se poata obtine 190-200p in mod usor de un concurent cu cunostiinte medii care implementeaza solutii corecte dar care nu se incadreaza complet in limita de timp. Din pacate rezultatele sunt un pic sub nivelul asteptarilor, dar speram ca se vor inbunatati in rundele urmatoare! ;)\r\n\r\nh2. Clasele 9-10\r\n\r\nPrimele $5$ locuri din clasamentul de la $9-10$ arata astfel:\r\n\r\n# Macarie & Petronela - 270p\r\n# Tataroiu Bogdan - 210p\r\n# Stefan Andrei - 190p\r\n# Ghilea Daniel - 180p\r\n# Saveluc Vlad - 170p\r\n# Stanescu Lucian - 170p\r\n\r\nEste de mentionat faptul ca sub pseudonimul \"Macarie & Petronela\":http://www.infoarena.ro/user/macarie se \"ascunde\" echipa care va reprezenta Romania la finala ACM, formata din Mugurel Andreica, Marius Andrei si Ghinea Dan. Ei au concurat pe un singur calculator si au rezolvat toate cele $6$ probleme propuse pentu a simula un concurs ACM. De asemenea, un lucru remarcabil, concurentul clasat pe locul {$2$}, Tataroiu Bogdan este abia clasa a {$7$}-a! Probabil ca va reprezenta Romania la multe IOI-uri :)\r\n\r\nh3. Text\r\n\r\nProblema a fost cea mai usoara din cele $3$ probleme din grupa si rezolvarea nu ar trebui sa ridice mari dificultati nici macar unui elev de a {$9$}-a incepator. Fie $N$ numarul de caractere din fisierul de intrare - voi prezenta o solutie {$O(N)$}. Se parcurge fisierul caracter cu caracter (nu este necesara stocarea datelor de intrare intr-un vector) si se mentin doua variabile care indica pozitia de inceput si sfarsit a ultimului cuvant detectat pana in prezent, daca s-a gasit vreunul. De asemenea se pastreaza si doua variabile pentru suma lungimilor cuvintelor si numarul de cuvinte pentru a calcula rezultatul. Atentie insa ca la sfarsitul parcurgerii fisierului de iesire, daca ultimul caracter citit a fost o litera mare sau mica, sa se actualizeze numarul de cuvinte si suma lungimilor.\r\n\r\nh3. Trapez\r\n\r\nProblema a fost cea de nivel mediu din cele $3$ si face apel la cunostiinte minime de geometrie. Conditia ca oricare trei puncte nu sunt coliniare simplifica mult rezolvarea. Din definitie, un trapez are cel putin doua laturi paralele deci se poate construi urmatorul algoritm: se iau toate perechile de puncte - acestea determina cate un segment - si sorteaza in functie de unghiul cu axa OX (panta dreptei). Pentru fiecare $k$ segmente cu acelasi unghi se pot forma {$Comb(k,2)$} trapeze. Pentru a evita calculele cu reale (care pot cauza erori de precizie), se tin pantele ca perechi de numere intregi ({$y, x$}), fara a efectua efectiv impartirea {$y/x$}. Pentru compararea a doua astfel de perechi sunt necesare tipuri de date pe $64$ de biti. Algoritmul descris are complexitate {$O(N^2^*lg N)$}. Las ca exercitiu rezolvarea acestei probleme folosind un algoritm $O(N^2^)$ care foloseste \"hashing\":http://www.infoarena.ro/Hashing (vezi articolul de pe site). Se puteau obtine $40-50p$ cu un algoritm brut {$O(N^4^)$}.\r\n\r\nh3. Subsir\r\n\r\nAceasta problema, care a fost si cea mai grea, a fost prezenta si la CEOI 2003, dar intr-o forma mai simpla. Acolo se cerea generarea efectiva a tuturor subsirurilor , nu numararea lor, si se garanta ca numarul lor este sub {$1000$}. Orice solutie care ar fi luat $100p$ la problema de la CEOI ar fi obtinut $50p$ la aceasta (primele $5$ teste fiind de fapt preluate de la CEOI 2003). Cum multi probabil au intuit, rezolvarea se bazeaza pe programare dinamica. Voi numi cele doua siruri $A$ si {$B$}, de lungime {$N$}, respectiv $M$ si voi construi initial matricea $C{~i,j~}$ = lungimea celui mai lung subsir comun al sirurilor {$A{~1..i~}$} si {$B{~1..j~}$}. Acest lucru se poate face in $O(N*M)$ si este o aplicatie clasica a programarii dinamice (se gaseste in foarte multe carti explicata ideea). In continuare voi numara sirurile folosind un algoritm $O(N*M*Sigma)$ unde $Sigma$ este numarul litere din care pot fi formate sirurile, adica {$26$}. Se va calcula o matrice $Nr{~i,j~}$ = cate subsiruri comune de lungime maxima existe pentru sirurile $A{~1..i~}$ si\r\n$B{~1..~}$ (evident modulo {$666013$}). Se calculeaza $Nr{~i,j~}$ doar atunci cand {$A{~i~} = B{~i~}$}, astfel: pentru fiecare caracter $c$ intre \'{$a$}\' si \'{$z$}\' se cauta ultima sa aparitie in sirul $A{~1..i-1~}$ (fie aceasta pozitia {$ii$}) si ultima sa aparitie in sirul $B{~1..j-1~}$ (fie aceasta pozitia {$jj$}). Acest lucru se poate face in $O(1)$ daca se preproceseaza inainte aceste informatii in {$O((N+M)*Sigma)$}. Daca $C{~i,j~} = C{~ii,jj~}+1$ se va aduna $Nr{~ii,jj~}$ la $Nr{~i,j~}$ - aceasta conditie ne garanteaza ca subsirurile adaugate au lungime maxima, iar faptul ca $ii$ si $jj$ reprezinta ultima aparitie a caracterului garanteaza ca nu se vor numara subsiruri identice. Pentru a gasi rezultatul final se aduna toate valorile $Nr{~i,j~}$ calculate, cu urmatoarea exceptie: daca exista pozitiile $x$ si $y$ astfel incat {$A{~x~} = A{~i~} = B{~y~} = B{~j~}$}, se aduna $Nr{~i,j~}$ doar daca $x < i$ si $y < j$ (pentru a asigura ca nu se numara subsiruri identice de mai multe ori).\r\n\r\nh2. Clasele 11-12\r\n\r\nPrimele 5 locuri din clasamentul de la 11-12 arata astfel:\r\n\r\n# Simion Filip - 200p\r\n# Macarie & Petronela - 190p\r\n# Fechete Dan Ionut - 190p\r\n# Crestez Leonard - 190p\r\n# Bindea Calin - 170p\r\n# Grosu Codrut - 140p\r\n# Gordon Freeman - 130p\r\n# Giurgea Mihnea - 130p\r\n\r\nh3. Iepuri\r\n\r\nProblema a fost cea mai usoara din cel 3 si necesita cunostiine elementare de matematica de clasa a 11-a. Daca se noteaza cu I(n) cati iepuri sunt in ziua n se deduc urmatoarele relatii din enunt:\r\nI(0)=X, I(1)=Y, I(2)=Z\r\nI(n)=A*I(n-1) + B*I(n-2) + C*I(n-3) pt n>=3\r\nRezultatul cerut este I(N) modulo 666013 pentru fiecare test.\r\nO prima rezolvare, si cea mai simpla, este implementarea directa a relatiei de recurenta si conduce la o complexitate O(N) pe set de date. Aceasta abordare ar fi obtinut 50p.In continuare voi descrie o rezolvare O(lg N) care foloseste matrici. Se construieste matricea:\r\n\r\n[0 1 0]\r\nM = [0 0 1]\r\n[C B A]\r\n\r\ncare sta la baza relatiei:\r\n\r\n[I(n) ] [I(n+1)]\r\nM * [I(n+1)] = [I(n+2)]\r\n[I(n+2)] [I(n+3)]\r\n\r\nDin asta se deduce:\r\n\r\n[I(0)] [I(N) ]\r\nM^N * [I(1)] = [I(N+1)]\r\n[I(2)] [I(N+2)]\r\n\r\nastfel problema se reduce la a calcula M^N in O(lg N). Algoritmul de ridicare la putere in timp logaritmic este clasic si nu-l mai mentionez aici.\r\n\r\nh3. Barbar\r\n\r\nProblema este de nivel mediu si necesita cunostiinte elementare de teoria grafurilor. Se considera matricea initiala un graf cu R*C noduri, mai putin zidurile. Se face o parcurgere BF pentru a determina pentru fiecare casuta din matrice distanta pana la cel mai apropiat dragon. Astfel, se incepe BF-ul cu toate nodurile care corespund dragonilor inserate in coada (deci nu va fi doar un nod in coada la inceput). Complexitatea acestui pas este O(R*C). Se observa daca exista un traseu valid care trece prin casute situate la distanta >=x fata de cel mai apropiat dragon, atunci exista in mod evident un traseu valid care trece prin casute situate la distanta >=x-1 fata de cel mai apropiat dragon. Aceasta observatie duce la folosirea cautarii binare a rezultatului (vezi articolul de pe site pentru alte aplicatii). Pentru a verifica daca exista un traseu valid care trece doar prin casute situate la o anumita distanta fata de cel mai apropiat dragon se foloseste tot o parcurgere BF, astfel rezolvarea fiind\r\nO(R*C*lg(R*C)).\r\n\r\nh3. ADN\r\n\r\nLa primul pas se elimina toate cuvintele incluse in alte cuvinte mai mari (pentru a cauta daca exista un cuvant in alt cuvant se foloseste algoritmul KMP pentru incadrarea in timp - vezi articolul de pe site). Apoi, se construieste un graf cu noduri cuvintele si muchii intre oricare doua cuvinte. Costul unei muchii (i, j) va fi cel mai lung sufix al cuvantului i care este prefix al cuvantului j (informatie care se poate determina cu KMP), adica cate litere sunt \"inutile\" daca lipim cuvantul i cu cuvantul j. Aceasta prima etapa are complexitate O(N^2*L), unde L e lungimea maxima a unui cuvant. Deoarece trebuie sa existe fiecar cuvant in sirul rezultat, iar sirul sa fie de lungime minima problema se reduce la determinarea unui lant hamiltonian de cost maxim, problema care este binecunoscuta ca fiind NP. Un algoritm care incearca toate cele n! permutari are complexitate O(n!) si va obtine 50p. Pentru punctaj maxim vom folosi programare dinamica astfel: fie A[i][(n1, n2.. nk)] = costul unui lant hamiltonian\r\nde cost maxim care incepe din nodul i si trece prin nodurile n1, n2 .. nk. Relatia de recurenta este: A[i][(n1,n2..nk)] = max cost(i, nj) + A[nj][(n1,n2,nj-1,nj+1..nk)] pentru fiecare j. Dinamica se initializeaza cu A[i][(i)] = 0 pentru fiecare i. Reprezentarea multimilor de noduri se face folosind un numar binar cu N biti, astfel complexitatea acestei etape fiind O(N^2*2^N). Mentionez ca aceasta rezolvare nu produce solutia minim lexicografic, fapt observat in timpul concursului si astfel s-a reevaluat problema dandu-se puncte pentru orice solutie valida, nu neaparat minim lexicografic. Rezolvarea problemei cu cerinta de minim lexicografic este posibila, dar pentru realizarea ei trebuie folosite structuri de date avansate ca Suffix Arrays sau Suffix Trees si nivelul de dificultate ar fi mult mai mare. Alta observarie este ca matricea cost ar putea fi calculata mai repede daca am folosi structurile mentionate mai devreme. Folosind prima structura am avea complexitatea O( N*L log (N*L)) iar a folosind a\r\ndoua structura am avea complexitatea O(N*L) . De asemenea mentionam posibilitatea folositii algoritmului randomizat de potrivire a sirurilor de caractere numit Rabin Karp pentru calcularea matricii cost ceea ce ar fi dus la o solutie mai scurta si la un cod mai clar. Ne cerem scuze pentru eventualele neplaceri cauzate de aceasta situatie.\r\n\r\nBafta la urmatorul concurs! (undeva prin februarie...)\r\n',961,'public'),('preoni-2005/runda-1/solutii','preONI 2005 runda #1 - solutii','2006-11-18 00:04:26','h1. preONI 2005 runda #1 - solutii\r\n\r\n(Creat de ==user(user=\"domino\" type=\"tiny\")== la data de _2005-01-24_ categoria _Competitii_, autor(i) _Mircea Pasoi_)\r\n\r\nArticolul contine ideile de rezolvare ale problemelor propuse la prima runda a concursului preONI ce s-a desfasurat pe data de 23 ianuarie 2005, cat si comentarii legate de concurs.\r\n\r\nCum s-a si promis, setul de probleme de data aceasta n-a fost dur, problemele fiind mult mai accesibile, fapt care se vede imediat din punctaje. Spre deosebire de concursurile anterioare in care problemele erau toate de acelasi nivel, de data aceasta a existat o problema usoara, una medie si una grea la fiecare grupa (gen TopCoder).\r\n\r\nToti care am participat la compunerea problemelor suntem de parere ca probleme au fost de nivelul ONI, chiar un pic mai usoare. De asemenea, testele au fost create astfel incat sa se poata obtine 190-200p in mod usor de un concurent cu cunostiinte medii care implementeaza solutii corecte dar care nu se incadreaza complet in limita de timp. Din pacate rezultatele sunt un pic sub nivelul asteptarilor, dar speram ca se vor inbunatati in rundele urmatoare! ;)\r\n\r\nh2. Clasele 9-10\r\n\r\nPrimele $5$ locuri din clasamentul de la $9-10$ arata astfel:\r\n\r\n==Rankings(rounds=\"preoni51a\" display_entries=\"6\" pager_style=\"none\")==\r\n\r\n# Macarie & Petronela - 270p\r\n# Tataroiu Bogdan - 210p\r\n# Stefan Andrei - 190p\r\n# Ghilea Daniel - 180p\r\n# Saveluc Vlad - 170p\r\n# Stanescu Lucian - 170p\r\n\r\nEste de mentionat faptul ca sub pseudonimul \"Macarie & Petronela\":http://www.infoarena.ro/user/macarie se \"ascunde\" echipa care va reprezenta Romania la finala ACM, formata din Mugurel Andreica, Marius Andrei si Ghinea Dan. Ei au concurat pe un singur calculator si au rezolvat toate cele $6$ probleme propuse pentu a simula un concurs ACM. De asemenea, un lucru remarcabil, concurentul clasat pe locul {$2$}, Tataroiu Bogdan este abia clasa a {$7$}-a! Probabil ca va reprezenta Romania la multe IOI-uri :)\r\n\r\nh3. Text\r\n\r\nProblema a fost cea mai usoara din cele $3$ probleme din grupa si rezolvarea nu ar trebui sa ridice mari dificultati nici macar unui elev de a {$9$}-a incepator. Fie $N$ numarul de caractere din fisierul de intrare - voi prezenta o solutie {$O(N)$}. Se parcurge fisierul caracter cu caracter (nu este necesara stocarea datelor de intrare intr-un vector) si se mentin doua variabile care indica pozitia de inceput si sfarsit a ultimului cuvant detectat pana in prezent, daca s-a gasit vreunul. De asemenea se pastreaza si doua variabile pentru suma lungimilor cuvintelor si numarul de cuvinte pentru a calcula rezultatul. Atentie insa ca la sfarsitul parcurgerii fisierului de iesire, daca ultimul caracter citit a fost o litera mare sau mica, sa se actualizeze numarul de cuvinte si suma lungimilor.\r\n\r\nh3. Trapez\r\n\r\nProblema a fost cea de nivel mediu din cele $3$ si face apel la cunostiinte minime de geometrie. Conditia ca oricare trei puncte nu sunt coliniare simplifica mult rezolvarea. Din definitie, un trapez are cel putin doua laturi paralele deci se poate construi urmatorul algoritm: se iau toate perechile de puncte - acestea determina cate un segment - si sorteaza in functie de unghiul cu axa OX (panta dreptei). Pentru fiecare $k$ segmente cu acelasi unghi se pot forma {$Comb(k,2)$} trapeze. Pentru a evita calculele cu reale (care pot cauza erori de precizie), se tin pantele ca perechi de numere intregi ({$y, x$}), fara a efectua efectiv impartirea {$y/x$}. Pentru compararea a doua astfel de perechi sunt necesare tipuri de date pe $64$ de biti. Algoritmul descris are complexitate {$O(N^2^*lg N)$}. Las ca exercitiu rezolvarea acestei probleme folosind un algoritm $O(N^2^)$ care foloseste \"hashing\":http://www.infoarena.ro/Hashing (vezi articolul de pe site). Se puteau obtine $40-50p$ cu un algoritm brut {$O(N^4^)$}.\r\n\r\nh3. Subsir\r\n\r\nAceasta problema, care a fost si cea mai grea, a fost prezenta si la CEOI 2003, dar intr-o forma mai simpla. Acolo se cerea generarea efectiva a tuturor subsirurilor , nu numararea lor, si se garanta ca numarul lor este sub {$1000$}. Orice solutie care ar fi luat $100p$ la problema de la CEOI ar fi obtinut $50p$ la aceasta (primele $5$ teste fiind de fapt preluate de la CEOI 2003). Cum multi probabil au intuit, rezolvarea se bazeaza pe programare dinamica. Voi numi cele doua siruri $A$ si {$B$}, de lungime {$N$}, respectiv $M$ si voi construi initial matricea $C{~i,j~}$ = lungimea celui mai lung subsir comun al sirurilor {$A{~1..i~}$} si {$B{~1..j~}$}. Acest lucru se poate face in $O(N*M)$ si este o aplicatie clasica a programarii dinamice (se gaseste in foarte multe carti explicata ideea). In continuare voi numara sirurile folosind un algoritm $O(N*M*Sigma)$ unde $Sigma$ este numarul litere din care pot fi formate sirurile, adica {$26$}. Se va calcula o matrice $Nr{~i,j~}$ = cate subsiruri comune de lungime maxima existe pentru sirurile $A{~1..i~}$ si\r\n$B{~1..i~}$ (evident modulo {$666013$}). Se calculeaza $Nr{~i,j~}$ doar atunci cand {$A{~i~} = B{~i~}$}, astfel: pentru fiecare caracter $c$ intre \'{$a$}\' si \'{$z$}\' se cauta ultima sa aparitie in sirul $A{~1..i-1~}$ (fie aceasta pozitia {$ii$}) si ultima sa aparitie in sirul $B{~1..j-1~}$ (fie aceasta pozitia {$jj$}). Acest lucru se poate face in $O(1)$ daca se preproceseaza inainte aceste informatii in {$O((N+M)*Sigma)$}. Daca $C{~i,j~} = C{~ii,jj~}+1$ se va aduna $Nr{~ii,jj~}$ la $Nr{~i,j~}$ - aceasta conditie ne garanteaza ca subsirurile adaugate au lungime maxima, iar faptul ca $ii$ si $jj$ reprezinta ultima aparitie a caracterului garanteaza ca nu se vor numara subsiruri identice. Pentru a gasi rezultatul final se aduna toate valorile $Nr{~i,j~}$ calculate, cu urmatoarea exceptie: daca exista pozitiile $x$ si $y$ astfel incat {$A{~x~} = A{~i~} = B{~y~} = B{~j~}$}, se aduna $Nr{~i,j~}$ doar daca $x < i$ si $y < j$ (pentru a asigura ca nu se numara subsiruri identice de mai multe ori).\r\n\r\nh2. Clasele 11-12\r\n\r\nPrimele 5 locuri din clasamentul de la 11-12 arata astfel:\r\n\r\n# Simion Filip - 200p\r\n# Macarie & Petronela - 190p\r\n# Fechete Dan Ionut - 190p\r\n# Crestez Leonard - 190p\r\n# Bindea Calin - 170p\r\n# Grosu Codrut - 140p\r\n# Gordon Freeman - 130p\r\n# Giurgea Mihnea - 130p\r\n\r\nh3. Iepuri\r\n\r\nProblema a fost cea mai usoara din cel 3 si necesita cunostiine elementare de matematica de clasa a 11-a. Daca se noteaza cu I(n) cati iepuri sunt in ziua n se deduc urmatoarele relatii din enunt:\r\nI(0)=X, I(1)=Y, I(2)=Z\r\nI(n)=A*I(n-1) + B*I(n-2) + C*I(n-3) pt n>=3\r\nRezultatul cerut este I(N) modulo 666013 pentru fiecare test.\r\nO prima rezolvare, si cea mai simpla, este implementarea directa a relatiei de recurenta si conduce la o complexitate O(N) pe set de date. Aceasta abordare ar fi obtinut 50p.In continuare voi descrie o rezolvare O(lg N) care foloseste matrici. Se construieste matricea:\r\n\r\n[0 1 0]\r\nM = [0 0 1]\r\n[C B A]\r\n\r\ncare sta la baza relatiei:\r\n\r\n[I(n) ] [I(n+1)]\r\nM * [I(n+1)] = [I(n+2)]\r\n[I(n+2)] [I(n+3)]\r\n\r\nDin asta se deduce:\r\n\r\n[I(0)] [I(N) ]\r\nM^N * [I(1)] = [I(N+1)]\r\n[I(2)] [I(N+2)]\r\n\r\nastfel problema se reduce la a calcula M^N in O(lg N). Algoritmul de ridicare la putere in timp logaritmic este clasic si nu-l mai mentionez aici.\r\n\r\nh3. Barbar\r\n\r\nProblema este de nivel mediu si necesita cunostiinte elementare de teoria grafurilor. Se considera matricea initiala un graf cu R*C noduri, mai putin zidurile. Se face o parcurgere BF pentru a determina pentru fiecare casuta din matrice distanta pana la cel mai apropiat dragon. Astfel, se incepe BF-ul cu toate nodurile care corespund dragonilor inserate in coada (deci nu va fi doar un nod in coada la inceput). Complexitatea acestui pas este O(R*C). Se observa daca exista un traseu valid care trece prin casute situate la distanta >=x fata de cel mai apropiat dragon, atunci exista in mod evident un traseu valid care trece prin casute situate la distanta >=x-1 fata de cel mai apropiat dragon. Aceasta observatie duce la folosirea cautarii binare a rezultatului (vezi articolul de pe site pentru alte aplicatii). Pentru a verifica daca exista un traseu valid care trece doar prin casute situate la o anumita distanta fata de cel mai apropiat dragon se foloseste tot o parcurgere BF, astfel rezolvarea fiind\r\nO(R*C*lg(R*C)).\r\n\r\nh3. ADN\r\n\r\nLa primul pas se elimina toate cuvintele incluse in alte cuvinte mai mari (pentru a cauta daca exista un cuvant in alt cuvant se foloseste algoritmul KMP pentru incadrarea in timp - vezi articolul de pe site). Apoi, se construieste un graf cu noduri cuvintele si muchii intre oricare doua cuvinte. Costul unei muchii (i, j) va fi cel mai lung sufix al cuvantului i care este prefix al cuvantului j (informatie care se poate determina cu KMP), adica cate litere sunt \"inutile\" daca lipim cuvantul i cu cuvantul j. Aceasta prima etapa are complexitate O(N^2*L), unde L e lungimea maxima a unui cuvant. Deoarece trebuie sa existe fiecar cuvant in sirul rezultat, iar sirul sa fie de lungime minima problema se reduce la determinarea unui lant hamiltonian de cost maxim, problema care este binecunoscuta ca fiind NP. Un algoritm care incearca toate cele n! permutari are complexitate O(n!) si va obtine 50p. Pentru punctaj maxim vom folosi programare dinamica astfel: fie A[i][(n1, n2.. nk)] = costul unui lant hamiltonian\r\nde cost maxim care incepe din nodul i si trece prin nodurile n1, n2 .. nk. Relatia de recurenta este: A[i][(n1,n2..nk)] = max cost(i, nj) + A[nj][(n1,n2,nj-1,nj+1..nk)] pentru fiecare j. Dinamica se initializeaza cu A[i][(i)] = 0 pentru fiecare i. Reprezentarea multimilor de noduri se face folosind un numar binar cu N biti, astfel complexitatea acestei etape fiind O(N^2*2^N). Mentionez ca aceasta rezolvare nu produce solutia minim lexicografic, fapt observat in timpul concursului si astfel s-a reevaluat problema dandu-se puncte pentru orice solutie valida, nu neaparat minim lexicografic. Rezolvarea problemei cu cerinta de minim lexicografic este posibila, dar pentru realizarea ei trebuie folosite structuri de date avansate ca Suffix Arrays sau Suffix Trees si nivelul de dificultate ar fi mult mai mare. Alta observarie este ca matricea cost ar putea fi calculata mai repede daca am folosi structurile mentionate mai devreme. Folosind prima structura am avea complexitatea O( N*L log (N*L)) iar a folosind a\r\ndoua structura am avea complexitatea O(N*L) . De asemenea mentionam posibilitatea folositii algoritmului randomizat de potrivire a sirurilor de caractere numit Rabin Karp pentru calcularea matricii cost ceea ce ar fi dus la o solutie mai scurta si la un cod mai clar. Ne cerem scuze pentru eventualele neplaceri cauzate de aceasta situatie.\r\n\r\nBafta la urmatorul concurs! (undeva prin februarie...)\r\n',961,'public'),('sandbox','Sandbox','2006-11-18 00:13:27','== code(pas) |\r\n    [0 1 0]\r\nM = [0 0 1]\r\n    [C B A]\r\n==\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',0,'public'),('faq-pregatire-bacalaureat-2005','F.A.Q. Pregatire bacalaureat 2005','2006-11-18 13:02:37','h1. F.A.Q. Pregatire bacalaureat 2005\r\n\r\n(Creat de \'_domino_\':user/domino la data de _2005-04-27_ categoria _Diverse_, autor(i) _Echipa devNet_)\r\n\r\n ==Include(page=\"template/raw\")==\r\n\r\nAcest articol poate fi considerat ca un ghid pentru programul de pregatire online la disciplina informatica din cadrul examenului de bacalaureat.\r\nCa o completare la acest articol, va recomadam sa accesati si link-ul \"Despre Infoarena\"http://infoarena.devnet.ro/index.php?page=about.\r\nPentru a citi in continuare faceti click pe titlu.\r\n\r\nIn cadrul acestui program de pregatire, profesori prestigiosi de informatica din tara vor pune la dispozitia elevilor o lista de subiecte de bacalaureat de doua tipuri:\r\n\r\n1. $Probleme de informatica;$ Pentru aceste subiecte, elevii vor trebui sa conceapa si sa redacteze solutii complete intr-un limbaj de programare la alegere. Site-ul dispune de un evaluator automat capabil sa noteze instantaneu solutiile propuse de elevi.\r\n2. $Teste de tip grila de informatica;$ Elevii au posibilitatea sa rezolve astfel de teste de tip grila. Ca si la problemele de informatica, raspunsurile trimise se evalueaza pe loc.\r\n\r\nPentru probleme disponibile in arhiva, rezultatul $evaluarii automate$ poate fi vazut in $monitorul de evaluare$. Acolo veti vedea numarul de puncte obtinute cat si detalii despre evaluare impreuna cu niste timpi de executie orientativi. Mesajele pe care le puteti primi sunt urmatoarele:\r\n\r\n* $OK$ (sau un mesaj asemanator): programul tau a mers corect pe testul respectiv si ai primit punctele care le meritai.\r\n* $Wrong Answer, Raspuns gresit$ (sau un mesaj asemanator): programul tau a terminat executia, dar raspunsul oferit nu a fost corect; verifica daca ai respectat intocmai cum este precizat in enunt formatul fisierului de iesire cat si formatul fisierului de intrare cand efectuezi citirea\r\n* $Time Limit Exceeded:$ programul tau a depasit timpul de executie permis pentru testul respectiv; cele mai dese cauze pentru acest mesaj sunt: algoritmul folosit este ineficient, fie programul tau contine bucle care se executa la infinit, fie programul tau incearca sa citeasca de la tastatura, etc.\r\n* $Missing input/grader$ file (sau un mesaj asemanator): fisierul de intrare sau de verificare lipseste, anunta un membru din echipa devNet (acest mesaj n-ar trebui sa apara!)\r\n* $Missing output file$ (sau un mesaj asemanator): programul tau n-a creat un fisier de iesire, sau in cazul in care a creat un fisier, nu a avut numele specificat in enuntul problemei\r\n* $Runtime error - Invalid memory reference:$ acest mesaj se poate referi la faptul ca depasesti memorie disponibila (care este de 1 MB pentru stiva si 63 MB pentru heap) sau la un acces invalid in memorie, accesarea unui pointer invalid, indecsi intr-un tablou care depasesc dimensiunile tabloului, etc.\r\n* $Runtime error - alt mesaj:$ cele mai cunoscute cauze pentru astfel de mesaje sunt depasirea stivei, accesarea unor fisiere gresite, erori cu numere reale, impartire la 0, etc. Un mesaj foarte intalnit este SIGKILL si semnifica ca programul tau a fost oprit de evaluator datorita unei erori ca cele descrise mai sus.\r\n\r\nVa recomandam sa consultati acest document periodic deoarece va fi actualizat des pentru a raspunde la majoritatea neclaritatilor care pot aparea in utilizarea sistemului de pregatire pentru bacalaureat. De asemenea acest document poate fi folosit si ca un ghid pentru utilizatorii \"Arhivei de probleme pentru concursuri\". Daca aveti alte intrebari care nu sunt raspunse aici nu evitati sa le puneti pe \"forum\":http://info.devnet.ro/forum.php.\r\n',48,'public'),('faq-pregatire-bacalaureat-2005','F.A.Q. Pregatire bacalaureat 2005','2006-11-18 13:07:57','h1. F.A.Q. Pregatire bacalaureat 2005\r\n\r\n(Creat de ==user(user=\"domino\" type=\"tiny\")== la data de _2005-04-27_ categoria _Diverse_, autor(i) _Echipa devNet_)\r\n\r\nAcest articol poate fi considerat ca un ghid pentru programul de pregatire online la disciplina informatica din cadrul examenului de bacalaureat.\r\nCa o completare la acest articol, va recomadam sa accesati si link-ul \"Despre Infoarena\":http://infoarena.devnet.ro/index.php?page=about.\r\n&nbsp;\r\nIn cadrul acestui program de pregatire, profesori prestigiosi de informatica din tara vor pune la dispozitia elevilor o lista de subiecte de bacalaureat de doua tipuri:\r\n\r\n# $Probleme de informatica;$ Pentru aceste subiecte, elevii vor trebui sa conceapa si sa redacteze solutii complete intr-un limbaj de programare la alegere. Site-ul dispune de un evaluator automat capabil sa noteze instantaneu solutiile propuse de elevi.\r\n# $Teste de tip grila de informatica;$ Elevii au posibilitatea sa rezolve astfel de teste de tip grila. Ca si la problemele de informatica, raspunsurile trimise se evalueaza pe loc.\r\n\r\nPentru probleme disponibile in arhiva, rezultatul $evaluarii automate$ poate fi vazut in +monitorul de evaluare+. Acolo veti vedea numarul de puncte obtinute cat si detalii despre evaluare impreuna cu niste timpi de executie orientativi. Mesajele pe care le puteti primi sunt urmatoarele:\r\n\r\n* $OK$ (sau un mesaj asemanator): programul tau a mers corect pe testul respectiv si ai primit punctele care le meritai.\r\n* $Wrong Answer, Raspuns gresit$ (sau un mesaj asemanator): programul tau a terminat executia, dar raspunsul oferit nu a fost corect; verifica daca ai respectat intocmai cum este precizat in enunt formatul fisierului de iesire cat si formatul fisierului de intrare cand efectuezi citirea\r\n* $Time Limit Exceeded:$ programul tau a depasit timpul de executie permis pentru testul respectiv; cele mai dese cauze pentru acest mesaj sunt: algoritmul folosit este ineficient, fie programul tau contine bucle care se executa la infinit, fie programul tau incearca sa citeasca de la tastatura, etc.\r\n* $Missing input/grader$ file (sau un mesaj asemanator): fisierul de intrare sau de verificare lipseste, anunta un membru din echipa devNet (acest mesaj n-ar trebui sa apara!)\r\n* $Missing output file$ (sau un mesaj asemanator): programul tau n-a creat un fisier de iesire, sau in cazul in care a creat un fisier, nu a avut numele specificat in enuntul problemei\r\n* $Runtime error - Invalid memory reference:$ acest mesaj se poate referi la faptul ca depasesti memorie disponibila (care este de 1 MB pentru stiva si 63 MB pentru heap) sau la un acces invalid in memorie, accesarea unui pointer invalid, indecsi intr-un tablou care depasesc dimensiunile tabloului, etc.\r\n* $Runtime error - alt mesaj:$ cele mai cunoscute cauze pentru astfel de mesaje sunt depasirea stivei, accesarea unor fisiere gresite, erori cu numere reale, impartire la 0, etc. Un mesaj foarte intalnit este SIGKILL si semnifica ca programul tau a fost oprit de evaluator datorita unei erori ca cele descrise mai sus.\r\n\r\n+Va recomandam sa consultati acest document periodic+ deoarece va fi actualizat des pentru a raspunde la majoritatea neclaritatilor care pot aparea in utilizarea sistemului de pregatire pentru bacalaureat. De asemenea acest document poate fi folosit si ca un ghid pentru utilizatorii \"Arhivei de probleme pentru concursuri\". Daca aveti alte intrebari care nu sunt raspunse aici nu evitati sa le puneti pe \"forum\":http://info.devnet.ro/forum.php.\r\n',961,'public'),('warm-up-2006/solutii','Solutii Autumn WarmUp 2006','2006-11-12 21:07:40','h1. Solutii Autumn WarmUp 2006\r\n\r\n(Creat de \'_filipb_\':user/filipb la data de _2006-09-07_ categoria _Competitii_, autor(i) _Echipa Info-arena_)\r\n\r\n*Continut scurt:*\r\n ==Include(page=\"template/raw\")==\r\n\r\nArticolul contine ideile de rezolvare a celor 5 probleme propuse spre rezolvare in concursul Autumn WarmUp 2006, concurs organizat in intregime de 5 dintre utilizatorii info-arena.\r\n\r\n\r\n*Continut lung:*\r\n==Include(page=\"template/raw\")==\r\n\r\nAici puteti gasi solutiile oficiale la cele 5 probleme propuse in concurs. De precizat si ca aceasta initiativa info-arena a fost un succes, adunand un numar respectabil de participanti. Punctajele au fost mai mici decat cele asteptate, fapt ce a confirmat ca setul de probleme a fost unul capabil sa puna in dificultate nume cunoscute la olimpiadele de informatica. Iata si solutiile:\r\n\r\n\r\nh2. poly\r\n\r\nProblema este una de programare dinamica si are complexitatea $O(N)$, de constanta $2^7^ = 128$. Sa notam cu $M{~i,j~}$ lungimea celui mai lung subsir utilizand primele $i$ numere din vector astfel incat ultimul element din subsirul optim sa aiba ca divizori numerele din multimea data corespunzatoare bitilor de $1$ din $j$. Mai intai $M{~i,j~}$ = $M{~i-1,j~}$ ( nu folosim numarul al $i$-lea ). Daca dorim sa folosim si numarul al $i$-lea, atunci $M{~i,config~} = maxim(M{~i,config~}$, M{~i-1,k~} + 1)$, cu $k and config = 0$, unde config are bitii de $1$ corespunzatori numerelor din multimea data cu care se divide acest al $i$-lea numar din sirul initial. Conditia $k and config$ ne asigura ca penultimul si ultimul numar din subsir nu au amandoua vreun divizor comun din multimea data (operatia $and$ in acest context este o operatie pe biti). Rezultatul va fi $max($M{~n,0~}$, $M{~n,1~}$... $M{~n,127~}$)$. Memoria folosita poate fi $O(1)$, retinand doar ultimele doua linii ale matricei.\r\n\r\nUn algoritm de complexitate patratica in $N$ folosind tot programarea dinamica ar fi obtinut $30-40$ de puncte.\r\n\r\nh2. bridge\r\n\r\nUn algoritm de complexitate $O(M + N * K)$ folosind programarea dinamica nu este foarte greu de gasit. Daca notam cu $M{~i,j~}$ numarul de moduri (modulo $666013$) de a ajunge in $i$ pasi pe scandura $j$ din pozitia initiala, atunci mai trebuie avut grija doar la relatiile de recurenta. In cazul de fata vom utiliza metoda inainte si vom trata cazurile: daca scandura $j$ este lipsa atunci $M{~i,j~} = 0$, daca scandura $j$ este teleportoare incrementam $M{~i+1,unde[j]~}$ cu $M{~i,j~}$ daca si numai daca $unde[j]$ nu este lipsa sau subreda ($unde[j]$ este destinatia teleportarii de pe scandura $j$),daca $j$ este scandura buna, incrementam $M{~i+1,j+1~}$ cu $M{~i,j~}$ si $M{~i+1,j+2~}$ cu $M{~i,j~}$ doar daca $j+2$ nu e lipsa sau subreda, etc.\r\n\r\nAvand construita matricea $M$, pentru fiecare query putem raspunde acum in $O(1)$. Exista diferite optimizari care pot fi facute si care sporesc substantial timpul de executie.\r\n\r\n\r\nh2. secv4\r\n\r\nDeoarece logaritmul unui produs de numere este egal cu suma logaritmilor fiecarui numar din produs, si in ipoteza ca toate numerele din sir sunt pozitive, logaritmam fiecare numar si notam cu $S{~i~}$ suma primilor $i$ logaritmi. Astfel, pentru a afla secventa de produs maxim care se termina pe pozitia $i$, este suficient sa determinam, pentru $k$ intre $i-y$ si $i-x$ care este $S{~k~}$ minim (astfel, $S{~i~} - S{~k~}$ va fi maxim, deci si produsul maxim, iar secventa va incepe pe pozitia $k+1$). Putem folosi un arbore de intervale si obtinem un algoritm $O(NlogN)$, sau o coada prin care scoatem elementele prin ambele parti (structura de date numita deque - double ended queue), obtinand complexitatea $O(N)$. Daca exista si numere negative, in momentul logaritmarii numerelor negative logaritmam opusul lor. Aplicand procedeul descris mai sus, stim sigur la final ca produsul obtinut are modulul maxim. Pentru a fi cu adevarat maxim (deci pozitiv), notam cu $semn{~i~}$ semnul produsului primelor $i$ numere. Ca secventa {$<j+1, i>$} sa aiba produs maxim trebuie in plus $semn{~i~} = semn{~j~}$. Vom retine doua deque-uri, unul pentru {$+$} si unul pt {$-$}, conform vectorului semn. Astfel, in final, suntem siguri ca produsul are semnul {$+$} si, cum are si modulul maxim, are valoarea maxima ceruta.\r\n\r\n\r\nh2. parcare\r\n\r\nProblema este exponentiala in dimensiunea matricii, dar polinomiala in numarul total de posibilitati de pozitionare al masinilor. Astfel, vom folosi un algoritm de tip BFS care garanteaza ca se ajunge la solutie intr-un numar minim de miscari. Plecam de la matricea initiala, si expandam pe rand toate starile posibile, miscand din starea curenta cate o masina pana cand nu mai exista nici o varianta noua de pozitionare a masinilor sau pana cand am scos masina A din parcare. Starile problemei le putem codifica intr-un intreg de 64 de biti. Singurele variabile sunt pozitiile masinilor. Dupa ce eliminam zidurile inconjuratoare, coordonatele nu sunt mai mari decat 7 ( 3 biti ), deci pentru pozitia unei masini vom folosi 6 biti. Concatenam pozitiile masinilor si, cum sunt maxim 10 masini, codificarea nu va avea mai mult de 60 de biti.\r\n\r\nPentru a memora starile explorate vom folosi o tabela de hash. De precizat si ca numarul total de posibilitati pornind de la starea initiala este destul de redus, deci problema va rula aproape instantaneu.\r\n\r\n\r\n\r\neasy query\r\n\r\nUn algoritm simplu de complexitate O(N*M) obtine 30-50 de puncte. Algoritmul de 100 de puncte are complexitatea O(MlogN) si foloseste arbori de intervale. Considerand o secventa x[i] x[i+1]... x[j] este evident ca pentru ca elementele sirurilor y si z sa fie maxime, respectiv minime, ele trebuiesc construite astfel:\r\n\r\ny[t] = x[t] - min(x[k]) + max(x[p]), i <= t <= j, t <= k, p <= j\r\n\r\nz[t] = x[t] - max(x[k]) + min(x[p]), i <= t <= j, t <= k, p <= j.\r\n\r\nPentru a calcula in timp optim valoarea P = max(y) + min(z) ne vom folosi de un arbore de intervale in urmatorul mod: fiecare nod al acestuia va constitui o secventa x[st], x[st+1]... x[dr] ( unde st si dr sunt marginile intervalului din nodul arborelui ) pe care o vom rezolva prin metoda brute force de la inceput, avand grija sa precalculam si alte valori necesare mai tarziu, cum ar fi :\r\n\r\nmin = minim(x[st], x[st+1]... x[dr])\r\n\r\nmax = maxim(x[st], x[st+1]... x[dr])\r\n\r\nx_max_max = maxim(x[t] + maxim(x[p]) ),\r\n\r\nst <= t <= dr si t <= p <= dr\r\n\r\nx_max_min = minim(x[t] - maxim(x[p]) ),\r\n\r\nst <= t <= dr si t <= p <= dr\r\n\r\nx_min_max = maxim(x[t] - minim(x[p]) ),\r\n\r\nst <= t <= dr si t <= p <= dr\r\n\r\nx_min_min = minim(x[t] + minim(x[p]) ),\r\n\r\nst <= t <= dr si t <= p <= dr\r\n\r\ny_max = maximul din sirul y corespunzator secventei x[st], x[st+1]... x[dr]\r\n\r\nz_min = minimul din sirul z corespunzator secventei x[st], x[st+1]... x[dr]\r\n\r\nAvand precalculate valorile de mai sus pentru fiecare nod al arborelui in parte vom putea raspunde in timp O(logN) pentru fiecare din cele M intrebari. Fiecare subsecventa data x[i], x[i+1]... x[j] va putea fi compusa din reuniunea mai multor noduri din arborele de intervale. Acum parcurgem nodurile ce compun subsecventa data de la dreapta la stanga si vom gasi rapid valorile maxim(y) si minim(z). Presupunand ca am ajuns la nodul Q valoarea maxim(y) pana aici se calculeaza astfel:\r\n\r\nMAX(Y) = y_max(Q) = y_max_max(Q) - min(W) = x_min_max(Q)+max(W) = max(Q)+max(W)-min(W).\r\n\r\nAnalog se calculeaza si minim(z).\r\n\r\n',18,'public'),('summer-challenge-2/solutii','Solutii - Summer Challenge Doi','2006-11-18 13:21:35','h1. Solutii - Summer Challenge Doi\r\n\r\n(Creat de ==user(user=\"ditzonec\" type=\"tiny\")== la data de _2006-08-11_ categoria _Competitii_, autor(i) _Adrian Diaconu si Cosmin Negruseri_)\r\n\r\n ==Include(page=\"template/raw\")==\r\n\r\nh3. Sah\r\n\r\nPrima observatie ar fi ca pentru a ne asigura ca intr-o regiune numarul de casute albe este egal cu numarul de celule negre este suficient ca aria regiunii sa fie para.\r\nPlecand de la aceasta observatie si de la faptul ca N este mereu par propunem urmatoarea impartirea tablei si voi demonstra apoi ca indeplineste conditiile din enunt. Impartim tabla in benzi de latime 2 (pentru a asigura paritatea ariilor). Apoi prima banda o lasam intreaga, iar pentru urmatoarele banda i se va inmparti in i-1 si N-i+1. Astfel se vor creea N-1 regiuni. Se observa ca toate dreptunghiurile difera intre ele prin lungime deoarece se folosesc toate numerele de la 1 la N mai putin N/2.\r\n\r\nPentru a demonstra ca N-1 este numarul maxim de regiuni care se poate creea vom presupune ca se poate imparti tabla in N regiuni. Vom considera ca se folosesc cele mai mici arii posibile, dar acestea trebuie sa fie toate pare. Suma ariilor va fi 2+4+6+..+2*N= 2*(N*(N+1)/2)=N*N+N ceea ce ar depasi tabla noastra.\r\n\r\nPlimbare\r\n\r\nEvident ca o conditie necesara ca un graf turneu (asa se numesc grafurile ca cel mentionat in enunt in care exista exact un arc intre oricare doua noduri) sa aiba un circuit hamiltonean ar fi ca graful sa fie tare conex, daca nu ar fi tare conex atunci evident nu poate exista un circuit intre doua noduri aflate in doua componente tari conexe diferite. Aceasta conditie este si suficienta asa cum va reiesi din algoritmul pe care il vom explica mai jos.\r\n\r\nAstfel pentru graful nostru vom determina componentele tari conexe, si vom cauta un circuit hamiltonean in cea mai mare dintre acestea. De acum ne vom concentra doar asupra nodurilor acestei componente. Evident ca aceasta componenta conexa contine cel putin un circuit, pentru a determina unul facem o cautare in adancime, si trebuie sa gasim la un moment dat o muchie de intoarcere (pentru ca altfel componenta nu ar fi tare conexa). Vom imparti nodurile din aceasta componenta in patru multimi: A multimea nodurilor din circuit, B multimea nodurilor din afara circuitului pentru care exista si arce orientate de la noduri din circuit la ele, si arce orientate de la ele la noduri din circuit, C multimea nodurilor din afara circuitului pentru care exista numai arce ce pornesc din circuit inspre noduri, si D multimea nodurilor pentru care toate arcele intre ele si noduri din circuit sunt orientate de la ele inspre circuit. Puteti observa ca nodurile din multimea B pot fi inserate tot timpul in circuit undeva\r\ninlocuind un arc intre doua noduri ale circuitului cu doua arce de la un nod al circuitului la nodul multimii B si apoi la alt nod din circuit. Inserarea unui astfel de nod dureaza maxim O(n) pasi, alti O(n) pasi ar fi necesari pentru modificarea multimilor B, C, D pentru ca circuitul s-a schimbat. Dupa ce nu ne mai ramane nici un nod in B. Ramanem doar cu noduri de tip C sau D. Orice nod din multimea C va avea cel putin un arc orientat spre alt nod din multimea D pentru ca altfel nu am fi intr-o componenta tare conexa. Acum aceste doua noduri legate printr-o muchie dinspre C inspre D pot fi inserate in circuit. Astfel am aratat o cale practica de a mari lungimea circuitului pana cand epuizam toate nodurile.\r\n\r\nDaca folosim metoda de determinare a componentelor tari conexe folosind un algoritm eficient de complexitate O(N + M), atunci algoritmul are complexitatea O(N^2) pentru ca la fiecare inserare facem O(n) pasi. Un algoritm mai eficient nu putem obtine deoarece M = N(N-1)/2, deci si citirea datelor e O(N^2). N a fost fixat la 100 pentru ca am vrut sa punem accent asupra ideii de gasire a circuitului si nu asupra algoritmului de determinare eficienta a componentelor tari conexe.\r\n\r\n\r\n\r\nTreiD\r\n\r\nAceasta problema e similara cu problema [1]Bmatrix din arhiva si a fost propusa pentru a favoriza utilizatorii inraiti :).\r\n\r\nTrei dreptunghiuri pot avea ca amplasare relativa doar 6 pozitii diferite:\r\n\r\n  \r\n\r\n| | | | | | |\r\n\r\n +-- + + +\r\n\r\n| | | | | | | |\r\n\r\n + + + \r\n\r\n| | | | | | |\r\n\r\n  \r\n\r\nsi rotatiile cu 90 de grade ale acestora.\r\n\r\nPentru a determina pentru fiecare configuratie solutia optima putem incerca orice impartire posibila cu doua linii in trei zone a dreptunghiului initial. Apoi ne trebuie pentru fiecare dreptunghi de tipul [1..i]x[1..j], [1..i][j..m], [i..n]x[1..j], [i..n]x[j..m], [i..j]x[1..m] si [1..n]x[i..j].\r\n\r\nCa sa determinam suma numerelor din un dreptunghi [r1..r2]x[c1..c2] folosim o matrice B[i][j] care e suma elementelor din [1..i]x[1..j], avand aceasta matrice calculata putem determina ca suma elementelor din dreptunghiul [r1..r2]x[c1..c2] este B[r2][c2] - B[r1 - 1][c2] - B[r2][c2 - 1] + B[r1 - 1][c1 - 1]. Pentru a calcula B[i][j] eficient parcurgem elementele matricii initiale A in ordine si avem ca B[i][j] = A[i][j] + B[i][j - 1] + B[i- 1][j] - B[i-1][j-1].\r\n\r\nVom explica cum determinam submatricea optima pentru dreptunghiul [i..j]x[1..m] in O(n), celelalte dreptunghiuri putand fi determinate intr-un mod asemanator. Avem trei cazuri posibile: linia de sus a dreptunghiului optim nu coincide cu linia i, si astfel putem lua informatia despre el din rezultatul calculului pentru dreptunghiul [i+1..j]x[1..m], al doilea caz e cand linia de jos nu coincide cu linia j, acum luam rezultatul optim pentru dreptunghiul [i..j-1]x[1..m]. Al treilea caz cand dreptunghiul optim se sprijina pe liniile i si j il putem rezolva in O(n) asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector C. C[k] va fi egal cu suma elementelor din dreptunghiul [i..j] x [k..k] (deci suma elementelor din banda [i..j] ce sunt pe coloana k).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului C, vom folosi vectorul sum[k] = C[k] + C[k-1] + ... + C[1]. Astfel suma elementelor C[k..l] este egala cu sum[l] - sum[k - 1]. Pentru a determina subsecventa de suma maxima ce se termina in l trebuie sa gasim cea mai mica sum[k - 1] pentru a maximiza expresia sum[l] - sum[k - 1]. Astfel obtinem urmatorul cod:\r\n\r\nint min_sum = 0;\r\n\r\nint best = - infinit;\r\n\r\nfor (int k = 0; k < m; k++) {\r\n\r\nif (best < sum[l] - min_sum)\r\n\r\nbest = sum[l] - min_sum;\r\n\r\nif (sum[l] < min_sum) min_sum = sum[l];\r\n\r\n}\r\n\r\nreturn best;\r\n\r\nAcest algoritm are complexitatea O(n).\r\n\r\nAstfel algoritmul calculeaza in O(n) valoarea optima pentru O(n^2) zone, deci in total avem un algoritm ce consuma O(n^2) memorie si are complexitatea O(n^3) ca timp.\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix\r\n\r\n',48,'public'),('summer-challenge-2/solutii','Solutii - Summer Challenge Doi','2006-11-18 13:33:51','h1. Solutii - Summer Challenge Doi\r\n\r\n(Creat de ==user(user=\"ditzonec\" type=\"tiny\")== la data de _2006-08-11_ categoria _Competitii_, autor(i) _Adrian Diaconu si Cosmin Negruseri_)\r\n\r\n ==Include(page=\"template/raw\")==\r\n\r\nh2. Sah\r\n\r\nPrima observatie ar fi ca pentru a ne asigura ca intr-o regiune numarul de casute albe este egal cu numarul de celule negre este suficient ca aria regiunii sa fie para.\r\nPlecand de la aceasta observatie si de la faptul ca $N$ este mereu par propunem urmatoarea impartirea tablei si voi demonstra apoi ca indeplineste conditiile din enunt. Impartim tabla in benzi de latime $2$ (pentru a asigura paritatea ariilor). Apoi prima banda o lasam intreaga, iar pentru urmatoarele banda $i$ se va inmparti in $i-1$ si $N-i+1$. Astfel se vor creea $N-1$ regiuni. Se observa ca toate dreptunghiurile difera intre ele prin lungime deoarece se folosesc toate numerele de la $1$ la $N$ mai putin $N/2$.\r\nPentru a demonstra ca $N-1$ este numarul maxim de regiuni care se poate creea vom presupune ca se poate imparti tabla in $N$ regiuni. Vom considera ca se folosesc cele mai mici arii posibile, dar acestea trebuie sa fie toate pare. Suma ariilor va fi $2+4+6+..+2*N= 2*(N*(N+1)/2)=N*N+N$ ceea ce ar depasi tabla noastra.\r\n\r\nh2. Plimbare\r\n\r\nEvident ca o conditie necesara ca un graf turneu (asa se numesc grafurile ca cel mentionat in enunt in care exista exact un arc intre oricare doua noduri) sa aiba un circuit hamiltonean ar fi ca graful sa fie tare conex, daca nu ar fi tare conex atunci evident nu poate exista un circuit intre doua noduri aflate in doua componente tari conexe diferite. Aceasta conditie este si suficienta asa cum va reiesi din algoritmul pe care il vom explica mai jos.\r\nAstfel pentru graful nostru vom determina componentele tari conexe, si vom cauta un circuit hamiltonean in cea mai mare dintre acestea. De acum ne vom concentra doar asupra nodurilor acestei componente. Evident ca aceasta componenta conexa contine cel putin un circuit, pentru a determina unul facem o cautare in adancime, si trebuie sa gasim la un moment dat o muchie de intoarcere (pentru ca altfel componenta nu ar fi tare conexa). Vom imparti nodurile din aceasta componenta in patru multimi: $A$ multimea nodurilor din circuit, $B$ multimea nodurilor din afara circuitului pentru care exista si arce orientate de la noduri din circuit la ele, si arce orientate de la ele la noduri din circuit, $C$ multimea nodurilor din afara circuitului pentru care exista numai arce ce pornesc din circuit inspre noduri, si $D$ multimea nodurilor pentru care toate arcele intre ele si noduri din circuit sunt orientate de la ele inspre circuit. Puteti observa ca nodurile din multimea $B$ pot fi inserate tot timpul in circuit undeva inlocuind un arc intre doua noduri ale circuitului cu doua arce de la un nod al circuitului la nodul multimii $B$ si apoi la alt nod din circuit. Inserarea unui astfel de nod dureaza maxim $O(n)$ pasi, alti $O(n)$ pasi ar fi necesari pentru modificarea multimilor $B, C, D $ pentru ca circuitul s-a schimbat. Dupa ce nu ne mai ramane nici un nod in $B$. Ramanem doar cu noduri de tip $C$ sau $D$. Orice nod din multimea $C$ va avea cel putin un arc orientat spre alt nod din multimea $D$ pentru ca altfel nu am fi intr-o componenta tare conexa. Acum aceste doua noduri legate printr-o muchie dinspre $C$ inspre $D$ pot fi inserate in circuit. Astfel am aratat o cale practica de a mari lungimea circuitului pana cand epuizam toate nodurile.\r\nDaca folosim metoda de determinare a componentelor tari conexe folosind un algoritm eficient de complexitate $O(N + M)$, atunci algoritmul are complexitatea $O(N^2)$ pentru ca la fiecare inserare facem $O(n)$ pasi. Un algoritm mai eficient nu putem obtine deoarece $M = N(N-1)/2$, deci si citirea datelor e $O(N^2)$. N a fost fixat la $100$ pentru ca am vrut sa punem accent asupra ideii de gasire a circuitului si nu asupra algoritmului de determinare eficienta a componentelor tari conexe.\r\n\r\nh2.TreiD\r\n\r\nAceasta problema e similara cu problema \"Bmatrix\":http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix din arhiva si a fost propusa pentru a favoriza utilizatorii inraiti :).\r\n\r\nTrei dreptunghiuri pot avea ca amplasare relativa doar 6 pozitii diferite:\r\n\r\n  \r\n\r\n| | | | | | |\r\n\r\n +-- + + +\r\n\r\n| | | | | | | |\r\n\r\n + + + \r\n\r\n| | | | | | |\r\n\r\n  \r\n\r\nsi rotatiile cu 90 de grade ale acestora.\r\n\r\nPentru a determina pentru fiecare configuratie solutia optima putem incerca orice impartire posibila cu doua linii in trei zone a dreptunghiului initial. Apoi ne trebuie pentru fiecare dreptunghi de tipul [1..i]x[1..j], [1..i][j..m], [i..n]x[1..j], [i..n]x[j..m], [i..j]x[1..m] si [1..n]x[i..j].\r\n\r\nCa sa determinam suma numerelor din un dreptunghi [r1..r2]x[c1..c2] folosim o matrice B[i][j] care e suma elementelor din [1..i]x[1..j], avand aceasta matrice calculata putem determina ca suma elementelor din dreptunghiul [r1..r2]x[c1..c2] este B[r2][c2] - B[r1 - 1][c2] - B[r2][c2 - 1] + B[r1 - 1][c1 - 1]. Pentru a calcula B[i][j] eficient parcurgem elementele matricii initiale A in ordine si avem ca B[i][j] = A[i][j] + B[i][j - 1] + B[i- 1][j] - B[i-1][j-1].\r\n\r\nVom explica cum determinam submatricea optima pentru dreptunghiul [i..j]x[1..m] in O(n), celelalte dreptunghiuri putand fi determinate intr-un mod asemanator. Avem trei cazuri posibile: linia de sus a dreptunghiului optim nu coincide cu linia i, si astfel putem lua informatia despre el din rezultatul calculului pentru dreptunghiul [i+1..j]x[1..m], al doilea caz e cand linia de jos nu coincide cu linia j, acum luam rezultatul optim pentru dreptunghiul [i..j-1]x[1..m]. Al treilea caz cand dreptunghiul optim se sprijina pe liniile i si j il putem rezolva in O(n) asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector C. C[k] va fi egal cu suma elementelor din dreptunghiul [i..j] x [k..k] (deci suma elementelor din banda [i..j] ce sunt pe coloana k).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului C, vom folosi vectorul sum[k] = C[k] + C[k-1] + ... + C[1]. Astfel suma elementelor C[k..l] este egala cu sum[l] - sum[k - 1]. Pentru a determina subsecventa de suma maxima ce se termina in l trebuie sa gasim cea mai mica sum[k - 1] pentru a maximiza expresia sum[l] - sum[k - 1]. Astfel obtinem urmatorul cod:\r\n\r\nint min_sum = 0;\r\n\r\nint best = - infinit;\r\n\r\nfor (int k = 0; k < m; k++) {\r\n\r\nif (best < sum[l] - min_sum)\r\n\r\nbest = sum[l] - min_sum;\r\n\r\nif (sum[l] < min_sum) min_sum = sum[l];\r\n\r\n}\r\n\r\nreturn best;\r\n\r\nAcest algoritm are complexitatea O(n).\r\n\r\nAstfel algoritmul calculeaza in O(n) valoarea optima pentru O(n^2) zone, deci in total avem un algoritm ce consuma O(n^2) memorie si are complexitatea O(n^3) ca timp.\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix\r\n\r\n',48,'public'),('summer-challenge-2/solutii','Solutii - Summer Challenge Doi','2006-11-18 13:50:47','h1. Solutii - Summer Challenge Doi\r\n\r\n(Creat de ==user(user=\"ditzonec\" type=\"tiny\")== la data de _2006-08-11_ categoria _Competitii_, autor(i) _Adrian Diaconu si Cosmin Negruseri_)\r\n\r\n ==Include(page=\"template/raw\")==\r\n\r\nh2. Sah\r\n\r\nPrima observatie ar fi ca pentru a ne asigura ca intr-o regiune numarul de casute albe este egal cu numarul de celule negre este suficient ca aria regiunii sa fie para.\r\nPlecand de la aceasta observatie si de la faptul ca $N$ este mereu par propunem urmatoarea impartirea tablei si voi demonstra apoi ca indeplineste conditiile din enunt. Impartim tabla in benzi de latime $2$ (pentru a asigura paritatea ariilor). Apoi prima banda o lasam intreaga, iar pentru urmatoarele banda $i$ se va inmparti in $i-1$ si $N-i+1$. Astfel se vor creea $N-1$ regiuni. Se observa ca toate dreptunghiurile difera intre ele prin lungime deoarece se folosesc toate numerele de la $1$ la $N$ mai putin $N/2$.\r\nPentru a demonstra ca $N-1$ este numarul maxim de regiuni care se poate creea vom presupune ca se poate imparti tabla in $N$ regiuni. Vom considera ca se folosesc cele mai mici arii posibile, dar acestea trebuie sa fie toate pare. Suma ariilor va fi $2+4+6+..+2*N= 2*(N*(N+1)/2)=N*N+N$ ceea ce ar depasi tabla noastra.\r\n\r\nh2. Plimbare\r\n\r\nEvident ca o conditie necesara ca un graf turneu (asa se numesc grafurile ca cel mentionat in enunt in care exista exact un arc intre oricare doua noduri) sa aiba un circuit hamiltonean ar fi ca graful sa fie tare conex, daca nu ar fi tare conex atunci evident nu poate exista un circuit intre doua noduri aflate in doua componente tari conexe diferite. Aceasta conditie este si suficienta asa cum va reiesi din algoritmul pe care il vom explica mai jos.\r\nAstfel pentru graful nostru vom determina componentele tari conexe, si vom cauta un circuit hamiltonean in cea mai mare dintre acestea. De acum ne vom concentra doar asupra nodurilor acestei componente. Evident ca aceasta componenta conexa contine cel putin un circuit, pentru a determina unul facem o cautare in adancime, si trebuie sa gasim la un moment dat o muchie de intoarcere (pentru ca altfel componenta nu ar fi tare conexa). Vom imparti nodurile din aceasta componenta in patru multimi: $A$ multimea nodurilor din circuit, $B$ multimea nodurilor din afara circuitului pentru care exista si arce orientate de la noduri din circuit la ele, si arce orientate de la ele la noduri din circuit, $C$ multimea nodurilor din afara circuitului pentru care exista numai arce ce pornesc din circuit inspre noduri, si $D$ multimea nodurilor pentru care toate arcele intre ele si noduri din circuit sunt orientate de la ele inspre circuit. Puteti observa ca nodurile din multimea $B$ pot fi inserate tot timpul in circuit undeva inlocuind un arc intre doua noduri ale circuitului cu doua arce de la un nod al circuitului la nodul multimii $B$ si apoi la alt nod din circuit. Inserarea unui astfel de nod dureaza maxim $O(n)$ pasi, alti $O(n)$ pasi ar fi necesari pentru modificarea multimilor $B, C, D $ pentru ca circuitul s-a schimbat. Dupa ce nu ne mai ramane nici un nod in $B$. Ramanem doar cu noduri de tip $C$ sau $D$. Orice nod din multimea $C$ va avea cel putin un arc orientat spre alt nod din multimea $D$ pentru ca altfel nu am fi intr-o componenta tare conexa. Acum aceste doua noduri legate printr-o muchie dinspre $C$ inspre $D$ pot fi inserate in circuit. Astfel am aratat o cale practica de a mari lungimea circuitului pana cand epuizam toate nodurile.\r\nDaca folosim metoda de determinare a componentelor tari conexe folosind un algoritm eficient de complexitate $O(N + M)$, atunci algoritmul are complexitatea $O(N^2^)$ pentru ca la fiecare inserare facem $O(n)$ pasi. Un algoritm mai eficient nu putem obtine deoarece $M = N(N-1)/2$, deci si citirea datelor e $O(N^2^)$. N a fost fixat la $100$ pentru ca am vrut sa punem accent asupra ideii de gasire a circuitului si nu asupra algoritmului de determinare eficienta a componentelor tari conexe.\r\n\r\nh2. TreiD\r\n\r\nAceasta problema e similara cu problema \"Bmatrix\":http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix din arhiva si a fost propusa pentru a favoriza utilizatorii inraiti :).\r\nTrei dreptunghiuri pot avea ca amplasare relativa doar 6 pozitii diferite:\r\n\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$ \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      {@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n+------+    +--+---+     +  +   +\r\n|      |    |  |   |     |  |   |\r\n+------+    +  +   +     +------+          \r\n|      |    |  |   |     |      |\r\n+------+    +------+     +------+\r\n\r\n  \r\nsi rotatiile cu 90 de grade ale acestora.\r\n\r\nPentru a determina pentru fiecare configuratie solutia optima putem incerca orice impartire posibila cu doua linii in trei zone a dreptunghiului initial. Apoi ne trebuie pentru fiecare dreptunghi de tipul [1..i]x[1..j], [1..i][j..m], [i..n]x[1..j], [i..n]x[j..m], [i..j]x[1..m] si [1..n]x[i..j].\r\n\r\nCa sa determinam suma numerelor din un dreptunghi [r1..r2]x[c1..c2] folosim o matrice B[i][j] care e suma elementelor din [1..i]x[1..j], avand aceasta matrice calculata putem determina ca suma elementelor din dreptunghiul [r1..r2]x[c1..c2] este B[r2][c2] - B[r1 - 1][c2] - B[r2][c2 - 1] + B[r1 - 1][c1 - 1]. Pentru a calcula B[i][j] eficient parcurgem elementele matricii initiale A in ordine si avem ca B[i][j] = A[i][j] + B[i][j - 1] + B[i- 1][j] - B[i-1][j-1].\r\n\r\nVom explica cum determinam submatricea optima pentru dreptunghiul [i..j]x[1..m] in O(n), celelalte dreptunghiuri putand fi determinate intr-un mod asemanator. Avem trei cazuri posibile: linia de sus a dreptunghiului optim nu coincide cu linia i, si astfel putem lua informatia despre el din rezultatul calculului pentru dreptunghiul [i+1..j]x[1..m], al doilea caz e cand linia de jos nu coincide cu linia j, acum luam rezultatul optim pentru dreptunghiul [i..j-1]x[1..m]. Al treilea caz cand dreptunghiul optim se sprijina pe liniile i si j il putem rezolva in O(n) asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector C. C[k] va fi egal cu suma elementelor din dreptunghiul [i..j] x [k..k] (deci suma elementelor din banda [i..j] ce sunt pe coloana k).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului C, vom folosi vectorul sum[k] = C[k] + C[k-1] + ... + C[1]. Astfel suma elementelor C[k..l] este egala cu sum[l] - sum[k - 1]. Pentru a determina subsecventa de suma maxima ce se termina in l trebuie sa gasim cea mai mica sum[k - 1] pentru a maximiza expresia sum[l] - sum[k - 1]. Astfel obtinem urmatorul cod:\r\n\r\nint min_sum = 0;\r\n\r\nint best = - infinit;\r\n\r\nfor (int k = 0; k < m; k++) {\r\n\r\nif (best < sum[l] - min_sum)\r\n\r\nbest = sum[l] - min_sum;\r\n\r\nif (sum[l] < min_sum) min_sum = sum[l];\r\n\r\n}\r\n\r\nreturn best;\r\n\r\nAcest algoritm are complexitatea O(n).\r\n\r\nAstfel algoritmul calculeaza in O(n) valoarea optima pentru O(n^2) zone, deci in total avem un algoritm ce consuma O(n^2) memorie si are complexitatea O(n^3) ca timp.\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix\r\n\r\n',48,'public'),('summer-challenge-2/solutii','Solutii - Summer Challenge Doi','2006-11-18 14:03:40','h1. Solutii - Summer Challenge Doi\r\n\r\n(Creat de ==user(user=\"ditzonec\" type=\"tiny\")== la data de _2006-08-11_ categoria _Competitii_, autor(i) _Adrian Diaconu si Cosmin Negruseri_)\r\n\r\n ==Include(page=\"template/raw\")==\r\n\r\nh2. Sah\r\n\r\nPrima observatie ar fi ca pentru a ne asigura ca intr-o regiune numarul de casute albe este egal cu numarul de celule negre este suficient ca aria regiunii sa fie para.\r\nPlecand de la aceasta observatie si de la faptul ca $N$ este mereu par propunem urmatoarea impartirea tablei si voi demonstra apoi ca indeplineste conditiile din enunt. Impartim tabla in benzi de latime $2$ (pentru a asigura paritatea ariilor). Apoi prima banda o lasam intreaga, iar pentru urmatoarele banda $i$ se va inmparti in $i-1$ si $N-i+1$. Astfel se vor creea $N-1$ regiuni. Se observa ca toate dreptunghiurile difera intre ele prin lungime deoarece se folosesc toate numerele de la $1$ la $N$ mai putin $N/2$.\r\nPentru a demonstra ca $N-1$ este numarul maxim de regiuni care se poate creea vom presupune ca se poate imparti tabla in $N$ regiuni. Vom considera ca se folosesc cele mai mici arii posibile, dar acestea trebuie sa fie toate pare. Suma ariilor va fi $2+4+6+..+2*N= 2*(N*(N+1)/2)=N*N+N$ ceea ce ar depasi tabla noastra.\r\n\r\nh2. Plimbare\r\n\r\nEvident ca o conditie necesara ca un graf turneu (asa se numesc grafurile ca cel mentionat in enunt in care exista exact un arc intre oricare doua noduri) sa aiba un circuit hamiltonean ar fi ca graful sa fie tare conex, daca nu ar fi tare conex atunci evident nu poate exista un circuit intre doua noduri aflate in doua componente tari conexe diferite. Aceasta conditie este si suficienta asa cum va reiesi din algoritmul pe care il vom explica mai jos.\r\nAstfel pentru graful nostru vom determina componentele tari conexe, si vom cauta un circuit hamiltonean in cea mai mare dintre acestea. De acum ne vom concentra doar asupra nodurilor acestei componente. Evident ca aceasta componenta conexa contine cel putin un circuit, pentru a determina unul facem o cautare in adancime, si trebuie sa gasim la un moment dat o muchie de intoarcere (pentru ca altfel componenta nu ar fi tare conexa). Vom imparti nodurile din aceasta componenta in patru multimi: $A$ multimea nodurilor din circuit, $B$ multimea nodurilor din afara circuitului pentru care exista si arce orientate de la noduri din circuit la ele, si arce orientate de la ele la noduri din circuit, $C$ multimea nodurilor din afara circuitului pentru care exista numai arce ce pornesc din circuit inspre noduri, si $D$ multimea nodurilor pentru care toate arcele intre ele si noduri din circuit sunt orientate de la ele inspre circuit. Puteti observa ca nodurile din multimea $B$ pot fi inserate tot timpul in circuit undeva inlocuind un arc intre doua noduri ale circuitului cu doua arce de la un nod al circuitului la nodul multimii $B$ si apoi la alt nod din circuit. Inserarea unui astfel de nod dureaza maxim $O(n)$ pasi, alti $O(n)$ pasi ar fi necesari pentru modificarea multimilor $B, C, D $ pentru ca circuitul s-a schimbat. Dupa ce nu ne mai ramane nici un nod in $B$. Ramanem doar cu noduri de tip $C$ sau $D$. Orice nod din multimea $C$ va avea cel putin un arc orientat spre alt nod din multimea $D$ pentru ca altfel nu am fi intr-o componenta tare conexa. Acum aceste doua noduri legate printr-o muchie dinspre $C$ inspre $D$ pot fi inserate in circuit. Astfel am aratat o cale practica de a mari lungimea circuitului pana cand epuizam toate nodurile.\r\nDaca folosim metoda de determinare a componentelor tari conexe folosind un algoritm eficient de complexitate $O(N + M)$, atunci algoritmul are complexitatea $O(N^2^)$ pentru ca la fiecare inserare facem $O(n)$ pasi. Un algoritm mai eficient nu putem obtine deoarece $M = N(N-1)/2$, deci si citirea datelor e $O(N^2^)$. N a fost fixat la $100$ pentru ca am vrut sa punem accent asupra ideii de gasire a circuitului si nu asupra algoritmului de determinare eficienta a componentelor tari conexe.\r\n\r\nh2. TreiD\r\n\r\nAceasta problema e similara cu problema \"Bmatrix\":http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix din arhiva si a fost propusa pentru a favoriza utilizatorii inraiti :).\r\nTrei dreptunghiuri pot avea ca amplasare relativa doar 6 pozitii diferite:\r\n\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$ \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}--{@+@}---{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@} &nbsp;&nbsp;{@+@}$\r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@} &nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$          \r\n{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}$\r\n+------+    +------+     +------+\r\n\r\n  \r\nsi rotatiile cu 90 de grade ale acestora.\r\n\r\nPentru a determina pentru fiecare configuratie solutia optima putem incerca orice impartire posibila cu doua linii in trei zone a dreptunghiului initial. Apoi ne trebuie pentru fiecare dreptunghi de tipul [1..i]x[1..j], [1..i][j..m], [i..n]x[1..j], [i..n]x[j..m], [i..j]x[1..m] si [1..n]x[i..j].\r\n\r\nCa sa determinam suma numerelor din un dreptunghi [r1..r2]x[c1..c2] folosim o matrice B[i][j] care e suma elementelor din [1..i]x[1..j], avand aceasta matrice calculata putem determina ca suma elementelor din dreptunghiul [r1..r2]x[c1..c2] este B[r2][c2] - B[r1 - 1][c2] - B[r2][c2 - 1] + B[r1 - 1][c1 - 1]. Pentru a calcula B[i][j] eficient parcurgem elementele matricii initiale A in ordine si avem ca B[i][j] = A[i][j] + B[i][j - 1] + B[i- 1][j] - B[i-1][j-1].\r\n\r\nVom explica cum determinam submatricea optima pentru dreptunghiul [i..j]x[1..m] in O(n), celelalte dreptunghiuri putand fi determinate intr-un mod asemanator. Avem trei cazuri posibile: linia de sus a dreptunghiului optim nu coincide cu linia i, si astfel putem lua informatia despre el din rezultatul calculului pentru dreptunghiul [i+1..j]x[1..m], al doilea caz e cand linia de jos nu coincide cu linia j, acum luam rezultatul optim pentru dreptunghiul [i..j-1]x[1..m]. Al treilea caz cand dreptunghiul optim se sprijina pe liniile i si j il putem rezolva in O(n) asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector C. C[k] va fi egal cu suma elementelor din dreptunghiul [i..j] x [k..k] (deci suma elementelor din banda [i..j] ce sunt pe coloana k).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului C, vom folosi vectorul sum[k] = C[k] + C[k-1] + ... + C[1]. Astfel suma elementelor C[k..l] este egala cu sum[l] - sum[k - 1]. Pentru a determina subsecventa de suma maxima ce se termina in l trebuie sa gasim cea mai mica sum[k - 1] pentru a maximiza expresia sum[l] - sum[k - 1]. Astfel obtinem urmatorul cod:\r\n\r\nint min_sum = 0;\r\n\r\nint best = - infinit;\r\n\r\nfor (int k = 0; k < m; k++) {\r\n\r\nif (best < sum[l] - min_sum)\r\n\r\nbest = sum[l] - min_sum;\r\n\r\nif (sum[l] < min_sum) min_sum = sum[l];\r\n\r\n}\r\n\r\nreturn best;\r\n\r\nAcest algoritm are complexitatea O(n).\r\n\r\nAstfel algoritmul calculeaza in O(n) valoarea optima pentru O(n^2) zone, deci in total avem un algoritm ce consuma O(n^2) memorie si are complexitatea O(n^3) ca timp.\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix\r\n\r\n',48,'public'),('summer-challenge-2/solutii','Solutii - Summer Challenge Doi','2006-11-18 14:04:01','h1. Solutii - Summer Challenge Doi\r\n\r\n(Creat de ==user(user=\"ditzonec\" type=\"tiny\")== la data de _2006-08-11_ categoria _Competitii_, autor(i) _Adrian Diaconu si Cosmin Negruseri_)\r\n\r\n ==Include(page=\"template/raw\")==\r\n\r\nh2. Sah\r\n\r\nPrima observatie ar fi ca pentru a ne asigura ca intr-o regiune numarul de casute albe este egal cu numarul de celule negre este suficient ca aria regiunii sa fie para.\r\nPlecand de la aceasta observatie si de la faptul ca $N$ este mereu par propunem urmatoarea impartirea tablei si voi demonstra apoi ca indeplineste conditiile din enunt. Impartim tabla in benzi de latime $2$ (pentru a asigura paritatea ariilor). Apoi prima banda o lasam intreaga, iar pentru urmatoarele banda $i$ se va inmparti in $i-1$ si $N-i+1$. Astfel se vor creea $N-1$ regiuni. Se observa ca toate dreptunghiurile difera intre ele prin lungime deoarece se folosesc toate numerele de la $1$ la $N$ mai putin $N/2$.\r\nPentru a demonstra ca $N-1$ este numarul maxim de regiuni care se poate creea vom presupune ca se poate imparti tabla in $N$ regiuni. Vom considera ca se folosesc cele mai mici arii posibile, dar acestea trebuie sa fie toate pare. Suma ariilor va fi $2+4+6+..+2*N= 2*(N*(N+1)/2)=N*N+N$ ceea ce ar depasi tabla noastra.\r\n\r\nh2. Plimbare\r\n\r\nEvident ca o conditie necesara ca un graf turneu (asa se numesc grafurile ca cel mentionat in enunt in care exista exact un arc intre oricare doua noduri) sa aiba un circuit hamiltonean ar fi ca graful sa fie tare conex, daca nu ar fi tare conex atunci evident nu poate exista un circuit intre doua noduri aflate in doua componente tari conexe diferite. Aceasta conditie este si suficienta asa cum va reiesi din algoritmul pe care il vom explica mai jos.\r\nAstfel pentru graful nostru vom determina componentele tari conexe, si vom cauta un circuit hamiltonean in cea mai mare dintre acestea. De acum ne vom concentra doar asupra nodurilor acestei componente. Evident ca aceasta componenta conexa contine cel putin un circuit, pentru a determina unul facem o cautare in adancime, si trebuie sa gasim la un moment dat o muchie de intoarcere (pentru ca altfel componenta nu ar fi tare conexa). Vom imparti nodurile din aceasta componenta in patru multimi: $A$ multimea nodurilor din circuit, $B$ multimea nodurilor din afara circuitului pentru care exista si arce orientate de la noduri din circuit la ele, si arce orientate de la ele la noduri din circuit, $C$ multimea nodurilor din afara circuitului pentru care exista numai arce ce pornesc din circuit inspre noduri, si $D$ multimea nodurilor pentru care toate arcele intre ele si noduri din circuit sunt orientate de la ele inspre circuit. Puteti observa ca nodurile din multimea $B$ pot fi inserate tot timpul in circuit undeva inlocuind un arc intre doua noduri ale circuitului cu doua arce de la un nod al circuitului la nodul multimii $B$ si apoi la alt nod din circuit. Inserarea unui astfel de nod dureaza maxim $O(n)$ pasi, alti $O(n)$ pasi ar fi necesari pentru modificarea multimilor $B, C, D $ pentru ca circuitul s-a schimbat. Dupa ce nu ne mai ramane nici un nod in $B$. Ramanem doar cu noduri de tip $C$ sau $D$. Orice nod din multimea $C$ va avea cel putin un arc orientat spre alt nod din multimea $D$ pentru ca altfel nu am fi intr-o componenta tare conexa. Acum aceste doua noduri legate printr-o muchie dinspre $C$ inspre $D$ pot fi inserate in circuit. Astfel am aratat o cale practica de a mari lungimea circuitului pana cand epuizam toate nodurile.\r\nDaca folosim metoda de determinare a componentelor tari conexe folosind un algoritm eficient de complexitate $O(N + M)$, atunci algoritmul are complexitatea $O(N^2^)$ pentru ca la fiecare inserare facem $O(n)$ pasi. Un algoritm mai eficient nu putem obtine deoarece $M = N(N-1)/2$, deci si citirea datelor e $O(N^2^)$. N a fost fixat la $100$ pentru ca am vrut sa punem accent asupra ideii de gasire a circuitului si nu asupra algoritmului de determinare eficienta a componentelor tari conexe.\r\n\r\nh2. TreiD\r\n\r\nAceasta problema e similara cu problema \"Bmatrix\":http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix din arhiva si a fost propusa pentru a favoriza utilizatorii inraiti :).\r\nTrei dreptunghiuri pot avea ca amplasare relativa doar 6 pozitii diferite:\r\n\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$ \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}--{@+@}---{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@} &nbsp;&nbsp;{@+@}$\r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@} &nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$          \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}$\r\n+------+    +------+     +------+\r\n\r\n  \r\nsi rotatiile cu 90 de grade ale acestora.\r\n\r\nPentru a determina pentru fiecare configuratie solutia optima putem incerca orice impartire posibila cu doua linii in trei zone a dreptunghiului initial. Apoi ne trebuie pentru fiecare dreptunghi de tipul [1..i]x[1..j], [1..i][j..m], [i..n]x[1..j], [i..n]x[j..m], [i..j]x[1..m] si [1..n]x[i..j].\r\n\r\nCa sa determinam suma numerelor din un dreptunghi [r1..r2]x[c1..c2] folosim o matrice B[i][j] care e suma elementelor din [1..i]x[1..j], avand aceasta matrice calculata putem determina ca suma elementelor din dreptunghiul [r1..r2]x[c1..c2] este B[r2][c2] - B[r1 - 1][c2] - B[r2][c2 - 1] + B[r1 - 1][c1 - 1]. Pentru a calcula B[i][j] eficient parcurgem elementele matricii initiale A in ordine si avem ca B[i][j] = A[i][j] + B[i][j - 1] + B[i- 1][j] - B[i-1][j-1].\r\n\r\nVom explica cum determinam submatricea optima pentru dreptunghiul [i..j]x[1..m] in O(n), celelalte dreptunghiuri putand fi determinate intr-un mod asemanator. Avem trei cazuri posibile: linia de sus a dreptunghiului optim nu coincide cu linia i, si astfel putem lua informatia despre el din rezultatul calculului pentru dreptunghiul [i+1..j]x[1..m], al doilea caz e cand linia de jos nu coincide cu linia j, acum luam rezultatul optim pentru dreptunghiul [i..j-1]x[1..m]. Al treilea caz cand dreptunghiul optim se sprijina pe liniile i si j il putem rezolva in O(n) asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector C. C[k] va fi egal cu suma elementelor din dreptunghiul [i..j] x [k..k] (deci suma elementelor din banda [i..j] ce sunt pe coloana k).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului C, vom folosi vectorul sum[k] = C[k] + C[k-1] + ... + C[1]. Astfel suma elementelor C[k..l] este egala cu sum[l] - sum[k - 1]. Pentru a determina subsecventa de suma maxima ce se termina in l trebuie sa gasim cea mai mica sum[k - 1] pentru a maximiza expresia sum[l] - sum[k - 1]. Astfel obtinem urmatorul cod:\r\n\r\nint min_sum = 0;\r\n\r\nint best = - infinit;\r\n\r\nfor (int k = 0; k < m; k++) {\r\n\r\nif (best < sum[l] - min_sum)\r\n\r\nbest = sum[l] - min_sum;\r\n\r\nif (sum[l] < min_sum) min_sum = sum[l];\r\n\r\n}\r\n\r\nreturn best;\r\n\r\nAcest algoritm are complexitatea O(n).\r\n\r\nAstfel algoritmul calculeaza in O(n) valoarea optima pentru O(n^2) zone, deci in total avem un algoritm ce consuma O(n^2) memorie si are complexitatea O(n^3) ca timp.\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix\r\n\r\n',48,'public'),('summer-challenge-2/solutii','Solutii - Summer Challenge Doi','2006-11-18 14:06:17','h1. Solutii - Summer Challenge Doi\r\n\r\n(Creat de ==user(user=\"ditzonec\" type=\"tiny\")== la data de _2006-08-11_ categoria _Competitii_, autor(i) _Adrian Diaconu si Cosmin Negruseri_)\r\n\r\n ==Include(page=\"template/raw\")==\r\n\r\nh2. Sah\r\n\r\nPrima observatie ar fi ca pentru a ne asigura ca intr-o regiune numarul de casute albe este egal cu numarul de celule negre este suficient ca aria regiunii sa fie para.\r\nPlecand de la aceasta observatie si de la faptul ca $N$ este mereu par propunem urmatoarea impartirea tablei si voi demonstra apoi ca indeplineste conditiile din enunt. Impartim tabla in benzi de latime $2$ (pentru a asigura paritatea ariilor). Apoi prima banda o lasam intreaga, iar pentru urmatoarele banda $i$ se va inmparti in $i-1$ si $N-i+1$. Astfel se vor creea $N-1$ regiuni. Se observa ca toate dreptunghiurile difera intre ele prin lungime deoarece se folosesc toate numerele de la $1$ la $N$ mai putin $N/2$.\r\nPentru a demonstra ca $N-1$ este numarul maxim de regiuni care se poate creea vom presupune ca se poate imparti tabla in $N$ regiuni. Vom considera ca se folosesc cele mai mici arii posibile, dar acestea trebuie sa fie toate pare. Suma ariilor va fi $2+4+6+..+2*N= 2*(N*(N+1)/2)=N*N+N$ ceea ce ar depasi tabla noastra.\r\n\r\nh2. Plimbare\r\n\r\nEvident ca o conditie necesara ca un graf turneu (asa se numesc grafurile ca cel mentionat in enunt in care exista exact un arc intre oricare doua noduri) sa aiba un circuit hamiltonean ar fi ca graful sa fie tare conex, daca nu ar fi tare conex atunci evident nu poate exista un circuit intre doua noduri aflate in doua componente tari conexe diferite. Aceasta conditie este si suficienta asa cum va reiesi din algoritmul pe care il vom explica mai jos.\r\nAstfel pentru graful nostru vom determina componentele tari conexe, si vom cauta un circuit hamiltonean in cea mai mare dintre acestea. De acum ne vom concentra doar asupra nodurilor acestei componente. Evident ca aceasta componenta conexa contine cel putin un circuit, pentru a determina unul facem o cautare in adancime, si trebuie sa gasim la un moment dat o muchie de intoarcere (pentru ca altfel componenta nu ar fi tare conexa). Vom imparti nodurile din aceasta componenta in patru multimi: $A$ multimea nodurilor din circuit, $B$ multimea nodurilor din afara circuitului pentru care exista si arce orientate de la noduri din circuit la ele, si arce orientate de la ele la noduri din circuit, $C$ multimea nodurilor din afara circuitului pentru care exista numai arce ce pornesc din circuit inspre noduri, si $D$ multimea nodurilor pentru care toate arcele intre ele si noduri din circuit sunt orientate de la ele inspre circuit. Puteti observa ca nodurile din multimea $B$ pot fi inserate tot timpul in circuit undeva inlocuind un arc intre doua noduri ale circuitului cu doua arce de la un nod al circuitului la nodul multimii $B$ si apoi la alt nod din circuit. Inserarea unui astfel de nod dureaza maxim $O(n)$ pasi, alti $O(n)$ pasi ar fi necesari pentru modificarea multimilor $B, C, D $ pentru ca circuitul s-a schimbat. Dupa ce nu ne mai ramane nici un nod in $B$. Ramanem doar cu noduri de tip $C$ sau $D$. Orice nod din multimea $C$ va avea cel putin un arc orientat spre alt nod din multimea $D$ pentru ca altfel nu am fi intr-o componenta tare conexa. Acum aceste doua noduri legate printr-o muchie dinspre $C$ inspre $D$ pot fi inserate in circuit. Astfel am aratat o cale practica de a mari lungimea circuitului pana cand epuizam toate nodurile.\r\nDaca folosim metoda de determinare a componentelor tari conexe folosind un algoritm eficient de complexitate $O(N + M)$, atunci algoritmul are complexitatea $O(N^2^)$ pentru ca la fiecare inserare facem $O(n)$ pasi. Un algoritm mai eficient nu putem obtine deoarece $M = N(N-1)/2$, deci si citirea datelor e $O(N^2^)$. N a fost fixat la $100$ pentru ca am vrut sa punem accent asupra ideii de gasire a circuitului si nu asupra algoritmului de determinare eficienta a componentelor tari conexe.\r\n\r\nh2. TreiD\r\n\r\nAceasta problema e similara cu problema \"Bmatrix\":http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix din arhiva si a fost propusa pentru a favoriza utilizatorii inraiti :).\r\nTrei dreptunghiuri pot avea ca amplasare relativa doar 6 pozitii diferite:\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$ \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}--{@+@}---{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@} &nbsp;&nbsp;{@+@}$\r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@} &nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$          \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$  \r\nsi rotatiile cu 90 de grade ale acestora.\r\nPentru a determina pentru fiecare configuratie solutia optima putem incerca orice impartire posibila cu doua linii in trei zone a dreptunghiului initial. Apoi ne trebuie pentru fiecare dreptunghi de tipul $[1..i]x[1..j], [1..i][j..m], [i..n]x[1..j], [i..n]x[j..m], [i..j]x[1..m] si [1..n]x[i..j]$.\r\n\r\nCa sa determinam suma numerelor din un dreptunghi [r1..r2]x[c1..c2] folosim o matrice B[i][j] care e suma elementelor din [1..i]x[1..j], avand aceasta matrice calculata putem determina ca suma elementelor din dreptunghiul [r1..r2]x[c1..c2] este B[r2][c2] - B[r1 - 1][c2] - B[r2][c2 - 1] + B[r1 - 1][c1 - 1]. Pentru a calcula B[i][j] eficient parcurgem elementele matricii initiale A in ordine si avem ca B[i][j] = A[i][j] + B[i][j - 1] + B[i- 1][j] - B[i-1][j-1].\r\n\r\nVom explica cum determinam submatricea optima pentru dreptunghiul [i..j]x[1..m] in O(n), celelalte dreptunghiuri putand fi determinate intr-un mod asemanator. Avem trei cazuri posibile: linia de sus a dreptunghiului optim nu coincide cu linia i, si astfel putem lua informatia despre el din rezultatul calculului pentru dreptunghiul [i+1..j]x[1..m], al doilea caz e cand linia de jos nu coincide cu linia j, acum luam rezultatul optim pentru dreptunghiul [i..j-1]x[1..m]. Al treilea caz cand dreptunghiul optim se sprijina pe liniile i si j il putem rezolva in O(n) asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector C. C[k] va fi egal cu suma elementelor din dreptunghiul [i..j] x [k..k] (deci suma elementelor din banda [i..j] ce sunt pe coloana k).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului C, vom folosi vectorul sum[k] = C[k] + C[k-1] + ... + C[1]. Astfel suma elementelor C[k..l] este egala cu sum[l] - sum[k - 1]. Pentru a determina subsecventa de suma maxima ce se termina in l trebuie sa gasim cea mai mica sum[k - 1] pentru a maximiza expresia sum[l] - sum[k - 1]. Astfel obtinem urmatorul cod:\r\n\r\nint min_sum = 0;\r\n\r\nint best = - infinit;\r\n\r\nfor (int k = 0; k < m; k++) {\r\n\r\nif (best < sum[l] - min_sum)\r\n\r\nbest = sum[l] - min_sum;\r\n\r\nif (sum[l] < min_sum) min_sum = sum[l];\r\n\r\n}\r\n\r\nreturn best;\r\n\r\nAcest algoritm are complexitatea O(n).\r\n\r\nAstfel algoritmul calculeaza in O(n) valoarea optima pentru O(n^2) zone, deci in total avem un algoritm ce consuma O(n^2) memorie si are complexitatea O(n^3) ca timp.\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix\r\n\r\n',48,'public'),('summer-challenge-2/solutii','Solutii - Summer Challenge Doi','2006-11-18 14:11:32','h1. Solutii - Summer Challenge Doi\r\n\r\n(Creat de ==user(user=\"ditzonec\" type=\"tiny\")== la data de _2006-08-11_ categoria _Competitii_, autor(i) _Adrian Diaconu si Cosmin Negruseri_)\r\n\r\nh2. Sah\r\n\r\nPrima observatie ar fi ca pentru a ne asigura ca intr-o regiune numarul de casute albe este egal cu numarul de celule negre este suficient ca aria regiunii sa fie para.\r\nPlecand de la aceasta observatie si de la faptul ca $N$ este mereu par propunem urmatoarea impartirea tablei si voi demonstra apoi ca indeplineste conditiile din enunt. Impartim tabla in benzi de latime $2$ (pentru a asigura paritatea ariilor). Apoi prima banda o lasam intreaga, iar pentru urmatoarele banda $i$ se va inmparti in $i-1$ si $N-i+1$. Astfel se vor creea $N-1$ regiuni. Se observa ca toate dreptunghiurile difera intre ele prin lungime deoarece se folosesc toate numerele de la $1$ la $N$ mai putin $N/2$.\r\nPentru a demonstra ca $N-1$ este numarul maxim de regiuni care se poate creea vom presupune ca se poate imparti tabla in $N$ regiuni. Vom considera ca se folosesc cele mai mici arii posibile, dar acestea trebuie sa fie toate pare. Suma ariilor va fi $2+4+6+..+2*N= 2*(N*(N+1)/2)=N*N+N$ ceea ce ar depasi tabla noastra.\r\n\r\nh2. Plimbare\r\n\r\nEvident ca o conditie necesara ca un graf turneu (asa se numesc grafurile ca cel mentionat in enunt in care exista exact un arc intre oricare doua noduri) sa aiba un circuit hamiltonean ar fi ca graful sa fie tare conex, daca nu ar fi tare conex atunci evident nu poate exista un circuit intre doua noduri aflate in doua componente tari conexe diferite. Aceasta conditie este si suficienta asa cum va reiesi din algoritmul pe care il vom explica mai jos.\r\nAstfel pentru graful nostru vom determina componentele tari conexe, si vom cauta un circuit hamiltonean in cea mai mare dintre acestea. De acum ne vom concentra doar asupra nodurilor acestei componente. Evident ca aceasta componenta conexa contine cel putin un circuit, pentru a determina unul facem o cautare in adancime, si trebuie sa gasim la un moment dat o muchie de intoarcere (pentru ca altfel componenta nu ar fi tare conexa). Vom imparti nodurile din aceasta componenta in patru multimi: $A$ multimea nodurilor din circuit, $B$ multimea nodurilor din afara circuitului pentru care exista si arce orientate de la noduri din circuit la ele, si arce orientate de la ele la noduri din circuit, $C$ multimea nodurilor din afara circuitului pentru care exista numai arce ce pornesc din circuit inspre noduri, si $D$ multimea nodurilor pentru care toate arcele intre ele si noduri din circuit sunt orientate de la ele inspre circuit. Puteti observa ca nodurile din multimea $B$ pot fi inserate tot timpul in circuit undeva inlocuind un arc intre doua noduri ale circuitului cu doua arce de la un nod al circuitului la nodul multimii $B$ si apoi la alt nod din circuit. Inserarea unui astfel de nod dureaza maxim $O(n)$ pasi, alti $O(n)$ pasi ar fi necesari pentru modificarea multimilor $B, C, D $ pentru ca circuitul s-a schimbat. Dupa ce nu ne mai ramane nici un nod in $B$. Ramanem doar cu noduri de tip $C$ sau $D$. Orice nod din multimea $C$ va avea cel putin un arc orientat spre alt nod din multimea $D$ pentru ca altfel nu am fi intr-o componenta tare conexa. Acum aceste doua noduri legate printr-o muchie dinspre $C$ inspre $D$ pot fi inserate in circuit. Astfel am aratat o cale practica de a mari lungimea circuitului pana cand epuizam toate nodurile.\r\nDaca folosim metoda de determinare a componentelor tari conexe folosind un algoritm eficient de complexitate $O(N + M)$, atunci algoritmul are complexitatea $O(N^2^)$ pentru ca la fiecare inserare facem $O(n)$ pasi. Un algoritm mai eficient nu putem obtine deoarece $M = N(N-1)/2$, deci si citirea datelor e $O(N^2^)$. N a fost fixat la $100$ pentru ca am vrut sa punem accent asupra ideii de gasire a circuitului si nu asupra algoritmului de determinare eficienta a componentelor tari conexe.\r\n\r\nh2. TreiD\r\n\r\nAceasta problema e similara cu problema \"Bmatrix\":http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix din arhiva si a fost propusa pentru a favoriza utilizatorii inraiti :).\r\nTrei dreptunghiuri pot avea ca amplasare relativa doar 6 pozitii diferite:\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$ \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}--{@+@}---{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@} &nbsp;&nbsp;{@+@}$\r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@} &nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$          \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$  \r\nsi rotatiile cu 90 de grade ale acestora.\r\nPentru a determina pentru fiecare configuratie solutia optima putem incerca orice impartire posibila cu doua linii in trei zone a dreptunghiului initial. Apoi ne trebuie pentru fiecare dreptunghi de tipul $[1..i]x[1..j], [1..i][j..m], [i..n]x[1..j], [i..n]x[j..m], [i..j]x[1..m] si [1..n]x[i..j]$.\r\nCa sa determinam suma numerelor din un dreptunghi $[r1..r2]x[c1..c2]$ folosim o matrice $B[i][j]$ care e suma elementelor din $[1..i]x[1..j]$, avand aceasta matrice calculata putem determina ca suma elementelor din dreptunghiul $[r1..r2]x[c1..c2]$ este $B[r2][c2] - B[r1 - 1][c2] - B[r2][c2 - 1] + B[r1 - 1][c1 - 1]$. Pentru a calcula $B[i][j]$ eficient parcurgem elementele matricii initiale $A$ in ordine si avem ca $B[i][j] = A[i][j] + B[i][j - 1] + B[i- 1][j] - B[i-1][j-1]$.\r\n\r\nVom explica cum determinam submatricea optima pentru dreptunghiul $[i..j]x[1..m]$ in $O(n)$, celelalte dreptunghiuri putand fi determinate intr-un mod asemanator. Avem trei cazuri posibile: linia de sus a dreptunghiului optim nu coincide cu linia $i$, si astfel putem lua informatia despre el din rezultatul calculului pentru dreptunghiul $[i+1..j]x[1..m]$, al doilea caz e cand linia de jos nu coincide cu linia $j$, acum luam rezultatul optim pentru dreptunghiul $[i..j-1]x[1..m]$. Al treilea caz cand dreptunghiul optim se sprijina pe liniile $i$ si $j$ il putem rezolva in $O(n)$ asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector $C$. $C[k]$ va fi egal cu suma elementelor din dreptunghiul $[i..j] x [k..k]$ (deci suma elementelor din banda $[i..j]$ ce sunt pe coloana $k$).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului $C$, vom folosi vectorul $sum[k] = C[k] + C[k-1] + ... + C[1]$. Astfel suma elementelor $C[k..l]$ este egala cu $sum[l] - sum[k - 1]$. Pentru a determina subsecventa de suma maxima ce se termina in $l$ trebuie sa gasim cea mai mica $sum[k - 1]$ pentru a maximiza expresia $sum[l] - sum[k - 1]$. Astfel obtinem urmatorul cod:\r\n== code(c) |\r\nint min_sum = 0;\r\nint best = - infinit;\r\nfor (int k = 0; k < m; k++) {\r\n    if (best < sum[l] - min_sum)\r\n        best = sum[l] - min_sum;\r\n    if (sum[l] < min_sum) min_sum = sum[l];\r\n}\r\nreturn best;\r\n==\r\nAcest algoritm are complexitatea $O(n)$.\r\nAstfel algoritmul calculeaza in $O(n)$ valoarea optima pentru $O(n^2)$ zone, deci in total avem un algoritm ce consuma $O(n^2)$ memorie si are complexitatea $O(n^3)$ ca timp.',48,'public'),('summer-challenge-2/solutii','Solutii - Summer Challenge Doi','2006-11-18 14:21:35','h1. Solutii - Summer Challenge Doi\r\n\r\n(Creat de ==user(user=\"ditzonec\" type=\"tiny\")== la data de _2006-08-11_ categoria _Competitii_, autor(i) _Adrian Diaconu si Cosmin Negruseri_)\r\n\r\nh2. Sah\r\n\r\nPrima observatie ar fi ca pentru a ne asigura ca intr-o regiune numarul de casute albe este egal cu numarul de celule negre este suficient ca aria regiunii sa fie para.\r\n\r\nPlecand de la aceasta observatie si de la faptul ca $N$ este mereu par propunem urmatoarea impartirea tablei si voi demonstra apoi ca indeplineste conditiile din enunt. Impartim tabla in benzi de latime $2$ (pentru a asigura paritatea ariilor). Apoi prima banda o lasam intreaga, iar pentru urmatoarele banda $i$ se va inmparti in $i-1$ si $N-i+1$. Astfel se vor creea $N-1$ regiuni. Se observa ca toate dreptunghiurile difera intre ele prin lungime deoarece se folosesc toate numerele de la $1$ la $N$ mai putin $N/2$.\r\n\r\nPentru a demonstra ca $N-1$ este numarul maxim de regiuni care se poate creea vom presupune ca se poate imparti tabla in $N$ regiuni. Vom considera ca se folosesc cele mai mici arii posibile, dar acestea trebuie sa fie toate pare. Suma ariilor va fi $2+4+6+..+2*N= 2*(N*(N+1)/2)=N*N+N$ ceea ce ar depasi tabla noastra.\r\n\r\nh2. Plimbare\r\n\r\nEvident ca o conditie necesara ca un graf turneu (asa se numesc grafurile ca cel mentionat in enunt in care exista exact un arc intre oricare doua noduri) sa aiba un circuit hamiltonean ar fi ca graful sa fie tare conex, daca nu ar fi tare conex atunci evident nu poate exista un circuit intre doua noduri aflate in doua componente tari conexe diferite. Aceasta conditie este si suficienta asa cum va reiesi din algoritmul pe care il vom explica mai jos.\r\n\r\nAstfel pentru graful nostru vom determina componentele tari conexe, si vom cauta un circuit hamiltonean in cea mai mare dintre acestea. De acum ne vom concentra doar asupra nodurilor acestei componente. Evident ca aceasta componenta conexa contine cel putin un circuit, pentru a determina unul facem o cautare in adancime, si trebuie sa gasim la un moment dat o muchie de intoarcere (pentru ca altfel componenta nu ar fi tare conexa). Vom imparti nodurile din aceasta componenta in patru multimi: $A$ multimea nodurilor din circuit, $B$ multimea nodurilor din afara circuitului pentru care exista si arce orientate de la noduri din circuit la ele, si arce orientate de la ele la noduri din circuit, $C$ multimea nodurilor din afara circuitului pentru care exista numai arce ce pornesc din circuit inspre noduri, si $D$ multimea nodurilor pentru care toate arcele intre ele si noduri din circuit sunt orientate de la ele inspre circuit. Puteti observa ca nodurile din multimea $B$ pot fi inserate tot timpul in circuit undeva inlocuind un arc intre doua noduri ale circuitului cu doua arce de la un nod al circuitului la nodul multimii $B$ si apoi la alt nod din circuit. Inserarea unui astfel de nod dureaza maxim $O(n)$ pasi, alti $O(n)$ pasi ar fi necesari pentru modificarea multimilor $B, C, D$ pentru ca circuitul s-a schimbat. Dupa ce nu ne mai ramane nici un nod in $B$. Ramanem doar cu noduri de tip $C$ sau $D$. Orice nod din multimea $C$ va avea cel putin un arc orientat spre alt nod din multimea $D$ pentru ca altfel nu am fi intr-o componenta tare conexa. Acum aceste doua noduri legate printr-o muchie dinspre $C$ inspre $D$ pot fi inserate in circuit. Astfel am aratat o cale practica de a mari lungimea circuitului pana cand epuizam toate nodurile.\r\n\r\nDaca folosim metoda de determinare a componentelor tari conexe folosind un algoritm eficient de complexitate $O(N + M)$, atunci algoritmul are complexitatea $O(N^2^)$ pentru ca la fiecare inserare facem $O(n)$ pasi. Un algoritm mai eficient nu putem obtine deoarece $M = N(N-1)/2$, deci si citirea datelor e $O(N^2^)$. N a fost fixat la $100$ pentru ca am vrut sa punem accent asupra ideii de gasire a circuitului si nu asupra algoritmului de determinare eficienta a componentelor tari conexe.\r\n\r\nh2. TreiD\r\n\r\nAceasta problema e similara cu problema \"Bmatrix\":http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix din arhiva si a fost propusa pentru a favoriza utilizatorii inraiti :).\r\nTrei dreptunghiuri pot avea ca amplasare relativa doar 6 pozitii diferite:\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$ \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}--{@+@}---{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@} &nbsp;&nbsp;{@+@}$\r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@} &nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$          \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$  \r\nsi rotatiile cu 90 de grade ale acestora.\r\n\r\nPentru a determina pentru fiecare configuratie solutia optima putem incerca orice impartire posibila cu doua linii in trei zone a dreptunghiului initial. Apoi ne trebuie pentru fiecare dreptunghi de tipul $[1..i]x[1..j], [1..i][j..m], [i..n]x[1..j], [i..n]x[j..m], [i..j]x[1..m] si [1..n]x[i..j]$.\r\nCa sa determinam suma numerelor din un dreptunghi $[r{~1~}..r{~2~}]x[c{~1~}..c{~2~}]$ folosim o matrice $B[i][j]$ care e suma elementelor din $[1..i]x[1..j]$, avand aceasta matrice calculata putem determina ca suma elementelor din dreptunghiul $[r{~1~}..r{~2~}]x[c{~1~}..c{~2~}]$ este $B[r{~2~}][c{~2~}] - B[r{~1~} - 1][c{~2~}] - B[r{~2~}][c{~2~} - 1] + B[r{~1~} - 1][c{~1~} - 1]$. Pentru a calcula $B[i][j]$ eficient parcurgem elementele matricii initiale $A$ in ordine si avem ca $B[i][j] = A[i][j] + B[i][j - 1] + B[i- 1][j] - B[i-1][j-1]$.\r\n\r\nVom explica cum determinam submatricea optima pentru dreptunghiul $[i..j]x[1..m]$ in $O(n)$, celelalte dreptunghiuri putand fi determinate intr-un mod asemanator. Avem trei cazuri posibile: linia de sus a dreptunghiului optim nu coincide cu linia $i$, si astfel putem lua informatia despre el din rezultatul calculului pentru dreptunghiul $[i+1..j]x[1..m]$, al doilea caz e cand linia de jos nu coincide cu linia $j$, acum luam rezultatul optim pentru dreptunghiul $[i..j-1]x[1..m]$. Al treilea caz cand dreptunghiul optim se sprijina pe liniile $i$ si $j$ il putem rezolva in $O(n)$ asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector $C$. $C[k]$ va fi egal cu suma elementelor din dreptunghiul $[i..j] x [k..k]$ (deci suma elementelor din banda $[i..j]$ ce sunt pe coloana $k$).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului $C$, vom folosi vectorul $sum[k] = C[k] + C[k-1] + ... + {@C[1]@}$. Astfel suma elementelor $C[k..l]$ este egala cu $sum[l] - sum[k - 1]$. Pentru a determina subsecventa de suma maxima ce se termina in $l$ trebuie sa gasim cea mai mica $sum[k - 1]$ pentru a maximiza expresia $sum[l] - sum[k - 1]$. Astfel obtinem urmatorul cod:\r\n== code(c) |\r\nint min_sum = 0;\r\nint best = - infinit;\r\nfor (int k = 0; k < m; k++) {\r\n    if (best < sum[l] - min_sum)\r\n        best = sum[l] - min_sum;\r\n    if (sum[l] < min_sum) min_sum = sum[l];\r\n}\r\nreturn best;\r\n==\r\nAcest algoritm are complexitatea $O(n)$.\r\n\r\nAstfel algoritmul calculeaza in $O(n)$ valoarea optima pentru $O(n^2^)$ zone, deci in total avem un algoritm ce consuma $O(n^2^)$ memorie si are complexitatea $O(n^3^)$ ca timp.',48,'public'),('summer-challenge-2/solutii','Solutii - Summer Challenge Doi','2006-11-18 14:25:05','h1. Solutii - Summer Challenge Doi\r\n\r\n(Creat de ==user(user=\"ditzonec\" type=\"tiny\")== la data de _2006-08-11_ categoria _Competitii_, autor(i) _Adrian Diaconu si Cosmin Negruseri_)\r\n\r\nh2. Sah\r\n\r\nPrima observatie ar fi ca pentru a ne asigura ca intr-o regiune numarul de casute albe este egal cu numarul de celule negre este suficient ca aria regiunii sa fie para.\r\n\r\nPlecand de la aceasta observatie si de la faptul ca $N$ este mereu par propunem urmatoarea impartirea tablei si voi demonstra apoi ca indeplineste conditiile din enunt. Impartim tabla in benzi de latime $2$ (pentru a asigura paritatea ariilor). Apoi prima banda o lasam intreaga, iar pentru urmatoarele banda $i$ se va inmparti in $i-1$ si $N-i+1$. Astfel se vor creea $N-1$ regiuni. Se observa ca toate dreptunghiurile difera intre ele prin lungime deoarece se folosesc toate numerele de la $1$ la $N$ mai putin $N/2$.\r\n\r\nPentru a demonstra ca $N-1$ este numarul maxim de regiuni care se poate creea vom presupune ca se poate imparti tabla in $N$ regiuni. Vom considera ca se folosesc cele mai mici arii posibile, dar acestea trebuie sa fie toate pare. Suma ariilor va fi $2+4+6+..+2*N= 2*(N*(N+1)/2)=N*N+N$ ceea ce ar depasi tabla noastra.\r\n\r\nh2. Plimbare\r\n\r\nEvident ca o conditie necesara ca un graf turneu (asa se numesc grafurile ca cel mentionat in enunt in care exista exact un arc intre oricare doua noduri) sa aiba un circuit hamiltonean ar fi ca graful sa fie tare conex, daca nu ar fi tare conex atunci evident nu poate exista un circuit intre doua noduri aflate in doua componente tari conexe diferite. Aceasta conditie este si suficienta asa cum va reiesi din algoritmul pe care il vom explica mai jos.\r\n\r\nAstfel pentru graful nostru vom determina componentele tari conexe, si vom cauta un circuit hamiltonean in cea mai mare dintre acestea. De acum ne vom concentra doar asupra nodurilor acestei componente. Evident ca aceasta componenta conexa contine cel putin un circuit, pentru a determina unul facem o cautare in adancime, si trebuie sa gasim la un moment dat o muchie de intoarcere (pentru ca altfel componenta nu ar fi tare conexa). Vom imparti nodurile din aceasta componenta in patru multimi: $A$ multimea nodurilor din circuit, $B$ multimea nodurilor din afara circuitului pentru care exista si arce orientate de la noduri din circuit la ele, si arce orientate de la ele la noduri din circuit, $C$ multimea nodurilor din afara circuitului pentru care exista numai arce ce pornesc din circuit inspre noduri, si $D$ multimea nodurilor pentru care toate arcele intre ele si noduri din circuit sunt orientate de la ele inspre circuit. Puteti observa ca nodurile din multimea $B$ pot fi inserate tot timpul in circuit undeva inlocuind un arc intre doua noduri ale circuitului cu doua arce de la un nod al circuitului la nodul multimii $B$ si apoi la alt nod din circuit. Inserarea unui astfel de nod dureaza maxim $O(n)$ pasi, alti $O(n)$ pasi ar fi necesari pentru modificarea multimilor $B, C, D$ pentru ca circuitul s-a schimbat. Dupa ce nu ne mai ramane nici un nod in $B$. Ramanem doar cu noduri de tip $C$ sau $D$. Orice nod din multimea $C$ va avea cel putin un arc orientat spre alt nod din multimea $D$ pentru ca altfel nu am fi intr-o componenta tare conexa. Acum aceste doua noduri legate printr-o muchie dinspre $C$ inspre $D$ pot fi inserate in circuit. Astfel am aratat o cale practica de a mari lungimea circuitului pana cand epuizam toate nodurile.\r\n\r\nDaca folosim metoda de determinare a componentelor tari conexe folosind un algoritm eficient de complexitate $O(N + M)$, atunci algoritmul are complexitatea $O(N^2^)$ pentru ca la fiecare inserare facem $O(n)$ pasi. Un algoritm mai eficient nu putem obtine deoarece $M = N(N-1)/2$, deci si citirea datelor e $O(N^2^)$. N a fost fixat la $100$ pentru ca am vrut sa punem accent asupra ideii de gasire a circuitului si nu asupra algoritmului de determinare eficienta a componentelor tari conexe.\r\n\r\nh2. TreiD\r\n\r\nAceasta problema e similara cu problema \"Bmatrix\":http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix din arhiva si a fost propusa pentru a favoriza utilizatorii inraiti :).\r\nTrei dreptunghiuri pot avea ca amplasare relativa doar 6 pozitii diferite:\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$ \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}--{@+@}---{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@} &nbsp;&nbsp;{@+@}$\r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@} &nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$          \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$  \r\nsi rotatiile cu 90 de grade ale acestora.\r\n\r\nPentru a determina pentru fiecare configuratie solutia optima putem incerca orice impartire posibila cu doua linii in trei zone a dreptunghiului initial. Apoi ne trebuie pentru fiecare dreptunghi de tipul $[1..i]x[1..j], [1..i][j..m], [i..n]x[1..j], [i..n]x[j..m], [i..j]x[1..m] si [1..n]x[i..j]$.\r\nCa sa determinam suma numerelor din un dreptunghi $[r{~1~}..r{~2~}]x[c{~1~}..c{~2~}]$ folosim o matrice $B[i][j]$ care e suma elementelor din $[1..i]x[1..j]$, avand aceasta matrice calculata putem determina ca suma elementelor din dreptunghiul $[r{~1~}..r{~2~}]x[c{~1~}..c{~2~}]$ este $B[r{~2~}][c{~2~}] - B[r{~1~} - 1][c{~2~}] - B[r{~2~}][c{~2~} - 1] + B[r{~1~} - 1][c{~1~} - 1]$. Pentru a calcula $B[i][j]$ eficient parcurgem elementele matricii initiale $A$ in ordine si avem ca $B[i][j] = A[i][j] + B[i][j - 1] + B[i- 1][j] - B[i-1][j-1]$.\r\n\r\nVom explica cum determinam submatricea optima pentru dreptunghiul $[i..j]x[1..m]$ in $O(n)$, celelalte dreptunghiuri putand fi determinate intr-un mod asemanator. Avem trei cazuri posibile: linia de sus a dreptunghiului optim nu coincide cu linia $i$, si astfel putem lua informatia despre el din rezultatul calculului pentru dreptunghiul $[i+1..j]x[1..m]$, al doilea caz e cand linia de jos nu coincide cu linia $j$, acum luam rezultatul optim pentru dreptunghiul $[i..j-1]x[1..m]$. Al treilea caz cand dreptunghiul optim se sprijina pe liniile $i$ si $j$ il putem rezolva in $O(n)$ asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector $C$. $C[k]$ va fi egal cu suma elementelor din dreptunghiul $[i..j] x [k..k]$ (deci suma elementelor din banda $[i..j]$ ce sunt pe coloana $k$).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului $C$, vom folosi vectorul {$sum[k] = C[k] + C[k-1] + ... + C[1{@]@}$}. Astfel suma elementelor $C[k..l]$ este egala cu {$sum[l] - sum[k - 1]$}. Pentru a determina subsecventa de suma maxima ce se termina in $l$ trebuie sa gasim cea mai mica $sum[k - 1]$ pentru a maximiza expresia $sum[l] - sum[k - 1]$. Astfel obtinem urmatorul cod:\r\n== code(c) |\r\nint min_sum = 0;\r\nint best = - infinit;\r\nfor (int k = 0; k < m; k++) {\r\n    if (best < sum[l] - min_sum)\r\n        best = sum[l] - min_sum;\r\n    if (sum[l] < min_sum) min_sum = sum[l];\r\n}\r\nreturn best;\r\n==\r\nAcest algoritm are complexitatea $O(n)$.\r\n\r\nAstfel algoritmul calculeaza in $O(n)$ valoarea optima pentru $O(n^2^)$ zone, deci in total avem un algoritm ce consuma $O(n^2^)$ memorie si are complexitatea $O(n^3^)$ ca timp.',961,'public'),('sandbox','Sandbox','2006-11-18 14:36:46','Ca sa determinam suma numerelor din un dreptunghi $[r{~1~}..r{~2~}]x[c{~1~}..c{~2~}]$ folosim o matrice $B[i][j]$ care e suma elementelor din {$[1..i]x[1..j]$}, avand aceasta matrice calculata putem determina ca suma elementelor din dreptunghiul $[r{~1~}..r{~2~}]x[c{~1~}..c{~2~}]$ este {$B[r{~2~}][c{~2~}] - B[r{~1~} - 1][c{~2~}] - B[r{~2~}][c{~2~} - 1] + B[r{~1~} - 1][c{~1~} - 1]$}. Pentru a calcula $B[i][j]$ eficient parcurgem elementele matricii initiale $A$ in ordine si avem ca {$B[i][j] = A[i][j] + B[i][j - 1] + B[i- 1][j] - B[i-1][j-1]$}.\r\n\r\nVom explica cum determinam submatricea optima pentru dreptunghiul $[i..j]x[1..m]$ in {$O(n)$}, celelalte dreptunghiuri putand fi determinate intr-un mod asemanator. Avem trei cazuri posibile: linia de sus a dreptunghiului optim nu coincide cu linia {$i$}, si astfel putem lua informatia despre el din rezultatul calculului pentru dreptunghiul {$[i+1..j]x[1..m]$}, al doilea caz e cand linia de jos nu coincide cu linia {$j$}, acum luam rezultatul optim pentru dreptunghiul {$[i..j-1]x[1..m]$}. Al treilea caz cand dreptunghiul optim se sprijina pe liniile $i$ si $j$ il putem rezolva in $O(n)$ asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector {$C$}. $C[k]$ va fi egal cu suma elementelor din dreptunghiul $[i..j] x [k..k]$ (deci suma elementelor din banda $[i..j]$ ce sunt pe coloana {$k$}).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului {$C$}, vom folosi vectorul {$sum[k] = C[k] + C[k-1] + ... + C[1{@]@}$}. Astfel suma elementelor $C[k..l]$ este egala cu {$sum[l] - sum[k - 1]$}. Pentru a determina subsecventa de suma maxima ce se termina in $l$ trebuie sa gasim cea mai mica $sum[k - 1]$ pentru a maximiza expresia {$sum[l] - sum[k - 1]$}. Astfel obtinem urmatorul cod:\r\n== code(c) |\r\nint min_sum = 0;\r\nint best = - infinit;\r\nfor (int k = 0; k < m; k++) {\r\n    if (best < sum[l] - min_sum)\r\n        best = sum[l] - min_sum;\r\n    if (sum[l] < min_sum) min_sum = sum[l];\r\n}\r\nreturn best;\r\n==\r\nAcest algoritm are complexitatea {$O(n)$}.\r\n\r\nAstfel algoritmul calculeaza in $O(n)$ valoarea optima pentru $O(n^2^)$ zone, deci in total avem un algoritm ce consuma $O(n^2^)$ memorie si are complexitatea $O(n^3^)$ ca timp.\r\n\r\np(pre). \r\n     [I{~0~}]    [I{~N&nbsp;&nbsp;~}]\r\nM^N^ * [I{~1~}] = [I{~N+1~}]\r\n     [I{~2~}]    [I{~N+2~}]\r\n\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',0,'public'),('sandbox','Sandbox','2006-11-18 14:37:39','\r\nlinia de jos nu coincide cu linia {$j$}, acum luam rezultatul optim pentru dreptunghiul {$[i..j-1]x[1..m]$}. Al treilea caz cand dreptunghiul optim se sprijina pe liniile $i$ si $j$ il putem rezolva in $O(n)$ asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector {$C$}. $C[k]$ va fi egal cu suma elementelor din dreptunghiul $[i..j] x [k..k]$ (deci suma elementelor din banda $[i..j]$ ce sunt pe coloana {$k$}).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului {$C$}, vom folosi vectorul {$sum[k] = C[k] + C[k-1] + ... + C[1{@]@}$}. Astfel suma elementelor $C[k..l]$ este egala cu {$sum[l] - sum[k - 1]$}. Pentru a determina subsecventa de suma maxima ce se termina in $l$ trebuie sa gasim cea mai mica $sum[k - 1]$ pentru a maximiza expresia {$sum[l] - sum[k - 1]$}. Astfel obtinem urmatorul cod:\r\n== code(c) |\r\nint min_sum = 0;\r\nint best = - infinit;\r\nfor (int k = 0; k < m; k++) {\r\n    if (best < sum[l] - min_sum)\r\n        best = sum[l] - min_sum;\r\n    if (sum[l] < min_sum) min_sum = sum[l];\r\n}\r\nreturn best;\r\n==\r\nAcest algoritm are complexitatea {$O(n)$}.\r\n\r\nAstfel algoritmul calculeaza in $O(n)$ valoarea optima pentru $O(n^2^)$ zone, deci in total avem un algoritm ce consuma $O(n^2^)$ memorie si are complexitatea $O(n^3^)$ ca timp.\r\n\r\np(pre). \r\n     [I{~0~}]    [I{~N&nbsp;&nbsp;~}]\r\nM^N^ * [I{~1~}] = [I{~N+1~}]\r\n     [I{~2~}]    [I{~N+2~}]\r\n\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',0,'public'),('summer-challenge-2/solutii','Solutii - Summer Challenge Doi','2006-11-18 14:40:43','h1. Solutii - Summer Challenge Doi\r\n\r\n(Creat de ==user(user=\"ditzonec\" type=\"tiny\")== la data de _2006-08-11_ categoria _Competitii_, autor(i) _Adrian Diaconu si Cosmin Negruseri_)\r\n\r\nh2. Sah\r\n\r\nPrima observatie ar fi ca pentru a ne asigura ca intr-o regiune numarul de casute albe este egal cu numarul de celule negre este suficient ca aria regiunii sa fie para.\r\n\r\nPlecand de la aceasta observatie si de la faptul ca $N$ este mereu par propunem urmatoarea impartirea tablei si voi demonstra apoi ca indeplineste conditiile din enunt. Impartim tabla in benzi de latime $2$ (pentru a asigura paritatea ariilor). Apoi prima banda o lasam intreaga, iar pentru urmatoarele banda $i$ se va inmparti in $i-1$ si {$N-i+1$}. Astfel se vor creea $N-1$ regiuni. Se observa ca toate dreptunghiurile difera intre ele prin lungime deoarece se folosesc toate numerele de la $1$ la $N$ mai putin {$N/2$}.\r\n\r\nPentru a demonstra ca $N-1$ este numarul maxim de regiuni care se poate creea vom presupune ca se poate imparti tabla in $N$ regiuni. Vom considera ca se folosesc cele mai mici arii posibile, dar acestea trebuie sa fie toate pare. Suma ariilor va fi $2+4+6+..+2*N= 2*(N*(N+1)/2)=N*N+N$ ceea ce ar depasi tabla noastra.\r\n\r\nh2. Plimbare\r\n\r\nEvident ca o conditie necesara ca un graf turneu (asa se numesc grafurile ca cel mentionat in enunt in care exista exact un arc intre oricare doua noduri) sa aiba un circuit hamiltonean ar fi ca graful sa fie tare conex, daca nu ar fi tare conex atunci evident nu poate exista un circuit intre doua noduri aflate in doua componente tari conexe diferite. Aceasta conditie este si suficienta asa cum va reiesi din algoritmul pe care il vom explica mai jos.\r\n\r\nAstfel pentru graful nostru vom determina componentele tari conexe, si vom cauta un circuit hamiltonean in cea mai mare dintre acestea. De acum ne vom concentra doar asupra nodurilor acestei componente. Evident ca aceasta componenta conexa contine cel putin un circuit, pentru a determina unul facem o cautare in adancime, si trebuie sa gasim la un moment dat o muchie de intoarcere (pentru ca altfel componenta nu ar fi tare conexa). Vom imparti nodurile din aceasta componenta in patru multimi: $A$ multimea nodurilor din circuit, $B$ multimea nodurilor din afara circuitului pentru care exista si arce orientate de la noduri din circuit la ele, si arce orientate de la ele la noduri din circuit, $C$ multimea nodurilor din afara circuitului pentru care exista numai arce ce pornesc din circuit inspre noduri, si $D$ multimea nodurilor pentru care toate arcele intre ele si noduri din circuit sunt orientate de la ele inspre circuit. Puteti observa ca nodurile din multimea $B$ pot fi inserate tot timpul in circuit undeva inlocuind un arc intre doua noduri ale circuitului cu doua arce de la un nod al circuitului la nodul multimii $B$ si apoi la alt nod din circuit. Inserarea unui astfel de nod dureaza maxim $O(n)$ pasi, alti $O(n)$ pasi ar fi necesari pentru modificarea multimilor $B, C, D$ pentru ca circuitul s-a schimbat. Dupa ce nu ne mai ramane nici un nod in {$B$}. Ramanem doar cu noduri de tip $C$ sau {$D$}. Orice nod din multimea $C$ va avea cel putin un arc orientat spre alt nod din multimea $D$ pentru ca altfel nu am fi intr-o componenta tare conexa. Acum aceste doua noduri legate printr-o muchie dinspre $C$ inspre $D$ pot fi inserate in circuit. Astfel am aratat o cale practica de a mari lungimea circuitului pana cand epuizam toate nodurile.\r\n\r\nDaca folosim metoda de determinare a componentelor tari conexe folosind un algoritm eficient de complexitate {$O(N + M)$}, atunci algoritmul are complexitatea $O(N^2^)$ pentru ca la fiecare inserare facem $O(n)$ pasi. Un algoritm mai eficient nu putem obtine deoarece {$M = N(N-1)/2$}, deci si citirea datelor e {$O(N^2^)$}. $N$ a fost fixat la $100$ pentru ca am vrut sa punem accent asupra ideii de gasire a circuitului si nu asupra algoritmului de determinare eficienta a componentelor tari conexe.\r\n\r\nh2. TreiD\r\n\r\nAceasta problema e similara cu problema \"Bmatrix\":http://infoarena.devnet.ro/index.php?page=read&conid=arhiva&tid=bmatrix din arhiva si a fost propusa pentru a favoriza utilizatorii inraiti :).\r\nTrei dreptunghiuri pot avea ca amplasare relativa doar 6 pozitii diferite:\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$ \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}--{@+@}---{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@} &nbsp;&nbsp;{@+@}$\r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@} &nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$          \r\n${@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;{@|@}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{@|@}$\r\n${@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}&nbsp;&nbsp;&nbsp;&nbsp;{@+@}------{@+@}$  \r\nsi rotatiile cu 90 de grade ale acestora.\r\n\r\nPentru a determina pentru fiecare configuratie solutia optima putem incerca orice impartire posibila cu doua linii in trei zone a dreptunghiului initial. Apoi ne trebuie pentru fiecare dreptunghi de tipul {$[1..i]x[1..j], [1..i][j..m], [i..n]x[1..j], [i..n]x[j..m], [i..j]x[1..m] si [1..n]x[i..j]$}.\r\nCa sa determinam suma numerelor din un dreptunghi $[r{~1~}..r{~2~}]x[c{~1~}..c{~2~}]$ folosim o matrice $B[i][j]$ care e suma elementelor din {$[1..i]x[1..j]$}, avand aceasta matrice calculata putem determina ca suma elementelor din dreptunghiul $[r{~1~}..r{~2~}]x[c{~1~}..c{~2~}]$ este {$B[r{~2~}][c{~2~}] - B[r{~1~} - 1][c{~2~}] - B[r{~2~}][c{~2~} - 1] + B[r{~1~} - 1][c{~1~} - 1]$}. Pentru a calcula $B[i][j]$ eficient parcurgem elementele matricii initiale $A$ in ordine si avem ca {$B[i][j] = A[i][j] + B[i][j - 1] + B[i- 1][j] - B[i-1][j-1]$}.\r\n\r\nVom explica cum determinam submatricea optima pentru dreptunghiul $[i..j]x[1..m]$ in {$O(n)$}, celelalte dreptunghiuri putand fi determinate intr-un mod asemanator. Avem trei cazuri posibile: linia de sus a dreptunghiului optim nu coincide cu linia {$i$}, si astfel putem lua informatia despre el din rezultatul calculului pentru dreptunghiul {$[i+1..j]x[1..m]$}, al doilea caz e cand linia de jos nu coincide cu linia {$j$}, acum luam rezultatul optim pentru dreptunghiul {$[i..j-1]x[1..m]$}. Al treilea caz cand dreptunghiul optim se sprijina pe liniile $i$ si $j$ il putem rezolva in $O(n)$ asemanator problemei de determinare a unei subsecvente de suma maxima pe un vector {$C$}. $C[k]$ va fi egal cu suma elementelor din dreptunghiul $[i..j] x [k..k]$ (deci suma elementelor din banda $[i..j]$ ce sunt pe coloana {$k$}).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului {$C$}, vom folosi vectorul {$sum[k]$} {$= C[k] + C[k-1] + ... + C[1&#0093;$}. Astfel suma elementelor $C[k..l]$ este egala cu {$sum[l] - sum[k - 1]$}. Pentru a determina subsecventa de suma maxima ce se termina in $l$ trebuie sa gasim cea mai mica $sum[k - 1]$ pentru a maximiza expresia {$sum[l] - sum[k - 1]$}. Astfel obtinem urmatorul cod:\r\n== code(c) |\r\nint min_sum = 0;\r\nint best = - infinit;\r\nfor (int k = 0; k < m; k++) {\r\n    if (best < sum[l] - min_sum)\r\n        best = sum[l] - min_sum;\r\n    if (sum[l] < min_sum) min_sum = sum[l];\r\n}\r\nreturn best;\r\n==\r\nAcest algoritm are complexitatea {$O(n)$}.\r\n\r\nAstfel algoritmul calculeaza in $O(n)$ valoarea optima pentru $O(n^2^)$ zone, deci in total avem un algoritm ce consuma $O(n^2^)$ memorie si are complexitatea $O(n^3^)$ ca timp.',961,'public'),('preoni-2006/runda-4/solutii','Solutii preONI 2006, Runda a 4-a','2006-11-19 00:33:34','h1. Solutii preONI 2006, Runda a 4-a\r\n\r\n(Creat de \'_domino_\':user/domino la data de _2006-02-19_ categoria _Competitii_, autor(i) _Echipa info-arena_)\r\n\r\nSuntem bucurosi sa va anuntam ca Runda a 4-a concursului preONI 2006 s-a incheiat. In acest articol va vom prezenta solutiile oficiale ale celor 7 probleme propuse precum si cateva aprecieri dupa cele patru probe de foc.\r\n\r\nS-a consumat si al patrulea act al bataliei si odata cu el si etapa on-line a concursului preONI. S-a tras linia si s-au desemnat \"fericitii calificati in runda finala\":http://infoarena.devnet.ro/clasament/preoni2006.php (atentie! verificarea inca nu a fost facuta, dar cu asta ne vom ocupa in urmatoarea perioada).\r\n\r\nAruncandu-ne ochii pe clasamentele Rundei 4, constatam ca participantii au tras tare pe ultima suta de metri vrand sa ne contrazica previziunile sumbre dupa Runda 3. Desi nivelul de dificultate al problemelor a fost un pic mai scazut fata de runda precedenta, concurentii s-au dovedit mult mai conectati la concurs - suspectam ca apropierea olimpiadelor ar fi cauza. Asadar am avut punctaje aproape maxime (275, 255) obtinute in viteza maxima de primii doi clasati la clasa a 9-a - $Bogdan Tataroiu$ si $Sima Mihai Cotizo$, un punctaj maxim la clasa a 12-a realizat de $Costea Andrei$ care a reusit, dupa un start mai putin reusit in rundele precedente, sa treaca la pas pe langa ceilalti info-atleti, unii dintre ei deja nume mari. De data aceasta, concurentii de la clasa a 10-a nu s-au lasat mai prejos fata de celelalte grupe de varsta si, avand un set clar mai usor decat precedentul, au adunat in ritm de maraton punctaje frumoase care au atins si depasit limita (legal admisa) de 200. Felicitari pentru aceasta realizare lui $Vlad Dumitriu$ si $Bogdan Stoica$. In concluzie, am asistat la un concurs bine organizat (felicitari comisiei!) si la un sprint de sanatate din partea concurentilor (felicitari mai ales lor!) care ne-au convins inca o data ca tinerii nostri sunt pregatiti sa fuga mancand pamantul pentru gloria si renumele olimpiadelor nationale si internationale.\r\n\r\nUna peste alta, s-a incheiat o etapa frumoasa a concursului in care am pus mult suflet. Normal, pot fi doar 30 de participanti fericiti de rezultate. Ii felicitam pe cei calificati si abia asteptam sa-i vedem in finala. Ii felicitam si pe ceilalti care nu au putut sa-si tina suflul pana in final, pierzand locurile calificabile. Noi le uram cat mai multe succese, sa mai alerge vreo cateva sute de probleme (incepand cu cele din Arhiva noastra) si sa ne intalnim cu ei mult mai pregatiti la startul urmatorului preONI.\r\n\r\nIn urmatoarele pagini vom incerca sa explicam solutiile problemelor. Asa cum v-ati obisnuit, va puteti lamuri orice vi se pare neclar sau vag explicat intreband pe forum, unde vom incerca sa raspundem cat mai promt. Va asteptam cu intrebari si sugestii (asigurati-va ca pareririle va sunt auzite!)\r\n\r\nh2. NextSeq\r\n\r\n(problema simpla clasa a 9-a)\r\n\r\nEste usor de observat ca cele doua siruri pot fi interpretate ca numere in baza $N$ (numarul de elemente din setul $X$). Acest lucru se poate efectua sortand numerele din setul $X$ si asociind fiecaruia o valoare intre $0$ si $N-1$ (procedeul poarta numele de normalizare). Stiind acest lucru, doua solutii sunt posibile.\r\n\r\nCea mai usoara dintre ele este sa calculam sirul ce il urmeaza pe $A$ (numarand in baza $N$) pana cand obtinem sirul $B$. Deoarece se garanta faptul ca sunt mai putin de $100$ de siruri intre $A$ si $B$, acest pas se va executa de maxim $100$ de ori. Ne punem problema calcularii sirului care urmeaza dupa sirul $A$. Putem afla sirul care-l urmeaza pe $A$ in complexitate $O(M)$ - $M$ este lungimea sirului $A$ - simuland operatia de adunare cu $1$ in urmatorul mod: parcurgem sirul $A$ incepand cu ultimul element pana cand gasim un element mai mic decat $N-1$ (interpretandu-l in baza $N$); incrementam acel numar si numerele egale cu $N-1$ intalnite pana la la el, le egalam cu $0$ (cea mai mica valoare). Singurul caz interesant este acela cand $A$ are toate elementele egale cu valoarea maxima dar este usor de tratat. Complexitatea finala va fi $O(D*P)$ - $P$ este lungimea sirului $B$ iar $D$ este numarul de siruri aflate intre $A$ si $B$.\r\n\r\nSolutia mai rapida, dar ceva mai dificil de implementat, se baza pe operatia de scadere pe numere mari. Astfel, dupa ce am calculat reprezentarile sirurilor $A$ si $B$ in baza $N$, putem efectua o scadere pe numere mari pentru a afla numarul de siruri cuprinse intre $A$ si $B$. Complexitatea solutiei este $O(P)$ - $P$ este lungimea sirului $B$.\r\n\r\nAmbele solutii obtin punctaj maxim, prima fiind ceva mai usoara, putandu-se ajunge la ea si prin abordari care nu tin cont de reprezentarea sirurilor in baza $N$.\r\n\r\nh2. GFact\r\n(problema medie clasa a 9-a)\r\n\r\nPrimul pas in rezolvarea problemei il reprezinta factorizarea numarului P. Acest lucru se poate realiza intr-o complexitate O(sqrt(P)). Odata obtinuta factorizarea, vom avea o relatie de forma:\r\n\r\nP = T1^R1 * ... * TK ^RK\r\n\r\nImediat rezulta:\r\n\r\nA = T1^(R1 * Q) * ... * TK^(RK * Q)\r\n\r\nAl doilea pas este sa observam ca daca aflam pentru fiecare T[i],B[i] astfel incat B[i]! se divide la Ti ^(Ri * Q) atunci B (numarul cautat in problema) este maximul dintre B[i]. Implicatia imediata e ca putem sa ne ocupam de fiecare numar prim in parte fara sa tinem cont de celelalte.\r\n\r\nAl treilea pas consta in determinarea B[i]-urilor cu ajutorul cautarii binare. Pentru o valoare canditata X (din cautarea binara) trebuie sa calculam puterea lui T[i] in descompunerea lui X!. Acest lucru se afla simplu ca fiind [ X / T[i] ] + [ X / (T[i] ^2) ] + ... (unde prin [x] intelegem partea intreaga a lui x). Cautarea binara se poate optimiza observand ca B[i] este intotdeauna divizibil cu T[i], ba mai mult nu va fi mai mare decat (R[i] * Q)*T[i] (observatie necesara obtinerii punctajului maxim). In concluzie, vom cauta binar o valoare intreaga K in intervalul [1, R[i] * Q] astfel incat B[i] = K * T[i] sa aiba propietata ca B[i]! se divide la T[i] ^(Ri * Q) . Va puteti intreba de ce putem cauta binar. Este simplu: daca o valoare X are propietatea ca X! se divide la Y (unde lui X si Y le putem da semnificatiile dorite de noi) atunci, evident, si (X + 1)! se divide la Y.\r\n\r\nSolutia finala va avea complexitatea O(sqrt(P) * log(Q) * log(Q)). Exista o serie de solutii intermediare care permiteau obtinerea de punctaje suficient de mari si de aceea problema a fost considerata medie desi rezolvarea completa este destul de dificila.\r\n\r\n\r\n\r\n\r\nMatrix\r\n\r\n(problema grea clasa a 9-a, problema medie clasa a 10-a)\r\n\r\nPrimul pas al algoritmului este calcularea numarului de aparitii ale fiecarei litere in matricea de N*N. Prima idee care ne vine in minte este ca pentru toate submatricile posibile sa calculam numarul de aparitii ale fiecarei litere si sa comparam cu valorile care trebuie obtinute. Acest algoritm are complexitatea O(M^2*(N+S)), unde S este dimensiunea alfabetului. Aceasta abordare obtine 50 de puncte. Vom verifica pentru toate cele (M-N)^2 matrici posibile daca sunt sau nu permutari ale matricii-template. Apoi, pentru fiecare litera a alfabetului, efectuam urmatoarea preprocesare pentru a putea calcula in O(1) numarul de aparitii ale literei din orice submatrice: T[i][j] = numarul de aparitii pe pozitii (x, y) cu 1 <= x <= i si 1 <= y <= j.\r\nRelatia de recurenta este T[i][j] = T[i-1][j]+T[i][j-1]-T[i-1][j-1], la care se adauga 1 daca si numai daca pe pozitia (i, j) se afla litera pe care o cautam. In aceste conditii, numarul de aparitii ale literei curente in submatricea cu colturile in (i-N+1, j-N+1) si (i, j) este T[i][j]-T[i-N][j]-T[i][j-N]+T[i-N][j-N]. Aceasta solutie are complexitatea O(M^2*S). Daca se foloseste O(M^2*S) memorie se obtin 70-80 de puncte, iar pentru punctaj maxim este necesara reducerea la O(M^2). Acest lucru poate fi realizat folosind doua matrici, una in care tinem minte daca pentru o anumita pozitie s-a gasit vreo litera pentru care numarul de aparitii nu coincide cu cel dorit, si una in care se efectueaza preprocesarea pentru litera curenta. O alta optimizare, mult mai nesimnificativa, si care nu este necesara pentru 100 de puncte, este renuntarea la verificarea pentru ultima litera, deoarece daca primele 25 de litere s-au potrivit, iar numarul de litere este constant, e clar ca si cea de-a 26-a litera se va\r\npotrivi.\r\n\r\n\r\n\r\nLista lui Andrei\r\n\r\n(problema usoara clasa a 10-a)\r\n\r\nProblema se rezolva folosind programare dinamica. Putem tine o matrice V[1..N][1..26] unde V[i][j] reprezinta numarul de siruri de lungime i ce contin ultima litera j. Incepem completarea matricii in ordine crescatoare a lungimii sirurilor, iar V[i][j] se obtine prin insumarea valorilor V[i-1][k], pentru orice k a.i perechea (k, j) sau (j, k) sa nu se regaseasca in lista. Acest rationament conduce la un algoritm in O(N * Sigma^2), unde Sigma reprezinta marimea alfabetului (in cazul nostru 26).\r\n\r\n\r\n\r\nCalcul\r\n\r\n(problema grea clasa a 10-a, problema medie clasele 11-12)\r\n\r\nDeoarece se cer doar ultimele C cifre se va lucra modulo 10^C. Asadar, la primul pas se va calcula A modulo 10^C, adica ne intereseaza doar ultimele C cifre din A.\r\nO prima solutie pentru a calcula A^1 + A^2 + ... + A^B este de calcula A^i in O(lg i) pentru fiecare i folosind algoritmul clasic de ridicare la o putere in numar logaritmic de pasi (Cormen, capitolul 33). Aceasta solutie ar fi adus doar 20p.\r\nSuma prezentata este o progresie geometrica clasica, si se poate calcula folosind formula (A^(B+1)-A) / (A-1). Calculul lui A^(B+1) se face folosind acelasi algoritm mentionat mai sus in O(lg B) (lg = logaritm in baza 2). Pentru a efectua impartirea modulo 10^C, trebuie sa existe un invers multiplicativ pentru A-1 , modulo 10^C, lucru garantat doar pentru 50% din teste (cmmdc(A-1, 10^C) = 1). Inversul multiplicativ poate fi calculat folosind algoritmul [2]Euclid extins sau teorema lui Fermat: X^phi(N) = 1 (mod N) pentru cmmdc(X, N) = 1 si phi(N) = indicatorul lui Euler, cate numere < N sunt prime cu N. Din teorema reiese ca X^(phi(N)-1) = X^(-1) (mod N), asadar inversul poate fi calculat algoritmul de ridicare la o putere mentionat mai sus (phi(10^C) poate fi calculat usor). Un caz special la aceasta solutie apare atunci cand A = 1. Aceasta solutie n-ar fi adus decat 50p si necesita cunostiinte de matematica de clasa a 12-a. Exista o solutie mult mai accesibila pentru clasele a 10-a si a 11-a, folosind\r\nrelatiile:\r\nS(A,2*B) = S(A,B) * (1+A^B)\r\nS(A,2*B+1) = A * (1+S(A,2*B))\r\nCum numarul B este dat in baza 16, parcurgerea bitilor acestuia se face usor, simuland algoritmul de mai sus. Daca A^B se calculeaza la fiecare pas, complexitatea va fi O(lg^2 B), obtinand 60p. O solutie O(lg B) de 100 de puncte se poate obtine calculand in paralel si valorile S(A,B) si A^B. O ultima \"problema\" care ar fi putut exista este faptul ca se cer ultimele C cifre, nu rezultatul modulo 10^C; spre exemplu, daca C = 4 si rezultatul modulo 10^4 ar fi fost \"123\", in fisierul de iesire trebuia afisat \"0123\".\r\n\r\n\r\n\r\nDistante minime\r\n\r\n(problema usoara clasele 11-12)\r\n\r\nProblema se rezolva folosind algoritmul lui Dijkstra pornind din nodul 1. Astfel pe langa vectorul D[1..N] in care tinem distantele minime vom mai folosi un vector P[1..N] in care tinem pentru fiecare nod i numarul de drumuri de lungime D[i]. Cand relaxam o muchie vom face update, daca este cazul, atat in vectorul D cat si in vectorul P.\r\n\r\nDeoarece costul drumurilor a fost definit ca produs de muchii, in vectorul D putem ajunge sa avem numere cu mii de cifre. O implementare cu numere mari a algoritmului descris mai sus nu este destul de eficienta, ea obtinand aproximativ 75 de puncte. Pentru a obtine punctajul maxim este necesara logaritmarea costului fiecarei muchii intr-o baza oarecare. Astfel putem transforma produsul in suma, folosind o proprietate a logaritmilor, fapt ce duce la o implementare simpla si rapida, folosind doar date de tip double.\r\n\r\n\r\n\r\nPopandai\r\n\r\n(problema grea clasele 11-12)\r\n\r\nMai intai vom calcula, pentru fiecare pereche de puncte A si B din punctele ce reprezinta vizuinele, in sirul sub[AB] cate puncte din restul de n se afla sub segmentul de dreapta determinat de A si B. Aceasta preprocesare poate fi efectuata in O(n^2 log n) cu un algoritm inteligent sau poate fi efectuata in O(n^3) cu metoda naiva care verifica pentru fiecare punct daca este situat pe intervalul [A.x, B.x] si este sub dreapta determinata de cele doua puncte. Preprocesare vom putea pentru fiecare triunghi ABC sa aflam in timp O(1) cate puncte are in interior: presupunem fara a restrange generalitatea ca A.x <= B.x <= C.x, daca punctul B e deasupra dreptei AC atunci numarul de puncte din interiorul lui ABC este sub[AB] + sub[BC] - sub[AC], iar daca B este sub dreapta AC atunci numarul de puncte este sub[AC] - sub[AB] - sub[BC] - 1.\r\n\r\nOrice patrulater, fie el concav sau convex, are o diagonala interna. Daca fixam un segment PQ ca fiind diagonala interna putem sa incercam sa gasim pentru fiecare x triunghiul PQR de arie minima pentru care punctul R este deasupra dreptei PQ si care contine in interior cel putin x puncte, iar apoi sa gasim un triunghi PQS de arie minima cu varful S sub dreapta PQ ce contine in interior cel putin k-x puncte. Ariile minime ale acestor triunghiuri se pastreaza in doua siruri over si under iar aria minima a unui patrulater cu o diagonala PQ va fi min(over[x] + under[k-x] | unde x ia toate valorile de la 0 la k). Folosind artificiul explicat mai sus putem determina in O(1) numarul de puncte ce se afla in interiorul unui triunghi, si astfel sirurile over si under pot fi calculate in O(n). Complexitatea totala a algoritmului este O(n^3) pentru ca avem O(n^3) calcule in faza de preprocesare si pentru fiecare n(n-1)/2 diagonale vom efectua O(n) calcule.\r\n\r\nReferences\r\n\r\nVisible links\r\n1. \r\n2. http://info.devnet.ro/articole.php?page=art&art=26\r\n\r\n',18,'public'),('preoni-2006/runda-4/solutii','Solutii preONI 2006, Runda a 4-a','2006-11-19 00:36:23','h1. Solutii preONI 2006, Runda a 4-a\r\n\r\n(Creat de \'_domino_\':user/domino la data de _2006-02-19_ categoria _Competitii_, autor(i) _Echipa info-arena_)\r\n\r\nSuntem bucurosi sa va anuntam ca Runda a 4-a concursului preONI 2006 s-a incheiat. In acest articol va vom prezenta solutiile oficiale ale celor 7 probleme propuse precum si cateva aprecieri dupa cele patru probe de foc.\r\n\r\nS-a consumat si al patrulea act al bataliei si odata cu el si etapa on-line a concursului preONI. S-a tras linia si s-au desemnat \"fericitii calificati in runda finala\":http://infoarena.devnet.ro/clasament/preoni2006.php (atentie! verificarea inca nu a fost facuta, dar cu asta ne vom ocupa in urmatoarea perioada).\r\n\r\nAruncandu-ne ochii pe clasamentele Rundei 4, constatam ca participantii au tras tare pe ultima suta de metri vrand sa ne contrazica previziunile sumbre dupa Runda 3. Desi nivelul de dificultate al problemelor a fost un pic mai scazut fata de runda precedenta, concurentii s-au dovedit mult mai conectati la concurs - suspectam ca apropierea olimpiadelor ar fi cauza. Asadar am avut punctaje aproape maxime (275, 255) obtinute in viteza maxima de primii doi clasati la clasa a 9-a - $Bogdan Tataroiu$ si $Sima Mihai Cotizo$, un punctaj maxim la clasa a 12-a realizat de $Costea Andrei$ care a reusit, dupa un start mai putin reusit in rundele precedente, sa treaca la pas pe langa ceilalti info-atleti, unii dintre ei deja nume mari. De data aceasta, concurentii de la clasa a 10-a nu s-au lasat mai prejos fata de celelalte grupe de varsta si, avand un set clar mai usor decat precedentul, au adunat in ritm de maraton punctaje frumoase care au atins si depasit limita (legal admisa) de 200. Felicitari pentru aceasta realizare lui $Vlad Dumitriu$ si $Bogdan Stoica$. In concluzie, am asistat la un concurs bine organizat (felicitari comisiei!) si la un sprint de sanatate din partea concurentilor (felicitari mai ales lor!) care ne-au convins inca o data ca tinerii nostri sunt pregatiti sa fuga mancand pamantul pentru gloria si renumele olimpiadelor nationale si internationale.\r\n\r\nUna peste alta, s-a incheiat o etapa frumoasa a concursului in care am pus mult suflet. Normal, pot fi doar 30 de participanti fericiti de rezultate. Ii felicitam pe cei calificati si abia asteptam sa-i vedem in finala. Ii felicitam si pe ceilalti care nu au putut sa-si tina suflul pana in final, pierzand locurile calificabile. Noi le uram cat mai multe succese, sa mai alerge vreo cateva sute de probleme (incepand cu cele din Arhiva noastra) si sa ne intalnim cu ei mult mai pregatiti la startul urmatorului preONI.\r\n\r\nIn urmatoarele pagini vom incerca sa explicam solutiile problemelor. Asa cum v-ati obisnuit, va puteti lamuri orice vi se pare neclar sau vag explicat intreband pe forum, unde vom incerca sa raspundem cat mai promt. Va asteptam cu intrebari si sugestii (asigurati-va ca pareririle va sunt auzite!)\r\n\r\nh2. NextSeq\r\n(problema simpla clasa a 9-a)\r\n\r\nEste usor de observat ca cele doua siruri pot fi interpretate ca numere in baza $N$ (numarul de elemente din setul $X$). Acest lucru se poate efectua sortand numerele din setul $X$ si asociind fiecaruia o valoare intre $0$ si $N-1$ (procedeul poarta numele de normalizare). Stiind acest lucru, doua solutii sunt posibile.\r\n\r\nCea mai usoara dintre ele este sa calculam sirul ce il urmeaza pe $A$ (numarand in baza $N$) pana cand obtinem sirul $B$. Deoarece se garanta faptul ca sunt mai putin de $100$ de siruri intre $A$ si $B$, acest pas se va executa de maxim $100$ de ori. Ne punem problema calcularii sirului care urmeaza dupa sirul $A$. Putem afla sirul care-l urmeaza pe $A$ in complexitate $O(M)$ - $M$ este lungimea sirului $A$ - simuland operatia de adunare cu $1$ in urmatorul mod: parcurgem sirul $A$ incepand cu ultimul element pana cand gasim un element mai mic decat $N-1$ (interpretandu-l in baza $N$); incrementam acel numar si numerele egale cu $N-1$ intalnite pana la la el, le egalam cu $0$ (cea mai mica valoare). Singurul caz interesant este acela cand $A$ are toate elementele egale cu valoarea maxima dar este usor de tratat. Complexitatea finala va fi $O(D*P)$ - $P$ este lungimea sirului $B$ iar $D$ este numarul de siruri aflate intre $A$ si $B$.\r\n\r\nSolutia mai rapida, dar ceva mai dificil de implementat, se baza pe operatia de scadere pe numere mari. Astfel, dupa ce am calculat reprezentarile sirurilor $A$ si $B$ in baza $N$, putem efectua o scadere pe numere mari pentru a afla numarul de siruri cuprinse intre $A$ si $B$. Complexitatea solutiei este $O(P)$ - $P$ este lungimea sirului $B$.\r\n\r\nAmbele solutii obtin punctaj maxim, prima fiind ceva mai usoara, putandu-se ajunge la ea si prin abordari care nu tin cont de reprezentarea sirurilor in baza $N$.\r\n\r\nh2. GFact\r\n(problema medie clasa a 9-a)\r\n\r\nPrimul pas in rezolvarea problemei il reprezinta factorizarea numarului $P$. Acest lucru se poate realiza intr-o complexitate $O(sqrt(P))$. Odata obtinuta factorizarea, vom avea o relatie de forma:\r\n\r\n${P = T1{~R1~} * ... * TK{~R~}}$\r\n\r\nImediat rezulta:\r\n\r\nA = T1^(R1 * Q) * ... * TK^(RK * Q)\r\n\r\nAl doilea pas este sa observam ca daca aflam pentru fiecare T[i],B[i] astfel incat B[i]! se divide la Ti ^(Ri * Q) atunci B (numarul cautat in problema) este maximul dintre B[i]. Implicatia imediata e ca putem sa ne ocupam de fiecare numar prim in parte fara sa tinem cont de celelalte.\r\n\r\nAl treilea pas consta in determinarea B[i]-urilor cu ajutorul cautarii binare. Pentru o valoare canditata X (din cautarea binara) trebuie sa calculam puterea lui T[i] in descompunerea lui X!. Acest lucru se afla simplu ca fiind [ X / T[i] ] + [ X / (T[i] ^2) ] + ... (unde prin [x] intelegem partea intreaga a lui x). Cautarea binara se poate optimiza observand ca B[i] este intotdeauna divizibil cu T[i], ba mai mult nu va fi mai mare decat (R[i] * Q)*T[i] (observatie necesara obtinerii punctajului maxim). In concluzie, vom cauta binar o valoare intreaga K in intervalul [1, R[i] * Q] astfel incat B[i] = K * T[i] sa aiba propietata ca B[i]! se divide la T[i] ^(Ri * Q) . Va puteti intreba de ce putem cauta binar. Este simplu: daca o valoare X are propietatea ca X! se divide la Y (unde lui X si Y le putem da semnificatiile dorite de noi) atunci, evident, si (X + 1)! se divide la Y.\r\n\r\nSolutia finala va avea complexitatea O(sqrt(P) * log(Q) * log(Q)). Exista o serie de solutii intermediare care permiteau obtinerea de punctaje suficient de mari si de aceea problema a fost considerata medie desi rezolvarea completa este destul de dificila.\r\n\r\n\r\n\r\n\r\nMatrix\r\n\r\n(problema grea clasa a 9-a, problema medie clasa a 10-a)\r\n\r\nPrimul pas al algoritmului este calcularea numarului de aparitii ale fiecarei litere in matricea de N*N. Prima idee care ne vine in minte este ca pentru toate submatricile posibile sa calculam numarul de aparitii ale fiecarei litere si sa comparam cu valorile care trebuie obtinute. Acest algoritm are complexitatea O(M^2*(N+S)), unde S este dimensiunea alfabetului. Aceasta abordare obtine 50 de puncte. Vom verifica pentru toate cele (M-N)^2 matrici posibile daca sunt sau nu permutari ale matricii-template. Apoi, pentru fiecare litera a alfabetului, efectuam urmatoarea preprocesare pentru a putea calcula in O(1) numarul de aparitii ale literei din orice submatrice: T[i][j] = numarul de aparitii pe pozitii (x, y) cu 1 <= x <= i si 1 <= y <= j.\r\nRelatia de recurenta este T[i][j] = T[i-1][j]+T[i][j-1]-T[i-1][j-1], la care se adauga 1 daca si numai daca pe pozitia (i, j) se afla litera pe care o cautam. In aceste conditii, numarul de aparitii ale literei curente in submatricea cu colturile in (i-N+1, j-N+1) si (i, j) este T[i][j]-T[i-N][j]-T[i][j-N]+T[i-N][j-N]. Aceasta solutie are complexitatea O(M^2*S). Daca se foloseste O(M^2*S) memorie se obtin 70-80 de puncte, iar pentru punctaj maxim este necesara reducerea la O(M^2). Acest lucru poate fi realizat folosind doua matrici, una in care tinem minte daca pentru o anumita pozitie s-a gasit vreo litera pentru care numarul de aparitii nu coincide cu cel dorit, si una in care se efectueaza preprocesarea pentru litera curenta. O alta optimizare, mult mai nesimnificativa, si care nu este necesara pentru 100 de puncte, este renuntarea la verificarea pentru ultima litera, deoarece daca primele 25 de litere s-au potrivit, iar numarul de litere este constant, e clar ca si cea de-a 26-a litera se va\r\npotrivi.\r\n\r\n\r\n\r\nLista lui Andrei\r\n\r\n(problema usoara clasa a 10-a)\r\n\r\nProblema se rezolva folosind programare dinamica. Putem tine o matrice V[1..N][1..26] unde V[i][j] reprezinta numarul de siruri de lungime i ce contin ultima litera j. Incepem completarea matricii in ordine crescatoare a lungimii sirurilor, iar V[i][j] se obtine prin insumarea valorilor V[i-1][k], pentru orice k a.i perechea (k, j) sau (j, k) sa nu se regaseasca in lista. Acest rationament conduce la un algoritm in O(N * Sigma^2), unde Sigma reprezinta marimea alfabetului (in cazul nostru 26).\r\n\r\n\r\n\r\nCalcul\r\n\r\n(problema grea clasa a 10-a, problema medie clasele 11-12)\r\n\r\nDeoarece se cer doar ultimele C cifre se va lucra modulo 10^C. Asadar, la primul pas se va calcula A modulo 10^C, adica ne intereseaza doar ultimele C cifre din A.\r\nO prima solutie pentru a calcula A^1 + A^2 + ... + A^B este de calcula A^i in O(lg i) pentru fiecare i folosind algoritmul clasic de ridicare la o putere in numar logaritmic de pasi (Cormen, capitolul 33). Aceasta solutie ar fi adus doar 20p.\r\nSuma prezentata este o progresie geometrica clasica, si se poate calcula folosind formula (A^(B+1)-A) / (A-1). Calculul lui A^(B+1) se face folosind acelasi algoritm mentionat mai sus in O(lg B) (lg = logaritm in baza 2). Pentru a efectua impartirea modulo 10^C, trebuie sa existe un invers multiplicativ pentru A-1 , modulo 10^C, lucru garantat doar pentru 50% din teste (cmmdc(A-1, 10^C) = 1). Inversul multiplicativ poate fi calculat folosind algoritmul [2]Euclid extins sau teorema lui Fermat: X^phi(N) = 1 (mod N) pentru cmmdc(X, N) = 1 si phi(N) = indicatorul lui Euler, cate numere < N sunt prime cu N. Din teorema reiese ca X^(phi(N)-1) = X^(-1) (mod N), asadar inversul poate fi calculat algoritmul de ridicare la o putere mentionat mai sus (phi(10^C) poate fi calculat usor). Un caz special la aceasta solutie apare atunci cand A = 1. Aceasta solutie n-ar fi adus decat 50p si necesita cunostiinte de matematica de clasa a 12-a. Exista o solutie mult mai accesibila pentru clasele a 10-a si a 11-a, folosind\r\nrelatiile:\r\nS(A,2*B) = S(A,B) * (1+A^B)\r\nS(A,2*B+1) = A * (1+S(A,2*B))\r\nCum numarul B este dat in baza 16, parcurgerea bitilor acestuia se face usor, simuland algoritmul de mai sus. Daca A^B se calculeaza la fiecare pas, complexitatea va fi O(lg^2 B), obtinand 60p. O solutie O(lg B) de 100 de puncte se poate obtine calculand in paralel si valorile S(A,B) si A^B. O ultima \"problema\" care ar fi putut exista este faptul ca se cer ultimele C cifre, nu rezultatul modulo 10^C; spre exemplu, daca C = 4 si rezultatul modulo 10^4 ar fi fost \"123\", in fisierul de iesire trebuia afisat \"0123\".\r\n\r\n\r\n\r\nDistante minime\r\n\r\n(problema usoara clasele 11-12)\r\n\r\nProblema se rezolva folosind algoritmul lui Dijkstra pornind din nodul 1. Astfel pe langa vectorul D[1..N] in care tinem distantele minime vom mai folosi un vector P[1..N] in care tinem pentru fiecare nod i numarul de drumuri de lungime D[i]. Cand relaxam o muchie vom face update, daca este cazul, atat in vectorul D cat si in vectorul P.\r\n\r\nDeoarece costul drumurilor a fost definit ca produs de muchii, in vectorul D putem ajunge sa avem numere cu mii de cifre. O implementare cu numere mari a algoritmului descris mai sus nu este destul de eficienta, ea obtinand aproximativ 75 de puncte. Pentru a obtine punctajul maxim este necesara logaritmarea costului fiecarei muchii intr-o baza oarecare. Astfel putem transforma produsul in suma, folosind o proprietate a logaritmilor, fapt ce duce la o implementare simpla si rapida, folosind doar date de tip double.\r\n\r\n\r\n\r\nPopandai\r\n\r\n(problema grea clasele 11-12)\r\n\r\nMai intai vom calcula, pentru fiecare pereche de puncte A si B din punctele ce reprezinta vizuinele, in sirul sub[AB] cate puncte din restul de n se afla sub segmentul de dreapta determinat de A si B. Aceasta preprocesare poate fi efectuata in O(n^2 log n) cu un algoritm inteligent sau poate fi efectuata in O(n^3) cu metoda naiva care verifica pentru fiecare punct daca este situat pe intervalul [A.x, B.x] si este sub dreapta determinata de cele doua puncte. Preprocesare vom putea pentru fiecare triunghi ABC sa aflam in timp O(1) cate puncte are in interior: presupunem fara a restrange generalitatea ca A.x <= B.x <= C.x, daca punctul B e deasupra dreptei AC atunci numarul de puncte din interiorul lui ABC este sub[AB] + sub[BC] - sub[AC], iar daca B este sub dreapta AC atunci numarul de puncte este sub[AC] - sub[AB] - sub[BC] - 1.\r\n\r\nOrice patrulater, fie el concav sau convex, are o diagonala interna. Daca fixam un segment PQ ca fiind diagonala interna putem sa incercam sa gasim pentru fiecare x triunghiul PQR de arie minima pentru care punctul R este deasupra dreptei PQ si care contine in interior cel putin x puncte, iar apoi sa gasim un triunghi PQS de arie minima cu varful S sub dreapta PQ ce contine in interior cel putin k-x puncte. Ariile minime ale acestor triunghiuri se pastreaza in doua siruri over si under iar aria minima a unui patrulater cu o diagonala PQ va fi min(over[x] + under[k-x] | unde x ia toate valorile de la 0 la k). Folosind artificiul explicat mai sus putem determina in O(1) numarul de puncte ce se afla in interiorul unui triunghi, si astfel sirurile over si under pot fi calculate in O(n). Complexitatea totala a algoritmului este O(n^3) pentru ca avem O(n^3) calcule in faza de preprocesare si pentru fiecare n(n-1)/2 diagonale vom efectua O(n) calcule.\r\n\r\nReferences\r\n\r\nVisible links\r\n1. \r\n2. http://info.devnet.ro/articole.php?page=art&art=26\r\n\r\n',18,'public'),('preoni-2005/runda-3/solutii','preONI 2005 runda #3 - solutii','2006-11-18 14:01:52','h1. preONI 2005 runda #3 - solutii\r\n\r\n(Creat de ==user(user=\"domino\" type=\"tiny\")== la data de _2005-03-20_ categoria _Competitii_, autor(i) _Echipa devNet_)\r\n\r\nArticolul contine ideile de rezolvare ale problemelor propuse la ultima runda a concursului preONI ce s-a desfasurat pe data de 20 martie 2005, cat si comentarii legate de concurs. Si de aceasta data numarul de participanti a fost impresionat, cu siguranta datorita faptului ca in numai 5 zile incepe ONI!\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nSetul de probleme a fost mai greu de data aceasta, special pentru a testa concurentii cu probleme cat mai asemanatoare cu stilul ONI. Speram ca fiecare participant a invatat cate ceva in urma acestui concurs si asteptam pareri si sugestii pentru viitor pe \"forum\":http://www.infoarena.ro/Forum.\r\n\r\nh2. Clasele 9-10\r\n\r\nh3. Clasament\r\n\r\n==Rankings(rounds=\"preoni53a\" display_entries=\"7\" pager_style=\"none\")==\r\n\r\nPrimele doua locuri din clasament sunt \"ocupate\" de \"veterani\", Dan Fechete fiind clasa a 12-a, iar Mugurel Ionut student. In rest, in clasament si-au facut loc concurenti destul de \"celebri\", unii dintre ei premianti la ONI in anii trecuti.\r\n\r\nh3. Barman\r\n\r\n(solutie corecta oferita de Dan Spatarel, 20 noiembrie 2005)\r\n\r\nMetoda folosita este una brute-force si se bazeaza pe cateva observatii. Pentru a determina solutia optima sortam sirul valorilor bauturilor si ii generam toate permutarile circulare in vectorul obt. De aici, problema noastra ramane transformarea de cost minim a vectorului initial a in vectorul obt folosind operatiile permise. Dintre toate permutarile circulare, evident o vom alege pe cea care cere un cost minim al operatiilor. In primul rand se observa ca nu are nici un rost sa deranjam camerele care au bautura ceruta (a[i] = obt[i]), deci pe Paftenie nu il vor preocupa acestea. In al doilea rand este de remarcat ca ar fi inutil ca Paftenie sa deplaseze mai mult de un pahar intre doua camere deoarece am considera un caz redundant. De ce? Ar fi libere numai camerele c1 si c2, din care provin cele doua pahare de pe tava. Cu doua pahare pe tava ar putea sa mearga intr-o camera c3 diferita de c1 si c2, dar ar fi inutil, caci nici pe tava nici in camera nu mai poate depozita vreun pahar.\r\n\r\nAstfel, problema se reduce la a gasi, pentru fiecare bautura care nu se afla pe locul ei, o pozitie optima, pe care daca o asezam, vom obtine un cost global minim. Pentru simplitate, in continuare voi numi \"cuplaj\" mutarea unei bauturi pe o alta masa. Se poate oberva ca problema se poate imparti in mai multe sub-probleme independente: fiecare sub-problema va calcula cuplajul optim pentru toate bauturile de aceeasi valoare. Problemele sunt independente, deoarece pentru a pastra solutia optima globala, trebuie sa cuplam o bautura cu o masa pe care trebuie plasata acelasi tip de bautura.\r\n\r\nO metoda ar fi greedy: pentru fiecare bautura care nu e la locul ei, cautam cea mai apropiata masa pe care se poate pune - insa aceasta metoda este gresita.\r\n\r\nO alta metoda este cuplajul intr-un graf bipatit. Desi aceasta rezolvare este corecta, nu se incadreaza in timpul de executie. Deoarece trebuie efectuate N cuplaje cu cate 2*N noduri fiecare, vom obtine o complexitate de O(N^5), supraestimata. Este posibil, totusi, ca in urma unor optimizari puternice, si aceasta metoda sa obtina punctaj mare.\r\n\r\nTotusi, mai exista si o alta metoda mult mai simpla si mai rapida, care se bazeaza pe cateva observatii suplimentare: datorita sortarii pe care am efecutat-o la inceputul algoritmului si a permutarilor circulare, mesele pe care trebuie plasata aceeasi bautura, sunt plasate fie secvential, fie in doua secvente, de la 1 la k si de la l la N. De asemenea, deoarece am eliminat cazurile in care a[i] = obt[i], cele doua cazuri, fara a pirde dingeneralitate, se reduc la unul singur: in intervalul 1 - k exista numai bauturi care trebuie cuplate; in intervalul k+1 - l exista numai mese care trebuie cuplate; in intervalul l+1 - N exista numai bauturi care trebuie cuplate. (Al doilea caz este simetric, si deoarece mesele pot fi privite ca bauturi, si invers, putem reduce al doilea caz la primmul.)\r\n\r\nProblema se rezolva partitionand mulmimea meselor in doua secvente: mesele din prima secventa se vor cupla cu bauturile din intervalul 1 - k, iar mesele din a doua secventa cu bauturile din intervalul l+1 - N. Se poate observa ca oricum s-ar realiza cele doua cuplaje, costul golbal va fi acelasi. In plus, orice alt cuplaj global care nu tine cont de aceasta impartire va obtine un const global mai mare. Astfel, se garanteaza ca aceasta metoda va calcula corect costul minim global.\r\n\r\nAlgoritmul care impleneteaza acest cuplaj este foarte simplu: pentru fiecare bautura care nu se alfa la locul ei (a[i] = obt[i]), se cauta prima masa necuplata pe care se poate plasa bautura.\r\n\r\nh3. Cifre\r\n\r\nPentru a afla probabilitatea ceruta trebuie sa aflat cate numere exista in intervalul [A..B] cu cel putin K cifre de C. Pentru asta vom construi o functia f(x) care va returna cate numere sunt in intervalul [0..x-1] care au cel putin K cifre de C. Astfel rezultatul va fi f(B+1)-f(A). Functia f(x) va rula in complexitate O(lg x) parcurgand numarul x cifra cu cifra. Ca sa realizam acest lucru avem nevoie de urmatoarele informatii:\r\ncnt(i, j) = cate numere intre 0 si 10^i-1 contin j cifre de C (vom considera ca numerele pot avea 0-uri in fata, de exemplu: 0003 are 3 cifre de 0)\r\nAcest numar se poate calcula fie printr-o formula matematica folosind combinari sau cu o relatia de recurenta (independenta de variabila C):\r\ncnt(i, j) = 9 * cnt(i-1, j) + cnt(i-1, j-1)\r\nDe asemenea mai avem nevoie de urmatoarele informatii:\r\ncnt0(i, j) = cate numere care nu au 0-uri in fata intre 0 si 10^i-1 contin j cifre de C\r\nRelatia de recurenta va fi in functie de C:\r\ndaca C=0 atunci cnt0(i, j) = cnt0(i-1, j) + 9 * cnt(i-1, j)\r\naltfel cnt0(i, j) = cnt0(i-1, j) + 8 * cnt(i-1, j) + cnt(i-1, j-1)\r\nCele doua matrici au marimi lgB*K deci construirea lor va avea complexitate O(lg B*K). Odata disponibile aceste informatii se poate realiza destul de usor functia f(x). Nu voi prezenta aici toate detaliile deoarecere apar mai multe cazuri (in special cand C = 0), lasand ca exercitiu pentru cititor. O alta rezolvare posibila ar fi calcularea functiei f(x) in O(2^lg10(x)*lg10(x)) astfel: pe fiecare pozitie intre 0 si lg10(x) avem doua variante, fie punem cifra C, fie alta cifra. Pentru fiecare astfel de configuratie cu cel putin K cifre de C se poate determina dintr-o parcurgere cate numere exista < x care au cifre de C in pozitiile respective.\r\n\r\nh3. Farfurii\r\n\r\nProblema cere construirea unei permutari de lungime N cu K inversiuni, minim lexicografica. O prima rezolvare de complexitate O(N^2) ar fi construirea permutarii element cu element. Cu cat un element este mai mare pe o anumita pozitie cu atat formeaza mai multe inversiuni, astfel ca incercam sa punem pe fiecare pozitie un element cat mai mic astfel: pe pozitia i, daca K <= (N-i)*(N-i-1)/2 putem pune cel mai mic element disponibil (pentru ca in bucata de N-i ramasa putem construi cel putin (N-i)*(N-i-1)/2 inversiuni), altfel punem al K-(N-i)*(N-i-1)/2 element disponibil. Aceasta modalitate de constructie garanteaza ca permutarea este minim lexicografic. O implementare directa, cum am zis, are complexitate O(N^2) si ia 40-60p. Pentru 100p se poate folosi un arbore de intervale (ca la problema \"concurs\" de la .campion 2005, runda 9) reducand complexitate la O(N*lg N). O asemenea solutie, desi lua 100p, necesita cunostiinte de structuri de date avansate care depasesc nivelul de cunostiinte general al unui\r\nconcurent pentru clasele 9-10. O rezolvare O(N) mult mai simpla se bazeaza pe urmatoarea observatie:\r\nO permutare de lungime i are cel mult i*(i-1)/2 inversiuni cand numerele sunt in ordine descrescatoare.\r\nAstfel, daca K e de forma M*(M-1)/2 permutarea minim lexicografica cu K inversiuni va fi:\r\n\r\n1, 2, 3, ... N-M, N, N-1, N-2, ... N-M+1\r\n\r\nCele K inversiunile apar in ultimele M elemente. Daca in aceasta permutare mutam un element N-x imediat inaintea lui N numarul de inversiuni scade cu x. Astfel, daca K>M*(M-1)/2 construim permutarea\r\n\r\n1, 2, 3, ... N-M-1, N, N-1, N-2, ... N-M\r\n\r\n(care are (M+1)*M/2 inversiuni) si mutam elementul N-((M+1)*M/2-K) imediat inaintea lui N, astfel scadem numarul de inversiuni la K. Este evident ca permutarea astfel construita este minim lexicografica. Algoritmul descris are complexitate O(N).\r\n\r\nh2. Clasele 11-12\r\n\r\nh3. Clasament\r\n\r\n==Rankings(rounds=\"preoni53b\" display_entries=\"6\" pager_style=\"none\")==\r\n\r\nSetul de probleme, mai greu de data aceasta, se pare ca a pus in dificultate majoritatea concurentilor. Desi problemele Critice si Poligon nu erau foarte dificile in faza de concepere a algoritmului se pare ca implementarea a fost cea care i-a speriat pe multi dintre participanti. Clasamentul este dominat de nume deja celebre precum Mugurel Ionut Andreica, Fechete Dan Ionut, Sorin Stancu-Mara (toti trei cu rezultate internationale) lor alaturandu-se participanti cu rezultate frumoase in concursurile nationale.\r\n\r\nh3. Critice\r\n\r\nProblema este o aplicatie a algoritmului de aflare a fluxului maxim dintr-o retea. Se construieste o retea, nodurile fiind adaposturile iar capacitatile muchiilor fiind egale cu rezistentele tunelurilor. Prima solutie, care trece ~ 50% din teste, este urmatoarea:\r\n\r\n# Se calculeaza fluxul maxim in reteau construita\r\n# Pentru fiecare muchie (separat) se creste capacitatea ei cu o unitate si se mai ruleaza inca o data algoritmul de flux maximi. Daca fluxul maxim a crescut atunci muchia este critica.\r\n\r\nSe observa ca acest algoritm are o complexitate considerabila si trebuie sa ne gandim la ceva mai bun. Primul lucru inteligent pe care il putem observa este ca muchiile critice sunt muchiile care, dupa ce am rulat odata algoritmul de flux maxim, sunt saturate (am folosit toata capacitatea ei intr-o directie sau cealalta). Totusi nu toate muchiile saturate sunt si critice. Pentru a fi mai exacti, muchiile critice sunt acele muchii saturate care au propietatea ca de la sursa retelei (nodul 1) este drum in graful rezidual (adica graful care ne ramane daca eliminam muchiile saturate) la unul din capetele ei si respectiv de la destinatie (nodul N) la celalalt capat. Asadar se contureaza algoritmul:\r\n\r\n# Se ruleaza odata algoritmul de flux maxim\r\n# Cu ajutorul a doua parcurgeri a grafului rezidual stabilim pentru fiecare muchie critica daca propietatea este adevarata\r\n\r\nComplexitatea (teoretica) va fi O(M^2*N + M) dar este supraestimata algoritmul de flux ruland mult mai rapid.\r\n\r\nh3. Ferma\r\n\r\nLa prima vedere, problema pare abordabila cu programare dinamica. O simpla rezolvare care nu tine cont de faptul ca sirul este circular este urmatoarea: A(i, j) = productivitatea maxima pentru a face i strangeri din primele j sectoare; evident raspunsul va fi A(K, N). Relatia de recurenta:\r\n\r\nA(i, j) = max (A(i, j-1), A(i-1, k) + suma P(k),P(k+1)..P(j)) pentru fiecare k<j, iar P reprezinta vectorul de productivitati.\r\n\r\nO astfel de implementare are complexitate O(N^2*K) si nu se va incadra in timp. Fie S(i) = P(1)+P(2)+...P(i), atunci putem rescrie relatia de recurenta astfel:\r\n\r\nA(i, j) = max(A(i, j-1), A(i-1, k) + S(j) - S(k)), pentru fiecare k<j\r\n\r\nAl doilea termen este de forma A(i-1, k) - S(k) (termen independent de j) + S(j). Astfel din linia i-1 a matricii de dinamica pentru fiecare j ne trebuie valoarea maxima A(i-1, k)-S(k) cu k<j. O prima idee ar fi ca pe masura ce construim linia i sa inseram elementele din linia i-1 intr-un max-heap astfel reducand complexitatea la O(N*lgN*K).\r\n\r\nCei care au rezolvat probleme precum \"secventa\" de pe info-arena, \"trans\" de la barajul de la ONI 2004 sau \"divide\" de la USACO Ianuarie 2005 vor realiza imediat ca putem reduce complexitatea la O(N*K) folosind structura necesara in rezolvarea acelor probleme si anume o coada (in literatura de specialitate se intalneste ca \"deque with heap order\"). Aceasta structura a mai fost tratata si in solutiilor problemelor prezentate mai sus, deci nu voi intra in detalii. Este evident ca un algoritm de complexitate O(N*K) se incadreaza in timp, dar mai apare in calcul faptul ca sirul este circular. Un algoritm O(N*K) care nu trateaza acest lucru ia 40 de puncte. O prima idee ar fi sa aplicam acelasi algoritm pe fiecare permutare circulara dar se ridica complexitatea iar la O(N^2*K). Aceasta abordare ar trebui sa obtina intre 50 si 60 de puncte. Putem trata circularitatea sirului tot in O(N*K) incercand sa obtinem o secventa care contine elemente N si 1. Putem realiza acest lucru astfel:\r\n\r\n* dupa ce realizam prima data dinamica, reinitializam linia 1 astfel A(1, i) = S(i)\r\n* aplicam din nou dinamica -> de data aceasta algoritmul va fi obligat sa intoarca rezultate care contin neaparat elementul 1 intr-o secventa din cauza initializarii\r\n* pentru fiecare pozitie i<=N comparam rezultatul A(i, K)+S(N)-S(i) (adaugam la secventa care il contine pe 1 o bucata care il contine pe N) cu cel mai bun obtinut\r\n\r\nAstfel, problema este rezolvabila in complexitate O(N*K).\r\n\r\nh3. Poligon\r\n\r\nProblema cere sa determinam cate puncte din cele M sunt in interiorul poligonului. O abordare imediata a acestei probleme ar fi sa determinam pentru fiecare punct in O(N) daca este sau nu in interiorul poligonului. Exista mai multe moduri de a rezolva acest lucru. Un mod ar fi sa ducem o semidreapta pornind din punctul nostru si sa vedem de cate ori intersecteaza laturile poligonului: daca intersecteaza poligonul de un numar par de ori atunci inseamna ca punctul este in exterior, iar daca ea intersecteaza de un numar impar de ori laturile poligonului inseamna ca punctul este in interior. O alta modalitate: calculam suma unghiurilor pe care le fac extremele laturilor cu punctul nostr (unghiurile sunt luate pozitive sau negative dupa cum cele 3 puncte ce formeaza unghiul sunt in sens trigonometric sau orar), daca suma unghiurilor pentru toate laturile e 0 atunci punctul e in exteriorul poligonului, iar daca suma unghiurilor e 2*Pi atunci punctul e in interiorul poligonului, pentru mai multe detalii puteti\r\nsa va uitati pe urmatoarele pagini:\r\n\r\nhttp://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\r\nhttp://softsurfer.com/Archive/algorithm_0103/algorithm_0103.htm\r\n\r\nDimensiunile datelor de intrare ne sugereaza ca trebuie sa acceleram determinarea pozitiei punctelor fata de poligon. Daca poligonul ar fi convex, este usor sa facem acest test in O(log N): consideram un varf al poligonului si semidrepte ce pleaca din el spre celelalte varfuri, cu cautare binara gasim in ce sector determinat de doua semidrepte intra punctul pentru care vrem sa determinam incluziunea in poligon, dupa ce gasim sectorul testul de incluziune se reduce la determinarea incluziunii intr-un triunghi. Aceasta metoda eleganta si simpla merge pentru poligon convex, dar pentru unul oarecare trebuie sa gasim o alta abordare.\r\n\r\nPentru poligoane concave, mergand pe aceeasi idee, impartirea in zone pentru care este mai usor sa determinam incluziunea se va face un pic diferit. Sortam coordonatele x ale punctelor poligonului si ducem prin fiecare coordonata x distincta cate o dreapta verticala. Se formeaza astfel niste benzi verticale intersectate de laturile poligonului. Pentru fiecare banda tinem minte ce laturi ale poligonului intersecteaza aceasta banda si sortam aceste laturi pe verticala dupa mijlocul segmentului de intersectie al laturii cu banda. Acum pentru a determina daca un punct e in interiorul poligonului, determinam cu cautare binara mai intai banda din care face parte si apoi pentru banda respectiva deasupra cator segmente se afla, daca punctul e deasupra unui numar par de segmente atunci punctul e in exterior si daca e deasupra unui numar impar e interior. Astfel rezolvarea noastra are complexitatea O(N^2 log N) in faza de preprocesare si O(log N) pentru a determina pentru fiecare punct daca este interior sau\r\nexterior poligonului. Complexitatea totala va fi O(N^2 log N + M log N).\r\n\r\n',961,'public'),('usaco-dec-2005-divizia-gold','USACO dec 2005, divizia GOLD','2006-01-05 00:00:00','h1. USACO dec 2005, divizia GOLD\n\n(Creat de \'_domino_\':user/domino la data de _2006-01-05_ categoria __, autor(i) _Daniel Pasaila, Mircea Pasoi_)\n\n*Continut scurt:*\n ==Include(page=\"template/raw\")==\n\nIn acest articol veti gasi solutiile pentru problemele propuse la concursul USACO, editia din luna decembrie 2005, divizia GOLD. Testele si enunturile sunt disponibile la sectiunea Download.\n\n\n*Continut lung:*\n==Include(page=\"template/raw\")==\n\nCow Patterns\n\n\n\nSolutia propusa in acest articol foloseste un algoritm de genul Rabin Karp. In aceasta problema alfabetul folosit este Sigma = {1, 2, ... S}, deci putem privi un sir de K caractere consecutive ca reprezentand un numar in baza S de lungime K. Spunem ca modelul este vectorul P[1..K] iar textul dat este T[1..N].\n\nFiind dat modelul P[1..K] notam cu p valoarea sa corespunzatoare in baza S. Intr-o maniera similara, fiind dat textul T[1..N], notam cu t_s valoarea in baza S a subsirului convertit T[s + 1...s + m]. In cazul in care gasim un subsir cu valoarea t_s = p atunci am gasit o potrivire a modelului pe text. Dificultatile care apar in rezolvarea problemei tin de convertirea sirului T in timp real, dupa conditiile impuse de enuntul problemei. Astfel, ne deplasam cu un sablon de lungime K spre dreapta. Pentru fiecare deplasament trebuie sa modificam valoarea t_s corespunzator. La deplasarea cu o pozitie apar urmatoarele cazuri:\n\n1. din sablon iese o valoare unica sau intra o valoare care nu exista in deplasamentul curent.\n\n2. din sablon iese o valoare care va exista si in deplasamentul urmator, si intra o valoare care exista deja in deplasamentul curent\n\nVom rezolva cazul 1 in O(K), convertind subsirul curent dupa regulile din enunt. Observam ca in cazul 2 dupa efectuarea deplasamentului sablonul va contine aceleasi cifre. Aceasta operatie este deci doar o deplasare, deci o putem efectua in O(1) exact ca la Rabin Karp.\n\nDesi complexitatea algoritmului pare ca este O(N * K), la o analiza mai atenta ne dam seama ca ea este de fapt O(N * S). Sa incercam sa calculam de cate ori poate aparea cazul 1 in deplasare. Trebuie sa observam ca un element odata intrat in sablon mai poate genera cazul 1 abia dupa K elemente, deci numarul total in cel mai defavorabil caz este N/K * S. Complexitatea algoritmului devine acum O(K * N/K * S + N) deci O(N * S).\n\nLa implementare, toate operatiile se fac modulo Q (unde Q este un numar prim destul de mare). Acum poate vi se pare ca de fiecare data cand t_s = p ar trebui sa comparam in O(K) cele doua subsiruri, complexitatea totala crescand. O analiza probabilistica ne arata ca pentru Q prim si destul de mare sansele ca doua subsiruri diferite de lungime K sa fie echivalente modulo Q sunt foarte mici, deci o solutie care compara doar modulele numerelor va lua punctajul maxim fara probleme.\n\n\n\nBarn expansion\n\n\n\nDupa cum au aratat-o si rezultatele, aceasta problema a fost cea mai simpla din concurs. Trebuie sa determinam numarul de dreptunghiuri a caror laturi nu intalnsesc laturile altor dreptunghiuri. De asemenea, sa nu uitam ca dreptunghiurile nu se pot suprapune. In aceste conditii observam ca daca doua dreptunghiuri se intersecteaza atunci se vor intersecta si 2 segmente verticale sau 2 segmente orizontale. Putem astfel sa luam mai intai toate segmentele verticale, vedem care dintre acestea se intersecteaza cu altele si marcam dreptunghiurile lor ca fiind rele. Repetam algoritmul si pentru segmentele orizontale, iar la sfarsit numaram cate dreptunghiuri bune ne-au ramas.\n\nProblema pe care trebuie sa o rezolvam acum este urmatoarea: avand K segmente paralele cu axa Oy trebuie sa determinam care dintre acestea se intersecteaza cu altele. Pentru aceasta sortam segmentele in primul rand dupa coordonata x si in al 2-lea rand dupa coordonata y minima. Dupa aceasta sortare putem determina in O(K) segmentele care se intersecteaza. Parcurgem vectorul de la stanga la dreapta, si pentru fiecare pas vedem daca segmentul curent se intersecteaza cu un segment precedent. Pentru aceasta trebuie sa tinem o variabila ls care reprezinta coordonata y maxima atinsa pana la un moment dat. Pentru segmentul i fie ymin_i, ymax_i si x_i coordonatele lui. Pentru un i daca x_i != x_i*1 sau ymin_i > ls initializam ls cu ymax_i. Altfel marcam segmentul i si segmentul cu care am obtinut maximul ls ca fiind rele, iar ls devine MAX(ls, ymax_i).\n\nProblema se rezolva similar si pentru segmentele orizontale. Complexitatea algoritmului este O(N logN).\n\n\n\nLayout\n\nVom nota pozitiile celor N vaci cu x[1], x[2] ... x[N] si vom transforma fiecare relatie care se da intr-o constrangere de forma x[i] - x[j] <= C. Cum se impune din enunt ca x[1] <= x[2] <= ... <= x[N], vom introduce initial constrangeri de forma x[i] - x[i+1] <= 0 (i < N). Apoi, pentru fiecare perechi de vaci i < j care trebuie sa fie la distanta maxim D, vom introduce constrangerea x[j] - x[i] <= D, iar pentru fiecare pereche i < j care trebuie sa fie la distanta de minim D, vom introduce constrangerea x[i] - x[j] <= -D. Trebuie acum sa rezolvam acest sistem de constrangeri.\nMotivul pentru toate constrangerile sunt de forma x[i] - x[j] <= C , este pentru a modela aceasta problema folosind teoria grafurilor. Vom considera vacile ca fiind noduri de la 1 la N, iar fiecare constrangere x[i] - x[j] <= C va reprezenta o muchia de la j la i cu costul C. In acest graf vom determina distantele minime de la 1 la fiecare nod intr-un vector D. Din definitia distantelor minime in grafuri , pentru o muchie (j, i) de cost C se respecta relatia D[i] <= D[j] + C, echivalenta cu D[i] - D[j] <= C. Asadar vectorul D va respecta fiecare constrangere formulata anterior pentru vectorul x. Fiindca graful este rar (MD+ML+N-1 muchii), se va folosi algoritmul Bellman-Ford pentru determinarea distantelor mimine, avand complexitatea O(N*(MD+ML+N)). Modul in care lucreaza algoritmul Bellman-Ford asigura ca distanta dintre vaca 1 si vaca N este maximizata.\nCazul cand vacile puteau fi asezate oricat de departe se putea detecta verificand daca distanta pana la vaca N este infinit. De asemenea, cazul cand problema nu avea solutie putea fi detectat tot cu Bellman Ford, verificand daca exista un ciclu de cost negative accesibil din nodul 1. Demonstratia ca atunci cand graful contine un ciclu negativ nu exista solutie o lasam pe seama cititorului.\n\n',0,'public'),('usaco-dec-2005-divizia-gold','USACO dec 2005, divizia GOLD','2006-11-19 12:37:20','h1. USACO dec 2005, divizia GOLD\r\n\r\n(Creat de ==user(user=\"domino\" type=\"tiny\")== la data de _2006-01-05_ categoria __, autor(i) _Daniel Pasaila, Mircea Pasoi_)\r\n\r\n ==Include(page=\"template/raw\")==\r\n\r\nIn acest articol veti gasi solutiile pentru problemele propuse la concursul USACO, editia din luna decembrie 2005, divizia GOLD. \"Teste si enunturile\":http://www.infoarena.ro/downloads?action=download&file=usaco.zip problemelor sunt disponibile in sectiunea Download.\r\n\r\nh2. Cow Patterns\r\n\r\nSolutia propusa in acest articol foloseste un algoritm de genul Rabin Karp. In aceasta problema alfabetul folosit este {$Sigma = {1, 2, ... S}$}, deci putem privi un sir de $K$ caractere consecutive ca reprezentand un numar in baza $S$ de lungime {$K$}. Spunem ca modelul este vectorul $P[1..K]$ iar textul dat este {$T[1..N]$}.\r\n\r\nFiind dat modelul $P[1..K]$ notam cu $p$ valoarea sa corespunzatoare in baza {$S$}. Intr-o maniera similara, fiind dat textul {$T[1..N]$}, notam cu $t{~s~}$ valoarea in baza $S$ a subsirului convertit {$T[s + 1...s + m]$}. In cazul in care gasim un subsir cu valoarea $t{~s~} = p$ atunci am gasit o potrivire a modelului pe text. Dificultatile care apar in rezolvarea problemei tin de convertirea sirului $T$ in timp real, dupa conditiile impuse de enuntul problemei. Astfel, ne deplasam cu un sablon de lungime $K$ spre dreapta. Pentru fiecare deplasament trebuie sa modificam valoarea $t{~s~}$ corespunzator. La deplasarea cu o pozitie apar urmatoarele cazuri:\r\n\r\n# din sablon iese o valoare unica sau intra o valoare care nu exista in deplasamentul curent.\r\n# din sablon iese o valoare care va exista si in deplasamentul urmator, si intra o valoare care exista deja in deplasamentul curent\r\n\r\nVom rezolva cazul $1$ in {$O(K)$}, convertind subsirul curent dupa regulile din enunt. Observam ca in cazul $2$ dupa efectuarea deplasamentului sablonul va contine aceleasi cifre. Aceasta operatie este deci doar o deplasare, deci o putem efectua in $O(1)$ exact ca la Rabin Karp.\r\n\r\nDesi complexitatea algoritmului pare ca este {$O(N * K)$}, la o analiza mai atenta ne dam seama ca ea este de fapt {$O(N * S)$}. Sa incercam sa calculam de cate ori poate aparea cazul $1$ in deplasare. Trebuie sa observam ca un element odata intrat in sablon mai poate genera cazul $1$ abia dupa $K$ elemente, deci numarul total in cel mai defavorabil caz este {$N/K * S$}. Complexitatea algoritmului devine acum $O(K * N/K * S + N)$ deci {$O(N * S)$}.\r\n\r\nLa implementare, toate operatiile se fac modulo $Q$ (unde $Q$ este un numar prim destul de mare). Acum poate vi se pare ca de fiecare data cand $t{~s~} = p$ ar trebui sa comparam in $O(K)$ cele doua subsiruri, complexitatea totala crescand. O analiza probabilistica ne arata ca pentru $Q$ prim si destul de mare sansele ca doua subsiruri diferite de lungime $K$ sa fie echivalente modulo $Q$ sunt foarte mici, deci o solutie care compara doar modulele numerelor va lua punctajul maxim fara probleme.\r\n\r\nh2. Barn expansion\r\n\r\nDupa cum au aratat-o si rezultatele, aceasta problema a fost cea mai simpla din concurs. Trebuie sa determinam numarul de dreptunghiuri a caror laturi nu intalnsesc laturile altor dreptunghiuri. De asemenea, sa nu uitam ca dreptunghiurile nu se pot suprapune. In aceste conditii observam ca daca doua dreptunghiuri se intersecteaza atunci se vor intersecta si $2$ segmente verticale sau $2$ segmente orizontale. Putem astfel sa luam mai intai toate segmentele verticale, vedem care dintre acestea se intersecteaza cu altele si marcam dreptunghiurile lor ca fiind rele. Repetam algoritmul si pentru segmentele orizontale, iar la sfarsit numaram cate dreptunghiuri bune ne-au ramas.\r\n\r\nProblema pe care trebuie sa o rezolvam acum este urmatoarea: avand $K$ segmente paralele cu axa Oy trebuie sa determinam care dintre acestea se intersecteaza cu altele. Pentru aceasta sortam segmentele in primul rand dupa coordonata $x$ si in al 2-lea rand dupa coordonata $y$ minima. Dupa aceasta sortare putem determina in $O(K)$ segmentele care se intersecteaza. Parcurgem vectorul de la stanga la dreapta, si pentru fiecare pas vedem daca segmentul curent se intersecteaza cu un segment precedent. Pentru aceasta trebuie sa tinem o variabila ls care reprezinta coordonata $y$ maxima atinsa pana la un moment dat. Pentru segmentul $i$ fie {$ymin{~i~}$}, $ymax{~i~}$ si $x{~i~}$ coordonatele lui. Pentru un $i$ daca $x{~i~} != x{~i-1~}$ sau $ymin{~i~} > ls$ initializam $ls$ cu {$ymax{~i~}$}. Altfel marcam segmentul $i$ si segmentul cu care am obtinut maximul $ls$ ca fiind rele, iar $ls$ devine {$MAX (ls, ymax{~i~})$}.\r\n\r\nProblema se rezolva similar si pentru segmentele orizontale. Complexitatea algoritmului este {$O(N logN)$}.\r\n\r\nh2. Layout\r\n\r\nVom nota pozitiile celor $N$ vaci cu $x{~1~}, x{~2~} ... x{~N~}$ si vom transforma fiecare relatie care se da intr-o constrangere de forma {$x{~i~} - x{~j~} &le; C$}. Cum se impune din enunt ca {$x{~1~} &le; x{~2~} &le; ... &le; x{~N~}$}, vom introduce initial constrangeri de forma {$x{~i~} - x{~i+1~} &le; 0$} ({$i < N$}). Apoi, pentru fiecare perechi de vaci $i < j$ care trebuie sa fie la distanta maxim {$D$}, vom introduce constrangerea {$x{~j~} - x{~i~} &le; D$}, iar pentru fiecare pereche $i < j$ care trebuie sa fie la distanta de minim {$D$}, vom introduce constrangerea {$x{~i~} - x{~j~} &le; -D$}. Trebuie acum sa rezolvam acest sistem de constrangeri.\r\n\r\nMotivul pentru toate constrangerile sunt de forma {$x{~i~} - x{~j~} &le; C$} , este pentru a modela aceasta problema folosind teoria grafurilor. Vom considera vacile ca fiind noduri de la $1$ la {$N$}, iar fiecare constrangere {$x{~i~} - x{~j~} &le; C$} va reprezenta o muchia de la $j$ la $i$ cu costul {$C$}. In acest graf vom determina distantele minime de la $1$ la fiecare nod intr-un vector {$D$}. Din definitia distantelor minime in grafuri , pentru o muchie ({$j, i$}) de cost $C$ se respecta relatia {$D{~i~} &le; D{~j~} + C$}, echivalenta cu {$D{~i~} - D{~j~} &le; C$}. Asadar vectorul $D$ va respecta fiecare constrangere formulata anterior pentru vectorul {$x$}. \r\n\r\nFiindca graful este rar ({$MD+ML+N-1$} muchii), se va folosi algoritmul Bellman-Ford pentru determinarea distantelor mimine, avand complexitatea O({$N*(MD+ML+N)$}). Modul in care lucreaza algoritmul Bellman-Ford asigura ca distanta dintre vaca $1$ si vaca $N$ este maximizata. Cazul cand vacile puteau fi asezate oricat de departe se putea detecta verificand daca distanta pana la vaca $N$ este infinit. De asemenea, cazul cand problema nu avea solutie putea fi detectat tot cu Bellman Ford, verificand daca exista un ciclu de cost negative accesibil din nodul {$1$}. Demonstratia ca atunci cand graful contine un ciclu negativ nu exista solutie o lasam pe seama cititorului.\r\n\r\n',0,'public'),('summer-challenge-unu/solutii','Solutii - Summer Challenge Unu','2006-11-21 10:01:25','h1. Solutii - Summer Challenge Unu\r\n\r\n(Creat de ==user(user=\"Cosmin\" type=\"tiny\")== la data de _2006-08-03_ categoria __, autor(i) _Cosmin_)\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nConcursul a fost unul reusit, adunand un numar respectabil de participanti.\r\nConcurentii ce vor participa la IOI au fost in forma azi ocupand primele trei pozitii ale clasamentului. greco a impresionat placut fiind singurul ce a rezolvat perfect problema de idee a concursului. Il remarcam pozitiv si pe wefgef care se tine aproape de ei, de asemenea o remarca negativa ar fi la adresa lui Adrian Vladu care nu a participat la aceasta pregatire ,desi ea a fost adresata direct lotului olimpic.\r\n\r\nUrmeaza primii 10 clasati:\r\n\r\n==Rankings(rounds=\"summer2006\" display_entries=\"10\" pager_style=\"none\")==\r\n\r\nVa invitam mai departe sa va uitati peste schitele solutiilor problemelor propuse.\r\n\r\nh2. Free\r\n\r\nAceasta problema a fost considerata cea mai simpla din concurs, in special pentru ca realizarea unui program experimental care simula pasii din problema ne arata ca usile ce raman inchise au ca index un patrat perfect.\r\n\r\nPentru a demonstra aceasta afirmatie avem nevie de cateva cunostinte minore de teoria numerelor.\r\n\r\nLa fiecare pas $i$ directorul va vizita toti multiplii lui {$i$}, ceea ce inseamna ca un anumit numar $X4 va fi vizitat la pasii ai caror indecsi il divid pe {$X$}. Deci pentru a afla cate usi vor fi deschise in final va trebui sa numaram cate numere au un numar par de divizori. Pentru acest lucru ne va si mai usor sa numaram cate au un numar impar de divizori urmand sa le scadem din {$N$}. Stim ca daca descompunem un numar $X$ in factori primi: {$X=F{~1~}^P{~1~}^*F{~2~}^P{~2~}^*...*F{~t~}^P{~t~}^$} numarul de divizori ai sai va fi {$D=(P{~1~}+1)*(P{~2~}+1)*...*(P{~t~}+1)$}. Pentru ca $D$ sa fie impar trebuie ca fiecare factor al produsului sa fie deci $P{~i~}+1$ impar ceea ce inseamna ca exponentii factorilor primi din descompunere vor fi pari. {$X=F{~1~}^2*P\'{~1~}^*F{~2~}^2*P\'{~2~}^*...*F{~t~}^2*P\'{~t~}^ = (F{~1~}^P\'{~1~}^*F{~2~}^P\'{~2~}^*...*F{~t~}^P\'{~t~}^)^2^$}. Inseamna ca $X$ va fi patrat pefrect.\r\n\r\nAlta demonstratie mai intuitiva ar fi ca pentru usa $X$ putem imperechea actiunea $i$ cu actiunea $X/i$ daca $i$ este divizor al lui $X$ si astfel cele doua isi anuleaza efectul. Daca $X$ este patrat perfect atunci actiunea $[sqrt(X)]$ ramane neimperecheata, deci usa ramane deschisa.\r\n\r\nAstfel solutia problemei va fi {$N-[sqrt(N)]$}.\r\n\r\nOperatiile trebuie implementate pe numere mari. Operatia radical se poate implementa folosind o cautare binara.\r\n\r\nh2. Patrol\r\n\r\nAceasta problema a fost considerata una medie, pentru ca algoritmii de drum minim in grafuri sunt foarte frecvent folositi la concursurile de programare.\r\n\r\nObsevam ca fiecare paznic va fi la orasul de unde a pornit la timpii multipli de 2*(l[i]-1) (din cauza miscarii dute-vino). Astfel toti paznicii vor fi in acelasi timp la orasul initial al fiecaruia la toti timpii multipli de cmmmc(2*(l[1]-1), 2*(l[2]-1), ..., 2*(l[n]-1)). Din cauza ca l[i] < 8 cel mai mic multiplu comun maxim posibil al numerelor din problema poate fi cmmmc(2*4, 2*3, 2*5) = 120, astfel pozitiile paznicilor pe reteaua noastra de orase cicleaza si perioada ciclului este 120 sau un divizor al sau. Vom crea un graf in care nodurile sunt stari ale problemei (oras, timp % 120). Acum am redus problema la determinarea drumului de cost minim de la (1, 0) la (N, timp % 120), putem folosi un algoritm de drum minim la alegere Dijkstra cu heapuri sau bellman ford.\r\n\r\nh2. Pscpld\r\n\r\nAceasta problema se vroia a fi cea mai grea din concurs. O solutie bazata pe siruri de sufixe poate fi gasita in articolul \"Siruri de sufixe\" Adrian Vladu, Negruseri Cosmin, GInfo. Aceasta rezolvare nu ar fi luat punctaj maxim, o solutie similara in O(n) foloseste arbori de sufixe. Denumirea problemei a fost aleasa pentru a sugera ca rezolvarea greoaie cu arbori de sufixe nu este cea cautata. Problema are o solutie simpla in O(n) care urmeaza ideea rezolvarii in O(n^2).\r\n\r\nIn rezolvarea brute force fixam un centru pentru un palindrom si incercam sa marim palindromul cat mai mult. Solutia va pastra un sir LUNG unde LUNG[2i - 1] reprezinta lungimea palindromului maxim centrat in caracterul i al sirului si LUNG[2i] lungimea palindromului centrat intre caracterul i si i + 1 al sirului. Vom parcurge sirul de caractere de la stanga la dreapta si vom afla in ordine valorile din sirul LUNG.\r\nSa luam un exemplu:\r\n\r\nsirul: a b a a b a c\r\n\r\nLUNG: 1 0 3 0 1 6 1 0 x\r\n\r\nindice: 1 2 3 4 5 6 7 8 9 10 11 12 13\r\n\r\nAcum daca vrem sa calculam LUNG[9] ar trebui sa ne extindem cat putem in lateral fata de b, dar observam ca centrul palindromului curent este continut in palindromul centrat la 6. Din faptul ca palindromul contine doua subsecvente oglindite, noi nu trebuie sa mai iteram prin literele palindromului nostru pentru ca avem deja rezolvata problema oglindita, si continuam comparatiile cu caractere noi (in cazul nostru avem deja rezolvata problema a b a in secventa [1..5] si nu mai trebuie sa o rezolvam inca o data). Am obtinut astfel o rezolvare simpla de complexitate O(N). Mentionam ca sursa oficiala nu are mai mult de 50 de linii.\r\n\r\nExista si alte rezolvari optime posibile si ii rugam pe cei care au luat 100 de puncte sa le explice in cadrul forumului.\r\n\r\n',961,'public'),('documentatie','Documentatie','2006-11-21 15:51:32','Asta este pagina de inceput a documentatiei, momentan are doar un vag outline. Eu propun cate o pagina pentru fiecare dintre subiectele astea.\r\n\r\nh2: Subiecte de acoperit\r\n\r\n* \'Wiki\':Docs/Wiki: Totul despre formatare.\r\n** \'Sintaxa Textile\':Docs/Textile. Copiat de pe hobix si din ce a scris buru.\r\n** \'Macro-uri\':Docs/Macros. Ce sunt, cum se folosesc, cateva macro-uri comune.\r\n** \'Conventii de formatare\':Docs/Conventii.\r\n*** \'Pentru enunturi\':Docs/Conventii/Probleme.\r\n*** \'Pentru concursuri\':Docs/Conventii/Runde.\r\n*** \'Pentru stiri\':Docs/Conventii/Stiri.\r\n* \'Ghid utilizator\':Docs/GhidUtilizatori. Inregistrare, submit, monitor, clasament. Cat mai scurt.\r\n* \'Ghid propunatori\':Docs/GhidPropunatori: Cum devii propunator, ce inseamna.\r\n** \'Probleme/Runde private\':Docs/PrivateContent. Task-uri/Runde private.\r\n** \'Editare de probleme\':Docs/EditareProbleme: cum se pun teste, cum se verifica etc.\r\n** \'Editare de runde\':Docs/EditareRunde: cum sa fac un concurs privat.\r\n* \'Ghid administratori:Docs/GhidAdmini.\r\n** \'Securitate\':Docs/Securitate.\r\n** \'Template-uri\':Docs/Templates.\r\n** \'Development stuff\':Docs/Development.\r\n** \'Cum sa ceri/scrii macro-uri\':Docs/NewMacros.\r\n** \'Pagini speciale\':Docs/AdminPages.\r\n\r\nh2. ',1142,'public'),('links','Link-uri','2006-11-05 23:22:35','h1. Resurse\n\nh2. Olimpiade (4 link-uri)\n\n* \'Olimpiade.ro\':http://www.olimpiade.ro (\'fluffy\':user/fluffy @ 2004-11-19)\nNu este strict despre informatica, este site-ul tuturor olimpiadelor romanesti. Are un numar mare de subiecte de pe la olimpiade.\n* \'olimpiada.info\':http://olimpiada.info/ (\'wickedman\':user/wickedman @ 2004-11-18)\nAceast site se prezinta ca pagina de plecare a Olimpiadei Nationale de Informatica. Nu te-ai saturat sa cauti in fiecare an un nou site, o noua adresa, o noua locatie a olimpiadei? Ei bine, de acum inainte tot ce este nevoie sa tii minte este http://olimpiada.info. \r\n\n* \'Olimpiada Nationala de Informatica 2004\':http://olimpiada.info/oni2004/ (\'gigi\':user/gigi @ 2004-08-11)\nSite-ul oficial al Olimpiadei Nationale de Informatica 2004, Buzau.\n* \'Olimpiada Judeteana de Informatica\':http://www.e-vrancea.com/oji/ (\'wickedman\':user/wickedman @ 2004-08-11)\nEste pagina oficiala a Olimpiadei Judetene de Informatica si ofera informatii real-time despre aceasta competitie. Tot aici se calculeaza listele de elevi ce se califica la ONI.\n\nh2. Concursuri online (11 link-uri)\n\n* \'Algoritmus\':http://www.algoritmus.org/index.php (\'domino\':user/domino @ 2004-11-10)\n&quot;Algoritmus&quot; este un concurs de programare cu premii, la care au drept de participare toti elevii de liceu din Romania.\n* \'Saratov State University :: Online Contester\':http://acm.sgu.ru (\'domino\':user/domino @ 2004-11-10)\nSite de antrenament pentru ACM, contine aproape 200 de probleme, dar nivelul de dificultate al problemelor este mult mai ridicat decat la celalte site-uri de acest tip.\n* \'TopCoder\':http://www.topcoder.com/tc (\'Cosmin\':user/Cosmin @ 2004-11-10)\nUn concurs de programare foarte popular. Accentul este pus mai mult pe viteza si acuratete decat pe probleme foarte grele.\n* \'IPSC - Internet Problem Solving Contest\':http://ipsc.ksp.sk/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Cel mai prestigios concurs online pe echipe. Problemele sunt frumoase si e primul concurs care cere nu surse de solutii ci outputuri pentru testele publicate.\n* \'Sphere Online Judge\':http://spoj.sphere.pl/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Online Judge cu probleme date la concursuri din Polonia.\n* \'Waterloo Programming Contests\':http://plg.uwaterloo.ca/~acm00/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Universitatea Waterloo din Canada organizeaza concursuri de pregatire pentru ACM. Pe acest site gasiti texte, teste si solutii ale acestor concursuri. Probleme de aici au fost folosite ca surse de inspiratie pt lotul roman si pentru balcaniada in 2000 parca ...\n* \'.campion\':http://www.liis.ro/~campion/ (\'wickedman\':user/wickedman @ 2004-10-12)\n&quot;.campion&quot; este un program de pregatire de performanta in informatica sustinut de profesori de prestigiu din tara - membri ai Comisiei Nationale de Informatica si de studenti - fosti olimpici internationali la informatica.\n* \'info-arena\':http://infoarena.devnet.ro/ (\'wickedman\':user/wickedman @ 2004-08-13)\nSite-ul info-arena vine in sprijinul elevilor, studentilor si profesorilor pasionati de informatica punand la dispozitie o arhiva de probleme de informatica atent alese, un evaluator online disponibil 24/7 si un forum. Tot aici se organizeaza periodic concursuri online de informatica.\n* \'Contaminare in programare\':http://www.contaminare.ro/ (\'wickedman\':user/wickedman @ 2004-08-13)\nContaminare.ro este un proiect al Palatul National al Copiilor, una din cele mai prestigioase institutii de instruire a copiilor in informatica din invatamantul preuniversitar. Contaminare.ro este una din cele mai indraznete modalitati interactive de pregatire a copiilor pasionati de programare. \n* \'ACM, University of Vallaloid\':http://acm.uva.es/ (\'wickedman\':user/wickedman @ 2004-08-11)\nEste cel mai mare site din reteaua ACM, ofera o arhiva de peste 1000 de probleme si o lista de discutii de cateva zeci de mii de membri. Site-ul organizeaza regulat concursuri online.\n* \'ACM, Ural State University\':http://acm.timus.ru/ (\'wickedman\':user/wickedman @ 2004-08-10)\nSite din reteaua ACM intretinut de Ural State University. O buna parte din problemele de aici sunt foarte interesante si pregatitoare. Demn de mentionat este faptul ca la realizarea acestei arhive au contribuit si cativa olimpici romani internationali.\n\nh2. Liste de discutii (2 link-uri)\n\n* \'Forum-ul oficial GInfo\':http://ba.toptalent.ro/forum/index.php (\'domino\':user/domino @ 2005-10-17)\nForumul oficial al revistei GInfo,\r\nrevista viitorilor specialisti in tehnologia informatiei.\n* \'Lista lui Francu\':http://probleme.francu.com (\'wickedman\':user/wickedman @ 2004-08-11)\n&quot;... o lista de e-mail care isi propune in principal sa ajute la pregatirea elevilor de liceu pentru concursurile de informatica.&quot;\n\nh2. Limbaje, compilatoare (2 link-uri)\n\n* \'Free Pascal\':http://www.freepascal.org/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n  Pagina oficiala a unui compilator pascal pe 32 de biti, gratuit folosit la concursurile internationale. La ACM ICPC s-a luat decizia ca in viitorul apropiat sa se renunte la limbajul pascal. Deja in unele concursuri regionale nu mai e folosit.\n* \'DJGPP\':http://www.delorie.com/djgpp/ (\'wickedman\':user/wickedman @ 2004-08-10)\nAceasta este pagina oficiala a distributiei DJGPP - un compilator ANSI C ce ruleaza pe sisteme Microsoft Windows. DJGPP este folosit cu precadere la olimpiadele si concursurile nationale si internationale.\n\nh2. Editoare, platforme (1 link-uri)\n\n* \'RHIDE\':http://www.rhide.com/ (\'wickedman\':user/wickedman @ 2004-08-12)\nRHIDE este unul dintre cele mai folosite IDE-uri la olimpiada. Seamana foarte mult cu interfata &quot;albastra&quot; Borland, are debugging integrat si functioneaza atat pe Windows cat si pe Linux.\n\nh2. Carti si publicatii (8 link-uri)\n\n* \'Solutii pentru cateva probleme din CLR\':http://www.itu.dk/people/beetle/teaching/ (\'Cosmin\':user/Cosmin @ 2005-03-24)\n Veti gasi pe aceasta pagina cateva solutii pentru problemele din cartea &quot;Introducere in algoritmi&quot;, parcurgerea lor e un bun pas inspre rezultate bune la olimpiadele de informatica.\n* \'Algoritmi Fundamentali\':http://www.cwu.edu/~andonie/Cartea%20de%20algoritmi/toc.htm (\'wickedman\':user/wickedman @ 2005-03-10)\nO carte online scrisa de Prof. Razvan Andonie si Ilie Garbacea.\r\nCartea prezinta structurile de date uzuale, analiza eficientei algoritmilor, tehnici de programare, algoritmi de explorare a grafurilor si concepte OOP.\r\nLa sfarsitul fiecarui capitol sunt adaugate exercitii, multe dintre ele rezolvate.\n* \'Introduction to Algorithms\':http://zhuzeyuan.hp.infoseek.co.jp/ita/toc.htm (\'Cosmin\':user/Cosmin @ 2004-11-12)\nNu are nevoie de introducere.\n* \'Algorithms Courses on the WWW\':http://www.cs.pitt.edu/~kirk/algorithmcourses/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Un site cu linkuri spre cursuri de algoritmica ale universitatilor puternice din State. Materialul in general este accesibil unui elev de liceu ce se pregateste pt ONI sau alte concursuri mai puternice.\n* \'Ferguson: Game Theory\':http://www.math.ucla.edu/~tom/Game_Theory/Contents.html (\'Cosmin\':user/Cosmin @ 2004-11-10)\n  Carte despre teoria jocurilor. Capitolul I este interesant pentru unele probleme folosite in concursurile de programare.\n* \'EWD Archive\':http://www.cs.utexas.edu/users/EWD/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n  Articole din corespondenta lui Dijkstra cu colegii algoritmicieni. Multe din articole sunt stufoase si greu de citit dar se gasesc si foarte multe idei interesante.\n* \'Numerical Recipes in C\':http://www.library.cornell.edu/nr/bookcpdf.html (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Poate majoritatea subiectelor tratate in carte sunt prea avansate pentru elevii de liceu, dar sunt si subiecte accesibile si folositoare.\n* \'Revista GInfo\':http://www.ginfo.ro/ (\'wickedman\':user/wickedman @ 2004-08-12)\nFoarte populara in randurile informaticienilor, GInfo este o revista de prestigiu in domeniu ce pune la dispozitia cititorilor articole foarte valoroase despre informatica si concursuri de programare. Site-ul ofera spre download gratuit toate numerele revistei (in afara de ultimul) in format PDF. \n\nh2. Algoritmi (6 link-uri)\n\n* \'Topcoder algorithm tutorials\':http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=index (\'Cosmin\':user/Cosmin @ 2005-05-17)\nO serie de tutoriale pentru cunostintele de  baza de care aveti nevoie in concursurilor de programare, deocamdata cateva subiecte interesante sunt geometrie computationala, greedy, programare dinamica, matematica pt concursuri de programare si folosirea expresiilor regulare.\n* \'Algorithmist\':http://www.algorithmist.com/index.php/Main_Page (\'domino\':user/domino @ 2005-03-13)\nSite cu explicatii pentru diversi algoritmi si solutii pentru cateva probleme de la ACM.UVA.ES\n* \'comp.graphics.algorithms Frequently Asked Questions\':http://www.faqs.org/faqs/graphics/algorithms-faq/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n O lista de intrebari si raspunsuri frecvente legate de geometrie computationala.\n* \'Graph Theory\':http://www.math.fau.edu/locke/graphthe.htm (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Notiuni si teoreme legate de teoria grafurilor.\n* \'The Aggregate Magic Algorithms\':http://aggregate.org/MAGIC/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Algoritmi low level, optimizari, operatii pe biti.\n* \'Stony Brook Algorithm Repository\':http://www.cs.sunysb.edu/~algorith/ (\'wickedman\':user/wickedman @ 2004-08-12)\nUn site ce serveste ca o colectie comprehensiva de implementari de algoritmi, intretinut de Steven Skiena - unul dintre cei mai prestigiosi algoristi din lume.\n\nh2. General (17 link-uri)\n\n* \'TJHSST&#039;s Senior Computer Team\':http://activities.tjhsst.edu/sct/ (\'Cosmin\':user/Cosmin @ 2005-05-27)\n Siteul de pregatire pentru concursuri de programare a liceului Thomas Jefferson, cel mai tare liceu din SUA la acest capitol.\n* \'Pareri ale fostilor olimpici despre olimpiada de informatica\':http://olimpiada.info/index.php?cid=quotes (\'wickedman\':user/wickedman @ 2005-03-10)\nO lista de pareri ale fostilor olimpici la informatica ai Romaniei. Daca nu sunteti siguri la ce e buna olimpiada si informatica in general cititi cateva randuri de acolo. ;)\n* \'Cut the Knot\':http://www.cut-the-knot.org/content.shtml (\'Cosmin\':user/Cosmin @ 2004-11-20)\nInteractive Mathematics Miscellany and Puzzles\r\n\n* \'Don Knuth: Musings\':http://scpd.stanford.edu/knuth/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Profesorul Knuth nu mai preda dar tine din cand in cand cate un curs despre ceva legat de algoritmica ce i se pare lui interesant. Aveti pe acest site acces la cateva din aceste cursuri ce au fost filmate. Din pacate trebuie o conexiune destul de buna.\n* \'Personal homepage of Zeyuan Zhu\':http://zhuzeyuan.hp.infoseek.co.jp/index.htm (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Pagina personala a unui reprezentant al Chinei la IOI. Contine idei la multe probleme de pe acm.timus.ru si probleme interesante ale autorului. De asemenea contine si versiunea online a cartii Introduction to Algorithms de Cormen, Leiserson si Rivest, carte de baza pentru concursurile de programare.\n* \'Google\':http://www.google.com (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Cel mai util site ;)\n* \'MathWorld\':http://mathworld.wolfram.com/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n  Daca intalniti o notiune de matematica care nu o intelegeti sau vreti sa o aprofundati acest site este ceea ce cautati.\n* \'On-Line Encyclopedia of Integer Sequences\':http://www.research.att.com/~njas/sequences/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n  Daca intalniti un sir si credeti ca ar putea fi unul celebru, puteti il cautati pe acest site.\n* \'TyperA - test your typing skills\':http://www.typera.tk/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Daca nu ati vazut pe cineva care sa tasteze mai repede ca voi, va puteti compara viteza cu cei mai buni din lume pe acest site.\n* \'How To Become A Hacker\':http://www.catb.org/~esr/faqs/hacker-howto.html (\'Cosmin\':user/Cosmin @ 2004-11-10)\nUn document interesant care ne ajuta sa intelegem modul de gandire a hackerilor.\n* \'Omnibus Useful Links Page\':http://sourceforge.net/forum/forum.php?thread_id=1039803&forum_id=48211 (\'wickedman\':user/wickedman @ 2004-11-10)\nGasiti aici o colectie impresionanta de link-uri catre carti si publicatii online (download-abile!) despre programare.\n* \'How To Be A Programmer\':http://samizdat.mines.edu/howto/HowToBeAProgrammer.pdf (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Document mai general ce nu e orientat inspre olimpici ci inspre un tip ce isi castiga painea din programare.\n* \'The rec.puzzles archive\':http://rec-puzzles.org/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n Arhiva de problemutze de pe lista de discutii rec.puzzles de pe usenet.\n* \'MathLinks\':http://www.mathlinks.ro/Forum/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\nCel mai mare forum ce se ocupa cu probleme de matematica.\n* \'Ponder This\':http://www.research.ibm.com/ponder/ (\'Cosmin\':user/Cosmin @ 2004-11-10)\n&quot;Welcome to our Monthly Puzzles  \r\nYou are cordially invited to match wits with some of the best minds in IBM Research.&quot;\r\n\n* \'Usaco training gateway\':http://ace.delos.com/usacogate (\'Cosmin\':user/Cosmin @ 2004-11-08)\n  Site american de pregatire pentru olimpiade. Cel mai bun site pentru incepatori. Siteul este impartit in sectiuni si pentru a trece de la o sectiune la urmatoarea trebuie rezolvate toate problemele din sectiunea curenta. In fiecare sectiune exista si documentatie referitoare la tehnica de programare ce poate fi folosita pentru a rezolva problemele acelei sectiuni.\n* \'e - Edu\':http://www.e-edu.go.ro/ (\'wickedman\':user/wickedman @ 2004-08-13)\nUn site aflat intr-o permanenta actualizare ce se adreseaza tuturor celor interesati in probleme de informatica.\n\nh2. Articole (1 link-uri)\n\n* \'Coding Style for C Programming\':http://www.cs.usyd.edu.au/~scilect/tpop/handouts/Style.htm (\'silviug\':user/silviug @ 2004-11-10)\nArticolul cuprinde recomandari pentru formarea un stil de implementare in limbajul C++.\n',0,'public'),('downloads','Download-uri','2006-11-22 01:26:25','h1. Download-uri\r\n\r\nh2. OJI (5 link-uri)\r\n\r\n* !\'OJI 2001\':downloads?subiecteJudete.zip! ( _613095_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele de la Olimpiada Judeteana de Informatica, anul 2001.\r\n* \'OJI 2002\':downloads?oji2002.zip ( _798994_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale la Olimpiada Judeteana de Informatica, anul 2002.\r\n* \'OJI 2003\':downloads?oji2003.zip ( _1097174_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale la Olimpiada Judeteana de Informatica, anul 2003.\r\n* \'OJI 2004\':downloads?oji2004.zip ( _744932_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale la Olimpiada Judeteana de Informatica, anul 2004.\r\n* \'OJI 2005\':downloads?oji2005.zip ( _365217_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale la Olimpiada Judeteana de Informatica, anul 2005.\r\n\r\nh2. ONI (5 link-uri)\r\n\r\n* \'ONI 2005\':downloads?oni2005.zip ( _6338659_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele, testele si solutiile oficiale din cadrul Olimpiadei Nationale de Informatica 2005, Galati.\r\n* \'ONI Gimnaziu 2002-2005\':downloads?onigim.zip ( _6020215_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele, solutiile si rezultatele de la Olimpiada Nationala pentru Gimnaziu, anii 2002-2005.\r\n* \'ONI2003\':downloads?oni03.zip ( _9734608_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-02-24 )\r\nSubiectele propuse in cadrul olimpiadei nationale de informatica 2003\r\n* \'ONI 2004\':downloads?ONI04.zip ( _7812828_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-02-21 )\r\nSubiectele propuse in cadrul olimpiadei nationale de informatica 2004\r\n* \'ONI2002\':downloads?ONI02.ZIP ( _2575564_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-02-21 )\r\nSubiectele propuse in cadrul olimpiadei nationale de informatica 2002\r\n\r\nh2. Lot (3 link-uri)\r\n\r\n* \'lot2004\':downloads?lot2004.rar ( _3434709_ bytes, ==user(user=\"cip\" type=\"tiny\")== @ 2006-02-04 )\r\nSubiectele, testele si solutiile oficiale din cadrul taberelor de pregatire ale lotolui largit, anul 2005.\r\n* \'lot2002\':downloads?lot2002.rar ( _1520669_ bytes, ==user(user=\"cip\" type=\"tiny\")== @ 2006-02-03 )\r\nSubiectele, testele si solutiile oficiale din cadrul taberelor de pregatire ale lotolui largit, anul 2002.\r\n* \'lot 2003\':downloads?lot2oo3.rar ( _15169596_ bytes, ==user(user=\"cip\" type=\"tiny\")== @ 2006-02-03 )\r\nSubiectele, testele si solutiile oficiale din cadrul taberelor de pregatire ale lotolui largit, anul 2003.\r\n\r\nh2. BOI (6 link-uri)\r\n\r\n* \'BOI 2005\':downloads?boi2005.zip ( _354783_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale de la BOI 2005 Grecia.\r\n* \'BOI 2004\':downloads?boi2004.zip ( _354835_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nProbleme si solutii oficiale de la BOI 2004\r\n* \'BOI 2003\':downloads?boi2003.zip ( _99072_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nProbleme si solutii oficiale de la BOI 2003\r\n* \'BOI 2002\':downloads?boi2002.zip ( _401602_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-08 )\r\nProbleme, solutii si rezultatele de la BOI 2002\r\n* \'BOI 2001\':downloads?boi2001.zip ( _16638_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-07 )\r\nProblemele de la BOI 2001\r\n* \'BOI 2000\':downloads?boi2000.zip ( _61296_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-06 )\r\nProblemele de la BOI 2000\r\n\r\nh2. CEOI (6 link-uri)\r\n\r\n* \'CEOI 2005\':downloads?ceoi2005.zip ( _1067059_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale de la CEOI 2005 Ungaria.\r\n* \'CEOI 2004\':downloads?ceoi-2004.zip ( _341294_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nProbleme, solutii oficiale si surse oficiale de la CEOI 2004 Polonia\r\n* \'CEOI 2003\':downloads?ceoi2003.zip ( _814025_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nProbleme, solutii oficiale si surse oficiale de la CEOI 2003 Germania\r\n* \'CEOI 2002\':downloads?ceoi2002.zip ( _316854_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-08 )\r\nProbleme, solutii oficiale si surse oficiale de la CEOI 2002 Slovacia\r\n* \'CEOI 2001\':downloads?CEOI_2001.zip ( _45819_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-07 )\r\nProbleme si solutii oficiale de la CEOI 2001 Ungaria\r\n* \'CEOI 2000\':downloads?CEOI_2000.zip ( _28537_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-06 )\r\nProblemele de la CEOI 2000 Romania\r\n\r\nh2. IOI (6 link-uri)\r\n\r\n* \'IOI 2005\':downloads?ioi2005.zip ( _584396_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale de la IOI 2005 Polonia.\r\n* \'IOI 2004\':downloads?ioi2004.zip ( _338911_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nSubiectele si solutiile oficiale de la IOI 2004 Grecia\r\n* \'IOI 2003\':downloads?ioi2003.zip ( _1213299_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nSubiecte in limba romana, solutii oficiale si rezultatele de la IOI 2003 USA\r\n* \'IOI 2002\':downloads?ioi2002.zip ( _1893445_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-08 )\r\nSubiecte, solutii, teste si handbook-ul de la IOI 2002 Coreea\r\n* \'IOI 2001\':downloads?IOI_2001.zip ( _465557_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-07 )\r\nSubiecte, solutii oficiale si rezultatele de la IOI 2001 Finlanda\r\n* \'IOI 2000\':downloads?IOI_2000.zip ( _1191184_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-06 )\r\nSubiecte, solutii oficiale si testele de la IOI 2000 China\r\n\r\nh2. USACO (5 link-uri)\r\n\r\n* \'USACO Gold - DEC05\':downloads?usaco.zip ( _2009498_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2006-01-31 )\r\nSetul de probleme si datele de test pentru concursul Usaco, diviza Gold, decembrie 2005. \r\n* \'Usaco Gold - NOV05\':downloads?usaco_nov05.zip ( _36878_ bytes, ==user(user=\"ditzonec\" type=\"tiny\")== @ 2005-11-22 )\r\nSetul de probleme si datele de test pentru concursul Usaco, diviza Gold, noiembrie 2005.\r\n* \'Usaco Gold - JAN05\':downloads?usaco_gold_jan05.zip ( _775374_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-03-02 )\r\nSetul de probleme, datele de test si clasamentul concursului Usaco, divizia Gold, ianuarie 2005.\r\n* \'Usaco Silver - DEC04\':downloads?silver.zip ( _736744_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-01-09 )\r\nSetul de probleme, testele si rezultatele concursului Usaco, divizia Silver, decembrie 2004 \r\n* \'Usaco Gold - DEC04\':downloads?gold_dec04.zip ( _1291870_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2004-12-20 )\r\nSetul de probleme, testele si rezultatele concursului Usaco, divizia Gold, decembrie 2004\r\n\r\nh2. BalticOI (6 link-uri)\r\n\r\n* \'BalticOI 2005\':downloads?baltic2005.zip ( _1781109_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale de la Olimpiada Baltica de Informatica 2005.\r\n* \'BalticOI 1995-1997\':downloads?boi1995_97.zip ( _1773528_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSolutiile oficiale si testele de la Olimpiada Baltica de Informatica, anii 1995 - 1997.\r\n* \'BalticOI 2004\':downloads?baltic2004.zip ( _74176_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nProbleme si solutii oficiale de la Olimpiada Baltica de Informatica 2004 \r\n* \'BalticOI 2003\':downloads?baltic2003.zip ( _560373_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nProbleme si solutii oficiale de la Olimpiada Baltica de Informatica 2003\r\n* \'BalticOI 2002\':downloads?baltic2002.zip ( _236152_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-08 )\r\nProbleme si solutii oficiale de la Olimpiada Baltica de Informatica 2002 \r\n* \'BalticOI 2001\':downloads?baltic2001.zip ( _326933_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-07 )\r\nProbleme si solutii oficiale de la Olimpiada Baltica de Informatica 2001\r\n\r\nh2. preONI (2 link-uri)\r\n\r\n* \'PreONI 2003\':downloads?preoni2.zip ( _32577_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nAl doilea concurs PreONI organizat de Stefan Ciobaca; majoritatea participantilor au fost membrii ai canalului #olimpiada. Formatul concursului a fost asemanator cu al primului concurs PreONI.\r\n* \'PreONI 2002\':downloads?preoni1.zip ( _316146_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nPrimul concurs PreONI organizat de Stefan Ciobaca si Mugurel Andreica; majoritatea participantilor au fost membrii ai canalului #olimpiada. Concurentii au avut de rezolvat 11 probleme in 24h.\r\n\r\nh2. Articole (4 link-uri)\r\n\r\n* \'Rotatie minim lexicografica\':downloads?Rotatie.pdf ( _131723_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2006-02-02 )\r\nUn articol scris de Mircea Pasoi in cadrul Gazetei de Informatica (www.ginfo.ro), numarul din decembrie 2005\r\n* \'Ghid complet pentru concursurile de informatica\':downloads?Ghid_complet_pentru_concursurile_de_informatica.pdf ( _162832_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2006-02-02 )\r\nUn articol scris de Mircea Pasoi in cadrul Gazetei de Informatica (www.ginfo.ro), numarul din octombrie 2005. \r\n* \'Cautari Ortogonale\':downloads?Cautari_Ortogonale.doc ( _80384_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-29 )\r\nAcest articol , scris de Cosmin Negruseri, prezinta algoritmi de cautari ortogonale, cat si aplicatii. Articolul a aparut si in Gazeta de Informatica 15/5, si a fost folosit initial la pregatirea lotului in 2005.\r\n* \'Arbori de intervale si aplicatii in geometria computationala\':downloads?arbori_de_intervale.zip ( _115043_ bytes, ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-11-10 )\r\nAcesta este un curs despre arbori de intervale si aplicatiile lor in geometria computationala. Cursul a fost predat de Prof. Dana Lica in cadrul sesiunii de pregatire a lotului largit de informatica 2004. Pe langa explicatii amanuntite veti gasi si exemple de cod sursa in C si Pascal.\r\n\r\nh2. Utilitare (2 link-uri)\r\n\r\n* \'Rhide\':downloads?rhide-1.5.20050823.tbz2 ( _4344271_ bytes, ==user(user=\"azotlichid\" type=\"tiny\")== @ 2006-07-12 )\r\nBinar pentru RHIDE functional pentru cele mai multe distributii de Linux. Detalii despre instalare gasiti pe \'forum\':http://forum.infoarena.ro.\r\n',1,'public'),('problema/pavare','Pavare','2006-11-22 01:27:36','==Include(page=\"template/taskheader\" task_id=\"pavare\")==\r\n\r\nGigel, primar in orasul sau, s-a gandit sa renoveze strada principala, strada de dimensiuni $M*N$ compusa din bucati de dimensiuni $1*1$. Majoritatea bucatilor sunt stricate, dar mai exista $K$ bucati care sunt considerate bune. Dorind sa plateasca cat mai putini bani, Gigel a luat de la un negustor blocuri de dimensiuni $2*2$ la pretul unui bloc de dimensiuni $1*1$. Pentru a pava strada trebuie sa amplaseze cat mai multe din aceste blocuri pe bucati stricate, fara sa paveze vreo bucata buna deoarece ar aparea denivelari, si fara sa se suprapuna blocurile $2*2$. El si-a dat seama ca mai bine ar fi cumparat blocuri $1*1$, pentru ca ar fi acoperit toata strada fara batai de cap, dar acum nu mai are de ales si are nevoie de ajutorul tau!\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul maxim de blocuri $2*2$ pe care le poate pune primarul pentru a repara strada.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie din fisierul $pavare.in$ se vor afla trei numere intregi separate prin cate un spatiu: $N, M$ si $K$. Pe urmatoarele $K$ linii se vor afla perechi de numere intregi reprezentand linia si coloana pe care se afla o bucata buna.\r\n\r\nh2. Date de Iesire\r\n\r\nPe prima linie in fisierul $pavare.out$ se va afla un numar natural reprezentand numarul maxim de blocuri $2*2$ care pot fi amplasate pe strada.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 150$\r\n* $1 &le; M &le; 15$\r\n* $1 &le; K &le; N*M$\r\n* Liinile sunt numerotate de la $1$ la $N$, iar coloanele de la $1$ la $M$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. pavare.in |_. pavare.out |\r\n| 4 6 3\r\n1 1\r\n2 6\r\n3 3 | 4 | \r\n\r\nh3. Explicatie\r\n\r\nAcesta este un amplasament posibil al blocurilor:\r\n!task/pavare?untitled.gif! \r\n\'click\':!downloads?ceoi_2000.zip!\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"pavare\")==',1,'task: pavare'),('warm-up-2006/solutii','Solutii Autumn WarmUp 2006','2006-11-22 02:02:15','h1. Solutii Autumn WarmUp 2006\r\n\r\n(Creat la data de _2006-09-07_ categoria _Competitii_, autor(i) _Echipa Info-arena_)\r\n\r\nAici puteti gasi solutiile oficiale la cele 5 probleme propuse in concurs. De precizat si ca aceasta initiativa $info-arena$ a fost un succes, adunand un numar respectabil de participanti. Punctajele au fost mai mici decat cele asteptate, fapt ce a confirmat ca setul de probleme a fost unul capabil sa puna in dificultate nume cunoscute la olimpiadele de informatica. Iata si solutiile:\r\n\r\nh2. poly\r\n\r\nProblema este una de programare dinamica si are complexitatea $O(N)$, de constanta $2^7^ = 128$. Sa notam cu $M{~i,j~}$ lungimea celui mai lung subsir utilizand primele $i$ numere din vector astfel incat ultimul element din subsirul optim sa aiba ca divizori numerele din multimea data corespunzatoare bitilor de $1$ din $j$. Mai intai $M{~i,j~}$ = $M{~i-1,j~}$ ( nu folosim numarul al $i$-lea ). Daca dorim sa folosim si numarul al $i$-lea, atunci $M{~i,config~} = maxim(M{~i,config~}$, $M{~i-1,k~} + 1)$, cu $k and config = 0$, unde config are bitii de $1$ corespunzatori numerelor din multimea data cu care se divide acest al $i$-lea numar din sirul initial. Conditia $k and config$ ne asigura ca penultimul si ultimul numar din subsir nu au amandoua vreun divizor comun din multimea data (operatia $and$ in acest context este o operatie pe biti). Rezultatul va fi $max(M{~n,0~}$, $M{~n,1~}$... $M{~n,127~})$. Memoria folosita poate fi $O(1)$, retinand doar ultimele doua linii ale matricei.\r\n\r\nUn algoritm de complexitate patratica in $N$ folosind tot programarea dinamica ar fi obtinut $30-40$ de puncte.\r\n\r\nh2. bridge\r\n\r\nUn algoritm de complexitate $O(M + N * K)$ folosind programarea dinamica nu este foarte greu de gasit. Daca notam cu $M{~i,j~}$ numarul de moduri (modulo $666013$) de a ajunge in $i$ pasi pe scandura $j$ din pozitia initiala, atunci mai trebuie avut grija doar la relatiile de recurenta. In cazul de fata vom utiliza metoda inainte si vom trata cazurile: daca scandura $j$ este lipsa atunci $M{~i,j~} = 0$, daca scandura $j$ este teleportoare incrementam $M{~i+1,unde[j]~}$ cu $M{~i,j~}$ daca si numai daca {$unde[j]$} nu este lipsa sau subreda ({$unde[j]$} este destinatia teleportarii de pe scandura $j$),daca $j$ este scandura buna, incrementam $M{~i+1,j+1~}$ cu $M{~i,j~}$ si $M{~i+1,j+2~}$ cu $M{~i,j~}$ doar daca $j+2$ nu e lipsa sau subreda, etc.\r\n\r\nAvand construita matricea $M$, pentru fiecare query putem raspunde acum in $O(1)$. Exista diferite optimizari care pot fi facute si care sporesc substantial timpul de executie.\r\n\r\n\r\nh2. secv4\r\n\r\nDeoarece logaritmul unui produs de numere este egal cu suma logaritmilor fiecarui numar din produs, si in ipoteza ca toate numerele din sir sunt pozitive, logaritmam fiecare numar si notam cu $S{~i~}$ suma primilor $i$ logaritmi. Astfel, pentru a afla secventa de produs maxim care se termina pe pozitia $i$, este suficient sa determinam, pentru $k$ intre $i-y$ si $i-x$ care este $S{~k~}$ minim (astfel, $S{~i~} - S{~k~}$ va fi maxim, deci si produsul maxim, iar secventa va incepe pe pozitia $k+1$). Putem folosi un arbore de intervale si obtinem un algoritm $O(NlogN)$, sau o coada prin care scoatem elementele prin ambele parti (structura de date numita deque - double ended queue), obtinand complexitatea $O(N)$. Daca exista si numere negative, in momentul logaritmarii numerelor negative logaritmam opusul lor. Aplicand procedeul descris mai sus, stim sigur la final ca produsul obtinut are modulul maxim. Pentru a fi cu adevarat maxim (deci pozitiv), notam cu $semn{~i~}$ semnul produsului primelor $i$ numere. Ca secventa {@<j+1, i>@} sa aiba produs maxim trebuie in plus $semn{~i~} = semn{~j~}$. Vom retine doua deque-uri, unul pentru {$+$} si unul pt {@-@}, conform vectorului semn. Astfel, in final, suntem siguri ca produsul are semnul {$+$} si, cum are si modulul maxim, are valoarea maxima ceruta.\r\n\r\n\r\nh2. parcare\r\n\r\nProblema este exponentiala in dimensiunea matricii, dar polinomiala in numarul total de posibilitati de pozitionare al masinilor. Astfel, vom folosi un algoritm de tip BFS care garanteaza ca se ajunge la solutie intr-un numar minim de miscari. Plecam de la matricea initiala, si expandam pe rand toate starile posibile, miscand din starea curenta cate o masina pana cand nu mai exista nici o varianta noua de pozitionare a masinilor sau pana cand am scos masina A din parcare. Starile problemei le putem codifica intr-un intreg de $64$ de biti. Singurele variabile sunt pozitiile masinilor. Dupa ce eliminam zidurile inconjuratoare, coordonatele nu sunt mai mari decat $7$ ( $3$ biti ), deci pentru pozitia unei masini vom folosi $6$ biti. Concatenam pozitiile masinilor si, cum sunt maxim $10$ masini, codificarea nu va avea mai mult de $60$ de biti.\r\nPentru a memora starile explorate vom folosi o tabela de hash. De precizat si ca numarul total de posibilitati pornind de la starea initiala este destul de redus, deci problema va rula aproape instantaneu.\r\n\r\nh2. easy query\r\n\r\nUn algoritm simplu de complexitate $O(N*M)$ obtine $30-50$ de puncte. Algoritmul de $100$ de puncte are complexitatea $O(MlogN)$ si foloseste arbori de intervale. Considerand o secventa $x{~i~} x{~i+1~}... x{~j~}$ este evident ca pentru ca elementele sirurilor $y$ si $z$ sa fie maxime, respectiv minime, ele trebuiesc construite astfel:\r\n$y{~t~} = x{~t~}- min(x{~k~}) + max({~p~}), i &le; t &le; j, t &le; k, p &le; j$\r\n$z{~t~} = x{~t~} - max(x{~k~}) + min({~p~}), i &le; t &le; j, t &le; k, p &le; j$\r\nPentru a calcula in timp optim valoarea $P = max(y) + min(z)$ ne vom folosi de un arbore de intervale in urmatorul mod: fiecare nod al acestuia va constitui o secventa $x{~st~}, x{~st+1~}... x{~dr~}$ ( unde $st$ si $dr$ sunt marginile intervalului din nodul arborelui ) pe care o vom rezolva prin metoda brute force de la inceput, avand grija sa precalculam si alte valori necesare mai tarziu, cum ar fi :\r\n$min = minim(x{~st~}, x{~st+1~}... x{~dr~})$\r\n$max = maxim(x{~st~}, x{~st+1~}... x{~dr~})$\r\n$x_max_max = maxim(x{~t~} + maxim(x{~p~}) ),st &le; t &le; dr si t &le; p &le; dr$\r\n$x_max_min = minim(x{~t~} - maxim(x{~p~}) ),st &le; t &le; dr si t &le; p &le; dr$\r\n$x_min_max = maxim(x{~t~} - minim(x{~p~}) ),st &le; t &le; dr si t &le; p &le; dr$\r\n$x_min_min = minim(x{~t~} + minim(x{~p~}) ),st &le; t &le; dr si t &le; p &le; dr$\r\n$y_max = maximul din sirul y corespunzator secventei x{~st~}, x{~st+1~}... x{~dr~}$\r\n$z_min = minimul din sirul z corespunzator secventei x{~st~}, x{~st+1~}... x{~dr~}$\r\nAvand precalculate valorile de mai sus pentru fiecare nod al arborelui in parte vom putea raspunde in timp $O(logN)$ pentru fiecare din cele $M$ intrebari. Fiecare subsecventa data $x{~i~}, x{~i+1~}... x{~j~}$ va putea fi compusa din reuniunea mai multor noduri din arborele de intervale. Acum parcurgem nodurile ce compun subsecventa data de la dreapta la stanga si vom gasi rapid valorile $maxim(y)$ si $minim(z)$. Presupunand ca am ajuns la nodul $Q$ valoarea $maxim(y)$ pana aici se calculeaza astfel:\r\n@MAX(Y) = y_max(Q) = y_max_max(Q) - min(W) = x_min_max(Q)+max(W) = max(Q)+max(W)-min(W)@\r\nAnalog se calculeaza si minim(z).',1,'public'),('preoni-2006/finala/solutii','Solutii preONI 2006, Runda finala','2006-03-26 00:00:00','h1. Solutii preONI 2006, Runda finala\n\n(Creat de \'_ditzonec_\':user/ditzonec la data de _2006-03-26_ categoria _Competitii_, autor(i) _Echipa Info-Arena_)\n\n*Continut scurt:*\n ==Include(page=\"template/raw\")==\n\nArticolul contine ideile de rezolvare a problemelor cu care cei 29 finalisti preONI 2006 au avut ocazia sa se confrunte.\n\n\n*Continut lung:*\n==Include(page=\"template/raw\")==\n\nSi iata-ne ajunsi in situatia de a trage concluziile dupa tot ce a insemnat preONI 2006. Toata comisia infoArena merita felicitata pentru organizarea si efortul depus de-a lungul campaniei. Inca odata multimim domnului profesor Onea pentru organizarea \"fara cusur\" :).\n\nFinala a fost ... \"Super. Super\", \"Super tare\", \"mda...a mers\" o spun concurentii. A fost grozav, intr-adevar, si ne-a facut mare placere sa va vedem prezenti intr-un numar atat de mare si veniti atat de departe. Va multumim pentru participare si speram ca ati petrecut un week-end pe cinste cu noi la Focsani.\n\nDupa cele patru runde online de concurs cu adevarat dure, cei 29 de concurenti si-au facut aparatia, de prin toate ungherele tarii, pe terenul de lupta. Desi in prima seara, la deschiderea ne-scortoasa si informala, concurentii isi zambeau sincer si fara vreun resentiment, in aer plutea \"emotia, tracul, tensiunea, stress-ul\".. Calmul dinaintea furtunii.. Venea marea confruntarea, batalia bataliilor, in urma careia trebuiau alesi castigatorii preONI 2006.\n\nConcursul s-a dovedit a fi o adevarata proba de foc, o batalie cu fum de creiere din plin si cu multe iesiri la toaleta (vezi [1]Cronica). Problemele, la limita imposibilului. Comisia a nascocit cele mai nastrusnice provocari pentru o finala in care participau concurenti adevarati, gata sa dea peste cap toate topurile Olimpiadelor ce vor voni. Muschi incordati, \"trac, tensiune, stress\". La sfarsit, punctaje reflectand truda demna de admirat a unor campioni alergand pe ultima suta de metri a unei curse in 5 acte. Castigatorii au fost sa fie, de acesta data, Cosmin Gheorghe la clasa a IX a, Simion Alexandru la clasa a X a si Marin Radu la clasele XI-XII. Ii felicitam pe ei si, in aceeasi masura, pe toti participantii care, desi au ratat premiile, cu siguranta au castigat prieteni noi.\n\nSa trecem la analiza problemelor cu care cei 29 concurenti nazdravani au avut de-a face in cele 5 ore ale finalei. Orice sugestie sau corectie privind articolul, solutiile problemelor v-o puteti exprima pe [2]forum.\n\n\n\nDivK\n(problema usoara clasa a IX-a, problema usoara clasa a X-a)\n\nExista solutii evidente O(N * (A-B)) si O(N * K) care obtin punctaje partiale si asupra carora nu se va insista in acest articol. Solutia care obtine insa 100 de puncte este O(N) si nu este greu de gasit, bazandu-se pe cateva observatii. Sa notam cu S[i] suma primelor i numere din sir. Pentru ca subsecventa intre pozitiile i si j sa aiba suma elementelor divizibila cu K, atunci S[j]-S[i-1] trebuie sa fie divizibil cu K, sau altfel spus, S[i-1] si S[j] sa aiba acelasi rest la impartirea cu K. Daca stim sa aflam raspunsul problemei pentru subsecvente de lungime maxim L si minim 1, aplicand de doua ori algoritmul pentru B si pentru A-1 si scazand cele doua valori obtinute vom obtine numarul de subsecvente cu proprietatea ceruta intre A si B inclusiv. Pentru a afla raspunsul pentru lungimea maxim L procedam astfel: introducem in lista LISTA[r] alocata dinamic pozitiile i pentru care S[i] da restul r la impartirea cu K, in ordine crescatoare. Pentru fiecare rest de la 0 la K-1 parcurgem lista\ncorespunzatoarea, si, daca ne aflam pe un element cu valoarea p2 si elementul cel mai din stanga din lista curenta are valoarea p1 astfel incat p2-p1 <= L, atunci cand avansam in lista nu mai este necesar sa incepem iterarea listei de la inceput pentru aflarea valorii cea mai din stanga, fiind suficient sa reluam cautarea din dreptul valorii p1. Astfel complexitatea algoritmului pentru o lista este O(LUNGIME), unde LUNGIME este lungimea unei liste, deci complexitatea intregului algoritm va fi O(N), pentru ca lungimea tuturor listelor este N.\nO alta solutie de aceeasi complexitate dar mai rapida este urmatoarea: daca notam cu v[r] de cate ori apare restul r in numerele S[i-B]...S[i-A+1] pentru pasul curent i, atunci la pasul i+1 este suficient sa decrementam v[S[i-B+1] % K] si sa incrementam v[S[i-A+2] % K]. La fiecare pas i vom aduna la solutia finala numarul v[S[i] % K].\n\n\n\nLupul Urias si Rau\n\n(problema medie clasa a IX-a)\n\nSe construieste vectorul T[i] care retine timpul maxim la care oaia i poate fi aleasa si notam T_max valoarea maxima din T.\nO abordare care insa nu conduce la punctaj maxim este programarea dinamica, calculand sol[i][j] cantitatea maxima de lana care se poate alege cu primele i oi pana la momentul j. Raspunsul se va gasi in sol[n][T_max]. Complexitatea este O(n^2) si ar obtine aproximativ 50-60 de puncte.\nO rezolvare ce aduce 100 de puncte se bazeaza pe metoda greedy. Pentru fiecare valoare j de la T_max la 1 se adauga intr-o multime toate cantitatile de lana A[i] pentru oile cu T[i]=j, apoi se extrage valoarea maxima care se adauga la solutie, restul valorilor pastrandu-se in multime pentru pasul urmator. Atentie, se va extrage valoarea maxima chiar daca la acest pas nu s-au introdus valori noi in multime. Pentru a implementa eficient aceste operatii ne vom folosi un heap care suporta operatiile de extragere maxim si adaugare element in O(log n). Complexitatea finala a algoritmului va fi de O(n log n). Demonstratia intuitiva a faptului ca algoritmul conduce la solutie optima este ca la fiecare pas j se alege valoarea maxima dintre cele care nu vor mai putea fi alese la pasul j+1.\nO alta solutie tot greedy a problemei este sortarea descrescatoare dupa cantitatile de lana. Pentru fiecare valoare apoi se vede cel mai mare timp mai mic sau egal cu T[i] si la care nu a mai fost aleasa nici o alta oaie. Daca exista un astfel de timp se adauga valoare respectiva la solutie. Acest lucru se poate realiza cu o cautare binara a acestui timp. O alternativa la acest lucru ar fi folosirea multimilor disjuncte. Initial se considera fiecare moment de timp o multime. Notam X = minimul din multimea care il contine pe T[i]. Daca alegem A[i] pentru a-l aduaga la solutie se va reuni multimea care il contine pe X cu multimea care il contine pe X-1. Aceasta rezolvare insa este considerata peste nivelul mediu al clasei a 9-a.\n\n\n\nOverlap\n\n(problema grea clasa a IX-a)\n\nObservam ca exista doar 4 rotatii posibile ale planului, facand abstractie de translatii. Daca CMAX este coordonata maxima, atunci punctul (i, j) se transforma in (CMAX-j, i), iar dupa 4 aplicari ale acestei transformari se ajunge din nou la punctul initial. Asadar, vom incerca pe rand fiecare dintre aceste posibilitati. Avand fixata o rotatie, stim ca punctul 1 se transforma intr-un alt punct i (i > 1), sau ca un punct i se transforma in el. Cel de-al doilea caz este redundant, deoarece aplicand transformarea P_i -> P_1, vom lua in considerare si transformarea inversa. De exemplu, daca rotind planul cu k*90 de grade si translatandu-l cu shift_X si shift_y obtinem P_i din P_j, atunci rotind planul cu (4-k)*90 grade si translatandu-l cu -shift_x, -shift_y vom obtine P_j din P_i.\nOdata fixata rotatia pe care o consideram (inclusiv cea de 0 grade), presupunem pe rand pentru fiecare punct i > 1 ca P_1 se transforma in P_i, si verificam daca aceasta presupunere conduce la o solutie valida. Presupunerea facuta stabileste in mod unic care este translatia efectuata. Retinem un vector P[i] = punctul in care se transforma al i-lea punct dupa aplicarea rotatiei fixate si a translatiei determinate, sau -1 daca punctul transformat nu se regaseste printre cele initiale. Pentru a realiza in mod eficient aceasta operatie, la inceputul algoritmului punctele se sorteaza cu o functie de comparare oarecare si la fiecare pas punctul dorit se cauta binar in acest vector, in O(log N). Eventual s-ar putea folosi un tabel de dispersie, insa consideram ca aceasta structura de date este prea complicata pentru nivelul clasei a 9-a si nu era necesara pentru obtinerea punctajului maxim.\nAvand vectorul P, va exista o structura de lanturi si cicluri rezultata in urma aplicarii repetate P[P[..P[i]]] asupra diverselor puncte. Se poate demonstra usor ca exista solutie daca si numai daca toate lanturile si toate ciclurile au lungime para; in acest caz solutia se poate obtine etichetand alternativ punctele consecutive dintr-un lant sau ciclu.\nComplexitatea algoritmului este O(N^2 * log N) pe cazul defavorabil folosind cautari binare pentru gasirea punctelor, sau O(N^2) pe cazul mediu folosind un hash (tabel de dispersie).\n\n\n\n\n\nIv\n\n(problema medie clasa a X-a)\n\nSolutia simpla, calculata prin metoda programarii dinamice, se bazeaza pe mentinerea starilor ce asigura obtinerea solutiilor distincte. Astfel interclasarea celor doua siruri se va face in acelasi timp atat din stanga cat si din dreapta pentru a garanta pastrarea proprietatii de palindrom. Notand cele doua siruri A si B, pastram 4 indici: p1, p2, q1, q2, reprezentand pozitia ultimului caracter luat din stanga sirului A, ultimului luat din dreapta sirului A, ultimului din stanga sirului B, respectiv ultimului luat din dreapta sirului B.\n\nSe iau 4 cazuri de tranzitie intre stari:\n(p1, q1, p2, q2) => (p1 + 1, q1 - 1, p2, q2), daca A[p1 + 1] = A[q1 - 1]\n(p1, q1, p2, q2) => (p1 + 1, q1, p2, q2 - 1), daca A[p1 + 1] = B[q2 - 1]\n(p1, q1, p2, q2) => (p1, q1 - 1, p2 + 1, q2), daca B[p2 + 1] = A[q1 - 1]\n(p1, q1, p2, q2) => (p1, q1, p2 + 1, q2 - 1), daca B[p2 + 1] = B[q2 - 1]\n\nAceasta ne duce la un algoritm de complexitate O(|A|^2 * |B|^2), ce ar fi asigurat obtinerea a 60% din punctaj. Simpla observare a faptului ca este suficienta pastrarea a numai trei indici, in loc de patru, pentru a pastra o stare completa (deoarece p1 + p2 = |A| - q1 + 1 + |B| - q2 + 1), duce la un algoritm de complexitate O(|A|^2 * |B|) ce ar fi obtinut punctaj maxim.\n\n\n\nRobotei\n\n(problema grea clasa a X-a)\n\nPentru a afla de cate ori trece un robotel prin pozitia (X Y) avem nevoie de urmatoarele informatii:\n\n1. Cate mutari efectuam daca pornim din pozitia (X Y) si ajungem tot in (X Y) - lungimea ciclului care cuprinde pozitia (X Y). Daca pozitia (X Y) nu se afla pe un ciclu atunci lucrurile se simplifica (acesta este un caz special care se trateaza separat).\n2. Cate mutari efectueaza fiecare robot pana ajunge in (X Y). Desigur, pot exista si roboti care nu ajung niciodata in (X Y).\n\nAflarea lungimii ciclului (punctul 1.) se face usor, pornind din pozitia (X Y), efectuand mutari pana se ajunge din nou in pozitia (X Y). Daca numarul de mutari depaseste modX*modY si nu am atins inca pozitia (X, Y), atunci aceasta nu se afla pe un ciclu. Complexitatea acestui pas va fi O(modX * modY).\nPentru a afla, pentru fiecare robot, numarul de mutari pentru a ajunge in (X Y), putem asocia un graf caroiajului, fiecarei celule din cele N*N corespunzandu-i un nod in graful orientat construit. Pentru fiecare celula (i j) vom adauga o muchie orientata in acest graf intre nodul corespunzator celulei (i , j) si nodul corespunzator celulei ( [i*i + offsetX] modulo modX , [j*j + offsetY] modulo modY ). Fiecare nod din acest graf va avea gradul de iesire 1, in consecinta, vor fi atatea muchii cate noduri sunt (adica N*N).\nPornind din pozitia (X Y), efectuam o parcurgere BFS a grafului INVERSAT si vom afla, pentru fiecare nod, care este numarul de mutari pe care trebuie sa le efectuam, pornind din celula corespunzatoare nodului, pentru a ajunge in pozitia (X Y). Nodurile care nu pot fi vizitate in aceasta parcurgere corespund unor celule din care nu se poate atinge pozitia (X Y).\nComplexitatea acestui algoritm este O(N*N) si obtine 70% din punctaj. Pentru a obtine punctaj maxim, observam ca, dupa prima mutare toti roboteii se afla in caroiajul de dimensiuni (modX modY), si aplicam acelasi algoritm ignorand pozitiile care sunt in afara acestuia. Observatia precedenta ne permite sa afirmam ca daca un robot pleaca din pozitia (i, j) e ca si cum ar pleca, imaginar, din pozitia (i modX, j modY). Putem determina cati roboti pleaca (considerandu-i si pe cei care pleaca imaginar) dintr-o celula (i j) a caroiajului redus, determinand cate solutii au ecuatiile x % modX = i si y % modY = j (x si y necunoscute) in intervalul [0..N-1].\n\n\n\nPScNv\n\n(problema simpla clasele XI-XII)\n\nAceasta problema a fost aleasa asa cum spune si textul pentru faptul ca sunt mai multe abordari ce rezolva problema. O prima abordare ar fi pentru un k fixat sa vedem daca putem ajunge de la nodul start pana la nodul destinatie folosind doar muchii cu cost mai mic sau egal cu k. Verificarea acestui fapt o facem folosind o cautare in latime. Cat timp nu putem ajunge de la nodul start la nodul destinatie incrementam pe k si apoi aplicam o cautare in latime. Astfel aflam valoarea k minima ceruta in problema. Complexitatea acestui algoritm este O(kmax (n + m)). Daca notam kmin valoarea ceruta in problema, atunci daca fixam un k si nodul destinatie este accesibil din nodul start folosind doar muchii de pondere mai mica sau egale cu k atunci este evident ca kmin <= k, iar daca nodul destinatie nu este accesibil atunci kmin > k. Pe baza acestei observatii putem dezvolta un algoritm ce cauta binar valoarea kmin ce are complexitatea O(log kmax (n + m)). O alta abordare se bazeaza pe o modificare usoara a\nalgoritmului Dijkstra de drum minim, in care in loc sa pastram drumuri minime, pastram drumuri pt care muchia maxima are valoare cat mai mica. O implementare cu heapuri a acestui algoritm are complexitate O(m log n). De asemenea algoritmul Bellman Ford poate fi modificat usor pentru a ne rezolva problema, chiar daca acest algoritm are complexitatea O(nm) in practica implementarea lui ce foloseste o lista se comporta cu mult mai bine. Ultimele trei rezolvari ar fi luat in jur de 70 de puncte.\nSolutia oficiala se bazeaza tot pe o varianta a algoritmului Dijkstra, dar care in loc sa foloseasca un heap pentru a determina nodul i inca neexpandat cu drumul de la sursa la el de cost minim, foloseste niste liste. Aceasta abordare este identica cu cea din problema Car, si comisia se astepta ca multi concurenti sa rezolve perfect problema, asteptare infirmata de rezultatele din concurs. Cum ponderile muchiilor sunt numere de la 1 pana la 1000 inseamna ca in d[i] oricare ar fi nodul i va fi intotdeauna mai mica sau egala cu 1000. Vom folosi astfel 1000 de liste dublu inlantuite. In lista i vom tine minte nodurile x pentru care d[x] = i. Cand d[x] se micsoreaza inseram pe x intr-o lista mai mica, dar pentru a il sterge din lista veche vom folosi \"lazy deletion\". Adica atunci cand ajungem la lista i si vrem sa expandam nodul x verificam mai intai daca d[x] = i, daca nu inseamna ca d[x] < i si nodul x a fost expandat mai devreme, deci putem sa il ignoram. Acest algoritm are complexitate O(kmax + n +\nm).\nComisia a mai discutat posibilitatea de a propune problema folosind un graf neorientat. Atunci o solutie similara algoritmului Kruskal ar fi avut complexitate aproape de cea optima. Am fi putut folosi un radix sort pentru a sorta muchiile, iar apoi sa adaugam muchii in ordine crescatoare la graf pana cand nodul start si nodul destinatie ar fi fost in aceiasi componenta conexa. Pentru a gestiona componentele conexe am fi folosit structuri de multimi disjuncte. Aceasta solutie ar fi avut complexitatea O(kmax + m log*n).\n\n\n\nArbore\n\n(problema medie clasele XI-XII)\n\nO prima idee de rezolvare a problemei are o complexitate de O(1) la operatiile de tip update si O(n) la operatiile de tip query. Cand intalnim o operatie de tip 1 este necesar sa folosim un vector S[1..N] in care marcam aceste modificari. Astfel, adunand valoarea s la elementul S[p] vom observa ca suma pe care a primit-o un nod X este de fapt suma valorilor S[nod] unde nod reprezinta indicele nodurilor din drumul lui X pana la radacina arborelui. Deci, pentru o operatie de tipul 1 vom face o singura adunare, iar pentru o operatie de tipul 2 vom efectua o parcurgere in adancime pentru a cauta suma ceruta. Aceasta solutie obtine in jur de 30 de puncte.\n\nO alta abordare ar fi reducerea problemei la nivel de vector. Am putea renumerota nodurile arborelui astfel incat subarborele fiecarui nod sa aiba id-uri consecutive. Acest lucru se poate face cu o parcurgere in adancime. Acum trebuie sa efectuam adunari pe intervale compacte de pe un vector, si trebuie sa gasim un element din vector ce are o anumita suma. Acest lucru se poate face, de asemenea in O(1) pentru update si O(N) pentru query usor. Aceasta solutie este mai rapida decat prima, deoarece nu foloseste apeluri recursive ale functiilor si efectueaza un numar mic de operatii. Asa s-ar fi luat 50-60 de puncte In cazul in care problema s-ar fi redus la nivel de vector dar atat update-ul cat si querry-ul s-ar fi efectuat in O(n) s-ar fi obtinut 30-40 de puncte..\n\nSolutia care ar fi obtinut punctajul maxim se bazeaza pe reducerea problemei la nivel de vector, descrisa in paragraful precedent. Fie SEC = sqrt(N). Putem imparti vectorul de lungime N in SEC secvente de lungime SEC. Vom mai folosi 3 vectori A[1..N] reprezentand sumele pe fiecare element ce au fost adunate la inceputul secventelor de lungime SEC, C[1..SEC] reprezinta sumele ce s-au adunat pe intregile secvente, iar P[1..SEC][1..1 000 000] este o matrice binara unde P[i][j] = 1 daca exista un element din secventa i astfel incat A[element] = j. Aceasta idee ne ajuta sa rezolvam problema intr-o complexitate de O(sqrt(n)) atat pentru query cat si pentru update. Pentru ca memoria folosita sa fie rezonabila implementarea matricii P se face pe biti.\n\n\n\n\n\nPedefe\n\n(problema grea clasele XI-XII)\n\nProblema cere determinarea numarului de subsiruri comune crescatoare al sirurilor S1 si S2 , care-l contin pe S3 ca subsir. Pentru a rezolva vom folosi metoda programarii dinamice. Se va construi un tabel A cu semnificatia:\nA[k,i,j] = cate subsiruri comune crescatoare exista tinand cont doar de primele i valori ale lui S1, primele j valori ale lui S2, si care sa contina ca subsir primele k caractere din S3, iar ultima valoare din aceste subsiruri sa fie S1[i]. Valorile din tablou se vor calcula doar atunci cand S1[i] = S2[j], in rest valorile vor fi 0. In implementare, se vor pastra doar ultimele doua linii din tabloul A, A[k-1] si A[k].\n\nIn continuare se vor prezenta mai multe implementari bazate pe aceasta idee cu diferite complexitati si care aduc punctaje diferite.\n\n* Solutia O(N^2*M^2*P) - 30 puncte\n\nPentru a calcula A[k, i, j] ne vom uita fie in A[k-1] daca S1[i] = S2[j] = S3[k], fie in A[k] (S1[i] = S2[j], S1[i] != S3[k]). Se vor aduna valorile A[k (sau k-1), p, q] cu p<i, q<j si S1[p] <= S1[i].\n\n* Solutia O(N*M^2*P) - 50 puncte\n\nSe porneste de la solutia anterioara si se observa faptul ca pentru fiecare q care se considera se poate preprocesa suma A[k (sau k-1), p, q] pentru p < i intr-un tablou S. Dupa ce se calculeaza A[k, i, j] considerand doar acele q pentru care S2[q] <= S2[j], se actualizeza S[k, j].\n\n* Solutia O(N*M*P*Sigma) - 75 puncte\n\nIn cazul cel mai devaforabil numarul de valori distincte din siruri este min(N, M), dar se garanteaza in enunt ca Sigma (numarul de valori distincte) este <= 20 pentru inca 25% din teste. Pornind de la solutia anterioara, se observa ca , parcurgand j-ul de la 1 la M, nu este necesar sa consideram de fiecare data toate valorile q < j, aceste informatii putand fi actualizate in O(1). Deoarece trebuie sa numaram doar valorile cu S2[q] <= S2[j], se pastreaza intr-un vector V[x] , suma q-urilor < j , cu S2[q] <= x. Calculul lui A[k,i,j] se face in O(Sigma), iar dupa aceasta se actualizeaza vectorul V in O(1).\n\n* Solutia O(N*M*P*lgSigma) - 100 puncte\n\nSolutia de 100 este asemantoare cu solutia de 75 de puncte, singura diferenta fiind folosirea unui arbore indexat binar pentru a face in O(lgSigma) operatiile desccrise mai sus.\n\nReferences\n\nVisible links\n1. http://infoarena.devnet.ro/forum/index.php/topic,935.0.html\n2. http://infoarena.devnet.ro/forum/index.php/topic,999.0.html\n\n',0,'public');
INSERT INTO `ia_textblock_revision` VALUES ('usaco-ianuarie-2005-divizia-gold','Usaco ianuarie 2005, divizia GOLD','2006-11-17 19:56:35','h1. Usaco ianuarie 2005, divizia GOLD\r\n\r\n(Creat de \'_silviug_\':user/silviug la data de _2005-03-03_ categoria _Competitii_, autor(i) _Silviu Ganceanu, Mircea Pasoi_)\r\n\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nAcest set de probleme a fost considerat unul dintre cele mai grele, daca nu cel mai greu, de pana acum. Problemele au fost intr-adevar dure cu atat mai mult cu cat timpul de lucru a fost mic (3 ore). In ciuda acestui fapt concurentii din Romania s-au comportat bine, concursul marcand primul succes de pe anul acesta al tarii noastre: locul 5 obtinut de Adrian Vladu.\r\n\r\nDesi rezultatele i-au determinat pe antrenorii americani sa considere setul de probleme cel mai greu de pana acum, pentru multi dintre elevii Romaniei problemele nu au fost in totalitate noi: cover a fost propusa (sub o forma un pic diferita) la CEOI, o varinta ceva mai blanda a problemei juice (cu limite mai mici) am putut vedea si in finala rundei .Campion de anul trecut iar ideea de rezolvare pentru naptime nu era noua (o problema din concursul $\"Stelele Informaticii\"$ de anul trecut se pare ca semana mult cu aceasta).\r\n\r\nCu toate aceastea problemele au fost deosebit de dificile necesitand concentrare maxima. Rezultatele elevilor din Romania s-au imbunatatit semnificativ fata de concursul precedent, acestia obtinand locuri mai bune. O parte din succesul acestora indraznesc sa o pun si pe seama faptului ca problema cea mai grea din concurs era cunoscuta la noi in tara. Avem astfel urmatorul clasament:\r\n\r\ntable(example). | 1. | Adrian Vladu | 958 puncte |\r\n| 2. | Sorin Stancu-Mara | 703 puncte |\r\n| 3. | Mircea Pasoi | 700 puncte |\r\n| 4. | Andrei Teodorescu | 640 puncte |\r\n| 5. | Dan-Ionut Fechete | 547 puncte |\r\n| 6. | Adrian Diaconu | 502 puncte |\r\n\r\nRestul concurentilor au obtinut punctaje frumoase dar mai mici de 400 de puncte. Sunt de remarcat comportarile bune de pana acum ale lui Andrei Teodorescu care reuseste sa se \"tina\" de mult mai titratii elevi ai Romaniei care au deja in palmares cel putin o medalie internationala.\r\n\r\nSetul de probleme, impreuna cu testele si clasamentul, se gaseste in cadrul \"sectiunii download\":http://info.devnet.ro/download.php?page=cat&cat=33 . In continuare vom prezenta solutiile:\r\n\r\nh2. Cover\r\n\r\nProblema nu era foarte dificila, cu atat mai mult cu cat ideea de rezolvare a problemei guards din concursul CEOI 2002 era aceeasi: se construieste un graf bipartit avand intr-o multime barele orizontale (set maximal de pozitii de pe o linie din matrice in care avem noroi) si in cealalta multime barele verticale (definite analog dar pentru coloane). Intre doua noduri din acest graf bipartit vom avea muchie doar daca barele corespunzatoare lor au o celula comuna. Pentru exemplificare vom lucra cu exemplul din enunt:\r\n\r\n@*.*.@\r\n@.***@\r\n@***.@\r\n@..*.@\r\n\r\nIata cum vom construi prima multime a grafului bipartit (vom pune numarul nodului din graf corespunzator fiecarei celule):\r\n\r\n@1.2.@\r\n@.333@\r\n@444.@\r\n@..5.@\r\n\r\nA doua multime a grafului bipartit va arata astfel (nodurile vor fi numerotate incepand tot cu 1):\r\n\r\n@1.2.@\r\n@.324@\r\n@532.@\r\n@..2.@\r\n\r\nMuchiile din graful bipartit vor fi urmatoarele:\r\n\r\n$(1, 1) (2, 2) (3, 3) (3, 2) (3, 4) (4, 5) (4, 3) (4, 2) (5, 2)$\r\n\r\nAsadar fiecarei celule din harta terenului ii corespunde o singura muchie in acest graf bipartit. Avand construit graful trebuie sa aflam numarul minim de noduri selectate astfel incat orice muchie sa aiba cel putin un capat intre nodurile selectate (in literatura de specialitate aceasta problema se numeste $Minimum Vertex Cover$). Explicatia acestui lucru este simpla: orice muchie, fiind de fapt o celula, ea trebuie sa fie \"acoperita\" de cel putin un nod din graf (adica o placa orizontala sau verticala utilizata de FJ). Problema acesta este NP-completa pentru grafuri generale dar in cazul grafurilor bipartite ea se poate rezolva in timp polinomial. De asemenea s-a demonstrat ca numarul minim de noduri dintr-un astfel de set este egal cu cardinalul cuplajului maximal din graful bipartit. De aici nu mai e decat un pas spre solutia finala. Avem, astfel, urmatorii pasi in algoritmul de rezolvare a problemei:\r\n\r\n\r\n* PAS 1: Construirea grafului bipartit$\r\n* PAS 2: Aflarea cuplajului maximal$\r\n\r\n\r\nPrimul pas este banal si consta din simple parcurgeri ale matricii. Pentru aflarea cuplajului maximal se poate afla utilizand un algoritm de aflarea a fluxului maxim in reteaua asociata grafului bipartit sau se poate algoritmul bazat pe gasirea succesiva a drumurilor in crestere in graf.\r\n\r\nComplexitatea finala a algoritmului va fi O(N^2*M^2) deoarece in graful bipartit avem maxim N*M muchii si vom N*M noduri. Cum algoritmul pentru aflarea cuplajului maximal are complexitatea V*E (V = numarul de noduri din graf, E = numarul de muchii din graf) concluzia este evidenta.\r\n\r\nCa tema, recomand rezolvarea urmatoarelor probleme a caror solutie se bazeaza pe aflarea cuplajului maximal intr-un graf bipartit (in unele cazuri acest lucru insa nu este de ajuns):\r\n\r\n1. guards (CEOI 2002)\r\n2. knigths (Baltica 2001) - in solutia oficiala a acestei probleme gasiti mai multe informatii despre notiunea de cuplaj maximal intr-un graf bipartit si problemele inrudite\r\n3. Problema Paznici din runda a patra a concursului Algoritmus (gasiti pe pagina si explicatia solutiei) [2]http://algoritmus.org/probleme/Probleme_Runda04.php\r\n4. [3]http://acm.timus.ru/problem.aspx?space=1&num=1106\r\n5. [4]http://acm.sgu.ru/problem.php?contest=0&problem=234\r\n6. [5]http://acm.sgu.ru/problem.php?contest=0&problem=210\r\n7. [6]http://acm.sgu.ru/problem.php?contest=0&problem=218\r\n8. [7]http://online-judge.uva.es/p/v107/10735.html\r\n9. [8]http://online-judge.uva.es/p/v108/10804.html\r\n10. [9]http://online-judge.uva.es/board/viewtopic.php?t=7462\r\n\r\nMentionez ca problema 8 m-a impresionat in mod placut fiind una dintre cele mai frumoase probleme pe care le-am intalnit in ultimele cateva luni.\r\n\r\nJuice\r\n\r\nFie A(i, j) inaltimea blocului aflat in pozitia (i, j). Aflam inaltimea maxima la care poate urca nivelul sucului in fiecare celula. Daca notam aceasta inaltime cu B(i, j) solutia problemei va fi suma( B(i, j) - A(i, j) ).\r\n\r\nVom numi celula turn o celula (i, j) care are propietatea ca B(i, j) = A(i, j) (nu putem pune suc in ea pentru ca ar curge in afara matricei). Componenta conexa a unei celule turn (i, j) este compusa din acele celule (x, y) pentru care avem B(x, y) = A(i, j). Definim inaltimea componentei conexe ca fiind inaltimea comuna a tuturor celulelor componente. Facem urmatoarele observatii utile in rezolvarea problemei:\r\n\r\n1. Celulele de pe marginea matricei sunt celule turn\r\n2. Celula (x, y) devine celula turn daca este vecina unei celule (i, j) ce face parte dintr-o componenta conexa si are propietatea ca B(i, j) < A(x, y).\r\n\r\nIncet, incet se contureaza solutia problemei observand ca, pentru a declara o celula ca fiind turn, trebuie sa aflam componentele conexe ale celulelor turn mai joase decat ea. Acest lucru ne aduce la ideea de procesa aceste celule turn in ordinea inaltimii lor afland pentru fiecare componenta conexa corespunzatoare. In acelasi timp aflam si celule ce devin turn si sunt mai inalte. Pentru aceasta utilizam o coada de prioritati (un heap) in care pastram toate celule turn neprocesate inca ordonate descrescator dupa inaltime. Ajungem astfel la nimic altceva decat un algoritm de tip FILL modificat corespunzator cerintelor acestei probleme. Iata o descriere a acestuia:\r\n\r\n\r\n\r\nPAS 1: Se introduc in coada de prioritati\r\n\r\npozitiile de pe margine\r\n\r\n\r\n\r\nPAS 2: Cat timp heapul nu este gol:\r\n\r\n* se selecteaza celula turn cea mai joasa\r\n\r\n* se afla componenta conexa a acesteia\r\n\r\n* se introduc in coada de prioritati\r\n\r\ncelulele vecine cu componenta conexa construita\r\n\r\ncare au inaltimea mai mare decat inaltimea\r\n\r\ncomponentei\r\n\r\n\r\n\r\nSe poate modifica usor algoritmul FILL pentru a rezolva toate aceste cerinte. Complexitatea finala a algoritmului va fi O(N^2*logN) deoarece, in cazul cel mai defavorabil, toate celulele sunt turn (un exemplu este cand matricea este piramidala) si in consecinta toate celulele vor fi introduse si scoase din heap necesitand logN pentru fiecare operatie. Aflarea componentelor conexe va necesita O(N^2) timp in total fiindca o celula va fi selectata o singura data intr-o componenta conexa si va fi accesata de maxim 4 ori de algoritmul FILL. Ca detalii de implementare, programatorii in C++ pot folosi cozile de prioritati din STL (pririority_queue ce se gaseste in headerul <queue>) pentru a reduce din complexitatea implementarii. Totusi, trebuie acordata atentie utilizarii acestora deoarece este posibil ca sursa sa depasesca timpul de executie.\r\n\r\nNaptime\r\n\r\nVom incerca sa rezolvam problema, ignorand la inceput faptul ca sirul este circular. Astfel, problema se transforma intr-una relativ usoara, abordabila cu programare dinamica. O prima incercare ar fi sa realizam o astfel de rezolvare: A(i, j) = utilitatea de somn maxima care se poate obtine alegand j perioade din primele i.\r\nRelatia de recurenta care se obtine este A(i, j)=max(A(i-k, j-k)+suma U[i-k+2]...U[i]) unde U este vectorul de utilitati. Din pacate aceasta abordare are dezavantajul ca are complexitatea de timp O(N*B^2) si de memorie O(N*B), neincadrandu-se nici in timp si nici in spatiu de memorie. Astfel, vom incerca sa imbunatatim aceasta dinamica modificand un pic semnificatia matricei A bazandu-ne pe faptul ca alegerea unei secvente continue de perioade aduca ca utilitate suma lor, mai putin prima perioada folosita:\r\nA(i, j, 1) = utilitatea de somn maxima care se poate obtine alegand j perioade din primele i si ultima perioada folosita sa fie j\r\nA(i, j, 0) = utilitatea de somn maxima care se poate obtine alegand j perioade din primele i si ultima perioada folosita sa NU fie j\r\nObtinem relatiile de recurenta:\r\nA(i, j, 1) = max(A(i-1, j-1, 1) + U[i], A(i-1, j-1, 0))\r\nA(i, j, 0) = max(A(i-1, j, 0), A(i-1, j, 1))\r\nAm redus complexitatea la O(N*B) si memoria la O(N), o imbunatatire substantiala.\r\n\r\nDeoarece sirul este circular, putem rezolva problema aplicand de N ori dinamica de mai sus considerand sirul liniar si alegand fiecare pozitie ca fiind pozitia initiala, dar aceasta solutie depaseste cu mult limita de timp pe cazul cel mai defavorabil. Totusi, aceasta idee ar fi adus 10 teste din cele 14. Cu un mic truc, si anume alegerea aleatorie a pozitiei de start cat timp nu s-a depasit timpul de executie, s-ar mai fi putut obtine inca 2 teste, in total 12 (desi aceasta rezolvare nu obtine solutia optima pe testele foarte mari).\r\n\r\nPutem scapa de faptul ca sirul este circular mult mai elegant, aplicand de 2 ori dinamica: odata cum am zis mai sus (acoperind cazul cand pozitiile N si 1 nu sunt in aceeasi secventa de pozitii consecutive) si inca odata fortand sa existe o secventa de utilitati aleasa care contine pozitiile N si 1. A doua dinamica se poate obtine exact ca mai sus, aplicand aceeasi idee doar ca se initializeaza A(1, 1, 1)=U[1] in loc de 0, si apoi pentru fiecare i se verifica rezultatul curent cu max(A(i, B-(N-i), 0), A(i, B-(N-i), 1)) + suma U[i+2]...U[N]. Pentru a se incadara in limita de 0.3s trebuie acordata o mare grija la implementare, de exemplu, optimizand dinamica de mai sus de la 2*N memorie (ultimele doua linii din matricea A) la doar N pastrand doar ultima linie si parcurgand indicele j descrescator.\r\n\r\nReferences\r\n\r\nVisible links\r\n2. http://algoritmus.org/probleme/probleme_runda04.php\r\n3. http://acm.timus.ru/problem.aspx?space=1&num=1106\r\n4. http://acm.sgu.ru/problem.php?contest=0&problem=234\r\n5. http://acm.sgu.ru/problem.php?contest=0&problem=210\r\n6. http://acm.sgu.ru/problem.php?contest=0&problem=218\r\n7. http://online-judge.uva.es/p/v107/10735.html\r\n8. http://online-judge.uva.es/p/v108/10804.html\r\n9. http://online-judge.uva.es/board/viewtopic.php?t=7462\r\n\r\n',18,'public'),('preoni-2005/runda-2/solutii','preONI 2005 runda #2 - solutii','2006-11-18 13:56:51','h1. preONI 2005 runda #2 - solutii\r\n\r\n(Creat de ==user(user=\"silviug\" type=\"tiny\")== la data de _2005-02-25_ categoria _Competitii_, autor(i) _Echipa devNet_)\r\n\r\nDesi s-a desfasurat intr-o zi de miercuri, runda a doua a concursului preONI a avut un numar aproape dublu de accesari fata de runda 1. Acest lucru se datoreaza probabil atat faptului ca olimpiada judeteana \"bate la usa\" cat si prezentei premiilor oferite de sponsorul nostru, Microsoft Romania.\r\n\r\nIn continuarea acestui articol vom descrie solutiile oficiale ale problemelor. Daca aveti nelamuriri puteti sa puneti intrebari pe \"forum\":http://www.infoarena.ro/Forum.\r\n\r\nScopul principal al concursului preONI 2005 este antrenamentul pentru ONI. Nivelul problemelor a fost corespunzator, asa ca nu fiti descurajati la OJI daca n-ati facut foarte bine acum! ;)\r\n\r\nPunctajele sunt multumitoare, fiindca de data asta nu s-au mai acordat cel putin $50p$ pentru solutii \"brute force\". Raportul de dificultate al problemelor a fost pastrat ca la runda {$1$}.\r\n\r\nIn continuare vom prezenta solutiile oficiale ale autorilor problemelor.\r\n\r\nh2. Clasele 9-10\r\n\r\nh3. Clasament\r\n\r\n==Rankings(rounds=\"preoni52a\" display_entries=\"8\" pager_style=\"none\")==\r\n\r\nSub pseudonimele ==user(user=\"arhirel\" type=\"tiny\")== si ==user(user=\"macarie\" type=\"tiny\")== se \"ascunde\", ca si la prima runda, echipa care va reprezenta Romania la finala ACM, formata din Mugurel Andreica, Marius Andrei si Ghinea Dan. Ei au concurat pe un singur calculator pentu a simula un concurs ACM. Stati linistit, premiile se dau doar concurentilor din ciclul de invatamant pre-universitar! De asemenea, se pare ca unii concurenti simt nevoia sa-si creeze mai multe conturi, Sorin Fagateanu avand 3 conturi in top 5 (cele 2 pe numele lui si contul cu numele \"Ion Iliescu\")... Tineti minte ca la un concurs \"standard\" nu aveti voie cu mai multe surse!\r\n\r\nh3. Pascal\r\n\r\nCa sa calculam puterea la care apare factorul prim $p$ in descompunerea lui $n!$ se poate folosi urmatoare formula $f = [n/p] + [n/p^2^] + [n/p^3^] +$ ... ({$[]$} reprezinta partea intrega). Avand acesta formula putem traversa un anumit rand din triunghiul lui Pascal si pt fiecare element ({$r,c$}) putem calcula puterea la care apare $d$ in descompunerea lui $r ! / ((r-c) ! * c!)$ . Atunci cand $d$ nu este prim trebuie sa avem grija sa verificam daca respectivul element ({$r,c$}) are in descompunerea sa toti factori primi a lui {$d$}. Daca $d=6$ , elementul din ({$r,c$}) trebuie sa contina $2$ si $3$ in descompunerea sa, iar daca {$d = 4$}, trebuie sa contina $2$ de cel putin doua ori.\r\n\r\nO alta modalitate sa calculam puterea la care apare un factor prim $p$ in descompunerea lui este: fie {$A{~c~}$} = puterea la care apare $p$ in decompunrea lui ({$r,c$}). $A{~c+1~}$ = {$A{~c~}$} + puterea lui $p$ in ({$r-c$}) - puterea lui $p$ in ({$c+1$}). Acesta relatie se poate deduce din modul din care putem calcula elementul ({$r,c+1$}) din ({$r,c$}) folosind formula ({$r,c$}) = $r ! / ((r-c)! * c !)$\r\n\r\nAceasta a fost cea mai simpla problema de la clasele {$9-10$}, oricare din cele doua idei prezentate mai sus aducand punctaj maxim.\r\n\r\nh3. Secv\r\n\r\nSubsirul trebuie sa contina toate elementele din sirul original in ordine crescatoare asa ca primul pas este sa ne formam acest subsir {$C$}. Avand acest subsir, parcurgem vectorul initial pentru a gasi pozitia de start a noii subsecvente. Dupa ce am gasit o posibila pozitie de start s incercam sa gasim subsirul $C$ avand ca pozitie de start {$s$}. Din toate aceste subsecvente o alegem pe aceea cu lungimea minima. Asftel, complexitatea algoritmului ajunge la {$O(N*M)$}, unde $N$ este lungimea secventei initiale si $M$ lungimea subsirului {$C$}. Problema se poate rezolva in aceeasi complexitate si cu programare dinamica, lasam acesta rezolvare ca exercitiu pentru concurenti!\r\n\r\nh3. Car\r\n\r\nLa prima vedere problema pare simpla si abordabila cu o cautare in latime, dar la o citire mai atenta problema se dovedeste putin mai grea. Cerinta e una de gasire a drumului minim intr-un graf in care nodurile sunt reprezentate de trei intregi ({$i,j,dir$}), $i$ si $j$ avand semnificatia liniei si coloanei din matrice iar $dir$ reprezinta directia cu care am intrat pe pozitia curenta. Muchiile din graful nostru au costurile dupa cum s-a explicat in enunt. Pentru gasirea drumului putem folosi algoritmul Dijkstra care foloseste un heap pentru expandarea nodurilor, complexitatea unei astfel de rezolvari ar fi fost $O(N*M lg (N*M))$ dar un asemenea algoritm nu ar fi luat punctaj maxim. O observatie care ne poate reduce constanta algoritmului ar fi ca nu are rost sa folosim curbe de $180$ sau de $135$ de grade, pentru ca am fi ajuns in aceeiasi pozitie mai repede. Pentru a nu folosi memorie prea multa pentru reprezentarea nodurilor in coada noastra de prioritati am putea folosi un singur intreg in loc de trei astfel:\r\n\r\n== code(cpp) |x = ((i - 1) * m + (j - 1)) * 8 + dir\r\n==\r\n\r\nsi decodificarea ar fi\r\n\r\n== code(cpp) |dir = x % 8; x /= 8;\r\nj = (x % m) + 1;\r\ni = (x / m) + 1;\r\n==\r\n\r\nPentru a avea o viteza mai mare la codificare si decodificare putem folosi operatii pe biti: $dir$ sa fie reprezentat pe $3$ biti {$i$}, pe urmatorii $9$ biti, iar $j$ pe urmatorii $9$ biti ({$i,j &le; 500 < 2^9^=512$}), astfel codificarea si decodificarea devin\r\n\r\n== code(cpp) |x = (i << 9) + j + (dir << 18);\r\ndir = x >> 18;\r\nj = (x & 511);\r\ni = (x >> 9) & 511;\r\n==\r\n\r\nCosturile muchiilor in graful nostru sunt mici si un algoritm ca cel\r\nal lui Dijkstra nu tine cont de aceasta proprietate. Daca aceste costuri sunt mici atunci si costul final al drumului de la sursa la destinatie va fi mic deci ne permitem sa folosim pentru fiecare valoare posibila a costului unui drum de la sursa la destinatie cate o lista. Cand am determinat pentru un nod distanta minima de la sursa la el, il inseram intr-o astfel de lista, observam ca expandarea unui astfel de nod poate afecta numai urmatoarele $4$ liste (prin expandare ne referim la actualizarea distantei minime de la sursa a vecinilor nodului curent). O astfel de rezolvare ar arata cam asa (pseudo-C):\r\n\r\n== code(cpp) |for (dir =0; dir < 8; dir++)\r\n    lst[0].add(starti,startj,dir,0);\r\ncurrent_cost = 0;\r\nwhile (lst[0].size()+lst[1].size()+lst[2].size>0){\r\n    while (lst[curent_cost % 3].size()>0) {\r\n        x = lst[curent_cost % 3].pop();\r\n        expand(x);\r\n    }\r\n    curent_cost++;\r\n}\r\n==\r\n\r\nAm folosit numai trei liste pentru ca am tinut cont de optimizarea precizata mai sus de a nu folosi numai curbele la $0$ grade, $45$ grade si $90$ grade. Fiecare nod poate fi expandat o singura data, si poate fi introdus in liste de cel mult trei ori, deci o astfel de solutie are complexitatea ca timp si ca spatiu {$O(N*M)$}. Mergand mai departe pe aceasta idee putem obtine o rezolvare putin mai buna care injumatateste timpul de executie. Costurile au fost alese intr-un mod particular permitand ca o curba de $90$ de grade sa aiba acelasi cost cu doua curbe de {$45$}, una de $135$ acelasi cost ca trei de $45$ si una de $180$ acelasi cost ca si patru de {$45$}. Astfel putem modifica rezolvarea noastra si sa facem numai miscarile urmatoare: rotiri de $45$ de grade pe loc si miscari in fata pe directia de mers. Astfel procedura de expandare actualizeaza numai trei noduri si in cursul procedurii de actualizare putem sa lucram numai cu lista curenta si cu lista urmatoare, pentru ca efectuam numai miscari de cost zero si unu. Aceasta observatie a micsorat numarul de liste si a micsorat numarul de calcule din metoda expand, cea mai frecvent utilizata in algoritm. O astfel de rezolvare ar fi adus punctajul maxim pe aceasta problema. Mentionam ca toate observatiile facute nu ar fi fost neaparat necesare pentru obtinerea unui punctaj maxim. Testele au fost facute in vederea obtinerii a $50$ de puncte folosind cautare in latime simpla, $60-70$ de puncte folosind Dijkstra cu heapuri si $90-100$ de puncte folosind penultima rezolvare.\r\n\r\nh2. Clasele 11-12\r\n\r\nh3. Clasament\r\n\r\n==Rankings(rounds=\"preoni52a\" display_entries=\"7\" pager_style=\"none\")==\r\n\r\nClasamentul la 11-12 este dominat de echipa ACM care a reusit sa rezolve toate cele 3 probleme (pe unul din cele doua conturi). Este de remarcat faptul ca primii $5$ clasati au punctaje peste $200$ de puncte.\r\n\r\nh3. Indep\r\n\r\nProblema se poate rezolva in mai multe moduri. Limitele au fost alese astfel incat problema sa fie cat mai usoara. Vom prezenta cele doua solutii pe care le puteti gasi interesante:\r\n\r\nh4. Solutia 1\r\n\r\nPrima solutie, si cea mai simpla, utilizeaza principiul programarii dinamice. Se calculeaza numarul de subsiruri din primele $i$ elemente care sunt divizibile cu un numar $j$ intre $1$ si {$1000$}. Sa notam acest numar cu {$Cnt{@[@}i{@][@}j{@]@}$}. Se obtine urmatoare recurenta pentru calculul acestor valori:\r\n\r\n== code(cpp) |Cnt[i][cmmdc(j, A[i])] = Cnt[i - 1][j] + Cnt[i - 1][cmmdc(j, A[i])]\r\n==\r\n\r\nOdata calculate aceste valori solutia o vom avea in {$Cnt{@[@}N{@][@}1{@]@}$}. Numerele depasesc orice tip de date predefinit si trebuie utilizate numere mari. Limitele fiind destul de mari, folosirea bazei $10$ este periculoasa, pe unele teste fiind necesar folosirea bazei $10^9^$ pentru a reduce timpul de executie. De asemenea si memoria se poate reduce, observand faptul ca pentru a calcula {$Cnt{@[@}i{@][@}j{@]@}$} ne sunt necesare doar valorile pentru {$Cnt{@[@}i-1{@][@}k{@]@}$} (ultima doua linii). Complexitatea acestei solutiei va fi $O(N * K * L)$ unde $K$ reprezinta valoarea maxima din sir si $L$ lungimea maxima a numerelor mari.\r\n\r\nh4. Solutia 2\r\n\r\nCea de-a doua solutie, cu mult mai interesanta decat prima, foloseste principiul includerii se excluderii. Fie $D(x)$ multimea numerelor din sir care sunt divizibile cu un anumit numar {$x$}, atunci numarul de submultimi formate doar din astfel de numere este {$Z(x) = 2^card(D(x))^-1$}. Multimile pentru principiul includerii si excluderii sunt chiar {$D(p)$}, unde $p$ este un numar prim. Intersectia {$D(p{~1~})$}, {$D(p{~2~})$}, {$D(p{~3~})$}.. este {$D(p{~1~} * p{~2~} * p{~3~}...)$}, oarecum evident, pentru $p$ distincte. Rezultatul este de forma:\r\n\r\n== code(cpp) |Rezultat = Z(1) - Z(2) - Z(3) - Z(5)... +\r\n           Z(2 * 3) + Z(2 * 5) + Z(3 * 5)... -\r\n           Z(2 * 3 * 5) ...\r\n==\r\n\r\nAcesta se deduce din principiul includerii si al excluderii. Pentru a-l calcula efectiv, luam toate numerele {$x < 1000$}, produs de numere prime distincte, si vom adauga sau scadea $Z(x)$ in functie de paritatea numarului de factori ai acestuia. Nu ne intereseaza decat produsele de numere prime distincte, care pot fi obtinute ca un produs {$p{~1~}*p{~2~}*p{~3~}$}... Complexitatea finala este sub {$O(N*K + N*L)$}, unde $K$ si $L$ au semnificatia de mai sus. Folosim $O(N*K)$ pentru a calcula $D(x)$ pentru fiecare {$x$}, dar pentru fiecare $x$ adunam sau scadem $Z(x)$ o singura data, asa ca facem doar $N$ operatii pe numere mari, o imbunatatire majora asupra primei rezolvari. Pentru a obtine aceasta complexitate este nevoie sa precalculam valorile lui $2^x^$ in {$O(N * L)$}, altfel ca sa calculam $Z(x)$ pentru fiecare ar fi nevoie de $O(L * X)$ timp.\r\n\r\nh3. Cerere\r\n\r\nProblema este de dificultate medie. O rezolvare $O(N*lg(N))$ este usor de gasit, fiind asemanatoare cu una deja exista in arhiva, \"Stramosi\":http://www.infoarena.ro/task/stramosi. Dar o astfel de rezolvare n-ar fi adus punctaj maxim in mod normal. Problema se poate rezolva printr-o simpla parcurgere in adancime din radacina implementand manual stiva DF-ului. Cand vom pune un nod $n$ pe pozitia $p$ in stiva, al {$K$}-lea stramos va fi nodul de pe pozitia $p-K$ din stiva, pentru care s-a procesat deja valoarea ceruta. Complexitatea finala a algoritmului va fi {$O(N)$}.\r\n\r\nh3. Rubarba\r\n\r\nAceasta problema e clasica in geometria computationala. O prima observatie care ne ajuta in rezolvare este ca numai punctele de pe infasuratoarea convexa influenteaza forma dreptunghiului minim. Deci primul pas in rezolvarea problemei este sa gasim infasuratoarea convexa a punctelor in {$O(N*lg(N))$}. Daca avem fixata o directie atunci e usor sa determinam in $O(h)$ (unde $h$ e numarul de puncte de pe infasuratoarea convexa) cele patru puncte ce marginesc dreptunghiul dupa directia aleasa si dupa directia perpendiculara. Folosind cautare binara pentru a determina cele patru puncte extreme, reducem astfel complexitatea la {$O(lg(h))$}. Observatia finala este ca un dreptunghi de arie minima ce contine o multime de puncte in interior trebuie sa aiba o latura paralela cu una din laturile infasuratorii convexe, aceasta idee este intuitiva dar demonstratia ei nu este foarte simpla. Complexitatea algoritmului ce rezolva problema poate fi $O(N*lg(N) + h^2^)$ sau $O(n*lg(n) + h*lg(h))$ daca folosim cautarea binara. Testele folosite au fost generate aleator, generand aleator puncte in plan infasuratoarea convexa va avea cardinalul $h$ teoretic egal cu {$&#920;(lg(N))$}, deci rezolvarea $O(N*lg(N) + h^2^)$ ar fi luat fara probleme punctaj maxim. Mentionam ca exista o tehnica numita \"Rotating Calipers\" care rezolva aceasta problema si altele similare in {$O(N*lg(N) + h)$}, daca vreti sa cititi despre aceasta tehnica accesati \"pagina\":http://cgm.cs.mcgill.ca/~orm/rotcal.html. Idei de acolo v-ar fi ajutat sa rezolvati problema propusa recent la \".campion\":http://campion.edu.ro/index.php, care cerea separarea a doua poligoane convexe cu o dreapta, si o prolema propusa anul trecut la Bursele Agora care cerea determinarea distantei maxime ce exista intre oricare doua puncte dintr-o multime, si tot pe acea pagina gasiti demonstratia matematica a faptului ca dreptunghiul de arie minima ce contine in interior o multime de puncte are o latura paralela cu o latura a infasuratorii convexe.\r\n\r\nh2. Incheiere\r\n\r\nPana la urmatorul concurs, BAFTA LA OJI!\r\n\r\n',961,'public'),('introducere-in-asamblare','Introducere in asamblare','2006-11-21 19:55:27','h1. Introducere in asamblare\n\n(Creat de \'_chris_11_\':user/chris_11 la data de _2005-08-15_ categoria _Limbaje_, autor(i) _Botau Cristian_)\n\n*Continut scurt:*\n Acest articol prezinta un limbaj mai putin folosit : limbajul de asamblare. Este folosit de cele mai multe ori pentru marirea vitezei de rulare a programelor. In prima sectiune sunt prezentate cateva avantaje / dezavantaje in folosirea acestui limbaj. Apoi sunt definite notiunile elementare ce trebuie stiute inainte de a trece la tratarea limbajului propriu-zis. De asemenea, sunt prezentate cateva intructiuni si transcrieri ale unor structuri din C/Pascal in limbaj de asamblare. In final sunt comparati timpii de executie intre varianta pascal si varianta assembler ale unei proceduri de Bubble Sort.\n==Include(page=\"template/raw\")==\n\nAcest articol prezinta un limbaj mai putin folosit : limbajul de asamblare. Este folosit de cele mai multe ori pentru marirea vitezei de rulare a programelor. In prima sectiune sunt prezentate cateva avantaje / dezavantaje in folosirea acestui limbaj. Apoi sunt definite notiunile elementare ce trebuie stiute inainte de a trece la tratarea limbajului propriu-zis. De asemenea, sunt prezentate cateva intructiuni si transcrieri ale unor structuri din C/Pascal in limbaj de asamblare. In final sunt comparati timpii de executie intre varianta pascal si varianta assembler ale unei proceduri de Bubble Sort.\n\n\n*Continut lung:*\nLimbajul de asamblare : avantaje si dezavantaje in folosirea lui\n\n\n\nDesi este unul dintre cele mai vechi limbaje de programare, limbajul de asamblare este incorporat si *n cele mai noi compilatoare cum ar fi Visual C++ si Delphi. Codul de asamblare este foarte apropiat de codul executabil al programelor, asamblorul avand rolul de a codifica instructiunile din limbaj de asamblare in cod masina.\n\nIn prezent, limbajul de asamblare este din ce in ce mai putin folosit in scrierea programelor, deoarece compilatoarele de ultima generatie au functiile cele mai folosite de programatori deja scrise si optimizate in limbaj de asamblare (gen memmove, memset / fillchar, etc.) incluse in unit-uri si biblioteci. Bineinteles, daca se doreste atingerea unor timpi de executie foarte mici, folosirea limbajului de asamblare este preferabila (cand avem algoritmul de complexitate optima).\n\nAvantaje ale limbajului de asamblare\n\n* Viteza foarte mare the executie a programelor (unele programe scrise si optimizate in asamblare au viteza de executie pana la 5-10 de ori mai mare decat cele scrise in C sau Pascal);\n* Marimea codului executabil este foarte mica;\n* Ajuta utilizatorul sa inteleaga mai bine cum functioneaza microprocesorul si sa scrie programe eficiente si in High Level Languages.\n\n\n\nDezavantaje ale limbajului de asamblare\n\n* nu este portabil; un program scris pentru calculatoare IBM PC nu va rula pe un Apple Macintosh (difera unele instructiuni);\n* un program in asamblare este mai greu de scris si ia mai mult timp decat un program scris in Pascal sau C;\n* un program scris in asamblare este mai greu de depanat;\n\nMajoritatea compilatoarelor din prezent permit programatorului sa scrie anumite parti de cod sau subprograme in asamblare, astfel incat programatorul sa poata scrie in asamblare doar partea din program care se executa de cele mai multe ori, programul ruland astfel mult mai rapid. Sunt si compilatoare dedicate exclusiv limbajului de asamblare, cum ar fi TASM - Turbo Assembler (il gasiti in directorul BP/Bin), MASM - Microsoft Assembler, etc.\n\nPentru a scrie o secventa de limbaj de asamblare intr-un program C se foloseste cuvantul rezervat asm :\n\nasm { instructiuni in asamblare };\n\niar in pascal :\n\nasm\ncod asamblare\nend.\n\n\n\n\n\nNotiuni de baza ale limbajului de asamblare\n\nRegistrii\n\nLimbajul de asamblare este foarte apropiat de codul executabil, deci pentru ca programatorul sa fie capabil sa scrie codul in asamblare trebuie sa cunoasca modul in care functioneaza microprocesorul si modul in care acesta executa instructiunile.\n\nToate operatiile aritmetice/logice/acces la memorie se fac prin intermediul registrilor. Registrii microprocesorului sunt asemanatori variabilelor (pot fi initializati cu anumite valori, se pot efectua operatii asupra lor, pot fi accesati (cititi/modificati)).\nRegistrii microprocesorului sunt clasificati in mai multe categorii :\n\n* registri de uz general : eax, ebx, ecx, edx si subregistrii lor;\n* registri segment : cs (code segment), ds (data segment), es (extra segment), ss (stack segment) - sunt folositi pentru adresarea memoriei in cazul modelului de memorie segmentat\n* registrii index : esi, edi (source index, destination index);\n* registri speciali : ebp, esp, ip;\n\nRegistrii de uz general sunt folositi in executia operatiilor aritmetice si logice. Registrii de segment si cei index sunt folositi in adresarea memoriei, iar cei speciali sunt folositi de microprocesor si S.O. pentru rularea programelor.\n\n\n\nRegistrii de uz general\n\nAcestia sunt :\n\n* eax * numit si \"accumulator\" * acesta este cel mai folosit in executarea operatiilor aritmetice (adunare, scadere, inmultire, impartire);\n* ebx * numit si \"base\" * acesta registru este folosit pentru adresarea indirecta a memoriei;\n* ecx * numit si \"count\" * acest registru este folosit mai ales in cadrul \"buclelor\" (in instructiunile repetitive * for/ while do/ do while/ repeat until);\n* edx * numit si \"data\" * retine anumite variabile, si este folosit impreuna cu eax in executarea operatiei \"div\" * impartire intreaga (avand rolul de a retine restul impartirii).\n\nDupa cum ati observat, fiecare registru general are o functie specifica, insa oricare din ei pot fi folositi si la operatii aritmetice/logice, adresare memorie sau ca si variabile.\n\nRegistrii precedati de prefixul \"e\" sunt \"pe 32 de biti\", deci pot fi tratati ca si variabile unsigned long/signed long (doubleword). Acestia pot fi folositi si ca registri pe 16 biti (word) sau pe 8 biti (byte) prin intermediul \"subregistrilor\" : ax, bx, cx, dx (reprezinta word-ul nesemnificativ = cel din dreapta)., ah, bh, ch, dh (byte-ul cel mai semnificativ al ax, bx, cx, dx), al, bl, cl, dl(registrii pe 8 biti).\n\n\nRegistrii de segment si index\n\nAcesti registri sunt folositi la adresarea memoriei.\nDe exemplu\nAvem variabila void *x;(x : pointer in pascal);\npentru modelul de memorie segmentata, in adresarea memoriei adresate de x se folosesc intructiunile (vezi \"Intructiunile de baza ale unui microprocesor 8086\") :\n\n\n\n// es:[di] va accesa adresa pointata de x;\n\nles di, x\n\n// se copiaza in ax primul word\n\n// de la adresa es:[di]\n\nmov ax, es:[di]\n\n// se copiaza in al cel de-al 3-lea byte\n\n// de la adresa es:[di]\n\nmov al, es:[di+2]\n\nParantezele drepte se refera la zona de memorie adresata de registru.\nExemplu :\n\n\"[esi]\" * se refera la valoarea aflata la adresa de memorie cu offset-ul esi, iar \"esi\" * se refera la valoarea stocata in registrul esi;\n\ndaca esi = 100 atunci [esi] * va reprezenta valoarea care se afla la adresa cu offset-ul 100, iar esi va reprezenta valoarea 100.\n\nVa sfatuiesc sa NU incercati sa modificati urmatorii registri : cs (care contine segmentul la care se afla incarcat codul executabilului, ss * contine segmentul de memorie in care se afla stiva sistemului).\n\n\n\nRegistrii speciali\n\nSunt folositi foarte rar in scrierea efectiva a programelor, deci nu veti accesa prea des acesti registri.De exemplu, ip (instruction pointer) care retine adresa (de fapt offset-ul) la care se afla instructiunea care urmeaza sa fie executata.\n\n\n\nFlagurile microprocesorului\n\nFlag-urile microprocesorului sunt asemanatoare unor variabile boolene. Cu ajutorul lor putem afla rezultatul unei comparatii sau daca o operatie a produs \"overflow\", etc. Aceste flag-uri nu pot fi accesate direct ca si registrii, ci testarea daca un flag este activat se face prin intermediul \"jump\"-urilor conditionate.(vezi instructiunea cmp).\n\nExemplu :\n\nFie ax = 1. Decrementarea lui ax cu 1 va duce la activarea flagului numit Zero-Flag.(rezultatul operatiei a fost 0).\n\nFie ax = 65535 (0xFFFF). Incrementarea lui ax cu 2 va duce la setarea flagului numit Overflow-Flag (rezultatul operatiei nu \"incape\" in 16 biti);\n\n\n\n\n\nInstructiunile de baza ale microprocesorului 8086 :\n\nSunt folosite urmatoarele prescurtari :\n\n* reg8/ reg16/ reg32 * se refera la registri pe 8/16/32 biti;\n* imm8/ imm16/ imm32 * se refera la valori imediate (constante);\n* mem8/ mem16/ mem32 * zona memorie de memorie sau variabile pe 8/16/32 biti;\n\nScriere/Citire memorie si registri\n\nInstructiunea MOV\n\nSintaxa\n\nmov dest, source // echivalenta cu dest = source\n\nVariante\n\nmov reg8/16/32, mem8/16/32\nmov reg8/16/32, reg8/16/32\nmov mem8/16/32, reg8/16/32\nmov reg8/16/32, imm8/16/32\nmov mem8/16/32, imm8/16/32\n\nDescriere\n\nInstructiunea copiaza o valoare dintr-o locatie in alta locatie. Aceasta locatie poate fi zona de memorie, variabila, registru. De retinut este ca nu exista variante ale instructiunii care copiaza direct dintr-o zona de memorie in alta.\n\nFlaguri afectate\n\nInstructiunea mov nu modifica nici un flag.\n\nRestrictii\n\nAmbii operanzi trebuie sa aiba aceeasi marime. De exemplu pentru ultima varianta a instructiunii mov trebuie specificata marimea zonei de memorie. Instructiunea \"mov [bx], 0\" nu este corecta deoarece compilatorul nu stie ce vrea sa faca instructiunea: sa copieze valoarea 0 in byte-ul, in word-ul sau in doubleword-ul de la adresa bx. Astfel variantele corecte sunt:\n\nmov byte ptr [bx], 0\n\nmov word ptr [bx], 0\n\nmov dword ptr [bx], 0\n\nExemplu\n\nmov ax, 3 // ax = 3\nmov bx, ax // bx = ax\n\n\n\nInstructiuni aritmetice\n\nInstructiunile ADD, SUB, INC, DEC\n\nSintaxa\n\nadd dest, source // echivalenta cu dest+=source\nsub dest, source // echivalenta cu dest-=source\ninc dest // echivalenta cu dest++\ndec dest // echivalenta cu dest*\n\n\n\nVariante\n\nadd(sub) reg8/16/32, mem8/16/32\nadd(sub) reg8/16/32, reg8/16/32\nadd(sub) mem8/16/32, reg8/16/32\nadd(sub) reg8/16/32, imm8/16/32\nadd(sub) mem8/16/32, imm8/16/32\n\nDescriere\n\nInstructiunea \"add\" este folosita pentru a aduna doua valori, \"sub\" pentru a scadea o valoare din alta, inc * incrementarea unei variabile, \"dec\" * decrementarea unei variabile (registru/memorie).\n\n\n\nFlaguri afectate\n\nFlagurile afectate de aceste instructiuni sunt :\n\ncarry flag - pentru \"signed overflow\"\n\noverflow flag - pentru overflow\n\nsign flag - activat daca rezultatul este negativ\n\nzero flag - activat daca rezultatul operatiei a fost 0\n\nparity flag - este setat in functie de paritatea rezultatului\n\n\n\nRestrictii\n\nDestinatia trebuie sa aiba aceeasi marime ca si sursa.\n\nExemplu\n\nmov ax, 3 // ax = 3\nadd bx, ax // bx = ax+3\n\nInstructiuni pe biti\n\nInstructiunile AND, TEST, OR, XOR, NOT\n\nSintaxa\n\nand dest, source // echivalenta cu dest&=source\n\ntest dest, source // dest & source\n\nor dest, source // echivalenta cu dest|=source\n\nxor dest, source // echivalenta cu dest^=source\n\nnot dest // ~dest\n\nVariante\n\nPentru \"and\", \"or\", \"test\", \"xor\" sunt ca si cele de la add. Pentru \"not\" avem doua variante :\n\nnot reg8/16/32\n\nnot mem\n\n\n\nDescriere\n\nExecuta operatiile pe biti corespunzatoare. Instructiunea test (non-destructive and) este asemanatoare lui and, dar nu afecteaza rezultatul ci doar flagurile.\n\n\n\nFlaguri afectate\n\nInstructiunea \"not\" nu afecteaza nici un flag.\n\nFlagurile afectate de celalalte instructiuni sunt :\n\ncarry, overflow - le dezactiveaza\n\nsign flag - este copiat bitul cel mai semnificativ din rezultat (semnul rezultatului, de fapt)\n\nzero flag - activat daca rezultatul operatiei a fost 0\n\nparity flag - este setat in functie de paritatea rezultatului\n\n\n\nRestrictii\n\nDestinatia trebuie sa aiba aceeasi marime ca si sursa.\nInstructinile OR/XOR/INC/DEC modifica flag-urile microprocesorului: Carry(numai ADD/SUB), Overflow, Zero, Parity.\n\nExemplu\n\nmov ax, 5 // ax = 3\ntest ax, 1 // daca (ax & 1)\njz @skip // daca ax este nu este impar sari la @skip\n// executa instructiuni\n@skip\nand bx, FFFEh // bx = bx & 0xFFFE (se sterge\n// bitul cel mai nesemnificativ)\n\n\n\nInstructiunile PUSH/POP\n\nDescriere\n\nAceste instructiuni sunt folosite pentru accesarea stivei sistemului. Instructiunea PUSH pune pe stiva sistemului o valoare, iar instructiunea POP extrage valoarea din varful stivei.\n\nSintaxa\n\npush val\n\npop val\n\nVariante\n\npush reg8/16/32\n\npop reg8/16/32\n\nExemplu\n\n@lp:\npush cx // salvam valoarea cx\n... // prelucreaza datele, se poate modifica cx\npop cx // scoate de pe stiva valoarea cx\ndec cx\njnz @lp // daca (cx != 0) atunci sari inapoi la @lp\n\nInstructiunea CMP\n\nDescriere\n\nCompara doua valori si seteaza flag-urile microprocesorului cu rezultatele compararii. De cele mai multe ori este folosita in combinatie cu jump-urile (vezi mai jos).\n\nSintaxa\n\ncmp val1, val2\n\nVariante\n\ncmp reg8/16/32, reg8/16/32\n\ncmp reg8/16/32, imm8/16/32\n\ncmp mem8/16/32, reg8/16/32\n\ncmp mem8/16/32, imm8/16/32\n\n\n\nJump-urile neconditionate (JMP) si jump-urile conditionate (JE, JNE, JB, JBE, JA, JAE, JZ, JNZ)\n\nAceste instructiuni sunt folosite pentru generarea instructiunilor If /while do /do while /repeat /for.Sunt asemanatoare instructiunii goto din C/Pascal.\nSintaxa : instructiune label\nJE * \"sare\" cu executia programului la label daca flag-ul equality este setat;\nJNE * \"sare\" cu executia programului la label daca flag-ul equality nu este setat;\nJB * \"sare\" cu executia programului la label daca flag-ul below este setat;\nJBE * \"sare\" cu executia programului la label daca flag-ul below sau flagul equality este setat;\nJA * \"sare\" cu executia programului la label daca flag-ul below nu este setat;\nJAE * \"sare\" cu executia programului la label daca flag-ul equality este setat sau flag-ul below nu este setat;\nJZ * \"sare\" cu executia programului la label daca flag-ul zero este setat;\nJNZ * \"sare\" cu executia programului la label daca flag-ul zero nu este setat;\nJMP * \"sare\" cu executia programului la label;\n\nExemplu :\n\nmov ax, 1\n@loop :\ninstr1\ninstr2\n*\ninc ax\n\n// compara ax cu valoarea 10\n\n// si seteaza flagurile\ncmp ax, 10\n\n// daca ax != 10 sari inapoi la @loop\njne @loop\n\nExemplul 2:\n\ninstr1\njmp @label1\ninstr2\ninstr3\n@label1 :\n\n\n\nIn ultimul exemplu instr2 si instr3 nu vor fi executate deoarece inaintea lor se afla instructiunea jump care face ca programul sa sara cu executia la instructiunea imediat urmatoare etichetei \"label1\".\n\n\n\nInstructiunea LOOP\n\nInstructiunea \"loop\" este folosita de obicei in transcrierea for-urilor si a buclelor.\n\nSintaxa\n\nloop label\n\nDescriere\n\nEchivalenta cu :\n\ndec ecx (sau dec cx)\njz label\n\nInstructiunea INT\n\nDescriere\n\nInstructiunea INT apealeaza o intrerupere.\nSintaxa\nINT nr_intrerupere (un numar cuprins intre 0 si 255);\n\nIntreruperile opresc programul din rulare, executa un anumit cod si apoi permit continuarea rularii programului. Cu ajutorul apelului intreruperilor aplicatia poate sa comunice cu sistemul de operare, si cu unele componente hardware ale calculatorului (mouse-ul, tastatura, imprimanta, etc). Fiecare intrerupere are asociat un numar.\nExemple de intreruperi :\n0x9 : intreruperea pentru tastatura;\n0x10 : intreruperea care ofera serviciile BIOS pentru accesul la placa video;\n0x21 : intreruperea sistemului de operare DOS;\n0x33 : intreruperea pentru mouse;\n\nIn DOS pentru initializarea mouse-ului se va apela\n\nfunctia numarul 0 a intreruperii 0x33 :\nasm\n{\nmov ax, 0\n\n// seteaza registrul ax cu valoarea 0 pentru ca\n\n// driverul ce gestioneaza intreruperea 0x33\n//sa stie ca trebuie sa initializeze mouse-ul\nint 0x33\n}\n\nPentru afisarea mouse-ului :\nasm\n{\nmov ax, 1\nint 0x33\n}\n\nPentru ascunderea cursorului de la mouse :\nasm\n{\nmov ax, 2\nint 0x33;\n}\n\n\n\n\n\nTranscrierea unor instructiuni C/PASCAL in asamblare\n\n\n\n* IF cond THEN instr\n\nExemplu : if (a==5) b=a; // a, b * integer\n\nmov ax, a\ncmp ax, 5\n\n// ne intrebam daca !cond\njnz @skip_if\nmov b, ax\n@skip_if :\n\n* IF cond THEN instr1 ELSE instr2\n\nExemplu : if (a==b) a-=b; else b-=a;\n\nTranscrierea in asamblare :\n\nmov ax, a\nmov bx, b\n\n// compara ax cu bx si seteaza flag-urile\n\ncmp ax, bx\n\nje @if_then\n\n// if (ax == bx) sari la @if_then\nsub b, ax\njmp @end_if :\n@if_then :\nsub a, bx\n@end_if :\n\n\n\n* DO { inst } WHILE\n\nExemplu :\n\nint i, a, n;\ni = 0;\na = 0;\ndo\n{\ni++;\na+=I;\n} while (i<=n);\n\n\n\nCodul in asamblare :\n\n// cx = 0, instructiunea xor cx, cx este\n\n// mai rapida decat mov cx, 0\nxor cx, cx\n\nxor ax, ax\nmov bx, n\n@while :\ninc cx\nadd ax, cx\ncmp cx, bx\njne @while\nmov a, ax\nmov I, cx\n\n\nSau folosind instructiunea loop (pornim invers) :\n\nmov cx, n\n\n@while:\nadd ax, cx\nloop @while\n\nIn codul de mai sus (prima varianta) puteti observa cateva mici optimizari : retinerea variabilelor in registri (accesul la registri este mult mai rapid decat la memorie), inlocuirea instructiunii mov reg, 0 cu xor reg, reg. Varianta \"xor\" este mai rapida (desi mov si xor \"teoretic\" au tot atatea ceasuri de procesor) deoarece instructiunea mov reg, 0 transcrisa in cod masina este mai \"lunga\" (are cu 2-4 bytes mai mult decat xor reg, reg). Aceeasi regula se aplica si in cazul \"or reg, reg\" in testarea daca valoarea unui registru este egala cu 0, intrucat instructiunea \"or\" modifica flagurile procesorului (ZeroFlag). O alta optimizare este folosirea registrului ax pentru calcule (in majoritatea cazurilor instructiunile care folosesc registrul (e)ax sunt mai rapide).\n\n\n\n\n\nProgram demonstrativ\n\nExemplu de functie in realizata in C/Asamblare (compilator folosit BC++ 3.1):\n\n// BSort.CPP\n#include <stdio.h>\n#include <conio.h>\n\nint a[20], n;\n\nvoid bsort()\n{\nasm {\nmov di,seg a\nmov es,di\nmov di,offset a\n// es:[di] inceputul vectorului\n// es - adresa segment\n// di - adresa offset\n};\n\ndo_while_not_ok :\nasm {\n// ok = 1;\nmov dx, 1\n// cx = n;\nmov cx, n\n// cx = n-1\ndec cx\n// ax = a[0]\nmov ax, es:[di]\n// punem di pe stiva\npush di\n}\ninner_for :\nasm {\n// bx = a[i-1]\nmov bx, ax\n// ne mutam pe noua pozitie in vector\nadd di, 2\n// ax = a[i]\nmov ax, es:[di]\n// comparam ax cu bx (a[i-1] cu a[i])\ncmp bx, ax\n// if (a[i-1] <= a[i]) don\'t swap\njbe if_not\n// interschimbam a[i-1] cu a[i]\nxchg bx, ax\n// le scriem in memorie\nmov es:[di], ax\nmov es:[di-2], bx\n// ok = 0\nxor dx, dx\n}\nif_not :\nasm {\n// cx--;\ndec cx\njnz inner_for\n// daca cx != 0 atunci continuam for-ul\npop di\n// compara dx cu 0\n// (mai rapid decat cmp dx, 0)\nor dx, dx\n// if (ok) executam inca odata while-ul\njz do_while_not_ok\n}\n}\n\nvoid citire()\n{\nprintf(\"Numarul de elemente : \");\nscanf(\"%d\", &n);\nfor (int i=0; i<n; i++)\n{\nprintf(\"a[%d] = \", i);\nscanf(\"%d\", &a[i]);\n}\n}\n\nvoid afis()\n{\nfor (int i=0; i<n; i++)\nprintf(\"%d \", a[i]);\n}\n\nint main()\n{\ncitire();\nbsort();\nafis();\nreturn 0;\n}\n\nVarianta Pascal + Asm (compilata cu BP 7.0):\n\nprogram b_sort;\n\nconst\nmax_N = 1000;\nn_tests = 100;\n\nvar\nN : Integer;\na, b : array [1..max_N] of Integer;\n\nprocedure citire;\nvar\nf : Text;\ni : Integer;\nbegin\nAssign(f, \'bsort.in\'); Reset(f);\nreadln(f, N);\nfor i := 1 to N do\nread(f, b[i]);\nClose(f)\nend;\n\nprocedure flip;\nvar\ni : Integer;\nbegin\nfor i:=1 to N do\na[i] := b[i];\nend;\n\nvar p : pointer;\n\nprocedure bsort; assembler;\nasm\n{ les <=> es = seg(p), di = offset(p) }\nles di, p\n@do_while_not_ok :\nmov dx, 1\nmov cx, N\ndec cx\nmov ax, es:[di]\npush di\n@inner_for :\nmov bx, ax\nadd di, 2\nmov ax, es:[di]\ncmp bx, ax\njbe @if_not\nxchg bx, ax\nmov es:[di], ax\nmov es:[di-2], bx\nxor dx, dx\n@if_not :\ndec cx\njnz @inner_for\npop di\nor dx, dx\njz @do_while_not_ok\nend;\n\nprocedure bsort2;\nvar\nok : Boolean;\ni, aux : Integer;\nbegin\nrepeat\nok := true;\nfor i := 1 to n-1 do\nif (a[i] > a[i+1]) then\nbegin\naux := a[i];\na[i] := a[i+1];\na[i+1] := aux;\nok := false;\nend;\nuntil ok;\nend;\n\nvar\ni : Integer;\nstarttick, endtick : LongInt;\ntime : Longint absolute $0000:$046C;\n\n{ timer pentru masurarea timpului }\nconst tickspersecond = 18.206;\n\nprocedure starttimer;\nbegin\nstarttick := time;\nend;\n\nfunction elapsedtime : real;\nbegin\nendtick := time;\nelapsedtime := (endtick - starttick)*\n(1 / tickspersecond);\nend;\n\nbegin\ncitire;\np := @a;\n\nstarttimer;\nfor i:=1 to n_tests do\nbegin\nflip;\nbsort;\nend;\nwriteln(n_tests, \' rulari ale bsort in asamblare\nau rulat in : \', elapsedtime : 6:3, \' secunde\');\n\nstarttimer;\nfor i:=1 to n_tests do\nbegin\nflip;\nbsort2;\nend;\nwriteln(n_tests, \' rulari ale bsort obisnuit\n\nau rulat in : \',\nelapsedtime : 6:3, \' secunde\');\nend.\n\nOutput program pascal (pe pc-ul meu: Duron 750 Mhz):\n100 rulari ale bsort in asamblare au rulat in : 1.263 secunde\n100 rulari ale bsort obisnuit au rulat in : 4.614 secunde\n\nDe precizat este ca nu am optimizat programul aproape deloc (am transcris codul din pascal in asm). Cu optimizari \"hardcore\" se pot obtine timpi mult mai buni. Diferenta dintre varianta asm si varianta high level language este mai mica pe compilatoarele mai noi, cum ar fi GCC sau FreePascal deoarece acestea stiu genera un cod mai optimizat. Totusi, nici un compilator nu poate bate creierul uman.\n\n\n\n\n\nLinkuri\n\n[1]http://www.arl.wustl.edu/~lockwood/class/cs306/books/\n\nartofasm/toc.html\n\n\n\nCartea \"The Art of Assembly Language Programming\". Este detaliata. Foarte buna atat pentru incepatori cat si pentru avansati.\n\n[2]http://www.goof.com/pcg/doc/pentopt.txt\n\n\n\nUn tutorial bun pentru optimizarea programelor in asamblare pentru procesoarele din familia Pentium. Tutorialul este pentru avansati.\n\n[3]http://www.techtutorials.info/assembly.html\n\n\n\nMai multe tutoriale despre assembly language.\n\nDoua cuvinte conclusive...\n\nAcest articol trateaza \"bazele\" programarii in asamblare, dupa cum ii zice numele este doar o introducere. Pentru a sti sa programezi in asm, trebuie invatate mult mai multe lucruri. Scopul articolului este de a starni interesul cititorilor si de a le oferi o imagine asupra acestui limbaj. Cei ce doresc sa invete mai multe despre assembly language sunt invitati sa citeasca cartile / tutorialele din sectiunea linkuri.\n\nReferences\n\nVisible links\n1. http://www.arl.wustl.edu/%7elockwood/class/cs306/books/artofasm/toc.html\n2. http://www.goof.com/pcg/doc/pentopt.txt\n3. http://www.techtutorials.info/assembly.html\n==Include(page=\"template/raw\")==\n\nLimbajul de asamblare : avantaje si dezavantaje in folosirea lui\n\n\n\nDesi este unul dintre cele mai vechi limbaje de programare, limbajul de asamblare este incorporat si *n cele mai noi compilatoare cum ar fi Visual C++ si Delphi. Codul de asamblare este foarte apropiat de codul executabil al programelor, asamblorul avand rolul de a codifica instructiunile din limbaj de asamblare in cod masina.\n\nIn prezent, limbajul de asamblare este din ce in ce mai putin folosit in scrierea programelor, deoarece compilatoarele de ultima generatie au functiile cele mai folosite de programatori deja scrise si optimizate in limbaj de asamblare (gen memmove, memset / fillchar, etc.) incluse in unit-uri si biblioteci. Bineinteles, daca se doreste atingerea unor timpi de executie foarte mici, folosirea limbajului de asamblare este preferabila (cand avem algoritmul de complexitate optima).\n\nAvantaje ale limbajului de asamblare\n\n* Viteza foarte mare the executie a programelor (unele programe scrise si optimizate in asamblare au viteza de executie pana la 5-10 de ori mai mare decat cele scrise in C sau Pascal);\n* Marimea codului executabil este foarte mica;\n* Ajuta utilizatorul sa inteleaga mai bine cum functioneaza microprocesorul si sa scrie programe eficiente si in High Level Languages.\n\n\n\nDezavantaje ale limbajului de asamblare\n\n* nu este portabil; un program scris pentru calculatoare IBM PC nu va rula pe un Apple Macintosh (difera unele instructiuni);\n* un program in asamblare este mai greu de scris si ia mai mult timp decat un program scris in Pascal sau C;\n* un program scris in asamblare este mai greu de depanat;\n\nMajoritatea compilatoarelor din prezent permit programatorului sa scrie anumite parti de cod sau subprograme in asamblare, astfel incat programatorul sa poata scrie in asamblare doar partea din program care se executa de cele mai multe ori, programul ruland astfel mult mai rapid. Sunt si compilatoare dedicate exclusiv limbajului de asamblare, cum ar fi TASM - Turbo Assembler (il gasiti in directorul BP/Bin), MASM - Microsoft Assembler, etc.\n\nPentru a scrie o secventa de limbaj de asamblare intr-un program C se foloseste cuvantul rezervat asm :\n\nasm { instructiuni in asamblare };\n\niar in pascal :\n\nasm\ncod asamblare\nend.\n\n\n\n\n\nNotiuni de baza ale limbajului de asamblare\n\nRegistrii\n\nLimbajul de asamblare este foarte apropiat de codul executabil, deci pentru ca programatorul sa fie capabil sa scrie codul in asamblare trebuie sa cunoasca modul in care functioneaza microprocesorul si modul in care acesta executa instructiunile.\n\nToate operatiile aritmetice/logice/acces la memorie se fac prin intermediul registrilor. Registrii microprocesorului sunt asemanatori variabilelor (pot fi initializati cu anumite valori, se pot efectua operatii asupra lor, pot fi accesati (cititi/modificati)).\nRegistrii microprocesorului sunt clasificati in mai multe categorii :\n\n* registri de uz general : eax, ebx, ecx, edx si subregistrii lor;\n* registri segment : cs (code segment), ds (data segment), es (extra segment), ss (stack segment) - sunt folositi pentru adresarea memoriei in cazul modelului de memorie segmentat\n* registrii index : esi, edi (source index, destination index);\n* registri speciali : ebp, esp, ip;\n\nRegistrii de uz general sunt folositi in executia operatiilor aritmetice si logice. Registrii de segment si cei index sunt folositi in adresarea memoriei, iar cei speciali sunt folositi de microprocesor si S.O. pentru rularea programelor.\n\n\n\nRegistrii de uz general\n\nAcestia sunt :\n\n* eax * numit si \"accumulator\" * acesta este cel mai folosit in executarea operatiilor aritmetice (adunare, scadere, inmultire, impartire);\n* ebx * numit si \"base\" * acesta registru este folosit pentru adresarea indirecta a memoriei;\n* ecx * numit si \"count\" * acest registru este folosit mai ales in cadrul \"buclelor\" (in instructiunile repetitive * for/ while do/ do while/ repeat until);\n* edx * numit si \"data\" * retine anumite variabile, si este folosit impreuna cu eax in executarea operatiei \"div\" * impartire intreaga (avand rolul de a retine restul impartirii).\n\nDupa cum ati observat, fiecare registru general are o functie specifica, insa oricare din ei pot fi folositi si la operatii aritmetice/logice, adresare memorie sau ca si variabile.\n\nRegistrii precedati de prefixul \"e\" sunt \"pe 32 de biti\", deci pot fi tratati ca si variabile unsigned long/signed long (doubleword). Acestia pot fi folositi si ca registri pe 16 biti (word) sau pe 8 biti (byte) prin intermediul \"subregistrilor\" : ax, bx, cx, dx (reprezinta word-ul nesemnificativ = cel din dreapta)., ah, bh, ch, dh (byte-ul cel mai semnificativ al ax, bx, cx, dx), al, bl, cl, dl(registrii pe 8 biti).\n\n\nRegistrii de segment si index\n\nAcesti registri sunt folositi la adresarea memoriei.\nDe exemplu\nAvem variabila void *x;(x : pointer in pascal);\npentru modelul de memorie segmentata, in adresarea memoriei adresate de x se folosesc intructiunile (vezi \"Intructiunile de baza ale unui microprocesor 8086\") :\n\n\n\n// es:[di] va accesa adresa pointata de x;\n\nles di, x\n\n// se copiaza in ax primul word\n\n// de la adresa es:[di]\n\nmov ax, es:[di]\n\n// se copiaza in al cel de-al 3-lea byte\n\n// de la adresa es:[di]\n\nmov al, es:[di+2]\n\nParantezele drepte se refera la zona de memorie adresata de registru.\nExemplu :\n\n\"[esi]\" * se refera la valoarea aflata la adresa de memorie cu offset-ul esi, iar \"esi\" * se refera la valoarea stocata in registrul esi;\n\ndaca esi = 100 atunci [esi] * va reprezenta valoarea care se afla la adresa cu offset-ul 100, iar esi va reprezenta valoarea 100.\n\nVa sfatuiesc sa NU incercati sa modificati urmatorii registri : cs (care contine segmentul la care se afla incarcat codul executabilului, ss * contine segmentul de memorie in care se afla stiva sistemului).\n\n\n\nRegistrii speciali\n\nSunt folositi foarte rar in scrierea efectiva a programelor, deci nu veti accesa prea des acesti registri.De exemplu, ip (instruction pointer) care retine adresa (de fapt offset-ul) la care se afla instructiunea care urmeaza sa fie executata.\n\n\n\nFlagurile microprocesorului\n\nFlag-urile microprocesorului sunt asemanatoare unor variabile boolene. Cu ajutorul lor putem afla rezultatul unei comparatii sau daca o operatie a produs \"overflow\", etc. Aceste flag-uri nu pot fi accesate direct ca si registrii, ci testarea daca un flag este activat se face prin intermediul \"jump\"-urilor conditionate.(vezi instructiunea cmp).\n\nExemplu :\n\nFie ax = 1. Decrementarea lui ax cu 1 va duce la activarea flagului numit Zero-Flag.(rezultatul operatiei a fost 0).\n\nFie ax = 65535 (0xFFFF). Incrementarea lui ax cu 2 va duce la setarea flagului numit Overflow-Flag (rezultatul operatiei nu \"incape\" in 16 biti);\n\n\n\n\n\nInstructiunile de baza ale microprocesorului 8086 :\n\nSunt folosite urmatoarele prescurtari :\n\n* reg8/ reg16/ reg32 * se refera la registri pe 8/16/32 biti;\n* imm8/ imm16/ imm32 * se refera la valori imediate (constante);\n* mem8/ mem16/ mem32 * zona memorie de memorie sau variabile pe 8/16/32 biti;\n\nScriere/Citire memorie si registri\n\nInstructiunea MOV\n\nSintaxa\n\nmov dest, source // echivalenta cu dest = source\n\nVariante\n\nmov reg8/16/32, mem8/16/32\nmov reg8/16/32, reg8/16/32\nmov mem8/16/32, reg8/16/32\nmov reg8/16/32, imm8/16/32\nmov mem8/16/32, imm8/16/32\n\nDescriere\n\nInstructiunea copiaza o valoare dintr-o locatie in alta locatie. Aceasta locatie poate fi zona de memorie, variabila, registru. De retinut este ca nu exista variante ale instructiunii care copiaza direct dintr-o zona de memorie in alta.\n\nFlaguri afectate\n\nInstructiunea mov nu modifica nici un flag.\n\nRestrictii\n\nAmbii operanzi trebuie sa aiba aceeasi marime. De exemplu pentru ultima varianta a instructiunii mov trebuie specificata marimea zonei de memorie. Instructiunea \"mov [bx], 0\" nu este corecta deoarece compilatorul nu stie ce vrea sa faca instructiunea: sa copieze valoarea 0 in byte-ul, in word-ul sau in doubleword-ul de la adresa bx. Astfel variantele corecte sunt:\n\nmov byte ptr [bx], 0\n\nmov word ptr [bx], 0\n\nmov dword ptr [bx], 0\n\nExemplu\n\nmov ax, 3 // ax = 3\nmov bx, ax // bx = ax\n\n\n\nInstructiuni aritmetice\n\nInstructiunile ADD, SUB, INC, DEC\n\nSintaxa\n\nadd dest, source // echivalenta cu dest+=source\nsub dest, source // echivalenta cu dest-=source\ninc dest // echivalenta cu dest++\ndec dest // echivalenta cu dest*\n\n\n\nVariante\n\nadd(sub) reg8/16/32, mem8/16/32\nadd(sub) reg8/16/32, reg8/16/32\nadd(sub) mem8/16/32, reg8/16/32\nadd(sub) reg8/16/32, imm8/16/32\nadd(sub) mem8/16/32, imm8/16/32\n\nDescriere\n\nInstructiunea \"add\" este folosita pentru a aduna doua valori, \"sub\" pentru a scadea o valoare din alta, inc * incrementarea unei variabile, \"dec\" * decrementarea unei variabile (registru/memorie).\n\n\n\nFlaguri afectate\n\nFlagurile afectate de aceste instructiuni sunt :\n\ncarry flag - pentru \"signed overflow\"\n\noverflow flag - pentru overflow\n\nsign flag - activat daca rezultatul este negativ\n\nzero flag - activat daca rezultatul operatiei a fost 0\n\nparity flag - este setat in functie de paritatea rezultatului\n\n\n\nRestrictii\n\nDestinatia trebuie sa aiba aceeasi marime ca si sursa.\n\nExemplu\n\nmov ax, 3 // ax = 3\nadd bx, ax // bx = ax+3\n\nInstructiuni pe biti\n\nInstructiunile AND, TEST, OR, XOR, NOT\n\nSintaxa\n\nand dest, source // echivalenta cu dest&=source\n\ntest dest, source // dest & source\n\nor dest, source // echivalenta cu dest|=source\n\nxor dest, source // echivalenta cu dest^=source\n\nnot dest // ~dest\n\nVariante\n\nPentru \"and\", \"or\", \"test\", \"xor\" sunt ca si cele de la add. Pentru \"not\" avem doua variante :\n\nnot reg8/16/32\n\nnot mem\n\n\n\nDescriere\n\nExecuta operatiile pe biti corespunzatoare. Instructiunea test (non-destructive and) este asemanatoare lui and, dar nu afecteaza rezultatul ci doar flagurile.\n\n\n\nFlaguri afectate\n\nInstructiunea \"not\" nu afecteaza nici un flag.\n\nFlagurile afectate de celalalte instructiuni sunt :\n\ncarry, overflow - le dezactiveaza\n\nsign flag - este copiat bitul cel mai semnificativ din rezultat (semnul rezultatului, de fapt)\n\nzero flag - activat daca rezultatul operatiei a fost 0\n\nparity flag - este setat in functie de paritatea rezultatului\n\n\n\nRestrictii\n\nDestinatia trebuie sa aiba aceeasi marime ca si sursa.\nInstructinile OR/XOR/INC/DEC modifica flag-urile microprocesorului: Carry(numai ADD/SUB), Overflow, Zero, Parity.\n\nExemplu\n\nmov ax, 5 // ax = 3\ntest ax, 1 // daca (ax & 1)\njz @skip // daca ax este nu este impar sari la @skip\n// executa instructiuni\n@skip\nand bx, FFFEh // bx = bx & 0xFFFE (se sterge\n// bitul cel mai nesemnificativ)\n\n\n\nInstructiunile PUSH/POP\n\nDescriere\n\nAceste instructiuni sunt folosite pentru accesarea stivei sistemului. Instructiunea PUSH pune pe stiva sistemului o valoare, iar instructiunea POP extrage valoarea din varful stivei.\n\nSintaxa\n\npush val\n\npop val\n\nVariante\n\npush reg8/16/32\n\npop reg8/16/32\n\nExemplu\n\n@lp:\npush cx // salvam valoarea cx\n... // prelucreaza datele, se poate modifica cx\npop cx // scoate de pe stiva valoarea cx\ndec cx\njnz @lp // daca (cx != 0) atunci sari inapoi la @lp\n\nInstructiunea CMP\n\nDescriere\n\nCompara doua valori si seteaza flag-urile microprocesorului cu rezultatele compararii. De cele mai multe ori este folosita in combinatie cu jump-urile (vezi mai jos).\n\nSintaxa\n\ncmp val1, val2\n\nVariante\n\ncmp reg8/16/32, reg8/16/32\n\ncmp reg8/16/32, imm8/16/32\n\ncmp mem8/16/32, reg8/16/32\n\ncmp mem8/16/32, imm8/16/32\n\n\n\nJump-urile neconditionate (JMP) si jump-urile conditionate (JE, JNE, JB, JBE, JA, JAE, JZ, JNZ)\n\nAceste instructiuni sunt folosite pentru generarea instructiunilor If /while do /do while /repeat /for.Sunt asemanatoare instructiunii goto din C/Pascal.\nSintaxa : instructiune label\nJE * \"sare\" cu executia programului la label daca flag-ul equality este setat;\nJNE * \"sare\" cu executia programului la label daca flag-ul equality nu este setat;\nJB * \"sare\" cu executia programului la label daca flag-ul below este setat;\nJBE * \"sare\" cu executia programului la label daca flag-ul below sau flagul equality este setat;\nJA * \"sare\" cu executia programului la label daca flag-ul below nu este setat;\nJAE * \"sare\" cu executia programului la label daca flag-ul equality este setat sau flag-ul below nu este setat;\nJZ * \"sare\" cu executia programului la label daca flag-ul zero este setat;\nJNZ * \"sare\" cu executia programului la label daca flag-ul zero nu este setat;\nJMP * \"sare\" cu executia programului la label;\n\nExemplu :\n\nmov ax, 1\n@loop :\ninstr1\ninstr2\n*\ninc ax\n\n// compara ax cu valoarea 10\n\n// si seteaza flagurile\ncmp ax, 10\n\n// daca ax != 10 sari inapoi la @loop\njne @loop\n\nExemplul 2:\n\ninstr1\njmp @label1\ninstr2\ninstr3\n@label1 :\n\n\n\nIn ultimul exemplu instr2 si instr3 nu vor fi executate deoarece inaintea lor se afla instructiunea jump care face ca programul sa sara cu executia la instructiunea imediat urmatoare etichetei \"label1\".\n\n\n\nInstructiunea LOOP\n\nInstructiunea \"loop\" este folosita de obicei in transcrierea for-urilor si a buclelor.\n\nSintaxa\n\nloop label\n\nDescriere\n\nEchivalenta cu :\n\ndec ecx (sau dec cx)\njz label\n\nInstructiunea INT\n\nDescriere\n\nInstructiunea INT apealeaza o intrerupere.\nSintaxa\nINT nr_intrerupere (un numar cuprins intre 0 si 255);\n\nIntreruperile opresc programul din rulare, executa un anumit cod si apoi permit continuarea rularii programului. Cu ajutorul apelului intreruperilor aplicatia poate sa comunice cu sistemul de operare, si cu unele componente hardware ale calculatorului (mouse-ul, tastatura, imprimanta, etc). Fiecare intrerupere are asociat un numar.\nExemple de intreruperi :\n0x9 : intreruperea pentru tastatura;\n0x10 : intreruperea care ofera serviciile BIOS pentru accesul la placa video;\n0x21 : intreruperea sistemului de operare DOS;\n0x33 : intreruperea pentru mouse;\n\nIn DOS pentru initializarea mouse-ului se va apela\n\nfunctia numarul 0 a intreruperii 0x33 :\nasm\n{\nmov ax, 0\n\n// seteaza registrul ax cu valoarea 0 pentru ca\n\n// driverul ce gestioneaza intreruperea 0x33\n//sa stie ca trebuie sa initializeze mouse-ul\nint 0x33\n}\n\nPentru afisarea mouse-ului :\nasm\n{\nmov ax, 1\nint 0x33\n}\n\nPentru ascunderea cursorului de la mouse :\nasm\n{\nmov ax, 2\nint 0x33;\n}\n\n\n\n\n\nTranscrierea unor instructiuni C/PASCAL in asamblare\n\n\n\n* IF cond THEN instr\n\nExemplu : if (a==5) b=a; // a, b * integer\n\nmov ax, a\ncmp ax, 5\n\n// ne intrebam daca !cond\njnz @skip_if\nmov b, ax\n@skip_if :\n\n* IF cond THEN instr1 ELSE instr2\n\nExemplu : if (a==b) a-=b; else b-=a;\n\nTranscrierea in asamblare :\n\nmov ax, a\nmov bx, b\n\n// compara ax cu bx si seteaza flag-urile\n\ncmp ax, bx\n\nje @if_then\n\n// if (ax == bx) sari la @if_then\nsub b, ax\njmp @end_if :\n@if_then :\nsub a, bx\n@end_if :\n\n\n\n* DO { inst } WHILE\n\nExemplu :\n\nint i, a, n;\ni = 0;\na = 0;\ndo\n{\ni++;\na+=I;\n} while (i<=n);\n\n\n\nCodul in asamblare :\n\n// cx = 0, instructiunea xor cx, cx este\n\n// mai rapida decat mov cx, 0\nxor cx, cx\n\nxor ax, ax\nmov bx, n\n@while :\ninc cx\nadd ax, cx\ncmp cx, bx\njne @while\nmov a, ax\nmov I, cx\n\n\nSau folosind instructiunea loop (pornim invers) :\n\nmov cx, n\n\n@while:\nadd ax, cx\nloop @while\n\nIn codul de mai sus (prima varianta) puteti observa cateva mici optimizari : retinerea variabilelor in registri (accesul la registri este mult mai rapid decat la memorie), inlocuirea instructiunii mov reg, 0 cu xor reg, reg. Varianta \"xor\" este mai rapida (desi mov si xor \"teoretic\" au tot atatea ceasuri de procesor) deoarece instructiunea mov reg, 0 transcrisa in cod masina este mai \"lunga\" (are cu 2-4 bytes mai mult decat xor reg, reg). Aceeasi regula se aplica si in cazul \"or reg, reg\" in testarea daca valoarea unui registru este egala cu 0, intrucat instructiunea \"or\" modifica flagurile procesorului (ZeroFlag). O alta optimizare este folosirea registrului ax pentru calcule (in majoritatea cazurilor instructiunile care folosesc registrul (e)ax sunt mai rapide).\n\n\n\n\n\nProgram demonstrativ\n\nExemplu de functie in realizata in C/Asamblare (compilator folosit BC++ 3.1):\n\n// BSort.CPP\n#include <stdio.h>\n#include <conio.h>\n\nint a[20], n;\n\nvoid bsort()\n{\nasm {\nmov di,seg a\nmov es,di\nmov di,offset a\n// es:[di] inceputul vectorului\n// es - adresa segment\n// di - adresa offset\n};\n\ndo_while_not_ok :\nasm {\n// ok = 1;\nmov dx, 1\n// cx = n;\nmov cx, n\n// cx = n-1\ndec cx\n// ax = a[0]\nmov ax, es:[di]\n// punem di pe stiva\npush di\n}\ninner_for :\nasm {\n// bx = a[i-1]\nmov bx, ax\n// ne mutam pe noua pozitie in vector\nadd di, 2\n// ax = a[i]\nmov ax, es:[di]\n// comparam ax cu bx (a[i-1] cu a[i])\ncmp bx, ax\n// if (a[i-1] <= a[i]) don\'t swap\njbe if_not\n// interschimbam a[i-1] cu a[i]\nxchg bx, ax\n// le scriem in memorie\nmov es:[di], ax\nmov es:[di-2], bx\n// ok = 0\nxor dx, dx\n}\nif_not :\nasm {\n// cx--;\ndec cx\njnz inner_for\n// daca cx != 0 atunci continuam for-ul\npop di\n// compara dx cu 0\n// (mai rapid decat cmp dx, 0)\nor dx, dx\n// if (ok) executam inca odata while-ul\njz do_while_not_ok\n}\n}\n\nvoid citire()\n{\nprintf(\"Numarul de elemente : \");\nscanf(\"%d\", &n);\nfor (int i=0; i<n; i++)\n{\nprintf(\"a[%d] = \", i);\nscanf(\"%d\", &a[i]);\n}\n}\n\nvoid afis()\n{\nfor (int i=0; i<n; i++)\nprintf(\"%d \", a[i]);\n}\n\nint main()\n{\ncitire();\nbsort();\nafis();\nreturn 0;\n}\n\nVarianta Pascal + Asm (compilata cu BP 7.0):\n\nprogram b_sort;\n\nconst\nmax_N = 1000;\nn_tests = 100;\n\nvar\nN : Integer;\na, b : array [1..max_N] of Integer;\n\nprocedure citire;\nvar\nf : Text;\ni : Integer;\nbegin\nAssign(f, \'bsort.in\'); Reset(f);\nreadln(f, N);\nfor i := 1 to N do\nread(f, b[i]);\nClose(f)\nend;\n\nprocedure flip;\nvar\ni : Integer;\nbegin\nfor i:=1 to N do\na[i] := b[i];\nend;\n\nvar p : pointer;\n\nprocedure bsort; assembler;\nasm\n{ les <=> es = seg(p), di = offset(p) }\nles di, p\n@do_while_not_ok :\nmov dx, 1\nmov cx, N\ndec cx\nmov ax, es:[di]\npush di\n@inner_for :\nmov bx, ax\nadd di, 2\nmov ax, es:[di]\ncmp bx, ax\njbe @if_not\nxchg bx, ax\nmov es:[di], ax\nmov es:[di-2], bx\nxor dx, dx\n@if_not :\ndec cx\njnz @inner_for\npop di\nor dx, dx\njz @do_while_not_ok\nend;\n\nprocedure bsort2;\nvar\nok : Boolean;\ni, aux : Integer;\nbegin\nrepeat\nok := true;\nfor i := 1 to n-1 do\nif (a[i] > a[i+1]) then\nbegin\naux := a[i];\na[i] := a[i+1];\na[i+1] := aux;\nok := false;\nend;\nuntil ok;\nend;\n\nvar\ni : Integer;\nstarttick, endtick : LongInt;\ntime : Longint absolute $0000:$046C;\n\n{ timer pentru masurarea timpului }\nconst tickspersecond = 18.206;\n\nprocedure starttimer;\nbegin\nstarttick := time;\nend;\n\nfunction elapsedtime : real;\nbegin\nendtick := time;\nelapsedtime := (endtick - starttick)*\n(1 / tickspersecond);\nend;\n\nbegin\ncitire;\np := @a;\n\nstarttimer;\nfor i:=1 to n_tests do\nbegin\nflip;\nbsort;\nend;\nwriteln(n_tests, \' rulari ale bsort in asamblare\nau rulat in : \', elapsedtime : 6:3, \' secunde\');\n\nstarttimer;\nfor i:=1 to n_tests do\nbegin\nflip;\nbsort2;\nend;\nwriteln(n_tests, \' rulari ale bsort obisnuit\n\nau rulat in : \',\nelapsedtime : 6:3, \' secunde\');\nend.\n\nOutput program pascal (pe pc-ul meu: Duron 750 Mhz):\n100 rulari ale bsort in asamblare au rulat in : 1.263 secunde\n100 rulari ale bsort obisnuit au rulat in : 4.614 secunde\n\nDe precizat este ca nu am optimizat programul aproape deloc (am transcris codul din pascal in asm). Cu optimizari \"hardcore\" se pot obtine timpi mult mai buni. Diferenta dintre varianta asm si varianta high level language este mai mica pe compilatoarele mai noi, cum ar fi GCC sau FreePascal deoarece acestea stiu genera un cod mai optimizat. Totusi, nici un compilator nu poate bate creierul uman.\n\n\n\n\n\nLinkuri\n\n[1]http://www.arl.wustl.edu/~lockwood/class/cs306/books/\n\nartofasm/toc.html\n\n\n\nCartea \"The Art of Assembly Language Programming\". Este detaliata. Foarte buna atat pentru incepatori cat si pentru avansati.\n\n[2]http://www.goof.com/pcg/doc/pentopt.txt\n\n\n\nUn tutorial bun pentru optimizarea programelor in asamblare pentru procesoarele din familia Pentium. Tutorialul este pentru avansati.\n\n[3]http://www.techtutorials.info/assembly.html\n\n\n\nMai multe tutoriale despre assembly language.\n\nDoua cuvinte conclusive...\n\nAcest articol trateaza \"bazele\" programarii in asamblare, dupa cum ii zice numele este doar o introducere. Pentru a sti sa programezi in asm, trebuie invatate mult mai multe lucruri. Scopul articolului este de a starni interesul cititorilor si de a le oferi o imagine asupra acestui limbaj. Cei ce doresc sa invete mai multe despre assembly language sunt invitati sa citeasca cartile / tutorialele din sectiunea linkuri.\n\nReferences\n\nVisible links\n1. http://www.arl.wustl.edu/%7elockwood/class/cs306/books/artofasm/toc.html\n2. http://www.goof.com/pcg/doc/pentopt.txt\n3. http://www.techtutorials.info/assembly.html\n\n',1142,''),('home','info-arena 2.0','2006-11-22 02:45:30','==html|<img src=\"http://msig.info/web2v2/info-arena+2.0BETA.png\" alt=\"info-arena 2.0 BETA\" />==\r\n\r\nh1. Anunturi:\r\n\r\nAm inceput o pagina de \"documentatie\":docs, toata lumea e invitata.\r\n\r\nh2. Starting points:\r\n\r\n* *{\'Quick TODO list\':QuickTodo}*\r\n* \'Documentatie\':Docs. Chestia asta trebuia facuta mai de mult.\r\n* \'Sandbox\':Sandbox. Ca sa nu mai frecam prima pagina.\r\n* \'Development site\':http://hackers.devnet.ro/ si \'bug tracker\':http://hackers.devnet.ro/report/3.\r\n* \'Arhiva de probleme\':round/arhiva\r\n* \'Lista rundelor\':round_list\r\n* \'Lista problemelor\':task_list\r\n\r\nh2. Mai trebuie de prasit:\r\n\r\n* \"Articole\":Articles\r\n* \"News\":Stiri\r\n* {\"wiki-ul vechi\":http://infoarena.devnet.ro/wiki/index.php/Main_Page}. Pentru asta ar cam trebui scris cod.\r\n\r\nh2. Ultimele 3 stiri\r\n\r\n==News(pager_style=\"none\" display_entries=\"3\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':news',1,'public'),('home','info-arena 2.0','2006-11-22 02:54:48','==html|<img src=\"http://msig.info/web2v2/info-arena+2.0BETA.png\" alt=\"info-arena 2.0 BETA\" />==\r\n\r\nh2. Anunturi:\r\n\r\nAm inceput o pagina de \"documentatie\":docs, toata lumea e invitata.\r\n\r\nh2. Starting points:\r\n\r\n* *{\'Quick TODO list\':QuickTodo}*\r\n* \'Documentatie\':Docs. Chestia asta trebuia facuta mai de mult.\r\n* \'Sandbox\':Sandbox. Ca sa nu mai frecam prima pagina.\r\n* \'Development site\':http://hackers.devnet.ro/ si \'bug tracker\':http://hackers.devnet.ro/report/3.\r\n* \'Arhiva de probleme\':round/arhiva\r\n* \'Lista rundelor\':round_list\r\n* \'Lista problemelor\':task_list\r\n\r\nh2. Mai trebuie de prasit:\r\n\r\n* \"Articole\":Articles\r\n* \"News\":News\r\n* {\"wiki-ul vechi\":http://infoarena.devnet.ro/wiki/index.php/Main_Page}. Pentru asta ar cam trebui scris cod.\r\n\r\nh2. Ultimele 3 stiri\r\n\r\n==News(pager_style=\"none\" display_entries=\"3\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':news',1,'public'),('home','infoarena 2.0','2006-11-28 16:23:32','h1. infoarena 2.0\r\n\r\n!>home?smith_miners.jpg 40%!\r\n\r\ninfoarena este un wiki. Cu unele exceptii, utilizatorii pot edita paginile de pe site sau pot creea unele noi. \'Incearca si tu!\':sandbox\r\n\r\nh2. Feedback\r\n\r\nAjuta-ne sa facem o infoarena ca _Soarele sfant de pe cer_ :) Asteptam bug reports, sugestii, intrebari pe forum. Iata niste topic-uri de feedback:\r\n\r\n==SmfTopics(board_id=\"33\")==\r\n\r\nh2. Puncte de pornire\r\n\r\n* \'Documentatie\':documentatie. Cum se foloseste site-ul infoarena?\r\n* \'Sandbox\':sandbox. Testeaza wiki-ul infoarena!\r\n* \'preONI 2006\':preoni-2006\r\n* \'Pagina administratori\':admin\r\n\r\nh2. Pentru programatori\r\n\r\n\r\nInfoarena imbratiseaza mentalitatea open-source: codul nostru sursa este \'liber disponibil\':http://hackers.devnet.ro/browser iar dezvoltarea se face \'public\':http://hackers.devnet.ro.\r\nDaca stii PHP / tehnologii web / webdesign sau vrei sa inveti alaturi de noi, intra pe \"pagina de development\":documentatie/development.\r\n\r\nh2. Ultimele stiri\r\n\r\n==News(pager_style=\"none\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':stiri',13,'protected'),('sandbox','Sandbox','2006-11-18 14:38:21','\r\na {$[i..j] x [k..k]$} (deci suma elementelor din banda {$[i..j]$} ce sunt pe coloana {$k$}).\r\n\r\nPentru a determina subsecventa de suma maxima a sirului {$C$}, vom folosi vectorul {$sum[k] = C[k] + C[k-1] + ... + C[1{@]@}$}. Astfel suma elementelor $C[k..l]$ este egala cu {$sum[l] - sum[k - 1]$}. Pentru a determina subsecventa de suma maxima ce se termina in $l$ trebuie sa gasim cea mai mica $sum[k - 1]$ pentru a maximiza expresia {$sum[l] - sum[k - 1]$}. Astfel obtinem urmatorul cod:\r\n== code(c) |\r\nint min_sum = 0;\r\nint best = - infinit;\r\nfor (int k = 0; k < m; k++) {\r\n    if (best < sum[l] - min_sum)\r\n        best = sum[l] - min_sum;\r\n    if (sum[l] < min_sum) min_sum = sum[l];\r\n}\r\nreturn best;\r\n==\r\nAcest algoritm are complexitatea {$O(n)$}.\r\n\r\nAstfel algoritmul calculeaza in $O(n)$ valoarea optima pentru $O(n^2^)$ zone, deci in total avem un algoritm ce consuma $O(n^2^)$ memorie si are complexitatea $O(n^3^)$ ca timp.\r\n\r\np(pre). \r\n     [I{~0~}]    [I{~N&nbsp;&nbsp;~}]\r\nM^N^ * [I{~1~}] = [I{~N+1~}]\r\n     [I{~2~}]    [I{~N+2~}]\r\n\r\n\r\n== Gallery(page=\"%\" file=\"%.jpg\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.gif\") ==\r\n\r\n== Gallery(page=\"%\" file=\"%.png\") ==\r\n',0,'public'),('arhiva','Arhiva de probleme','2006-11-22 22:11:45','h1. Arhiva de problema\r\n\r\nArhiva de probleme info-arena contine peste 300 de probleme. Vezi \'clasamentul\':clasament-arhiva.\r\n\r\nh2. Lista de probleme (fixme: sorting?)\r\n\r\np. &nbsp;\r\n\r\n==Tasks(round_id=\"arhiva\") ==',1142,'protected'),('home','info-arena 2.0','2006-11-22 22:07:32','==html|<img src=\"http://msig.info/web2v2/info-arena+2.0BETA.png\" alt=\"info-arena 2.0 BETA\" />==\r\n\r\nh2. Anunturi:\r\n\r\n* \'Pagina de modificari\':changes. Prasiti ca va tai.\r\n* Am inceput o pagina de \"documentatie\":documentatie, toata lumea e invitata.\r\n* Se pot muta pagini!\r\n* WTF people:\r\n** ==user(user=\"muioc\" type=\"tiny\")==\r\n** ==user(user=\"pulasan\" type=\"tiny\")==\r\n** ==user(user=\"cacatu\" type=\"tiny\")==\r\n** ==user(user=\"fucker\" type=\"tiny\")==\r\n** ==user(user=\"mada_fucku\" type=\"tiny\")==\r\n\r\nh2. Starting points:\r\n\r\n* *{\'Quick TODO list\':quick-todo}*\r\n* \'Modificari recente\':changes, inclusiv \'rss\':changes?format=rss.\r\n* \'Documentatie\':documentatie. Chestia asta trebuia facuta mai de mult.\r\n* \'Sandbox\':sandbox. Ca sa nu mai frecam prima pagina.\r\n* \'Development site\':http://hackers.devnet.ro/ si \'bug tracker\':http://hackers.devnet.ro/report/3.\r\n* \'Arhiva de probleme\':round/arhiva\r\n* \'Lista rundelor\':lista-rundelor\r\n\r\nh2. Mai trebuie de prasit:\r\n\r\n* \"Articole\":Articles\r\n* \"News\":News\r\n* {\"wiki-ul vechi\":http://infoarena.devnet.ro/wiki/index.php/Main_Page}. Pentru asta ar cam trebui scris cod.\r\n\r\nh2. Ultimele 3 stiri\r\n\r\n==News(pager_style=\"none\" display_entries=\"3\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':news',1142,'public'),('articole','Articole','2006-11-22 23:09:01','h1. Articole\r\n\r\n* Algoritmi\r\n** Automate\r\n*** \'Automate finite si KMP\':Automate_finite_si_KMP\r\n** Elementari\r\n*** \'Aplicatii ale cautarii binare\':Aplicatii_ale_cautarii_binare\r\n** Grafuri\r\n*** \'Al K-lea drum minim\':Al_K_lea_drum_minim\r\n*** \'Ciclu hamiltonian in graf dens\':Ciclu_hamiltonian_in_graf_dens\r\n** Metode de programare\r\n* Competitii\r\n** \'Solutiile oficiale pentru Concursul &quot;de incalzire&quot;\':Solutiile_oficiale_pentru_Concursul_de_incalzire\r\n** \'Concursul Agora - Etapa Finala - Solutii\':Concursul_Agora_Etapa_Finala_Solutii\r\n** \'USACO decembrie 2004, divizia GOLD - idei de solutii\':USACO_decembrie_2004_divizia_GOLD_idei_de_solutii\r\n** \'Doua probleme de la runda 6 a concursului Algoritmus\':Doua_probleme_de_la_runda_6_a_concursului_Algoritmus\r\n** \'preONI 2005 runda #1 - solutii\':preONI_2005_runda_1_solutii\r\n** \'Usaco ianuarie 2005, divizia GOLD\':Usaco_ianuarie_2005_divizia_GOLD\r\n** \'preONI 2005 runda #2 - solutii\':preONI_2005_runda_2_solutii\r\n** \'preONI 2005 runda #3 - solutii\':preONI_2005_runda_3_solutii\r\n** \'USACO oct 2005, divizia GOLD\':USACO_oct_2005_divizia_GOLD\r\n** \'Solutii preONI 2006 - Runda 1\':Solutii_preONI_2006_Runda_1\r\n** \'USACO nov 2005, divizia GOLD\':USACO_nov_2005_divizia_GOLD\r\n** \'Solutii preONI 2006 - Runda a 2-a\':Solutii_preONI_2006_Runda_a_2_a\r\n** \'USACO dec 2005, divizia GOLD\':USACO_dec_2005_divizia_GOLD\r\n** \'Solutii preONI 2006 - Runda a 3-a\':Solutii_preONI_2006_Runda_a_3_a\r\n** \'Solutii preONI 2006, Runda a 4-a\':Solutii_preONI_2006_Runda_a_4_a\r\n** \'Solutii preONI 2006, Runda finala\':Solutii_preONI_2006_Runda_finala\r\n** \'Solutii - Summer Challenge Unu\':Solutii_Summer_Challenge_Unu\r\n** \'Solutii - Summer Challenge Doi\':Solutii_Summer_Challenge_Doi\r\n** \'Solutii - Summer Challenge Trei\':Solutii_Summer_Challenge_Trei\r\n** \'Solutii Autumn WarmUp 2006\':Solutii_Autumn_WarmUp_2006\r\n* Limbaje\r\n** \'STL\':STL\r\n** \'Introducere in asamblare\':Introducere_in_asamblare\r\n** {\'12 ponturi pentru programatorii C/C++\':12_ponturi_pentru_programatorii_CC}\r\n** \'Multe &quot;smenuri&quot; de programare in C/C++... si nu numai!\':Multe_smenuri_de_programare_in_CC_si_nu_numai\r\n* Matematica\r\n** Combinatorica\r\n** Geometrie\r\n** Teoria numerelor\r\n*** \'Algoritmul lui Euclid\':Algoritmul_lui_Euclid\r\n*** \'Ciurul lui Erathostene\':Ciurul_lui_Erathostene\r\n* Structuri de date\r\n** Arbori\r\n*** \'LCA: Lowest common ancestor\':LCA_Lowest_common_ancestor\r\n** Liste\r\n*** \'Skiplists\':Skiplists\r\n** Tabele de dispersie\r\n*** \'Hashing\':Hashing\r\n* Diverse\r\n** \'F.A.Q. Pregatire bacalaureat 2005\':FAQ_Pregatire_bacalaureat_2005\r\n** \'DJGPP - instalarea de la A la Z\':DJGPP_instalarea_de_la_A_la_Z\r\n** \'The Monty Hall Problem\':The_Monty_Hall_Problem\r\n\r\n\r\n',961,'public'),('template/newround','%round_id%','2006-11-12 18:54:16','== include(page=\"template/roundheader\" round_id=\"%round_id%\") ==\r\n\r\n== include(page=\"template/todo\") ==\r\n\r\nPoveste ...\r\n\r\nProgram ...\r\n\r\n== include(page=\"template/roundfooter\" round_id=\"%round_id%\") ==\r\n',1142,'public'),('articole','Articole','2006-11-23 07:28:39','h1. Articole\r\n\r\ntable(layout). |_. Algoritmi |_. Structuri de date |\r\n|* \'Automate finite si KMP\':Automate_finite_si_KMP\r\n* \'Aplicatii ale cautarii binare\':Aplicatii_ale_cautarii_binare\r\n* \'Al K-lea drum minim\':Al_K_lea_drum_minim\r\n* \'Ciclu hamiltonian in graf dens\':Ciclu_hamiltonian_in_graf_dens\r\n|* \'LCA: Lowest common ancestor\':LCA_Lowest_common_ancestor\r\n* \'Skiplists\':Skiplists\r\n* \'Hashing\':Hashing |\r\n|_. Limbaje |_. Matematica|\r\n|* \'STL\':STL\r\n* \'Introducere in asamblare\':Introducere_in_asamblare\r\n* {\'12 ponturi pentru programatorii C/C++\':12_ponturi_pentru_programatorii_CC}\r\n* \'Multe &quot;smenuri&quot; de programare in C/C++... si nu numai!\':Multe_smenuri_de_programare_in_CC_si_nu_numai\r\n|* \'Algoritmul lui Euclid\':Algoritmul_lui_Euclid\r\n* \'Ciurul lui Erathostene\':Ciurul_lui_Erathostene|\r\n|_. Despre infoarena |_. Diverse |\r\n|* \'Despre infoarena\':Despre\r\n* \'Asociatia infoarena\':Asociatia-infoarena\r\n|* \'F.A.Q. Pregatire bacalaureat 2005\':FAQ_Pregatire_bacalaureat_2005\r\n* \'DJGPP - instalarea de la A la Z\':DJGPP_instalarea_de_la_A_la_Z\r\n* \'The Monty Hall Problem\':The_Monty_Hall_Problem |\r\n\r\n|\\2_. Competitii |\r\n|\\2. * \'Solutiile oficiale pentru Concursul &quot;de incalzire&quot;\':Solutiile_oficiale_pentru_Concursul_de_incalzire\r\n* \'Concursul Agora - Etapa Finala - Solutii\':Concursul_Agora_Etapa_Finala_Solutii\r\n* \'USACO decembrie 2004, divizia GOLD - idei de solutii\':USACO_decembrie_2004_divizia_GOLD_idei_de_solutii\r\n* \'Doua probleme de la runda 6 a concursului Algoritmus\':Doua_probleme_de_la_runda_6_a_concursului_Algoritmus\r\n* \'preONI 2005 runda #1 - solutii\':preONI_2005_runda_1_solutii\r\n* \'Usaco ianuarie 2005, divizia GOLD\':Usaco_ianuarie_2005_divizia_GOLD\r\n* \'preONI 2005 runda #2 - solutii\':preONI_2005_runda_2_solutii\r\n* \'preONI 2005 runda #3 - solutii\':preONI_2005_runda_3_solutii\r\n* \'USACO oct 2005, divizia GOLD\':USACO_oct_2005_divizia_GOLD\r\n* \'Solutii preONI 2006 - Runda 1\':Solutii_preONI_2006_Runda_1\r\n* \'USACO nov 2005, divizia GOLD\':USACO_nov_2005_divizia_GOLD\r\n* \'Solutii preONI 2006 - Runda a 2-a\':Solutii_preONI_2006_Runda_a_2_a\r\n* \'USACO dec 2005, divizia GOLD\':USACO_dec_2005_divizia_GOLD\r\n* \'Solutii preONI 2006 - Runda a 3-a\':Solutii_preONI_2006_Runda_a_3_a\r\n* \'Solutii preONI 2006, Runda a 4-a\':Solutii_preONI_2006_Runda_a_4_a\r\n* \'Solutii preONI 2006, Runda finala\':Solutii_preONI_2006_Runda_finala\r\n* \'Solutii - Summer Challenge Unu\':Solutii_Summer_Challenge_Unu\r\n* \'Solutii - Summer Challenge Doi\':Solutii_Summer_Challenge_Doi\r\n* \'Solutii - Summer Challenge Trei\':Solutii_Summer_Challenge_Trei\r\n* \'Solutii Autumn WarmUp 2006\':Solutii_Autumn_WarmUp_2006|\r\n',13,'public'),('al-k-lea-drum-minim','Al K-lea drum minim','2006-11-22 02:16:41','h1. Al K-lea drum minim\r\n\r\n(Categoria _Grafuri_, autor(i) _Crestez Leonard_)\r\n\r\nExista un numar mare de algoritmi pentru a calcula cel mai scurt drum intre $2$ noduri intr-un graf, dar chiar si al {$2$}-lea cel mai scurt drum este o extindere non-triviala. Pentru a afla al {$k$}-lea drum minim se foloseste un algoritm total diferit fata de cei pentru drum minim. Algoritmul este dificil de implementat, iar sursa rezultata este de obicei voluminoasa, asa ca acest algoritm nu prea intervine in problemele de concurs. Am considerat totusi ca este destul de interesant, si merita prezentat.\r\n\r\nO nota importanta este ca nu se determina drumul cu al {$k$}-lea cost. Doua drumuri se considera diferita daca au noduri diferite, nu neaparat si cost diferit. Astfel, daca exista $5$ drumuri distincte de cost minim, oricare dintre ele poate fi solutie pentru al {$4$}-lea sau al {$5$}-lea drum minim. Astfel, aceasta problema are de fapt mai multe solutii posibile.\r\n\r\nExista $2$ cazuri pentru aceasta problema, iar algoritmul prezentat necesita mici modificari pentru a se adapta, dar ideea de baza ramane aceeasi. Cele doua cazuri sunt daca drumul trebuie neaparat sa fie elementar sau nu. Cazul in care se accepta doar drumuri elementare este mai restrictiv, si, astfel, un pic mai dificil.\r\n\r\nh2. Mod de functionare\r\n\r\nDaca pentru drumul minim intre $2$ noduri de obicei se calculeaza drumul minim dintre primul nod si celelalte noduri din graf, pentru a afla al {$k$}-lea drum minim se calculeaza toate primele $k$ drumuri minime, in ordine. Un pas al algortimului consta in aflarea celul de-al {$k$}-lea drum minim cand primele $k$ sunt cunoscute. Drumul minim este folosit de mai multe ori in algoritm, pentru a intelege acest algoritm este necesara o anumita familiaritate cu algoritmul lui Dijkstra.\r\n\r\nDrumurile minime pana la $k-1$ sunt stocate compactate intr-un arbore de drumuri. Fiecarui nod din acel arbore ii corespunde un nod din graf, dar nu si invers, un nod din graf poate aparea de mai multe ori in arbore. Radacina arborelui corespunde nodului de start, iar toate frunzele arborelui corespund nodului de final, iar drumurile de la radacina catre frunze reprezinta fiecare cate un drum minim. Vezi in figura cum se compacteaza drumurile ({$1, 7, 4, 5$}), ({$1, 7, 3, 5$}), ({$1, 2, 4, 5$}) si ({$1, 2, 6, 4, 5$}). Drumurile sunt primele $4$ drumuri din graful desenat mai sus si luat drept exemplu.\r\n\r\n!http://www.infoarena.ro/Al_K_lea_drum_minim?action=download&file=kshortest_graph.png!\r\n!http://www.infoarena.ro/Al_K_lea_drum_minim?action=download&file=kshortest_tree.png!\r\n\r\nAl {$k$}-lea drum minim trebuie sa corespund pana intr-un anumit punct cu un drum aflat deja in arbore, chiar daca punctul acela este de fapt nodul de start. Pentru a gasi urmatorul drum minim, incercam sa \"deviem\" din fiecare nod din arbore. Un drum de deviatie pentru un anume nod $X$ este un drum identic cu drumul de la radacina pana la nodul {$X$}, care apoi continua (deviaza) pe cel mai scurt drum pana la destinatie care nu a fost inca luat in cosiderare. Spre exemplu pentru nodul $4$ din drumul ({$1, 2, 4, 5$}) putem sa deviem din $4$ prin ({$7, 3, 5$}), formand drumul ({$1, 2, 4, 7, 3, 5$}). Este intuitiv ca, la fiecare pas, pentru fiecare nod din arbore este interesant doar cel mai scurt drum de deviatie.\r\n\r\nAlgoritmul mentine o multime, eventual ca un heap, de deviatii. Se tine pentru fiecare drum de deviatie nodul din care deviaza si lungimea drumului. La fiecare pas extragem drumul de deviatie minim si reconstituim drumul. Sa zicem ca drumul scos din heap este ({$a{~1~} a{~2~} ... a{~d~}, a{~d+1~} ... a{~n~}$}), unde $a{~d~}$ este nodul de unde s-a facut deviatia. Introducem acest drum in arborele de drumuri, si pentru fiecare nod de la $a{~d~}$ la $a{~n-1~}$ calculam deviatia minima si o introducem in heap. Pentru restul nodurilor este evident ca deviatia minima nu se modifica.\r\n\r\nAlgoritmul odata inteles este relativ logic. Al {$k$}-lea drum minim trebuie sa coincida cu unul dintre cele $k-1$ drumuri deja existente pana intr-un anumit punct, dupa care \"ia un viraj\" nevizitat si continua cel mai scurt drumul inca neparcurs.\r\n\r\nDupa cum am zis mai sus, algoritmul are $2$ variante, daca este necesar ca drumurile sa fie elementare sau nu. Pentru cele $2$ variante se modifica modul in care se calculeaza deviatia minima dintr-un nod. Cazul cel mai simplu este atunci cand nu este necesar ca drumurile sa fie elementare. Pentru nodul $X$ din care trebuie sa deviem, vom lua cel mai scurt drum care inca nu este in arbore. Putem sa calculam de dinainte un arbore de drumuri inversat, de la toate nodurile la destinatie, si sa luam minimul de la nodurile adiacente care NU sunt printre copii in arbore. Pentru arborele din desen, daca ar fi sa deviem din ({$1, 2$}) am putea lua in considerare doar nodul {$1$}.\r\n\r\nDaca trebuie sa luam in considerare doar drumurile elementare, algoritmul simplu de mai sus da erori. Spre exemplu, daca ar fi sa deviem din ({$1, 7$}) in desen, drumul optim ar fi prin {$1$}, adica ({$1, 7, 1, 7, 4, 5$}), care drum nu este elementar. Pentru a scapa de drumurile elementare, este nevoie sa marcam nodurile de la radacina pana la deviatie ca \"ocupate\" si sa rulam un algoritm de drum minim pana la destinatie. Acest lucru creste foarte mult complexitatea in timp si in implementare.\r\n\r\nh2. Exemplu\r\n\r\nAlgoritmul prezentat este destul de complex, asa ca vom detalia rularea algoritmului pe graful din desen. Vom incerca sa calculam toate cele mai scurte $5$ drumuri elementare intre nodurile $1$ si {$5$}. Punem si conditia ca drumurile sa fie elementare (cazul mai dificil).\r\n\r\n* Primul drum minim este ({$1, 7, 4, 5$}), de lungime {$9$}.\r\n* Incercam sa deviem din {$1$}. Drumul minim de la $1$ la $5$ care nu trece imediat prin $7$ este ({$1, 2, 4, 5$}), cu cost {$10$}.\r\n* Incercam sa deviem din {$7$}. Drumul minim de la $7$ la $5$ care nu trece imediat prin $4$ este ({$7, 3, 5$}), cu cost {$10$}. Atentie, adaugam si costul de la $1$ la {$7$}.\r\n* Incercam sa deviem din {$4$}. Nu exista alt drum de la {$4$} la {$5$}. Ar putea fi drumul ({$4, 7, 3, 5$}), dar nu ar fi elementar, deoarece avem prefixul ({$1, 7$}), noduri pe care le-am marcat blocate.\r\n* Din $5$ nu are sens sa deviem, asa ca..\r\n* Al doilea drum minim este ({$1, 2, 4, 5$}), de lungime {$10$}.\r\n* Incercam sa deviem din {$1$}, dar nu exista drum de la $1$ la $5$ care sa nu o ia imediat nici prin $2$ si nici prin {$7$}.\r\n* Incercam sa deviem din {$2$}. Drumul minim de la $2$ la $5$ care nu trece imediat prin $4$ este ({$2, 6, 4, 5$}), cu cost {$10$}. Atentie, drumul trece prin {$4$}, dar nu imediat.\r\n* Incercam sa deviam din {$4$}. Drumul minim de la $4$ la $5$ care nu trece imediat prin $5$ este ({$4, 7, 3, 5$}), cu cost {$15$}. Acest drum nu a fost valid mai inainte, dar acum prefixul lui $4$ este ({$1, 2$}), asa ca drumul e valid.\r\n* Al treilea drum minim este ({$1, 7, 3, 5$}), tot de lungime {$10$}. Al doilea si al treilea drum minim sunt interschimbabile.\r\n* Acest drum a fost derivat din {$7$}, asa ca nu trebie incercam sa derivam din {$1$}.\r\n* Incercam sa deviem din {$7$}, dar nu exista drum de la $7$ la $5$ care sa nu treaca imediat nici prin $3$ nici prin {$4$}. Ar fi ({$7, 1, 2, 4, 5$}), dar avem $1$ ca prefix si marcat blocat. Astfel, evitam un drum neelementar.\r\n* Incercam sa deviem din {$3$}, fara succes(si fara explicatii kilometrice.).\r\n* Al patrulea drum minim este ({$1, 2, 6, 4, 5$}), de lungime {$11$}.\r\n* Incercam sa deviem din {$2$}, dar fara succes.\r\n* Incercam sa deviem din {$6$}, dar tot fara succes.\r\n* Incercam sa deviam din {$4$}. Drumul minim de la $4$ la $5$ care nu trece imediat prin $5$ este ({$4, 7, 3, 5$}), cu cost {$16$}. Noi am mai gasit odata acest drum, dar de data asta e cu un alt prefix, si alt cost. Drumul complet este ({$1, 2, 6, 4, 7, 3, 5$}), nu ({$1, 2, 4, 7, 3, 5$}).\r\n* Al cincilea drum minim este ({$1, 2, 4, 7, 3, 5$}), de lungime {$15$}.\r\n* Astfel se termina exemplul nostru. Puteti sa incercati, nu mai exista deviatii posibile. Al {$6$}-lea si ultimul drum este ({$1, 2, 6, 4, 7, 3, 5$}) , care se intample sa fie si cel mai lung drum, si hamiltonian.\r\n\r\nh2. Analiza complexitatii\r\n\r\nComplexitatea algoritmului este diferita in cele $2$ variante. In ambele cazuri putem considera la lugimea fiecarui drum este de {$O(n)$}, si ca heap-ul contine $O(k * n)$ valori. Luam cazul cel mai defavorabil, cu graf complet, si consideram ca un algoritm de drumuri minime necesita timp {$O(n * n)$}. Astfel, daca nu este nevoie ca drumurile sa fie elementare:\r\n\r\n* Precalculam drumurile de la orice nod la destinatie, {$O(n * n)$}.\r\n* La fiecare dintre cei k pasi.\r\n** Extragem din heap, $O(log(k * n))$\r\n** Reconstituim drumul, $O(n)$\r\n** Pentru fiecare dintre cele maxim $n$ noduri din drum:\r\n*** Vedem cel mai scurt drum de continuare, $O(n)$\r\n*** Il adaugam in heap, $O(log(k * n))$\r\n\r\nComplexitatea ajunge astfel la {$O(k * n * (n + log(k * n)))$}. Trebuie avut in vedere ca in general drumurile minime vor avea noduri relativ putine, asa ca algorimtul e mai rapid decat pare. Daca punem conditia ca drumurile determinate sa fie elementare, complexitatea creste:\r\n\r\n* La fiecare dintre cei $k$ pasi.\r\n** Extragem din heap, $O(log(k * n))$\r\n** Reconstituim drumul, $O(n * n)$ (il calculam iarasi)\r\n** Blocam nodurile de la start pana la nodul de deviatie, $O(n)$\r\n** Pentru fiecare dintre cele maxim $n$ noduri din drum:\r\n*** Vedem cel mai scurt drum de continuare, $O(n * n)$\r\n*** Il adaugam in heap, $O(log(k * n))$\r\n\r\nComplexitatea ajunge acum la {$O(k * n * (n * n + log(k * n)))$}, aproximativ {$O(k * n^3^)$}. Iarasi, algoritmul se comporta mai bine in practica decat pare in complexitate.\r\n\r\nh2. Observatii, indicatii, completari\r\n\r\nAlgoritmul poate fi mai incet sau mai rapid. Se poate folosi ceva mai simplu de implementat in loc de heap, sau un algoritm de drumuri minime mai evoluat. Daca va intrebati daca algoritmul poate fi folosit pentru a determina un drum hamiltonian, raspunsul este da, dar asta necesita determinarea tuturor drumurile lor dintre $2$ muchii, care este exponential in functie de {$n$}.\r\n\r\nDaca sunteti interesati si, bineinteles, daca \"va tine\", incercati se rezolvati problema \"SGU 145\":http://acm.sgu.ru/problem.php?contest=0&problem=145 , de unde a pornit de fapt acest articol. Se cere cazul cel dificil, cu drumuri elementare.\r\n\r\n',1,'public'),('articole','Articole','2006-11-23 07:33:49','h1. Articole\r\n\r\ntable(layout). |_. Algoritmi |_. Structuri de date |\r\n|* \'Automate finite si KMP\':Automate_finite_si_KMP\r\n* \'Aplicatii ale cautarii binare\':Aplicatii_ale_cautarii_binare\r\n* \'Al K-lea drum minim\':Al_K_lea_drum_minim\r\n* \'Ciclu hamiltonian in graf dens\':Ciclu_hamiltonian_in_graf_dens\r\n|* \'LCA: Lowest common ancestor\':LCA_Lowest_common_ancestor\r\n* \'Skiplists\':Skiplists\r\n* \'Hashing\':Hashing |\r\n|_. Limbaje |_. Matematica|\r\n|* \'STL\':STL\r\n* \'Introducere in asamblare\':Introducere_in_asamblare\r\n* {\'12 ponturi pentru programatorii C/C++\':12_ponturi_pentru_programatorii_CC}\r\n* \'Multe &quot;smenuri&quot; de programare in C/C++... si nu numai!\':Multe_smenuri_de_programare_in_CC_si_nu_numai\r\n|* \'Algoritmul lui Euclid\':Algoritmul_lui_Euclid\r\n* \'Ciurul lui Erathostene\':Ciurul_lui_Erathostene|\r\n|_. Despre infoarena |_. Diverse |\r\n|* \'Despre infoarena\':Despre\r\n* \'Asociatia infoarena\':Asociatia-infoarena\r\n|* \'F.A.Q. Pregatire bacalaureat 2005\':FAQ_Pregatire_bacalaureat_2005\r\n* \'DJGPP - instalarea de la A la Z\':DJGPP_instalarea_de_la_A_la_Z\r\n* \'The Monty Hall Problem\':The_Monty_Hall_Problem |\r\n|\\2_. Competitii |\r\n|* \'preONI 2005 runda #1 - solutii\':preONI_2005_runda_1_solutii\r\n* \'preONI 2005 runda #2 - solutii\':preONI_2005_runda_2_solutii\r\n* \'preONI 2005 runda #3 - solutii\':preONI_2005_runda_3_solutii\r\n* \'Solutii preONI 2006 - Runda 1\':Solutii_preONI_2006_Runda_1\r\n* \'Solutii preONI 2006 - Runda a 2-a\':Solutii_preONI_2006_Runda_a_2_a\r\n* \'Solutii preONI 2006 - Runda a 3-a\':Solutii_preONI_2006_Runda_a_3_a\r\n* \'Solutii preONI 2006, Runda a 4-a\':Solutii_preONI_2006_Runda_a_4_a\r\n* \'Solutii preONI 2006, Runda finala\':Solutii_preONI_2006_Runda_finala\r\n* \'Solutii - Summer Challenge Unu\':Solutii_Summer_Challenge_Unu\r\n* \'Solutii - Summer Challenge Doi\':Solutii_Summer_Challenge_Doi\r\n* \'Solutii - Summer Challenge Trei\':Solutii_Summer_Challenge_Trei\r\n* \'Solutii Autumn WarmUp 2006\':Solutii_Autumn_WarmUp_2006\r\n|* \'Solutiile oficiale pentru Concursul &quot;de incalzire&quot;\':Solutiile_oficiale_pentru_Concursul_de_incalzire\r\n* \'Concursul Agora - Etapa Finala - Solutii\':Concursul_Agora_Etapa_Finala_Solutii\r\n* \'Doua probleme de la runda 6 a concursului Algoritmus\':Doua_probleme_de_la_runda_6_a_concursului_Algoritmus\r\n* \'USACO decembrie 2004, divizia GOLD - idei de solutii\':USACO_decembrie_2004_divizia_GOLD_idei_de_solutii\r\n* \'Usaco ianuarie 2005, divizia GOLD\':Usaco_ianuarie_2005_divizia_GOLD\r\n* \'USACO oct 2005, divizia GOLD\':USACO_oct_2005_divizia_GOLD\r\n* \'USACO nov 2005, divizia GOLD\':USACO_nov_2005_divizia_GOLD\r\n* \'USACO dec 2005, divizia GOLD\':USACO_dec_2005_divizia_GOLD |',13,'public'),('articole','Articole','2006-11-23 07:50:06','h1. Articole\r\n\r\ntable(layout). |_. Algoritmi |_. Structuri de date |\r\n| * !>Al_K_lea_drum_minim?kshortest_tree.png 40%! \'Automate finite si KMP\':Automate_finite_si_KMP\r\n* \'Aplicatii ale cautarii binare\':Aplicatii_ale_cautarii_binare\r\n* \'Al K-lea drum minim\':Al_K_lea_drum_minim\r\n* \'Ciclu hamiltonian in graf dens\':Ciclu_hamiltonian_in_graf_dens\r\n|* !>LCA_Lowest_common_ancestor?euler.jpg 40%! \'LCA: Lowest common ancestor\':LCA_Lowest_common_ancestor\r\n* \'Skiplists\':Skiplists\r\n* \'Hashing\':Hashing |\r\n|_. Limbaje |_. Matematica|\r\n|* \'STL\':STL\r\n* \'Introducere in asamblare\':Introducere_in_asamblare\r\n* {\'12 ponturi pentru programatorii C/C++\':12_ponturi_pentru_programatorii_CC}\r\n* \'Multe &quot;smenuri&quot; de programare in C/C++... si nu numai!\':Multe_smenuri_de_programare_in_CC_si_nu_numai\r\n|* \'Algoritmul lui Euclid\':Algoritmul_lui_Euclid\r\n* \'Ciurul lui Erathostene\':Ciurul_lui_Erathostene|\r\n|_. Despre infoarena |_. Diverse |\r\n|* \'Despre infoarena\':Despre\r\n* \'Asociatia infoarena\':Asociatia-infoarena\r\n|* \'F.A.Q. Pregatire bacalaureat 2005\':FAQ_Pregatire_bacalaureat_2005\r\n* \'DJGPP - instalarea de la A la Z\':DJGPP_instalarea_de_la_A_la_Z\r\n* \'The Monty Hall Problem\':The_Monty_Hall_Problem |\r\n|\\2_. Solutii (oficiale) la diverse competitii |\r\n|* \'preONI 2005 runda #1 - solutii\':preONI_2005_runda_1_solutii\r\n* \'preONI 2005 runda #2 - solutii\':preONI_2005_runda_2_solutii\r\n* \'preONI 2005 runda #3 - solutii\':preONI_2005_runda_3_solutii\r\n* \'Solutii preONI 2006 - Runda 1\':Solutii_preONI_2006_Runda_1\r\n* \'Solutii preONI 2006 - Runda a 2-a\':Solutii_preONI_2006_Runda_a_2_a\r\n* \'Solutii preONI 2006 - Runda a 3-a\':Solutii_preONI_2006_Runda_a_3_a\r\n* \'Solutii preONI 2006, Runda a 4-a\':Solutii_preONI_2006_Runda_a_4_a\r\n* \'Solutii preONI 2006, Runda finala\':Solutii_preONI_2006_Runda_finala\r\n* \'Solutii - Summer Challenge Unu\':Solutii_Summer_Challenge_Unu\r\n* \'Solutii - Summer Challenge Doi\':Solutii_Summer_Challenge_Doi\r\n* \'Solutii - Summer Challenge Trei\':Solutii_Summer_Challenge_Trei\r\n* \'Solutii Autumn WarmUp 2006\':Solutii_Autumn_WarmUp_2006\r\n|* \'Solutiile oficiale pentru Concursul &quot;de incalzire&quot;\':Solutiile_oficiale_pentru_Concursul_de_incalzire\r\n* \'Concursul Agora - Etapa Finala - Solutii\':Concursul_Agora_Etapa_Finala_Solutii\r\n* \'Doua probleme de la runda 6 a concursului Algoritmus\':Doua_probleme_de_la_runda_6_a_concursului_Algoritmus\r\n* \'USACO decembrie 2004, divizia GOLD - idei de solutii\':USACO_decembrie_2004_divizia_GOLD_idei_de_solutii\r\n* \'Usaco ianuarie 2005, divizia GOLD\':Usaco_ianuarie_2005_divizia_GOLD\r\n* \'USACO oct 2005, divizia GOLD\':USACO_oct_2005_divizia_GOLD\r\n* \'USACO nov 2005, divizia GOLD\':USACO_nov_2005_divizia_GOLD\r\n* \'USACO dec 2005, divizia GOLD\':USACO_dec_2005_divizia_GOLD |',13,'public'),('articole','Articole','2006-11-23 07:52:13','h1. Articole\r\n\r\ntable(layout). |_. Algoritmi |_. Structuri de date |\r\n| * !>Al_K_lea_drum_minim?kshortest_tree.png 40%! \'Automate finite si KMP\':Automate_finite_si_KMP\r\n* \'Aplicatii ale cautarii binare\':Aplicatii_ale_cautarii_binare\r\n* \'Al K-lea drum minim\':Al_K_lea_drum_minim\r\n* \'Ciclu hamiltonian in graf dens\':Ciclu_hamiltonian_in_graf_dens\r\n|* !>LCA_Lowest_common_ancestor?euler.jpg 40%! \'LCA: Lowest common ancestor\':LCA_Lowest_common_ancestor\r\n* \'Skiplists\':Skiplists\r\n* \'Hashing\':Hashing |\r\n|_. Limbaje |_. Matematica|\r\n|* \'STL\':STL\r\n* \'Introducere in asamblare\':Introducere_in_asamblare\r\n* {\'12 ponturi pentru programatorii C/C++\':12_ponturi_pentru_programatorii_CC}\r\n* \'Multe &quot;smenuri&quot; de programare in C/C++... si nu numai!\':Multe_smenuri_de_programare_in_CC_si_nu_numai\r\n|* \'Algoritmul lui Euclid\':Algoritmul_lui_Euclid\r\n* \'Ciurul lui Erathostene\':Ciurul_lui_Erathostene|\r\n|_. Despre infoarena |_. Diverse |\r\n|* \'Despre infoarena\':Despre\r\n* \'Asociatia infoarena\':Asociatia-infoarena\r\n|* \'F.A.Q. Pregatire bacalaureat 2005\':FAQ_Pregatire_bacalaureat_2005\r\n* \'DJGPP - instalarea de la A la Z\':DJGPP_instalarea_de_la_A_la_Z\r\n* \'The Monty Hall Problem\':The_Monty_Hall_Problem |\r\n|\\2_. Solutii (oficiale) la diverse competitii |\r\n|* !>articole?preoni2006.gif 50%! \'preONI 2005 runda #1 - solutii\':preONI_2005_runda_1_solutii\r\n* \'preONI 2005 runda #2 - solutii\':preONI_2005_runda_2_solutii\r\n* \'preONI 2005 runda #3 - solutii\':preONI_2005_runda_3_solutii\r\n* \'Solutii preONI 2006 - Runda 1\':Solutii_preONI_2006_Runda_1\r\n* \'Solutii preONI 2006 - Runda a 2-a\':Solutii_preONI_2006_Runda_a_2_a\r\n* \'Solutii preONI 2006 - Runda a 3-a\':Solutii_preONI_2006_Runda_a_3_a\r\n* \'Solutii preONI 2006, Runda a 4-a\':Solutii_preONI_2006_Runda_a_4_a\r\n* \'Solutii preONI 2006, Runda finala\':Solutii_preONI_2006_Runda_finala\r\n* \'Solutii - Summer Challenge Unu\':Solutii_Summer_Challenge_Unu\r\n* \'Solutii - Summer Challenge Doi\':Solutii_Summer_Challenge_Doi\r\n* \'Solutii - Summer Challenge Trei\':Solutii_Summer_Challenge_Trei\r\n* \'Solutii Autumn WarmUp 2006\':Solutii_Autumn_WarmUp_2006\r\n|* \'Solutiile oficiale pentru Concursul &quot;de incalzire&quot;\':Solutiile_oficiale_pentru_Concursul_de_incalzire\r\n* \'Concursul Agora - Etapa Finala - Solutii\':Concursul_Agora_Etapa_Finala_Solutii\r\n* \'Doua probleme de la runda 6 a concursului Algoritmus\':Doua_probleme_de_la_runda_6_a_concursului_Algoritmus\r\n* \'USACO decembrie 2004, divizia GOLD - idei de solutii\':USACO_decembrie_2004_divizia_GOLD_idei_de_solutii\r\n* \'Usaco ianuarie 2005, divizia GOLD\':Usaco_ianuarie_2005_divizia_GOLD\r\n* \'USACO oct 2005, divizia GOLD\':USACO_oct_2005_divizia_GOLD\r\n* \'USACO nov 2005, divizia GOLD\':USACO_nov_2005_divizia_GOLD\r\n* \'USACO dec 2005, divizia GOLD\':USACO_dec_2005_divizia_GOLD |',13,'public'),('ciclu-hamiltonian-in-graf-dens','Ciclu hamiltonian in graf dens','2006-11-22 02:07:50','h1. Ciclu hamiltonian in graf dens\r\n\r\n(Categoria _Grafuri_, autor(i) _Crestez Leonard_)\r\n\r\nIn acest articol va voi prezenta un algoritm pentru gasirea unui ciclu hamiltonian intr-un graf neorientat dens - in care fiecare nod are macar $(N + 1) / 2$ muchii.\r\n\r\nIn general, gasirea unui ciclu hamiltonian intr-un graf neorientat este un exemplu clasic de problema NP - completa. Insa, daca graful este dens - fiecare nod are cel putin $(N+1) / 2$ muchii incidente ({$N$} este numarul de noduri) - se poate gasi o solutie de complexitate {$O(N^2^)$}.\r\n\r\nh2. Algoritm\r\n\r\nLa inceput formam un ciclu la intamplare, fara a tine cont daca muchiile luate in considerare chiar exista in graf. Astfel, putem alege chiar ciclul {$1, 2, 3, 4, ... N$}. Daca acest ciclu este valid, atunci avem noroc si solutia a fost gasita. Altfel, trebuie sa incercam sa \"umplem gaurile\" din ciclu (adica muchiile pe care le-am ales la intamplare si care nu exista in graf).\r\n\r\nGasim prima muchie de acest fel, fie ea ({$A, B$}). Cautam apoi doua alte noduri adiacente in ciclul nostru, notate cu $C$ si {$D$}, astfel incat sa avem muchie de la $A$ la $C$ si de la $B$ la {$D$}. Se poate demonstra ca vom gasi mereu $C$ si {$D$}. Acum vom \"incrucisa\" $A B$ cu {$C D$}. Prin \"incrucisare\" se intelege transfromarea unui ciclu $...AB...CD...$ in $...AC...BD...$ (sau $...CD...AB...$ in $...CA...DB...$) . Atentie, secventa de la $B$ la $C$ (respectiv de la $D$ la {$A$}) va fi inversata complet!\r\n\r\nSe observa ca a scazut numarul de \"gauri\" din sir, $AB$ a fost eliminata si nu au fost adaugate \"gauri\" noi. Repetam \"umplerea gaurilor\" pana nu mai avem ce umple, deci am gasit solutie.\r\n\r\nDesi suna complicat, \"umplerea unei gauri\" necesita doar $O(N)$ timp pentru cautarea nodurile {$AB$}, {$CD$}, si incrucisare. Avand in vedere ca sunt maxim $N$ gauri la inceput, algoritmul necesita $O(N^2^)$ ca timp de executie.\r\n\r\nMai sus am folosit o afirmatie fara a o demonstra. Demonstratia e relativ intuitiva. Daca nu o descoperiti singuri, puteti sa intrebati pe \"forum\":http://info.devnet.ro/forum.php.\r\n\r\nProblema luata in discutie este propusa pe lista \"sgu\":http://acm.sgu.ru/, nr. \"122\":http://acm.sgu.ru/problem.php?contest=0&problem=122, unde exista si evaluator online. Atentie la implementare! Citirea si scrierea folosind functii standard pot iesi din timp!\r\n\r\n',1,'public'),('faq-pregatire-bacalaureat-2005','F.A.Q. Pregatire bacalaureat 2005','2006-11-22 02:24:26','h1. F.A.Q. Pregatire bacalaureat 2005\r\n\r\n(Categoria _Diverse_, autor(i) _Echipa devNet_)\r\n\r\nAcest articol poate fi considerat ca un ghid pentru programul de pregatire online la disciplina informatica din cadrul examenului de bacalaureat.\r\nCa o completare la acest articol, va recomadam sa accesati si link-ul \"Despre Infoarena\":docs/despre\r\nIn cadrul acestui program de pregatire, profesori prestigiosi de informatica din tara vor pune la dispozitia elevilor o lista de subiecte de bacalaureat de doua tipuri:\r\n\r\n# $Probleme de informatica;$ Pentru aceste subiecte, elevii vor trebui sa conceapa si sa redacteze solutii complete intr-un limbaj de programare la alegere. Site-ul dispune de un evaluator automat capabil sa noteze instantaneu solutiile propuse de elevi.\r\n# $Teste de tip grila de informatica;$ Elevii au posibilitatea sa rezolve astfel de teste de tip grila. Ca si la problemele de informatica, raspunsurile trimise se evalueaza pe loc.\r\n\r\nPentru probleme disponibile in arhiva, rezultatul $evaluarii automate$ poate fi vazut in +monitorul de evaluare+. Acolo veti vedea numarul de puncte obtinute cat si detalii despre evaluare impreuna cu niste timpi de executie orientativi. Mesajele pe care le puteti primi sunt urmatoarele:\r\n\r\n* $OK$ (sau un mesaj asemanator): programul tau a mers corect pe testul respectiv si ai primit punctele care le meritai.\r\n* $Wrong Answer, Raspuns gresit$ (sau un mesaj asemanator): programul tau a terminat executia, dar raspunsul oferit nu a fost corect; verifica daca ai respectat intocmai cum este precizat in enunt formatul fisierului de iesire cat si formatul fisierului de intrare cand efectuezi citirea\r\n* $Time Limit Exceeded:$ programul tau a depasit timpul de executie permis pentru testul respectiv; cele mai dese cauze pentru acest mesaj sunt: algoritmul folosit este ineficient, fie programul tau contine bucle care se executa la infinit, fie programul tau incearca sa citeasca de la tastatura, etc.\r\n* $Missing input/grader$ file (sau un mesaj asemanator): fisierul de intrare sau de verificare lipseste, anunta un membru din echipa devNet (acest mesaj n-ar trebui sa apara!)\r\n* $Missing output file$ (sau un mesaj asemanator): programul tau n-a creat un fisier de iesire, sau in cazul in care a creat un fisier, nu a avut numele specificat in enuntul problemei\r\n* $Runtime error - Invalid memory reference:$ acest mesaj se poate referi la faptul ca depasesti memorie disponibila (care este de 1 MB pentru stiva si 63 MB pentru heap) sau la un acces invalid in memorie, accesarea unui pointer invalid, indecsi intr-un tablou care depasesc dimensiunile tabloului, etc.\r\n* $Runtime error - alt mesaj:$ cele mai cunoscute cauze pentru astfel de mesaje sunt depasirea stivei, accesarea unor fisiere gresite, erori cu numere reale, impartire la 0, etc. Un mesaj foarte intalnit este SIGKILL si semnifica ca programul tau a fost oprit de evaluator datorita unei erori ca cele descrise mai sus.\r\n\r\n+Va recomandam sa consultati acest document periodic+ deoarece va fi actualizat des pentru a raspunde la majoritatea neclaritatilor care pot aparea in utilizarea sistemului de pregatire pentru bacalaureat. De asemenea acest document poate fi folosit si ca un ghid pentru utilizatorii \"Arhivei de probleme pentru concursuri\". Daca aveti alte intrebari care nu sunt raspunse aici nu evitati sa le puneti pe \"forum\":http://info.devnet.ro/forum.php.\r\n',1,'public'),('preoni-2006/finala/solutii','Solutii preONI 2006, Runda finala','2006-11-23 15:53:03','h1. Solutii preONI 2006, Runda finala\r\n\r\n(Categoria _Competitii_, autor(i) _Echipa Info-Arena_)\r\n\r\nSi iata-ne ajunsi in situatia de a trage concluziile dupa tot ce a insemnat preONI 2006. Toata comisia infoArena merita felicitata pentru organizarea si efortul depus de-a lungul campaniei. Inca odata multimim domnului profesor Onea pentru organizarea \"fara cusur\" :).\r\n\r\nFinala a fost ... \"Super. Super\", \"Super tare\", \"mda...a mers\" o spun concurentii. A fost grozav, intr-adevar, si ne-a facut mare placere sa va vedem prezenti intr-un numar atat de mare si veniti atat de departe. Va multumim pentru participare si speram ca ati petrecut un week-end pe cinste cu noi la Focsani.\r\n\r\nDupa cele patru runde online de concurs cu adevarat dure, cei 29 de concurenti si-au facut aparatia, de prin toate ungherele tarii, pe terenul de lupta. Desi in prima seara, la deschiderea ne-scortoasa si informala, concurentii isi zambeau sincer si fara vreun resentiment, in aer plutea \"emotia, tracul, tensiunea, stress-ul\".. Calmul dinaintea furtunii.. Venea marea confruntarea, batalia bataliilor, in urma careia trebuiau alesi castigatorii preONI 2006.\r\n\r\nConcursul s-a dovedit a fi o adevarata proba de foc, o batalie cu fum de creiere din plin si cu multe iesiri la toaleta (vezi [1]Cronica). Problemele, la limita imposibilului. Comisia a nascocit cele mai nastrusnice provocari pentru o finala in care participau concurenti adevarati, gata sa dea peste cap toate topurile Olimpiadelor ce vor voni. Muschi incordati, \"trac, tensiune, stress\". La sfarsit, punctaje reflectand truda demna de admirat a unor campioni alergand pe ultima suta de metri a unei curse in 5 acte. Castigatorii au fost sa fie, de acesta data, Cosmin Gheorghe la clasa a IX a, Simion Alexandru la clasa a X a si Marin Radu la clasele XI-XII. Ii felicitam pe ei si, in aceeasi masura, pe toti participantii care, desi au ratat premiile, cu siguranta au castigat prieteni noi.\r\n\r\nSa trecem la analiza problemelor cu care cei 29 concurenti nazdravani au avut de-a face in cele 5 ore ale finalei. Orice sugestie sau corectie privind articolul, solutiile problemelor v-o puteti exprima pe [2]forum.\r\n\r\nh2. DivK\r\n(problema usoara clasa a IX-a, problema usoara clasa a X-a)\r\n\r\nExista solutii evidente $O(N * (A-B))$ si $O(N * K)$ care obtin punctaje partiale si asupra carora nu se va insista in acest articol. Solutia care obtine insa $100$ de puncte este $O(N)$ si nu este greu de gasit, bazandu-se pe cateva observatii. Sa notam cu $S{~i~}$ suma primelor $i $numere din sir. Pentru ca subsecventa intre pozitiile $i$ si $j$ sa aiba suma elementelor divizibila cu $K$, atunci $S{~j~}-S{~i-1~}$ trebuie sa fie divizibil cu $K$, sau altfel spus, $S{~i-1~}$ si $S{~j~}$ sa aiba acelasi rest la impartirea cu $K$. Daca stim sa aflam raspunsul problemei pentru subsecvente de lungime maxim $L$ si minim $1$, aplicand de doua ori algoritmul pentru $B$ si pentru $A-1$ si scazand cele doua valori obtinute vom obtine numarul de subsecvente cu proprietatea ceruta intre $A$ si $B$ inclusiv. Pentru a afla raspunsul pentru lungimea maxim $L$ procedam astfel: introducem in lista $LISTA{~r~}$ alocata dinamic pozitiile $i$ pentru care $S{~i~}$ da restul $r$ la impartirea cu $K$, in ordine crescatoare. Pentru fiecare rest de la $0$ la $K-1$ parcurgem lista\r\ncorespunzatoarea, si, daca ne aflam pe un element cu valoarea $p2$ si elementul cel mai din stanga din lista curenta are valoarea $p1$ astfel incat $p2-p1 &le; L$, atunci cand avansam in lista nu mai este necesar sa incepem iterarea listei de la inceput pentru aflarea valorii cea mai din stanga, fiind suficient sa reluam cautarea din dreptul valorii $p1$. Astfel complexitatea algoritmului pentru o lista este $O(LUNGIME)$, unde $LUNGIME$ este lungimea unei liste, deci complexitatea intregului algoritm va fi $O(N)$, pentru ca lungimea tuturor listelor este $N$.\r\nO alta solutie de aceeasi complexitate dar mai rapida este urmatoarea: daca notam cu $v[r]$ de cate ori apare restul $r$ in numerele $S{~i-B~}...S{~i-A+1~}$ pentru pasul curent $i$, atunci la pasul $i+1$ este suficient sa decrementam $v[S{~i-B+1~} % K]$ si sa incrementam $v[S{~i-A+2~} % K]$. La fiecare pas $i$ vom aduna la solutia finala numarul $v[S{~i~} % K]$.\r\n\r\nh2. Lupul Urias si Rau\r\n(problema medie clasa a IX-a)\r\n\r\nSe construieste vectorul T[i] care retine timpul maxim la care oaia i poate fi aleasa si notam T_max valoarea maxima din T.\r\nO abordare care insa nu conduce la punctaj maxim este programarea dinamica, calculand sol[i][j] cantitatea maxima de lana care se poate alege cu primele i oi pana la momentul j. Raspunsul se va gasi in sol[n][T_max]. Complexitatea este O(n^2) si ar obtine aproximativ 50-60 de puncte.\r\nO rezolvare ce aduce 100 de puncte se bazeaza pe metoda greedy. Pentru fiecare valoare j de la T_max la 1 se adauga intr-o multime toate cantitatile de lana A[i] pentru oile cu T[i]=j, apoi se extrage valoarea maxima care se adauga la solutie, restul valorilor pastrandu-se in multime pentru pasul urmator. Atentie, se va extrage valoarea maxima chiar daca la acest pas nu s-au introdus valori noi in multime. Pentru a implementa eficient aceste operatii ne vom folosi un heap care suporta operatiile de extragere maxim si adaugare element in O(log n). Complexitatea finala a algoritmului va fi de O(n log n). Demonstratia intuitiva a faptului ca algoritmul conduce la solutie optima este ca la fiecare pas j se alege valoarea maxima dintre cele care nu vor mai putea fi alese la pasul j+1.\r\nO alta solutie tot greedy a problemei este sortarea descrescatoare dupa cantitatile de lana. Pentru fiecare valoare apoi se vede cel mai mare timp mai mic sau egal cu T[i] si la care nu a mai fost aleasa nici o alta oaie. Daca exista un astfel de timp se adauga valoare respectiva la solutie. Acest lucru se poate realiza cu o cautare binara a acestui timp. O alternativa la acest lucru ar fi folosirea multimilor disjuncte. Initial se considera fiecare moment de timp o multime. Notam X = minimul din multimea care il contine pe T[i]. Daca alegem A[i] pentru a-l aduaga la solutie se va reuni multimea care il contine pe X cu multimea care il contine pe X-1. Aceasta rezolvare insa este considerata peste nivelul mediu al clasei a 9-a.\r\n\r\nh2. Overlap\r\n(problema grea clasa a IX-a)\r\n\r\nObservam ca exista doar 4 rotatii posibile ale planului, facand abstractie de translatii. Daca CMAX este coordonata maxima, atunci punctul (i, j) se transforma in (CMAX-j, i), iar dupa 4 aplicari ale acestei transformari se ajunge din nou la punctul initial. Asadar, vom incerca pe rand fiecare dintre aceste posibilitati. Avand fixata o rotatie, stim ca punctul 1 se transforma intr-un alt punct i (i > 1), sau ca un punct i se transforma in el. Cel de-al doilea caz este redundant, deoarece aplicand transformarea P_i -> P_1, vom lua in considerare si transformarea inversa. De exemplu, daca rotind planul cu k*90 de grade si translatandu-l cu shift_X si shift_y obtinem P_i din P_j, atunci rotind planul cu (4-k)*90 grade si translatandu-l cu -shift_x, -shift_y vom obtine P_j din P_i.\r\nOdata fixata rotatia pe care o consideram (inclusiv cea de 0 grade), presupunem pe rand pentru fiecare punct i > 1 ca P_1 se transforma in P_i, si verificam daca aceasta presupunere conduce la o solutie valida. Presupunerea facuta stabileste in mod unic care este translatia efectuata. Retinem un vector P[i] = punctul in care se transforma al i-lea punct dupa aplicarea rotatiei fixate si a translatiei determinate, sau -1 daca punctul transformat nu se regaseste printre cele initiale. Pentru a realiza in mod eficient aceasta operatie, la inceputul algoritmului punctele se sorteaza cu o functie de comparare oarecare si la fiecare pas punctul dorit se cauta binar in acest vector, in O(log N). Eventual s-ar putea folosi un tabel de dispersie, insa consideram ca aceasta structura de date este prea complicata pentru nivelul clasei a 9-a si nu era necesara pentru obtinerea punctajului maxim.\r\nAvand vectorul P, va exista o structura de lanturi si cicluri rezultata in urma aplicarii repetate P[P[..P[i]]] asupra diverselor puncte. Se poate demonstra usor ca exista solutie daca si numai daca toate lanturile si toate ciclurile au lungime para; in acest caz solutia se poate obtine etichetand alternativ punctele consecutive dintr-un lant sau ciclu.\r\nComplexitatea algoritmului este O(N^2 * log N) pe cazul defavorabil folosind cautari binare pentru gasirea punctelor, sau O(N^2) pe cazul mediu folosind un hash (tabel de dispersie).\r\n\r\nh2. Iv\r\n(problema medie clasa a X-a)\r\n\r\nSolutia simpla, calculata prin metoda programarii dinamice, se bazeaza pe mentinerea starilor ce asigura obtinerea solutiilor distincte. Astfel interclasarea celor doua siruri se va face in acelasi timp atat din stanga cat si din dreapta pentru a garanta pastrarea proprietatii de palindrom. Notand cele doua siruri A si B, pastram 4 indici: p1, p2, q1, q2, reprezentand pozitia ultimului caracter luat din stanga sirului A, ultimului luat din dreapta sirului A, ultimului din stanga sirului B, respectiv ultimului luat din dreapta sirului B.\r\n\r\nSe iau 4 cazuri de tranzitie intre stari:\r\n(p1, q1, p2, q2) => (p1 + 1, q1 - 1, p2, q2), daca A[p1 + 1] = A[q1 - 1]\r\n(p1, q1, p2, q2) => (p1 + 1, q1, p2, q2 - 1), daca A[p1 + 1] = B[q2 - 1]\r\n(p1, q1, p2, q2) => (p1, q1 - 1, p2 + 1, q2), daca B[p2 + 1] = A[q1 - 1]\r\n(p1, q1, p2, q2) => (p1, q1, p2 + 1, q2 - 1), daca B[p2 + 1] = B[q2 - 1]\r\n\r\nAceasta ne duce la un algoritm de complexitate O(|A|^2 * |B|^2), ce ar fi asigurat obtinerea a 60% din punctaj. Simpla observare a faptului ca este suficienta pastrarea a numai trei indici, in loc de patru, pentru a pastra o stare completa (deoarece p1 + p2 = |A| - q1 + 1 + |B| - q2 + 1), duce la un algoritm de complexitate O(|A|^2 * |B|) ce ar fi obtinut punctaj maxim.\r\n\r\nh2. Robotei\r\n(problema grea clasa a X-a)\r\n\r\nPentru a afla de cate ori trece un robotel prin pozitia (X Y) avem nevoie de urmatoarele informatii:\r\n\r\n1. Cate mutari efectuam daca pornim din pozitia (X Y) si ajungem tot in (X Y) - lungimea ciclului care cuprinde pozitia (X Y). Daca pozitia (X Y) nu se afla pe un ciclu atunci lucrurile se simplifica (acesta este un caz special care se trateaza separat).\r\n2. Cate mutari efectueaza fiecare robot pana ajunge in (X Y). Desigur, pot exista si roboti care nu ajung niciodata in (X Y).\r\n\r\nAflarea lungimii ciclului (punctul 1.) se face usor, pornind din pozitia (X Y), efectuand mutari pana se ajunge din nou in pozitia (X Y). Daca numarul de mutari depaseste modX*modY si nu am atins inca pozitia (X, Y), atunci aceasta nu se afla pe un ciclu. Complexitatea acestui pas va fi O(modX * modY).\r\nPentru a afla, pentru fiecare robot, numarul de mutari pentru a ajunge in (X Y), putem asocia un graf caroiajului, fiecarei celule din cele N*N corespunzandu-i un nod in graful orientat construit. Pentru fiecare celula (i j) vom adauga o muchie orientata in acest graf intre nodul corespunzator celulei (i , j) si nodul corespunzator celulei ( [i*i + offsetX] modulo modX , [j*j + offsetY] modulo modY ). Fiecare nod din acest graf va avea gradul de iesire 1, in consecinta, vor fi atatea muchii cate noduri sunt (adica N*N).\r\nPornind din pozitia (X Y), efectuam o parcurgere BFS a grafului INVERSAT si vom afla, pentru fiecare nod, care este numarul de mutari pe care trebuie sa le efectuam, pornind din celula corespunzatoare nodului, pentru a ajunge in pozitia (X Y). Nodurile care nu pot fi vizitate in aceasta parcurgere corespund unor celule din care nu se poate atinge pozitia (X Y).\r\nComplexitatea acestui algoritm este O(N*N) si obtine 70% din punctaj. Pentru a obtine punctaj maxim, observam ca, dupa prima mutare toti roboteii se afla in caroiajul de dimensiuni (modX modY), si aplicam acelasi algoritm ignorand pozitiile care sunt in afara acestuia. Observatia precedenta ne permite sa afirmam ca daca un robot pleaca din pozitia (i, j) e ca si cum ar pleca, imaginar, din pozitia (i modX, j modY). Putem determina cati roboti pleaca (considerandu-i si pe cei care pleaca imaginar) dintr-o celula (i j) a caroiajului redus, determinand cate solutii au ecuatiile x % modX = i si y % modY = j (x si y necunoscute) in intervalul [0..N-1].\r\n\r\nh2. PScNv\r\n(problema simpla clasele XI-XII)\r\n\r\nAceasta problema a fost aleasa asa cum spune si textul pentru faptul ca sunt mai multe abordari ce rezolva problema. O prima abordare ar fi pentru un k fixat sa vedem daca putem ajunge de la nodul start pana la nodul destinatie folosind doar muchii cu cost mai mic sau egal cu k. Verificarea acestui fapt o facem folosind o cautare in latime. Cat timp nu putem ajunge de la nodul start la nodul destinatie incrementam pe k si apoi aplicam o cautare in latime. Astfel aflam valoarea k minima ceruta in problema. Complexitatea acestui algoritm este O(kmax (n + m)). Daca notam kmin valoarea ceruta in problema, atunci daca fixam un k si nodul destinatie este accesibil din nodul start folosind doar muchii de pondere mai mica sau egale cu k atunci este evident ca kmin <= k, iar daca nodul destinatie nu este accesibil atunci kmin > k. Pe baza acestei observatii putem dezvolta un algoritm ce cauta binar valoarea kmin ce are complexitatea O(log kmax (n + m)). O alta abordare se bazeaza pe o modificare usoara a\r\nalgoritmului Dijkstra de drum minim, in care in loc sa pastram drumuri minime, pastram drumuri pt care muchia maxima are valoare cat mai mica. O implementare cu heapuri a acestui algoritm are complexitate O(m log n). De asemenea algoritmul Bellman Ford poate fi modificat usor pentru a ne rezolva problema, chiar daca acest algoritm are complexitatea O(nm) in practica implementarea lui ce foloseste o lista se comporta cu mult mai bine. Ultimele trei rezolvari ar fi luat in jur de 70 de puncte.\r\nSolutia oficiala se bazeaza tot pe o varianta a algoritmului Dijkstra, dar care in loc sa foloseasca un heap pentru a determina nodul i inca neexpandat cu drumul de la sursa la el de cost minim, foloseste niste liste. Aceasta abordare este identica cu cea din problema Car, si comisia se astepta ca multi concurenti sa rezolve perfect problema, asteptare infirmata de rezultatele din concurs. Cum ponderile muchiilor sunt numere de la 1 pana la 1000 inseamna ca in d[i] oricare ar fi nodul i va fi intotdeauna mai mica sau egala cu 1000. Vom folosi astfel 1000 de liste dublu inlantuite. In lista i vom tine minte nodurile x pentru care d[x] = i. Cand d[x] se micsoreaza inseram pe x intr-o lista mai mica, dar pentru a il sterge din lista veche vom folosi \"lazy deletion\". Adica atunci cand ajungem la lista i si vrem sa expandam nodul x verificam mai intai daca d[x] = i, daca nu inseamna ca d[x] < i si nodul x a fost expandat mai devreme, deci putem sa il ignoram. Acest algoritm are complexitate O(kmax + n +\r\nm).\r\nComisia a mai discutat posibilitatea de a propune problema folosind un graf neorientat. Atunci o solutie similara algoritmului Kruskal ar fi avut complexitate aproape de cea optima. Am fi putut folosi un radix sort pentru a sorta muchiile, iar apoi sa adaugam muchii in ordine crescatoare la graf pana cand nodul start si nodul destinatie ar fi fost in aceiasi componenta conexa. Pentru a gestiona componentele conexe am fi folosit structuri de multimi disjuncte. Aceasta solutie ar fi avut complexitatea O(kmax + m log*n).\r\n\r\nh2. Arbore\r\n(problema medie clasele XI-XII)\r\n\r\nO prima idee de rezolvare a problemei are o complexitate de O(1) la operatiile de tip update si O(n) la operatiile de tip query. Cand intalnim o operatie de tip 1 este necesar sa folosim un vector S[1..N] in care marcam aceste modificari. Astfel, adunand valoarea s la elementul S[p] vom observa ca suma pe care a primit-o un nod X este de fapt suma valorilor S[nod] unde nod reprezinta indicele nodurilor din drumul lui X pana la radacina arborelui. Deci, pentru o operatie de tipul 1 vom face o singura adunare, iar pentru o operatie de tipul 2 vom efectua o parcurgere in adancime pentru a cauta suma ceruta. Aceasta solutie obtine in jur de 30 de puncte.\r\n\r\nO alta abordare ar fi reducerea problemei la nivel de vector. Am putea renumerota nodurile arborelui astfel incat subarborele fiecarui nod sa aiba id-uri consecutive. Acest lucru se poate face cu o parcurgere in adancime. Acum trebuie sa efectuam adunari pe intervale compacte de pe un vector, si trebuie sa gasim un element din vector ce are o anumita suma. Acest lucru se poate face, de asemenea in O(1) pentru update si O(N) pentru query usor. Aceasta solutie este mai rapida decat prima, deoarece nu foloseste apeluri recursive ale functiilor si efectueaza un numar mic de operatii. Asa s-ar fi luat 50-60 de puncte In cazul in care problema s-ar fi redus la nivel de vector dar atat update-ul cat si querry-ul s-ar fi efectuat in O(n) s-ar fi obtinut 30-40 de puncte..\r\n\r\nSolutia care ar fi obtinut punctajul maxim se bazeaza pe reducerea problemei la nivel de vector, descrisa in paragraful precedent. Fie SEC = sqrt(N). Putem imparti vectorul de lungime N in SEC secvente de lungime SEC. Vom mai folosi 3 vectori A[1..N] reprezentand sumele pe fiecare element ce au fost adunate la inceputul secventelor de lungime SEC, C[1..SEC] reprezinta sumele ce s-au adunat pe intregile secvente, iar P[1..SEC][1..1 000 000] este o matrice binara unde P[i][j] = 1 daca exista un element din secventa i astfel incat A[element] = j. Aceasta idee ne ajuta sa rezolvam problema intr-o complexitate de O(sqrt(n)) atat pentru query cat si pentru update. Pentru ca memoria folosita sa fie rezonabila implementarea matricii P se face pe biti.\r\n\r\nh2. Pedefe\r\n(problema grea clasele XI-XII)\r\n\r\nProblema cere determinarea numarului de subsiruri comune crescatoare al sirurilor S1 si S2 , care-l contin pe S3 ca subsir. Pentru a rezolva vom folosi metoda programarii dinamice. Se va construi un tabel A cu semnificatia:\r\nA[k,i,j] = cate subsiruri comune crescatoare exista tinand cont doar de primele i valori ale lui S1, primele j valori ale lui S2, si care sa contina ca subsir primele k caractere din S3, iar ultima valoare din aceste subsiruri sa fie S1[i]. Valorile din tablou se vor calcula doar atunci cand S1[i] = S2[j], in rest valorile vor fi 0. In implementare, se vor pastra doar ultimele doua linii din tabloul A, A[k-1] si A[k].\r\n\r\nIn continuare se vor prezenta mai multe implementari bazate pe aceasta idee cu diferite complexitati si care aduc punctaje diferite.\r\n\r\n* Solutia O(N^2*M^2*P) - 30 puncte\r\n\r\nPentru a calcula A[k, i, j] ne vom uita fie in A[k-1] daca S1[i] = S2[j] = S3[k], fie in A[k] (S1[i] = S2[j], S1[i] != S3[k]). Se vor aduna valorile A[k (sau k-1), p, q] cu p<i, q<j si S1[p] <= S1[i].\r\n\r\n* Solutia O(N*M^2*P) - 50 puncte\r\n\r\nSe porneste de la solutia anterioara si se observa faptul ca pentru fiecare q care se considera se poate preprocesa suma A[k (sau k-1), p, q] pentru p < i intr-un tablou S. Dupa ce se calculeaza A[k, i, j] considerand doar acele q pentru care S2[q] <= S2[j], se actualizeza S[k, j].\r\n\r\n* Solutia O(N*M*P*Sigma) - 75 puncte\r\n\r\nIn cazul cel mai devaforabil numarul de valori distincte din siruri este min(N, M), dar se garanteaza in enunt ca Sigma (numarul de valori distincte) este <= 20 pentru inca 25% din teste. Pornind de la solutia anterioara, se observa ca , parcurgand j-ul de la 1 la M, nu este necesar sa consideram de fiecare data toate valorile q < j, aceste informatii putand fi actualizate in O(1). Deoarece trebuie sa numaram doar valorile cu S2[q] <= S2[j], se pastreaza intr-un vector V[x] , suma q-urilor < j , cu S2[q] <= x. Calculul lui A[k,i,j] se face in O(Sigma), iar dupa aceasta se actualizeaza vectorul V in O(1).\r\n\r\n* Solutia O(N*M*P*lgSigma) - 100 puncte\r\n\r\nSolutia de 100 este asemantoare cu solutia de 75 de puncte, singura diferenta fiind folosirea unui arbore indexat binar pentru a face in O(lgSigma) operatiile desccrise mai sus.\r\n\r\nReferences\r\n\r\nVisible links\r\n1. http://infoarena.devnet.ro/forum/index.php/topic,935.0.html\r\n2. http://infoarena.devnet.ro/forum/index.php/topic,999.0.html\r\n\r\n',1,'public'),('testgal','testgal','2006-12-04 09:12:05','Scrie aici despre testgal',13,'public'),('sandbox','Sandbox','2006-12-04 12:54:03','h1. Sandbox\r\n\r\nFeel free to play around.\r\n\r\n\'codetest\':sandbox/code-test\r\n\r\nWhat does \'this\':sandbox?action=edit button do?\r\n\r\nlalallaa\r\n',1142,'public'),('home','infoarena 2.0','2006-11-23 16:05:05','h1. Infoarena\r\n\r\nh2. Anunturi:\r\n\r\n* Se face re-re-branding: infoarena este un singur cuvant, fara dungulite.\r\n* Url-urile se scriu cu dash-uri, vezi \'conventiile de formatare\':documentatie/conventii-formatare.\r\n* \'Pagina de modificari\':changes. Prasiti ca va tai.\r\n* Am inceput o pagina de \"documentatie\":documentatie, toata lumea e invitata.\r\n* Se pot muta pagini!\r\n* WTF people:\r\n** ==user(user=\"muioc\" type=\"tiny\")==\r\n** ==user(user=\"pulasan\" type=\"tiny\")==\r\n** ==user(user=\"cacatu\" type=\"tiny\")==\r\n** ==user(user=\"fucker\" type=\"tiny\")==\r\n** ==user(user=\"mada_fucku\" type=\"tiny\")==\r\n\r\nh2. Starting points:\r\n\r\n* *{\'Quick TODO list\':quick-todo}*\r\n* \'Modificari recente\':changes, inclusiv \'rss\':changes?format=rss.\r\n* \'Documentatie\':documentatie. Chestia asta trebuia facuta mai de mult.\r\n* \'Sandbox\':sandbox. Ca sa nu mai frecam prima pagina.\r\n* \'Development site\':http://hackers.devnet.ro/ si \'bug tracker\':http://hackers.devnet.ro/report/3.\r\n* \'Arhiva de probleme\':arhiva (\'clasament\':clasament-arhiva).\r\n* \'Preoni 2006\':preoni-2006 (copiati aici din wiki-up vechi).\r\n* \'Lista rundelor\':lista-rundelor.\r\n\r\nh2. Ultimele 3 stiri\r\n\r\n==News(pager_style=\"none\" display_entries=\"3\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':news',1142,'public'),('preoji-2004/clasament-9-10','Clasament preoji1','2006-11-23 21:08:49','h1. Clasament ==roundparam(round_id=\"preoji1\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoji1\")==',0,'round: preoji1'),('preoni-2004/clasament-9-10','preoni-2004/clasament-9-10','2006-11-25 00:26:15','h1.  Clasament global preONI 2004 (Clasele IX-X)\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni1|preoni3\")==',961,'protected'),('preoni-2006/clasament-11-12','Clasament preoni6c','2006-11-25 03:30:58','h1.  Clasament global preONI 2004 (Clasele XI-XII)\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"preoni61c|preoni62c|preoni63c|preoni64c\")==',961,'protected'),('summer-challenge-unu','summer06','2006-11-23 21:09:02','h1. summer06\r\n\r\n== include(page=\"template/todo\") ==\r\n\r\nConcursul se va desfasura --candva-- intre orele --x-- si --y--. Vrajeala si alte prostii.\r\n\r\nClasamentul poate fi vizualizat \'aici\':summer06/clasament\r\n\r\nh2. Probleme\r\n\r\nAceasta lista va deveni vizibila doar in momentul inceperii concursului.\r\n\r\n== Tasks(round_id=\"summer06\")==',0,'round: summer06'),('agora-finala','agora-finala','2006-11-24 16:38:15','\r\nAceasta este runda finala online a concursului \"Bursele Agora\", editia 6. Concursul a fost organizat de catre redactia revistei GInfo si Editura Agora Media.',1,'public'),('arhiva','Arhiva de probleme','2006-11-22 22:17:27','h1. Arhiva de probleme\r\n\r\nArhiva de probleme info-arena contine peste 300 de probleme. Vezi si \'clasamentul\':clasament-arhiva.\r\n\r\nh2. Lista de probleme (fixme: sorting?)\r\n\r\n==Tasks(round_id=\"arhiva\") ==',1142,'protected'),('documentatie/textile','Formatare Textile','2006-11-22 21:11:28','h1. Tutorial de Textile\r\n\r\nh2. Limbajul Textile\r\n\r\n(TODO): Copy from buru.\r\n\r\nPentru reguli generale despre regulile de formatare ale limbajului Textile accesati acest link: \"http://hobix.com/textile/\":http://hobix.com/textile/\r\n*ATENTIE!* Evitati folosirea codului HTML in cadrul Textile.\r\n\r\nh3. Fragmente de cod\r\n\r\n@== code(c) |@\r\n@...fragment de cod...@\r\n{@==@}\r\n\r\nUrmatoarele limbaje sunt suportate:\r\n\r\n* $code{@(c)@}$ pentru C\r\n* $code(cpp)$ pentru C++\r\n* $code(pas)$ pentru Object Pascal\r\n* $code(java)$ pentru Java\r\n\r\nIata un exemplu:\r\n\r\n== code(c) |\r\n#include <stdio.h>\r\n\r\nint main(void) {\r\n    int a, b;\r\n\r\n    freopen(\"adunare.in\", \"rt\", stdin);\r\n    freopen(\"adunare.out\", \"rt\", stdout);\r\n\r\n    scanf(\"%d%d\", &a, &b);\r\n    printf(\"%d\\n\", a+b);\r\n\r\n    return 0;\r\n}\r\n==',1142,'public'),('documentatie/textile','Formatare Textile','2006-11-23 22:06:26','h1. Tutorial de Textile\r\n\r\nh2. Introducere\r\n\r\n_Textile_ este un limbaj de markup ce va ajuta sa editati paginile web. Ce inseamna aceasta? In loc sa scrieti tag-urile specifice de html pentru a edita o astfel de pagina, _Textile_ va pune la dispozitie o serie de elemente de sintaxa prin care puteti edita mai simplu si mult mai rapid aceste pagini. In continuare sunt prezentate notiunile care trebuiesc cunoscute inainte de a incepe scrierea unui pagini html folosind _Textile_. \r\n\r\nh1. Paragrafe\r\n\r\nUn text este structurat pe mai multe paragrafe. Atunci cand folositi Textile, paragrafele trebuiesc separate de o linie alba ( goala ).\r\n\r\ntable(example). |_. Cod _Textile_|_. Cod html asociat|\r\n|Un paragraf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;\r\nAl doilea paragraf\r\n|@<p>Un paragraf</p>@&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;\r\n@<p>Al doilea paragraf</p>@|\r\n\r\nh1. \r\n\r\nUn intreg paragraf se poate transforma cu usurinta intr-un header, folosind sintaxa \"h_n_.\" la inceputul paragrafului, unde _n_ este un numar de la 1 la 6. De exemplu, folosind \"==h1. Header 1==\", rezultatul va avea forma:\r\n\r\n	h1. Header 1\r\n\r\nPentru a transforma un intreg paragraf intr-un citat, scrieti bq. inaintea lui. De exe\r\n\r\nPentru a scrie inclinat ( italic text ), pur si simplu puneti caracterul underscore (_) la inceputul si la sfarsitul zonei care doriti sa apara scrisa italic. De exemplu, textul \"==Aici apare un _cuvant_.==\" genereaza \"Aici apare un _cuvant_.\". Ingrosarea unui text ( bold text ) se realizeaza la fel ca in cazul textului italic, numai ca de data aceasta se va folosi caracterul * ( asterics ) in loc de _: astfel, textul \"==Datele de intrare se citesc din fisierul *a.txt*.==\" va genera \"Datele de intrare se citesc din fisierul *a.txt*.\". In continuare este prezentata o lista a caracterelor speciale care modifica un text, impreuna cu semnificatia lor ( ele vor fi folosite exact ca in modelele prezentate mai sus ):\r\n_ : italic ( inclinat ) =>\r\n* : bold ( ingrosat ) =>\r\n- : strikethrough ( taiat ) => \r\n+ : underline ( subliniat ) => \"Acesta\r\n\r\nPentru a scrie formule matematice utilizand puteri, se va folosi ^, de exemplu:\r\n\"==a^2^ + b^2^ = c^2^==\" va fi interpretat ca \"a^2^ + b^2^ = c^2^\".\r\nIndicii sunt tratati similar, utilizand caracterul ~ ( tilda ):\r\n\"==log ~2~ x==\" va aparea ca \"log ~2~ x\".\r\n\r\n\r\nh1. Liste\r\n\r\nPentru a crea o lista numerica cu Textile, este suficient sa inseram # inainte de fiecare paragraf:\r\n==#Primul item\r\n#Al doilea item\r\n#Al treilea item== va genera:\r\n#Primul item\r\n#Al doilea item\r\n#Al treilea item\r\n\r\nDe asemenea este posibil ca listele sa fie imbricate, incrementand numarul de caractere #. Listele vor avea o structura aborescenta:\r\n==#Un item\r\n##Alt item\r\n#Al doilea item==\r\ngenereaza:\r\n#Un item\r\n##Alt item\r\n#Al doilea item\r\n\r\nDaca in locul listelor indexate numeric se doreste creerea listelor ??? ( bulleted lists ), in loc de # se va folosi *. Regula pentru liste imbricate ramane valabila si aici:\r\n==*Un item\r\n**Alt item\r\n*Al doilea item==\"\r\ngenereaza:\r\n*Un item\r\n**Alt item\r\n*Al doilea item\"\r\n\r\nh1. Referinte externe\r\n\r\nPentru a crea un link catre un alt site, textul descriptiv va fi plasat intre ghilimele duble ( \" ), urmat imediat de caracterul : si de URLul dorit: \'==Link catre \"Google\":www.google.ro==\' va fi interpretat ca \'Link catre \"Google\":www.google.ro\'. Daca un link este folosit de mai multe ori in acelasi document sau daca se doreste o mai buna organizare a textului, este posibil ca URLul sa fie specificat oriunde in document, prin paranteze patrate intre care se afla textul identificator pentru link sis\r\n\r\nPentru a adauga o imagine, URLul ei va fi inconjurat de !.\r\n\r\nDe asemenea, o imagine poate fi ea facuta link prin\r\n\r\nh1. Tabele\r\n\r\nTabelele simple pot fi construite separand campurile lor prin caracterul |.\r\n==| nume | varsta | judet |\r\n| popescu | 24 | bucuresti |\r\n| ionescu | 12 | constanta |\r\n| petrescu | 50 | galati |==\r\nva genera tabelul de mai jos:\r\n| nume | varsta | judet |\r\n| popescu | 24 | bucuresti |\r\n| ionescu | 12 | constanta |\r\n| petrescu | 50 | galati |\r\nCelulele care doresc sa fie facute cap de tabel vor fi marcate initial printr-un underscore, urmat imediat de un punct: \"_.\" .\r\n==| _.nume | _.varsta | _.judet |\r\n| popescu | 24 | bucuresti |\r\n| ionescu | 12 | constanta |\r\n| petrescu | 50 | galati |==\r\nva avea urmatorul rezultat:\r\n| _.nume | _.varsta | _.judet |\r\n| popescu | 24 | bucuresti |\r\n| ionescu | 12 | constanta |\r\n| petrescu | 50 | galati |\r\n\r\nAtributele celulelor\r\n\r\n(TODO): Copy from buru.\r\n\r\nPentru reguli generale despre regulile de formatare ale limbajului Textile accesati acest link: \"http://hobix.com/textile/\":http://hobix.com/textile/\r\n*ATENTIE!* Evitati folosirea codului HTML in cadrul Textile.\r\n\r\nh3. Fragmente de cod\r\n\r\n@== code(c) |@\r\n@...fragment de cod...@\r\n{@==@}\r\n\r\nUrmatoarele limbaje sunt suportate:\r\n\r\n* $code{@(c)@}$ pentru C\r\n* $code(cpp)$ pentru C++\r\n* $code(pas)$ pentru Object Pascal\r\n* $code(java)$ pentru Java\r\n\r\nIata un exemplu:\r\n\r\n== code(c) |\r\n#include <stdio.h>\r\n\r\nint main(void) {\r\n    int a, b;\r\n\r\n    freopen(\"adunare.in\", \"rt\", stdin);\r\n    freopen(\"adunare.out\", \"rt\", stdout);\r\n\r\n    scanf(\"%d%d\", &a, &b);\r\n    printf(\"%d\\n\", a+b);\r\n\r\n    return 0;\r\n}\r\n==',256,'public'),('utilizator/fluffy','Profil fluffy','2006-12-02 19:16:01','h1. == userinfo(user=\"fluffy\" info=\"fullname\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"fluffy\") ==\r\n\r\n== include(page=\"template/userstats\" user_id=\"fluffy\") ==\r\n\r\nh2. Contact\r\n\r\nBug-uri pe forum ==smflink(link=\"topic\" topic=\"1359\")==\r\n\r\nh2. Despre mine\r\n\r\nbq.. Eu sunt o valoare, eu sunt number one\r\nEu sunt un baiat super unicat.\r\n\r\nh2. Distinctii primite\r\n\r\nbq.. Nu este nevoie ca sa ma prezint\r\nSunt si platina si aur si argint.\r\n\r\nh2. Arte martiale\r\n\r\nbq.. Dau cu sabia, dau cu paru\'\r\nNu se satura dusmanu\'',13,'protected'),('preoni-2005-runda-3','preONI, runda #3','2005-03-17 00:00:00','h1. preONI, runda #3\n\n(Creat de \'_domino_\':user/domino la data de _2005-03-17_ categoria _Arhiva stiri_, autor(i) _Echipa info-arena_)\n\n*Continut scurt:*\n ==Include(page=\"template/raw\")==\n\nSuntem bucurosi sa te anuntam ca runda #3 a concursului preONI se va desfasura Duminica, 20 martie la ora 10:00 - vezi mai jos informatii detaliate.\nAceasta este ultima runda a concursului preONI 2005, runda ce va decide castigatorii premiilor oferite de Microsoft. Click pe tiltul articolului pentru mai multe detalii.\n\n\n*Continut lung:*\n==Include(page=\"template/raw\")==\n\nSuntem bucurosi sa te anuntam ca runda #3 a concursului preONI se va desfasura Duminica, 20 martie la ora 10:00 - vezi mai jos informatii detaliate. Aceasta este ultima runda a concursului preONI 2005, runda ce va decide castigatorii premiilor oferite de Microsoft.\n\nClasamentul final se va calcula pe baza punctajelor obtinute in runda #2 si #3, punctajele din runda #1 fiind folosite doar pentru departajare in caz de egalitate.\n\nOricine este invitat sa participe, insa, eligibili pentru premii sunt doar acei concurenti din ciclul de invatamant pre-universitar care nu fac parte din echipa devNet.\n\npreONI 2005, runda #3\n=============================================================\n\nDuminica, 20 marie, ora 10:00 va avea loc a treia (ultima) runda preONI. Ca de obicei, concursul se va desfasura online la adresa [1]http://infoarena.devnet.ro/ Formatul concursului: 2 grupe (clasele IX-X, XI-XII), 3 probleme in fiecare grupa si un timp de lucru de 4h. Evaluarea\nva incepe la 15min dupa terminarea timpului de lucru si va putea fi urmarita in timp real la sectiunea \"statistici\".\nPropunatorii problemelor din runda #2 sunt:\n* clasele IX - X: Mircea Pasoi, Adrian Vladu\n* clasele XI - XII: Silviu Ganceanu, Cosmin Negruseri, Mircea Pasoi\nAsteptam intrebarile / sugestiile tale pe forum la adresa [2]http://info.devnet.ro/forum.php\nPremii pentru preONI 2005\n=============================================================\n\nSe vor acorda premii primilor 3 concurenti de la fiecare grupa. Premiile constau in carti valoroase de programare si sunt oferite de Microsoft Romania, prin intermediul programului \"Parteneri pentru Educatie\".\n\n[3]http://www.microsoft.com/romania/educatie/pil/default.mspx\n\nPremiul 1\n- \"Arta programarii calculatoarelor\", vol. 3, Donald E. Knuth,\n- \"POO cu Visual Basic.Net si Visual C#.Net\", R. Reynolds Haertle\n\nPremiul 2\n- \"Limbajul C Kernighan, Ritchie\", Brian Kernighan, Dennis Ritchie\n- \"POO cu Visual Basic.Net si Visual C#.Net\", R. Reynolds Haertle\n\nPremiul 3\n- \"STL - Biblioteca programatorului\", Scott Meyers\n- \"POO cu Visual Basic.Net si Visual C#.Net\", R. Reynolds Haertle\n\n(toate cartile sunt publicate de editura Teora)\n\nONI 2005\n=============================================================\n\nAsa cum bine stii, ne mai despart 8 zile de ONI! Site-ul oficial al olimpiadei de informatica este [4]http://olimpiada.info/ . Gasesti acolo tot ce doresti sa afli despre ONI, OJI si ONI by NET.\n\nDaca nu te-ai calificat la ONI, ai ocazia sa participi virtual la olimpiada! Afla mai multe la [5]http://olimpiada.info/bynet/ Inscrierile au inceput deja!\n\nEchipa info.devNet iti ureaza mult succes!\n\nReferences\n\nVisible links\n1. http://infoarena.devnet.ro/\n2. http://info.devnet.ro/forum.php\n3. http://www.microsoft.com/romania/educatie/pil/default.mspx\n4. javascript:ol(\'http://olimpiada.info/\');\n5. javascript:ol(\'http://olimpiada.info/bynet/\');\n\n',0,'public'),('documentatie/textile','Formatare Textile','2006-11-23 22:56:28','h1. Tutorial de Textile\r\n\r\nh1. Introducere\r\n\r\n_Textile_ este un limbaj de markup ce va ajuta sa editati paginile web. Ce inseamna aceasta? In loc sa scrieti tag-urile specifice de html pentru a edita o astfel de pagina, _Textile_ va pune la dispozitie o serie de elemente de sintaxa prin care puteti edita mai simplu si mult mai rapid aceste pagini. In continuare sunt prezentate notiunile care trebuiesc cunoscute inainte de a incepe scrierea unui pagini html folosind _Textile_. \r\n\r\nh1. Paragrafe\r\n\r\nUn text este structurat pe mai multe paragrafe. Atunci cand folositi Textile, paragrafele trebuiesc separate de o linie alba ( goala ).\r\n\r\ntable(example). |_. Cod _Textile_|_. Cod HTML asociat|\r\n|Un paragraf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;\r\nAl doilea paragraf\r\n|@<p>Un paragraf</p>@&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\r\n&nbsp;&nbsp;&nbsp;\r\n@<p>Al doilea paragraf</p>@|\r\n\r\n\r\nUn intreg paragraf se poate transforma cu usurinta intr-un header, folosind sintaxa {$hn$} la inceputul paragrafului, unde {$n$} este un numar de la $1$ la $6$. De exemplu, Textile va interpreta linia @h1. Primul header@ ca @<h1>Primul header</h1>@ si rezultatul va fi: \r\n\r\nh1. Primul header\r\n\r\nh1. Modificatori\r\n\r\nPentru a scrie un text cu diferite efecte ( ingrosat, inclinat, subliniat, taiat ) sau in diferite pozitii ( puteri sau indici ) se scrie textul care se doreste a fi modificat intre modificatorii corespunzatori. In tabelul de mai jos este prezentat modul de folosire al acestora:\r\n\r\ntable(example). |_. Cod _Textile_|_. Cod HTML asociat|\r\n|@**Un text ingrosat**@|@<b>Un text ingrosat</b>@|\r\n|@_Aici apare subliniat_@|@<i>Un text ingrosat</i>@|\r\n|@+Merge chiar si subliniat+@|@<ins>Merge chiar si subliniat</ins>@|\r\n|@-Text gresit-@|@<del>Text gresit</del>@|\r\n|@Pitagora: a ^2^ + b ^2^ = c ^2^@|@Pitagora: a <sup>2</sup> + b <sup>2</sup> = c <sup>2</sup>@|\r\n|@Chiar si logaritmi: log ~2~ N@|@Chiar si logaritmi: log <sub>2</sub> N@|\r\n\r\nIn cazul in care rezultatele produse de limbajul de markup nu sunt cele asteptate, se poate forta folosirea acestor modificatori prin caracterele { si } puse la inceputul si respectiv la sfarsitul secventei. De exemplu, @{**Text fortat**}@ are ca rezultat {**Text fortat**}.\r\n\r\nh1. Liste\r\n\r\nPentru a crea o lista numerica cu Textile, este suficient sa inseram # inainte de fiecare paragraf:\r\n\r\n@# Primul item@\r\n@# Al doilea item@\r\n@# Al treilea item@\r\n\r\nva genera:\r\n\r\n# Primul item\r\n# Al doilea item\r\n# Al treilea item\r\n\r\nDe asemenea este posibil ca listele sa fie imbricate, incrementand numarul de caractere #. Listele vor avea o structura aborescenta:\r\n\r\n@# Un item@\r\n@## Alt item@\r\n@# Al doilea item@\r\n\r\nva avea ca rezultat:\r\n\r\n# Un item\r\n## Alt item\r\n# Al doilea item\r\n\r\nDaca in locul listelor indexate numeric se doreste creerea listelor cu bulete ( _bulleted lists_ ), in loc de # se va folosi *. Regula pentru liste imbricate ramane valabila si aici:\r\n\r\n@* Capitolul 1@\r\n@** Capitolul 1.1@\r\n@* Capitolul 2@\r\n\r\nproduce urmatorul efect:\r\n\r\n* Capitolul 1\r\n** Capitolul 1.1\r\n* Capitolul 2\r\n\r\nh1. Referinte externe\r\n\r\nPentru a crea o referinta catre un alt site ( un _link_ ), textul descriptiv va fi plasat intre ghilimele duble (\"), urmat imediat de caracterul : si de URLul dorit: @Link catre \"infoarena\":http://infoarena.ro@ va fi interpretat ca Link catre \"infoarena\":http://infoarena.ro. Daca un link este folosit de mai multe ori in acelasi document sau daca se doreste o mai buna organizare a textului, este posibil ca URLul sa fie specificat oriunde in document: intre paranteze patrate se va afla identificatorul unic asociat linkului, dupa care urmeaza adresa propriu-zisa. In momentul in care dorim sa inseram in document acel link este suficient in loc de adresa completa sa introducem doar identificatorul pe care l-am asociat adresei:\r\n\r\n@Link catre \"infoarena\":arena@\r\n@Al doilea link catre \"inforarena\":arena@\r\n\r\n@[arena]http://infoarena.ro@\r\n\r\nare rezultatul:\r\n\r\nLink catre \"infoarena\":arena\r\nAl doilea link catre \"inforarena\":arena\r\n\r\n[arena]http://infoarena.ro\r\n\r\n\r\nPentru a adauga o imagine, URLul ei va fi inconjurat de !.\r\n\r\nDe asemenea, o imagine poate fi ea facuta link prin\r\n\r\nh1. Tabele\r\n\r\nTabelele simple pot fi construite separand campurile lor prin caracterul |.\r\n==| nume | varsta | judet |\r\n| popescu | 24 | bucuresti |\r\n| ionescu | 12 | constanta |\r\n| petrescu | 50 | galati |==\r\nva genera tabelul de mai jos:\r\n| nume | varsta | judet |\r\n| popescu | 24 | bucuresti |\r\n| ionescu | 12 | constanta |\r\n| petrescu | 50 | galati |\r\nCelulele care doresc sa fie facute cap de tabel vor fi marcate initial printr-un underscore, urmat imediat de un punct: \"_.\" .\r\n==| _.nume | _.varsta | _.judet |\r\n| popescu | 24 | bucuresti |\r\n| ionescu | 12 | constanta |\r\n| petrescu | 50 | galati |==\r\nva avea urmatorul rezultat:\r\n| _.nume | _.varsta | _.judet |\r\n| popescu | 24 | bucuresti |\r\n| ionescu | 12 | constanta |\r\n| petrescu | 50 | galati |\r\n\r\nAtributele celulelor\r\n\r\n(TODO): Copy from buru.\r\n\r\nPentru reguli generale despre regulile de formatare ale limbajului Textile accesati acest link: \"http://hobix.com/textile/\":http://hobix.com/textile/\r\n*ATENTIE!* Evitati folosirea codului HTML in cadrul Textile.\r\n\r\nh3. Fragmente de cod\r\n\r\n@== code(c) |@\r\n@...fragment de cod...@\r\n{@==@}\r\n\r\nUrmatoarele limbaje sunt suportate:\r\n\r\n* $code{@(c)@}$ pentru C\r\n* $code(cpp)$ pentru C++\r\n* $code(pas)$ pentru Object Pascal\r\n* $code(java)$ pentru Java\r\n\r\nIata un exemplu:\r\n\r\n== code(c) |\r\n#include <stdio.h>\r\n\r\nint main(void) {\r\n    int a, b;\r\n\r\n    freopen(\"adunare.in\", \"rt\", stdin);\r\n    freopen(\"adunare.out\", \"rt\", stdout);\r\n\r\n    scanf(\"%d%d\", &a, &b);\r\n    printf(\"%d\\n\", a+b);\r\n\r\n    return 0;\r\n}\r\n==',256,'public'),('summer-challenge-unu/clasament','Clasament Summer Challenge Unu','2006-11-23 23:44:48','h1. Clasament \'Summer Challenge Unu\':summer-challenge-unu\r\n\r\n!>summer-challenge-unu?logo!\r\n\r\n==Rankings(rounds=\"summer06\")==',1142,'public'),('summer-challenge-unu/clasament','Clasament Summer Challenge Unu','2006-11-23 23:46:19','h1. Clasament \'Summer Challenge Unu\':summer-challenge-unu\r\n\r\n!>summer-challenge-unu?logo 100%!\r\n\r\n==Rankings(rounds=\"summer06\")==',1142,'public'),('summer-challenge-unu','Summer Challenge Unu','2006-11-23 23:50:42','h1. Summer Challenge Unu.\r\n\r\n!>summer-challenge-unu?logo!\r\n\r\nConcursul s-a desfasurat pe 3/8/2006 intre orele FIXME si FIXME.\r\n\r\nEvaluarea s-a terminat si s-a afisat \'clasamentul\':summer-challenge-unu/clasament. Felicitari castigatorilor!\r\n\r\nConcursul a avut 3 probleme, care au fost adaugate in \'arhiva\':arhiva.\r\n== Tasks(round_id=\"summer06\" pager_style=\"none\") ==',1142,'public'),('arhiva','Arhiva de probleme','2006-11-23 21:14:49','h1. Arhiva de probleme\r\n\r\nArhiva de probleme info-arena contine peste 300 de probleme. Vezi si \'clasamentul\':clasament-arhiva.\r\n\r\nh2. Lista de probleme\r\n\r\n==Tasks(round_id=\"arhiva\") ==',1142,'protected'),('sandbox','Sandbox','2006-11-28 10:50:25','h1. Sandbox\r\n\r\nFeel free to play around.\r\n\r\n\r\ngigi  *ionel*\r\n\r\n* caterinca',1490,'public'),('problema/arbfind','Arbfind','2006-11-24 15:56:51','==Include(page=\"template/taskheader\" task_id=\"arbfind\")==\r\n\r\nSe numeste arbore cu radacina o structura care contine un nod special denumit radacina arborelui si $A{~1~}, A{~2~}, ..., A{~n~}$ (unde $n &ge; 0$) arbori cu radacina (denumiti subarbori ai radacinii). Nodul radacina al fiecarui arbore $A{~i~}$ este denumit fiu al radacinii arborelui si este conectat printr-o muchie de radacina arborelui.\r\n\r\nDoi arbori cu radacina sunt identici daca radacinile celor doi au acelasi numar de subarbori si acestia sunt identici (mai exact, pentru orice $i=1, 2, ..., n$ subarborele $i$ al primului este identic cu subarborele $i$ al celui de-al doilea).\r\n\r\nO termita poate \"ciopli\" un arbore actionand astfel:\r\n1. termita porneste de la radacina arborelui;\r\n2. la fiecare moment (in orice nod s-ar afla), termita poate face una dintre urmatoarele operatii:\r\n\r\n* sta in nod si mananca cea mai din dreapta muchie, eliminand astfel cel mai din dreapta fiu si subarborele corespunzator (acestea cad si vor fi mancate de alte termite lenese);\r\n* inainteaza pe muchia din dreapta, spre fiul ramas cel mai din dreapta al nodului in care se afla;\r\n* se opreste\r\n\r\nDoua termite prietene aleg doi arbori si ii cioplesc in modul descris pana cand obtin doi arbori identici. Similaritatea dintre doi arbori este egala cu numarul maxim de noduri care raman in fiecare dintre cei doi arbori identici obtinuti prin cioplire.\r\n\r\nh2. Cerinta\r\n\r\nDandu-se doi arbori (un arbore model si un arbore de evaluat) sa se calculeze pentru fiecare nod al arborelui de evaluat similaritatea dintre subarborele cu radacina in nodul respectiv si arborele model dat.\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului de intrare $arbfind.in$ se gaseste un numar natural $N$ reprezentand numarul de noduri din arborele model, nodurile fiind numerotate de la $1$ la $N$. Pe liniile $2..N+1$ se va afla descrierea arborelui model. Mai exact, pe linia $i$ se va afla un numar natural $F{~i-1~}$ reprezentand numarul de fii directi ai nodului $i-1$, urmat de $F ~i-1~$ numere naturale cuprinse intre $1$ si $N$, reprezentand in ordinea de la stanga la dreapta fiii nodului $i-1$.\r\n\r\nLinia $N+2$ va contine un numar natural $M$ reprezentand numarul de noduri din arborele de evaluat. Liniile $N+3..N+M+2$ vor contine descrierea arborelui de evaluat, in mod analog cu descrierea arborelui model.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $arbfind.out$ va contine $M$ linii. Pe linia $i$ se va afla similaritatea subarborelui cu radacina in nodul $i$ fata de arborele model.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* Radacina arborilor este intotdeauna nodul $1$.\r\n* $1 &le; M, N &le; 32000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. arbfind.in |_. arbfind.out |\r\n| 4\r\n2 2 3\r\n1 4\r\n0\r\n0\r\n9\r\n2 2 3\r\n2 4 5\r\n2 6 7\r\n1 8\r\n0\r\n0\r\n1 9\r\n0\r\n0\r\n| 3\r\n4\r\n2\r\n2\r\n1\r\n1\r\n2\r\n1\r\n1 | \r\n\r\nh3. Explicatie\r\n\r\n!http://www.infoarena.ro/task/arbfind?action=download&file=arbfind.jpg! &nbsp;\r\nDe exemplu, pentru nodul 1 din arborele model s-au eliminat in ordine subarborii cu radacinile 3, 5 si 8. Din arborele model se elimina subarborele cu radacina 3.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"arbfind\")==',1,'task: arbfind'),('problema/paralelograme','Paralelograme','2006-11-12 16:00:13','==Include(page=\"template/taskheader\" task_id=\"paralelograme\")==\r\n\r\nClod din nou e plictisit la ora matematica si se joaca desenand pe o foaie de patratele paralelograme cu varfurile in colturi ale patratelelor. Tot desenand paralelograme, Clod se intreaba cate astfel de paralelograme poate construi daca stie ca foaia de patratele are $N$ randuri si $M$ coloane.\r\n\r\nh2. Cerinta\r\n\r\nAjutati-l pe Clod sa rezolve problema!\r\n\r\nh2. Date de intrare\r\n\r\nIn fisierul de intrare $paralelograme.in$ pe prima linie se vor afla doua numere intregi $N$ si $M$ separate printr-un spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $paralelograme.out$ va contine pe prima linie un singur numar intreg reprezentand numarul de paralelograme cerut in problema.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N,M &le; 2.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. paralelograme.in |_. paralelograme.out |\r\n| 2 2\r\n| 22 |\r\n\r\nh3. Explicatii\r\n\r\n!http://www.infoarena.ro/task/paralelograme?action=download&file=image001.jpg!\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"paralelograme\")==',15,'task: paralelograme'),('problema/jarbore','J-Arbore','2006-11-12 14:02:43','==Include(page=\"template/taskheader\" task_id=\"jarbore\")==\r\n\r\nJ-arborele este un arbore infinit cu urmatoarele proprietati:\r\n\r\n* pe nivelul $1$ al arborelui exista un singur nod (radacina)\r\n* fiecare nod de pe nivelul $i$ are exact $i$ fii\r\n* muchiile arborelui se eticheteaza cu numere intregi consecutive incepand cu primul nivel al arborelui mergand de la stanga la dreapta\r\n* toate nodurile in afara radacinii vor fi etichetate cu numere intregi egale cu suma muchiilor de pe drumul de la radacina la nodul respectiv\r\n\r\nMai jos aveti primele nivele ale unui astfel de arbore.\r\n\r\n!http://infoarena.ro/task/jarbore?action=download&file=jtree.gif!\r\n\r\n\r\nh2. Cerinta\r\n\r\nDandu-se un numar natural $X$ vi se cere sa spuneti daca exista un nod etichetat cu valoarea $X$ si sa afisati etichetele muchiilor din drumul de la radcina spre nodul respectiv.\r\n\r\nh2. Date de Intrare\r\n\r\nIn fisierul de intrare $jarbore.in$ vor exista mai multe teste. Pe prima linie se va afla $T$ numarul de teste. Pe urmatoarele $T$ linii se afla cate un numar {$X$}.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul de iesire $jarbore.out$ vor exista $T$ linii. Pe fiecare linie se vor afla etichetele muchiilor din drumul de radacina catre nodul cu proprietatea ceruta sau $-1$ in cazul in care nu exista un astfel de nod.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; X &le; 10^18^$\r\n* $1 &le; T &le; 1000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. jarbore.in |_. jarbore.out |\r\n| 7\r\n100\r\n1\r\n2\r\n12\r\n17\r\n89\r\n666\r\n| -1\r\n1\r\n-1\r\n1 3 8\r\n1 2 4 10\r\n1 2 5 16 65\r\n1 3 7 22 97 536 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"jarbore\")==',961,'task: jarbore'),('problema/regine','Regine','2006-11-12 15:06:13','==Include(page=\"template/taskheader\" task_id=\"regine\")==\r\n\r\nPe o tabla triunghiulara de latura $N$, trebuiesc asezate cat mai multe regine, astfel incat acestea sa nu se atace.\r\n\r\nO tabla triunghiulara, de latura $N$, are $N$ linii. Pe linia $i$ sunt $i$ locuri in care reginele pot sta, iar locurile sunt asezate sub forma de triunghi, ca in figura de mai jos. Fiind vorba de o tabla mai speciala si reginele sunt speciale, in sensul ca ele se pot deplasa (ataca) in $6$ directii.\r\n\r\n!http://www.infoarena.ro/task/regine?action=download&file=regine.jpg!&nbsp;\r\n\r\nIn figura de mai sus este reprezentata o tabla de latura $6$, cu o regina pe linia $5$, coloana $4$. Numerotarea liniilor si coloanelor incepe de la $1$ (din varful tablei in jos - pentru linii si de la stanga la dreapta pentru coloane).\r\n\r\nh2. Cerinta\r\n\r\nDeterminati numarul maxim de regine ce pot fi asezate pe o tabla de dimensiune $N$ si o asezare posibila a lor (oricare dintre solutiile cu numar maxim).\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului se afla un numar natural $N$, reprezentand dimensiunea tablei.\r\n\r\nh2. Date de iesire\r\n\r\nFisierul va contine pe prima linie un singur numar intreg, $X$, reprezentand numarul maxim de regine ce pot fi asezate. Pe urmatoarele $X$ linii se vor scrie cate $2$ numere separate de un singur spatiu, reprezentand linia si respectiv coloana reginelor.\r\n\r\nh2. Restrictii\r\n\r\n* $1 < N < 1 001$\r\n* daca un test are numarul corect de regine, dar configuratia reginelor nu este valida, se acorda $30%$ din punctajul testului.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. regine.in |_. regine.out |\r\n| 3\r\n| 2\r\n2 1\r\n3 3 |\r\n\r\nh3. Explicatii\r\n\r\nPutem aseza maxim $2$ regine: una pe linia $2$, coloana $1$ si una pe linia $3$, coloana $3$.\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"regine\")==',18,'task: regine'),('problema/sortnet','Sortnet','2006-11-12 14:33:54','==Include(page=\"template/taskheader\" task_id=\"sortnet\")==\r\n\r\nO retea de sortare este formata din $N$ linii de date, numerotate de la $1$ la $N$, legate prin comparatori. Pe o linie de date circula valori numerice; initial $N$ valori oarecare sunt introduse in retea si se asteapta ca reteaua sa furnizeze la iesire o permutare a acestor numere. O retea de sortare perfecta va furniza la iesire valorile in ordine crescatoare.\r\n\r\nComparatorii sunt plasati intre doua linii de date cu scopul de a aseza in ordine crescatoare cele doua valori. Un comparator poate lega oricare doua linii $A$ si $B$, cu $A < B$; un astfel de comparator este notat simbolic cu <{$A$},{$B$}> sau grafic cu un segment vertical intre cele doua linii de date. Notatia grafica determina univoc comparatorul. Imaginati-va un segment care uneste liniile $1$ si $3$; acesta reprezinta comparatorul <{$1$},{$3$}>, deoarece <{$3$},{$1$}> nu poate fi un comparator (vezi definitia de mai sus). In aceasta problema, numarul de linii de date va fi intotdeauna par. Un ciclu de sortare este format din $N/2$ comparatori, astfel incat fiecare linie este legata la un singur comparator. O retea de sortare completa de adancime $M$ este o retea de sortare formata din $M$ cicli de sortare.\r\n\r\nUn exemplu valoreaza cat 1000 de cuvinte:\r\n\r\n!http://infoarena.ro/task/sortnet?action=download&file=sortnet.gif!\r\n\r\nReteaua din figura are $4$ linii de date si $2$ cicli de sortare. Se observa ca aceasta retea de sortare nu este perfecta. Desi sorteaza corect datele din figura (secventa {$7$},{$8$},{$7$},{$3$}), ea nu va sorta corect secventa {$1$},{$3$},{$2$},{$9$}.\r\n\r\nh2. Cerinta\r\n\r\nSe poate demonstra ca daca o retea sorteaza corect orice intrare formata numai din numerele $0$ si $1$, ea va sorta corect orice secventa de numere. Are deci sens sa spunem ca o retea este cu atat mai buna, cu cat sorteaza corect mai multe intrari formate din numerele $0$ si $1$. Exista $2^N^$ astfel de intrari; scrieti un program care determina cate dintre aceste intrari posibile sunt sortate corect de o anumita retea (prin sortate corecta, intelegem ca la iesire toate numerele de zero apar inaintea celor de unu).\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $sortnet.in$ sunt scrise doua numere intregi $N$ si $M$, reprezentand numarul de linii de date, respectiv numarul de cicli de sortare. Pe fiecare dintre urmatoarele $M$ linii sunt reprezentati $N/2$ comparatori, in formatul <{$A$},{$B$}>, cu $A$ si $B$ numere intregi intre $1$ si $N$, $A < B$. Nici un numar nu se va repeta in descrierea unui ciclu de sortare (fiecare linie este legata la exact un comparator in fiecare ciclu).\r\n\r\nh2. Date de iesire\r\n\r\nFisierul $sortnet.out$ va contine numarul de intrari formate numai din numerele $0$ si $1$, care sunt sortate corect de catre reteaua considerata.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $2 &le; N &le; 20$ si $N$ par\r\n* $0 &le; M &le; 32$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. sortnet.in|_. sortnet.out|\r\n|4 2\r\n<1,3> <2,4>\r\n<3,4> <1,2>\r\n|14|\r\n\r\n_Explicatie_: Exemplul corespunde figurii; cele doua secvente formate din cifre de $0$ si $1$ care nu sunt sortate corect sunt {$0$},{$1$},{$0$},{$1$} si {$1$},{$0$},{$1$},{$0$}. \r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"sortnet\")==',256,'task: sortnet'),('agora-finala','Bursele agora, editia 6, finala online','2006-11-24 16:48:24','h1. Bursele agora, editia 6, finala online\r\n\r\nAceasta este runda finala online a concursului \"Bursele Agora\", editia 6. Concursul a fost organizat de catre redactia revistei GInfo si Editura Agora Media. Concursul s-a desfasurat pe 9 iulie 2005. Puteti vedea \'clasamentul\':agora-finala/clasament, cat si un articol cu \'solutii\':agora-finala/solutii.\r\n\r\n!>agora-finala?logo.gif!\r\n== Tasks(round_id=\"happy\" pager_style=\"none\")==',1,'protected'),('summer-challenge-3','Summer Challenge Trei','2006-11-24 16:51:55','h1. Summer challenge 3\r\n\r\nConcursul s-a desfasurat pe 27 august 2006, ora 10:00 pe o durata de 5h. S-au propus spre rezolvare 3 probleme care au fost adaugate in \'arhiva\':arhiva.\r\n\r\nSolutiile problemelor le puteti gasi \"aici\":summer-challenge-3/solutii.\r\n\r\nh2. \'Clasament\':summer-challenge-3/clasament\r\n\r\n!>summer-challenge-3?logo.jpg!\r\n\r\n== Tasks(round_id=\"summer3\" pager_style=\"none\") ==',961,'public'),('summer-challenge-2/clasament','Clasament summer2','2006-11-23 21:09:02','h1. Clasament ==roundparam(round_id=\"summer2\" param=\"title\") ==\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==Rankings(rounds = \"summer2\")==',0,'round: summer2'),('summer-challenge-unu/clasament','Clasament Summer Challenge Unu','2006-11-23 23:51:16','h1. Clasament \'Summer Challenge Unu\':summer-challenge-unu\r\n\r\n==Rankings(rounds=\"summer06\")==',1142,'public'),('concursuri','Concursuri','2006-11-24 17:49:51','h1. Concursuri\r\n\r\nAici e de prasit mult. Vezi \'Summer challenge Unu\':summer-challenge-unu si \'preOJI 2004\':preoji-2004 pentru un model.\r\n\r\nTrebuie mutate chestiile din round/ in pagini frumoase despre runde. URL-urile probabil ca o sa fie alea de mai sus. Pagini diferite pe clase se fac doar la clasamente. Mutati una dintre paginile round/ ca sa pastrati logo-ul, restul le stergeti.\r\n\r\nClasamentele ar trebui sa fie ceva de genul contest-name/clasament-9-10, iar paginile trebuie sa fie *protected*.\r\n\r\nAtentie: mutati articolele cu solutii in contest-name/solutii.\r\n\r\nBold when it\'s done.\r\n\r\n\r\nh2. Seria preONI.\r\n\r\nInceputa in 2004, preONI este cel mai cunoscut concurs info-arena.\r\n\r\n* \'preONI 2004\':preoni-2004\r\n** \'preONI 2004\':preoni-2004/ziua-1\r\n** \'preONI 2004\':preoni-2004/ziua-2\r\n* \'preONI 2005\':preoni-2005\r\n** \'Runda 1\':preoni-2005/runda-1\r\n** \'Runda 2\':preoni-2005/runda-2\r\n** \'Runda 3\':preoni-2005/runda-3\r\n* \'preONI 2006\':preoni-2006\r\n** \'Runda 1\':preoni-2006/runda-1\r\n** \'Runda 2\':preoni-2006/runda-2\r\n** \'Runda 3\':preoni-2006/runda-3\r\n** \'Runda 4\':preoni-2006/runda-4\r\n** \'Finala\':preoni-2006/finala\r\n\r\nh2. Diverse\r\n\r\nPe langa preONI info-arena face si concursuri de balta:\r\n\r\n* *{\'Concurs de incalzire\':warm-up-2004}*\r\n* *{\'preOJI 2004\':preoji-2004}*\r\n* *{\'Bursele agora, editia 6, finala online\':agora-finala}*\r\n* *{\'Summer challenge 1\':summer-challenge-unu}*\r\n* *{\'Summer challenge 2\':summer-challenge-2}*\r\n* *{\'Summer challenge 3\':summer-challenge-3}*\r\n* *{\'Happy coding 1 (2005)\':happy-coding-2005-1}*\r\n* *{\'Happy coding 2\':happy-coding-2005-2}*\r\n* *{\'Happy coding 3 (2006)\':happy-coding-2006*}\r\n* \'Autumn warmUp 2006\':warm-up-2006\r\n* \'Grigore Moisil By Net\':moisil-by-net\r\n* \'Bacalaurea 2005\':bacalaureat-2005 <- WTF is this?\r\n\r\n\r\n==TableOfContents(prefix=\"round\")==',961,'public'),('preoni-2006','Preoni 2006','2006-11-25 01:04:39','h1. Preoni 2006.\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\n\r\n\"!http://infoarena.ro/preoni-2006?action=download&file=hlogo.gif!\":http://infoarena.ro/preoni-2006 \"!http://infoarena.ro/preoni-2006?action=download&file=Ipdevel.gif!\":http://www.ipdevel.ro/ \"!http://infoarena.ro/preoni-2006?action=download&file=Oracle_ro.gif!\":http://www.oracle.com/global/ro/index.html\r\n\r\n*Editia 2006 a concursului preONI s-a incheiat cu succes la Focsani in perioada 24-26 martie!*\r\nFinala a fost ... \"Super. Super\", \"Super tare\", \"mda...a mers\" o spun concurentii. A fost grozav, intr-adevar, si ne-a facut mare placere sa va vedem prezenti intr-un numar atat de mare si veniti atat de departe. Va multumim pentru participare si speram ca ati petrecut un week-end pe cinste cu noi la Focsani. Toata echipa info-arena merita felicitata pentru organizarea si efortul depus de-a lungul campaniei. Inca odata multimim domnului profesor Onea pentru organizarea \"fara cusur\".\r\n\r\n|\"Cronica\":preoni-2006/finala/cronica|\"Feedback\":preoni-2006/finala/feedback|\"Poze!\":|\r\n\r\nh2. Noutati\r\n\r\nSponsorii finalei sunt:\r\n\r\n\"!http://infoarena.ro/preoni-2006?action=download&file=Oracle_ro.gif!\":http://www.oracle.com/global/ro/index.html\r\n\r\n\"Colegiul National Unirea, Focsani\":http://cnu.lufo.ro/\r\n\r\n*Hotel Unirea, Focsani*\r\n\r\nViziteaza \"Pagina rundei finale\":preoni-2006/finala.\r\n\r\nh2. preONI 2006 pe scurt\r\n\r\nConcursul este destinat elevilor de liceu ce se pregatesc pentru competitii de informatica (in special ONI).\r\n\r\npreONI 2006 este impartit pe 3 grupe (Clasa a 9-a si gimnaziu, Clasa a 10-a, Clasele 11-12), iar concurentii vor avea de rezolvat 3 probleme in 4 ore. Primele 4 runde online se vor desfasura in zile de sambata, incepand de la ora 09:00, iar in urma acestora cei mai buni de la fiecare grupa vor participa la o runda finala care se va desfasura intr-o tabara, la sfarsit acordandu-se premii. In continuare veti gasi un tabel cu datele provizorii ale rundelor: \r\n\r\n|_. Runda|_. Data|_. Pagina cu detalii|\r\n|#1|19 noiembrie 2005|\"Runda 1 preONI 2006\":preoni-2006/runda-1|\r\n|#2|17 decembrie 2005|\"Runda 2 preONI 2006\":preoni-2006/runda-2|\r\n|#3|21 ianuarie 2006|\"Runda 3 preONI 2006\":preoni-2006/runda-3|\r\n|#4|19 februarie 2006|\"Runda 4 preONI 2006\":preoni-2006/runda-4|\r\n|Finala|24 - 26 martie 2006|\"Runda finala (Focsani)\":preoni-2006/finala|\r\n\r\nh2. Bine, dar cum particip?\r\n\r\n# Intri pe site in ziua si la ora la care incepe o runda preONI.\r\n# Dai click pe pagina dedicata rundei respective\r\n# Citesti problemele si trimiti solutiile. Daca nu esti familiarizat cu sistemul info-arena, citeste acest foarte mic tutorial: \"Click aici\":\r\n\r\nh2. Sponsori\r\n\r\n\"!http://infoarena.ro/preoni-2006?action=download&file=Softwin.gif!\":http://www.softwin.ro/ \"!http://infoarena.ro/preoni-2006?action=download&file=microsoft.jpg!\":http://www.microsoft.com/romania/ \"!http://infoarena.ro/preoni-2006?action=download&file=Totalsoft.gif!\":http://www.totalsoft.ro/\r\n\r\n',961,'protected'),('preoni-2005/runda-3','preoni-2005/runda-3','2006-11-25 01:08:34','h1. Preoni 2005 (Runda 3)\r\n\r\nConcursul s-a desfasurat Duminica, 20 martie la ora 10:00. Pe parcursul celor 4 ore de concurs participantii au avut de rezolvat 3 probleme. \r\n\r\nSolutiile problemelor le puteti gasi \"aici\":preoni-2005/runda-3/solutii\r\n\r\nh2. Clasele 9-10 (\'Clasament\':preoni-2005/runda-3/clasament-9-10)\r\n\r\n!>preoni-2005/runda-3?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni53a\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':preoni-2005/runda-3/clasament-11-12)\r\n\r\n!>preoni-2005/runda-3?logo2.gif!\r\n\r\n== Tasks(round_id=\"preoni53b\" pager_style=\"none\") ==',961,'protected'),('warm-up-2006/solutii','Solutii Autumn WarmUp 2006','2006-11-23 15:11:33','h1. Solutii Autumn WarmUp 2006\r\n\r\n(Categoria _Competitii_, autor(i) _Echipa Info-arena_)\r\n\r\nAici puteti gasi solutiile oficiale la cele 5 probleme propuse in concurs. De precizat si ca aceasta initiativa $info-arena$ a fost un succes, adunand un numar respectabil de participanti. Punctajele au fost mai mici decat cele asteptate, fapt ce a confirmat ca setul de probleme a fost unul capabil sa puna in dificultate nume cunoscute la olimpiadele de informatica. Iata si solutiile:\r\n\r\nh2. poly\r\n\r\nProblema este una de programare dinamica si are complexitatea $O(N)$, de constanta $2^7^ = 128$. Sa notam cu $M{~i,j~}$ lungimea celui mai lung subsir utilizand primele $i$ numere din vector astfel incat ultimul element din subsirul optim sa aiba ca divizori numerele din multimea data corespunzatoare bitilor de $1$ din $j$. Mai intai $M{~i,j~}$ = $M{~i-1,j~}$ ( nu folosim numarul al $i$-lea ). Daca dorim sa folosim si numarul al $i$-lea, atunci $M{~i,config~} = maxim(M{~i,config~}$, $M{~i-1,k~} + 1)$, cu $k and config = 0$, unde config are bitii de $1$ corespunzatori numerelor din multimea data cu care se divide acest al $i$-lea numar din sirul initial. Conditia $k and config$ ne asigura ca penultimul si ultimul numar din subsir nu au amandoua vreun divizor comun din multimea data (operatia $and$ in acest context este o operatie pe biti). Rezultatul va fi $max(M{~n,0~}$, $M{~n,1~}$... $M{~n,127~})$. Memoria folosita poate fi $O(1)$, retinand doar ultimele doua linii ale matricei.\r\n\r\nUn algoritm de complexitate patratica in $N$ folosind tot programarea dinamica ar fi obtinut $30-40$ de puncte.\r\n\r\nh2. bridge\r\n\r\nUn algoritm de complexitate $O(M + N * K)$ folosind programarea dinamica nu este foarte greu de gasit. Daca notam cu $M{~i,j~}$ numarul de moduri (modulo $666013$) de a ajunge in $i$ pasi pe scandura $j$ din pozitia initiala, atunci mai trebuie avut grija doar la relatiile de recurenta. In cazul de fata vom utiliza metoda inainte si vom trata cazurile: daca scandura $j$ este lipsa atunci $M{~i,j~} = 0$, daca scandura $j$ este teleportoare incrementam $M{~i+1,unde[j]~}$ cu $M{~i,j~}$ daca si numai daca {$unde[j]$} nu este lipsa sau subreda ({$unde[j]$} este destinatia teleportarii de pe scandura $j$),daca $j$ este scandura buna, incrementam $M{~i+1,j+1~}$ cu $M{~i,j~}$ si $M{~i+1,j+2~}$ cu $M{~i,j~}$ doar daca $j+2$ nu e lipsa sau subreda, etc.\r\n\r\nAvand construita matricea $M$, pentru fiecare query putem raspunde acum in $O(1)$. Exista diferite optimizari care pot fi facute si care sporesc substantial timpul de executie.\r\n\r\n\r\nh2. secv4\r\n\r\nDeoarece logaritmul unui produs de numere este egal cu suma logaritmilor fiecarui numar din produs, si in ipoteza ca toate numerele din sir sunt pozitive, logaritmam fiecare numar si notam cu $S{~i~}$ suma primilor $i$ logaritmi. Astfel, pentru a afla secventa de produs maxim care se termina pe pozitia $i$, este suficient sa determinam, pentru $k$ intre $i-y$ si $i-x$ care este $S{~k~}$ minim (astfel, $S{~i~} - S{~k~}$ va fi maxim, deci si produsul maxim, iar secventa va incepe pe pozitia $k+1$). Putem folosi un arbore de intervale si obtinem un algoritm $O(NlogN)$, sau o coada prin care scoatem elementele prin ambele parti (structura de date numita deque - double ended queue), obtinand complexitatea $O(N)$. Daca exista si numere negative, in momentul logaritmarii numerelor negative logaritmam opusul lor. Aplicand procedeul descris mai sus, stim sigur la final ca produsul obtinut are modulul maxim. Pentru a fi cu adevarat maxim (deci pozitiv), notam cu $semn{~i~}$ semnul produsului primelor $i$ numere. Ca secventa {@<j+1, i>@} sa aiba produs maxim trebuie in plus $semn{~i~} = semn{~j~}$. Vom retine doua deque-uri, unul pentru {$+$} si unul pt {@-@}, conform vectorului semn. Astfel, in final, suntem siguri ca produsul are semnul {$+$} si, cum are si modulul maxim, are valoarea maxima ceruta.\r\n\r\n\r\nh2. parcare\r\n\r\nProblema este exponentiala in dimensiunea matricii, dar polinomiala in numarul total de posibilitati de pozitionare al masinilor. Astfel, vom folosi un algoritm de tip BFS care garanteaza ca se ajunge la solutie intr-un numar minim de miscari. Plecam de la matricea initiala, si expandam pe rand toate starile posibile, miscand din starea curenta cate o masina pana cand nu mai exista nici o varianta noua de pozitionare a masinilor sau pana cand am scos masina A din parcare. Starile problemei le putem codifica intr-un intreg de $64$ de biti. Singurele variabile sunt pozitiile masinilor. Dupa ce eliminam zidurile inconjuratoare, coordonatele nu sunt mai mari decat $7$ ( $3$ biti ), deci pentru pozitia unei masini vom folosi $6$ biti. Concatenam pozitiile masinilor si, cum sunt maxim $10$ masini, codificarea nu va avea mai mult de $60$ de biti.\r\nPentru a memora starile explorate vom folosi o tabela de hash. De precizat si ca numarul total de posibilitati pornind de la starea initiala este destul de redus, deci problema va rula aproape instantaneu.\r\n\r\nh2. easy query\r\n\r\nUn algoritm simplu de complexitate $O(N*M)$ obtine $30-50$ de puncte. Algoritmul de $100$ de puncte are complexitatea $O(MlogN)$ si foloseste arbori de intervale. Considerand o secventa $x{~i~} x{~i+1~}... x{~j~}$ este evident ca pentru ca elementele sirurilor $y$ si $z$ sa fie maxime, respectiv minime, ele trebuiesc construite astfel:\r\n\r\n* $y{~t~} = x{~t~}- min(x{~k~}) + max(x{~p~}), i &le; t &le; j, t &le; k, p &le; j$\r\n* $z{~t~} = x{~t~} - max(x{~k~}) + min(x{~p~}), i &le; t &le; j, t &le; k, p &le; j$\r\n\r\nPentru a calcula in timp optim valoarea $P = max(y) + min(z)$ ne vom folosi de un arbore de intervale in urmatorul mod: fiecare nod al acestuia va constitui o secventa $x{~st~}, x{~st+1~}... x{~dr~}$ ( unde $st$ si $dr$ sunt marginile intervalului din nodul arborelui ) pe care o vom rezolva prin metoda brute force de la inceput, avand grija sa precalculam si alte valori necesare mai tarziu, cum ar fi :\r\n\r\n* $min = minim(x{~st~}, x{~st+1~}... x{~dr~})$\r\n* $max = maxim(x{~st~}, x{~st+1~}... x{~dr~})$\r\n* $x_max_max = maxim(x{~t~} + maxim(x{~p~}) ),st &le; t &le; dr si t &le; p &le; dr$\r\n* $x_max_min = minim(x{~t~} - maxim(x{~p~}) ),st &le; t &le; dr si t &le; p &le; dr$\r\n* $x_min_max = maxim(x{~t~} - minim(x{~p~}) ),st &le; t &le; dr si t &le; p &le; dr$\r\n* $x_min_min = minim(x{~t~} + minim(x{~p~}) ),st &le; t &le; dr si t &le; p &le; dr$\r\n* $y_max = maximul din sirul y corespunzator secventei x{~st~}, x{~st+1~}... x{~dr~}$\r\n* $z_min = minimul din sirul z corespunzator secventei x{~st~}, x{~st+1~}... x{~dr~}$\r\n\r\nAvand precalculate valorile de mai sus pentru fiecare nod al arborelui in parte vom putea raspunde in timp $O(logN)$ pentru fiecare din cele $M$ intrebari. Fiecare subsecventa data $x{~i~}, x{~i+1~}... x{~j~}$ va putea fi compusa din reuniunea mai multor noduri din arborele de intervale. Acum parcurgem nodurile ce compun subsecventa data de la dreapta la stanga si vom gasi rapid valorile $maxim(y)$ si $minim(z)$. Presupunand ca am ajuns la nodul $Q$ valoarea $maxim(y)$ pana aici se calculeaza astfel:\r\n\r\n* @MAX(Y) = y_max(Q) = y_max_max(Q) - min(W) = x_min_max(Q)+max(W) = max(Q)+max(W)-min(W)@\r\n\r\nAnalog se calculeaza si $minim(z)$.',961,'public'),('sandbox/code-test','sandbox/code-test','2006-11-28 21:40:35','h1. Keep on codin\'\r\n\r\n== code(c) |\r\n#include <stdio.h>\r\n\r\nint main(void) {\r\n    printf(\"Hello World\\n\");\r\n    return 0;\r\n}\r\n==\r\n\r\n== code(pas) |\r\nbegin\r\n\r\n  writeln(\'Hello world\');\r\n\r\nend.\r\n==\r\n\r\nh2. Capsunele pe campii\r\n\r\n== code(c) |\r\n#include <stdio.h>\r\n\r\nint main(void) {\r\n    printf(\"Hello World\\n\");\r\n    return 0;\r\n}\r\n==\r\n\r\n== code(pas) |\r\nbegin\r\n\r\n  writeln(\'Hello world\');\r\n\r\nend.\r\n==\r\n\r\n',1142,'public'),('sandbox/code-test','sandbox/code-test','2006-11-28 20:52:39','h1. Keep on codin\'\r\n\r\n== code(c) |\r\n#include <stdio.h>\r\n\r\nint main(void) {\r\n    printf(\"Hello World\\n\");\r\n    return 0;\r\n}\r\n==\r\n\r\n== code(pas) |\r\nbegin\r\n\r\n  writeln(\'Hello world\');\r\n\r\nend.\r\n==\r\n\r\nh2. Capsunele pe campii\r\n\r\n== code(c) |\r\n#include <stdio.h>\r\n\r\nint main(void) {\r\n    printf(\"Hello World\\n\");\r\n    return 0;\r\n}\r\n==\r\n\r\nh3. nu merge\r\n\r\n== code(pas) |\r\nbegin\r\n\r\n  writeln(\'Hello world\');\r\nend.\r\n==\r\n\r\nh3. wtf?',1142,'protected'),('sandbox/code-test','sandbox/code-test','2006-11-28 20:52:59','h1. Keep on codin\'\r\n\r\n== code(c) |\r\n#include <stdio.h>\r\n\r\nint main(void) {\r\n    printf(\"Hello World\\n\");\r\n    return 0;\r\n}\r\n==\r\n\r\n== code(pas) |\r\nbegin\r\n\r\n  writeln(\'Hello world\');\r\n\r\nend.\r\n==\r\n\r\nh2. Capsunele pe campii\r\n\r\n== code(c) |\r\n#include <stdio.h>\r\n\r\nint main(void) {\r\n    printf(\"Hello World\\n\");\r\n    return 0;\r\n}\r\n==\r\n\r\nh3. nu merge\r\n\r\n== code(pas) |\r\nbegin\r\n\r\n  writeln(\'Hello world\');\r\n\r\nend.\r\n==\r\n\r\nh3. wtf?',1142,'protected'),('sandbox','Sandbox','2006-11-28 17:06:10','h1. Sandbox\r\n\r\nFeel free to play around.\r\n\r\n\r\ngigi  **ionel**\r\n\r\n* caterinca',2970,'public'),('sandbox','Sandbox','2006-11-28 17:18:35','h1. Sandbox\r\n\r\nFeel free to play around.\r\n\r\n',2970,'public'),('problema/subsir2','Subsir 2','2006-11-12 13:35:08','==Include(page=\"template/taskheader\" task_id=\"subsir2\")==\r\n\r\nBronzarel se antreneaza zi de zi pentru a deveni un mare olimpic la informatica, avandu-l pe Zaharel ca mentor. Desigur, sursa lor preferata de probleme este $info-arena$! Vazandu-l foarte increzator, Zaharel vrea sa-l testeze pe Bronzarel cu o noua problema si ii spune: \"Iti dau un sir de $N$ numere intregi si vreau sa imi spui care este cel mai scurt _subsir crescator maximal_.\"\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care rezolva problema primita.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie din fisierul $subsir2.in$ se va gasi numarul $N$. Pe urmatoarea linie vor fi scrie $N$ numere intregi.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie din fisierul $subsir2.out$ va contine un numar $L{~min~}$, reprezetand lungimea minima a unui subsir crescator maximal. Pe urmatoarea linie se vor afisa $L{~min~}$ numere in ordine crescatoare, reprezetand poziitile elementelor din sirul initial care fac parte din subsirul ales. Daca exista mai multe solutii, se va afisa cea lexicografic minima, din punct de vedere al valorilor elementelor din subsir.\r\n\r\nh2. Restrictii si observatii\r\n\r\n* $1 &le; N &le; 5 000$\r\n* $50%$ din teste vor avea $N &le; 500$\r\n* Sirul dat va contine numere intregi din intervalul $[-1 000 000, 1 000 000]$\r\n* Considerand ca sirul dat este {$A=(a{~1~},a{~2~}...a{~N~})$}, se numeste subsir al lui $A$ un sir {$B=(b{~i{~1~}~},b{~i{~2~}~}...b{~i{~N~}~})$} cu proprietatea $1 &le; i{~1~} < i{~2~} < ... < i{~K~} &le; N$.\r\n* Spunem ca un subsir {$B=(b{~i{~1~}~},b{~i{~2~}~}...b{~i{~N~}~})$} este _crescator maximal_ daca {$a{~i{~1~}~} &le; a{~i{~2~}~} &le; ... &le; a{~i{~K~}~}$} si nu exista nici un $x$ astfel incat: sa existe $j < K$, {$i{~j~} < x < i{~j+1~}$} si {$a{~i{~j~}~} &le; a{~x~} &le; a{~i{~j+1~}~}$}, sau {$1 &le; x < i{~1~}$} si {$a{~x~} &le; a{~i{~1~}~}$} sau {$i{~K~} < x &le; N$} si {$a{~i{~K~}~} <= a{~x~}$}\r\n* Pentru fiecare test se va acorda $40%$ din punctaj pentru determinarea corecta a lungimii subsirului, inca $40%$ pentru determinarea unei solutii corecte, si inca $20%$ daca solutia determinata este minima din punct de vedere lexicografic\r\n* Un sir {$(x{~1~},x{~2~}...x{~K~})$} este mai mic din punct de vedere lexicografic decat un alt sir {$(y{~1~},y{~2~}...y{~K~})$} daca exista o pozitie $p$ astfel incat {$x{~p~} < y{~p~}$} si {$x{~1~} = y{~1~}$}, {$x{~2~} = y{~2~}$} ... {$x{~p-1~} = y{~p-1~}$}.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. subsir2.in|_. subsir2.out|\r\n|6\r\n1 3 6 2 5 4\r\n|3\r\n1 4 6|\r\n\r\n_Explicatie_: Subsirul cu elemente pe poziiile {$1$},{$4$},{$6$} este {$(1,2,4)$}. Acesta este maximal si are lungime minima. Alte subsiruri maximale de aceeasi lungime sunt:\r\n{$(1,2,5)$}\r\n{$(1,3,4)$}\r\n{$(1,3,5)$}\r\nSolutia data este minima lexicografic din punct de vedere al valorilor elementelor subsirului. \r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"subsir2\")==',13,'task: subsir2'),('usaco-dec-2004-divizia-gold','USACO decembrie 2004, divizia GOLD - idei de solutii','2006-11-25 14:17:26','h1. USACO decembrie 2004, divizia GOLD - idei de solutii\r\n\r\n(Categoria _Competitii_, autor(i) _Silviu Ganceanu_)\r\n\r\n\"Setul de probleme\":http://info.devnet.ro/download.php?page=cat&cat=30 pe marginea caruia voi discuta in urmatoarele randuri se afla disponibil in sectiunea download impreuna cu datele de test si rezultatele finale ale concursului (cei care nu stiu setul de probleme si vor sa citeasca articolul sunt rugati sa parcurga mai intai textele problemelor).\r\n\r\nVoi incepe prin cateva observatii in legatura cu evolutia concurentilor din Romania in acest concurs. Asadar un clasament (neoficial) alcatuit intre acestia ar arata in urmatorul mod:\r\n\r\ntable. |_. 1 | Vladu Adrian | 783 puncte|\r\n|_. 2 | Stancu-Mara Sorin | 782 puncte |\r\n|_. 3 | Andrei-Marius Teodorescu | 710 puncte |\r\n|_. 4 | Fechete Dan Ionut | 490 puncte |\r\n|_. 5 | Pasaila Daniel | 436 puncte |\r\n|_. 6 | Paul Diac | 406 puncte |\r\n\r\nRestul concurentilor au avut punctaje sub $400$ de puncte. Primii doi din clasamentul \"nostru\" au reusit sa se strecoare intre primele $20$ de locuri din clasamentul final dar, din nou, remarc lipsa unui roman in topul celor mai buni. Sper mai multe de la concursurile viitore! Mai vreau sa precizez ca Romania nu a dispus de tot arsenalul avut in dotare si concurenti cu rezultate in competiile internationale anterioare precum Dan Crestez si Dan Spatarel nu au fost prezenti in concurs (cel putin nu cu numele lor!). Ei sunt rugati sa participe in viitoarele concursuri (sau sa renunte la pseudonime - daca e cazul), spre binele lor si spre prestigiul Romaniei!\r\n\r\nSetul de probleme a fost unul dificil dar deosebit de frumos, necesitand cunostinte avansate de programare dinamica, structuri de date si teoria grafurilor. Totusi, pentru un concurent experimentat, problemele nu erau in totalitate noi. Spun asta pentru ca toate problemele aveau in substrat idei deja folosite in alte concursuri (CEOI, IOI si chiar barajele noastre).\r\n\r\nLasand comentariile deoparte sa trecem la ce ne intereseaza cel mai mult: solutiile.\r\n\r\nh2. Divide\r\n\r\nProblema se rezolva prin programare dinamica. Prima idee, destul de intuitiva de altfel, este o solutie de complexitate {$O(L * B)$}. Sa notam cu $BST{~l~}$ = numar minim de stropitori de care avem nevoie pentru a acoperi complet intervalul [{$0, l$}] cu $l$ par. Avem urmatoarea recurenta:\r\n\r\n* $BST{~l~}$ = $INFINIT$ daca $l$ este inclus intr-un interval al unei vaci\r\n* $BST{~l~}$ = {$minim(BST{~l - 2 * x~}) + 1$}, cu $x$ intre $A$ si $B$ astfel incat $2 * x$ este mai mic sau egal cu $l$\r\n\r\nPrintr-o implementare directa a recurentei de mai sus obtinem o solutie care foloseste $O(L)$ memorie si $O(L * B)$ operatii (cu observatia ca spatiul de memorie se poate reduce la {$O(B)$}).\r\n\r\nPentru a reduce complexitatea la $O(L)$ operatii se utilizeaza o coada care pastreaza valorile $BST{~x~}$ cu $x$ in intervalul [{$i - 2*B, i - 2*A$}] sortate crescator. Se observa cum se modifica coada cand se trece de la pozitia $i$ la pozitia $i + 2$ (practic \"intra\" valoarea $BST{~i + 2 - 2*A~}$ si \"iese\" valoarea {$BST{~i - 2*B~}$}. Nu voi intra in detalii despre modul cum lucreaza aceasta coada. Pe aceeasi idee (utilizarea acestei cozi) se rezolva si problema \"secventa\":problema/secventa (preOJI 2004 - infoarena) si \"trans\":problema/trans (prima proba a selectiei lotului national largit, Buzau 2004).\r\n\r\nh2. Obstacle\r\n\r\nSi aceasta problema se rezolva tot programare dinamica. Asadar avem $BST{~i, 0~}$ = distanta minima parcursa pentru a ajunge la capatul din stanga al gardului numarul $i$ si $BST{~i, 1~}$ = distanta minima parcursa pentru a ajunge la capatul din dreapta al gardului numarul {$i$}. De asemenea notam cu $Cap{~i, 0~}$ = pozitia capatului din stanga al gardului $i$ in sistemul de coordonte si $Cap{~i, 1~}$ = analog pentru capatul din dreapta. Avem urmatoarele recurenta:\r\n\r\n* $BST{~i, j~}$ = $minim(BST{~k, l~} + dst(Cap{~k, l~}, Cap{~i, j~})$ cu $k$ de la $i + 1$ la {$N$}, $l$ si $j$ fiind $0$ sau $1$ si cu proprietatea ca drumul pe Oy dintre $Cap{~k, l~} la gardul $i$ nu se interpune nici un alt gard.\r\n\r\nAceasta recurenta implementata direct ne da o solutie $O(N^2^)$ care, putin optimizata, ar fi putut obtine punctajul maxim. Totusi exista o solutie $O(N log N)$ care utilizeaza o structura de date numita arbori de intervale. Practic noi trebuie sa aflam pentru fiecare gard $i$ care este gardul pe care cade o bila lasata libera din capatul din stanga si din capatul din dreapta. Aceste informatii ne permit reducerea complexitatii recurentei de mai sus la $O(N)$ (nu va mai spun cum, ganditi si voi!). Pentru a afla informatiile despre care vorbeam se parcurg cele $N$ garduri de la $1$ la $N$ (in ordinea asta!) si se proiecteaza, pe rand, pe axa Ox. Practic se pastreaza axa Ox ca un interval [{$-200.000, 200.000$}] si, pentru un gard {$i$}, se egaleaza toate pozitiile din intervalul [{$Cap{~i, 0~}, Cap{~i, 1~}$}] cu {$i$}. Pentru un afla gardul pe care cade bila se interogheaza arborele pentru fiecare capat al gardului {$i$}. Explicatiile mele nu dezvaluie modul in care lucreaza acest arbore de intervale (mi-ar lua cateva zeci de randuri bune daca as intra in detalii). Pentru cei care nu au idee cum functioneaza acest \"monstru informatic\" le recomand citirea \"articolului\":http://info.devnet.ro/download.php?page=cat&cat=24 scris pe tema aceasta din sectiunea \"Download\":http://www.infoarena.ro/Downloads.\r\n\r\nh2. Skiarea\r\n\r\nProblema se poate rezolva utilizand cunostinte de teoria grafurilor. Mai intai se contruiesc componentele conexe ale fiecarei celule printr-un algoritm de tipul {$FLOOD FILL$}. Prin componenta conexa intelegem set de celule din matrice cu aceeasi valoarea si care indeplineste propietatea ca intre oricare doua celule exista drum (dupa regulile din enunt). Odata aflate aceste componente conexe se construieste un graf asociat lor in urmatorul mod:\r\n\r\n* fiecare componenta conexa are asociat un nod\r\n* intre doua noduri $x$ si $y$ exista drum daca componenta conexa asociata lui $x$ este \"vecina\" cu componenta conexa a lui $y$ (este usor de intuit ce inseamna \"vecina\") si daca valoarea celulelor din $x$ este mai mare decat valoarea celulelor din {$y$}.\r\n\r\nGraful astfel construit este aciclic (acesta se demostreaza usor). In acest graf aflam nodurile in care nu intra nici o muchie - noduri \"sursa\" - (fie numarul lor {$P$}) si toate nodurile din care nu iese nici o muchie - noduri \"destinatie\" - (fie numarul lor {$Q$}). Solutia pentru problema noastra va fi:\r\n\r\n* maxim dintre $P$ si {$Q$}, daca graful are doua sau mai multe noduri\r\n* {$0$}, daca graful are un singur nod.\r\n\r\nToate cele trei etape ({$FLOOD FILL-ul$}, construirea grafului, aflarea nodurilor \"sursa\" si \"destinatie\") se pot realiza in $O(N*M)$ operatii utilizand $O(N*M)$ spatiu de memorie. Mare atentie insa: nici unul dintre pasi nu trebuie realizat recursiv!! (pentru ca altfel se iese din segmentul de stiva pe testele mari).\r\n\r\n\r\n',961,'public'),('usaco-dec-2004-divizia-gold','USACO decembrie 2004, divizia GOLD - idei de solutii','2006-11-22 02:17:45','h1. USACO decembrie 2004, divizia GOLD - idei de solutii\r\n\r\n(Categoria _Competitii_, autor(i) _Silviu Ganceanu_)\r\n\r\n\"Setul de probleme\":http://info.devnet.ro/download.php?page=cat&cat=30 pe marginea caruia voi discuta in urmatoarele randuri se afla disponibil in sectiunea download impreuna cu datele de test si rezultatele finale ale concursului (cei care nu stiu setul de probleme si vor sa citeasca articolul sunt rugati sa parcurga mai intai textele problemelor).\r\n\r\nVoi incepe prin cateva observatii in legatura cu evolutia concurentilor din Romania in acest concurs. Asadar un clasament (neoficial) alcatuit intre acestia ar arata in urmatorul mod:\r\n\r\ntable. |_. 1 | Vladu Adrian | 783 puncte|\r\n|_. 2 | Stancu-Mara Sorin | 782 puncte |\r\n|_. 3 | Andrei-Marius Teodorescu | 710 puncte |\r\n|_. 4 | Fechete Dan Ionut | 490 puncte |\r\n|_. 5 | Pasaila Daniel | 436 puncte |\r\n|_. 6 | Paul Diac | 406 puncte |\r\n\r\nRestul concurentilor au avut punctaje sub $400$ de puncte. Primii doi din clasamentul \"nostru\" au reusit sa se strecoare intre primele $20$ de locuri din clasamentul final dar, din nou, remarc lipsa unui roman in topul celor mai buni. Sper mai multe de la concursurile viitore! Mai vreau sa precizez ca Romania nu a dispus de tot arsenalul avut in dotare si concurenti cu rezultate in competiile internationale anterioare precum Dan Crestez si Dan Spatarel nu au fost prezenti in concurs (cel putin nu cu numele lor!). Ei sunt rugati sa participe in viitoarele concursuri (sau sa renunte la pseudonime - daca e cazul), spre binele lor si spre prestigiul Romaniei!\r\n\r\nSetul de probleme a fost unul dificil dar deosebit de frumos, necesitand cunostinte avansate de programare dinamica, structuri de date si teoria grafurilor. Totusi, pentru un concurent experimentat, problemele nu erau in totalitate noi. Spun asta pentru ca toate problemele aveau in substrat idei deja folosite in alte concursuri (CEOI, IOI si chiar barajele noastre).\r\n\r\nLasand comentariile deoparte sa trecem la ce ne intereseaza cel mai mult: solutiile.\r\n\r\nh2. Divide\r\n\r\nProblema se rezolva prin programare dinamica. Prima idee, destul de intuitiva de altfel, este o solutie de complexitate {$O(L * B)$}. Sa notam cu $BST{~l~}$ = numar minim de stropitori de care avem nevoie pentru a acoperi complet intervalul [{$0, l$}] cu $l$ par. Avem urmatoarea recurenta:\r\n\r\n* $BST{~l~}$ = $INFINIT$ daca $l$ este inclus intr-un interval al unei vaci\r\n* $BST{~l~}$ = {$minim(BST{~l - 2 * x~}) + 1$}, cu $x$ intre $A$ si $B$ astfel incat $2 * x$ este mai mic sau egal cu $l$\r\n\r\nPrintr-o implementare directa a recurentei de mai sus obtinem o solutie care foloseste $O(L)$ memorie si $O(L * B)$ operatii (cu observatia ca spatiul de memorie se poate reduce la {$O(B)$}).\r\n\r\nPentru a reduce complexitatea la $O(L)$ operatii se utilizeaza o coada care pastreaza valorile $BST{~x~}$ cu $x$ in intervalul [{$i - 2*B, i - 2*A$}] sortate crescator. Se observa cum se modifica coada cand se trece de la pozitia $i$ la pozitia $i + 2$ (practic \"intra\" valoarea $BST{~i + 2 - 2*A~}$ si \"iese\" valoarea {$BST{~i - 2*B~}$}. Nu voi intra in detalii despre modul cum lucreaza aceasta coada. Pe aceeasi idee (utilizarea acestei cozi) se rezolva si problema \"secventa\":http://www.infoarena.ro/task/secventa (preOJI 2004 - infoarena) si \"trans\":http://www.infoarena.ro/task/trans (prima proba a selectiei lotului national largit, Buzau 2004).\r\n\r\nh2. Obstacle\r\n\r\nSi aceasta problema se rezolva tot programare dinamica. Asadar avem $BST{~i, 0~}$ = distanta minima parcursa pentru a ajunge la capatul din stanga al gardului numarul $i$ si $BST{~i, 1~}$ = distanta minima parcursa pentru a ajunge la capatul din dreapta al gardului numarul {$i$}. De asemenea notam cu $Cap{~i, 0~}$ = pozitia capatului din stanga al gardului $i$ in sistemul de coordonte si $Cap{~i, 1~}$ = analog pentru capatul din dreapta. Avem urmatoarele recurenta:\r\n\r\n* $BST{~i, j~}$ = $minim(BST{~k, l~} + dst(Cap{~k, l~}, Cap{~i, j~})$ cu $k$ de la $i + 1$ la {$N$}, $l$ si $j$ fiind $0$ sau $1$ si cu proprietatea ca drumul pe Oy dintre $Cap{~k, l~} la gardul $i$ nu se interpune nici un alt gard.\r\n\r\nAceasta recurenta implementata direct ne da o solutie $O(N^2^)$ care, putin optimizata, ar fi putut obtine punctajul maxim. Totusi exista o solutie $O(N log N)$ care utilizeaza o structura de date numita arbori de intervale. Practic noi trebuie sa aflam pentru fiecare gard $i$ care este gardul pe care cade o bila lasata libera din capatul din stanga si din capatul din dreapta. Aceste informatii ne permit reducerea complexitatii recurentei de mai sus la $O(N)$ (nu va mai spun cum, ganditi si voi!). Pentru a afla informatiile despre care vorbeam se parcurg cele $N$ garduri de la $1$ la $N$ (in ordinea asta!) si se proiecteaza, pe rand, pe axa Ox. Practic se pastreaza axa Ox ca un interval [{$-200.000, 200.000$}] si, pentru un gard {$i$}, se egaleaza toate pozitiile din intervalul [{$Cap{~i, 0~}, Cap{~i, 1~}$}] cu {$i$}. Pentru un afla gardul pe care cade bila se interogheaza arborele pentru fiecare capat al gardului {$i$}. Explicatiile mele nu dezvaluie modul in care lucreaza acest arbore de intervale (mi-ar lua cateva zeci de randuri bune\r\ndaca as intra in detalii). Pentru cei care nu au idee cum functioneaza acest \"monstru informatic\" le recomand citirea \"articolului\":http://info.devnet.ro/download.php?page=cat&cat=24 scris pe tema aceasta din sectiunea \"Download\":http://www.infoarena.ro/Downloads.\r\n\r\nh2. Skiarea\r\n\r\nProblema se poate rezolva utilizand cunostinte de teoria grafurilor. Mai intai se contruiesc componentele conexe ale fiecarei celule printr-un algoritm de tipul {$FLOOD FILL$}. Prin componenta conexa intelegem set de celule din matrice cu aceeasi valoarea si care indeplineste propietatea ca intre oricare doua celule exista drum (dupa regulile din enunt). Odata aflate aceste componente conexe se construieste un graf asociat lor in urmatorul mod:\r\n\r\n* fiecare componenta conexa are asociat un nod\r\n* intre doua noduri $x$ si $y$ exista drum daca componenta conexa asociata lui $x$ este \"vecina\" cu componenta conexa a lui $y$ (este usor de intuit ce inseamna \"vecina\") si daca valoarea celulelor din $x$ este mai mare decat valoarea celulelor din {$y$}.\r\n\r\nGraful astfel construit este aciclic (acesta se demostreaza usor). In acest graf aflam nodurile in care nu intra nici o muchie - noduri \"sursa\" - (fie numarul lor {$P$}) si toate nodurile din care nu iese nici o muchie - noduri \"destinatie\" - (fie numarul lor {$Q$}). Solutia pentru problema noastra va fi:\r\n\r\n* maxim dintre $P$ si {$Q$}, daca graful are doua sau mai multe noduri\r\n* {$0$}, daca graful are un singur nod.\r\n\r\nToate cele trei etape ({$FLOOD FILL-ul$}, construirea grafului, aflarea nodurilor \"sursa\" si \"destinatie\") se pot realiza in $O(N*M)$ operatii utilizand $O(N*M)$ spatiu de memorie. Mare atentie insa: nici unul dintre pasi nu trebuie realizat recursiv!! (pentru ca altfel se iese din segmentul de stiva pe testele mari).\r\n\r\n\r\n',1,'public'),('preoni-2006/finala/poze','Poze finala preONI 2006','2006-11-25 15:01:34','\'sandbox\':sandbox',1,'public'),('sandbox','Sandbox','2006-12-03 19:06:29','h1. Sandbox\r\n\r\nFeel free to play around.\r\n\r\n\'codetest\':sandbox/code-test\r\n\r\nUuu, what does \'this\':sandbox?action=edit button do?\r\n',2145,'public'),('preoni-2006/regulament','Regulament preONI 2006','2006-11-25 18:16:40','h1. Regulament preONI 2006\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\nSe recomanda, pe langa citirea acestui regulament, citirea \"regulamentului\":documentatie/regulament general info-arena.\r\n\r\nEchipa infoarena isi rezerva dreptul de a modifica prezentul regulament pe parcursul desfasurarii concursului. Daca apar prevederi noi sau daca anumite prevederi ale regulamentului sunt modificate sau eliminate, atunci acestea vor fi anuntate pe site-ul concursului. Orice modificare a regulamentului va intra in vigoare, in functie de situatie, fie din momentul publicarii ei, fie dupa incheierea rundei aflate in desfasurare. In momentul anuntarii modificarii va fi precizat si momentul din care aceasta intra in vigoare.\r\n\r\nh2. Dreptul de participare\r\n\r\nPersoanele care fac parte din echipa info-arena cat si alti contribuitorii implicati direct in organizarea concursului preONI 2006 nu au dreptul de a participa. De asemenea, orice concurent care are un comportament considerat inadecvat fata de echipa info-arena sau fata de alti concurenti va fi descalificat. Un concurent se poate califica la finala doar daca se incadreaza in grupa la care a concurat (aceasta verificare se va face prin prezentarea unei dovezi legale care il incadreaza pe concurent la aceea grupa).\r\n\r\nh2. Repartizarea\r\n\r\nToti participantii vor fi repartizati in 3 grupe, in concordanta cu varsta lor. Repartizarii este asemanatoare cu acea facuta la olimpiadele de informatica.\r\n\r\n    * Clasa a 9a (si gimnaziu)\r\n    * Clasa a 10a\r\n    * Clasele 11-12 \r\n\r\nOricine poate participa la o alta grupa decat cea la care se incadreaza, dar calificarea la finala cat si impartirea premiilor se va face conform regulamentului respectiv, fara nici o exceptie.\r\n[edit]\r\nInscriere\r\n\r\nTot ce trebuie sa faceti pentru a participa la concursul preONI 2006 este sa aveti un cont la info-arena. Inregistrarea se poate face pe site-ul cont.devNet. Acesta este un serviciu ce permite utilizatorilor sa foloseasca un singur cont (protejat de o parola) pe toate site-urile ce apartin proiectului info-arena. Pentru a accesa forum-ul va trebui sa creati un cont separat de cel oferit la cont.devNet\r\n\r\nh2. Runde\r\n\r\nVor exista 4 runde de calficare, iar in urma clasamentului stabilit primii de la fiecare grupa vor fi selectati pentru etapa finala desfasurata in cadrul unei tabere. Pentru detalii faceti click aici. Cele 4 runde vor avea loc sambata incepand cu ora 9:00, desi pot interveni exceptii. Durata lor va fi de 4 ore. Pentru un program detaliat al concursului faceti click aici.\r\n\r\nh2. Intrebari\r\n\r\nIn prima ora vor putea fi formulate eventualele intrebari, pe forum, in topicurile special create. Orice intrebare pusa in alt mod (primita ca personal message, pe mail, etc.) va fi ignorata. Raspunsuri vor fi oferite doar la intrebarile puse in prima ora . Intrebarile trebuie formulate astfel incat sa se poate raspunda cu DA sau NU. In caz contrar sau in cazul in care raspunsul se afla in textul problemei se va raspunde cu NO COMMENT. Nu vor exista exceptii de la aceaste reguli. Daca echipa va considera ca raspunsul la o anumita intrebare este de interes general si clarifica anumite aspecte, atunci se va face un anunt general care va aparea atat pe forum cat si in sectiunea Mesaje de la organizatori a grupei respective. Fiecare grupa va avea doi administratori care se vor ocupa de raspunsul acestor intrebari.\r\n\r\nh2. Trimiterea solutiilor\r\n\r\nTrimitrea solutiile se va face prin intermediul interfetei site-ului info-arena. Odata logati in contul vostru, veti putea selecta arhiva la care doriti sa lucrati (in cazul acesta una din arhivele preONI 2006) si veti putea folosi link-ul trimite solutii.\r\n[edit]\r\nEvaluare\r\n\r\nDupa expirarea timpului de trimitere a solutiilor acestea vor fi evaluate de SAE (mai multe detalii aici). In mod normal, evaluarea se va face imediat dupa concurs, desi exista posibilitatea ca echipa info-arena sa amane evaluarea din motive obiective. Veti putea vizualiza pozitia ocupata in clasament dupa evaluarea in rubrica Clasamente si alte statistici. Detalii despre evaluator (sistem de operare, versiuni de compilatoare etc.) gasiti aici: Evaluator.\r\n\r\nSe recomanda sa instalati pe calculatorul vostru aceleasi versiuni de compilatoare ca cele specificate la link-ul de mai sus. Echipa info-arena nu este responsabila pentru diferentele intre versiuni de compilatoare si nu va efectua reevaluaari in astfel de cazuri.\r\n\r\nh2. Contestatii\r\n\r\nEchipa info-arena isi rezerva dreptul de a reevalua orice problema in situatia in care se detecteaza erori in teste sau in programul de verificare dupa evaluare. Cum testele problemelor nu vor fi facute publice, posiblitatile de a contesta sunt limitate. Pentru a asigura o evaluarea corecta, echipa info-arena va garanteaza ca va testa intens toate problemele inainte de concurs si ca va verifica corectitudinea procesului de evaluare dupa terminare. In caz ca totusi aveti o contestatie, aceasta trebuie trimisa pe mail la adresa preONI2006 -at- gmail.com in termen de 24 de ore de la afisarea rezultatelor rundei curente pe site. Ele vor fi rezolvate in termen de maxim 5 zile, iar dupa rezolvarea lor rezultatele vor fi declarate finale.\r\n\r\nh2. Solutii\r\n\r\nLa scurt timp dupa terminarea evaluarii se va publica un articol cu solutiile pentru problemele rundei respective. Testele utilizate pentru evaluare nu vor fi facute publice.\r\n\r\nh2. Transferul problemelor\r\n\r\nProblemele vor fi mutate dupa evaluare in Arhiva de probleme info-arena, avand astfel la dispozitie un evaluator 24 din 24 si posiblitatea de a finisa solutiile la problemele nerezolvate in timpul concursului.\r\n\r\nh2. Trisare\r\n\r\npreONI 2006 este un concurs individual, asadar orice tentativa de colaborare va aduce descalificarea celor implicati. echipa info-arena isi rezerva dreptul de a verifica sursele concurentilor, iar in caz ca se descopera surse aproximativ identice, concurentii respectivi vor fi descalificati din concurs iar user-ul lor de pe info-arena eliminat. Tentativele de frauda (concurarea sub un alt nume decat cel adevarat, etc.) sau orice atac asupra sistemului de evaluare sau asupra paginilor info-arena vor fi pedepsite in aceeasi masura. \r\n',961,'public'),('template/preoni-2006','template/preoni-2006','2006-11-26 03:59:39','|{background-image: url(\'hlogo.gif?action=download\'); background-repeat: repeat-x; background-position: bottom left}. !template/preoni-2006?hlogo.gif! |>. !template/preoni-2006?ipdevel.gif! |>. !template/preoni-2006?oracle_ro.gif! |',1,'public'),('preoni-2006','preONI 2006','2006-11-26 04:39:50','h1. preONI 2006\r\n\r\n==Include(page=\"template/preoni-2006\")==\r\n\r\n*Editia 2006 a concursului preONI s-a incheiat cu succes la Focsani in perioada 24-26 martie!*\r\nFinala a fost ... \"Super. Super\", \"Super tare\", \"mda...a mers\" o spun concurentii. A fost grozav, intr-adevar, si ne-a facut mare placere sa va vedem prezenti intr-un numar atat de mare si veniti atat de departe. Va multumim pentru participare si speram ca ati petrecut un week-end pe cinste cu noi la Focsani. Toata echipa infoarena merita felicitata pentru organizarea si efortul depus de-a lungul campaniei. Inca odata multimim domnului profesor Onea pentru organizarea \"fara cusur\".\r\n\r\n|\"Cronica\":preoni-2006/finala/cronica|\"Feedback\":preoni-2006/finala/feedback|\"Poze!\":preoni-2006/finala/poze|\r\n\r\nh2. Noutati\r\n\r\nSponsorii finalei sunt:\r\n\r\n\"!preoni-2006?Oracle_ro.gif!\":http://www.oracle.com/global/ro/index.html\r\n\r\n\"Colegiul National Unirea, Focsani\":http://cnu.lufo.ro/\r\n\r\n*Hotel Unirea, Focsani*\r\n\r\nViziteaza \"Pagina rundei finale\":preoni-2006/finala.\r\n\r\nh2. preONI 2006 pe scurt\r\n\r\nConcursul este destinat elevilor de liceu ce se pregatesc pentru competitii de informatica (in special ONI).\r\n\r\npreONI 2006 este impartit pe 3 grupe (Clasa a 9-a si gimnaziu, Clasa a 10-a, Clasele 11-12), iar concurentii vor avea de rezolvat 3 probleme in 4 ore. Primele 4 runde online se vor desfasura in zile de sambata, incepand de la ora 09:00, iar in urma acestora cei mai buni de la fiecare grupa vor participa la o runda finala care se va desfasura intr-o \"tabara\":preoni-2006/finala, la sfarsit acordandu-se \"premii\":preoni-2006/premii. In continuare veti gasi un tabel cu datele provizorii ale rundelor: \r\n\r\n|_. Runda|_. Data|_. Pagina cu detalii|\r\n|#1|19 noiembrie 2005|\"Runda 1 preONI 2006\":preoni-2006/runda-1|\r\n|#2|17 decembrie 2005|\"Runda 2 preONI 2006\":preoni-2006/runda-2|\r\n|#3|21 ianuarie 2006|\"Runda 3 preONI 2006\":preoni-2006/runda-3|\r\n|#4|19 februarie 2006|\"Runda 4 preONI 2006\":preoni-2006/runda-4|\r\n|Finala|24 - 26 martie 2006|\"Runda finala (Focsani)\":preoni-2006/finala|\r\n\r\nh2. Sponsori\r\n\r\n\"!http://infoarena.ro/preoni-2006?action=download&file=Softwin.gif!\":http://www.softwin.ro/ \"!http://infoarena.ro/preoni-2006?action=download&file=microsoft.jpg!\":http://www.microsoft.com/romania/ \"!http://infoarena.ro/preoni-2006?action=download&file=Totalsoft.gif!\":http://www.totalsoft.ro/\r\n\r\n',1,'protected'),('preoni-2006/info','Informatii generale','2006-11-26 04:43:54','h1. Informatii generale\r\n\r\n==Include(page=\"template/preoni-2006\")==\r\n\r\n==Include(page=\"template/raw\")==',1,'protected'),('preoni-2006/runda-2','preONI 2006 (Runda 2)','2006-11-25 03:07:49','h1. preONI 2006 (Runda 2)\r\n\r\nConcursul s-a desfasurat sambata, 17 decembrie, la ora 09:00. Pe parcursul celor 4 ore de concurs participantii au avut de rezolvat 3 probleme. \r\n\r\nh2. Comisii\r\n\r\nh3. Stiintific\r\n\r\n* clasa a 9-a (si gimnaziu)\r\n** Mircea Pasoi\r\n** Adrian Vladu \r\n* clasa a 10-a\r\n** Adrian Diaconu\r\n** Daniel Pasaila \r\n* clasele 11-12\r\n** Cosmin Negruseri\r\n** Tiberiu Florea \r\n\r\nh3. Organizatoric\r\n\r\nPentru intrebari de factura organizatorica / tehnica poti contacta urmatoarele persoane:\r\n\r\n* Cristian Strat\r\n* Crestez Leonard \r\n\r\nh2. Solutii\r\n\r\nSolutiile problemelor le puteti gasi \"aici\":preoni-2006/runda-2/solutii\r\n\r\nh2. Clasa a 9-a si gimnaziu (\'Clasament\':preoni-2006/runda-2/clasament-9)\r\n\r\n!>preoni-2006/runda-2?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni62a\" pager_style=\"none\") ==\r\n\r\nh2. Clasa a 10-a(\'Clasament\':preoni-2006/runda-2/clasament-10)\r\n\r\n!>preoni-2006/runda-2?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni62b\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':preoni-2006/runda-2/clasament-11-12)\r\n\r\n!>preoni-2006/runda-2?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni62c\" pager_style=\"none\") ==',961,'protected'),('preoni-2006/runda-3','preONI 2006 (Runda 3)','2006-11-25 03:07:38','h1. preONI 2006 (Runda 3)\r\n\r\nConcursul s-a desfasurat sambata, 21 ianuarie, la ora 09:00. Pe parcursul celor 4 ore de concurs participantii au avut de rezolvat 3 probleme. \r\n\r\nh2. Comisii\r\n\r\nh3. Stiintific\r\n\r\n* clasa a 9-a (si gimnaziu)\r\n** Adrian Diaconu\r\n** Daniel Pasaila \r\n* clasa a 10-a\r\n** Mircea Pasoi\r\n** Tiberiu Florea \r\n* clasele 11-12\r\n** Cosmin Negruseri\r\n** Adrian Vladu\r\n** Silviu Ganceanu\r\n\r\nh3. Organizatoric\r\n\r\nPentru intrebari de factura organizatorica / tehnica poti contacta urmatoarele persoane:\r\n\r\n* Cristian Strat\r\n* Crestez Leonard \r\n\r\nh2. Solutii\r\n\r\nSolutiile problemelor le puteti gasi \"aici\":preoni-2006/runda-3/solutii\r\n\r\nh2. Clasa a 9-a si gimnaziu (\'Clasament\':preoni-2006/runda-3/clasament-9)\r\n\r\n!>preoni-2006/runda-3?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni63a\" pager_style=\"none\") ==\r\n\r\nh2. Clasa a 10-a(\'Clasament\':preoni-2006/runda-3/clasament-10)\r\n\r\n!>preoni-2006/runda-3?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni63b\" pager_style=\"none\") ==\r\n\r\nh2. Clasele 11-12 (\'Clasament\':preoni-2006/runda-3/clasament-11-12)\r\n\r\n!>preoni-2006/runda-3?logo.gif!\r\n\r\n== Tasks(round_id=\"preoni63c\" pager_style=\"none\") ==',961,'protected'),('preoni-2006/clasament','Clasament partial dupa rundele online','2006-11-25 03:57:08','h1. Clasament partial dupa rundele online\r\n\r\n* \'Clasament clasa a 9-a (si gimnaziu)\':preoni-2006/clasament-9\r\n* \'Clasament clasa a 10-a\':preoni-2006/clasament-10\r\n* \'Clasament clasele 11-12\':preoni-2006/clasament-11-12',1,'protected'),('template/newuser','Profil %user_id%','2006-11-12 18:36:32','==User(user=\"%user_id%\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"%user_id%\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti %user_id% atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',1142,'public'),('template/userinfo','Informatii despre %user_id%','2006-11-26 21:43:43','table(compact). |/4. !utilizator/%user_id%?avatar 150x150! |_. Nume | == userinfo(user=\"%user_id%\" info=\"fullname\")== |\r\n| |_. Cont infoarena | == userinfo(user=\"%user_id%\" info=\"username\")== |\r\n| |_. Statut infoarena | == userinfo(user=\"%user_id%\" info=\"security\")== |\r\n|_. Forum | ==SmfLink(user=\"%user_id%\" link=\"pm\" caption=\"trimite mesaj personal\")==, ==SmfLink(user=\"%user_id%\" link=\"stats\" caption=\"vezi activitate\")== |\r\n\r\n',13,'public'),('documentatie','Documentatie','2006-11-23 23:09:50','h1. Documentatie\r\n\r\nAsta este pagina de inceput a documentatiei, momentan doar un vag outline. Eu propun cate o pagina pentru fiecare dintre subiectele astea.\r\n\r\nh2. Subiecte de acoperit\r\n\r\nPoti sa mai adaugi, dar intrai scrie pagina.\r\n\r\n* \'Wiki\':documentatie/wiki: Despre formatare.\r\n** \'Sintaxa Textile\':documentatie/textile\r\n** \'Macro-uri\':documentatie/macro-uri. Ce sunt, cum se folosesc, cateva macro-uri comune.\r\n** \'Conventii de formatare\':documentatie/conventii-de-formatare. Split later.\r\n* \'Ghid utilizator\':documentatie/pentru-utilizatori. Inregistrare, submit, monitor, clasament. Cat mai scurt.\r\n* \'Ghid propunatori\':documentatie/pentru-propunatori: Cum devii propunator, ce inseamna.\r\n** \'Editare de probleme\':documentatie/editare-de-probleme: cum se pun teste, cum se verifica etc.\r\n** \'Editare de runde\':documentatie/editare-de-runde: cum sa fac un concurs privat.\r\n* \'Ghid administrare\':documentatie/administrare.\r\n** \'Securitate\':documentatie/securitate.\r\n** \'Template-uri\':documetatie/template-uri.\r\n** \'Development stuff\':documentatie/development.\r\n** \'Pagini speciale\':documentatie/pagini-de-administrare.',256,'public'),('template/newuser','Profil %user_id%','2006-11-26 21:33:52','h1. == userinfo(user=\"%user_id%\" info=\"fullname\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"%user_id%\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti %user_id% atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n\r\n* \"Fluffy Magicianul\":user/fluffy',13,'public'),('template/userinfo','Informatii despre %user_id%','2006-11-26 22:35:35','table(compact). |/4. !utilizator/%user_id%?avatar 150x150! |_. Nume | == userinfo(user=\"%user_id%\" info=\"fullname\")== |\r\n| |_. Cont infoarena | == userinfo(user=\"%user_id%\" info=\"username\")== |\r\n| |_. Statut infoarena | == userinfo(user=\"%user_id%\" info=\"security\")== |\r\n|_. Forum | ==SmfLink(user=\"%user_id%\" link=\"pm\" caption=\"trimite mesaj privat\")==, ==SmfLink(user=\"%user_id%\" link=\"stats\" caption=\"vezi activitate\")== |\r\n\r\n| *Probleme rezolvate* ==UserSolved(user=\"%user_id%\")== | *Probleme incercate* ==UserTried(user=\"%user_id%\")== |\r\n|\\2. *Participant la &hellip;* == UserContests(user=\"%user_id%\") == |',13,'public'),('utilizator/danielp','Profil danielp','2006-11-24 20:56:16','==User(user=\"danielp\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"danielp\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti danielp atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',48,'private'),('utilizator/wickedman','Profil wickedman','2006-11-27 01:19:30','h1. == userinfo(user=\"wickedman\" info=\"fullname\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"wickedman\") ==\r\n\r\n== include(page=\"template/userstats\" user_id=\"wickedman\") ==\r\n\r\n== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',13,'private'),('utilizator/azotlichid','Profil azotlichid','2006-11-27 01:19:31','h1. == userinfo(user=\"azotlichid\" info=\"fullname\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"azotlichid\") ==\r\n\r\n== include(page=\"template/userstats\" user_id=\"azotlichid\") ==\r\n\r\n== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',18,'private'),('utilizator/tabara','Profil tabara','2006-11-24 20:58:19','==User(user=\"tabara\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"tabara\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti tabara atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',1024,'private'),('utilizator/littleman','Profil littleman','2006-11-24 20:58:59','==User(user=\"littleman\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"littleman\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti littleman atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',1325,'private'),('utilizator/expertu','Profil expertu','2006-11-24 20:59:02','==User(user=\"expertu\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"expertu\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti expertu atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',1343,'private'),('utilizator/szaki','Profil szaki','2006-11-24 20:59:52','==User(user=\"szaki\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"szaki\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti szaki atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',1689,'private'),('utilizator/ionelya15','Profil ionelya15','2006-11-24 21:01:26','==User(user=\"ionelya15\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"ionelya15\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti ionelya15 atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',2256,'private'),('utilizator/aln','Profil aln','2006-11-24 21:02:01','==User(user=\"aln\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"aln\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti aln atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',2511,'private'),('utilizator/cioryboy','Profil cioryboy','2006-11-24 21:02:06','==User(user=\"cioryboy\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"cioryboy\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti cioryboy atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',2546,'private'),('utilizator/adinachiv','Profil adinachiv','2006-11-24 21:02:42','==User(user=\"adinachiv\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"adinachiv\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti adinachiv atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',2794,'private'),('utilizator/alexxxx','Profil Alexxxx','2006-11-24 21:04:09','==User(user=\"Alexxxx\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"Alexxxx\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti Alexxxx atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',3369,'private'),('utilizator/faxmodem','Profil faxmodem','2006-11-24 21:04:24','==User(user=\"faxmodem\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"faxmodem\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti faxmodem atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',3467,'private'),('utilizator/daysleeper','Profil daysleeper','2006-11-24 21:05:36','==User(user=\"daysleeper\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"daysleeper\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti daysleeper atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',3935,'private'),('utilizator/redskirt','Profil redskirt','2006-11-24 21:05:55','==User(user=\"redskirt\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"redskirt\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti redskirt atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',4049,'private'),('utilizator/pleasure','Profil Pleasure','2006-11-24 21:06:45','==User(user=\"Pleasure\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"Pleasure\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti Pleasure atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',4357,'private'),('utilizator/vinete','Profil vinete','2006-11-24 21:07:05','==User(user=\"vinete\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"vinete\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti vinete atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',4481,'private'),('utilizator/iuliavls','Profil iuliavls','2006-11-24 21:09:22','==User(user=\"iuliavls\" type=\"normal\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"iuliavls\") ==\r\n\r\nh2. Atentie!\r\n\r\nDaca esti iuliavls atunci poti sa-ti editezi aceasta pagina.\r\n\r\nh2. Despre mine\r\n\r\n...\r\n\r\nh2. Distinctii primite\r\n\r\n...\r\n\r\nh2. Prieteni\r\n* \"Fluffy Magicianul\":user/fluffy',5252,'private'),('documentatie/borderoul-de-evaluare','Borderoul de evaluare','2006-11-27 07:05:05','h1. Borderoul de evaluare\r\n\r\n==include(page=\"template/todo\")==\r\n\r\nBorderoul de evaluare prezinta informatii despre cum a decurs evaluarea unei solutii trimise de un concurent. Borderoul include timpul de executie, numarul de puncte obtinute la fiecare test si, uneori, mesaje de compilare sau de rulare (runtime) ale solutiei.\r\n\r\nh2. Mesaje de eroare\r\n\r\n* *OK* (sau un mesaj asemanator): programul tau a mers corect pe testul respectiv si ai primit punctele care le meritai.\r\n* *Wrong Answer*, *Raspuns gresit* (sau un mesaj asemanator): programul tau a terminat executia, dar raspunsul oferit nu a fost corect; verifica daca ai respectat intocmai cum este precizat in enunt formatul fisierului de iesire cat si formatul fisierului de intrare cand efectuezi citirea\r\n* *Time Limit Exceeded*: programul tau a depasit timpul de executie permis pentru testul respectiv; cele mai dese cauze pentru acest mesaj sunt: algoritmul folosit este ineficient, fie programul tau contine bucle care se executa la infinit, fie programul tau incearca sa citeasca de la tastatura, etc.\r\n* *System Error* (sau un mesaj asemanator): acest mesaj nu ar trebui sa apara. ==SmfLink(link=\"board\" board=\"33\" caption=\"Anunta echipa infoarena!\")==\r\n* *Missing output file* (sau un mesaj asemanator): programul tau nu a creat un fisier de iesire, sau in cazul in care a creat un fisier, nu a avut numele specificat in enuntul problemei.\r\n* *Runtime Error - Invalid memory reference*: acest mesaj se poate referi la faptul ca depasesti limita de memorie disponibila (care este de 1 MB pentru stiva si 63 MB pentru heap) sau acces invalid in memorie, accesarea unui pointer invalid, indecsi intr-un tablou care depasesc dimensiunile tabloului, etc.\r\n* *Runtime Error*: cele mai cunoscute cauze pentru astfel de mesaje sunt depasirea stivei, accesarea unor fisiere gresite, erori cu numere reale, impartire la 0, etc. Un mesaj foarte intalnit este SIGKILL si semnifica ca programul tau a fost oprit de evaluator datorita unei erori ca cele descrise mai sus.\r\n\r\nh2. Greseli frecvente\r\n\r\n...\r\n',13,'public'),('despre-infoarena','Despre infoarena','2006-11-27 08:00:06','h1. Despre infoarena\r\n\r\n*infoarena ajuta elevi si studenti sa devina excelenti in informatica!* Gratuit ;)\r\n\r\n<div id=\"sidebar2\">\r\n<div class=\"section\">\r\n\r\nh3. Cu ce ne ocupam?\r\n\r\n* concursuri online pentru studenti/elevi\r\n* stiri si articole despre informatica\r\n* discutam pe forum tot despre informatica\r\n* cateodata organizam concursuri on-site.\r\n</div>\r\n<div class=\"section\">\r\n\r\nbq. People have been known to achieve more as a result of working with others than against them.\r\n*Dr. Allan Fromme*\r\n\r\n</div>\r\n</div>\r\n\r\ninfoarena functioneaza din 2002 si este dezvoltata de noi, echipa infoarena.\r\nSuntem o mana de studenti si elevi innebuniti de info. Tinem neaparat sa-i ajutam si pe altii sa innebuneasca :)\r\n\r\nComunitatea noastra cuprinde aproape toti elevii romani ce participa la concursuri de informatica nationale si internationale. Ne mandrim cu valoarea concursurilor si a materialelor prezentate pe site.\r\n\r\nDemn de mentionat este evaluatorul infoarena, un program care evalueaza solutiile trimise de concurenti. Evaluatorul iti spune aproape instantaneu daca (si cat de bine) ai rezolvat o problema (\"vezi Evaluator\":documentatie/evaluator).\r\n\r\nh2. In cuvintele lor\r\n\r\nbq. infoarena este un proiect remarcabil, realizat cu entuziasm, generozitate si profesionalism. Este locul in care tinerii pasionati de informatica se pot intalni, atat de o parte, cat si de cealalta parte a baricadei, ca propunatori sau ca rezolvitori de probleme, isi pot impartasi experienta competitionala, pot constitui modele, pot ajuta la formarea a noi si noi generatii de performanta.\r\n\r\n*Emanuela Cerchez*\r\nCoordonator stiintific in Comisia Nationala de Informatica\r\nProfesor grad didactic I - Liceul de Informatica \"Grigore Moisil\" Iasi\r\n\r\nbq. infoarena e plin de energie, e dinamic si riguros, gratie unei echipe curajoase. Site-ul infoarena reprezinta cea mai originala forma de pregatire pe net a performerilor in informatica din Romania. Mecanism de lucru excelent, probleme propuse, fara cusur. Felicitari!\r\n\r\n*Emil Onea*\r\nInspector scolar informatica\r\nComisia Nationala de Informatica pentru Invatamant Preuniversitar\r\n',13,'public'),('despre-infoarena','Despre infoarena','2006-11-27 08:11:47','h1. Despre infoarena\r\n\r\n*infoarena ajuta elevi si studenti sa devina excelenti in informatica!* Gratuit ;)\r\n\r\n<div id=\"sidebar2\">\r\n<div class=\"section\">\r\n\r\nh3. Cu ce ne ocupam?\r\n\r\n* concursuri online pentru studenti/elevi\r\n* stiri si articole despre informatica\r\n* discutam pe forum tot despre informatica\r\n* cateodata organizam concursuri on-site.\r\n</div>\r\n\r\n</div>\r\n\r\ninfoarena functioneaza din 2002 si este dezvoltata de noi, echipa infoarena.\r\nSuntem o mana de studenti si elevi innebuniti de info. Tinem neaparat sa-i ajutam si pe altii sa innebuneasca :)\r\n\r\nComunitatea noastra cuprinde aproape toti elevii romani ce participa la concursuri de informatica nationale si internationale. Ne mandrim cu valoarea concursurilor si a materialelor prezentate pe site.\r\n\r\nDemn de mentionat este evaluatorul infoarena, un program care evalueaza solutiile trimise de concurenti. Evaluatorul iti spune aproape instantaneu daca (si cat de bine) ai rezolvat o problema (\"vezi Evaluator\":documentatie/evaluator).\r\n\r\nbq. People have been known to achieve more as a result of working with others than against them.\r\n\r\n*Dr. Allan Fromme*\r\n\r\nh2. In cuvintele lor\r\n\r\nbq. infoarena este un proiect remarcabil, realizat cu entuziasm, generozitate si profesionalism. Este locul in care tinerii pasionati de informatica se pot intalni, atat de o parte, cat si de cealalta parte a baricadei, ca propunatori sau ca rezolvitori de probleme, isi pot impartasi experienta competitionala, pot constitui modele, pot ajuta la formarea a noi si noi generatii de performanta.\r\n\r\n*Emanuela Cerchez*\r\nCoordonator stiintific in Comisia Nationala de Informatica, Prof. grad I - Lic. de Informatica \"Grigore Moisil\" Iasi\r\n\r\nbq. infoarena e plin de energie, e dinamic si riguros, gratie unei echipe curajoase. Site-ul infoarena reprezinta cea mai originala forma de pregatire pe net a performerilor in informatica din Romania. Mecanism de lucru excelent, probleme propuse, fara cusur. Felicitari!\r\n\r\n*Emil Onea*\r\nInspector scolar informatica, Comisia Nationala de Informatica pentru Invatamant Preuniversitar\r\n',13,'public'),('despre-infoarena','Despre infoarena','2006-11-27 08:14:13','h1. Despre infoarena\r\n\r\n*infoarena ajuta elevi si studenti sa devina excelenti in informatica!* Gratuit ;)\r\n\r\n<div id=\"sidebar2\">\r\n<div class=\"section\">\r\n\r\nh3. Cu ce ne ocupam?\r\n\r\n* concursuri online pentru studenti/elevi\r\n* stiri si articole despre informatica\r\n* discutam pe forum tot despre informatica\r\n* cateodata organizam concursuri on-site.\r\n</div>\r\n\r\n</div>\r\n\r\ninfoarena functioneaza din 2002 si este dezvoltata de noi, echipa infoarena.\r\nSuntem o mana de studenti si elevi innebuniti de info. Tinem neaparat sa-i ajutam si pe altii sa innebuneasca :)\r\n\r\nComunitatea noastra cuprinde aproape toti elevii romani ce participa la concursuri de informatica nationale si internationale. Ne mandrim cu valoarea concursurilor si a materialelor prezentate pe site.\r\n\r\nDemn de mentionat este evaluatorul infoarena, un program care evalueaza solutiile trimise de concurenti. Evaluatorul iti spune aproape instantaneu daca (si cat de bine) ai rezolvat o problema (\"vezi Evaluator\":documentatie/evaluator).\r\n\r\nbq. People have been known to achieve more as a result of working with others than against them.\r\n\r\n*Dr. Allan Fromme*\r\n\r\nh2. In cuvintele lor\r\n\r\nbq. infoarena este un proiect remarcabil, realizat cu entuziasm, generozitate si profesionalism. Este locul in care tinerii pasionati de informatica se pot intalni, atat de o parte, cat si de cealalta parte a baricadei, ca propunatori sau ca rezolvitori de probleme, isi pot impartasi experienta competitionala, pot constitui modele, pot ajuta la formarea a noi si noi generatii de performanta.\r\n\r\n*Emanuela Cerchez*\r\nCoordonator stiintific in Comisia Nationala de Informatica, Prof. grad I - Lic. de Informatica \"Grigore Moisil\" Iasi\r\n\r\n&nbsp;\r\n\r\nbq. infoarena e plin de energie, e dinamic si riguros, gratie unei echipe curajoase. Site-ul infoarena reprezinta cea mai originala forma de pregatire pe net a performerilor in informatica din Romania. Mecanism de lucru excelent, probleme propuse, fara cusur. Felicitari!\r\n\r\n*Emil Onea*\r\nInspector scolar informatica, Comisia Nationala de Informatica pentru Invatamant Preuniversitar\r\n',13,'public'),('preoni-2006/program','Program preONI 2006','2006-11-26 04:45:25','h1. Program preONI 2006\r\n\r\n==Include(page=\"template/preoni-2006\")==\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\n',1,'protected'),('preoni-2006/comisie','Organizatori preONI 2006','2006-11-27 10:23:27','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Organizatori\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\n',13,'protected'),('preoni-2006/program','Program, preONI 2006','2006-11-27 10:25:27','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Program\r\n\r\n==Include(page=\"template/raw\")==\r\n\r\n',13,'protected'),('preoni-2006/clasament-9','Clasament preoni6a','2006-11-27 15:52:04','h1.  Clasament global preONI 2006 (Clasa a IX-a si gimnaziu)\r\n\r\nFelicitari primilor clasati!!!\r\n\r\n==include(page=\"template/preoni-2006/rankings\")==\r\n\r\n==Rankings(rounds = \"preoni61a|preoni62a|preoni63a|preoni64a\")==',13,'public'),('template/preoni-2006/rankings','template/preoni-2006/rankings','2006-11-27 16:01:11','==include(page=\"template/preoni-2006/header\")==\r\n\r\np={font-weight: bold}. &larr; \"preONI 2006 Homepage\":preoni-2006 | \"Clasa a IX-a si gimnaziu\":preoni-2006/clasament-9 | \"Clasa a X-a \":preoni-2006/clasament-10 | \"Clasele XI-XII\":preoni-2006/clasament-11-12\r\n',13,'public'),('preoni-2006','preONI 2006','2006-11-27 15:44:16','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. preONI 2006\r\n\r\n*Editia 2006 a concursului preONI s-a incheiat cu succes la Focsani in perioada 24-26 martie!*\r\nFinala a fost ... \"Super. Super\", \"Super tare\", \"mda...a mers\" o spun concurentii. A fost grozav, intr-adevar, si ne-a facut mare placere sa va vedem prezenti intr-un numar atat de mare si veniti atat de departe. Va multumim pentru participare si speram ca ati petrecut un week-end pe cinste cu noi la Focsani. Toata echipa infoarena merita felicitata pentru organizarea si efortul depus de-a lungul campaniei. Inca odata multimim domnului profesor Onea pentru organizarea \"fara cusur\".\r\n\r\n|\"Cronica\":preoni-2006/finala/cronica|\"Feedback\":preoni-2006/finala/feedback|\"Poze!\":preoni-2006/finala/poze|\r\n\r\nh2. Noutati\r\n\r\nSponsorii finalei sunt:\r\n\r\n\"!preoni-2006?Oracle_ro.gif!\":http://www.oracle.com/global/ro/index.html\r\n\r\n\"Colegiul National Unirea, Focsani\":http://cnu.lufo.ro/\r\n\r\n*Hotel Unirea, Focsani*\r\n\r\nViziteaza \"Pagina rundei finale\":preoni-2006/finala.\r\n\r\nh2. preONI 2006 pe scurt\r\n\r\nConcursul este destinat elevilor de liceu ce se pregatesc pentru competitii de informatica (in special ONI).\r\n\r\npreONI 2006 este impartit pe 3 grupe (Clasa a 9-a si gimnaziu, Clasa a 10-a, Clasele 11-12), iar concurentii vor avea de rezolvat 3 probleme in 4 ore. Primele 4 runde online se vor desfasura in zile de sambata, incepand de la ora 09:00, iar in urma acestora cei mai buni de la fiecare grupa vor participa la o runda finala care se va desfasura intr-o \"tabara\":preoni-2006/finala, la sfarsit acordandu-se \"premii\":preoni-2006/premii. In continuare veti gasi un tabel cu datele provizorii ale rundelor: \r\n\r\n|_. Runda|_. Data|_. Pagina cu detalii|\r\n|#1|19 noiembrie 2005|\"Runda 1 preONI 2006\":preoni-2006/runda-1|\r\n|#2|17 decembrie 2005|\"Runda 2 preONI 2006\":preoni-2006/runda-2|\r\n|#3|21 ianuarie 2006|\"Runda 3 preONI 2006\":preoni-2006/runda-3|\r\n|#4|19 februarie 2006|\"Runda 4 preONI 2006\":preoni-2006/runda-4|\r\n|Finala|24 - 26 martie 2006|\"Runda finala (Focsani)\":preoni-2006/finala|\r\n\r\nh2. Sponsori\r\n\r\n\"!http://infoarena.ro/preoni-2006?action=download&file=Softwin.gif!\":http://www.softwin.ro/ \"!http://infoarena.ro/preoni-2006?action=download&file=microsoft.jpg!\":http://www.microsoft.com/romania/ \"!http://infoarena.ro/preoni-2006?action=download&file=Totalsoft.gif!\":http://www.totalsoft.ro/\r\n\r\n',13,'public'),('documentatie/development','Development','2006-11-25 13:55:17','h1. Development\r\n\r\nInfoarena 2.0 imbratiseaza mentalitate open-source: codul nostru sursa este \'liber disponibil\':http://hackers.devnet.ro/source iar dezvoltarea se face \'public\':http://hackers.devnet.ro.\r\n\r\nh2. Tichete\r\n\r\nIn dezvoltarea infoarena 2.0 noi incercam sa fim organizati, folosim bug-tracker.\r\n\r\nh2. Cum sa contribui.\r\n\r\nSi tu poti sa contribui la infoarena 2.0!',1142,'public'),('utilizator/wickedman','Profil wickedman','2006-11-27 20:32:01','h1. == userinfo(user=\"wickedman\" info=\"fullname\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"wickedman\") ==\r\n\r\n== include(page=\"template/userstats\" user_id=\"wickedman\") ==\r\n\r\nh2. Contact\r\n\r\n*Atentie!* poti sa ma contactezi in legatura cu bug-uri infoarena:\r\n\r\n* Email: \'cristi858@yahoo.com\':cristi858@yahoo.com, \'strat.cristian@gmail.com\':strat.cristian@gmail.com.\r\n* YMess: cristi858\r\n* GTalk: strat.cristian\r\n\r\nh2. Despre mine\r\n\r\n... Vrajeala ...',1142,'private'),('utilizator/fluffy','Profil fluffy','2006-11-27 20:29:01','h1. == userinfo(user=\"fluffy\" info=\"fullname\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"fluffy\") ==\r\n\r\n== include(page=\"template/userstats\" user_id=\"fluffy\") ==\r\n\r\nh2. Contact\r\n\r\n*Atentie!* poti sa ma contactezi in legatura cu bug-uri infoarena:\r\n\r\n* Email: \'cdleonard@gmail.com\':cdleonard@gmail.com\r\n* YMess: crestez_leonard\r\n* GTalk: cdleonard\r\n\r\nh2. Despre mine\r\n\r\nbq.. Eu sunt o valoare, eu sunt number one\r\nEu sunt un baiat super unicat.\r\n\r\nh2. Distinctii primite\r\n\r\nbq.. Nu este nevoie ca sa ma prezint\r\nSunt si platina si aur si argint.\r\n\r\nh2. Arte martiale\r\n\r\nbq.. Dau cu sabia, dau cu paru\'\r\nNu se satura dusmanu\'\r\nIl bat pan se schimba banu\'\r\nIl bat pan la ora patru',1142,'protected'),('despre-infoarena','Despre infoarena','2006-11-27 14:24:52','h1. Despre infoarena\r\n\r\n<div id=\"sidebar2\">\r\n<div class=\"section\">\r\n\r\nh3. Cu ce ne ocupam?\r\n\r\n* Concursuri online de informatica pentru studenti si elevi\r\n* Stiri si articole despre informatica\r\n* Discutam pe forum tot despre informatica\r\n* Cateodata organizam concursuri on-site.\r\n</div>\r\n\r\n</div>\r\n\r\n*infoarena ajuta elevi si studenti sa devina excelenti in informatica!* Gratuit ;)\r\n\r\ninfoarena functioneaza din 2002 si este dezvoltata de noi, echipa infoarena.\r\nSuntem o mana de studenti si elevi innebuniti de info. Tinem neaparat sa-i ajutam si pe altii sa innebuneasca :)\r\n\r\nComunitatea noastra cuprinde aproape toti elevii romani ce participa la concursuri de informatica nationale si internationale. Ne mandrim cu valoarea concursurilor si a materialelor prezentate pe site.\r\n\r\nDemn de mentionat este evaluatorul infoarena, un program care evalueaza solutiile trimise de concurenti. Evaluatorul iti spune aproape instantaneu daca (si cat de bine) ai rezolvat o problema (\"vezi Evaluator\":documentatie/evaluator).\r\n\r\n&nbsp;\r\n\r\nbq. People have been known to achieve more as a result of working with others than against them.\r\n\r\n*Dr. Allan Fromme*\r\n\r\n&nbsp;\r\n\r\nbq. infoarena este un proiect remarcabil, realizat cu entuziasm, generozitate si profesionalism. Este locul in care tinerii pasionati de informatica se pot intalni, atat de o parte, cat si de cealalta parte a baricadei, ca propunatori sau ca rezolvitori de probleme, isi pot impartasi experienta competitionala, pot constitui modele, pot ajuta la formarea a noi si noi generatii de performanta.\r\n\r\n*Emanuela Cerchez*\r\nCoordonator stiintific in Comisia Nationala de Informatica, Prof. grad I - Lic. de Informatica \"Grigore Moisil\" Iasi\r\n\r\n&nbsp;\r\n\r\nbq. infoarena e plin de energie, e dinamic si riguros, gratie unei echipe curajoase. Site-ul infoarena reprezinta cea mai originala forma de pregatire pe net a performerilor in informatica din Romania. Mecanism de lucru excelent, probleme propuse, fara cusur. Felicitari!\r\n\r\n*Emil Onea*\r\nInspector scolar informatica, Comisia Nationala de Informatica pentru Invatamant Preuniversitar\r\n',1,'public'),('home','infoarena 2.0','2006-11-27 21:18:49','h1. infoarena 2.0\r\n\r\nh2. Feedback\r\n\r\nAjuta-ne sa facem facem o infoarena ca _Soarele sfant de pe cer_ :) Asteptam bug reports, sugestii, intrebari pe forum. Iata niste topic-uri de feedback:\r\n\r\n==SmfTopics(board_id=\"33\")==\r\n\r\nh2. Starting points:\r\n\r\n* \'Modificari recente\':changes, inclusiv \'rss\':changes?format=rss.\r\n* \'Documentatie\':documentatie. Chestia asta trebuia facuta mai de mult.\r\n* \'Sandbox\':sandbox. Testeaza wiki-ul infoarena!\r\n* \'Arhiva de probleme\':arhiva (\'clasament\':clasament-arhiva).\r\n* \'preONI 2006\':preoni-2006\r\n* \'Admins go here\':admin\r\n\r\nh2. Pentru programatori\r\n\r\ninfoarena imbratiseaza mentalitatea open-source: codul nostru sursa este \'liber disponibil\':http://hackers.devnet.ro/browse iar dezvoltarea se face \'public\':http://hackers.devnet.ro.\r\nDaca stii PHP / tehnologii web / webdesign sau vrei sa inveti alaturi de noi, intra pe \"pagina de development\":documentatie/development.\r\n\r\nh2. Ultimele stiri\r\n\r\n==News(pager_style=\"none\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':stiri',13,'protected'),('template/userrating','template/userrating','2006-12-06 11:33:44','h2. Rating pentru %user%\r\n\r\np=. ! http://infoarena.ro/plot/rating?user=%user% !',13,'protected'),('template/userrating','template/userrating','2006-12-06 11:59:20','h2. Rating %user%\r\n\r\np=. ! http://infoarena.ro/plot/rating?user=%user% !\r\n\r\n==RatingRounds(user=\"%user%\")==\r\n\r\n*{\"Ce inseamna si cum se calculeaza rating-ul?\":documentatie/rating}*',13,'protected'),('template/userrating','template/userrating','2006-12-06 12:04:26','h2. Rating %user%\r\n\r\np{color: red; font-weight: bold}. Datele afisate in grafic sunt temporare. Formula de rating mai trebuie ajustata.\r\n\r\np=. ! http://infoarena.ro/plot/rating?user=%user% !\r\n\r\n==RatingRounds(user=\"%user%\")==\r\n\r\n*{\"Ce inseamna si cum se calculeaza rating-ul?\":documentatie/rating}*',13,'protected'),('template/userrating','template/userrating','2006-12-06 15:02:06','h2. Rating %user%\r\n\r\np=. ! http://infoarena.ro/plot/rating?user=%user% (Evolutie rating %user%) !\r\n\r\n&nbsp; ==RatingRounds(user=\"%user%\")==\r\n\r\np=. ! http://infoarena.ro/plot/distribution?user=%user% (Distributie rating %user%) !\r\n\r\n*{\"Ce inseamna si cum se calculeaza rating-ul?\":documentatie/rating}*',13,'protected'),('utilizator/svalentin','Profil svalentin','2006-12-10 12:44:55','h2. Despre mine\r\n\r\n* Age - 18\r\n\r\n* Cont pe deviantart - \'deviantART account\':http://svnightblade.deviantart.com (fotografii)\r\n\r\nh2. Distinctii primite\r\n\r\n* trecut..\r\n* luat recent un premiu 2 la Stelele Informaticii\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* ==User(user=\"wefgef\" type=\"tiny\")==',75,'protected'),('home','infoarena 2','2006-12-10 15:35:47','h1. Bine ai venit!\r\n\r\nAcesta este noul site infoarena. Am inlocuit vechiul infoarena.devnet.ro dupa aproape 3 ani de functionare.\r\nSunt multe de spus despre noua versiune asa ca incepem cu ce e mai important ...\r\n\r\ntable(layout3). | *infoarena este un wiki*\r\nPoti sa schimbi continutul paginilor sau sa faci altele noi.\r\n\'Afla mai multe&hellip;\':documentatie/wiki\r\n| *infoarena iti da rating*\r\nDupa ce participi la concursuri, iti\r\ncalculam rating-ul: un numar care reflecta performantele tale.\r\n\'Afla mai multe&hellip;\':documentatie/rating\r\n| *Forum integrat*\r\nForum-ul ne ajuta sa invatam unii de la altii. De aceea, am avut grija ca acesta sa fie bine integrat in experienta infoarena.\r\n\'Afla mai multe&hellip;\':documentatie/forum |\r\n| *Fa-ti pagina personala*\r\nIti rezervam o pagina personala in care sa te prezinti comunitatii infoarena: cine esti, distinctii primite samd.\r\n\'Afla mai multe&hellip;\':documentatie/pagina-de-profil\r\n| *Un nou evaluator*\r\nEvaluatorul nou masoara mult mai exact timpii de executie. In plus, suporta tipuri noi de probleme si concursuri.\r\n\'Afla mai multe&hellip;\':documentatie/evaluator\r\n| *Mai usor de folosit*\r\nNu in ultimul rand, site-ul infoarena este mai usor de navigat si de folosit.\r\n\'Afla mai multe&hellip;\':documentatie/pentru-utilizatori |\r\n\r\nh2. Feedback\r\n\r\nAjuta-ne sa facem o infoarena ca _Soarele sfant de pe cer_ :) Asteptam bug reports, sugestii, intrebari pe forum. Iata niste topic-uri de feedback:\r\n\r\n==SmfTopics(board_id=\"33\")==\r\n\r\nh2. Puncte de pornire\r\n\r\n* \'Documentatie\':documentatie. Cum se foloseste site-ul infoarena?\r\n* \'Sandbox\':sandbox. Testeaza wiki-ul infoarena!\r\n* \'preONI 2006\':preoni-2006\r\n* \'Pagina administratori\':admin\r\n\r\nh2. Pentru programatori\r\n\r\nInfoarena imbratiseaza mentalitatea open-source: codul nostru sursa este \'liber disponibil\':http://hackers.devnet.ro/browser iar dezvoltarea se face \'public\':http://hackers.devnet.ro.\r\nDaca stii PHP / tehnologii web / webdesign sau vrei sa inveti alaturi de noi, intra pe \"pagina de development\":documentatie/development.\r\n\r\nDe asemenea, infoarena imbratiseaza iepurasii, *nu* broscutele. Vladu imbratiseaza calutii.\r\n\r\nh2. Ultimele stiri\r\n\r\n==News(pager_style=\"none\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':stiri',13,'protected'),('documentatie/wiki','Ghid infoarena: Wiki','2006-12-04 00:56:08','h1. Introducere in wiki\r\n\r\nInfoarena este un site bazat pe wiki, tot continutul nostru este complet editabil. Poti si tu sa editezi, nu trebuie decat sa dai click pe link-ul de editare. Te rugam totusi sa nu editezi aceasta pagina (care face parte din \'documentatie\':documentatie), in schimb poti sa experimentezi in \'groapa cu nisip\':sandbox.\r\n\r\nh2. Textile\r\n\r\nWiki-ul infoarena nu foloseste o sintaxa proprie, in loc ne folosim de \'textile\':http://hobix.com/textile/, un mark-up plain-text foarte puternic si usor de citit. Pentru un ghid complet, vezi \'aici\':documentatie/textile.\r\n\r\n*(TODO)* basic textile intro here, max 20 randuri.\r\n\r\nh2. Macro-uri si template-uri (TODO)\r\n\r\nContinutul paginilor infoarena poate fi imbogatit folosind macro-uri.\r\n\r\nh2. Atasamente (TODO)\r\n\r\nLa orice pagina poti sa atasezi fisiere oarecare. Daca sunt imagini poti sa le faci resize.',13,'public'),('ia_in_ie7','Cum arata infoarena in internet explorer 7','2006-12-10 18:06:57','Momentan sunt 2 buguri vizibile:\r\n\r\n* FIXED -footer afisat prost-\r\n* vezi partea din stanga, problema cu casuta cu utilizatorul pare rezolvata\r\n* bogdan2412: nu e rezolvata la mine... in continuare arata ca in poza.. s-ar putea sa fie prea  !ia_in_ie7?IE7.png.jpg!\r\n* FIXED -inca un bug chiar pe pagina asta - ce se intampla ca daca imaginea nu incape in fereastra -- a se observa spatiul liber intre textul \'footer afisat prost\' si poza; daca fereastra este destul de mare sa incapa poza, spatiul dispare-\r\n',1490,'public'),('documentatie','Documentatie','2006-12-10 17:42:34','h1. Documentatie\r\n\r\nAsta este pagina de inceput a documentatiei, momentan doar un vag outline. Eu propun cate o pagina pentru fiecare dintre subiectele astea.\r\n\r\nh2. Subiecte de acoperit\r\n\r\nPoti sa mai adaugi, dar intai scrie pagina.\r\n\r\n* {\'Wiki\':documentatie/wiki}: Despre formatare.\r\n** {\'Sintaxa Textile\':documentatie/textile}\r\n** {\'Macro-uri\':documentatie/macro-uri} Ce sunt, cum se folosesc, cateva macro-uri comune.\r\n** {\'Conventii de formatare\':documentatie/conventii-de-formatare}: Split later.\r\n* {\'Ghid utilizator\':documentatie/pentru-utilizatori}: Inregistrare, submit, monitor, clasament. Cat mai scurt.\r\n** {\'Monitorul de evaluare\':documentatie/monitorul-de-evaluare}: Ce este si cum se foloseste monitorul de evaluare.\r\n** {\'Trimiterea solutiilor\':documentatie/trimiterea-solutiilor}: Cum se trimit solutii.\r\n** {\'Pagina de profil\':documentatie/pagina-de-profil}: Cum se face o pagina de profil pe infoarena.\r\n* {\'Ghid propunatori\':documentatie/pentru-propunatori}: Cum devii propunator, ce inseamna.\r\n** {\'Editare de probleme\':documentatie/editare-de-probleme}: cum se pun teste, cum se verifica etc.\r\n** {\'Editare de runde\':documentatie/editare-de-runde}: cum sa fac un concurs privat.\r\n* {\'Ghid administrare\':documentatie/administrare}\r\n** {\'Securitate\':documentatie/securitate}\r\n** {\'Development stuff\':documentatie/development}\r\n** {\'Pagini speciale\':documentatie/pagini-de-administrare}',1142,'public'),('template/despre-infoarena','template/despre-infoarena','2006-12-10 20:21:49','(vmenu)*(section) Despre infoarena\r\n* \'Privire generala\':despre-infoarena\r\n* \'Evaluatorul\':evaluatorul\r\n* \'Echipa infoarena\':echipa\r\n* \'Colaboratori infoarena\':colaboratorii\r\n* \'Asociatia infoarena\':asociatia-infoarena\r\n* \'Documentatie\':documentatie',1142,'public'),('problema/adunare','A+B','2006-11-24 04:41:43','==Include(page=\"template/taskheader\" task_id=\"adunare\")==\r\n\r\nAdunare simpla\r\n\r\nh2. Date de Intrare\r\n\r\nDatele de intrare se citesc din fisierul $adunare.in$:\r\n\r\n* pe prima linie un numar intreg $a$\r\n* pe a doua linie un numar intreg $b$\r\n\r\n\r\nh2. Date de Iesire\r\n\r\nDatele de iesire se tiparesc in fisierul $adunare.out$\r\n\r\n* pe prima linie: suma celor doua numere $a + b$\r\n\r\nh2. Restrictii\r\n\r\n* suma celor doua numere nu va depasi niciodata valoarea $2.000.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. adunare.in |_. adunare.out |\r\n| 131\r\n  245\r\n| 376 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"adunare\")==\r\n\r\nh2. Discutii pe forum\r\n\r\n== SmfTopic(topic_id=\"27\") ==',13,'task: adunare'),('clasament-arhiva','Cei mai harnici utilizatori infoarena','2006-12-11 00:52:21','h1. Clasament \'arhiva\':arhiva\r\n\r\nClasamentul arhivei ordoneaza membrii infoarena dupa punctele obtinute rezolvand problemele din arhiva.\r\nAcest clasament reflecta *munca depusa in pregatire* si nu performanta concurentului in regim de concurs.\r\n\r\n== Rankings(rounds=\"arhiva\") ==',13,'protected'),('clasament-rating','Clasament infoarena','2006-12-11 01:03:42','h1. Clasament infoarena\r\n_cei mai bine cotati utilizatori in regim de concurs_\r\n\r\nAcest clasament ordoneaza utilizatorii in functie de *performantele obtinute in regim de concurs*.\r\n\r\n\r\n\r\n== TopRated() ==',13,'public'),('clasament-rating','Clasament rating','2006-12-11 01:10:20','h1. Clasament rating\r\n\r\nAcest clasament ordoneaza utilizatorii dupa *performantele obtinute in regim de concurs*.\r\nDoar o parte din utilizatorii infoarena au participat la concursuri cu rating. Marea majoritate numai cat au rezolvat probleme din arhiva.\r\n\r\n== TopRated() ==',13,'public'),('documentatie','Documentatie','2006-12-10 19:40:18','h1. Documentatie\r\n\r\nAsta este pagina de inceput a documentatiei, momentan doar un vag outline. Eu propun cate o pagina pentru fiecare dintre subiectele astea.\r\n\r\nh2. Subiecte de acoperit\r\n\r\nPoti sa mai adaugi, dar intai scrie pagina.\r\n\r\n* {\'Wiki\':documentatie/wiki}: O introducere in wiki-ul infoarena.\r\n** {\'Sintaxa Textile\':documentatie/textile}: Detalii hardcore despre formatarea cu textile.\r\n** {\'Macro-uri\':documentatie/macro-uri}: Ce sunt, cum se folosesc, cateva macro-uri comune.\r\n** {\'Conventii de formatare\':documentatie/conventii-de-formatare}: Cum anume se foloseste formatarea pentru a ajunge la un look uniform.\r\n* {\'Ghid utilizator\':documentatie/pentru-utilizatori}: Inregistrare, submit, monitor, clasament. Cat mai scurt.\r\n** {\'Monitorul de evaluare\':documentatie/monitorul-de-evaluare}: Ce este si cum se foloseste monitorul de evaluare.\r\n** {\'Trimiterea solutiilor\':documentatie/trimiterea-solutiilor}: Cum se trimit solutii.\r\n** {\'Pagina de profil\':documentatie/pagina-de-profil}: Cum se face o pagina de profil pe infoarena.\r\n* {\'Ghid propunatori\':documentatie/pentru-propunatori}: Cum devii propunator, ce inseamna.\r\n** {\'Editare de probleme\':documentatie/editare-de-probleme}: cum se pun teste, cum se verifica etc.\r\n** {\'Editare de runde\':documentatie/editare-de-runde}: cum sa fac un concurs privat.\r\n* {\'Ghid administrare\':documentatie/administrare}\r\n** {\'Securitate\':documentatie/securitate}\r\n** {\'Development stuff\':documentatie/development}\r\n** {\'Pagini speciale\':documentatie/pagini-de-administrare}',1142,'public'),('documentatie/pagina-de-profil','Pagina de profil.','2006-12-10 17:35:21','h1. Pagina de profil.\r\n\r\n==include(page=\"template/todo\")==\r\n\r\nTot ce trebuie ca sa-ti faci pagina de profil este sa dai click pe link-ul de \'edit\' la pagina ta de profil. Acolo poti scrie absolut orice folosind sintaxa \'wiki-ului infoarena\':documentatie/wiki.\r\n\r\nPoti sa-ti faci pagina sa arate oricum vrei tu, dar incearca sa nu exagerezi. Tine minte ca este pagina cu care te prezinti comunitatii infoarena.\r\n\r\nh2. De ce sa-mi fac pagina de profil?\r\n\r\nInfoarena nu este doar un site cu probleme, infoarena este o comunitate de elevi interesati de programare si algoritmi. Prin pagina de profil poti sa te \"prezinti\" comunitatii infoarena.',1142,'protected'),('documentatie/monitorul-de-evaluare','Monitorul de evaluare','2006-11-30 12:24:07','h1. Monitorul de evaluare\r\n\r\n==include(page=\"template/todo\")==\r\n\r\nh2. Ce este monitorul de evaluare?\r\n\r\nMonitorul de evaluare este o pagina in care poti sa vezi sursele trimise pe infoarena si punctajele obtinute de acestea, ordonate cronologic, prima sursa fiind ultima sursa trimisa. De asemenea poti sa vezi felul in care s-a comportat o sursa pe fiecare test de la problema respectiva. \r\n\r\nh2. Cum se foloseste?\r\n\r\nNu trebuie decat sa intri pe pagina monitorului de evaluare (un link in partea stanga a paginii), si acolo vei gasi toate detaliile.',2993,'public'),('asociatia-infoarena','Asociatia infoarena','2006-11-27 07:21:55','h1. Asociatia infoarena\r\n\r\nAsociatia infoarena (organizatie non-profit) este in curs de constituire. Pe masura ce demersurile se apropie de finalizare vom reveni cu detalii despre statut, membri fondatori, organigrama etc.\r\n\r\nAsociatia confera comunitatii infoarena personalitate juridica. Asociatia ne ajuta &hellip;\r\n\r\n* &hellip; sa primim mai usor sponsorizari din partea companiilor private\r\n* &hellip; sa ne protejam brand-ul infoarena\r\n* &hellip; sa protejam drepturile de autor ale materialelor contribuite de comunitate\r\n',13,'public'),('despre-infoarena','Despre infoarena','2006-12-11 03:19:46','==include(page=\"template/despre-infoarena\")==\r\n\r\nh1. Despre infoarena\r\n\r\n*infoarena ajuta elevi si studenti sa devina excelenti in informatica!* Gratuit ;)\r\n\r\nh2. Cu ce ne ocupam?\r\n\r\n* Concursuri online de informatica pentru studenti si elevi\r\n* Stiri si articole despre informatica\r\n* Discutam pe forum tot despre informatica\r\n* Cateodata organizam concursuri on-site.\r\n\r\ninfoarena functioneaza din 2002 si este dezvoltata de noi, echipa infoarena.\r\nSuntem o mana de studenti si elevi innebuniti de info. Tinem neaparat sa-i ajutam si pe altii sa innebuneasca :)\r\n\r\nComunitatea noastra cuprinde aproape toti elevii romani ce participa la concursuri de informatica nationale si internationale. Ne mandrim cu valoarea concursurilor si a materialelor prezentate pe site.\r\n\r\nDemn de mentionat este evaluatorul infoarena, un program care evalueaza solutiile trimise de concurenti. Evaluatorul iti spune aproape instantaneu daca (si cat de bine) ai rezolvat o problema (\"vezi Evaluator\":documentatie/evaluator).\r\n\r\nh2. Citate\r\n\r\n&nbsp;\r\n\r\nbq. People have been known to achieve more as a result of working with others than against them.\r\n\r\n*Dr. Allan Fromme*\r\n\r\n&nbsp;\r\n\r\nbq. infoarena este un proiect remarcabil, realizat cu entuziasm, generozitate si profesionalism. Este locul in care tinerii pasionati de informatica se pot intalni, atat de o parte, cat si de cealalta parte a baricadei, ca propunatori sau ca rezolvitori de probleme, isi pot impartasi experienta competitionala, pot constitui modele, pot ajuta la formarea a noi si noi generatii de performanta.\r\n\r\n*Emanuela Cerchez*\r\nCoordonator stiintific in Comisia Nationala de Informatica, Prof. grad I - Lic. de Informatica \"Grigore Moisil\" Iasi\r\n\r\n&nbsp;\r\n\r\nbq. infoarena e plin de energie, e dinamic si riguros, gratie unei echipe curajoase. Site-ul infoarena reprezinta cea mai originala forma de pregatire pe net a performerilor in informatica din Romania. Mecanism de lucru excelent, probleme propuse, fara cusur. Felicitari!\r\n\r\n*Emil Onea*\r\nInspector scolar informatica, Comisia Nationala de Informatica pentru Invatamant Preuniversitar\r\n',13,'public'),('regulament','Regulament','2006-12-11 03:20:23','h1. Regulamentul infoarena\r\n\r\n==include(page=\"template/despre-infoarena\")==\r\n\r\nIn afara de regulile de bun simt, pe care nu le scriem aici, la infoarena nu sunt prea multe restrictii&hellip;\r\n\r\n# *Distrati-va cat mai mult!* Faceti cunostinta cu alti oameni care va impartasesc interesele.\r\n# Castigati cat mai multe premii la concursurile gazduite aici.\r\n# Nu incercati sa trisati! Nu este distractiv. In plus, se penalizeaza cu descalificare.',13,'public'),('despre-infoarena','Despre infoarena','2006-12-11 03:19:57','h1. Despre infoarena\r\n\r\n==include(page=\"template/despre-infoarena\")==\r\n\r\n*infoarena ajuta elevi si studenti sa devina excelenti in informatica!* Gratuit ;)\r\n\r\nh2. Cu ce ne ocupam?\r\n\r\n* Concursuri online de informatica pentru studenti si elevi\r\n* Stiri si articole despre informatica\r\n* Discutam pe forum tot despre informatica\r\n* Cateodata organizam concursuri on-site.\r\n\r\ninfoarena functioneaza din 2002 si este dezvoltata de noi, echipa infoarena.\r\nSuntem o mana de studenti si elevi innebuniti de info. Tinem neaparat sa-i ajutam si pe altii sa innebuneasca :)\r\n\r\nComunitatea noastra cuprinde aproape toti elevii romani ce participa la concursuri de informatica nationale si internationale. Ne mandrim cu valoarea concursurilor si a materialelor prezentate pe site.\r\n\r\nDemn de mentionat este evaluatorul infoarena, un program care evalueaza solutiile trimise de concurenti. Evaluatorul iti spune aproape instantaneu daca (si cat de bine) ai rezolvat o problema (\"vezi Evaluator\":documentatie/evaluator).\r\n\r\nh2. Citate\r\n\r\n&nbsp;\r\n\r\nbq. People have been known to achieve more as a result of working with others than against them.\r\n\r\n*Dr. Allan Fromme*\r\n\r\n&nbsp;\r\n\r\nbq. infoarena este un proiect remarcabil, realizat cu entuziasm, generozitate si profesionalism. Este locul in care tinerii pasionati de informatica se pot intalni, atat de o parte, cat si de cealalta parte a baricadei, ca propunatori sau ca rezolvitori de probleme, isi pot impartasi experienta competitionala, pot constitui modele, pot ajuta la formarea a noi si noi generatii de performanta.\r\n\r\n*Emanuela Cerchez*\r\nCoordonator stiintific in Comisia Nationala de Informatica, Prof. grad I - Lic. de Informatica \"Grigore Moisil\" Iasi\r\n\r\n&nbsp;\r\n\r\nbq. infoarena e plin de energie, e dinamic si riguros, gratie unei echipe curajoase. Site-ul infoarena reprezinta cea mai originala forma de pregatire pe net a performerilor in informatica din Romania. Mecanism de lucru excelent, probleme propuse, fara cusur. Felicitari!\r\n\r\n*Emil Onea*\r\nInspector scolar informatica, Comisia Nationala de Informatica pentru Invatamant Preuniversitar\r\n',13,'public'),('documentatie/development','Development','2006-11-27 21:14:40','h1. Development\r\n\r\ninfoarena imbratiseaza mentalitatea open-source: codul nostru sursa este \'liber disponibil\':http://hackers.devnet.ro/browse iar dezvoltarea se face \'public\':http://hackers.devnet.ro.\r\n\r\nh2. Stii PHP/tehnologii web/design sau vrei sa inveti?\r\n\r\nAvem nevoie de ajutorul tau! Instaleaza-ti infoarena pe calculatorul tau si rezolva un \"ticket\":http://hackers.devnet.ro/report/3.\r\nAm documentat intreg procesul, am scris tutoriale, am comentat codul sursa, am planificat tichete si suntem alaturi de tine daca ai intrebari.\r\n\r\n\"Click aici - doar pentru programatori\":http://hackers.devnet.ro/\r\n\r\nh2. Pe cine poti contacta\r\n\r\nDaca vrei sa contribui si ai nelamuriri, contacteaza pe unul (sau mai multi :) dintre cei care lucreaza la codul sursa infoarena.\r\n\r\n* ==user(user=\"fluffy\" type=\"tiny\")==\r\n* ==user(user=\"wickedman\" type=\"tiny\")==\r\n* ==user(user=\"domino\" type=\"tiny\")==\r\n* ==user(user=\"DITzoneC\" type=\"tiny\")==\r\n* ==user(user=\"svalentin\" type=\"tiny\")==\r\n\r\nPe paginile lor vei gasi informatii de contact (email, IM).',13,'public'),('documentatie/borderoul-de-evaluare','Borderoul de evaluare','2006-11-27 23:25:54','h1. Borderoul de evaluare\r\n\r\n==include(page=\"template/todo\")==\r\n\r\nBorderoul de evaluare prezinta informatii despre cum a decurs evaluarea unei solutii trimise de un concurent. Borderoul include timpul de executie, numarul de puncte obtinute la fiecare test si, uneori, mesaje de compilare sau de rulare (runtime) ale solutiei.\r\n\r\nh2. Mesaje de eroare\r\n\r\n* *OK* (sau un mesaj asemanator): programul tau a mers corect pe testul respectiv si ai primit punctele care le meritai.\r\n* *Wrong Answer*, *Raspuns gresit* (sau un mesaj asemanator): programul tau a terminat executia, dar raspunsul oferit nu a fost corect; verifica daca ai respectat intocmai cum este precizat in enunt formatul fisierului de iesire cat si formatul fisierului de intrare cand efectuezi citirea\r\n* *Time Limit Exceeded*: programul tau a depasit timpul de executie permis pentru testul respectiv; cele mai dese cauze pentru acest mesaj sunt: algoritmul folosit este ineficient, fie programul tau contine bucle care se executa la infinit, fie programul tau incearca sa citeasca de la tastatura, etc.\r\n* *System Error* (sau un mesaj asemanator): acest mesaj nu ar trebui sa apara. ==SmfLink(link=\"board\" board=\"33\" caption=\"Anunta echipa infoarena!\")==\r\n* *Missing output file* (sau un mesaj asemanator): programul tau nu a creat un fisier de iesire, sau in cazul in care a creat un fisier, nu a avut numele specificat in enuntul problemei.\r\n* *Runtime Error - Invalid memory reference*: acest mesaj se poate referi la faptul ca depasesti limita de memorie disponibila (care este de 1 MB pentru stiva si 63 MB pentru heap) sau acces invalid in memorie, accesarea unui pointer invalid, indecsi intr-un tablou care depasesc dimensiunile tabloului, etc.\r\n* *Runtime Error*: cele mai cunoscute cauze pentru astfel de mesaje sunt depasirea stivei, accesarea unor fisiere gresite, erori cu numere reale, impartire la 0, etc. Un mesaj foarte intalnit este SIGKILL si semnifica ca programul tau a fost oprit de evaluator datorita unei erori ca cele descrise mai sus.\r\n\r\nh2. Greseli frecvente\r\n\r\n* nu sterge ecranul si nu scrie nimic pe iesirea standard (ecran). Solutiile trimise sunt corectate automat de sistemul de evaluare. Acesta nu ia in considerare informatiile tiparite pe ecran ci doar cele scrise in fisierul de iesire specificat in descrierea problemei.\r\n* nu folosi functii care asteapta apasarea unei taste sau introducerea unei valori de la tastatura ($getch$, $readkey$, $readln$ etc.) Solutiile trimise sunt corectate automat de sistemul de evaluare. Sursele care folosesc astfel de functii vor primi punctaj $0$ pentru timp de executie depasit!\r\n* foloseste doar librariile standard pentru rezolvarea problemelor, adica cele care vin odata cu distributia limbajului de programare. Vezi \"lista oficiala de compilatoarele\":documentatie/evaluator folosite la infoarena.\r\n* *numele fisierelor este case sensitive!* Prin conventie, toate fisierele de intrare si de iesire vor avea nume in lowercase (fara majuscule).\r\n\r\nh2. Pentru programatorii C/C++\r\n\r\n* Tipul $int$ din GNU GCC este pe $32$ de biti, nu $16$ ca in Borland C/C++, $char$ pe $8$ biti, $short$ pe $16$ biti, $long$ pe $32$, $long long$ pe $64$ de biti.\r\n* Foloseste sprintf in loc de itoa sau ltoa.\r\n* Programul de evaluare ruleaza pe un sistem de operare UNIX. Foloseste $\"\\n\"$ pentru terminarea liniei curente, nu $\"\\r\\n\"$.\r\n* Functia $main$ trebuie sa fie de tip $int$ si sa intoarca $0$ - $return 0;$\r\n* Nu folosi librarii dependente de sistemul de operare (ex. $dos.h$, $graphics.h$). Foloseste evaluatorul pentru a descoperi care sunt acestea.\r\n* No folosi modificatorii $far$, $huge$, $_huge$, $__huge$ pentru ca nu exista in GNU GCC. De asemenea, nu exista nici functiile care folosesc aceste tipuri de date (de ex. $farmalloc$, $farfree$ etc.) si nici conceptul de memory model (tiny, small, medium, large, huge). De toate acestea nu mai e nevoie intrucat ai acces la toata memoria prin functii standard si pointer-i standard - $new$, $delete$, $malloc$ etc. \r\n\r\nh2. Pentru programatorii Pascal\r\n\r\n* Nu folosi nici unul din unit-urile $dos$, $crt$ sau $graph$! Nu ai nevoie de nici unul din ele pentru a rezolva problemele de aici. Programul nu va compila!\r\n',1142,'public'),('utilizator/domino','Profil domino','2006-12-12 17:14:19','\r\nh2. Despre mine\r\n\r\nStudii: \r\n* Colegiul National \"I. L. Caragiale\" Ploiesti\r\n* Universitatea Bucuresti, Facultatea de informatica\r\nProfesori pregatitori: Dana Lica\r\n\r\nh2. Distinctii primite\r\n\r\n*2006 (clasa a XII-a):*\r\n\r\n* Premiul I la etapa judeteana de informatica\r\n* Premiul II la concursul international de programare on-line Bitwise (http://www.bitwise.iitkgp.ernet.in/), in echipa cu Adrian Vladu ?? concurentii au fost majoritatea studenti\r\n* Locul I la concursul international USACO februarie 2006 (http://ace.delos.com/FEB06results), folosit si pentru selectarea lotului national de informatica din S.U.A.\r\n* Locul I la concursul international USACO martie 2006 (http://ace.delos.com/FEB06results), folosit si pentru selectarea lotului national de informatica din S.U.A.\r\n* Invitat alaturi de lotul american de informatica la USA International Computing Olympiad 2006 \r\n* Locul I la Olimpiada Nationala de Informatica, Targoviste\r\n* Locul al III-lea la faza finala a concursului international \".campion\"\r\n* Medalie de argint la Olimpiada Central Europeana de Informatica,Vrsar, Croatia, 8 iulie\r\n* Medalie de aur (locul 7) la Olimpiada Internationala de Informatica, Merida, Mexic, 20 august\r\n\r\n*2005 (clasa a XI-a):*\r\n\r\n* Premiul I la etapa judeteana de informatica\r\n* Locul I la Olimpiada Nationala de Informatica, Galati\r\n* Locul al IV-lea (premiu special) la faza finala a concursului national \".campion\",14-19 aprilie\r\n* Medalie de argint la Olimpiada Internationala de Informatica, Nowy Sacz, Polonia, 18 august\r\n* Premiul III la Concursul National \"Stelele Informaticii\", Bucuresti, 3-4 decembrie\r\n\r\n*2004 (clasa a X-a):*\r\n\r\n* Premiul I la etapa judeteana de informatica\r\n* Mentiune la Olimpiada Nationala de Informatica, Buzau (locul 4)\r\n* Premiul al III-lea la faza finala a concursului national \".campion\", 16 aprilie\r\n* Diploma de onoare pentru rezultate deosebite in Invatamantul de Excelenta Prahovean,17 mai\r\n* Mentiune la Concursul National de Informatica PACO, programare, 29 mai\r\n* Locul al II-lea la Concursul National de Soft \"Grigore Moisil\", Lugoj, programare, 13 iunie\r\n* Medalie de argint la Olimpiada Balcanica de Informatica, Plovdiv, Bulgaria, 9 iulie\r\n* Locul al II-lea la faza finala a concursului international \"Bursele Agora\", 25 septembrie\r\n\r\n*2003 (clasa a IX-a):*\r\n\r\n* Premiul al II-lea la etapa judeteana de informatica\r\n* Diploma de excelenta pentru rezultate la informatica in cadrul Centrului de Excelenta Ploiesti\r\n* Premiul I  la Olimpiada Nationala de Informatica, Focsani	\r\n* Diploma de Onoare oferita de grupul \"Romanians at Microsoft\", aprilie\r\n* Diploma de Merit pentru calificarea in lotul Olimpic National  de Informatica al Romaniei \r\n* Premiul I la Concursul National de Informatica InfoKids, Bucuresti, programare, 1 iunie\r\n* Diploma Excellentia pentru rezultate la Olimpiada Nationala de Informatica, 13 iunie\r\n* Premiul I la Concursul National \"Stelele Informaticii\", Bucuresti, noiembrie\r\n* Diploma \"Elevul Anului 2003\" pentru reprezentarea merituoasa a invatamantului ploiestean\r\n\r\n*2002 (clasa a VIII-a):*\r\n\r\n* Premiul I la Concursul National de Informatica InfoKids, Bucuresti, programare, 22 martie\r\n* Locul al II-lea la Olimpiada Nationala de Informatica pe Internet, Braila, clasa a IX-a\r\n* Premiul al II-lea la Concursul National de Soft \"Grigore Moisil\", Lugoj, programare\r\n* Premiul I la etapa judeteana de informatica, 8 iunie\r\n* Premiul I la Concursul National de Informatica PACO, Bucuresti, programare, 17 iulie \r\n* Locul I la Concursul National de Programare de la Satu Mare, 12 octombrie\r\n* Diploma de onoare acordata in cadrul Concursul National de Programare de la Satu Mare\r\n* Diploma acordata de Fundatia \"Excellentia 21\" Ploiesti pentru rezultate deosebite, octombrie \r\n\r\n*2001 (clasa a VII-a):*\r\n\r\n* Premiul al II-lea la etapa judeteana de limba engleza, 28 aprilie\r\n* Premiul I la Concursul National de Soft \"Grigore Moisil\", Lugoj, sectiunea pagini web\r\n* Premiul al III-lea la Concursul National de Soft \"Grigore Moisil\", Lugoj, sectiunea software\r\n* Locul al III-lea la Concursul National \"Multimedia & Games\", sectiunea jocuri, 12 iulie\r\n* Locul al II-lea la Concursul National \"Multimedia & Games\", sectiunea pagini web, 12 iulie\r\n* Premiul al III-lea la Concursul National de Informatica pentru gimnaziu, Galaciuc, august\r\n* Mentiune la Concursul National de Informatica de la Piatra-Neamt, 1 septembrie\r\n* Premiul I la Concursul National de Informatica PACO, Bucuresti, programare, 14 septembrie\r\n* Premiul II la Concursul National de Informatica PACO, Bucuresti, pagini web, 14 septembrie\r\n\r\n*2000 (clasa a VI-a):*\r\n\r\n* Premiul al III-lea la etapa judeteana de matematica, 13 mai\r\n* Premiul al II-lea la Concursul National de Soft \"Grigore Moisil\", Lugoj, sectiunea software\r\n* Mentiune la Concursul National de Soft \"Grigore Moisil\",Lugoj,sectiunea programare cls 5-6\r\n* Premiul I la Olimpiada Judeteana de Informatica (la clasele a VI-a, a VII-a si a VIII-a),14 mai\r\n* Premiul al III-lea la Concursul National de Informatica de la Piatra-Neamt, iunie\r\n* Premiu Special la Concursul National INFOeducatie Galaciuc, 17 iulie\r\n1999 (clasa a V-a):\r\n* Premiul I la etapa judeteana de informatica, 22 mai\r\n1998 (clasa a IV-a):\r\n* Premiul al III-lea la etapa judeteana de matematica, 16 mai\r\n\r\n',1,'protected'),('sandbox','Sandbox','2006-12-11 11:16:36','h1. Sandbox\r\n\r\nFeel free to play around.\r\n\r\nCapsuni.\r\n\r\n\'codetest\':sandbox/code-test\r\n\r\nWhat does \'this\':sandbox?action=edit button do?\r\n\r\nlalallaa\r\n\r\nIntrebare: cum poti seta culoarea cu care scrii? Cu tagurile HTML am incercat si nu merge.\r\n\r\nSiteul sub IE 7 -- vezi \'pagina dedicata\':ia_in_ie7\r\n\r\nSiteul sub FF 2 - mica problema panoul de \'editeaza\', \'vezi istoria\', \'sterge\' etc (in IE7 panoul nu se suprapune)\r\n!sandbox?IA_bug_in_FF2.jpg!',2963,'public'),('documentatie/wiki','Ghid infoarena: Wiki','2006-12-11 11:01:55','h1. Introducere in wiki\r\n\r\n== include(page=\"template/todo\")==\r\n\r\nInfoarena este un site bazat pe wiki, tot continutul nostru este complet editabil, cu unele exceptii. Poti si tu sa editezi, nu trebuie decat sa dai click pe link-ul de editare. Te rugam totusi sa nu editezi aceasta pagina (care face parte din \'documentatie\':documentatia oficiala), in schimb poti sa experimentezi in \'groapa cu nisip\':sandbox.\r\n\r\nSperam ca spre deosebire de infoarena1 noul site sa fie mai dinamic si accesibil.\r\n\r\nh2. Cum se editeaza\r\n\r\nAre rost sa explicam preview, istorie, vrajeli de genul asta?\r\n\r\nh2. Textile\r\n\r\nWiki-ul infoarena nu foloseste o sintaxa proprie, in loc ne folosim de \'textile\':http://hobix.com/textile/, un mark-up plain-text foarte puternic si usor de citit. Folosind textile paginile din infoarena sunt simplu de editat si arata foarte \"curat\".\r\n\r\nO scurta introducere in textile (vezi \'ghidul complet\':documentatie/textile):\r\n\r\n* Poti sa marchezi anumite fraze/cuvinte/etc cu modificatori inline. Spre exemplu poti sa pui *&#42;bold&#42;*, _&#95;italic&#95;_, +&#43;underline&#43;+, ^&#94;superscript&#94;^ si ~&#126;subscript&#126;~. Textile in general aplica aceaste formatari doar cand sunt separate prin punctuatie, etc. Poti sa fortezi formatarea folosin acolade: al{*&#123;&#42;aba&#42;&#125;*}la.\r\n\r\n* Textile imparte codul in blocuri separate prin linii goale. Poti si pui diverse declaratii pentru a formata blocul. \"h1.\", \"h2. \" fac headere, \"bq. \" face citat, etc.\r\n\r\n* Poti sa faci liste cu sau fara numere punand pe fiecare linie # sau respectiv *.\r\n\r\n* Link-urile se fac cu o sintaxa de genul @\'nume link\':http://adresa/@. Daca adresa nu contine http:// in fata este considerat un link intern infoarena.\r\n\r\n* Imaginilie sunt introduse cu sintaxa @!http://adresa/!@ pentru imagini externe sau @!pagina@atasament!@ pentru o imagine infoarena. Poti sa redimensionezi automat imaginile cu @!home?rabbits.jpg 50x50!@. !>home?rabbits.jpg 100x100!\r\n\r\nPentru o descriere amanuntita a sintaxei de textile \'vezi aici\':documentatie/textile.\r\n\r\nh2. Macro-uri\r\n\r\nContinutul paginilor infoarena poate fi imbogatit folosind macro-uri. Macro-uri sunt introduse cu sintaxa @==MacroName(a1=\"b1\" a2=\"b2)==@. *Atentie:* sintaxa este foarte fragila, vezi \'o explicatie completa\':documentaties/macro-uri.\r\n\r\nCateva exemple de ce poti face cu macro-uri:\r\n\r\n* Link-uri la utilizatori: @==user(user=\"chucknorris\" type=\"tiny\")==@ ==user(user=\"chucknorris\" type=\"tiny\")==.\r\n\r\n* Clasamente: *todo*\r\n\r\n* Liste de posturi din forum: *todo*.',4772,'public'),('utilizator/azotlichid','Profil azotlichid','2006-12-12 19:21:37','h1. == userinfo(user=\"azotlichid\" info=\"fullname\") ==\r\n\r\n== include(page=\"template/userinfo\" user_id=\"azotlichid\") ==\r\n\r\n== include(page=\"template/userstats\" user_id=\"azotlichid\") ==\r\n\r\n== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n* The last affirmation is true.\r\n\r\nh2. Distinctii primite\r\n\r\n* This text does not exist.\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* The first affirmation is false.',18,'protected'),('utilizator/slayerdme','Profil slayerdme','2006-11-27 01:29:29','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1975,'protected'),('utilizator/slayerdme','Profil slayerdme','2006-12-13 15:28:44','== include(page=\"utilizator/slayerdme/test.html\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',1975,'protected'),('utilizator/azotlichid','Profil azotlichid','2006-12-13 22:09:39','h2. Despre mine\r\n\r\n* Yes.\r\n* No.\r\n\r\nh2. Distinctii primite\r\n\r\n* This text does not exist.\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* ==User(user=\"chucknorris\" type=\"tiny\")==\r\n* ==User(user=\"eval\" type=\"tiny\")==\r\n\r\n',18,'protected'),('sandbox','Sandbox','2006-12-13 15:34:26','h1. Sandbox\r\n\r\nFeel free to play around.\r\n\r\nCapsuni.\r\n\r\n\'codetest\':sandbox/code-test\r\n\r\nWhat does \'this\':sandbox?action=edit button do?\r\n\r\nlalallaa\r\n\r\nIntrebare: cum poti seta culoarea cu care scrii? Cu tagurile HTML am incercat si nu merge.\r\n\r\nSiteul sub IE 7 -- vezi \'pagina dedicata\':ia_in_ie7\r\n\r\nSiteul sub FF 2 - mica problema panoul de \'editeaza\', \'vezi istoria\', \'sterge\' etc (in IE7 panoul nu se suprapune)\r\n!sandbox?IA_bug_in_FF2.jpg!\r\n\r\n[test]\r\n*OMG* test, good work people :D\r\nAcuma doar trebuie putin stimulata comunitatea\r\n[/test]',1975,'public'),('home','infoarena 2','2006-12-11 18:42:03','h1. Bine ai venit!\r\n\r\np. Acesta este *noul site infoarena*! Am inlocuit vechiul infoarena.devnet.ro dupa aproape 3 ani de functionare.\r\nSunt multe de spus despre noua versiune asa ca incepem cu ce e mai important ...\r\n\r\ntable(layout3). | *infoarena este un wiki*\r\nSchimba continutul paginilor sau sa creaza pagini noi.\r\n\'Afla mai multe&hellip;\':documentatie/wiki\r\n| *infoarena iti da rating*\r\nIti calculam rating-ul: un numar care reflecta performantele tale.\r\n\'Afla mai multe&hellip;\':documentatie/rating\r\n| *Forum integrat*\r\nAm avut grija ca forum-ul sa fie bine integrat in experienta infoarena.\r\n\'Afla mai multe&hellip;\':documentatie/forum |\r\n| *Fa-ti pagina personala*\r\nPrezinta-te comunitatii infoarena: cine esti, de unde vii, distinctii primite etc.\r\n\'Afla mai multe&hellip;\':documentatie/pagina-de-profil\r\n| *Un nou evaluator*\r\nEvaluatorul nou masoara mai exact timpii de executie si suporta tipuri noi de probleme si concursuri.\r\n\'Afla mai multe&hellip;\':documentatie/evaluator\r\n| *Mai usor de folosit*\r\nNoul infoarena este mai usor de navigat si de folosit.\r\n\'Afla mai multe&hellip;\':documentatie/pentru-utilizatori |\r\n\r\nh2. Ne trebuie feedback!\r\n\r\nNe asteptam sa gasim multe bug-uri si deficiente in noua versiune. Ajuta-ne sa facem o infoarena ca _Soarele sfant de pe cer_ :)\r\nAsteptam bug reports, sugestii, intrebari pe forum. Iata niste topic-uri de feedback:\r\n\r\n==SmfTopics(board_id=\"33\")==\r\n\r\nh2. Ce este infoarena?\r\n\r\ninfoarena este un site web care ajuta elevi si studenti sa obtina performanta in informatica! \'Afla mai multe&hellip;\':despre-infoarena\r\n\r\nCu ce ne ocupam?\r\n\r\n* Concursuri online de informatica pentru studenti si elevi\r\n* Stiri si articole despre informatica\r\n* Discutam pe forum tot despre informatica\r\n\r\nh2. Pentru programatori PHP / web\r\n\r\nSite-ul si evaluatorul infoarena sunt open-source! Codul sursa este \'liber disponibil\':http://hackers.devnet.ro/browser/trunk/infoarena2 iar dezvoltarea se face \'public\':http://hackers.devnet.ro.\r\n\r\nDaca stii PHP / tehnologii web / webdesign sau vrei sa inveti alaturi de noi, intra pe \"pagina de development\":documentatie/development. \r\n\r\nh2. Ultimele Stiri\r\n\r\n==News(pager_style=\"none\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':stiri',75,'protected'),('utilizator/ditzonec','Profil DITzoneC','2006-11-27 01:25:48','== include(page=\"template/noprofile\") ==\r\n\r\nh2. Despre mine\r\n\r\n_(completeaza aici: studii, an de absolvire, institutie de invatamant, locatie, profesori pregatitori, site personal ...)_\r\n\r\nh2. Distinctii primite\r\n\r\n* _(completeaza aici: locuri obtinute la concursuri de informatica)_\r\n\r\nh2. Prieteni pe infoarena\r\n\r\n* _(completeaza aici: link-uri catre profilele altor utilizatori infoarena pe care ii cunosti)_\r\n',961,'protected'),('problema/arbore','Arbore','2006-11-11 14:57:55','==Include(page=\"template/taskheader\" task_id=\"arbore\")==\r\n\r\nO firma are $N$ angajati numerotati de la $1$ la $N$. Angajatii sunt ierarhizati sub forma de arbore (graf conex fara cicluri). Astfel, fiecare angajat are exact un sef direct (cu exceptia patronului firmei), iar un anumit angajat poate avea mai multi subordonati directi. Patronul firmei este numerotat cu $1$. Un angajat $A$ este subordonatul unui alt angajat $B$ daca una din urmatoarele conditii este indeplinita:\r\n\r\n* $A$ este subordonat direct al lui $B$\r\n* $A$ este unul dintre subordonatii unui alt subordonat de-al lui $B$\r\n\r\nDatorita profiturilor foarte mari obtinute de firma, angajatii vor primi anumite sume de bani drept bonus. Pentru a avea o evidenta stricta, contabilul firmei trebuie sa efectueze M operatii de doua tipuri:\r\n\r\n# dandu-se $p$ si {$s$}, toti subordonatii nodului $p$ (inclusiv nodul {$p$}) vor primi suma de bani $s$\r\n# dandu-se un numar {$s$}, el trebuie sa afle un angajat care a primit pana la momentul respectiv suma $s$\r\n\r\nMentionam ca unii angajati pot fi recompensati de mai multe ori, iar altii pot sa nu primeasca nimic.\r\n\r\nh2. Cerinta\r\n\r\nScrieti un program care primeste {$N$}, {$M$}, structura angajatilor si cele $M$ operatii iar pentru fiecare operatie de tipul $2$ afiseaza valoarea ceruta.\r\n\r\nh2. Date de Intrare\r\n\r\nFisierul $arbore.in$ contine pe prima linie numerele $N$ si $M$ separate printr-un spatiu.\r\nUrmatoarele $N-1$ linii contin cate doua numere intregi $p$ si $q$ cu semnificatia ca \"exista relatie directa intre angajatul $p$ si angajatul {$q$}\". \r\nUrmatoarele $M$ linii cotin cate o operatie pe linie. Primul numar de pe linie este $1$ sau {$2$}, si semnifica tipul operatiei ce va fi descrisa. In cazul unei operatii de tip $1$ vor urma numerele $p$ si {$s$}, iar in cazul unei operatii de tip $2$ va urma un singur numar {$s$}.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul $arbore.out$ contine pentru fiecare operatie de tip $2$ indicele unui angajat care a primit suma respectiva de bani pana la momentul respectiv. In cazul in care nu exista un asemenea angajat, se cere sa se afiseze {$-1$}. Nu are importanta indicele carui angajat il veti afisa, atata timp cat acesta a primit suma {$s$}.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N, M &le; 100 000$\r\n* pentru o operatie de tipul $1$ avem $1 &le; s &le; 10$\r\n* pentru o operatie de tipul $2$ avem $0 &le; s &le; 1 000 000$\r\n* $50%$ dintre testele folosite la evaluare nu vor contine mai mult de $100$ de operatii de tip $2$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. arbfind.in |_. arbfind.out |\r\n| 6 6\r\n1 2\r\n1 3\r\n3 4\r\n3 5\r\n4 6\r\n1 1 1\r\n1 2 4\r\n2 5\r\n2 1\r\n1 3 3\r\n2 4\r\n| 2\r\n1\r\n3 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"arbore\")==',961,'task: arbore'),('problema/bridge','Bridge','2006-11-11 16:49:18','==Include(page=\"template/taskheader\" task_id=\"bridge\")==\r\n\r\nFat-Frumos a plecat in cautarea iubirii sale, fiica imparatului, Simona, care a fost rapita de balaurul cel rau si dusa in pestera acestuia. Acesta s-a pregatit intens de lupta insa el nu a stiut ca balaurul ii pregatise o surpriza, si astfel l-a atras pe acesta pe un pod. Pe pod Fat-Frumos se poate deplasa pasind (se va deplasa o scandura la dreapta), sarind (se va deplasa $2$ scanduri la dreapta), stationand (va ramane pe aceeasi scandura) sau teleportandu-se (vezi scandura teleportoare). Insa podul este putin mai ciudat fiind format din $4$ tipuri de scanduri astfel:\r\n\r\n* $0$ - scandura buna (pe o astfel de scandura se poate stationa, pasi, sari sau teleporta, si se poate ajunge oricum pe ea)\r\n* $1$ - scandura subreda (la fel ca la o scandura buna, numai ca pe acest tip de scandura nu se poate ajunge decat prin pasire)\r\n* $2$ - scandura lipsa (Daca Fat-Frumos va ajunge pe o astfel de scandura el va ajunge felul principal al crocodililor de sub pod)\r\n* $3$ - scandura teleportoare (pe astfel de scandura se poate ajunge oricum, iar o astfel de scandura il va teleporta pe eroul nostru pe o alta scandura numita scandura destinatie)\r\n\r\nh2. Cerinta\r\n\r\nFat-Frumos va trebui sa isi coordoneze miscarile cat mai bine pe pod de aceea va roaga pe voi sa ii raspunde-ti la $M$ intrebari de forma \"In cate moduri pot ajunge pe scandura $X$ in $K$ pasi?\"\r\n\r\nh2. Date de Intrare\r\n\r\nPe prima linie a fisierului bridge.in vor fi scrise $2$ numere $N$ si $M$ reprezentand numarul de scanduri respective numarul de intrebari. Pe urmatoarea linie vor fi scrise N numere cuprinse intre $0$ si $3$ reprezentand configuratia podului, corespondenta fiind cea de mai sus. Pe urmatoarele linii vor fi scrise scandurile destinatie pentru fiecare scandura teleportoare in ordinea aparitiei acestora pe pod, si, in final, pe urmatoarele $M$ linii vor fi scrise cate $2$ numere $X$ si $K$ care definesc o intrebare de genul \"In cate moduri se poate ajunge pe scandura $X$ in $K$ pasi?\".\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $bridge.out$ va contine $M$ linii reprezentand raspunsul pentru fiecare intrebare din fisierul de intrare in ordine.\r\n\r\nh2. Restrictii si Precizari\r\n\r\n* $1 < N < 4001$\r\n* $1 < M < 30001$\r\n* Numarul maxim de pasi dintr-o intrebare nu va depasi valoarea $4000$\r\n* Daca scandura $x$ este teleportoare si are ca destinatie scandura $y$ atunci vom avea urmatoarea relatie $x < y$\r\n* Mai multe scanduri teleportoare pot avea ca destinatie aceeasi scandura\r\n In momentul in care Fat-Frumos ajunge pe o scandura teleportoare el va fi teleportat pe scandura destinatie indiferent daca el vrea sau nu (nu poate stationa, sari sau pasi de pe ea)\r\n* Teleportarea se considera pas\r\n* Raspunsurile se vor afisa modulo $666013$\r\n* Numarul de moduri de a ajunge pe o scandura lipsa sau pe o scandura teleportoare care are ca destinatie o scandura lipsa sau subreda este 0\r\n* Fat-Frumos nu se poate deplasa inapoi (el la un pas se va deplasa {$0$},{$1$} sau $2$ scanduri la dreapta sau va fi teleportat in cazul in care scandura respective are aceasta propietate)\r\n* Initial Fat-Frumos se afla in afara podului pozitie pe care nu poate stationa, la primul pas el ori va pasi pe prima scandura ori va sari pe cea de-a doua daca acest lucru este posibil\r\n* Prima scandura nu este niciodata lipsa\r\n* Pe o scandura teleportoare se poate ajunge ca si pe o scandura buna\r\n* Daca o scandura teleportoare nu are ca scandura destinatie o scandura lipsa sau subreda atunci numarul de moduri de a ajunge pe aceasta in K pasi nu este neaparat $0$ (vezi exemplu)\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. bridge.in |_. bridge.out |\r\n| 5 3\r\n0 0 3 1 2\r\n4\r\n4 4\r\n2 3\r\n3 2\r\n| 0\r\n3\r\n0 |\r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"bridge\")==',961,'task: bridge'),('downloads','Downloads','2006-12-15 11:10:20','h1. Downloads\r\n\r\nh2. OJI (5 link-uri)\r\n\r\n* \'OJI 2001\':downloads?subiecteJudete.zip ( _613095_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele de la Olimpiada Judeteana de Informatica, anul 2001.\r\n* \'OJI 2002\':downloads?oji2002.zip ( _798994_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale la Olimpiada Judeteana de Informatica, anul 2002.\r\n* \'OJI 2003\':downloads?oji2003.zip ( _1097174_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale la Olimpiada Judeteana de Informatica, anul 2003.\r\n* \'OJI 2004\':downloads?oji2004.zip ( _744932_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale la Olimpiada Judeteana de Informatica, anul 2004.\r\n* \'OJI 2005\':downloads?oji2005.zip ( _365217_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale la Olimpiada Judeteana de Informatica, anul 2005.\r\n\r\nh2. ONI (5 link-uri)\r\n\r\n* \'ONI 2005\':downloads?oni2005.zip ( _6338659_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele, testele si solutiile oficiale din cadrul Olimpiadei Nationale de Informatica 2005, Galati.\r\n* \'ONI Gimnaziu 2002-2005\':downloads?onigim.zip ( _6020215_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele, solutiile si rezultatele de la Olimpiada Nationala pentru Gimnaziu, anii 2002-2005.\r\n* \'ONI2003\':downloads?oni03.zip ( _9734608_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-02-24 )\r\nSubiectele propuse in cadrul olimpiadei nationale de informatica 2003\r\n* \'ONI 2004\':downloads?ONI04.zip ( _7812828_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-02-21 )\r\nSubiectele propuse in cadrul olimpiadei nationale de informatica 2004\r\n* \'ONI2002\':downloads?ONI02.ZIP ( _2575564_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-02-21 )\r\nSubiectele propuse in cadrul olimpiadei nationale de informatica 2002\r\n\r\nh2. Lot (3 link-uri)\r\n\r\n* \'lot2004\':downloads?lot2004.rar ( _3434709_ bytes, ==user(user=\"cip\" type=\"tiny\")== @ 2006-02-04 )\r\nSubiectele, testele si solutiile oficiale din cadrul taberelor de pregatire ale lotolui largit, anul 2005.\r\n* \'lot2002\':downloads?lot2002.rar ( _1520669_ bytes, ==user(user=\"cip\" type=\"tiny\")== @ 2006-02-03 )\r\nSubiectele, testele si solutiile oficiale din cadrul taberelor de pregatire ale lotolui largit, anul 2002.\r\n* \'lot 2003\':downloads?lot2oo3.rar ( _15169596_ bytes, ==user(user=\"cip\" type=\"tiny\")== @ 2006-02-03 )\r\nSubiectele, testele si solutiile oficiale din cadrul taberelor de pregatire ale lotolui largit, anul 2003.\r\n\r\nh2. BOI (6 link-uri)\r\n\r\n* \'BOI 2005\':downloads?boi2005.zip ( _354783_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale de la BOI 2005 Grecia.\r\n* \'BOI 2004\':downloads?boi2004.zip ( _354835_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nProbleme si solutii oficiale de la BOI 2004\r\n* \'BOI 2003\':downloads?boi2003.zip ( _99072_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nProbleme si solutii oficiale de la BOI 2003\r\n* \'BOI 2002\':downloads?boi2002.zip ( _401602_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-08 )\r\nProbleme, solutii si rezultatele de la BOI 2002\r\n* \'BOI 2001\':downloads?boi2001.zip ( _16638_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-07 )\r\nProblemele de la BOI 2001\r\n* \'BOI 2000\':downloads?boi2000.zip ( _61296_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-06 )\r\nProblemele de la BOI 2000\r\n\r\nh2. CEOI (6 link-uri)\r\n\r\n* \'CEOI 2005\':downloads?ceoi2005.zip ( _1067059_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale de la CEOI 2005 Ungaria.\r\n* \'CEOI 2004\':downloads?ceoi-2004.zip ( _341294_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nProbleme, solutii oficiale si surse oficiale de la CEOI 2004 Polonia\r\n* \'CEOI 2003\':downloads?ceoi2003.zip ( _814025_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nProbleme, solutii oficiale si surse oficiale de la CEOI 2003 Germania\r\n* \'CEOI 2002\':downloads?ceoi2002.zip ( _316854_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-08 )\r\nProbleme, solutii oficiale si surse oficiale de la CEOI 2002 Slovacia\r\n* \'CEOI 2001\':downloads?CEOI_2001.zip ( _45819_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-07 )\r\nProbleme si solutii oficiale de la CEOI 2001 Ungaria\r\n* \'CEOI 2000\':downloads?CEOI_2000.zip ( _28537_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-06 )\r\nProblemele de la CEOI 2000 Romania\r\n\r\nh2. IOI (6 link-uri)\r\n\r\n* \'IOI 2005\':downloads?ioi2005.zip ( _584396_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale de la IOI 2005 Polonia.\r\n* \'IOI 2004\':downloads?ioi2004.zip ( _338911_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nSubiectele si solutiile oficiale de la IOI 2004 Grecia\r\n* \'IOI 2003\':downloads?ioi2003.zip ( _1213299_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nSubiecte in limba romana, solutii oficiale si rezultatele de la IOI 2003 USA\r\n* \'IOI 2002\':downloads?ioi2002.zip ( _1893445_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-08 )\r\nSubiecte, solutii, teste si handbook-ul de la IOI 2002 Coreea\r\n* \'IOI 2001\':downloads?IOI_2001.zip ( _465557_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-07 )\r\nSubiecte, solutii oficiale si rezultatele de la IOI 2001 Finlanda\r\n* \'IOI 2000\':downloads?IOI_2000.zip ( _1191184_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-06 )\r\nSubiecte, solutii oficiale si testele de la IOI 2000 China\r\n\r\nh2. USACO (5 link-uri)\r\n\r\n* \'USACO Gold - DEC05\':downloads?usaco.zip ( _2009498_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2006-01-31 )\r\nSetul de probleme si datele de test pentru concursul Usaco, diviza Gold, decembrie 2005. \r\n* \'Usaco Gold - NOV05\':downloads?usaco_nov05.zip ( _36878_ bytes, ==user(user=\"ditzonec\" type=\"tiny\")== @ 2005-11-22 )\r\nSetul de probleme si datele de test pentru concursul Usaco, diviza Gold, noiembrie 2005.\r\n* \'Usaco Gold - JAN05\':downloads?usaco_gold_jan05.zip ( _775374_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-03-02 )\r\nSetul de probleme, datele de test si clasamentul concursului Usaco, divizia Gold, ianuarie 2005.\r\n* \'Usaco Silver - DEC04\':downloads?silver.zip ( _736744_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2005-01-09 )\r\nSetul de probleme, testele si rezultatele concursului Usaco, divizia Silver, decembrie 2004 \r\n* \'Usaco Gold - DEC04\':downloads?gold_dec04.zip ( _1291870_ bytes, ==user(user=\"silviug\" type=\"tiny\")== @ 2004-12-20 )\r\nSetul de probleme, testele si rezultatele concursului Usaco, divizia Gold, decembrie 2004\r\n\r\nh2. BalticOI (6 link-uri)\r\n\r\n* \'BalticOI 2005\':downloads?baltic2005.zip ( _1781109_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSubiectele si solutiile oficiale de la Olimpiada Baltica de Informatica 2005.\r\n* \'BalticOI 1995-1997\':downloads?boi1995_97.zip ( _1773528_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-17 )\r\nSolutiile oficiale si testele de la Olimpiada Baltica de Informatica, anii 1995 - 1997.\r\n* \'BalticOI 2004\':downloads?baltic2004.zip ( _74176_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nProbleme si solutii oficiale de la Olimpiada Baltica de Informatica 2004 \r\n* \'BalticOI 2003\':downloads?baltic2003.zip ( _560373_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nProbleme si solutii oficiale de la Olimpiada Baltica de Informatica 2003\r\n* \'BalticOI 2002\':downloads?baltic2002.zip ( _236152_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-08 )\r\nProbleme si solutii oficiale de la Olimpiada Baltica de Informatica 2002 \r\n* \'BalticOI 2001\':downloads?baltic2001.zip ( _326933_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-07 )\r\nProbleme si solutii oficiale de la Olimpiada Baltica de Informatica 2001\r\n\r\nh2. preONI (2 link-uri)\r\n\r\n* \'PreONI 2003\':downloads?preoni2.zip ( _32577_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-10 )\r\nAl doilea concurs PreONI organizat de Stefan Ciobaca; majoritatea participantilor au fost membrii ai canalului #olimpiada. Formatul concursului a fost asemanator cu al primului concurs PreONI.\r\n* \'PreONI 2002\':downloads?preoni1.zip ( _316146_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2004-11-09 )\r\nPrimul concurs PreONI organizat de Stefan Ciobaca si Mugurel Andreica; majoritatea participantilor au fost membrii ai canalului #olimpiada. Concurentii au avut de rezolvat 11 probleme in 24h.\r\n\r\nh2. Articole (4 link-uri)\r\n\r\n* \'Rotatie minim lexicografica\':downloads?Rotatie.pdf ( _131723_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2006-02-02 )\r\nUn articol scris de Mircea Pasoi in cadrul Gazetei de Informatica (www.ginfo.ro), numarul din decembrie 2005\r\n* \'Ghid complet pentru concursurile de informatica\':downloads?Ghid_complet_pentru_concursurile_de_informatica.pdf ( _162832_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2006-02-02 )\r\nUn articol scris de Mircea Pasoi in cadrul Gazetei de Informatica (www.ginfo.ro), numarul din octombrie 2005. \r\n* \'Cautari Ortogonale\':downloads?Cautari_Ortogonale.doc ( _80384_ bytes, ==user(user=\"domino\" type=\"tiny\")== @ 2005-10-29 )\r\nAcest articol , scris de Cosmin Negruseri, prezinta algoritmi de cautari ortogonale, cat si aplicatii. Articolul a aparut si in Gazeta de Informatica 15/5, si a fost folosit initial la pregatirea lotului in 2005.\r\n* \'Arbori de intervale si aplicatii in geometria computationala\':downloads?arbori_de_intervale.zip ( _115043_ bytes, ==user(user=\"wickedman\" type=\"tiny\")== @ 2004-11-10 )\r\nAcesta este un curs despre arbori de intervale si aplicatiile lor in geometria computationala. Cursul a fost predat de Prof. Dana Lica in cadrul sesiunii de pregatire a lotului largit de informatica 2004. Pe langa explicatii amanuntite veti gasi si exemple de cod sursa in C si Pascal.\r\n\r\nh2. Utilitare (2 link-uri)\r\n\r\n* \'Rhide\':downloads?rhide-1.5.20050823.tbz2 ( _4344271_ bytes, ==user(user=\"azotlichid\" type=\"tiny\")== @ 2006-07-12 )\r\nBinar pentru RHIDE functional pentru cele mai multe distributii de Linux. Detalii despre instalare gasiti pe \'forum\':http://infoarena.ro/forum.\r\n',1858,'public'),('problema/party','Party','2006-11-11 19:26:35','==Include(page=\"template/taskheader\" task_id=\"party\")==\r\n\r\nGeorge vrea sa isi organizeze majoratul, si vrea ca petrecerea sa fie de neuitat, mancarea, bautura, locatia si sonorizarea sunt deja asigurate, si mai ramane problema chemarii prietenilor. El si cu prietenul lui cel mai bun Lucian au preferinte diferite si pentru a nu se certa au pus la punct o lista de cerinte care vor trebui sa fie indeplinite toate astfel incat cheful sa se desfasoare in cele mai bune conditii! Pentru usurinta, prietenii lui George vor fi indentificati prin numere intregi de la $1$ la $N$ si cerintele vor fi de tipurile $0, 1, 2$ sau $3$.\r\nO cerinta de genul $x y 0$ are semnificatia ca $x$ sau $y$ trebuie sa participle la petrecere ; $x y 1$ are semnificatia ca daca $x$ participa nu exista nici o restrictie pentru $y$, dar daca $x$ nu participa atunci nici $y$ nu participa ; $x y 2$ are semnificatia simetrica cu cerinta $1$ ; iar cerinta $x y 3$ are semnificatia ca cel putin unul dintre $x$ si $y$ nu participa la petrecere. Scrieti un program care sa-i ajute pe cei doi sa determine care persoane vor fi invitate la petrecere ; se garanteaza ca va fi posibila intotdeauna organizarea unei petreceri !\r\n\r\nh2. Date de Intrare (fisierul $party.in$)\r\n\r\nPe prima linie se vor afisa numerele $N$ si $M$ care reprezinta numarul de prieteni si numarul de cerinte de indeplinit. Pe urmatoarele $M$ linii vor fi cerinte de forma $x y z$ unde $1<=x,y<=N$ iar $0<=z<=3$.\r\n\r\nh2. Date de Iesire (fisierul $party.out$)\r\n\r\nPe prima linie va fi un numar $Nr$ ce reprezinta numarul de invitati la petrecere, iar pe urmatoarele $Nr$ linii cate un invitat pe linie.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 100$\r\n* 1 &le; M &le; 1.000\r\n\r\nh2. Exemple\r\n\r\ntable(example). |_. party.in |_. party.out |\r\n| 4 4            \r\n1 4 3          \r\n2 3 3\r\n1 2 1\r\n2 4 1\r\n| 1\r\n3 |\r\n| 3 7          \r\n3 2 1          \r\n3 1 1          \r\n2 1 1          \r\n2 3 1\r\n3 1 1\r\n3 2 1\r\n2 3 2\r\n| 3\r\n1\r\n2\r\n3 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"party\")==',48,'task: party'),('template/newround','%round_id%','2006-12-28 01:33:38','h1. == roundparam(round_id=\"%round_id%\" param=\"title\") ==\r\n\r\nConcursul se va desfasura intre ==roundparam(round_id=\"%round_id%\" param=\"starttime\")== si\r\n==roundparam(round_id=\"%round_id%\" param=\"endtime\")==\r\n\r\nClasamentul poate fi vizualizat \'aici\':%round_id%/clasament\r\n\r\nh2. Probleme\r\n\r\nAceasta lista va deveni vizibila doar in momentul inceperii concursului.\r\n\r\n== Tasks(round_id=\"%round_id%\")==',1142,'protected'),('preoni-2005','Preoni 2005','2007-01-13 21:39:30','h1. preONI 2005\r\n\r\nConcursul preONI 2005 s-a desfasurat in 3 runde avand ca principal scop pregatirea participantilor pentru olimpiada nationala de informatica ONI2005.\r\n\r\nFormatul concursului: 2 grupe (clasele IX-X, XI-XII), 3 probleme in fiecare grupa si un timp de lucru de 4h.\r\n\r\nh2. Runde\r\n\r\n* \"Runda 1\":preoni-2005/runda-1 :Duminica, 23 ianuarie, ora 15:00\r\n* \"Runda 2\":preoni-2005/runda-2 :Miercuri, 23 februarie ora 16:00\r\n* \"Runda 3\":preoni-2005/runda-3 :Duminica, 20 martie la ora 10:00\r\n\r\nh2. \"Clasament IX-X\":preoni-2005/clasament-9-10\r\n\r\nh2. \"Clasament XI-XII\":preoni-2005/clasament-11-12',1,'round: preoni-2005'),('preoni-2005','Preoni 2005','2007-01-13 21:42:31','h1. preONI 2005\r\n\r\nConcursul preONI 2005 s-a desfasurat in 3 runde avand ca principal scop pregatirea participantilor pentru olimpiada nationala de informatica ONI2005.\r\n\r\nFormatul concursului: 2 grupe (clasele IX-X, XI-XII), 3 probleme in fiecare grupa si un timp de lucru de 4h.\r\n\r\nh2. Runde\r\n\r\n* \"Runda 1\":preoni-2005/runda-1 :Duminica, 23 ianuarie, ora 15:00\r\n* \"Runda 2\":preoni-2005/runda-2 :Miercuri, 23 februarie ora 16:00\r\n* \"Runda 3\":preoni-2005/runda-3 :Duminica, 20 martie la ora 10:00\r\n\r\nh2. \"Clasament IX-X\":preoni-2005/clasament-9-10\r\n\r\nh2. \"Clasament XI-XII\":preoni-2005/clasament-11-12',1,'round: preo'),('template/preoni-2007/header','template/preoni-2007/header','2007-01-13 23:36:13','table{margin: 0; width: 99%; background-image: url(/template/preoni-2006?action=download&file=hbk.gif); background-repeat: repeat-x; background-position: bottom left;}. |{border: 0px;}. !template/preoni-2007?not-available.jpg!:/preoni-2007 |{border: 0px; text-align: right; vertical-align: bottom}. !template/preoni-2007?not-available.jpg!:http://www.infoarena.ro/ |\r\n',1,'protected'),('problema/numere','Numere','2006-11-22 02:53:32','==Include(page=\"template/taskheader\" task_id=\"numere\")==\r\n\r\nCand erau ei mai tineri, lui Mars si lui Mugurel le placea sa se joace cu numerele. Astfel, ei au inventat urmatorul joc: Doi jucatori se joaca cu doua numere pozitive. Jucatorii efectueaza mutari alternativ, iar jucatorul care a efectuat ultima mutare castiga. O mutare consta in scaderea din numarul mai mare a unui multiplu strict pozitiv al numarului mai mic, cu conditia ca acest multiplu sa fie mai mic decat sau egal cu numarul mai mare. Altfel spus, presupunand ca cele doua numere sunt $X$ si $Y$ si ca $X&ge;Y$, o mutare consta in scaderea din numarul $X$ a oricarui numar de forma $K*Y$ ({$K&ge;1$}), cu conditia $K*Y&ge;X$. Jocul se termina cand unul din numere devine egal cu $0$. Scrieti un program care decide care din cei doi jucatori va castiga jocul, considerand ca ambii jucatori joaca optim.\r\n\r\nh2. Date de Intrare\r\n\r\nPrima linie a fisierului $numere.in$ contine numarul $T$ de jocuri descrise in continuare. Fiecare din urmatoarele $T$ linii contine $2$ numere intregi $X$ si $Y$, separate printr-un spatiu, reprezentand valorile initiale ale celor doua numere.\r\n\r\nh2. Date de Iesire\r\n\r\nIn fisierul $numere.out$ veti afisa $T$ linii. Pe fiecare linie veti afisa castigatorul jocului corespunzator din fisierul de intrare. Veti afisa $1$, daca primul jucator (cel care efectueaza prima mutare) va castiga, respectiv $2$, daca al doilea jucator va castiga.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; T &le; 20$\r\n* $1 &le; X,Y &le; 10^9^$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. acolor.in |_. acolor.out |\r\n| 5\r\n  1 19\r\n  19 1\r\n  27 33\r\n  333333333 273333333\r\n  9997 19999\r\n| 1\r\n  1\r\n  2\r\n  2\r\n  1 |\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"numere\")==',1,'task: numere'),('problema/nr','nr','2007-01-14 17:44:58','== include(page=\"template/taskheader\" task_id=\"nr\") ==\r\n\r\nPoveste si cerinta...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n... &le; ...\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. nr.in |_. nr.out |\r\n| This is some\r\n  text written on\r\n  multiple lines.\r\n| This is another\r\n  text written on\r\n  multiple lines.\r\n| \r\n\r\nh3. Explicatie\r\n\r\n...\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"nr\") ==\r\n',1,'task: nr'),('problema/nr','Nr','2007-01-14 18:03:28','== include(page=\"template/taskheader\" task_id=\"nr\") ==\r\n\r\nZaharel este un mare pasionat de numere. Astazi, se joaca cu numere de $N$ cifre scrise in baza $B$. Fie $NR=nr{~0~}nr{~1~}...nr{~N-1~}$  un astfel de numar in baza $B$ ({$nr{~0~}, nr{~1~}$} etc. reprezinta cifrele numarului $NR$ scrise de la stanga la dreapta), definim imaginea acestui numar ca fiind numarul $I(NR)=i{~0~}i{~1~}...i{~N-2~}$ cu proprietatea $i{~p~}=min(i{~p~},i{~p+1~})$. Avand o groaza de timp liber, Zaharel s-a gandit sa calculeze pentru fiecare numar posibil de $N$ cifre (numarul poate incepe cu cifre de 0) in baza $B$ produsul cifrelor imaginii numarului si sa adune aceste valori.\r\nScrieti un program care il scuteste pe Zaharel de aceste calcule, si determina aceasta suma in timp util.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $numere.in$ sunt scrise cele doua numere naturale $N, B$, separate printr-un singur spatiu.\r\n\r\nh2. Date de iesire\r\n\r\nPrima linie a fisierului $numere.out$ va contine suma dorita de Zaharel. Deoarece rezultatul poate fi foarte mare, este de ajuns afisarea restului impartirii rezultatului la numarul $666013$.\r\n\r\nh2. Restrictii\r\n\r\n* $2 &le; N &le; 20.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. nr.in |_. nr.out |\r\n| This is some\r\n  text written on\r\n  multiple lines.\r\n| This is another\r\n  text written on\r\n  multiple lines.\r\n| \r\n\r\nh3. Explicatie\r\n\r\n...\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"nr\") ==\r\n',1,'task: nr'),('problema/criptare','Criptare','2007-01-14 21:37:52','== include(page=\"template/taskheader\" task_id=\"criptare\") ==\r\n\r\nZaharel si Bronzarel se intrec adesea in criptare. De data aceasta, Zaharel a criptat un sir de $N$ numere naturale $a{~0~}, a{~1~},... a{~N-1~}$ astfel: a luat un numar natural $M$ si a construit urmatorul sir: $b{~i~} = a{~i~}+a{~(i+1) mod N~}+a{~(i+2) mod N~}+...+a{~(i+M-1) mod N~}$; apoi, l-a intrebat pe Bronzarel daca poate sa determine sirul initial $a{~0~}, a{~1~},... a{~N-1~}$ daca i se da acest nou sir, precum si numarul $M$.\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n... &le; ...\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. criptare.in |_. criptare.out |\r\n| This is some\r\n  text written on\r\n  multiple lines.\r\n| This is another\r\n  text written on\r\n  multiple lines.\r\n| \r\n\r\nh3. Explicatie\r\n\r\n...\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"criptare\") ==\r\n',1,'task: criptare'),('template/preoni-2007/footer','template/preoni-2007/footer','2007-01-15 15:15:22','h2. Sponsori\r\n\r\n!template/preoni-2007?photo-not-available.jpg 40%!:http://www.infoarena.ro/',1,'protected'),('echipa-infoarena','Echipa infoarena','2006-11-27 08:30:42','h1. Echipa infoarena\r\n\r\n==include(page=\"template/todo\")==\r\n\r\n_(aici trebuie sa punem un macro cu atribute/tags de utilizatori)_\r\n',13,'public'),('echipa-infoarena','Echipa infoarena','2007-01-15 15:30:27','h1. Echipa infoarena\r\n\r\n* ==include(page=\"template/todo\")==\r\n* ==user(user=\"wickedman\" type=\"large\")==\r\n* ==user(user=\"fluffy\" type=\"tiny\")==\r\n* ==user(user=\"Cosmin\" type=\"tiny\")==\r\n* ==user(user=\"domino\" type=\"tiny\")==\r\n* ==user(user=\"ditzoneC\" type=\"tiny\")==\r\n* ==user(user=\"silviug\" type=\"tiny\")==\r\n* ==user(user=\"filipb\" type=\"tiny\")==\r\n* ==user(user=\"danielp\" type=\"tiny\")==\r\n* ==user(user=\"azotlichid\" type=\"tiny\")==\r\n* ==user(user=\"greco\" type=\"tiny\")==\r\n* ==user(user=\"svalentin\" type=\"tiny\")==\r\n\r\n_(aici trebuie sa punem un macro cu atribute/tags de utilizatori)_\r\n',1,'public'),('despre-infoarena','Despre infoarena','2006-12-18 17:56:20','h1. Despre infoarena\r\n\r\n==include(page=\"template/despre-infoarena\")==\r\n\r\n*infoarena ajuta elevi si studenti sa devina excelenti in informatica!* Gratuit ;)\r\n\r\nh2. Cu ce ne ocupam?\r\n\r\n* Concursuri online de informatica pentru studenti si elevi\r\n* Stiri si articole despre informatica\r\n* Discutam pe forum tot despre informatica\r\n* Cateodata organizam concursuri on-site.\r\n\r\ninfoarena functioneaza din 2002 si este dezvoltata de noi, echipa infoarena.\r\nSuntem o mana de studenti si elevi innebuniti de info. Tinem neaparat sa-i ajutam si pe altii sa innebuneasca :)\r\n\r\nComunitatea noastra cuprinde aproape toti elevii romani ce participa la concursuri de informatica nationale si internationale. Ne mandrim cu valoarea concursurilor si a materialelor prezentate pe site.\r\n\r\nDemn de mentionat este evaluatorul infoarena, un program care evalueaza solutiile trimise de concurenti. Evaluatorul iti spune aproape instantaneu daca (si cat de bine) ai rezolvat o problema (\"vezi Evaluator\":documentatie/evaluator).\r\n\r\nh2. Citate\r\n\r\n&nbsp;\r\n\r\nbq. People have been known to achieve more as a result of working with others than against them.\r\n\r\n*Dr. Allan Fromme*\r\n\r\n&nbsp;\r\n\r\nbq. infoarena este un proiect remarcabil, realizat cu entuziasm, generozitate si profesionalism. Este locul in care tinerii pasionati de informatica se pot intalni, atat de o parte, cat si de cealalta parte a baricadei, ca propunatori sau ca rezolvitori de probleme, isi pot impartasi experienta competitionala, pot constitui modele, pot ajuta la formarea a noi si noi generatii de performanta.\r\n\r\n*Emanuela Cerchez*\r\nCoordonator stiintific in Comisia Nationala de Informatica, Prof. grad I - Lic. de Informatica \"Grigore Moisil\" Iasi\r\n\r\n&nbsp;\r\n\r\nbq. infoarena e plin de energie, e dinamic si riguros, gratie unei echipe curajoase. Site-ul infoarena reprezinta cea mai originala forma de pregatire pe net a performerilor in informatica din Romania. Mecanism de lucru excelent, probleme propuse, fara cusur. Felicitari!\r\n\r\n*Emil Onea*\r\nInspector scolar informatica, Comisia Nationala de Informatica pentru Invatamant Preuniversitar\r\n',1490,'public'),('template/despre-infoarena','template/despre-infoarena','2006-12-11 03:19:24','(vmenu)* \'Despre infoarena\':despre-infoarena\r\n* \'Regulament\':regulament\r\n* \'Echipa\':echipa\r\n* \'Colaboratori\':colaboratorii\r\n* \'Asociatia infoarena\':asociatia-infoarena\r\n',13,'protected'),('preoni-2007/comisie','Organizatori preONI 2007','2007-01-15 15:47:51','==Include(page=\"template/preoni-2006\")==\r\n\r\nh1. Organizatori\r\n\r\nEchipa care se ocupa de organizarea si desfasurarea concursului *preONI 2007* este \'echipa infoarena\':echipa-infoarena.\r\n\r\nh2. Organizare \r\n\r\n* == user(user=\"wickedman\" format=\"tiny\") == : coordonator, promovare concurs\r\n* == user(user=\"wickedman\" format=\"fluffy\") == : asigura buna desfasurare a concursului din punct de vedere tehnic (site-ul, evaluatorul etc.)\r\n* == user(user=\"wickedman\" format=\"svalentin\") == : suport tehnic\r\n\r\nh2. Echipa stiintifica \r\n\r\nCei care se vor ocupa de buna desfasurarea a concursului din punct de vedere stiintific (redactarea si compunerea problemelor, realizarea testelor, clarificarea intrebarilor, etc.) sunt:\r\n\r\n* == user(user=\"domino\" format=\"tiny\") ==\r\n* == user(user=\"Cosmin\" format=\"tiny\") ==\r\n* == user(user=\"ditzone\" format=\"tiny\") ==\r\n* == user(user=\"silviug\" format=\"tiny\") ==\r\n* == user(user=\"filipb\" format=\"tiny\") ==\r\n* == user(user=\"danielp\" format=\"tiny\") ==\r\n* == user(user=\"azotlichid\" format=\"tiny\") ==\r\n* == user(user=\"greco\" format=\"tiny\") ==\r\n\r\n==include(page=\"template/preoni-2007/footer\")==',1,'public'),('preoni-2007/regulament','Regulament preONI 2007','2007-01-15 15:52:52','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Regulament\r\n\r\nSe recomanda, pe langa citirea acestui regulament, citirea \"regulamentului\":regulament general infoarena.\r\n\r\nEchipa infoarena isi rezerva dreptul de a modifica prezentul regulament pe parcursul desfasurarii concursului. Daca apar prevederi noi sau daca anumite prevederi ale regulamentului sunt modificate sau eliminate, atunci acestea vor fi anuntate pe site-ul concursului. Orice modificare a regulamentului va intra in vigoare, in functie de situatie, fie din momentul publicarii ei, fie dupa incheierea rundei aflate in desfasurare. In momentul anuntarii modificarii va fi precizat si momentul din care aceasta intra in vigoare.\r\n\r\nh2. Dreptul de participare\r\n\r\nPersoanele care fac parte din echipa infoarena cat si alti contribuitorii\r\nimplicati direct in organizarea concursului *preONI 2007* nu au dreptul de a participa. De asemenea, orice concurent care are un comportament considerat inadecvat fata de echipa infoarena sau fata de alti concurenti va fi descalificat. Un concurent se poate califica la finala doar daca se incadreaza in grupa la care a concurat (aceasta verificare se va face prin prezentarea unei dovezi legale care il incadreaza pe concurent la aceea grupa).\r\n\r\nh2. Repartizarea\r\n\r\nToti participantii vor fi repartizati in 3 grupe, in concordanta cu varsta lor. Repartizarii este asemanatoare cu acea facuta la olimpiadele de informatica.\r\n\r\n* Clasa a 9a (si gimnaziu)\r\n* Clasa a 10a\r\n* Clasele 11-12 \r\n\r\nOricine poate participa la o alta grupa decat cea la care se incadreaza, dar calificarea la finala cat si impartirea premiilor se va face conform regulamentului respectiv, fara nici o exceptie.\r\n\r\nh2. Inscriere\r\n\r\nTot ce trebuie sa faceti pentru a participa la concursul *preONI 2007* este sa aveti un cont la infoarena. Inregistrarea se poate face pe site-ul infoarena. Acelasi cont va fi folosit pentru a accesa forum-ul.\r\n\r\nh2. Runde\r\n\r\nVor exista 4 runde de calficare, iar in urma clasamentului stabilit primii de la fiecare grupa vor fi selectati pentru etapa finala desfasurata in cadrul unei tabere. Cele 4 runde vor avea loc sambata incepand cu ora 9:00, desi pot interveni exceptii. Durata lor va fi de 4 ore. Pentru un program detaliat al concursului \"click aici\":preoni-2007/program.\r\n\r\nh2. Intrebari\r\n\r\nIn prima ora vor putea fi formulate eventualele intrebari, pe forum, in topicurile special create. Orice intrebare pusa in alt mod (primita ca personal message, pe mail, etc.) va fi ignorata. Raspunsuri vor fi oferite doar la intrebarile puse in prima ora . Intrebarile trebuie formulate astfel incat sa se poate raspunda cu DA sau NU. In caz contrar sau in cazul in care raspunsul se afla in textul problemei se va raspunde cu NO COMMENT. Nu vor exista exceptii de la aceaste reguli. Daca echipa va considera ca raspunsul la o anumita intrebare este de interes general si clarifica anumite aspecte, atunci se va face un anunt general care va aparea atat pe forum cat si in sectiunea Mesaje de la organizatori a grupei respective. Fiecare grupa va avea doi administratori care se vor ocupa de raspunsul acestor intrebari.\r\n\r\nh2. Trimiterea solutiilor\r\n\r\nTrimitrea solutiile se va face prin intermediul interfetei site-ului infoarena.\r\nOdata logati in contul vostru, veti putea selecta arhiva la care doriti sa\r\nlucrati (in cazul acesta una din arhivele {*preONI 2007*}) si veti putea folosi link-ul trimite solutii.\r\n\r\nh2. Evaluare\r\n\r\nDupa expirarea timpului de trimitere a solutiilor acestea vor fi evaluate (\"mai multe detalii aici\":documentatie/evaluator). In mod normal, evaluarea se va face imediat dupa concurs, desi exista posibilitatea ca echipa infoarena sa amane evaluarea din motive obiective. Veti putea vizualiza pozitia ocupata in clasament dupa evaluarea in rubrica Clasamente si alte statistici.\r\n\r\nSe recomanda sa instalati pe calculatorul vostru aceleasi versiuni de compilatoare ca cele specificate la link-ul de mai sus. Echipa infoarena nu este responsabila pentru diferentele intre versiuni de compilatoare si nu va efectua reevaluaari in astfel de cazuri.\r\n\r\nh2. Contestatii\r\n\r\nEchipa infoarena isi rezerva dreptul de a reevalua orice problema in situatia in care se detecteaza erori in teste sau in programul de verificare dupa evaluare. Cum testele problemelor nu vor fi facute publice, posiblitatile de a contesta sunt limitate. Pentru a asigura o evaluarea corecta, echipa infoarena va garanteaza ca va testa intens toate problemele inainte de concurs si ca va verifica corectitudinea procesului de evaluare dupa terminare. In caz ca totusi aveti o contestatie, aceasta trebuie trimisa pe mail la adresa preONI2007 -at- gmail.com in termen de 24 de ore de la afisarea rezultatelor rundei curente pe site. Ele vor fi rezolvate in termen de maxim 5 zile, iar dupa rezolvarea lor rezultatele vor fi declarate finale.\r\n\r\nh2. Solutii\r\n\r\nLa scurt timp dupa terminarea evaluarii se va publica un articol cu solutiile pentru problemele rundei respective. Testele utilizate pentru evaluare nu vor fi facute publice.\r\n\r\nh2. Transferul problemelor\r\n\r\nProblemele vor fi mutate dupa evaluare in Arhiva de probleme infoarena, avand astfel la dispozitie un evaluator 24 din 24 si posiblitatea de a finisa solutiile la problemele nerezolvate in timpul concursului.\r\n\r\nh2. Trisare\r\n\r\n*preONI 2007* este un concurs individual, asadar orice tentativa de colaborare va aduce descalificarea celor implicati. echipa infoarena isi rezerva dreptul de a verifica sursele concurentilor, iar in caz ca se descopera surse aproximativ identice, concurentii respectivi vor fi descalificati din concurs iar user-ul lor de pe infoarena eliminat. Tentativele de frauda (concurarea sub un alt nume decat cel adevarat, etc.) sau orice atac asupra sistemului de evaluare sau asupra paginilor infoarena vor fi pedepsite in aceeasi masura. \r\n',1,'public'),('problema/joc2','Joc2','2006-12-16 09:02:36','==Include(page=\"template/taskheader\" task_id=\"joc2\")==\r\n\r\nDoi participanti mananca alternant din niste tablete de ciocolata dupa urmatoarele reguli:\r\n\r\n# taie o tableta in doua, taietura trebuie sa fie paralela cu una din laturile tabletei si trebuie sa nu taie patratelele de ciocolata\r\n# poate sa rupa si sa manance orice linie sau coloana de patratele care nu se afla pe marginea tabletei\r\n# poate sa rupa si sa manance toate patratelele de pe marginea tabletei, cu conditia ca tableta ramasa sa aiba cel putin dimensiunea {$1 x 1$}\r\n\r\nNici una dintre aceste trei mutari nu poate fi efectuata asupra unei tablete de dimensiune {$1 x 1$}.\r\nPierde jucatorul care nu mai poate efectua nici o mutare.\r\n\r\nh2. Date de intare\r\n\r\nIn fisierul de intrare $joc2.in$ se va afla numarul $N$ de tablete, iar pe urmatoarele $N$ linii se afla perechi de numere intregi care reprezinta dimensiunile tabletelor.\r\n\r\nh2. Date de Iesire\r\n\r\nFisierul de iesire $joc2.out$ va contine un singur numar intreg, care reprezinta numarul de moduri in care poate face prima mutare astfel incat sa existe o strategie ca sa poata castiga partida.\r\n\r\nh2. Restrictii si precizari\r\n\r\n* $1 &le; N &le; 100$\r\n* dimensiunile tabletelor sunt cuprinse intre $1$ si $100$\r\n* primul jucator muta intotdeauna primul\r\n* se presupune ca ambii participanti joaca optim\r\n* mutare este identificata prin tableta asupra careia se efectueaza, prin tip, si prin linia/coloana pe care o afecteaza.\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. joc2.in |_. joc2.out |\r\n| 2\r\n1 2\r\n2 2 | 0 |\r\n\r\nh3. Explicatie\r\n\r\nLa prima mutare, primul jucator poate sa rupa fie prima tableta in doua, obtinandu-se astfel doua tablete de $1$ patratel si una de $4$ patratele.\r\nLa a doua mutare, al doilea jucator poate rupe in doua (fie orizontal fie vertical) tableta de $4$ patratele, obtinandu-se $2$ tablete de $2$ patratele.\r\nLa a treia mutare, primul jucator poate sa rupa in doua una dintre cele $2$ tablete de $2$ patratele, obtinandu-se astfel doua tablete de $1$ patratel si una de $2$ patratele.\r\nLa a patra mutare, al doilea jucator poate rupe in doua singura tableta de $2$ patratele care a mai ramas, obtinandu-se astfel doua tablete de $1$ patratel.\r\nPrimul jucator nu mai poate efectua nici o mutare.\r\n\r\nO alta varianta de joc ar putea fi:\r\nLa prima mutare, primul jucator poate rupe in doua (orizontal sau vertical) tableta de $4$ patratele, obtinandu-se astfel trei tablete de $2$ patratele.\r\nLa a doua mutare, al doile jucator poate sa rupa in doua una dintre cele $3$ tablete de $2$ patratele, obtinandu-se astfel doua tablete de $1$ patratel si $2$ de $2$ patratele.\r\nLa a treia mutare, primul jucator poate sa rupa in doua una dintre cele $2$ tablete de $2$ patratele, obtinandu-se astfel doua tablete de $1$ patratel si una de $2$ patratele.\r\nLa a patra mutare, al doilea jucator poate rupe in doua singura tableta de $2$ patratele care a mai ramas, obtinandu-se astfel doua tablete de $1$ patratel.\r\nPrimul jucator nu mai poate efectua nici o mutare.\r\n\r\nIn concluzie indiferent ce muta primul jucator la prima mutare, acesta va pierde partida de fiecare data. \r\n\r\n\r\n==Include(page=\"template/taskfooter\" task_id=\"joc2\")==',256,'task: joc2'),('preoni-2007/clasament','Clasament preONI 2007','2007-01-15 15:59:18','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Clasament\r\n\r\n_in curand_\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==',1,'protected'),('documentatie/evaluator','Evaluatorul infoarena','2006-12-10 21:04:03','h1. Evaluatorul infoarena\r\n\r\n==include(page=\"template/todo\")==\r\n\r\n... este responsabil de evaluarea solutiilor trimise de utilizator.\r\n\r\nh2. Cum se evalueaza o problema\r\n\r\nMai intai, codul sursa trimis de concurent se compileaza (vezi tabelul de mai jos). Apoi, solutia se _evalueaza_: se ruleaza programul compilat pentru diferite date de intrare (teste). In urma rularii, un program specializat decide daca raspunsul dat de solutia concurentului este corect si acord un punctaj pe masura.\r\n\r\nFiecare program compilat are dreptul de a rula doar un anumit interval de timp (specificat in descrierea problemei). in cazul in care timpul de executie este depasit, programul este terminat automat de sistem. Analog, se pot impune si limite de memorie.\r\n\r\nEvaluarea se face intr-un mediu restrictionat. Programele compilate pot citi/scrie fisiere doar din/in directorul curent si nu au acces la unele functii sistem.\r\n\r\nh2. Compilatoare folosite\r\n\r\nIata *lista oficiala* de compilatoare folosite de evaluatorul infoarena:\r\n\r\n|_. Compilator si versiune|_. Comanda de compilare |_. Extensie implicita |\r\n| GNU GCC 3.3.5 | $gcc -Wall -O2 -static &hellip; -lm$ | c |\r\n| GNU G++ 3.3.5 | $g++ -Wall -O2 -static &hellip; -lm$ | cpp |\r\n| FreePascal Compiler 202 | $fpc -O2 -Xs &hellip;$               | pas |\r\n\r\nh2. Configuratia sistemului de evaluare\r\n\r\nEvaluatorul ruleaza pe un calculator dedicat, oferit de ==User(type=\"tiny\" user=\"fluffy\")==. (Multumim, Leo!)\r\n\r\n* Sistem de operare: Debian stable(sarge)\r\n* Procesor: Pentium IV, $2.0 GHz$\r\n* Memorie: $512 MB RAM$\r\n\r\nh2. Gazduire !>documentatie/evaluator?hqn.png!\r\n\r\nEvaluatorul infoarena este gazduit cu placere de catre \"HQN (High Quality Networks)\":http://hqn.ro/.\r\n\r\nh2. Mesage de evaluare.\r\n\r\nPentru cei care nu sunt familiari cu sistemele unix sau sunt incepatori in programare, multe dintre mesajele evaluatorului pot parea oarecum criptice.\r\n\r\n* Eroare de sistem: Daca ai obtinut aceast mesaj te rugam sa ne contactezi, preferabil pe \'forum\':forum. Te rugam sa mentionezi si id-ul job-ului.\r\n* OK: Totul a functionat perfect.\r\n* Memory limit exceeded: Ai depasit limita de memorie. Majoritatea problemelor au o limita de 64 de mega, pe care noi o consideram destul de generoasa.\r\n* Time limit exceeded: Programul tau a depasit limita de timp. Asta inseamna ca programul tau nu este destul de rapid.\r\n* Wall time limit exceeded: Evaluarea a durat prea mult si a fost abandonata. Evaluatorul infoarena masoara doar timpul folosit de programul tau pentru a determina daca iti da TLE, dar exista si o limita fata de \"ceasul de perete\". Acest mesaj poti sa il obtii daca faci sleep, scanf de la stdin si alte functii care stau degeaba fara sa consume efectiv procesorul.\r\n* Non-zero exit status: Programul tau a returnat o valoare diferita de 0. Cel mai probabil ai uitat return 0; sau ceva similar.\r\n* Blocked system call: Ai accesat o functie la care nu ai access. Nu ar trebui sa primesti aceasta functie decat daca incerci explicit sa faci ceva interzis.\r\n* Killed by signal: Cea mai frecventa eroare cand ai un bug in program. Cand un program incalca anumite conventii in UNIX acel program primeste un \"semnal\" care de cele mai multe ori il opreste. Cateva semnale comune:\r\n** 11(SIGSEGV): Segmentation fault. Asta in 99% din cazuri inseamna ca ai probleme cu accesul la memorie. Ai iesit din limitele unui vector, ai facut stack overflow, etc.\r\n** 8(SIGFPE): Floating point error. Cauza cel mai frecvent de impartiri la 0.\r\n\r\nEvaluatoarele problemelor iti vor da si ele un mesaj scurt, cel mai frecvent ceva de genul \"OK\" sau \"Wrong Answer\", dar unii propunatorii au umor :).\r\n\r\nh2. Troubleshooting\r\n\r\nPentru programatorii in Borland C/Pascal este important de tinut minte ca evaluatorul infoarena este un mediu *foarte* diferit fata de dos. Cateva erori comune si cum pot fi rezolvate\r\n\r\n* Pe infoarena se face I/O din fisiere, nu de la stdin, stdout. Daca faci scanf de la stdin vezi obtine cel mai probabil \"Wall time limit exceeded\" (vezi mai sus) iar daca faci printf la stdout rezultatul tau va fi ignorat.\r\n* tipul int din GCC este pe 32 de biti, nu 16 ca in Borland C/C++, char - 8 biti, short - 16 biti, long - 32, long long - 64\r\n* folositi sprintf in loc de itoa sau ltoa.\r\n* programul de evaluare ruleaza pe un sistem de operare UNIX. Folositi \"\\n\" pentru terminarea liniei curente, nu \"\\r\\n\"\r\n* aveti grija ca functia main sa fie de tip int si sa intoarca 0 (return 0;)\r\n* nu folositi librarii dependente de sistemul de operare (ex. dos.h, graphics.h in C sau dos, crt, graph in pascal). Aceste librarii nu sunt necesare pentru a rezolva problemele de pe infoarena.\r\n* nu folositi modificatorii far, huge, _huge, __huge pentru ca nu exista in GCC. De asemenea, nu exista nici functiile care folosesc aceste tipuri de date (de ex. farmalloc, farfree etc.) si nici conceptul de memory model (tiny, small, medium, large, huge). De toate acestea nu mai e nevoie intrucat puteti avea acces la toata memoria prin functii standard si pointer-i standard - new, delete, malloc etc.',1142,'protected'),('preoni-2007','preONI 2007','2007-01-18 03:36:26','==Include(page=\"template/preoni-2007\")==\r\n\r\npreONI, concursul de pregatire pentru Olimpiada Nationala de Informatica, a ajuns la a patra editie.\r\n\r\npreONI 2007 incepe cu 4 runde online de calificare. Cei mai buni de la fiecare grupa sunt invitati la finala on-site. Castigatorii rundei finale sunt premiati in bani si obiecte.\r\n\r\np=. &rarr; \'*Remember preONI 2006*\':preoni-2006\r\n\r\nh2. Program concurs\r\n\r\ntable{width: 50%}. |_. Runda|_. Data|\r\n|\"Runda 1\":preoni-2007/runda-1|Duminica, 21 ianuarie 2007|\r\n|\"Runda 2\":preoni-2007/runda-2|_Duminica, 18 februarie 2007_|\r\n|\"Runda 3\":preoni-2007/runda-3|_Duminica, 4 martie 2007_|\r\n|\"Runda 4\":preoni-2007/runda-4|_Duminica, 25 martie 2007_|\r\n|\"Runda finala\":preoni-2007/finala| _6-8 aprilie 2007_ |\r\n\r\nClick pe titlul unei runde pentru informatii detaliate.\r\n\r\nDatele scrise _inclinat_ sunt provizorii. Este posibil sa le schimbam pe parcurs.\r\n\r\nh2. Despre preONI\r\n\r\npreONI, concursul de marca al comunitatii infoarena, este dedicat elevilor de liceu ce se pregatesc pentru ONI (\'Olimpiada Nationala de Informatica\':http://olimpiada.info/).\r\n\r\nConcursul este impartit in 3 grupe: clasa a IX-a si gimnaziu, clasa a X-a si clasele XI-XII. Se organizeaza 4 runde online de calificare. In urma acestora, cei mai buni de la fiecare grupa sunt invitati la o \'runda finala\':preoni-2007/finala.\r\n\r\nIn cadrul unei runde, concurentii au de rezolvat 3 probleme in 4 ore. Castigatorii rundei finale sunt premiati cu bani si/sau obiecte.\r\n\r\nVezi \'preONI 2006\':preoni-2006, \'preONI 2005\':preoni-2005.\r\n\r\nh2. Cum particip?\r\n\r\nInainte de toate trebuie sa \'te inregistrezi\':register pe site-ul nostru.\r\n\r\nOricine este invitat sa participe. In ziua de concurs intri pe site, citesti probleme, le rezolvi si trimiti solutiile inainte de expirarea timpului de lucru. La sfarsitul rundei, \'evaluatorul\':evaluator infoarena iti va testa solutiile pentru corectitudine. Clasamentul se va actualiza in timp real pe parcursul evaluarii.\r\n\r\nPoti sa rezolvi probleme de la orice grupa de varsta. Totusi, te vei califica la runda finala numai daca te incadrezi in grupa la care ai concurat.\r\n\r\nh2. Prima data pe infoarena?\r\n\r\ninfoarena ajuta elevi si studenti sa devina excelenti in informatica! Gratuit ;) \'Citeste mai multe\':despre-infoarena despre noi.\r\n\r\nVezi \'ghidul utilizatorului\':documentatie/pentru-utilizatori.\r\n\r\n==include(page=\"template/preoni-2007/footer\")==\r\n',13,'protected'),('home','infoarena 2','2007-01-18 20:29:04','h1. Bine ai venit!\r\n\r\np. Acesta este *noul site infoarena*! Am inlocuit vechiul infoarena.devnet.ro dupa aproape 3 ani de functionare.\r\nSunt multe de spus despre noua versiune asa ca incepem cu ce e mai important ...\r\n\r\ntable(layout3). | *infoarena este un wiki*\r\nSchimba continutul paginilor sau sa creaza pagini noi.\r\n\'Afla mai multe&hellip;\':documentatie/wiki\r\n| *infoarena iti da rating*\r\nIti calculam rating-ul: un numar care reflecta performantele tale.\r\n\'Afla mai multe&hellip;\':documentatie/rating\r\n| *Forum integrat*\r\nAm avut grija ca forum-ul sa fie bine integrat in experienta infoarena.\r\n\'Afla mai multe&hellip;\':documentatie/forum |\r\n| *Fa-ti pagina personala*\r\nPrezinta-te comunitatii infoarena: cine esti, de unde vii, distinctii primite etc.\r\n\'Afla mai multe&hellip;\':documentatie/pagina-de-profil\r\n| *Un nou evaluator*\r\nEvaluatorul nou masoara mai exact timpii de executie si suporta tipuri noi de probleme si concursuri.\r\n\'Afla mai multe&hellip;\':documentatie/evaluator\r\n| *Mai usor de folosit*\r\nNoul infoarena este mai usor de navigat si de folosit.\r\n\'Afla mai multe&hellip;\':documentatie/pentru-utilizatori |\r\n\r\nh2. Ne trebuie feedback!\r\n\r\nNe asteptam sa gasim multe bug-uri si deficiente in noua versiune. Ajuta-ne sa facem o infoarena ca _Soarele sfant de pe cer_ :)\r\nAsteptam bug reports, sugestii, intrebari pe forum. Iata niste topic-uri de feedback:\r\n\r\n==SmfTopics(board_id=\"33\")==\r\n\r\nh2. Ce este infoarena?\r\n\r\ninfoarena este un site web care ajuta elevi si studenti sa obtina performanta in informatica! \'Afla mai multe&hellip;\':despre-infoarena\r\n\r\nCu ce ne ocupam?\r\n\r\n* Concursuri online de informatica pentru studenti si elevi\r\n* Stiri si articole despre informatica\r\n* Discutam pe forum tot despre informatica\r\n\r\nh2. Pentru programatori PHP / web\r\n\r\nSite-ul si evaluatorul infoarena sunt open-source! Codul sursa este \'liber disponibil\':http://hackers.devnet.ro/browser/trunk/infoarena2 iar dezvoltarea se face \'public\':http://hackers.devnet.ro.\r\n\r\nDaca stii PHP / tehnologii web / webdesign sau vrei sa inveti alaturi de noi, intra pe \"pagina de development\":documentatie/development. \r\n\r\nh2. Ultimele Stiri\r\n\r\n==News(pager_style=\"none\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':stiri',256,'protected'),('preoni-2007/runda-1/9','preONI 2007, Runda 1, Clasa a 9-a si gimnaziu','2007-01-20 21:48:21','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. preONI 2007, Runda 1, Clasa a 9-a si gimnaziu\r\n\r\n==roundstatus(round_id=\"preoni2007_runda1_9\")== \r\n\r\n\r\nConcursul incepe ==roundparam(round_id=\"preoni2007_runda1_9\" param=\"start_time\")== si dureaza ==roundparam(round_id=\"preoni2007_runda1_9\" param=\"duration\")== ore.\r\n\r\n==roundregister(round_id=\"preoni2007_runda1_9\")==\r\n\r\n\r\nClasamentul poate fi vizualizat \'aici\':preoni2007_runda1_9/clasament\r\n\r\nh2. Probleme\r\n\r\nAceasta lista va deveni vizibila doar in momentul inceperii concursului.\r\n\r\n== Tasks(round_id=\"preoni2007_runda1_9\" score=\"1\")==\r\n\r\n==include(page=\"template/preoni-2007/footer\")==',1,'protected'),('problema/aprindere','Aprindere','2007-01-20 19:43:28','== include(page=\"template/taskheader\" task_id=\"aprindere\") ==\r\n\r\nJohnie vrea sa sparga o banca, in care seifurile sunt asezate in N camere alaturate. Astfel camerele sunt asezate in ordinea $0, 1, 2 ... N - 1$. Pentru a putea gasi cifrurile seifurilor, Johnie are nevoie de lumina. El cunoaste initial camerele in care lumina este aprinsa, si in care nu. De asemenea, stie ca in unele camere sunt intrerupatoare care modifica starea unor becuri. Fiind un hot priceput, Johnie a programat intrerupatoarele camerelor astfel incat un intrerupator din camera $i$ ( $0 &le; i &le; N - 1$ ) sa modifice atat becul din camera respectiva, cat si eventual unele becuri din camere de dupa $i$. De asemenea, stie ca pentru fiecare intrerupator i are nevoie de un timp T{~i~} pentru a-l actiona. \r\nCunoscand numarul de camere, starea lor initiala,  configuratia intrerupatoarelor (programate de Johnie) cat si timpul de actionare a acestora se cere sa determinati, daca este posibil, timpul minim in care Johnie poate face lumina in toate camerele.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $aprindere.in$ se gaeste $N$, numarul de camere si $M$, numarul de intrerupatoare. Pe urmatoarea linie gasim $N$ numere binare, $0$ reprezentand o camera in care lumina este inchisa iar $1$ o camera in care lumina e deschisa. Pe urmatoarele $M$ linii gasim mai intai $3$ numere $C$, $T{~C~}$ si $NR{~C~}$, reprezentand camera intrerupatorului, timpul necesar actionarii intrerupatorului respectiv si numarul de camere in care modifica starea becurilor. Urmeaza apoi $NR{~C~}$ numere reprezentand indicii camerelor in care becurile sunt schimbate de intrerupatorul curent (camera $i$ se va afla mereu in aceasta multime).\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $aprindere.out$ se gaseste un singur numar, cu semnificatia de mai sus.\r\n\r\nh2. Restrictii\r\n\r\n*    $1 &le; N &le; 1000$\r\n*    $1 &le; M &le; N$\r\n*    $1 &le; NRi &le; 100$\r\n*    $1 &le; Ti &le; 1000$\r\n*    intrerupatoarele din lista de intrare vor fi distincte\r\n*    pentru datele de test folosite va exista mereu solutie\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. aprindere.in |_. aprindere.out |\r\n|5 4\r\n0 1 0 0 1\r\n0 3 2 0 2\r\n1 3 2 1 2\r\n3 1 2 3 4\r\n4 2 1 4\r\n|6| \r\n\r\nh3. Explicatie\r\n\r\nSe actioneaza intrerupatoarele din camerele $0$, $3$ si $4$. Timpul total este $3 + 1 + 2 = 6$.\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"aprindere\") ==\r\n',48,'task: aprindere'),('documentatie/tutorial','Tutorial infoarena','2007-01-18 14:10:59','h1. Tutorial infoarena\r\n\r\n==include(page=\"template/todo\")==\r\n\r\n==include(page=\"template/raw\")==\r\n\r\nh2. Citirea problemelor\r\n\r\nProblemele de pe acest site sunt grupate in mai multe seturi(cate un set pentru fiecare concurs, un set mare care grupeaza problemele de olimpiada si un set special pentru problemele de bac). Ne vom referi la un set ca la o arhiva de probleme.\r\n\r\nAccesul problemelor se face mergand la sectiunea Citeste probleme. Din aceasta pagina se va selecta arhiva pentru care se doreste vizualizarea problemelor.\r\n\r\nOdata ajunsi aici va aparea o lista cu probleme. Selectati problema al carei text doriti sa il cititi.\r\nTrimiterea solutiilor\r\n\r\nPentru a trimite o rezolvare trebuie mai intai sa va logati. Daca nu aveti inca un cont personal accesati sectiunea Inregistrare. Odata logati mergeti la Trimitere solutii unde va trebui eventual sa alegeti arhiva pentru care doriti sa submitati solutia. Daca nu sunteti in arhiva corespunzatoarea alegeti optiunea Alege alta arhiva si faceti optiunea dorita.\r\n\r\nOdata aleasa arhiva pentru care veti trimite rezolvarea veti avea de completat:\r\n\r\n* problema pentru care veti trimite ( aceasta va fi aleasa din lista corespunzatoare)\r\n* fisierul de trimis (veti specifica calea de pe hard-disk a fisierului)\r\n* compilatorul pe care doriti sa se foloseasca (acesta se poate completa automat in functie de extensia sursei). \r\n\r\nAcum sunteti gata, apasati butonu Trimite soltuie! si asteptai mesajul de confirmare.\r\nVizualizare clasament\r\n\r\nClasamentul poate fi vizualizat in sectiunea Clasamente si alte statistici. Pentru concursurile on-line aceasta sectiune va fi disponibila doar dupa incheierea concursului si evaluarea solutiilor.\r\n\r\nPentru un borderou exact puteti merge la Monitorul de evalouare(aflat tot in sectiunea de Clasamente si statistici) si sa alegeti sursa pentru care doriti borderoul.\r\nAlte resurse\r\n\r\nPentru articole despre diversi algoritmi, arhive cu teste si solutii de pe la diverse concursuri nationale si internationale mergeti la Portalul de informatica.\r\n\r\nPentru discutii despre o anumita problema sau alte lucruri care tin de domeniul informaticii accesati Forumul infoarena. ',13,'public'),('newsletter/2007-01-18','preONI 2007, Runda #1','2007-01-18 14:19:01','Buna, %full_name%!\r\n\r\nIncepe o noua editie preONI, concursul cu premii care te\r\npregateste pentru Olimpiada Nationala de Informatica.\r\n\r\nPrima runda a concursului a fost programata ...\r\n\r\n    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\r\n    Duminica, 21 ianuarie 2007, orele 09:00 - 13:00\r\n    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~\r\n    Pagina rundei: %url_infoarena%preoni-2007/runda-1\r\n\r\n== Despre preONI ==\r\n\r\npreONI, concursul de marca al comunitatii infoarena,\r\neste dedicat elevilor de liceu ce se pregatesc pentru ONI\r\n(Olimpiada Nationala de Informatica).\r\n\r\nConcursul este impartit in 3 grupe: clasa a IX-a si gimnaziu,\r\nclasa a X-a si clasele XI-XII. Se organizeaza 4 runde online\r\nde calificare. In urma acestora, cei mai buni de la fiecare\r\ngrupa sunt invitati la o runda finala.\r\n\r\nIn cadrul unei runde, vei avea de rezolvat 3 probleme in 4h.\r\nCastigatorii rundei finale sunt premiati cu bani si/sau obiecte.\r\n\r\nPe pagina concursului ( %url_infoarena%preoni-2007 ) vei gasi\r\ninformatii despre cum participi, cine propune probleme, premii\r\nsi sponsori, regulamentul concursului samd.\r\n\r\n\r\n== Prima data la infoarena? ==\r\n\r\ninfoarena ajuta elevi si studenti sa devina excelenti\r\nin informatica! Gratuit ;)\r\n\r\nCiteste mai multe despre noi: %url_infoarena%despre-infoarena.\r\nVezi si ghidul utilizatorului: %url_infoarena%pentru-utilizatori.\r\n\r\n\r\nStai alaturi de noi. Te ajutam sa devii olimpic!\r\n\r\nSucces!\r\nEchipa infoarena\r\n\r\n\r\n\r\n== Despre acest mesaj ==\r\n\r\nEsti inscris pe %url_infoarena% cu numele\r\n%full_name%, utilizator %username%\r\nsi ai acceptat sa primesti mesaje de instiintare.\r\n\r\nDaca nu mai doresti instiintari, da click pe acest link:\r\n%url_unsubscribe%\r\n',13,'public'),('preoni-2007/regulament','Regulament preONI 2007','2007-01-15 15:58:15','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Regulament\r\n\r\nSe recomanda, pe langa citirea acestui regulament, citirea \"regulamentului\":regulament general infoarena.\r\n\r\n\'Echipa infoarena\':echipa-infoarena isi rezerva dreptul de a modifica prezentul regulament pe parcursul desfasurarii concursului. Daca apar prevederi noi sau daca anumite prevederi ale regulamentului sunt modificate sau eliminate, atunci acestea vor fi anuntate pe site-ul concursului. Orice modificare a regulamentului va intra in vigoare, in functie de situatie, fie din momentul publicarii ei, fie dupa incheierea rundei aflate in desfasurare. In momentul anuntarii modificarii va fi precizat si momentul din care aceasta intra in vigoare.\r\n\r\nh2. Dreptul de participare\r\n\r\nPersoanele care fac parte din \'echipa infoarena\':echipa-infoarena cat si alti contribuitorii implicati direct in organizarea concursului *preONI 2007* nu au dreptul de a participa. De asemenea, orice concurent care are un comportament considerat inadecvat fata de echipa infoarena sau fata de alti concurenti va fi descalificat. Un concurent se poate califica la finala doar daca se incadreaza in grupa la care a concurat (aceasta verificare se va face prin prezentarea unei dovezi legale care il incadreaza pe concurent la aceea grupa).\r\n\r\nh2. Repartizarea\r\n\r\nToti participantii vor fi repartizati in 3 grupe, in concordanta cu varsta lor. Repartizarii este asemanatoare cu acea facuta la olimpiadele de informatica.\r\n\r\n* Clasa a 9a (si gimnaziu)\r\n* Clasa a 10a\r\n* Clasele 11-12 \r\n\r\nOricine poate participa la o alta grupa decat cea la care se incadreaza, dar calificarea la finala cat si impartirea premiilor se va face conform regulamentului respectiv, fara nici o exceptie.\r\n\r\nh2. Inscriere\r\n\r\nTot ce trebuie sa faceti pentru a participa la concursul *preONI 2007* este sa aveti un cont la infoarena. Inregistrarea se poate face pe site-ul infoarena. Acelasi cont va fi folosit pentru a accesa forum-ul.\r\n\r\nh2. Runde\r\n\r\nVor exista 4 runde de calficare, iar in urma clasamentului stabilit primii de la fiecare grupa vor fi selectati pentru etapa finala desfasurata in cadrul unei tabere. Cele 4 runde vor avea loc sambata si duminica, incepand cu ora 9:00, desi pot interveni exceptii. Durata lor va fi de 4 ore. Pentru un program detaliat al concursului \"click aici\":preoni-2007/program.\r\n\r\nh2. Intrebari\r\n\r\nIn prima ora vor putea fi formulate eventualele intrebari, pe forum, in topicurile special create. Orice intrebare pusa in alt mod (primita ca personal message, pe mail, etc.) va fi ignorata. Raspunsuri vor fi oferite doar la intrebarile puse in prima ora . Intrebarile trebuie formulate astfel incat sa se poate raspunda cu DA sau NU. In caz contrar sau in cazul in care raspunsul se afla in textul problemei se va raspunde cu NO COMMENT. Nu vor exista exceptii de la aceaste reguli. Daca echipa va considera ca raspunsul la o anumita intrebare este de interes general si clarifica anumite aspecte, atunci se va face un anunt general care va aparea atat pe forum cat si in sectiunea Mesaje de la organizatori a grupei respective. Fiecare grupa va avea doi administratori care se vor ocupa de raspunsul acestor intrebari.\r\n\r\nh2. Trimiterea solutiilor\r\n\r\nTrimitrea solutiile se va face prin intermediul interfetei site-ului infoarena.\r\nOdata logati in contul vostru, veti putea selecta arhiva la care doriti sa lucrati (in cazul acesta una din arhivele {*preONI 2007*}) si veti putea folosi link-ul trimite solutii.\r\n\r\nh2. Evaluare\r\n\r\nDupa expirarea timpului de trimitere a solutiilor acestea vor fi evaluate (\"mai multe detalii aici\":documentatie/evaluator). In mod normal, evaluarea se va face imediat dupa concurs, desi exista posibilitatea ca echipa infoarena sa amane evaluarea din motive obiective. Veti putea vizualiza pozitia ocupata in clasament dupa evaluarea in rubrica Clasament.\r\n\r\nSe recomanda sa instalati pe calculatorul vostru aceleasi versiuni de compilatoare ca cele specificate la link-ul de mai sus. \'Echipa infoarena\':echipa-infoarena nu este responsabila pentru diferentele intre versiuni de compilatoare si nu va efectua reevaluaari in astfel de cazuri.\r\n\r\nh2. Contestatii\r\n\r\nEchipa infoarena isi rezerva dreptul de a reevalua orice problema in situatia in care se detecteaza erori in teste sau in programul de verificare dupa evaluare. Cum testele problemelor nu vor fi facute publice, posiblitatile de a contesta sunt limitate. Pentru a asigura o evaluarea corecta, echipa infoarena va garanteaza ca va testa intens toate problemele inainte de concurs si ca va verifica corectitudinea procesului de evaluare dupa terminare. In caz ca totusi aveti o contestatie, aceasta trebuie trimisa pe mail la adresa _mircea.pasoi -at- gmail.com_ in termen de 24 de ore de la afisarea rezultatelor rundei curente pe site. Ele vor fi rezolvate in termen de maxim 5 zile, iar dupa rezolvarea lor rezultatele vor fi declarate finale.\r\n\r\nh2. Solutii\r\n\r\nLa scurt timp dupa terminarea evaluarii se va publica un articol cu solutiile pentru problemele rundei respective. Testele utilizate pentru evaluare nu vor fi facute publice.\r\n\r\nh2. Transferul problemelor\r\n\r\nProblemele vor fi mutate dupa evaluare in Arhiva de probleme infoarena, avand astfel la dispozitie un evaluator 24 din 24 si posiblitatea de a finisa solutiile la problemele nerezolvate in timpul concursului.\r\n\r\nh2. Trisare\r\n\r\n*preONI 2007* este un concurs individual, asadar orice tentativa de colaborare va aduce descalificarea celor implicati. \'echipa infoarena\':echipa-infoarena isi rezerva dreptul de a verifica sursele concurentilor, iar in caz ca se descopera surse aproximativ identice, concurentii respectivi vor fi descalificati din concurs iar user-ul lor de pe infoarena eliminat. Tentativele de frauda (concurarea sub un alt nume decat cel adevarat, etc.) sau orice atac asupra sistemului de evaluare sau asupra paginilor infoarena vor fi pedepsite in aceeasi masura. \r\n',1,'protected'),('preoni-2007/runda-1','Runda 1 preONI 2007','2007-01-15 15:59:43','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Runda 1\r\n\r\n_in curand_\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==',1,'public'),('home','infoarena 2','2006-12-18 07:53:54','h1. Bine ai venit!\r\n\r\np. Acesta este *noul site infoarena*! Am inlocuit vechiul infoarena.devnet.ro dupa aproape 3 ani de functionare.\r\nSunt multe de spus despre noua versiune asa ca incepem cu ce e mai important ...\r\n\r\ntable(layout3). | *infoarena este un wiki*\r\nSchimba continutul paginilor sau sa creaza pagini noi.\r\n\'Afla mai multe&hellip;\':documentatie/wiki\r\n| *infoarena iti da rating*\r\nIti calculam rating-ul: un numar care reflecta performantele tale.\r\n\'Afla mai multe&hellip;\':documentatie/rating\r\n| *Forum integrat*\r\nAm avut grija ca forum-ul sa fie bine integrat in experienta infoarena.\r\n\'Afla mai multe&hellip;\':documentatie/forum |\r\n| *Fa-ti pagina personala*\r\nPrezinta-te comunitatii infoarena: cine esti, de unde vii, distinctii primite etc.\r\n\'Afla mai multe&hellip;\':documentatie/pagina-de-profil\r\n| *Un nou evaluator*\r\nEvaluatorul nou masoara mai exact timpii de executie si suporta tipuri noi de probleme si concursuri.\r\n\'Afla mai multe&hellip;\':documentatie/evaluator\r\n| *Mai usor de folosit*\r\nNoul infoarena este mai usor de navigat si de folosit.\r\n\'Afla mai multe&hellip;\':documentatie/pentru-utilizatori |\r\n\r\nh2. Ne trebuie feedback!\r\n\r\nNe asteptam sa gasim multe bug-uri si deficiente in noua versiune. Ajuta-ne sa facem o infoarena ca _Soarele sfant de pe cer_ :)\r\nAsteptam bug reports, sugestii, intrebari pe forum. Iata niste topic-uri de feedback:\r\n\r\n==SmfTopics(board_id=\"33\")==\r\n\r\nh2. Ce este infoarena?\r\n\r\ninfoarena este un site web care ajuta elevi si studenti sa obtina performanta in informatica! \'Afla mai multe&hellip;\':despre-infoarena\r\n\r\nCu ce ne ocupam?\r\n\r\n* Concursuri online de informatica pentru studenti si elevi\r\n* Stiri si articole despre informatica\r\n* Discutam pe forum tot despre informatica\r\n\r\nh2. Pentru programatori PHP / web\r\n\r\nSite-ul si evaluatorul infoarena sunt open-source! Codul sursa este \'liber disponibil\':http://hackers.devnet.ro/browser/trunk/infoarena2 iar dezvoltarea se face \'public\':http://hackers.devnet.ro.\r\n\r\nDaca stii PHP / tehnologii web / webdesign sau vrei sa inveti alaturi de noi, intra pe \"pagina de development\":documentatie/development. \r\n\r\nh2. Ultimele Stiri\r\n\r\n==News(pager_style=\"none\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':stiri',1,'protected'),('preoni-2007/runda-1','Runda 1 preONI 2007','2007-01-20 22:39:29','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. Runda 1\r\n\r\nConcursul se va desfasura duminica, 21 ianuarie, incepand cu ora 09:*30*. Pe parcursul celor 4 ore de concurs participantii vor avea de rezolvat 3 probleme de natura algoritmica.\r\n\r\n\r\nh2. Probleme\r\n\r\n*Atentie!* Pentru a participa la o clasa trebuie sa va inregistrati intrand pe pagina grupei la care doriti sa participati si folosind link-ul \"Inregistreaza-te!\".\r\n\r\n* \'Clasa a 9-a si gimnaziu\':preoni-2007/runda-1/9\r\n* \'Clasa a 10-a\':preoni-2007/runda-1/10\r\n* \'Clasele 11-12\':preoni-2007/runda-1/11-12\r\n\r\nh2. Clasamente\r\n\r\n* \'Clasa a 9-a si gimnaziu\':preoni-2007/clasament/runda-1/9\r\n* \'Clasa a 10-a\':preoni-2007/clasament/runda-1/10\r\n* \'Clasele 11-12\':preoni-2007/clasament/runda-1/11-12\r\n\r\nh2. Comisia stiintifica\r\n\r\n* Subiectele vor fi propuse de:\r\n==User(user=\"danielp\" type=\"tiny\")==\r\n==User(user=\"ditzonec\" type=\"tiny\")==\r\n==User(user=\"domino\" type=\"tiny\")==\r\n==User(user=\"filipb\" type=\"tiny\")==\r\n==User(user=\"greco\" type=\"tiny\")==\r\n\r\n* Pentru intrebari de factura organizatorica / tehnica poti contacta urmatoarele persoane:\r\n==User(user=\"fluffy\" type=\"tiny\")==\r\n==User(user=\"svalentin\" type=\"tiny\")==\r\n==User(user=\"wickedman\" type=\"tiny\")==\r\n\r\n*{\'Echipa infoarena\':echipa-infoarena}* va ureaza mult succes!\r\n\r\n\r\n==Include(page=\"template/preoni-2007/footer\")==',1,'protected'),('preoni-2007/clasament/runda-1/9','Clasament preONI 2007, Runda 1, Clasa a 9-a si gimnaziu','2007-01-20 22:53:52','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. == roundparam(round_id=\"preoni2007_runda1_9\" param=\"title\") ==\r\n\r\np<. == Rankings(rounds=\"preoni2007_runda1_9\") == \r\n\r\n==include(page=\"template/preoni-2007/footer\")==\r\n',1,'protected'),('preoni-2007/runda-1/9','preONI 2007, Runda 1, Clasa a 9-a si gimnaziu','2007-01-21 00:55:20','==Include(page=\"template/preoni-2007\")==\r\n\r\nh1. == roundparam(round_id=\"preoni2007_runda1_9\" param=\"title\") ==\r\n\r\n==roundregister(round_id=\"preoni2007_runda1_9\" template=\"template/preoni-2007/inscriere-runda\")==\r\n\r\nIncepe Duminica 21 ianuarie, la ora {*09^30^*} si dureaza 4h. Participantii vor avea de rezolvat 3 probleme de natura algoritmica.\r\n\r\nh2. Probleme\r\n\r\n== Tasks(round_id=\"preoni2007_runda1_9\" score=\"1\")==\r\n\r\nh2. Discutii pe forum\r\n\r\nVrei sa adresezi intrebari comisiei? Fa-o pe forum.\r\n\r\n==SmfTopics(board_id=\"35\")==\r\n\r\n==include(page=\"template/preoni-2007/footer\")==\r\n',13,'protected'),('problema/1-sir','1-sir','2007-01-20 18:25:55','== include(page=\"template/taskheader\" task_id=\"1-sir\") ==\r\n\r\nDefinim un {$1-sir$} de lungime $N$ un sir $s$ cu proprietatea {$|s{~i~} - s{~i+1~}| = 1$} pentru {$0 < i < N$} si {$s{~1~} = 0$}. Calculati numarul de 1-siruri de lungime $N$ cu suma tuturor termenilor $S$.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului {$1-sir.in$} se afla numerele $N$ si $S$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului {$1-sir.out$} se va afisa numarul de 1-siruri de lungime $N$ care au suma $S$, modulo $194767$.\r\n\r\nh2. Restrictii\r\n\r\n* $1 < N &le; 256$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. 1-sir.in |_. 1-sir.out |\r\n| 4 4\r\n| 1\r\n| \r\n\r\n== include(page=\"template/taskfooter\" task_id=\"1-sir\") ==\r\n',66,'task: 1-sir'),('template/userheader','template/userheader','2007-01-21 14:02:17','h1. test\r\n\r\nh1. ==UserInfo(user=\"%user%\" info=\"fullname\")== (%user%)\r\n\r\n== include(page=\"template/userinfo\" user=\"%user%\") ==\r\n',13,'protected'),('home','infoarena 2','2007-01-20 23:49:39','&nbsp;\r\n\r\ntable{width: 50%}=. |_=. \'*Participi la preONI, Runda 1? Click aici!*\':preoni-2007/runda-1 |\r\n\r\nh2. Un nou infoarena\r\n\r\np. Acesta este *noul site infoarena*! Am inlocuit vechiul infoarena.devnet.ro dupa aproape 3 ani de functionare.\r\nSunt multe de spus despre noua versiune asa ca incepem cu ce e mai important ...\r\n\r\ntable(layout3). | *infoarena este un wiki*\r\nSchimba continutul paginilor sau sa creaza pagini noi.\r\n\'Afla mai multe&hellip;\':documentatie/wiki\r\n| *infoarena iti da rating*\r\nIti calculam rating-ul: un numar care reflecta performantele tale.\r\n\'Afla mai multe&hellip;\':documentatie/rating\r\n| *Forum integrat*\r\nAm avut grija ca forum-ul sa fie bine integrat in experienta infoarena.\r\n\'Afla mai multe&hellip;\':documentatie/forum |\r\n| *Fa-ti pagina personala*\r\nPrezinta-te comunitatii infoarena: cine esti, de unde vii, distinctii primite etc.\r\n\'Afla mai multe&hellip;\':documentatie/pagina-de-profil\r\n| *Un nou evaluator*\r\nEvaluatorul nou masoara mai exact timpii de executie si suporta tipuri noi de probleme si concursuri.\r\n\'Afla mai multe&hellip;\':documentatie/evaluator\r\n| *Mai usor de folosit*\r\nNoul infoarena este mai usor de navigat si de folosit.\r\n\'Afla mai multe&hellip;\':documentatie/pentru-utilizatori |\r\n\r\nh2. Ne trebuie feedback!\r\n\r\nNe asteptam sa gasim multe bug-uri si deficiente in noua versiune. Ajuta-ne sa facem o infoarena ca _Soarele sfant de pe cer_ :)\r\nAsteptam bug reports, sugestii, intrebari pe forum. Iata niste topic-uri de feedback:\r\n\r\n==SmfTopics(board_id=\"33\")==\r\n\r\nh2. Ce este infoarena?\r\n\r\ninfoarena este un site web care ajuta elevi si studenti sa obtina performanta in informatica! \'Afla mai multe&hellip;\':despre-infoarena\r\n\r\nCu ce ne ocupam?\r\n\r\n* Concursuri online de informatica pentru studenti si elevi\r\n* Stiri si articole despre informatica\r\n* Discutam pe forum tot despre informatica\r\n\r\nDaca stii PHP / tehnologii web / webdesign sau vrei sa inveti alaturi de noi, intra pe \"pagina de development\":documentatie/development. \r\n\r\nh2. Ultimele Stiri\r\n\r\n==News(pager_style=\"none\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':stiri',13,'protected'),('home','infoarena 2','2007-01-21 14:07:15','&nbsp;\r\n\r\nh2. Un nou infoarena\r\n\r\np. Acesta este *noul site infoarena*! Am inlocuit vechiul infoarena.devnet.ro dupa aproape 3 ani de functionare.\r\nSunt multe de spus despre noua versiune asa ca incepem cu ce e mai important ...\r\n\r\ntable(layout3). | *infoarena este un wiki*\r\nSchimba continutul paginilor sau sa creaza pagini noi.\r\n\'Afla mai multe&hellip;\':documentatie/wiki\r\n| *infoarena iti da rating*\r\nIti calculam rating-ul: un numar care reflecta performantele tale.\r\n\'Afla mai multe&hellip;\':documentatie/rating\r\n| *Forum integrat*\r\nAm avut grija ca forum-ul sa fie bine integrat in experienta infoarena.\r\n\'Afla mai multe&hellip;\':documentatie/forum |\r\n| *Fa-ti pagina personala*\r\nPrezinta-te comunitatii infoarena: cine esti, de unde vii, distinctii primite etc.\r\n\'Afla mai multe&hellip;\':documentatie/pagina-de-profil\r\n| *Un nou evaluator*\r\nEvaluatorul nou masoara mai exact timpii de executie si suporta tipuri noi de probleme si concursuri.\r\n\'Afla mai multe&hellip;\':documentatie/evaluator\r\n| *Mai usor de folosit*\r\nNoul infoarena este mai usor de navigat si de folosit.\r\n\'Afla mai multe&hellip;\':documentatie/pentru-utilizatori |\r\n\r\nh2. Ne trebuie feedback!\r\n\r\nNe asteptam sa gasim multe bug-uri si deficiente in noua versiune. Ajuta-ne sa facem o infoarena ca _Soarele sfant de pe cer_ :)\r\nAsteptam bug reports, sugestii, intrebari pe forum. Iata niste topic-uri de feedback:\r\n\r\n==SmfTopics(board_id=\"33\")==\r\n\r\nh2. Ce este infoarena?\r\n\r\ninfoarena este un site web care ajuta elevi si studenti sa obtina performanta in informatica! \'Afla mai multe&hellip;\':despre-infoarena\r\n\r\nCu ce ne ocupam?\r\n\r\n* Concursuri online de informatica pentru studenti si elevi\r\n* Stiri si articole despre informatica\r\n* Discutam pe forum tot despre informatica\r\n\r\nDaca stii PHP / tehnologii web / webdesign sau vrei sa inveti alaturi de noi, intra pe \"pagina de development\":documentatie/development. \r\n\r\nh2. Ultimele Stiri\r\n\r\n==News(pager_style=\"none\")==\r\n\r\np(strap). Vezi \'arhiva stiri\':stiri',1,'protected'),('unirea-2007/clasele-9-10','unirea9-10','2007-01-22 16:12:12','h1. == roundparam(round_id=\"unirea9-10\" param=\"title\") ==\r\n\r\np>. ==roundstatus(round_id=\"unirea9-10\")==\r\n\r\n== roundregister(round_id=\"unirea9-10\") ==\r\n\r\nConcursul incepe ==roundparam(round_id=\"unirea9-10\" param=\"start_time\")== si dureaza ==roundparam(round_id=\"unirea9-10\" param=\"duration\")== ore.\r\n\r\nClasamentul poate fi vizualizat \'aici\':unirea9-10/clasament\r\n\r\nh2. Probleme\r\n\r\nAceasta lista va deveni vizibila doar in momentul inceperii concursului.\r\n\r\n== Tasks(round_id=\"unirea9-10\" score=\"1\")==',1,'round: unirea9-10'),('problema/maxsecv','maxsecv','2007-01-22 18:23:32','== include(page=\"template/taskheader\" task_id=\"maxsecv\") ==\r\n\r\nJohnie areun vector binar de $N$ elemente. El poate extrage o anumita subsecventa din vector, ramanand astfel cu un vector mai mic. Apoi, el poate insera subsecventa extrasa la orice pozitie din vectorul rezultat.\r\nSe cere sa se afle lungimea maxima a unei subsecvente pline de $1$ pe care o poate obtine Johnie daca efectueaza o singura operatie.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $maxsecv.in$ se afla $N$, dimensiunea vectorului. Urmeaza apoi pr urmatoarea linie $N$ numere de $0$ si $1$, reprezentand elementele vectorului.\r\n\r\n\r\nh2. Date de iesire\r\n\r\nFisierul de iesire $maxsecv.out$ trebuie sa contina un singur numar, reprezentand valoarea ceruta.\r\n\r\nh2. Restrictii\r\n\r\n*    $1 &le; N &le; 1 000 000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. maxsecv.in |_. maxsecv.out |\r\n|6\r\n1 1 0 1 1 1\r\n|5| \r\n|13\r\n0 1 1 1 0 1 1 1 1 0 1 1 0\r\n|7|\r\n\r\nh3. Explicatie\r\n\r\n\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"maxsecv\") ==\r\n',48,'task: maxsecv'),('unirea-2007/clasele-9-10','Unirea 2007, Clasele IX - X','2007-01-24 01:15:59','h1. == roundparam(round_id=\"unirea9-10\" param=\"title\") ==\r\n\r\n== roundregister(round_id=\"unirea9-10\") ==\r\n\r\nConcursul incepe *Sambata, 27 ianuarie, ora 14^00^* si dureaza *3 ore*.\r\n\r\nh2. Probleme\r\n\r\nAceasta lista va deveni vizibila doar in momentul inceperii concursului.\r\n\r\n== Tasks(round_id=\"unirea9-10\" score=\"1\")==\r\n\r\nh2. Organizatori\r\n\r\n* Subiectele vor fi propuse de:\r\n==User(user=\"danielp\" type=\"tiny\")==\r\n==User(user=\"azotlichid\" type=\"tiny\")==\r\n\r\n* Pentru intrebari de factura organizatorica / tehnica poti contacta urmatoarele persoane:\r\n==User(user=\"fluffy\" type=\"tiny\")==\r\n==User(user=\"svalentin\" type=\"tiny\")==\r\n==User(user=\"wickedman\" type=\"tiny\")==\r\n\r\n*{\'Echipa infoarena\':echipa-infoarena}* iti ureaza mult succes!\r\n',13,'round: unirea9-10'),('problema/amenzi','amenzi','2007-01-25 21:29:29','== include(page=\"template/taskheader\" task_id=\"amenzi\") ==\r\n\r\nIon este politist intr-un mare oras. In oras exista $N$ intersectii legate intre ele prin intermediul a $M$ strazi pe care se poate circula in ambele sensuri. Pentru fiecare strada se stie timpul $C{~i~}$ necesar pentru a o parcurge. Informat de o sursa sigura Ion stie ca in cursul urmatoarei zile se vor petrece $K$ infractiuni. Pentru fiecare infractiune $i$ se cunosc urmatoarele date: $T{~i~}$ - timpul la care infractiunea are loc, $A{~i~}$ - intersectia in care infractiunea are loc, $S{~i~}$ - amenda pe care Ion o poate da daca se afla in intersectia $S{~i~}$ la momentul $T{~i~}$.\r\n\r\nStie ca in cursul zilei urmatoare trebuie sa se intalneasca cu sotia sa, dar nu mai stie exact nici timpul nici ora la care trebuie sa faca acest lucru. Tot ce isi aminteste sunt $P$ perechi de forma $X{~i~}$, $Y{~i~}$ care semnifica faptul ca s-ar putea sa trebuiasca sa se intalneasca cu sotia sa la momentul $Y{~i~}$ in intersectia {$X{~i~}$}.\r\n\r\nAvand la dispozitie toate aceste date ajutati-l pe Ion sa afle valoare maxima totala a amenzilor pe care o poate da pentru fiecare din cele $P$ perechi pe care si le aminteste. Din momentul in care se intalneste cu sotia sa Ion nu va mai da amenzi.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $amenzi.in$ se afla patru numere intregi {$N$}, {$M$}, {$K$} si {$P$} cu semnificatia din enunt. Urmatoarele $M$ linii contin cate trei numere {$a$}, $b$ si $c$ cu semnificatia ca exista o strada ce leaga intersectiile $a$ si $b$ si care poate fi parcursa in $c$ unitati de timp. Urmatoarele $K$ linii contin cate trei numere {$a$}, $b$ si $c$ cu semnificatia ca va avea loc o infractiune in intersectia {$a$}, la timpul $b$ si pentru care se va da o amenda in valoare de {$c$} unitati monetare. Apoi urmeaza $P$ linii cu cate doua numere $a$ si $b$ cu seminficatia ca este posibil ca Ion sa se intalneasca cu sotia sa in intersectia $a$ la momentul {$b$}.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $amenzi.out$ vor exista $P$ linii coninand valoarea totala maxima pe care Ion o va obtine din amenzi in fiecare din cele $P$ cazuri descrise in fisierul de intrare.\r\n\r\nh2. Restrictii\r\n\r\n* Initial Ion se afla in intersectia $1$ la momentul {$0$}.\r\n* Timpii la care se petrec infractiunile si la care Ion se poate intalni cu sotia sa sunt in intervalul [{$0, 1000$}]\r\n* {$0 &le; K &le; 1000$}\r\n* {$1 &le; N &le; 100$}\r\n* {$1 &le; M &le; 1000$}\r\n* Costul unei amenzi va fi un intreg din intervalul [{$1, 1000$}]\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. amenzi.in |_. amenzi.out |\r\n| This is some\r\n  text written on\r\n  multiple lines.\r\n| This is another\r\n  text written on\r\n  multiple lines.\r\n| \r\n\r\nh3. Explicatie\r\n\r\n...\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"amenzi\") ==\r\n',961,'task: amenzi'),('problema/chernel','chernel','2007-01-26 16:24:35','== include(page=\"template/taskheader\" task_id=\"chernel\") ==\r\n\r\nPoveste si cerinta...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n... &le; ...\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. chernel.in |_. chernel.out |\r\n| This is some\r\n  text written on\r\n  multiple lines.\r\n| This is another\r\n  text written on\r\n  multiple lines.\r\n| \r\n\r\nh3. Explicatie\r\n\r\n...\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"chernel\") ==\r\n',18,'task: chernel'),('problema/chernel','chernel','2007-01-26 16:54:02','== include(page=\"template/taskheader\" task_id=\"chernel\") ==\r\n\r\nChernel a renuntat la afaceri si s-a apucat de matematica. De aceasta data, el studiaza niste siruri mai speciale. Chernel porneste de la un sir de N numere naturale a1 a2 ... aN, pe care aplica transformari succesive care schimba un sir de X elemente a1 a2 ... aX in sirul de X-1 elemente a1+a2 a2+a3 ... aX-1+aX. Chernel repeta aceasta operatie pana cand ramane cu un singur element. De aici obtine \"numarul caracteristic\" al sirului, ca fiind restul impartirii aceslui ultim element ramas la un numar natural M.\r\n\r\nChernel observa ca valorile unor elemente din sirul initial nu influenteaza numarul caracteristic al sirului, altfel spus oricare ar fi valoarea acestora, numarul caracteristic ramane acelasi.\r\n\r\nPentru N si M date, ajutati-l pe Chernel sa afle cate astfel de valori exista in sirul initial.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare se gasesc cele doua numere naturale N si M.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului de iesire se va gasi un singur numar natural, reprezentand numarul de elemente din sirul initial a caror valoare nu influenteaza numarul caracteristic al sirului.\r\n\r\nh2. Restrictii\r\n\r\n* 1 &le; N &le; 100.000\r\n* 1 &le; M &le; 1.000.000\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. chernel.in |_. chernel.out |\r\n| This is some\r\n  text written on\r\n  multiple lines.\r\n| This is another\r\n  text written on\r\n  multiple lines.\r\n| \r\n\r\nh3. Explicatie\r\n\r\n...\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"chernel\") ==\r\n',18,'task: chernel'),('problema/chernel','chernel','2007-01-26 17:16:10','== include(page=\"template/taskheader\" task_id=\"chernel\") ==\r\n\r\nChernel a renuntat la afaceri si s-a apucat de matematica. De aceasta data, el studiaza niste siruri mai speciale. Chernel porneste de la un sir de $N$ numere naturale $a{~1~} a{~2~} ... a{~N~}$, pe care aplica transformari succesive care schimba un sir de $X$ elemente $a{~1~} a{~2~} ... a{~X~}$ in sirul de $X-1$ elemente $a{~1~}+a{~2~} a{~2~}+a{~3~} ... a{~N-1~}+a{~N~}$. Chernel repeta aceasta operatie pana cand ramane cu un singur element. De aici obtine $\"numarul caracteristic\"$ al sirului, ca fiind restul impartirii aceslui ultim element ramas la un numar natural $M$.\r\n\r\nChernel observa ca valorile unor elemente din sirul initial nu influenteaza $numarul caracteristic$ al sirului, altfel spus oricare ar fi valoarea acestora, numarul caracteristic ramane acelasi.\r\n\r\nPentru $N$ si $M$ date, ajutati-l pe Chernel sa afle cate astfel de valori exista in sirul initial.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare se gasesc cele doua numere naturale $N$ si $M$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului de iesire se va gasi un singur numar natural, reprezentand numarul de elemente din sirul initial a caror valoare nu influenteaza $numarul caracteristic$ al sirului.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 100.000$\r\n* $1 &le; M &le; 1.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. chernel.in |_. chernel.out |\r\n| 3 10\r\n| 666\r\n| \r\n\r\nh3. Explicatie\r\n\r\nFie sirul initial a1 a2 a3. Acesta se transforma in a1+a2 a2+a3 apoi in a1+2*a2+a3 ...blah, blah :-@\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"chernel\") ==\r\n',18,'task: chernel'),('problema/chernel','chernel','2007-01-26 19:13:21','== include(page=\"template/taskheader\" task_id=\"chernel\") ==\r\n\r\nChernel a renuntat la afaceri si s-a apucat de matematica. De aceasta data, el studiaza niste siruri mai speciale. Chernel porneste de la un sir de $N$ numere naturale $a{~1~} a{~2~} ... a{~N~}$, pe care aplica transformari succesive care schimba un sir de $X$ elemente $a{~1~} a{~2~} ... a{~X~}$ in sirul de $X-1$ elemente $a{~1~}+a{~2~} a{~2~}+a{~3~} ... a{~N-1~}+a{~N~}$. Chernel repeta aceasta operatie pana cand ramane cu un singur element. De aici obtine ${\"numarul caracteristic\"}$ al sirului, ca fiind restul impartirii aceslui ultim element ramas la un numar natural $M$.\r\n\r\nChernel observa ca valorile unor elemente din sirul initial nu influenteaza ${numarul caracteristic}$ al sirului, altfel spus oricare ar fi valoarea acestora, ${numarul caracteristic}$ ramane acelasi.\r\n\r\nPentru $N$ si $M$ date, ajutati-l pe Chernel sa afle cate astfel de valori exista in sirul initial.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare se gasesc cele doua numere naturale $N$ si $M$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului de iesire se va gasi un singur numar natural, reprezentand numarul de elemente din sirul initial a caror valoare nu influenteaza $numarul caracteristic$ al sirului.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 100.000$\r\n* $1 &le; M &le; 1.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. chernel.in |_. chernel.out |\r\n| 3 2\r\n| 1\r\n| \r\n\r\nh3. Explicatie\r\n\r\nFie sirul initial $a{~1~} a{~2~} a{~3~}$. Acesta se transforma in $a{~1~}+a{~2~}$ a{~2~}+a{~3~}$ apoi in $a{~1~}+2*a{~2~}+a{~3~}$. Pentru $M = 2$, singura valoare a sirului initial care nu influenteaza ${\"numarul caracteristic\"}$ este $a{~2~}$\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"chernel\") ==\r\n',18,'task: chernel'),('problema/secv5','secv5','2007-01-26 22:50:38','== include(page=\"template/taskheader\" task_id=\"secv5\") ==\r\n\r\nPoveste si cerinta...\r\n\r\nh2. Date de intrare\r\n\r\n...\r\n\r\nh2. Date de iesire\r\n\r\n...\r\n\r\nh2. Restrictii\r\n\r\n... &le; ...\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. secv5.in |_. secv5.out |\r\n| This is some\r\n  text written on\r\n  multiple lines.\r\n| This is another\r\n  text written on\r\n  multiple lines.\r\n| \r\n\r\nh3. Explicatie\r\n\r\n...\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"secv5\") ==\r\n',1,'task: secv5'),('unirea-2007/clasele-11-12','Unirea 2007, clasele 11-12','2007-01-24 01:24:06','(htabs)* \'*Home*\':unirea-2007\r\n* \'Clasele IX-X\':unirea-2007/clasele-9-10\r\n*(active) \'Clasele XI-XII\':unirea-2007/clasele-11-12\r\n\r\nh1. == roundparam(round_id=\"unirea11-12\" param=\"title\") ==\r\n\r\n== roundregister(round_id=\"unirea11-12\") ==\r\n\r\nConcursul incepe *Sambata, 27 ianuarie, ora 14^00^* si dureaza *3 ore*.\r\n\r\nh2. Probleme\r\n\r\nAceasta lista va deveni vizibila doar in momentul inceperii concursului.\r\n\r\n_Lista de probleme va aparea in momentul inceperii concursului._\r\n\r\nh2. Organizatori\r\n\r\n* Subiectele vor fi propuse de:\r\n==User(user=\"ditzonec\" type=\"tiny\")==\r\n==User(user=\"domino\" type=\"tiny\")==\r\n\r\n* Pentru intrebari de factura organizatorica / tehnica poti contacta urmatoarele persoane:\r\n==User(user=\"wickedman\" type=\"tiny\")==\r\n\r\n*{\'Echipa infoarena\':echipa-infoarena}* iti ureaza mult succes!\r\n',13,'round: unirea11-12'),('problema/aprindere','Aprindere','2007-01-21 00:21:18','== include(page=\"template/taskheader\" task_id=\"aprindere\") ==\r\n\r\nJohnie vrea sa sparga o banca, in care seifurile sunt asezate in $N$ camere alaturate. Astfel camerele sunt asezate in ordinea $0, 1, 2 ... N - 1$. Pentru a putea gasi cifrurile seifurilor, Johnie are nevoie de lumina. El cunoaste initial camerele in care lumina este aprinsa, si in care nu. De asemenea, stie ca in unele camere sunt intrerupatoare care modifica starea unor becuri. Fiind un hot priceput, Johnie a programat intrerupatoarele camerelor astfel incat un intrerupator din camera $i$ ( $0 &le; i &le; N - 1$ ) sa modifice atat becul din camera respectiva, cat si eventual unele becuri din camere de dupa $i$. De asemenea, stie ca pentru fiecare intrerupator i are nevoie de un timp $T{~i~}$ pentru a-l actiona. \r\nCunoscand numarul de camere, starea lor initiala,  configuratia intrerupatoarelor (programate de Johnie) cat si timpul de actionare a acestora se cere sa determinati, daca este posibil, timpul minim in care Johnie poate face lumina in toate camerele.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului $aprindere.in$ se gaseste $N$, numarul de camere si $M$, numarul de intrerupatoare. Pe urmatoarea linie gasim $N$ cifre de {$0$} sau {$1$}, $0$ reprezentand o camera in care lumina este inchisa iar $1$ o camera in care lumina e deschisa. Pe urmatoarele $M$ linii gasim mai intai $3$ numere $C$, $T{~C~}$ si $NR{~C~}$, reprezentand camera intrerupatorului, timpul necesar actionarii intrerupatorului respectiv si numarul de camere in care modifica starea becurilor. Urmeaza apoi $NR{~C~}$ numere reprezentand indicii camerelor in care becurile sunt schimbate de intrerupatorul curent (camera $i$ se va afla mereu in aceasta multime).\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul $aprindere.out$ se gaseste un singur numar, cu semnificatia de mai sus.\r\n\r\nh2. Restrictii\r\n\r\n*    $1 &le; N &le; 1000$\r\n*    $1 &le; M &le; N$\r\n*    $1 &le; NR{~i~} &le; 100$\r\n*    $1 &le; T{~i~} &le; 1000$\r\n*    Intrerupatoarele din lista de intrare vor fi distincte\r\n*    Pentru datele de test folosite va exista mereu solutie\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. aprindere.in |_. aprindere.out |\r\n|5 4\r\n0 1 0 0 1\r\n0 3 2 0 2\r\n1 3 2 1 2\r\n3 1 2 3 4\r\n4 2 1 4\r\n|6| \r\n\r\nh3. Explicatie\r\n\r\nSe actioneaza intrerupatoarele din camerele $0$, $3$ si $4$. Timpul total este $3 + 1 + 2 = 6$.\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"aprindere\") ==\r\n',1,'task: aprindere'),('problema/amenzi','amenzi','2007-01-26 23:13:20','== include(page=\"template/taskheader\" task_id=\"amenzi\") ==\r\n\r\nIon este politist intr-un mare oras. In oras exista $N$ intersectii legate intre ele prin intermediul a $M$ strazi pe care se poate circula in ambele sensuri. Pentru fiecare strada se stie timpul $C{~i~}$ necesar pentru a o parcurge. Informat de o sursa sigura Ion stie ca in cursul urmatoarei zile se vor petrece $K$ infractiuni. Pentru fiecare infractiune $i$ se cunosc urmatoarele date: $T{~i~}$ - timpul la care infractiunea are loc, $A{~i~}$ - intersectia in care infractiunea are loc, $S{~i~}$ - amenda pe care Ion o poate da daca se afla in intersectia $S{~i~}$ la momentul $T{~i~}$.\r\n\r\nStie ca in cursul zilei urmatoare trebuie sa se intalneasca cu sotia sa, dar nu mai stie exact nici timpul nici ora la care trebuie sa faca acest lucru. Tot ce isi aminteste sunt $P$ perechi de forma $X{~i~}$, $Y{~i~}$ care semnifica faptul ca s-ar putea sa trebuiasca sa se intalneasca cu sotia sa la momentul $Y{~i~}$ in intersectia {$X{~i~}$}.\r\n\r\nAvand la dispozitie toate aceste date ajutati-l pe Ion sa afle valoare maxima totala a amenzilor pe care o poate da pentru fiecare din cele $P$ perechi pe care si le aminteste. Din momentul in care se intalneste cu sotia sa Ion nu va mai da amenzi.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $amenzi.in$ se afla patru numere intregi {$N$}, {$M$}, {$K$} si {$P$} cu semnificatia din enunt. Urmatoarele $M$ linii contin cate trei numere {$a$}, $b$ si $c$ cu semnificatia ca exista o strada ce leaga intersectiile $a$ si $b$ si care poate fi parcursa in $c$ unitati de timp. Urmatoarele $K$ linii contin cate trei numere {$a$}, $b$ si $c$ cu semnificatia ca va avea loc o infractiune in intersectia {$a$}, la timpul $b$ si pentru care se va da o amenda in valoare de {$c$} unitati monetare. Apoi urmeaza $P$ linii cu cate doua numere $a$ si $b$ cu seminficatia ca este posibil ca Ion sa se intalneasca cu sotia sa in intersectia $a$ la momentul {$b$}.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $amenzi.out$ vor exista $P$ linii coninand valoarea totala maxima pe care Ion o va obtine din amenzi in fiecare din cele $P$ cazuri descrise in fisierul de intrare. Daca Ion nu poate ajunge sub nici o forma in intersectia respectiva la momenul stabilit afisati $-1$ pe testul respectiv.\r\n\r\nh2. Restrictii\r\n\r\n* Initial Ion se afla in intersectia $1$ la momentul {$0$}.\r\n* Timpii la care se petrec infractiunile si la care Ion se poate intalni cu sotia sa sunt in intervalul [{$0, 3500$}]\r\n* {$0 &le; K &le; 4000$}\r\n* {$0 &le; P &le; 2500$}\r\n* {$1 &le; N &le; 150$}\r\n* {$1 &le; M &le; 1500$}\r\n* Timpul necesar parcurgerii unei strazi este un numar intreg strict pozitiv\r\n* Costul unei amenzi va fi un intreg din intervalul [{$1, 10000$}]\r\n* Pot exista mai multe strazi intre aceleasi orase\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. amenzi.in |_. amenzi.out |\r\n| 5 7 4 2\r\n5 4 4\r\n4 3 5\r\n2 3 7\r\n3 1 3\r\n5 2 3\r\n4 1 10\r\n4 2 1\r\n2 6 5736\r\n2 20 2567\r\n5 6 1530\r\n3 3 4067\r\n1 50\r\n3 15\r\n| 6634\r\n4067\r\n| \r\n\r\nh3. Explicatie\r\n\r\nPentru primul caz Ion va merge in intersectia 3 unde va ajunge la momentul 3 exact la timp pentru a da o amenda in valoare de 4067. Apoi merge in intersectia 2 unde ajunge la momentul 10. Aici asteapta pana la momentul 20 cand da amenda in valoare de 2567. El merge apoi la intersectia 1 unde isi va astepta sotia pana la momentul 50.\r\n\r\nPentru al doilea caz Ion merge in intersectia 3 unde ajunge la momentul 3, da amenda in valoare de 4067 apoi isi asteapta sotia pana la momentul 15.\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"amenzi\") ==\r\n',961,'task: amenzi'),('template/userinfo','template/userinfo','2007-01-27 10:08:10','table(compact). |/5. !utilizator/%user%?avatar 150x150! |_. Nume | == userinfo(user=\"%user%\" info=\"fullname\")== |\r\n| |_. Cont | ==userinfo(user=\"%user%\" info=\"username\")== |\r\n| |_. Rating | ==userinfo(user=\"%user%\" info=\"rating\")== |\r\n| |_. Statut | ==userinfo(user=\"%user%\" info=\"security\")== |\r\n|_. Forum | ==SmfLink(user=\"%user%\" link=\"pm\" caption=\"trimite mesaj privat\")==, ==SmfLink(user=\"%user%\" link=\"stats\" caption=\"vezi activitate\")== |\r\n\r\n\'Vezi solutiile trimise\':monitor?user=%user%\r\n',1,'protected'),('problema/amenzi','amenzi','2007-01-27 10:43:36','== include(page=\"template/taskheader\" task_id=\"amenzi\") ==\r\n\r\nIon este politist intr-un mare oras. In oras exista $N$ intersectii legate intre ele prin intermediul a $M$ strazi pe care se poate circula in ambele sensuri. Pentru fiecare strada se stie timpul $C{~i~}$ necesar pentru a o parcurge. Informat de o sursa sigura Ion stie ca in cursul urmatoarei zile se vor petrece $K$ infractiuni. Pentru fiecare infractiune $i$ se cunosc urmatoarele date: $T{~i~}$ - timpul la care infractiunea are loc, $A{~i~}$ - intersectia in care infractiunea are loc, $S{~i~}$ - amenda pe care Ion o poate da daca se afla in intersectia $S{~i~}$ la momentul $T{~i~}$.\r\n\r\nStie ca in cursul zilei urmatoare trebuie sa se intalneasca cu sotia sa, dar nu mai stie exact nici timpul nici ora la care trebuie sa faca acest lucru. Tot ce isi aminteste sunt $P$ perechi de forma $X{~i~}$, $Y{~i~}$ care semnifica faptul ca s-ar putea sa trebuiasca sa se intalneasca cu sotia sa la momentul $Y{~i~}$ in intersectia {$X{~i~}$}.\r\n\r\nAvand la dispozitie toate aceste date ajutati-l pe Ion sa afle valoare maxima totala a amenzilor pe care o poate da pentru fiecare din cele $P$ perechi pe care si le aminteste. Din momentul in care se intalneste cu sotia sa Ion nu va mai da amenzi.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare $amenzi.in$ se afla patru numere intregi {$N$}, {$M$}, {$K$} si {$P$} cu semnificatia din enunt. Urmatoarele $M$ linii contin cate trei numere {$a$}, $b$ si $c$ cu semnificatia ca exista o strada ce leaga intersectiile $a$ si $b$ si care poate fi parcursa in $c$ unitati de timp. Urmatoarele $K$ linii contin cate trei numere {$a$}, $b$ si $c$ cu semnificatia ca va avea loc o infractiune in intersectia {$a$}, la timpul $b$ si pentru care se va da o amenda in valoare de {$c$} unitati monetare. Apoi urmeaza $P$ linii cu cate doua numere $a$ si $b$ cu seminficatia ca este posibil ca Ion sa se intalneasca cu sotia sa in intersectia $a$ la momentul {$b$}.\r\n\r\nh2. Date de iesire\r\n\r\nIn fisierul de iesire $amenzi.out$ vor exista $P$ linii coninand valoarea totala maxima pe care Ion o va obtine din amenzi in fiecare din cele $P$ cazuri descrise in fisierul de intrare. Daca Ion nu poate ajunge sub nici o forma in intersectia respectiva la momenul stabilit afisati $-1$ pe testul respectiv.\r\n\r\nh2. Restrictii\r\n\r\n* Initial Ion se afla in intersectia $1$ la momentul {$0$}.\r\n* Timpii la care se petrec infractiunile si la care Ion se poate intalni cu sotia sa sunt in intervalul [{$0, 3500$}]\r\n* {$0 &le; K &le; 12000$}\r\n* {$0 &le; P &le; 8000$}\r\n* {$1 &le; N &le; 150$}\r\n* {$1 &le; M &le; 1500$}\r\n* Timpul necesar parcurgerii unei strazi este un numar intreg strict pozitiv\r\n* Costul unei amenzi va fi un intreg din intervalul [{$1, 10000$}]\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. amenzi.in |_. amenzi.out |\r\n| 5 7 4 2\r\n5 4 4\r\n4 3 5\r\n2 3 7\r\n3 1 3\r\n5 2 3\r\n4 1 10\r\n4 2 1\r\n2 6 5736\r\n2 20 2567\r\n5 6 1530\r\n3 3 4067\r\n1 50\r\n3 15\r\n| 6634\r\n4067\r\n| \r\n\r\nh3. Explicatie\r\n\r\nPentru primul caz Ion va merge in intersectia 3 unde va ajunge la momentul 3 exact la timp pentru a da o amenda in valoare de 4067. Apoi merge in intersectia 2 unde ajunge la momentul 10. Aici asteapta pana la momentul 20 cand da amenda in valoare de 2567. El merge apoi la intersectia 1 unde isi va astepta sotia pana la momentul 50.\r\n\r\nPentru al doilea caz Ion merge in intersectia 3 unde ajunge la momentul 3, da amenda in valoare de 4067 apoi isi asteapta sotia pana la momentul 15.\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"amenzi\") ==\r\n',961,'task: amenzi'),('problema/chernel','Chernel','2007-01-26 20:15:04','== include(page=\"template/taskheader\" task_id=\"chernel\") ==\r\n\r\nChernel a renuntat la afaceri si s-a apucat de matematica. De aceasta data, el studiaza niste siruri mai speciale. Chernel porneste de la un sir de $N$ numere naturale $a{~1~} a{~2~} ... a{~N~}$, pe care aplica transformari succesive care schimba un sir de $X$ elemente $a{~1~} a{~2~} ... a{~X~}$ in sirul de $X-1$ elemente $a{~1~}+a{~2~} a{~2~}+a{~3~} ... a{~N-1~}+a{~N~}$. Chernel repeta aceasta operatie pana cand ramane cu un singur element. De aici obtine $numarul caracteristic$ al sirului, ca fiind restul impartirii aceslui ultim element ramas la un numar natural $M$.\r\n\r\nChernel observa ca valorile unor elemente din sirul initial nu influenteaza $numarul caracteristic$ al sirului, altfel spus oricare ar fi valoarea acestora, $numarul caracteristic$ ramane acelasi.\r\n\r\nPentru $N$ si $M$ date, ajutati-l pe Chernel sa afle cate astfel de valori exista in sirul initial.\r\n\r\nh2. Date de intrare\r\n\r\nPe prima linie a fisierului de intrare se gasesc cele doua numere naturale $N$ si $M$.\r\n\r\nh2. Date de iesire\r\n\r\nPe prima linie a fisierului de iesire se va gasi un singur numar natural, reprezentand numarul de elemente din sirul initial a caror valoare nu influenteaza $numarul caracteristic$ al sirului.\r\n\r\nh2. Restrictii\r\n\r\n* $1 &le; N &le; 100.000$\r\n* $1 &le; M &le; 1.000.000.000$\r\n\r\nh2. Exemplu\r\n\r\ntable(example). |_. chernel.in |_. chernel.out |\r\n| 3 2\r\n| 1\r\n| \r\n\r\nh3. Explicatie\r\n\r\nFie sirul initial $a{~1~} a{~2~} a{~3~}$. Acesta se transforma in $a{~1~}+a{~2~} a{~2~}+a{~3~}$ apoi in $a{~1~}+2*a{~2~}+a{~3~}$. Pentru $M = 2$, singura valoare a sirului initial care nu influenteaza $numarul caracteristic$ este $a{~2~}$\r\n\r\n== include(page=\"template/taskfooter\" task_id=\"chernel\") ==\r\n',18,'task: chernel'),('stiri/s-a-incheiat-unirea-2007','S-a incheiat concursul Unirea 2007','2007-01-27 16:50:29','h1. S-a incheiat Unirea 2007\r\n\r\nEvaluarea a inceput imediat dupa terminarea timpului de lucru. \'Rezultatele au fost publicate\':unirea-2007/rezultate-9-10 iar problemele au fost adaugate in \'arhiva\':arhiva.\r\n\r\nLa acest concurs s-au inscris *342 de concurenti*. 237 concurenti au trimis cel putin o solutie. In total au fost evaluate *545 de solutii*.\r\n\r\n\'*Vezi clasamentul*\':unirea-2007/rezultate-9-10\r\n',13,'public'),('unirea-2007/solutii','Solutii Unirea 2007','2007-01-27 21:33:28','h1. Solutii\r\n\r\nh2. Maxsecv\r\n\r\nh3. (clasele 9-10)\r\n\r\n...\r\n\r\nh2. Chernel\r\n\r\nh3. (clasele 9-10)\r\n\r\nConsiderandu-se sirul $a{~1~} a{~2~} ... a{~N~}$ pentru un $N$ fixat, se observa ca dupa $N-1$ transformari, acesta devine $a{~1~} * C{~N-1~}^0^ + a{~2~} * C{~N-1~}^1^ + a{~3~} * C{~N-1~}^2^ + ... + a{~N~} * C{~N-1~}^N-1^$ . De aici reiese ca elementele sirului initial a calor valoare nu influenteaza numarul caracteristic (numarul din ultimul sir obtinut $modulo M$) sunt cele ai caror coeficienti sunt multipli ai lui $M$. Astfel problema se reduce la numararea combinarilor de $N-1$ luate cate $i$ (cu $i$ intre $0$ si $N-1$) care sunt multipli de $M$. Aceasta se realizeaza simplu \"generand\" combinarile respective: ne bazam pe recurenta $C{~N~}^k+1^ = C{~N~}^k^ * (n-k) / (k+1)$ si verificam cate dintre acestea sunt divizibile cu $M$. Problema este ca aceste valori vor deveni uriase destul de rapid, iar stocarea lor in memoria calculatorului este ineficienta. Din acest motiv nu se vor retine numerele propriu zise, ci doar exponentii factorilor primi ai lui $M$, (numarul maxim de factori primi ai lui fiind aproximat la $O(ln ln M)$, si $9$ pentru datele de test ale problemei) care se vor actualiza pentru fiecare combinare procesata.\r\nComplexitatea finala a algoritmului devine astfel $O(N * ln ln M)$.\r\n\r\nh2. Amenzi\r\n\r\nh3. (clasele 11-12)\r\n\r\nProblema se poate rezolva folosind metoda programarii dinamice. Se construieste matricea $A{~t,i~}$ in care se retine valoarea totala a amenzilor ce poate fi data pana la momentul $t$ astfel incat la momentul $t$ sa fim in intersectia {$i$}. Pentru toate muchiile ({$j,i$}) de cost $c$ vom compara {$A{~t,i~}$} cu {$A{~t-c,j~}$} alegand maximul dintre aceste valori. De fapt ar trebui inspectate toate valorile {$A{~t-c,j~}$} {$A{~t-c-1,j~}$} ... {$A{~1,j~}$} {$A{~0,j~}$} dar este clar ca maximul acestor valori se afla in {$A{~t-c,j~}$}. Deasemenea trebuie considerat cazul cand politistul sta pe loc deci ne vom uita si la valoarea din {$A{~t-1,i~}$}. Apoi politistul va da toate amenzile posibile la momentul respectiv in intersectia respectiva deci vom aduna respectiva suma la {$A{~t,i~}$}.\r\nAvand construita aceasta matrice se poate raspunde in $O(1)$ la fiecare intrebare.\r\nComplexitatea totala va fi $O(Tmax * M)$ ca timp si $O( Tmax * N )$ ca memorie. \r\n\r\nh2. Secventa 5\r\n\r\nh3. (clasele 11-12)\r\n\r\n...\r\n',961,'private'),('unirea-2007/solutii','Solutii Unirea 2007','2007-01-27 22:22:05','h1. Solutii\r\n\r\nh2. Maxsecv\r\n\r\nSe observa ca secventa maxima de $1$ care se poate obtine are lungimea egala cu suma primelor doua secvente maxime din vectorul original. Printr-o operatie descrisa se pot alatura cu usurinta cele doua secvente. \r\nPentru obtinerea unei solutii liniare e suficient sa parcurgem vectorul de la stanga la dreapta si sa updatam la fiecare pas lungimea secventei curente de $1$. In momentul in care ajungem la capatul unei astfel de secvente facem un update pentru primul si al 2-lea maxim, dupa caz.\r\n\r\nh3. (clasele 9-10)\r\n\r\n...\r\n\r\nh2. Chernel\r\n\r\nh3. (clasele 9-10)\r\n\r\nConsiderandu-se sirul $a{~1~} a{~2~} ... a{~N~}$ pentru un $N$ fixat, se observa ca dupa $N-1$ transformari, acesta devine $a{~1~} * C{~N-1~}^0^ + a{~2~} * C{~N-1~}^1^ + a{~3~} * C{~N-1~}^2^ + ... + a{~N~} * C{~N-1~}^N-1^$ . De aici reiese ca elementele sirului initial a calor valoare nu influenteaza numarul caracteristic (numarul din ultimul sir obtinut $modulo M$) sunt cele ai caror coeficienti sunt multipli ai lui $M$. Astfel problema se reduce la numararea combinarilor de $N-1$ luate cate $i$ (cu $i$ intre $0$ si $N-1$) care sunt multipli de $M$. Aceasta se realizeaza simplu \"generand\" combinarile respective: ne bazam pe recurenta $C{~N~}^k+1^ = C{~N~}^k^ * (n-k) / (k+1)$ si verificam cate dintre acestea sunt divizibile cu $M$. Problema este ca aceste valori vor deveni uriase destul de rapid, iar stocarea lor in memoria calculatorului este ineficienta. Din acest motiv nu se vor retine numerele propriu zise, ci doar exponentii factorilor primi ai lui $M$, (numarul maxim de factori primi ai lui fiind aproximat la $O(ln ln M)$, si $9$ pentru datele de test ale problemei) care se vor actualiza pentru fiecare combinare procesata.\r\nComplexitatea finala a algoritmului devine astfel $O(N * ln ln M)$.\r\n\r\nh2. Amenzi\r\n\r\nh3. (clasele 11-12)\r\n\r\nProblema se poate rezolva folosind metoda programarii dinamice. Se construieste matricea $A{~t,i~}$ in care se retine valoarea totala a amenzilor ce poate fi data pana la momentul $t$ astfel incat la momentul $t$ sa fim in intersectia {$i$}. Pentru toate muchiile ({$j,i$}) de cost $c$ vom compara {$A{~t,i~}$} cu {$A{~t-c,j~}$} alegand maximul dintre aceste valori. De fapt ar trebui inspectate toate valorile {$A{~t-c,j~}$} {$A{~t-c-1,j~}$} ... {$A{~1,j~}$} {$A{~0,j~}$} dar este clar ca maximul acestor valori se afla in {$A{~t-c,j~}$}. Deasemenea trebuie considerat cazul cand politistul sta pe loc deci ne vom uita si la valoarea din {$A{~t-1,i~}$}. Apoi politistul va da toate amenzile posibile la momentul respectiv in intersectia respectiva deci vom aduna respectiva suma la {$A{~t,i~}$}.\r\nAvand construita aceasta matrice se poate raspunde in $O(1)$ la fiecare intrebare.\r\nComplexitatea totala va fi $O(Tmax * M)$ ca timp si $O( Tmax * N )$ ca memorie. \r\n\r\nh2. Secventa 5\r\n\r\nh3. (clasele 11-12)\r\n\r\n...\r\n',48,'private'),('unirea-2007','Unirea 2007','2007-01-27 15:39:51','(htabs)*(active) \'*Home*\':unirea-2007\r\n* \'Clasele IX-X\':unirea-2007/clasele-9-10\r\n* \'Clasele XI-XII\':unirea-2007/clasele-11-12\r\n* \'Rezultate\':unirea-2007/rezultate-9-10\r\n\r\nh1. Unirea 2007\r\n\r\nCa parte din cadrul manifestarilor _Zilele Unirii_, infoarena gazduieste un concurs de informatica online - *cu premii si diplome* - la care sunt invitati elevi din toata tara.\r\n\r\nConcursul incepe *Sambata, 27 ianuarie la ora 14^00^* si dureaza *3h*.\r\n\r\np{color:red}. *ATENTIE!* Pentru a participa la acest concurs, trebuie sa te inscrii inainte de ora 14^00^, 27 ian. la grupa de varsta corespunzatoare! Nu pot participa elevii care nu se inscriu la grupa lor de varsta inainte de ora 14^00^, 27 ian.\r\n\r\nInscrierea se face printr-un simplu click. Nu trebuie sa te inregistrezi din nou pe site!\r\n\r\nh2. Alege-ti grupa de varsta\r\n\r\n* \'*Clasele IX si X*\':unirea-2007/clasele-9-10\r\n* \'*Clasele XI si XII*\':unirea-2007/clasele-11-12\r\n\r\nh2. Despre Unirea 2007\r\n\r\nIn perioada 26 - 28 ianuarie 2007, Colegiul National Unirea, Primaria Focsani, Inspectoratul Scolar Vrancea si Microsoft Romania organizeaza, in cadrul manifestarilor _Zilele Unirii_, intalnirea cu tema Resurse IT&amp;C in educatie.\r\n\r\nCele doua zile dedicate acestei intalniri vor cuprinde:\r\n\r\n* concurs online de informatica gazduit de infoarena.ro\r\n* concurs de proiecte realizate de elevi in domeniile: pagini web, software educational &amp; utilitar, multimedia\r\n* concurs de matematica\r\n\r\n&rarr; \'Vezi pagina oficiala a acestei manifestari\':http://unirea.lufo.ro/\r\n\r\nh2. Cum particip?\r\n\r\nInainte de toate trebuie sa \'te inregistrezi\':register pe site-ul nostru.\r\n\r\nOricine este invitat sa participe. In ziua de concurs intri pe site, citesti probleme, le rezolvi si trimiti solutiile inainte de expirarea timpului de lucru. La sfarsitul rundei, \'evaluatorul\':evaluator infoarena iti va testa solutiile pentru corectitudine. Clasamentul se va actualiza in timp real pe parcursul evaluarii.\r\n\r\nh2. Prima data pe infoarena?\r\n\r\ninfoarena ajuta elevi si studenti sa devina excelenti in informatica! Gratuit ;) \'Citeste mai multe\':despre-infoarena despre noi.\r\n\r\nVezi \'ghidul utilizatorului\':documentatie/pentru-utilizatori.\r\n',13,'protected'),('concursuri','Concursuri','2007-01-20 22:34:13','h1. Concursuri\r\n\r\nIn aproape 3 ani de activitate, infoarena a organizat cateva zeci de concursuri/runde online.\r\n\r\nFiecare concurs are un format aparte. De la o runda la cinci, de la cateva ore la cateva zile sau chiar o saptamana, de la cateva probleme la 20, concursurile infoarena variaza in amploare, dificultate si popularitate.\r\n\r\n\r\nh2. Seria preONI\r\n\r\nConcursul _de marca_ infoarena se organizeaza anual si pregateste elevii pentru \"Olimpiada Nationala de Informatica\":http://olimpiada.info/. Este cel mai popular concurs al nostru.\r\n\r\nh3. \'preONI 2007\':preoni-2007 (In desfasurare!)\r\n\r\n* *{\'Runda 1\':preoni-2007/runda-1}* \r\n* Runda 2\r\n* Runda 3\r\n* Runda 4\r\n* Finala\r\n\r\nh3. preONI 2006 (\'pagina concursului\':preoni-2006)\r\n\r\nA 3-a editie a concursului preONI (editia din 2006), primii 10 calificati de la fiecare grupa au participat intr-o finala on-site in Focsani, jud. Vrancea. Concursul a fost sponsorizat de ORACLE Romania, IP Devel, C.N. \"Unirea\" Focsani si altii.\r\n\r\n* *{\'Runda 1\':preoni-2006/runda-1}*\r\n* *{\'Runda 2\':preoni-2006/runda-2}*\r\n* *{\'Runda 3\':preoni-2006/runda-3}*\r\n* *{\'Runda 4\':preoni-2006/runda-4}*\r\n* *{\'Finala in Focsani\':preoni-2006/finala}*\r\n\r\nh3. preONI 2005 (\'pagina concursului\':preoni-2005)\r\n\r\nPrimul concurs preONI cu premii. A fost sponsorizat de Microsoft Romania.\r\n\r\n* *{\'Runda 1\':preoni-2005/runda-1}*\r\n* *{\'Runda 2\':preoni-2005/runda-2}*\r\n* *{\'Runda 3\':preoni-2005/runda-3}*\r\n\r\nh3. preONI 2004 (\'pagina concursului\':preoni-2004)\r\n\r\n* *{\'Runda 1\':preoni-2004/runda-1}*\r\n* *{\'Runda 2\':preoni-2004/runda-2}*\r\n\r\nh2. Happy Coding\r\n\r\nUn concurs infoarena mai neobisnuit. _Happy Coding inseamna programare cu zambetul pe buze, placere si distractie pura!_\r\n\r\nConcursurile Happy Coding dispun de evaluator live si au timp de lucru lejer. Nu vei mai fi stresat de pana la aflarea rezultatelor. Afli pe loc daca solutiile tale sunt bune. In plus, poti lucra si ziua si noaptea, dupa sau in timpul orelor de scoala.\r\n\r\n* *{\'Happy coding 1 (2005)\':happy-coding-2005-1}*\r\n* *{\'Happy coding 2\':happy-coding-2005-2}*\r\n* *{\'Happy coding 3 (2006)\':happy-coding-2006}*\r\n\r\nh2. Summer Challenge\r\n\r\nO serie noua de concursuri infoarena. Acestea se organizeaza in timpul vacantei de vara pentru cei care nu vor _sa-si iasa din mana_. :)\r\n\r\n* *{\'Summer challenge 1\':summer-challenge-unu}*\r\n* *{\'Summer challenge 2\':summer-challenge-2}*\r\n* *{\'Summer challenge 3\':summer-challenge-3}*\r\n\r\nh2. Alte concursuri infoarena\r\n\r\n* *{\'Concurs de incalzire\':warm-up-2004}*\r\n* *{\'preOJI 2004\':preoji-2004}*\r\n* *{\'Bursele agora, editia 6, finala online\':agora-finala}*\r\n* *{\'Autumn warmUp 2006\':warm-up-2006}*\r\n* *{\'Grigore Moisil By Net 2006\':moisil-by-net-2006}*\r\n* *{\'Bacalaureat 2005\':bacalaureat-2005}* \r\n',1,'protected');
/*!40000 ALTER TABLE `ia_textblock_revision` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_user`
--

DROP TABLE IF EXISTS `ia_user`;
CREATE TABLE `ia_user` (
  `id` int(10) unsigned NOT NULL auto_increment,
  `username` varchar(64) collate latin1_general_ci default NULL,
  `password` varchar(64) collate latin1_general_ci default NULL,
  `email` varchar(64) collate latin1_general_ci default NULL,
  `full_name` varchar(64) collate latin1_general_ci default NULL,
  `security_level` enum('normal','admin','helper') collate latin1_general_ci NOT NULL default 'normal',
  `newsletter` tinyint(1) NOT NULL default '1',
  `rating_cache` decimal(11,4) NOT NULL,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `username` (`username`),
  KEY `rating_cache` (`rating_cache`),
  KEY `rating_cache_2` (`rating_cache`)
) ENGINE=MyISAM AUTO_INCREMENT=5888 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci COMMENT='User information here - needs grad year, more optional stuff';

--
-- Dumping data for table `ia_user`
--

LOCK TABLES `ia_user` WRITE;
/*!40000 ALTER TABLE `ia_user` DISABLE KEYS */;
INSERT INTO `ia_user` VALUES (1,'domino','6bd0a33ee98c8bf6aed56c6fe710002bde6048b3','domino@example.com','Mircea Pasoi','admin',1,'2022.7086'),(13,'wickedman','63e05201f16771dd6d4694b502a4fb0dbdac0780','wickedman@example.com','Cristian George Strat','admin',1,'1760.1443'),(15,'silviug','9678b7723d81d9a0eab85832847123c6cfc0dda4','silviug@example.com','Silviu Ganceanu','admin',1,'0.0000'),(18,'azotlichid','c2e30bcb9a5615e5934d178c6fd7ebc15ac54006','azotlichid@example.com','Adrian Vladu','admin',1,'1893.0300'),(48,'danielp','da35f7052906a790a80177483e34a86f358fa609','danielp@example.com','Daniel Pasaila','admin',1,'1616.5849'),(58,'Cosmin','95ddb1caf1d978e1cce9074bb1affbea2dcb7421','Cosmin@example.com','Cosmin','admin',1,'1703.7924'),(66,'greco','aaf53667e069463f8c21f09642e068e526cad665','greco@example.com','Florea Tiberiu','admin',1,'1859.2661'),(75,'svalentin','dfdfb51287c0b7472c0c501394f0440f9dcf14c9','svalentin@example.com','Valentin Stanciu','admin',1,'1664.0691'),(76,'tbog','d3cd3f696e3ecf520fb39d5b4e59a6712a1150f7','tbog@example.com','Tautu Bogdan','normal',1,'1459.1444'),(93,'ira','091ff1ded7c806baf5c2a40b467a19c4e1123b01','ira@example.com','Irina Stanescu','normal',1,'1589.5525'),(142,'snaked31','29cd62e2c753f2284315fd1bd9f14afcf3b9a6d9','snaked31@example.com','Stanica Andrei','normal',1,'1686.1941'),(201,'vali','8d86036107b9bb02eb7c1c7bc14247decec382c6','vali@example.com','Dobrota Valentin','normal',1,'0.0000'),(205,'e_udrea','6b5130f8d7fbc134b85f03ab394a83dc343de0d9','e_udrea@example.com','Udrea Emanuel','normal',1,'0.0000'),(256,'filipb','811bbf59e81ca6425274da0ef63e29dffd48d9a1','filipb@example.com','Buruiana Filip Cristian','admin',1,'1758.8933'),(453,'monica','01d9da958624831fc6ed0d5da058fd22aa55a1a4','monica@example.com','Bercea Monica','normal',1,'0.0000'),(630,'hitandyrun','1dc20dd4d48f951e379ad75f4ac6e8c02b4fed25','hitandyrun@example.com','Andrei Baltuta','normal',1,'0.0000'),(666,'mirela lazar','ebe98599b5ddfd810cf7682b75a8985ab883549a','mirela lazar@example.com','lazar mirela claudia','normal',1,'0.0000'),(951,'domnina','1f219c282048034fd6b42cb2b1b499f13ed9fe52','domnina@example.com','ioana cristescu','normal',0,'0.0000'),(961,'DITzoneC','bd0c869fdf51f004a547ad0a1a002be83c677b52','DITzoneC@example.com','Adrian Diaconu','admin',1,'1772.6442'),(970,'MrMagic','d9d7eddfe7a0719a062dd9f2fe574c9b7dc01dbd','MrMagic@example.com','Gabriel Rizuc','normal',1,'1634.2620'),(1024,'Tabara','9639c299c429eaeb1c3df24e38690246aec5ca04','Tabara@example.com','Tabara Mihai','normal',1,'1460.0799'),(1137,'Gaby','8360fb0079926132bcb207385774da4a8ee33378','Gaby@example.com','Bratu Gabriel','normal',1,'0.0000'),(1142,'fluffy','7b1045aac728fec00a86a68aba993d6d85a74529','fluffy@example.com','Crestez Dan-Leonard','admin',1,'1606.6233'),(1164,'hda','571c45b87bd96a3ecef57ce5914f14cfd35fddf5','hda@example.com','laura','normal',1,'0.0000'),(1287,'bogdang1723','8c6653aeba7243a866886fcaf8cbe73664914883','bogdang1723@example.com','Gurau Bogdan','normal',1,'1435.9974'),(1325,'littleman','461d547d7c4a30c5e21f5013d25701b2b9ebd962','littleman@example.com','Petrovan Bogdan','normal',1,'0.0000'),(1343,'expertu','f70261eea90ea29f0625695b5e8b78cb1fcca5b6','expertu@example.com','Cristian Mezei','normal',0,'0.0000'),(1501,'misha','d5df58fbe05dee2569ce09a637ba679c12046763','misha@example.com','Flutur Mihaela','normal',1,'0.0000'),(1503,'george126','f5a1b70ea2b39897b164d9603cc10ec1efff39be','george126@example.com','Rata Ioan George','normal',1,'1408.8107'),(1631,'roberto','b15052dcc0ad77eed4e370b5e87b1bb08b2452ad','roberto@example.com','Roberto Carlos','normal',1,'0.0000'),(1636,'_cont_','7516a713098f2bfd2a3b3c6c1cc6ee091487cc17','_cont_@example.com','sese','normal',1,'0.0000'),(1666,'Drroty','93545aa0dae2ba5788a11bfafdfde7de2d484ab6','Drroty@example.com','Adi Drotar','normal',0,'0.0000'),(1670,'DianaH','87f28f7a629d44d91bb09f58ef437eece3c7457a','DianaH@example.com','Hodea Diana','normal',1,'0.0000'),(1689,'szaki','6f60959e58f7ac643aee1f9b5b494dbd4ccd9093','szaki@example.com','Stefan Szakats','normal',1,'1497.5444'),(1696,'vax187','83bfcfcca661287ce0724ac21afb18097e5752ff','vax187@example.com','Corciova Cristin','normal',1,'1439.5625'),(1779,'xlf','76143f60f3965d72112938822c957ab54e845520','xlf@example.com','Eftimie Alexandru','normal',0,'0.0000'),(1935,'_darlene_','2bb13ef4f081a8573e9f8857aefb894927673f80','_darlene_@example.com','popa roxana','normal',1,'0.0000'),(1967,'K_ionutz','042ef18e2684bfbe9bd16d7deec1cc9c4497d143','K_ionutz@example.com','Bostan Ionut','normal',1,'0.0000'),(1975,'slayerdme','acf0d9ecebb8abac6e9c9cbe12ec31d6c9fa28c7','slayerdme@example.com','Mihai Dumitrescu','normal',1,'1495.9721'),(2029,'ltugmaria','bc73f2d4b90b29299b2339c4e46ff203c9c58054','ltugmaria@example.com','Maria Voicu','normal',1,'0.0000'),(2092,'astronomy','b796ebf62bc3cfea237ef0eb21e77051f436f3bb','astronomy@example.com','Airinei Adrian','normal',1,'1838.0802'),(2180,'tudorel','824634bf3c0fe9c0263f9880b53e04e636d0bbb1','tudorel@example.com','Tudor Curelaru','normal',1,'0.0000'),(2186,'sarge','44452dff19b2cbb4ad15b67ec5b5a0f5ebda9d67','sarge@example.com','Domide Sergiu','normal',0,'0.0000'),(2256,'ionelya15','67434699fee90a6d3d41c56f188d4570bb6cea61','ionelya15@example.com','pop laura ionelia','normal',1,'0.0000'),(2311,'dandreica','21976dc71301d779efaa45ad2c7f36953ee82ef3','dandreica@example.com','andreica dumitru','normal',1,'0.0000'),(2315,'bacinfo2005','572e339e4d639c8bb0b7e17db7dcddbb39e9d501','bacinfo2005@example.com','Sofica Dan Adrian','normal',0,'0.0000'),(2377,'veleavlad','f4d11097e2267eacd59469ee28b7248e3dee22e7','veleavlad@example.com','Velea Vlad','normal',1,'0.0000'),(2455,'alinutzu_vip','7b917b8fbead28ef18a8a81b38fe4ce3fec06c34','alinutzu_vip@example.com','Constantin Alin Daniel','normal',1,'0.0000'),(2511,'aln','ded2ede8d328e7086364898b8713eeed067af9ec','aln@example.com','aln dra','normal',1,'0.0000'),(2524,'sims_gl','49a75456a54783f50575b2121358e8a58b234d3f','sims_gl@example.com','Alexandru Simion','normal',1,'1927.9188'),(2537,'sdmagor','959836f88e702d6fad1c9160b35b0eccbebc5a8f','sdmagor@example.com','Sch. Dukasz Magor','normal',0,'0.0000'),(2546,'cioryboy','c4a2d0dacf3c5f5327d9b8a1a8c80df43b079103','cioryboy@example.com','CIORANU','normal',1,'0.0000'),(2580,'brenda','318705c55da0840f1063f321ec0739ef027dbbfc','brenda@example.com','brenda','normal',1,'0.0000'),(2631,'adrian_006','9727f683ae4afd67afb1fcb32a56c012b1898708','adrian_006@example.com','diaconu','normal',0,'0.0000'),(2794,'adinachiv','377986fd29ab4de6b3336fc4d6fec94d9010b932','adinachiv@example.com','Adina Paraschiv','normal',1,'0.0000'),(2807,'clau12345','09e7f505754705d39bcb2b15a43e4a1db4ff4019','clau12345@example.com','clau','normal',1,'0.0000'),(2928,'ana724','4606e3da59138da67cc9f2794af1161df3b35587','ana724@example.com','DAN ALEXANDRESCU','normal',0,'0.0000'),(2986,'marius_902002','f781e86f4ece9605f6f5c5f8faa280a9b66e182b','marius_902002@example.com','Cocis Marius Gabriel','normal',0,'1440.0425'),(3044,'POPMAR72','075073808f37bd3a9b7b5dcb1586f95f157e4b8d','POPMAR72@example.com','POPES MAR','normal',1,'0.0000'),(3095,'victor_onaga','0f93db5c0819e7d8a66b722a4292594273faea9b','victor_onaga@example.com','Victor Onaga','normal',0,'0.0000'),(3257,'BogdanBl','82444a066900c9a1198df737fa500d3a672b3ea5','BogdanBl@example.com','Blaga Bogdan','normal',1,'0.0000'),(3280,'dragosh','8992c6af6b9931bb97f63622abc5ddf6924a92f8','dragosh@example.com','vasilcanu','normal',1,'0.0000'),(3353,'Skynet','a4f68d3c5200951a6d730fc9f19972b603337497','Skynet@example.com','Marian Ciortea','normal',1,'0.0000'),(3369,'Alexxxx','b806b9bb5321f36481b215d7e5893e46206ea809','Alexxxx@example.com','Eh...','normal',1,'1471.5524'),(3403,'ursusevastian','4ae223c075690a1920137a58e4fd6c3510c67d8c','ursusevastian@example.com','ursu sevastian','normal',1,'0.0000'),(3467,'faxmodem','536fbb8912f15d81cfd072d1f58831362bec5278','faxmodem@example.com','Razvan Coman','normal',1,'0.0000'),(3481,'filipman','04af9f4c1df0026397f770292f6481d608797c27','filipman@example.com','n-am nume','normal',0,'0.0000'),(3883,'smi','730d3e142b507c6b977d9e94d17c01d122506376','smi@example.com','Simi','normal',1,'0.0000'),(3935,'daysleeper','11666aa401e8f49ec4606f196b9176f2a03990bc','daysleeper@example.com','Radu Ciurlea','normal',1,'0.0000'),(3959,'bmihai','e457cba182bb7946fb744797833aca36a9dbf026','bmihai@example.com','Baba Sebastian Mihai','normal',1,'0.0000'),(3968,'denis','c6ce6834c2430b5189ce2798ae8909fc016bef12','denis@example.com','Cozman Denis','normal',1,'0.0000'),(4030,'adrienne','0c35e22a38be147b769a8aa0b3dca3faf6bb5a6d','adrienne@example.com','Garfileld Adrienne','normal',1,'0.0000'),(4049,'redskirt','ea8e3fc62c66966b270f64d1b6460e0b5beec14d','redskirt@example.com','Joe Black','normal',1,'0.0000'),(4115,'lrazvan','1495241efefbc61226c7147cbe4a2c2e6a9a0207','lrazvan@example.com','Lica Razvan','normal',0,'0.0000'),(4140,'irina_marincas','2159566118b8df2aea1cf3fd783c82a35873aeb9','irina_marincas@example.com','irina marincas','normal',0,'0.0000'),(4159,'Febra_OJI','60a9ab05fdbd218d9c28d3225feff7b22e84ef72','Febra_OJI@example.com','caut antidot pentru febra','normal',0,'0.0000'),(4197,'testall','14502895092e0c0cc14590268713f58586175c8e','testall@example.com','MARIAN','normal',1,'0.0000'),(4313,'nicol','196a3df5e04a56015420a9c6f53250f38a6bbbf1','nicol@example.com','hadryanys','normal',1,'0.0000'),(4318,'moraru','1ba340a12d7872cab0bc588fc8e38151258c6bd2','moraru@example.com','moraru ionut','normal',1,'0.0000'),(4340,'Villy_the_first','cc508f1c7f0a7ae9f46a58d91dd1b9b3a3b1ca06','Villy_the_first@example.com','Varlan Daniel','normal',0,'0.0000'),(4351,'moldi','393569aa417422c8c9c03546ff12cae534d7bd31','moldi@example.com','Moldovan Andrei','normal',1,'0.0000'),(4357,'Pleasure','91866f97b0f5b37095ddda5825eee84bdbb4c3f5','Pleasure@example.com','Downward Spiral','normal',0,'0.0000'),(4429,'tudor_tudy','0e3dc1e1296831427217f5d848b50697a90ac58a','tudor_tudy@example.com','Mihuta Tudor','normal',1,'0.0000'),(4481,'vinete','20cf664c14826c67725f90d8f69e4b466a87dfb5','vinete@example.com','budau tiberiu','normal',1,'0.0000'),(4663,'eta_trial','3987c06a19ed8e76a33f9dd966ed158080ff2b97','eta_trial@example.com','Colac Alexandru','normal',1,'0.0000'),(4681,'voronoi','f120069ac28c903c8295739052a0f43c3fda92a0','voronoi@example.com','Costin Radu','normal',1,'0.0000'),(4764,'stancovz','f091d349e07aa8b95d9ad63f6301589f09833724','stancovz@example.com','Stankov Zeljko','normal',1,'0.0000'),(5040,'cristinutza_g1989','28a032d519ee3629929ed4e08a7a065be23b68fb','cristinutza_g1989@example.com','Goicea Cristina','normal',1,'0.0000'),(5083,'madutza','508876496a936aa1dc724ab91bd1b8024de90cbb','madutza@example.com','Anton Madalina','normal',1,'0.0000'),(5147,'Ivanescu_miruna','f0206af2eb597560d1e4eebb8c767cbc70b4128f','Ivanescu_miruna@example.com','Ivanescu Miruna','normal',1,'0.0000'),(5237,'yourlove','db0d671288660992c437caed094dd2cd265e5183','yourlove@example.com','anghelache andreea','normal',1,'0.0000'),(5252,'iuliavls','9394221f5207163ba15877e1fd958c705ce839a8','iuliavls@example.com','iulia vlasceanu','normal',1,'0.0000'),(5292,'hajek_hajni','51162492aa56c7586b3cbfb66f4eba37ed053aa5','hajek_hajni@example.com','hajek hajnalka','normal',1,'1482.0011'),(5383,'jsin','5619141d385331cc1e0ad9199d6f1dff29edaffa','jsin@example.com','Joe Sinapsa','normal',0,'0.0000'),(5392,'eval','99f84d9f2e99cba220e37d9e293f295da6e5c3f4','eval@example.com','Evaluatorul infoarena','admin',0,'0.0000'),(5425,'meREMY','e8bf95439de5eaf21372936d967bad9d7edd03e0','meREMY@example.com','Marinescu Remus','normal',1,'0.0000'),(5474,'tanasefl0rin9','b161fa228675cad15dbb468ebaa9152ea6fa4b1d','tanasefl0rin9@example.com','tanaseflorin','normal',1,'0.0000'),(5586,'anchidinraluca','c02fcb7fc00320c2e52c03c062cf1a28250f203e','anchidinraluca@example.com','anchidin raluca florentina','normal',1,'0.0000'),(5695,'vali_mi','c45b2d6f5ec1260b1005be549cbc39d09cc72126','vali_mi@example.com','Mihai Valentin','normal',1,'0.0000'),(5855,'birsan','451b7fd27d9e6dc26163cebc46cf16dfe56b2e3e','birsan@example.com','Andrei Birsan','normal',1,'1431.0333');
/*!40000 ALTER TABLE `ia_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ia_user_round`
--

DROP TABLE IF EXISTS `ia_user_round`;
CREATE TABLE `ia_user_round` (
  `user_id` int(11) NOT NULL,
  `round_id` varchar(64) collate latin1_general_ci NOT NULL default '',
  PRIMARY KEY  (`round_id`,`user_id`),
  KEY `user_id` (`user_id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;

--
-- Dumping data for table `ia_user_round`
--

LOCK TABLES `ia_user_round` WRITE;
/*!40000 ALTER TABLE `ia_user_round` DISABLE KEYS */;
INSERT INTO `ia_user_round` VALUES (117,'preoni2007_runda1_10'),(142,'preoni2007_runda1_10'),(155,'preoni2007_runda1_10'),(468,'preoni2007_runda1_10'),(477,'preoni2007_runda1_10'),(602,'preoni2007_runda1_10'),(641,'preoni2007_runda1_10'),(909,'preoni2007_runda1_10'),(954,'preoni2007_runda1_10'),(996,'preoni2007_runda1_10'),(2038,'preoni2007_runda1_10'),(2072,'preoni2007_runda1_10'),(2986,'preoni2007_runda1_10'),(2993,'preoni2007_runda1_10'),(3065,'preoni2007_runda1_10'),(3077,'preoni2007_runda1_10'),(3117,'preoni2007_runda1_10'),(3163,'preoni2007_runda1_10'),(3219,'preoni2007_runda1_10'),(3269,'preoni2007_runda1_10'),(3270,'preoni2007_runda1_10'),(3440,'preoni2007_runda1_10'),(3504,'preoni2007_runda1_10'),(3542,'preoni2007_runda1_10'),(3587,'preoni2007_runda1_10'),(3680,'preoni2007_runda1_10'),(3829,'preoni2007_runda1_10'),(3946,'preoni2007_runda1_10'),(4274,'preoni2007_runda1_10'),(4297,'preoni2007_runda1_10'),(4308,'preoni2007_runda1_10'),(4437,'preoni2007_runda1_10'),(4439,'preoni2007_runda1_10'),(4452,'preoni2007_runda1_10'),(4539,'preoni2007_runda1_10'),(4547,'preoni2007_runda1_10'),(4772,'preoni2007_runda1_10'),(4806,'preoni2007_runda1_10'),(4813,'preoni2007_runda1_10'),(4948,'preoni2007_runda1_10'),(4986,'preoni2007_runda1_10'),(5064,'preoni2007_runda1_10'),(5465,'preoni2007_runda1_10'),(5503,'preoni2007_runda1_10'),(5511,'preoni2007_runda1_10'),(5653,'preoni2007_runda1_10'),(5675,'preoni2007_runda1_10'),(5681,'preoni2007_runda1_10'),(5693,'preoni2007_runda1_10'),(5694,'preoni2007_runda1_10'),(98,'preoni2007_runda1_1112'),(199,'preoni2007_runda1_1112'),(212,'preoni2007_runda1_1112'),(344,'preoni2007_runda1_1112'),(468,'preoni2007_runda1_1112'),(477,'preoni2007_runda1_1112'),(495,'preoni2007_runda1_1112'),(716,'preoni2007_runda1_1112'),(735,'preoni2007_runda1_1112'),(836,'preoni2007_runda1_1112'),(863,'preoni2007_runda1_1112'),(986,'preoni2007_runda1_1112'),(996,'preoni2007_runda1_1112'),(997,'preoni2007_runda1_1112'),(1002,'preoni2007_runda1_1112'),(1021,'preoni2007_runda1_1112'),(1024,'preoni2007_runda1_1112'),(1027,'preoni2007_runda1_1112'),(1070,'preoni2007_runda1_1112'),(1189,'preoni2007_runda1_1112'),(1204,'preoni2007_runda1_1112'),(1231,'preoni2007_runda1_1112'),(1242,'preoni2007_runda1_1112'),(1255,'preoni2007_runda1_1112'),(1306,'preoni2007_runda1_1112'),(1320,'preoni2007_runda1_1112'),(1451,'preoni2007_runda1_1112'),(1459,'preoni2007_runda1_1112'),(1476,'preoni2007_runda1_1112'),(1541,'preoni2007_runda1_1112'),(1565,'preoni2007_runda1_1112'),(1573,'preoni2007_runda1_1112'),(1576,'preoni2007_runda1_1112'),(1611,'preoni2007_runda1_1112'),(1621,'preoni2007_runda1_1112'),(1782,'preoni2007_runda1_1112'),(1792,'preoni2007_runda1_1112'),(1806,'preoni2007_runda1_1112'),(1836,'preoni2007_runda1_1112'),(1851,'preoni2007_runda1_1112'),(1931,'preoni2007_runda1_1112'),(2006,'preoni2007_runda1_1112'),(2013,'preoni2007_runda1_1112'),(2028,'preoni2007_runda1_1112'),(2037,'preoni2007_runda1_1112'),(2044,'preoni2007_runda1_1112'),(2072,'preoni2007_runda1_1112'),(2086,'preoni2007_runda1_1112'),(2090,'preoni2007_runda1_1112'),(2092,'preoni2007_runda1_1112'),(2127,'preoni2007_runda1_1112'),(2145,'preoni2007_runda1_1112'),(2524,'preoni2007_runda1_1112'),(2929,'preoni2007_runda1_1112'),(2962,'preoni2007_runda1_1112'),(3062,'preoni2007_runda1_1112'),(3063,'preoni2007_runda1_1112'),(3066,'preoni2007_runda1_1112'),(3141,'preoni2007_runda1_1112'),(3146,'preoni2007_runda1_1112'),(3165,'preoni2007_runda1_1112'),(3333,'preoni2007_runda1_1112'),(3430,'preoni2007_runda1_1112'),(3455,'preoni2007_runda1_1112'),(3548,'preoni2007_runda1_1112'),(3632,'preoni2007_runda1_1112'),(4137,'preoni2007_runda1_1112'),(4148,'preoni2007_runda1_1112'),(4239,'preoni2007_runda1_1112'),(4247,'preoni2007_runda1_1112'),(4309,'preoni2007_runda1_1112'),(4509,'preoni2007_runda1_1112'),(4568,'preoni2007_runda1_1112'),(4613,'preoni2007_runda1_1112'),(4772,'preoni2007_runda1_1112'),(4798,'preoni2007_runda1_1112'),(4805,'preoni2007_runda1_1112'),(4922,'preoni2007_runda1_1112'),(4996,'preoni2007_runda1_1112'),(5373,'preoni2007_runda1_1112'),(5415,'preoni2007_runda1_1112'),(5504,'preoni2007_runda1_1112'),(5512,'preoni2007_runda1_1112'),(5698,'preoni2007_runda1_1112'),(603,'preoni2007_runda1_9'),(996,'preoni2007_runda1_9'),(1430,'preoni2007_runda1_9'),(1490,'preoni2007_runda1_9'),(1507,'preoni2007_runda1_9'),(1976,'preoni2007_runda1_9'),(2070,'preoni2007_runda1_9'),(2071,'preoni2007_runda1_9'),(2072,'preoni2007_runda1_9'),(2934,'preoni2007_runda1_9'),(2963,'preoni2007_runda1_9'),(3036,'preoni2007_runda1_9'),(3057,'preoni2007_runda1_9'),(3593,'preoni2007_runda1_9'),(3888,'preoni2007_runda1_9'),(3904,'preoni2007_runda1_9'),(4234,'preoni2007_runda1_9'),(4274,'preoni2007_runda1_9'),(4359,'preoni2007_runda1_9'),(4371,'preoni2007_runda1_9'),(4374,'preoni2007_runda1_9'),(4772,'preoni2007_runda1_9'),(4863,'preoni2007_runda1_9'),(4984,'preoni2007_runda1_9'),(4986,'preoni2007_runda1_9'),(5016,'preoni2007_runda1_9'),(5067,'preoni2007_runda1_9'),(5097,'preoni2007_runda1_9'),(5250,'preoni2007_runda1_9'),(5465,'preoni2007_runda1_9'),(5511,'preoni2007_runda1_9'),(5573,'preoni2007_runda1_9'),(5612,'preoni2007_runda1_9'),(5661,'preoni2007_runda1_9'),(5664,'preoni2007_runda1_9'),(5673,'preoni2007_runda1_9'),(3,'unirea11-12'),(75,'unirea11-12'),(98,'unirea11-12'),(115,'unirea11-12'),(117,'unirea11-12'),(314,'unirea11-12'),(332,'unirea11-12'),(344,'unirea11-12'),(354,'unirea11-12'),(362,'unirea11-12'),(393,'unirea11-12'),(445,'unirea11-12'),(475,'unirea11-12'),(477,'unirea11-12'),(495,'unirea11-12'),(648,'unirea11-12'),(716,'unirea11-12'),(735,'unirea11-12'),(874,'unirea11-12'),(878,'unirea11-12'),(947,'unirea11-12'),(962,'unirea11-12'),(986,'unirea11-12'),(996,'unirea11-12'),(1002,'unirea11-12'),(1021,'unirea11-12'),(1024,'unirea11-12'),(1027,'unirea11-12'),(1059,'unirea11-12'),(1070,'unirea11-12'),(1072,'unirea11-12'),(1091,'unirea11-12'),(1189,'unirea11-12'),(1196,'unirea11-12'),(1197,'unirea11-12'),(1204,'unirea11-12'),(1224,'unirea11-12'),(1231,'unirea11-12'),(1242,'unirea11-12'),(1306,'unirea11-12'),(1451,'unirea11-12'),(1459,'unirea11-12'),(1476,'unirea11-12'),(1495,'unirea11-12'),(1503,'unirea11-12'),(1541,'unirea11-12'),(1565,'unirea11-12'),(1576,'unirea11-12'),(1582,'unirea11-12'),(1611,'unirea11-12'),(1617,'unirea11-12'),(1621,'unirea11-12'),(1689,'unirea11-12'),(1730,'unirea11-12'),(1792,'unirea11-12'),(1806,'unirea11-12'),(1836,'unirea11-12'),(1851,'unirea11-12'),(1852,'unirea11-12'),(1880,'unirea11-12'),(2013,'unirea11-12'),(2022,'unirea11-12'),(2028,'unirea11-12'),(2044,'unirea11-12'),(2086,'unirea11-12'),(2090,'unirea11-12'),(2092,'unirea11-12'),(2127,'unirea11-12'),(2140,'unirea11-12'),(2145,'unirea11-12'),(2524,'unirea11-12'),(2567,'unirea11-12'),(2929,'unirea11-12'),(2960,'unirea11-12'),(2961,'unirea11-12'),(2970,'unirea11-12'),(3059,'unirea11-12'),(3077,'unirea11-12'),(3141,'unirea11-12'),(3146,'unirea11-12'),(3215,'unirea11-12'),(3290,'unirea11-12'),(3311,'unirea11-12'),(3324,'unirea11-12'),(3333,'unirea11-12'),(3401,'unirea11-12'),(3430,'unirea11-12'),(3455,'unirea11-12'),(3483,'unirea11-12'),(3548,'unirea11-12'),(3636,'unirea11-12'),(4064,'unirea11-12'),(4076,'unirea11-12'),(4082,'unirea11-12'),(4087,'unirea11-12'),(4105,'unirea11-12'),(4137,'unirea11-12'),(4148,'unirea11-12'),(4175,'unirea11-12'),(4223,'unirea11-12'),(4239,'unirea11-12'),(4247,'unirea11-12'),(4346,'unirea11-12'),(4428,'unirea11-12'),(4430,'unirea11-12'),(4446,'unirea11-12'),(4447,'unirea11-12'),(4509,'unirea11-12'),(4772,'unirea11-12'),(4779,'unirea11-12'),(4805,'unirea11-12'),(4858,'unirea11-12'),(4900,'unirea11-12'),(4922,'unirea11-12'),(4985,'unirea11-12'),(4995,'unirea11-12'),(4996,'unirea11-12'),(5015,'unirea11-12'),(5089,'unirea11-12'),(5105,'unirea11-12'),(5245,'unirea11-12'),(5292,'unirea11-12'),(5331,'unirea11-12'),(5348,'unirea11-12'),(5373,'unirea11-12'),(5698,'unirea11-12'),(5706,'unirea11-12'),(5711,'unirea11-12'),(5737,'unirea11-12'),(5738,'unirea11-12'),(5754,'unirea11-12'),(5760,'unirea11-12'),(5763,'unirea11-12'),(5764,'unirea11-12'),(5779,'unirea11-12'),(5796,'unirea11-12'),(5805,'unirea11-12'),(5829,'unirea11-12'),(5831,'unirea11-12'),(5836,'unirea11-12'),(5837,'unirea11-12'),(5838,'unirea11-12'),(5841,'unirea11-12'),(5847,'unirea11-12'),(5849,'unirea11-12'),(5860,'unirea11-12'),(142,'unirea9-10'),(155,'unirea9-10'),(259,'unirea9-10'),(445,'unirea9-10'),(477,'unirea9-10'),(602,'unirea9-10'),(603,'unirea9-10'),(641,'unirea9-10'),(735,'unirea9-10'),(909,'unirea9-10'),(954,'unirea9-10'),(996,'unirea9-10'),(1430,'unirea9-10'),(1490,'unirea9-10'),(1507,'unirea9-10'),(1771,'unirea9-10'),(1977,'unirea9-10'),(2022,'unirea9-10'),(2028,'unirea9-10'),(2038,'unirea9-10'),(2070,'unirea9-10'),(2567,'unirea9-10'),(2720,'unirea9-10'),(2934,'unirea9-10'),(2958,'unirea9-10'),(2963,'unirea9-10'),(2985,'unirea9-10'),(2986,'unirea9-10'),(2992,'unirea9-10'),(2993,'unirea9-10'),(3009,'unirea9-10'),(3036,'unirea9-10'),(3057,'unirea9-10'),(3065,'unirea9-10'),(3077,'unirea9-10'),(3084,'unirea9-10'),(3117,'unirea9-10'),(3163,'unirea9-10'),(3173,'unirea9-10'),(3176,'unirea9-10'),(3187,'unirea9-10'),(3219,'unirea9-10'),(3269,'unirea9-10'),(3270,'unirea9-10'),(3379,'unirea9-10'),(3414,'unirea9-10'),(3417,'unirea9-10'),(3440,'unirea9-10'),(3478,'unirea9-10'),(3504,'unirea9-10'),(3540,'unirea9-10'),(3542,'unirea9-10'),(3587,'unirea9-10'),(3593,'unirea9-10'),(3658,'unirea9-10'),(3680,'unirea9-10'),(3687,'unirea9-10'),(3706,'unirea9-10'),(3775,'unirea9-10'),(3888,'unirea9-10'),(3896,'unirea9-10'),(3938,'unirea9-10'),(3946,'unirea9-10'),(3947,'unirea9-10'),(3948,'unirea9-10'),(3966,'unirea9-10'),(4031,'unirea9-10'),(4043,'unirea9-10'),(4082,'unirea9-10'),(4188,'unirea9-10'),(4274,'unirea9-10'),(4297,'unirea9-10'),(4306,'unirea9-10'),(4371,'unirea9-10'),(4374,'unirea9-10'),(4417,'unirea9-10'),(4437,'unirea9-10'),(4439,'unirea9-10'),(4452,'unirea9-10'),(4543,'unirea9-10'),(4547,'unirea9-10'),(4558,'unirea9-10'),(4603,'unirea9-10'),(4734,'unirea9-10'),(4772,'unirea9-10'),(4791,'unirea9-10'),(4792,'unirea9-10'),(4806,'unirea9-10'),(4853,'unirea9-10'),(4859,'unirea9-10'),(4908,'unirea9-10'),(4986,'unirea9-10'),(5003,'unirea9-10'),(5016,'unirea9-10'),(5064,'unirea9-10'),(5067,'unirea9-10'),(5090,'unirea9-10'),(5097,'unirea9-10'),(5101,'unirea9-10'),(5243,'unirea9-10'),(5299,'unirea9-10'),(5334,'unirea9-10'),(5400,'unirea9-10'),(5465,'unirea9-10'),(5511,'unirea9-10'),(5514,'unirea9-10'),(5521,'unirea9-10'),(5596,'unirea9-10'),(5625,'unirea9-10'),(5647,'unirea9-10'),(5649,'unirea9-10'),(5651,'unirea9-10'),(5653,'unirea9-10'),(5664,'unirea9-10'),(5665,'unirea9-10'),(5673,'unirea9-10'),(5692,'unirea9-10'),(5693,'unirea9-10'),(5694,'unirea9-10'),(5714,'unirea9-10'),(5721,'unirea9-10'),(5728,'unirea9-10'),(5729,'unirea9-10'),(5732,'unirea9-10'),(5734,'unirea9-10'),(5735,'unirea9-10'),(5736,'unirea9-10'),(5742,'unirea9-10'),(5747,'unirea9-10'),(5748,'unirea9-10'),(5756,'unirea9-10'),(5757,'unirea9-10'),(5758,'unirea9-10'),(5759,'unirea9-10'),(5760,'unirea9-10'),(5761,'unirea9-10'),(5762,'unirea9-10'),(5764,'unirea9-10'),(5766,'unirea9-10'),(5769,'unirea9-10'),(5770,'unirea9-10'),(5771,'unirea9-10'),(5773,'unirea9-10'),(5775,'unirea9-10'),(5778,'unirea9-10'),(5780,'unirea9-10'),(5781,'unirea9-10'),(5782,'unirea9-10'),(5785,'unirea9-10'),(5786,'unirea9-10'),(5787,'unirea9-10'),(5788,'unirea9-10'),(5789,'unirea9-10'),(5790,'unirea9-10'),(5791,'unirea9-10'),(5792,'unirea9-10'),(5793,'unirea9-10'),(5794,'unirea9-10'),(5795,'unirea9-10'),(5797,'unirea9-10'),(5799,'unirea9-10'),(5800,'unirea9-10'),(5801,'unirea9-10'),(5806,'unirea9-10'),(5807,'unirea9-10'),(5808,'unirea9-10'),(5809,'unirea9-10'),(5810,'unirea9-10'),(5813,'unirea9-10'),(5814,'unirea9-10'),(5815,'unirea9-10'),(5816,'unirea9-10'),(5819,'unirea9-10'),(5820,'unirea9-10'),(5822,'unirea9-10'),(5823,'unirea9-10'),(5824,'unirea9-10'),(5825,'unirea9-10'),(5826,'unirea9-10'),(5835,'unirea9-10'),(5839,'unirea9-10'),(5840,'unirea9-10'),(5842,'unirea9-10'),(5843,'unirea9-10'),(5845,'unirea9-10'),(5846,'unirea9-10'),(5848,'unirea9-10'),(5850,'unirea9-10'),(5851,'unirea9-10'),(5853,'unirea9-10'),(5855,'unirea9-10'),(5856,'unirea9-10'),(5857,'unirea9-10'),(5858,'unirea9-10'),(5859,'unirea9-10'),(5862,'unirea9-10');
/*!40000 ALTER TABLE `ia_user_round` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2007-02-14 21:24:57
